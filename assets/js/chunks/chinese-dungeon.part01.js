
			const canvas = document.getElementById("dungeonCanvas");
			const ctx = canvas.getContext("2d");
			let supabase = null;
			let 创意工坊已启用 = false;
			
			async function 初始化创意工坊() {
			    try {
			        if (!window.supabase) {
			            throw new Error("Supabase 客户端库未加载。");
			        }
			        const 创意关卡按钮 = document.getElementById("创意关卡按钮");
			        if (创意关卡按钮) {
			            创意关卡按钮.onclick = 显示创意关卡浏览器;
			        }
			        if (创意关卡文件输入) {
			    创意关卡文件输入.addEventListener("change", (事件) => {
			        const 选择的文件 = 事件.target.files[0];
			        if (!选择的文件) return;
			        const 文件阅读器 = new FileReader();
			        文件阅读器.onload = async (读取事件) => {
			            const 存档字符串 = 读取事件.target.result;
			            if(await 导入创意关卡(存档字符串)) {隐藏游戏模式选择()};
			        };
			        文件阅读器.readAsText(选择的文件);
			        事件.target.value = '';
			    });
			}
			        const supabaseUrl = 'https://xazugujttgmudrtfvwrg.supabase.co';
			        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhhenVndWp0dGdtdWRydGZ2d3JnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI2NzIyNjksImV4cCI6MjA2ODI0ODI2OX0.ycWl0bdX0heyFTm4BJCL-1YpSYZI9uIiDzYwE5rivi4';
			        supabase = window.supabase.createClient(supabaseUrl, supabaseKey); //固若金汤的数据库，坚不可摧的防火墙
			
			        // 验证连接和权限！！！
			        const { error } = await supabase.from('levels').select('id').limit(1);
			        if (error) {
			            throw new Error(`数据库连接测试失败: ${error.message}`);
			        }
			        
			        创意工坊已启用 = true;
			
			
			        document.getElementById('返回游戏模式选择按钮').addEventListener('click', 隐藏创意关卡浏览器);
			        document.getElementById('上传关卡按钮').addEventListener('click', 上传关卡处理函数);
			        document.getElementById('搜索关卡按钮').addEventListener('click', 刷新关卡列表);
			        document.getElementById('搜索关卡输入').addEventListener('keypress', function(e) {
			            if (e.key === 'Enter') {
			                刷新关卡列表();
			            }
			        });
			        document.getElementById('返回浏览器按钮').addEventListener('click', 隐藏关卡详情);
			    } catch (error) {
			        创意工坊已启用 = false;
			        console.warn("创意工坊初始化失败:", error.message);
			        显示通知("创意工坊功能不可用，已切换为本地模式。", "警告");
			        if (创意关卡按钮) {
			            创意关卡按钮.textContent = "加载本地创意关卡";
			            创意关卡按钮.onclick = () => {
			                
			                创意关卡文件输入.click();
			            };
			        }
			    }
			}
			
			// 常量 好吧有些已经变成变量了
			let 单元格大小 = 30;
			let 已初始化 = 2;
			let 画布宽度 = Math.min(
			    window.innerWidth - 20,
			    window.innerHeight - 20
			); // 动态宽度
			let 画布高度 = 画布宽度; // 动态高度
			const 房间尺寸范围 = [7, 10];
			const 最大房间数 = 15;
			let 相机显示边长 = 15;
			const 最大堆叠数 = 64;
			let 地牢大小 = 100;
			const 存档版本 = "v1";
			const 游戏版本 = 1526
			document.querySelector('.info-version-tag').innerHTML=`v${游戏版本}`;
			const 所有天气列表 = [
			    "雷暴",
			    "诡魅",
			    "大风",
			    "严寒",
			    "深夜",
			    "深夜",
			];
			const 大风吹动概率 = 0.3;
			let 互动冷却 = false;
			const 怪物移动动画时长 = 300;
			const 数据完整性密钥 = "f_SECRET_KEY_FOR_CHINESE_DUNGEON";
			
			const 调试序列 = ["上", "上", "下", "下", "左", "右", "左", "右"];
			// 单元格类型枚举
			let 当前层数 = 0;
			let 所有地牢层 = new Map(); // 保存各层地牢数据
			
			const 中文对照图标映射 = {
			    药水: "药",
			    钢制长剑: "剑",
			    吸血剑: "吸",
			    橡木法杖: "法",
			    卷轴: "卷",
			    钥匙: "钥",
			    金币: "金",
			    喷火枪: "喷",
			    回旋镖: "回",
			    闪电链法杖: "链",
			    大地猛击锤: "震",
			    穿云箭: "穿",
			    荆棘鞭: "鞭",
			    能量草: "草",
			    秘银锁甲: "翈",
			    真言卷轴: "视",
			    钢制板甲: "甲",
			    金币手枪: "枪",
			    狙击金币枪: "狙",
			    下楼楼梯: "下",
			    上楼楼梯: "上",
			    怪物: "怪",
			    炸弹怪物: "爆",
			    炸弹: "炸",
			    罐子: "罐",
			    锅盖: "锅",
			    盔甲怪物: "魁",
			    敏捷怪物: "速",
			    远攻怪物: "远",
			    仙人掌怪物: "刺",
			    大魔法师: "师",
			    寻宝戒指: "戒",
			    装备按钮: "装",
			    死亡图标: "☠︎",
			    错误: "✘",
			    成功: "✔",
			    缓慢: "慢",
			    冰冻怪物: "㓕",
			    冰盾: "栤",
			    重铸台: "铸",
			    斜方刀: "斜",
			    神秘商人: "商",
			    探险家: "探",
			    祭坛: "坛",
			    互动按钮: "互",
			    背包按钮: "背",
			    卷轴按钮: "卷",
			    HUD常显: "显",
			    HUD智能: "䚐",
			    HUD常隐: "隐",
			    魔法师法杖: "法",
			    符文圈: "符",
			    水晶: "晶",
			    宠物: "宠",
			    熊猫: "態",
			    水母: "鲝",
			    冰霜法杖: "霜",
			    重力锤: "引",
			    剧毒匕首: "毒",
			    大史莱姆: "大",
			    小史莱姆: "小",
			    瞬移怪物: "瞬",
			    伪装怪物: "伪",
			    腐蚀怪物: "蚀",
			    盗贼怪物: "盗",
			    萨满怪物: "萨",
			    召唤师怪物: "召",
			    幽灵仆从: "仆",
			    吸能怪物: "吸",
			    剧毒云雾怪物: "雾",
			    旋风怪物: "旋",
			    旋风: "風",
			    旋风物品: "风",
			    米诺陶: "㸴",
			    折跃门: "门",
			    传送门: "门",
			    毒液: "毒",
			    眩晕: "晕",
			    火焰: "火",
			    引雷针护符: "引",
			    种子: "种",
			    荆棘丛: "荆",
			    灵能盾牌: "灵",
			    恐惧魔杖: "惧",
			    恐惧怪物: "恐",
			    调试工具: "调",
			    恐惧: "恐",
			    冲撞牛角: "角",
			    护卫植物: "卫",
			    远射植物: "远",
			    泉水: "泉",
			    书架: "书",
			    渔网: "网",
			    充能魔杖: "充",
			    时间卷轴: "时",
			    潜行靴子: "潜",
			    钩索: "钩",
			    嗜血战斧: "斧",
			    渔网陷阱: "网",
			    磨刀石: "磨",
			    急救绷带: "绷",
			    照明弹: "照",
			    照明弹光源: "光",
			    挑战石碑: "碑",
			    神龛: "龛",
			    洗身砚: "砚",
			    毒气瓶: "瓶",
			    万能钥匙: "万",
			    陨石法杖: "星",
			    毒气: "毒",
			    落石: "石",
			    地刺: "刺",
			    失明: "盲",
			    召唤陷阱: "召",
			    烈焰陷阱: "焰",
			    虫洞: "洞",
			    障碍物: "障",
			    远射陷阱: "塔",
			    沙漏: "时",
			    时间:"时",
			    脚印:"迹",
			    爱心: "伤",
			    修补心: "心",
			    旗帜: "旗",
			    门: "门",
			    锁: "锁",
			    手形: "改",
			    删除: "删",
			    房间工具: "创",
			    房间编辑: "修",
			    地板: "房",
			    走廊: "廊",
			    墙壁: "墙",
			    告示牌: "牌",
			    超速怪物: "超",
			    复活怪物: "复",
			    娃娃怪物: "娃",
			    吸血鬼: "血",
			    存档点: "存",
			    皇家守卫:"卫",
			    王座守护者:"王",
			    墓碑:"墓",
			    移动弹幕:"弹",
			    奖杯:"奖",
			    陷阱先锋: '探',
			    飞毛腿: '腿',
			    瞬间移动: '瞬',
			    博士之卷: '博',
			    恢复之心: '愈',
			    以牙还牙: '牙',
			    饰品: '饰',
			    分裂怪物: "裂",
			    巨人怪物: "巨",
			    巨人部位: "巨",
			    红蓝开关:"控",
			    红砖块:"█",
			    蓝砖块:"▓",
			    追踪风弹:"颩",
			    刷怪笼: "笼",
			    传送带: "传",
			    巡逻怪物: "巡",
			    同步怪物: "同",
			    绿砖块: "▓",
			    紫砖块: "▒",
			    绿紫开关: "切",
			    开关脉冲器: "脉",
			    复制工具:'拷',
			    沉浸式传送门:'传',
			    卷轴滚动墙: '停',
			    嗅探之鼻:'鼻',
			    永久抗火:'火',
			    永久解冻:'冻',
			    永久力量:'力',
			    永久抗毒:'毒',
			    神偷手: '偷',
			    小书魔:'书',
			    扫帚: '帚',
			    战士: '战',
			    法师: '法',
			    忍者: '忍',
			    游侠:'侠',
			    死灵:'灵',
			    骑士:'骑',
			    磁铁: "磁",
			    蜘蛛怪物: "蛛",
			    反弹怪物: "反",
			    蛛网: "网",
			    魔法师: "麽",
            火蜥蜴: "蜥",
            烟雾弹: "烟",
            烟雾: "雾",
            蜈蚣怪物:"虫",
            定位器地图:"图",
            死灵法杖: "杖",
            骷髅仆从: "骸",
			};
			let 图标映射 = {
			    药水: "🧪",
			    钢制长剑: "🗡️",
			    橡木法杖: "🪄",
			    吸血剑: "🗡️",
			    喷火枪: "💥",
			    冰霜法杖: "🪄",
			    重力锤: "🔨",
			    剧毒匕首: "🐍",
			    卷轴: "📜",
			    钥匙: "🔑",
			    金币: "🪙",
			    锅盖: "🫕",
			    回旋镖: "🪃",
			    闪电链法杖: "🌩️",
			    大地猛击锤: "🔨",
			    穿云箭: "🏹",
			    荆棘鞭: "⛓️",
			    秘银锁甲: "🥼",
			    真言卷轴: "📖",
			    钢制板甲: "🥋",
			    金币手枪: "🔫",
			    狙击金币枪: "🔫",
			    下楼楼梯: "⬇️",
			    上楼楼梯: "⬆️",
			    怪物: "👾",
			    炸弹怪物: "💣",
			    盔甲怪物: "💂",
			    炸弹: "💣",
			    罐子: "🏺",
			    缓慢: "🐌",
			    敏捷怪物: "🏃",
			    远攻怪物: "👼",
			    仙人掌怪物: "🌵",
			    大魔法师: "🧙",
			    寻宝戒指: "💍",
			    装备按钮: "🛡",
			    死亡图标: "💀",
			    错误: "❌",
			    成功: "✅",
			    冰冻怪物: "🧊",
			    冰盾: "❄",
			    重铸台: "⚒️",
			    斜方刀: "💠",
			    神秘商人: "🧙",
			    探险家: "👨‍🌾",
			    祭坛: "🛐",
			    互动按钮: "⚡",
			    背包按钮: "🎒",
			    卷轴按钮: "📜",
			    HUD常显: "👀",
			    HUD智能: "👁️",
			    HUD常隐: "😑",
			    宠物: "🐾",
			    熊猫: "🐼",
			    水母: "🪼",
			    大史莱姆: "🦠",
			    小史莱姆: "🦠",
			    瞬移怪物: "💫",
			    伪装怪物: "👿",
			    腐蚀怪物: "👹",
			    盗贼怪物: "🥷",
			    萨满怪物: "⚕️",
			    召唤师怪物: "🧿",
			    幽灵仆从: "👻",
			    吸能怪物: "😈",
			    剧毒云雾怪物: "☁️",
			    旋风怪物: "🌪️",
			    米诺陶: "🐂",
			    折跃门: "🍥",
			    传送门: "🚪",
			    魔法师法杖: "🔱",
			    符文圈: "⭕",
			    水晶: "💎",
			    毒液: "☢️",
			    能量草: "🌿",
			    旋风: "🌀",
			    旋风物品: "🍃",
			    眩晕: "💫",
			    火焰: "🔥",
			    引雷针护符: "🗼",
			    种子: "🌱",
			    荆棘丛: "🌵",
			    灵能盾牌: "🛡️",
			    恐惧魔杖: "🔮",
			    恐惧怪物: "😨",
			    调试工具: "🛠️",
			    恐惧: "😨",
			    冲撞牛角: "🐂",
			    护卫植物: "🛡️",
			    远射植物: "🎯",
			    泉水: "💧",
			    书架: "📚",
			    渔网: "🕸️",
			    充能魔杖: "🔋",
			    时间卷轴: "⏳",
			    潜行靴子: "👟",
			    钩索: "🪝",
			    嗜血战斧: "🪓",
			    渔网陷阱: "🕸️",
			    磨刀石: "✨",
			    急救绷带: "🩹",
			    照明弹: "🚨",
			    照明弹光源: "💡",
			    挑战石碑: "🏛️",
			    神龛: "⛩️",
			    洗身砚: "🧼",
			    毒气瓶: "⚗️",
			    万能钥匙: "🗝️",
			    陨石法杖: "☄️",
			    毒气: "☣️",
			    落石: "🪨",
			    地刺: "뾰",
			    失明: "🕶️",
			    召唤陷阱: "🧿",
			    烈焰陷阱: "♨️",
			    虫洞: "🌀",
			    障碍物: "🧱",
			    远射陷阱: "🗼",
			    沙漏: "⏳",
			    时间: "⏳",
			    脚印:"👣",
			    爱心: "♥️",
			    修补心: "💔",
			    旗帜: "🚩",
			    门: "🚪",
			    锁: "🔒",
			    手形: "✋",
			    删除: "🗑️",
			    房间工具: "📏",
			    房间编辑: "🏠",
			    地板: "🟩",
			    走廊: "🟫",
			    墙壁: "⬛",
			    告示牌: "🪧",
			    超速怪物: "💨",
			    复活怪物: "🧙🏿‍♂️",
			    娃娃怪物: "👶",
			    吸血鬼: "🧛‍♂️",
			    存档点:"💾",
			    皇家守卫:"💂🏿‍♂️",
			    王座守护者:"⚜️",
			    墓碑:"🪦",
			    移动弹幕:"💀",
			    奖杯:"🏆",
			    陷阱先锋: '🧿',
			    飞毛腿: '👟',
			    瞬间移动: '💫',
			    博士之卷: '🎓',
			    恢复之心: '❤️‍🩹',
			    以牙还牙: '💥',
			    饰品: '💍',
			    分裂怪物: "➗",
			    巨人怪物: "🗿",
			    巨人部位: "🗿",
			    红蓝开关:"🔘",
			    红砖块:"🟥",
			    蓝砖块:"🟦",
			    追踪风弹:"💨",
			    刷怪笼: "⚙️",
			    传送带: "➡️",
			    巡逻怪物: "🚶",
			    同步怪物: "🎯",
			    绿砖块: "🟩",
			    紫砖块: "🟪",
			    绿紫开关: "🟢",
			    开关脉冲器: "📡",
			    复制工具:'📋',
			    沉浸式传送门:"🌀",
			    卷轴滚动墙: '🚫',
			    嗅探之鼻:'👃🏻',
			    永久抗火:'🔥',
			    永久解冻:'🥶',
			    永久力量:'💪🏻',
			    永久抗毒:'🧪',
			    神偷手: '🤏',
			    小书魔:'📖',
			    扫帚: '🧹',
			    战士: '💂‍♀️',
			    法师: '🧙',
			    忍者: '🥷',
			    游侠:'🏹',
			    死灵:'💀',
			    骑士:'🏇',
			    磁铁: "🧲",
			    蜘蛛怪物: "🕷️",
			    反弹怪物: "🪞",
			    蛛网: "🕸️",
			    魔法师: "🧙",
            火蜥蜴: "🦎",
            烟雾弹: "🌫️",
            烟雾: "🌫️",
            蜈蚣怪物:"🐲",
            定位器地图:"🗺️",
            死灵法杖: "🪄",
            骷髅仆从: "💀",
			};
			// 单元格类型枚举
			const 单元格类型 = {
			    墙壁: 0,
			    房间: 1,
			    走廊: 2,
			    门: 3,
			    上锁的门: 4,
			    物品: 5,
			    楼梯下楼: 6,
			    楼梯上楼: 7,
			    怪物: 8,
			};
			const 怪物状态 = {
			    休眠: 0,
			    活跃: 1,
			    攻击: 2,
			};
			const 颜色表 = [
			    "#00FF00", // 绿色
			    "#0000FF", // 蓝色
			    "#FFFF00", // 黄色
			    "#FF00FF", // 品红
			    "#FF0000", // 红色
			    "#800080", //紫色
			];
			const 效果颜色编号映射 = [
			    "#ff0000",
			    "#00ff00",
			    "#2196F3",
			    "#FF9800",
			    "#808080",
			    "#9C27B0",
			    "#008000",
			    "#888888",
			    "#8FBC8F",
			    "#FFEB3B",
			    "#CC5500",
			    "#FFD700",
			    "#8A2BE2",
			    "#A0522D",
			];
			const 效果名称编号映射 = {
			    治疗: 0,
			    能量: 1,
			    神龟: 2,
			    狂暴: 3,
			    隐身: 4,
			    透视: 5,
			    中毒: 6,
			    缓慢: 7,
			    腐蚀: 8,
			    眩晕: 9,
			    火焰: 10,
			    充能: 11,
			    恐惧: 12,
			    牵制: 13,
			};
			const 颜色名表 = ["绿", "蓝", "黄", "品红", "红", "紫"];
			let 楼梯图标 = { 下楼: 图标映射.下楼楼梯, 上楼: 图标映射.上楼楼梯 };
			const 功能键映射 = {
			    1: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 1),
			    2: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 2),
			    3: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 3),
			    4: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 4),
			    5: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 5),
			    6: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 6),
			    7: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 7),
			    q: () => 处理HUD切换按钮点击(),
			    e: () => {
			        界面可见性.背包 = !界面可见性.背包;
			        切换背包显示();
			    },
			    g: 切换日志显示,
			    f: 尝试互动,
			    z: 导出存档,
			    t: 打开传送菜单,
			    j: () => {
			        切换装备页(-1);
			    },
			    k: () => {
			        切换装备页(1);
			    },
			    u: 玩家死亡,
			    r: 重置创意关卡,
			    c: 打开配方书,
			};
			const 物品生成配置 = {
			    基础概率: {
			        普通房间: 0.4,
			        上锁房间: 0.7,
			    },
			    品质权重: {
			        1: [60, 0], // 品质: [基础刷新概率,随层数增长的附加刷新概率]
			        2: [25, 20],
			        3: [10, 30],
			        4: [5, 40],
			        5: [0, 10],
			    },
			    类型分布: {
			        普通房间: [
			            { 类型: "武器", 权重: 40 },
			            { 类型: "防具", 权重: 30 },
			            { 类型: "药水", 权重: 20 },
			            { 类型: "卷轴", 权重: 10 },
			            { 类型: "工具", 权重: 25 },
			            { 类型: "宠物", 权重: 10 },
			            { 类型: "饰品", 权重: 8 },
			        ],
			        上锁房间: [
			            { 类型: "卷轴", 权重: 30 },
			            { 类型: "武器", 权重: 30 },
			            { 类型: "药水", 权重: 25 },
			            { 类型: "防具", 权重: 15 },
			            { 类型: "工具", 权重: 25 },
			            { 类型: "宠物", 权重: 10 },
			            { 类型: "饰品", 权重: 10 },
			        ],
			    },
			};
			
			const 创建物品池 = () => ({
			    武器: [
			        { 类: 荆棘种子, 品质: 1, 最小层: 1 },
			        { 类: 护卫种子, 品质: 2, 最小层: 1 },
			        { 类: 远射种子, 品质: 3, 最小层: 2 },
			        { 类: 吸能种子, 品质: 2, 最小层: 1 },
			        { 类: 橡木法杖, 品质: 2, 最小层: 3 },
			        { 类: 钢制长剑, 品质: 1, 最小层: 0 },
			        { 类: 吸血剑, 品质: 1, 最小层: 0 },
			        { 类: 喷火枪, 品质: 1, 最小层: 0 },
			        { 类: 炸弹, 品质: 2, 最小层: 1 },
			        { 类: 金币手枪, 品质: 3, 最小层: 2 },
			        { 类: 回旋镖, 品质: 2, 最小层: 1 },
			        { 类: 闪电链法杖, 品质: 3, 最小层: 3 },
			        { 类: 大地猛击锤, 品质: 3, 最小层: 3 },
			        { 类: 穿云箭, 品质: 2, 最小层: 2 },
			        { 类: 荆棘鞭, 品质: 1, 最小层: 1 },
			        { 类: 冰霜法杖, 品质: 3, 最小层: 2 },
			        { 类: 重力锤, 品质: 4, 最小层: 5 },
			        { 类: 剧毒匕首, 品质: 1, 最小层: 1 },
			        { 类: 神秘商人, 品质: 1, 最小层: 1 }, // 奸商武力值要高，所以在武器类（确信）
			        { 类: 恐惧魔杖, 品质: 3, 最小层: 4 },
			        { 类: 斜方刀, 品质: 2, 最小层: 1 },
			        { 类: 充能魔杖, 品质: 4, 最小层: 6 },
			        { 类: 嗜血战斧, 品质: 4, 最小层: 4 },
			        { 类: 陨石法杖, 品质: 4, 最小层: 6 },
			        { 类: 狙击金币枪, 品质: 2, 最小层: 4 },
			        { 类: 追踪风弹, 品质: 3, 最小层: 4 },
			        { 类: 死灵法杖, 品质: 2, 最小层: 7 },
			        { 类: 扫帚, 品质: 2, 最小层: 2 },
			    ],
			    工具: [
			        { 类: 能量熔炉, 品质: 3, 最小层: 4 },
			        { 类: 物品祭坛, 品质: 1, 最小层: 0 },
			        { 类: 耐久祭坛, 品质: 2, 最小层: 0 },
			        { 类: 背包扩容祭坛, 品质: 2, 最小层: 0 },
			        { 类: 重铸台, 品质: 3, 最小层: 2 },
			        { 类: 探险家, 品质: 1, 最小层: 1 },
			        { 类: 火把, 品质: 1, 最小层: 2 },
			        { 类: 罐子, 品质: 1, 最小层: 0 },
			        { 类: 渔网, 品质: 2, 最小层: 1 },
			        { 类: 钩索, 品质: 3, 最小层: 2 },
			        { 类: 急救绷带, 品质: 2, 最小层: 1 },
			        { 类: 磨刀石, 品质: 3, 最小层: 2},
			        { 类: 照明弹, 品质: 2, 最小层: 2},
			        { 类: 挑战石碑, 品质: 4, 最小层: 3},
			        { 类: 神龛, 品质: 5, 最小层: 2},
			        { 类: 洗身砚, 品质: 4, 最小层: 3 },
			        { 类: 毒气瓶, 品质: 2, 最小层: 2 },
			        { 类: 万能钥匙, 品质: 3, 最小层: 3 },
			        { 类: 便携障碍物, 品质: 1, 最小层: 0 },
			        { 类: 时空罗盘, 品质: 5, 最小层: 8 },
			        { 类: 神偷手, 品质: 4, 最小层: 2 },
			        { 类: 磁铁, 品质: 3, 最小层: 2 },
			        { 类: 烟雾弹, 品质: 3, 最小层: 3 },
			        { 类: 定位器地图, 品质: 1, 最小层: 0 },
			    ],
			    防具: [
			        { 类: 引雷针护符, 品质: 3, 最小层: 2 },
			        { 类: 钢制板甲, 品质: 2, 最小层: 0 },
			        { 类: 锅盖, 品质: 2, 最小层: 0 },
			        { 类: 秘银锁甲, 品质: 4, 最小层: 2 },
			        { 类: 冰盾, 品质: 1, 最小层: 1 },
			        { 类: 潜行靴子, 品质: 2, 最小层: 4 },
			        { 类: 守卫者盔甲, 品质: 4, 最小层: 5 },
			    ],
			    药水: [
			        { 类: 治疗药水, 品质: 2, 最小层: 0 },
			        { 类: 狂暴药水, 品质: 2, 最小层: 0 },
			        { 类: 神龟药水, 品质: 3, 最小层: 1 },
			        { 类: 能量药水, 品质: 4, 最小层: 1 },
			        { 类: 隐身药水, 品质: 3, 最小层: 2 },
			        { 类: 透视药水, 品质: 3, 最小层: 1 },
			    ],
			    卷轴: [
			        { 类: 迅捷卷轴, 品质: 2, 最小层: 0 },
			        { 类: 清净卷轴, 品质: 2, 最小层: 0 },
			        { 类: 跃迁卷轴, 品质: 3, 最小层: 2 },
			        { 类: 真言卷轴, 品质: 4, 最小层: 4 },
			        { 类: 湮灭卷轴, 品质: 1, 最小层: 0 },
			        { 类: 贪婪卷轴, 品质: 3, 最小层: 3 },
			        { 类: 神秘卷轴, 品质: 1, 最小层: 0 },
			        { 类: 附魔卷轴, 品质: 1, 最小层: 1 },
			        { 类: 时间卷轴, 品质: 4, 最小层: 5 },
			        { 类: 易位卷轴, 品质: 4, 最小层: 4 },
			    ],
			    宠物: [
			        { 类: 熊猫, 品质: 3, 最小层: 2 },
			        { 类: 水母, 品质: 4, 最小层: 2 },
			        { 类: 火蜥蜴, 品质: 4, 最小层: 4 },
			    ],
			    饰品: [
			        { 类: 陷阱先锋饰品, 品质: 3, 最小层: 3 },
			        { 类: 飞毛腿饰品, 品质: 2, 最小层: 2 },
			        { 类: 瞬间移动饰品, 品质: 4, 最小层: 5 },
			        { 类: 博士之卷饰品, 品质: 3, 最小层: 2 },
			        { 类: 恢复之心饰品, 品质: 2, 最小层: 2 },
			        { 类: 以牙还牙饰品, 品质: 4, 最小层: 4 },
			        { 类: 嗅探之鼻饰品, 品质: 3, 最小层: 2 },
			    ],
			});
			
			const 创建怪物池 = () => ({
			    普通房间: [
			        { 类: 怪物, 权重: 45, 最小层: 0 },
			        { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
			        { 类: 敏捷怪物, 权重: 15, 最小层: 2 },
			        { 类: 远攻怪物, 权重: 25, 最小层: 1 },
			        { 类: 炸弹怪物, 权重: 15, 最小层: 3 },
			        { 类: 冰冻怪物, 权重: 15, 最小层: 2 },
			        { 类: 仙人掌怪物, 权重: 25, 最小层: 1 },
			        { 类: 大史莱姆怪物, 权重: 15, 最小层: 2 },
			        { 类: 瞬移怪物, 权重: 10, 最小层: 3 },
			        { 类: 伪装怪物, 权重: 8, 最小层: 1 },
			        { 类: 腐蚀怪物, 权重: 12, 最小层: 2 },
			        { 类: 盗贼怪物, 权重: 10, 最小层: 4 },
			        { 类: 萨满怪物, 权重: 7, 最小层: 3 },
			        { 类: 召唤师怪物, 权重: 7, 最小层: 4 },
			        { 类: 吸能怪物, 权重: 11, 最小层: 1 },
			        { 类: 剧毒云雾怪物, 权重: 9, 最小层: 2 },
			        { 类: 旋风怪物, 权重: 10, 最小层: 4 },
			        { 类: 恐惧怪物, 权重: 10, 最小层: 3 },
			        { 类: 超速怪物, 权重: 12, 最小层: 4 },
			        { 类: 复活怪物, 权重: 14, 最小层: 5 },
			        { 类: 吸血鬼, 权重: 8, 最小层: 0 },
			        { 类: 分裂怪物, 权重: 10, 最小层: 6 },
			        { 类: 巨人怪物, 权重: 12, 最小层: 7 },
			        { 类: 巡逻怪物, 权重: 5, 最小层: 7 },
			        { 类: 反弹怪物, 权重: 20, 最小层: 2 },
			        { 类: 蜘蛛怪物, 权重: 25, 最小层: 1 },
			        { 类: 魔法师, 权重: 8, 最小层: 6 },
			        { 类: 蜈蚣怪物, 权重: 12, 最小层: 5 },
			    ],
			    上锁房间: [
			        { 类: 炸弹怪物, 权重: 35, 最小层: 1 },
			        { 类: 远攻怪物, 权重: 30, 最小层: 3 },
			        { 类: 敏捷怪物, 权重: 35, 最小层: 2 },
			        { 类: 冰冻怪物, 权重: 15, 最小层: 0 },
			        { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
			        { 类: 仙人掌怪物, 权重: 30, 最小层: 1 },
			        { 类: 大史莱姆怪物, 权重: 20, 最小层: 2 },
			        { 类: 瞬移怪物, 权重: 15, 最小层: 3 },
			        { 类: 伪装怪物, 权重: 12, 最小层: 1 },
			        { 类: 腐蚀怪物, 权重: 18, 最小层: 2 },
			        { 类: 盗贼怪物, 权重: 18, 最小层: 1 },
			        { 类: 萨满怪物, 权重: 5, 最小层: 3 },
			        { 类: 召唤师怪物, 权重: 4, 最小层: 4 },
			        { 类: 吸能怪物, 权重: 9, 最小层: 1 },
			        { 类: 剧毒云雾怪物, 权重: 7, 最小层: 2 },
			        { 类: 旋风怪物, 权重: 12, 最小层: 3 },
			        { 类: 恐惧怪物, 权重: 15, 最小层: 3 },
			        { 类: 超速怪物, 权重: 15, 最小层: 4 },
			        { 类: 复活怪物, 权重: 10, 最小层: 2 },
			        { 类: 吸血鬼, 权重: 8, 最小层: 0 },
			        { 类: 分裂怪物, 权重: 15, 最小层: 6 },
			        { 类: 巨人怪物, 权重: 15, 最小层: 7 },
			        { 类: 巡逻怪物, 权重: 5, 最小层: 7 },
			        { 类: 反弹怪物, 权重: 25, 最小层: 2 },
			        { 类: 蜘蛛怪物, 权重: 25, 最小层: 1 },
			        { 类: 蜈蚣怪物, 权重: 15, 最小层: 5 },
			    ],
			});
			const 融合Buff类型 = {
			    攻击加成: "ATTACK_BONUS",
			    攻击倍率: "ATTACK_MULTIPLIER",
			    冷却缩减: "COOLDOWN_REDUCTION",
			    冷却倍率: "COOLDOWN_MULTIPLIER",
			    耐久加成: "DURABILITY_BONUS",
			    耐久倍率: "DURABILITY_MULTIPLIER",
			    范围加成: "RANGE_BONUS",
			    中毒几率: "POISON_CHANCE",
			    火焰伤害: "FIRE_DAMAGE_CHANCE",
			    冰冻几率: "ICE_CHANCE",
			    生命偷取: "LIFE_STEAL",
			    防御加成: "DEFENSE_BONUS",
			    防御倍率: "DEFENSE_MULTIPLIER",
			    暴击几率: "CRITICAL_CHANCE",
			    暴击伤害倍率: "CRITICAL_DAMAGE_MULTIPLIER",
			    击退几率: "KNOCKBACK_CHANCE",
			    攻击吸能: "ENERGY_STEAL_ON_HIT",
			    闪避几率: "DODGE_CHANCE",
			    固定伤害减免: "FLAT_DAMAGE_REDUCTION",
			    受击回能: "ENERGY_ON_DAMAGE_TAKEN",
			    幸运一击: "LUCKY_STRIKE",
			    协同效应: "SYNERGY_EFFECT",
			    磨刀石攻击加成: "SHARPEN_ATTACK_BONUS",
			    磨刀石冷却缩减: "SHARPEN_COOLDOWN_REDUCTION",
			};
			            const 神龛效果列表 = [
			    {
			        id: '祝福_最大生命值',
			        名称: '生命祝福',
			        描述: '你的体魄变得更加强健，最大生命值永久提升了25点。',
			        类型: '祝福',
			        apply: () => {
			            永久Buffs.最大生命值加成 = (永久Buffs.最大生命值加成 || 0) + 25;
			            应用永久Buffs();
			        },
			        deapply: () => {
			            永久Buffs.最大生命值加成 = -永久Buffs.最大生命值加成;
			        }
			    },
			    {
			        id: '祝福_挖掘墙壁',
			        名称: '开山之力',
			        描述: '你获得了开山之力，现在可以挖掘墙壁了！',
			        类型: '祝福',
			        apply: () => {
			            永久Buffs.能挖掘墙壁 = true;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '祝福_永久攻击',
			        名称: '战神之赐',
			        描述: '武运昌隆！你的基础攻击力永久提升了2点。',
			        类型: '祝福',
			        apply: () => {
			            永久Buffs.攻击加成 = (永久Buffs.攻击加成 || 0) + 2;
			            应用永久Buffs();
			        }
			    },
			     {
			        id: '祝福_初始能量',
			        名称: '启迪之心',
			        描述: '你的心智变得更加敏锐，每层开始时都会获得额外的初始能量。',
			        类型: '祝福',
			        apply: () => {
			            永久Buffs.初始能量加成 = (永久Buffs.初始能量加成 || 0) + 20;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '祝福_装备耐久',
			        名称: '工匠之魂',
			        描述: '你的装备似乎变得更加坚固，所有装备的耐久度消耗降低25%。',
			        类型: '祝福',
			        apply: () => {
			            const i=永久Buffs.耐久消耗减免 || 0;
			            永久Buffs.耐久消耗减免 = i+(Math.pow(1-i,2))/4
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_随机掉落',
			        名称: '失物之咒',
			        描述: '你的口袋似乎有个破洞，移动时偶尔会随机掉落背包中的物品！',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.随机掉落 = true;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_挑战增加',
			        名称: '好战之血',
			        描述: '你变得更好战了，所有挑战房间的波数都将永久增加2波。',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.挑战波数增加 = (永久Buffs.挑战波数增加 || 0) + 2;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_怪物反伤',
			        名称: '荆棘诅咒',
			        描述: '你的攻击似乎会激怒地牢的意志，所有怪物现在都会反弹少量伤害给你。',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.怪物反伤 = true;
			            应用永久Buffs();
			        }
			    },
			     {
			        id: '诅咒_能量流失',
			        名称: '遗忘之咒',
			        描述: '你的精神不再集中，每回合都会缓慢流失少量能量。',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.能量流失 = (永久Buffs.能量流失 || 0) + 0.2;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_商店涨价',
			        名称: '奸商之友',
			        描述: '神秘商人们似乎达成了共识，他们所有商品的价格都上涨了。',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.商店价格倍率 = (永久Buffs.商店价格倍率 || 0.2) * 1.5;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_耐久减半',
			        名称: '腐朽之触',
			        描述: '一股腐朽的力量侵蚀了你的装备，所有装备的耐久度立即减半！',
			        类型: '诅咒',
			        apply: () => {
			            [...玩家背包.values(), ...玩家装备.values()].forEach(item => {
			                if (item && item.自定义数据 && item.自定义数据.has('耐久') && !item.自定义数据.get('不可破坏')) {
			                    const 当前耐久 = item.自定义数据.get('耐久');
			                    item.自定义数据.set('耐久', Math.ceil(当前耐久 / 2));
			                }
			            });
			            更新装备显示();
			            更新背包显示();
			        }
			    }
			];
			
			
			// 全局变量
			let 地牢 = [];
			let 房间列表 = [];
			let 临时测试 = false;
			let 玩家距离图 = [];
			let isSifting = false;
			let 当前天气效果 = [];
			let 编辑器剪贴板 = null;
			let 是否是自定义关卡 = false
			let 上次放置的传送带 = null;
			let 上次放置的开关脉冲器 = null;
			let 上次放置的隐形毒气陷阱 = null;
			let 绿紫开关状态 = '绿';
			let 跳过怪物回合剩余次数 = 0;
			let 当前关卡存档数据字符串 = null;
			let 玩家装备 = new Map(); // 以装备槽位为索引，目前有 4 个槽位，索引从 1 开始
			let 玩家 = { x: 0, y: 0 };
			const 材料 = {
			    木质: "木质",
			    铁质: "铁质",
			    玻璃: "玻璃",
			    铜质: "铜质",
			    金质: "金质",
			    普通: "普通",
			};
			let 玩家死亡次数 = 0;
			let 红蓝开关状态 = '红';
			let 小地图Ctx;
			const 小地图缩放 = 3;
			const 小地图Offset = 10;
			let 视口偏移X = 0,
			    视口偏移Y = 0;
			let 跟踪玩家怪物数 = 0;
			let 房间地图 = Array(地牢大小)
			    .fill()
			    .map(() => Array(地牢大小).fill(-1)); // 记录每个单元格所属房间ID
			let 上锁房间列表 = []; // 存储被锁定房间对象
			let 已访问房间 = new Set(); // 记录已访问过的房间
			let 显示HUD计时器 = null;
			let 玩家正在传送 = false;
			let 所有传送门 = [];
			let hud模式 = "默认";
			let 背包可见 = false;
			let 玩家背包 = new Map(); // 以物品唯一标识为索引
			let 最大背包容量 = 12;
			let 门实例列表 = new Map();
			const 通知队列 = [];
			let 移动历史 = [];
			let 传送点列表 = []; // 存储传送点 { id: string, 名称: string, 层数: number, x: number, y: number } 其实这里也可以xss
			const 最大传送点数量 = 5; // 限制最大保存数量
			let 上次移动 = 0;
			let 移动状态 = {
			    up: false,
			    down: false,
			    left: false,
			    right: false,
			};
			let hud显示 = false;
			let 界面可见性 = {
			    hud: false,
			    背包: false,
			};
			let 游戏设置 = {
			 热键绑定: {
			     '等待': ' ',
			     '装备槽1': '1', '装备槽2': '2', '装备槽3': '3', '装备槽4': '4',
			     '装备槽5': '5', '装备槽6': '6', '装备槽7': '7', '切换HUD': 'q',
			     '背包': 'e', '日志': 'g', '互动': 'f', '导出存档': 'z',
			     '传送菜单': 't', '装备页上一页': 'j', '装备页下一页': 'k', '自杀': 'u',
			     '重置关卡': 'r', '配方书': 'c',
                 '编辑器游玩': 'h',
                 '编辑器删除工具': 'b',
                 '编辑器撤销': 'z',
                 '编辑器重做': 'y',
                 '编辑器确认': 'Enter'
			 },
			 热键绑定描述: {
			     '等待': '等待/休息',
			     '装备槽1': '使用装备1', '装备槽2': '使用装备2', '装备槽3': '使用装备3', '装备槽4': '使用装备4',
			     '装备槽5': '使用装备5', '装备槽6': '使用装备6', '装备槽7': '使用装备7', '切换HUD': '切换HUD',
			     '背包': '打开/关闭背包', '日志': '打开/关闭日志', '互动': '互动/攻击', '导出存档': '导出存档',
			     '传送菜单': '传送菜单', '装备页上一页': '装备页(上)', '装备页下一页': '装备页(下)', '自杀': '自杀',
			     '重置关卡': '重置关卡', '配方书': '打开配方书',
                 '编辑器游玩': '开始游玩',
                 '编辑器删除工具': '选择删除工具',
                 '编辑器撤销': '撤销 (Ctrl/Cmd)',
                 '编辑器重做': '重做 (Ctrl/Cmd+Shift)',
                 '编辑器确认': '确认/应用'
			 },
			 方向键大小: 13,
			 显示方向键: true,
			 禁用点击移动: false,
			 手机模式: false,
			 动画模式: false,
			 文本模式: false,
			 相机视野大小: 15,
			 移动速度: 100,
			 小地图大小: 150,
			 受伤时击退: false,
			};
			
			const 热键绑定描述 = {
			 '等待': '等待/休息',
			 '装备槽1': '使用装备1', '装备槽2': '使用装备2', '装备槽3': '使用装备3', '装备槽4': '使用装备4',
			 '装备槽5': '使用装备5', '装备槽6': '使用装备6', '装备槽7': '使用装备7', '切换HUD': '切换HUD',
			 '背包': '打开/关闭背包', '日志': '打开/关闭日志', '互动': '互动/攻击', '导出存档': '导出存档',
			 '传送菜单': '传送菜单', '装备页上一页': '装备页(上)', '装备页下一页': '装备页(下)', '自杀': '自杀',
			 '重置关卡': '重置关卡', '配方书': '打开配方书',
             '编辑器游玩': '开始游玩',
             '编辑器删除工具': '选择删除工具',
             '编辑器撤销': '撤销 (Ctrl/Cmd)',
             '编辑器重做': '重做 (Ctrl/Cmd+Shift)',
             '编辑器确认': '确认/应用'
			};
			let 玩家正在休息 = false;
			let 休息定时器 = null;
			let 等待触摸定时器 = null;
			let 所有怪物 = [];
			let 玩家动画状态 = { 正在动画: false };
			let 当前出战宠物列表 = [];
			let 当前加载的关卡数据缓存 = null;
			let 当前关卡ID = null;
			let prng = Math.random;
			let 当前游戏种子 = null;
			let 玩家职业 = null;
			const 怪物生成概率 = 0.7;
			const 最大怪物数 = 5; //一个房间内的怪物生成上限
			let 玩家初始位置 = { x: 0, y: 0 };
			let 死亡界面已显示 = false;
			let 单击移动定时器 = null;
			let 开始移动定时器 = null;
			let 长按移动 = false;
			let 当前激活卷轴列表 = new Set();
			let 移动间隔 = 100; // 长按连续移动间隔
			let 首次移动延迟 = 250; // 首次移动后的延迟
			let 最后移动时间 = 0;
			let 移动定时器 = null;
			let 教程阶段 = 0;
			let 教程提示已显示 = false;
			let 是否为教程层 = false;
			let 玩家属性 = {
			    移动步数: 1,
			    攻击加成: 0,
			    防御加成: 0,
			    掉落倍率: 1,
			    透视: false,
			    允许移动: 0,
			    能挖掘墙壁: false,
			    最大生命值加成: 0,
			    怪物反伤: false,
			    挑战波数增加: 0,
			    随机掉落: false,
			    初始能量加成: 0,
			    耐久消耗减免: 0,
			    能量流失: 0,
			    商店价格倍率: 1,
			    已获得神龛效果: [],
			};
			let 初始玩家属性 = {
			    移动步数: 1,
			    攻击加成: 0,
			    防御加成: 0,
			    掉落倍率: 1,
			    透视: false,
			    允许移动: 0,
			    能挖掘墙壁: false,
			    最大生命值加成: 0,
			    怪物反伤: false,
			    挑战波数增加: 0,
			    随机掉落: false,
			    初始能量加成: 0,
			    耐久消耗减免: 0,
			    能量流失: 0,
			    商店价格倍率: 1,
			    已获得神龛效果: [],
			};
			let 自定义全局设置 = {
		    初始生命值: 100,
		    初始能量值: 100,
		    初始背包容量: 12,
		    玩家属性: {
		        移动步数: 1,
		        攻击加成: 0,
		        防御加成: 0,
		    },
		    胜利条件: {
		        回合数限制: 0,
		        伤害限制: 0,
		        生命下限: 0,
		        清除所有怪物: false,
		        死亡次数限制: 0,
		    },
		    全局天气: [],
		    禁用传送菜单: false,
		    禁用大地图: false,
		    诡魅天气怪物层级: 1,
		    奖励物品层级: 1,
		};
			let 胜利条件提示元素组 = {
			    标题: null,
			    回合: null,
			    伤害: null,
			    生命: null,
			    死亡: null
			};
			let 玩家总移动回合数 = 0;
			let 玩家总受到伤害 = 0;
			let 永久Buffs = {
			    已获得效果: new Set(),
			};
			let 相机目标X = 视口偏移X;
			let 相机目标Y = 视口偏移Y;
			let 当前相机X = 视口偏移X;
			let 当前相机Y = 视口偏移Y;
			let 相机锁定 = false; // 防止中途更新目标
			let 玩家仆从列表 = [];
			const 相机移动速度 = 0.2;
			let 显示模式 = "装备"; // 默认显示装备槽
			let 日志历史 = [];
			let 是否显示通知 = true;
			let 日志面板可见 = false;
			let 所有计时器 = [];
			let 玩家状态 = [];
			let NPC互动中 = false;
			let 当前NPC = null;
			let 已击杀怪物数 = 0;
			let 怪物状态表 = new WeakMap(); //好耶！WeakMap！
			let 彩蛋1触发,
			    彩蛋2触发,
			    彩蛋3触发 = false; //卑鄙的人，彩蛋要靠自己寻找才有意义
			let 待显示格子特效队列 = [];
			let 活动DOM特效 = [];
			let 待显示爆炸范围 = [];
			let 物品池;
			let 怪物池;
			let 所有物品定义 = []; // 用于存储图鉴的物品定义
			let 所有怪物定义 = [];
			let 怪物动画状态 = new WeakMap();
			let 玩家正在放置障碍物 = false;
			let 编辑器工具栏模式 = '常显';
			
			
			let moveQueue = [];
			let isAutoMoving = false;
			let 最高教程阶段 = 0;
			let 当前回放阶段 = 0;
			            let 中文模式 = false;
			let 游戏状态 = "主菜单"; // "主菜单", "游戏中", "地图编辑器", "图鉴", "图鉴选择", "编辑器游玩"
			let 编辑器状态 = {
			    当前选中: null, 
			    模式: '编辑',
			    选中实例: null, 
			    相机速度: 1,
			    正在划区: false,
			    划区起点: { x: 0, y: 0 },
			    上次放置的背景: null,
				笔刷模式: '单个',
				笔刷形状: '圆形',
				笔刷半径: 3,
			};
			let undoStack = [];
			let redoStack = [];
			const MAX_UNDO_STEPS = 50;
			let 编辑器最近使用列表 = [];
			let 自动回合间隔 = 350;
			let 上次自动回合时间 = 0;
			let 玩家正在钩索 = false;
			let 钩索移动定时器 = null;
			let 生存挑战激活 = false;
			let 生存挑战备份单元格 = [];
			let 物品点击监听器 = null;
			let 开发者模式 = false;
			let versionClickCount = 0;
			let 地牢生成方式 = 'default';
            let 已揭示洞穴格子 = new Set();
			
			
			//装备栏相关
			let 当前装备页 = 0;
			let 最大装备页 = 3;
			let 最大装备槽数量 = 24;
			let 触摸起始X = 0;
			let 触摸移动X = 0;
			let 装备栏滑动中 = false;
			let 装备栏每页装备数 = 7;
			
			
			let touchStartX = 0;
			let touchStartY = 0;
			let touchCurrentX = 0;
			let touchCurrentY = 0;
			let touchStartTime = 0;
			let isSwiping = false;
			let swipeMoveInterval = null;
			const swipeThreshold = 15; // 移动超过才识别为滑动
			const tapTimeThreshold = 75; // 毫秒内的触摸视为点击
			let 地图标记 = new Map();
			let 大地图状态 = {
    可见: false,
    缩放等级: 1.0,
    最小缩放: 0.2,
    最大缩放: 5.0,
    平移X: 0,
    平移Y: 0,
    拖拽中: false,
    拖拽起始X: 0,
    拖拽起始Y: 0,
    上次平移X: 0,
    上次平移Y: 0,
    动画帧ID: null,
    悬停信息: null,
    当前查看楼层: 0,
    标记模式: false,
    传送模式: false,
};

const 大地图画布 = document.getElementById('大地图画布');
const 大地图画布容器 = document.getElementById('大地图画布容器');
const 大地图遮罩 = document.getElementById('大地图遮罩');
const 大地图信息 = document.getElementById('大地图信息');

document.getElementById('小地图容器').addEventListener('click', 打开大地图);
document.getElementById('关闭大地图按钮').addEventListener('click', 关闭大地图);
document.getElementById('大地图缩放放大按钮').addEventListener('click', () => 调整大地图缩放(1.2));
document.getElementById('大地图缩放缩小按钮').addEventListener('click', () => 调整大地图缩放(1 / 1.2));
document.getElementById('大地图居中按钮').addEventListener('click', () => 居中大地图(true));
document.getElementById('大地图上一层按钮').addEventListener('click', () => 切换大地图楼层(-1));
document.getElementById('大地图下一层按钮').addEventListener('click', () => 切换大地图楼层(1));
document.getElementById('大地图标记模式按钮').addEventListener('click', 切换大地图标记模式);
document.getElementById('大地图传送按钮').addEventListener('click', 切换大地图传送模式);

function 打开大地图() {
    if (大地图状态.可见) return;
    if ((是否是自定义关卡 || 游戏状态 === '编辑器游玩') && 自定义全局设置.禁用大地图 && !开发者模式) {
显示通知("此关卡禁用了大地图。", "警告");
return;
}
if (
			        (当前天气效果.includes("诡魅") ||
			        当前天气效果.includes("深夜")) &&
			        游戏状态!=="地图编辑器"
			    ) {
			    return;
			    }
    大地图状态.可见 = true;
    大地图状态.当前查看楼层 = 当前层数;
    大地图状态.标记模式 = false;
    document.getElementById('大地图标记模式按钮').classList.remove('active');
    玩家属性.允许移动++;
    const 传送按钮 = document.getElementById('大地图传送按钮');
    if (开发者模式) {
传送按钮.style.display = 'block';
传送按钮.classList.remove('active');
传送按钮.style.borderColor = '';
} else {
传送按钮.style.display = 'none';
}

    大地图遮罩.style.display = 'flex';
    requestAnimationFrame(() => {
        大地图遮罩.classList.add('显示');
    });

    居中大地图(false);
    添加大地图事件监听();
    大地图状态.动画帧ID = requestAnimationFrame(绘制大地图循环);
    更新大地图楼层显示();
}

function 切换大地图标记模式() {
大地图状态.标记模式 = !大地图状态.标记模式;
const 按钮 = document.getElementById('大地图标记模式按钮');
const 传送按钮 = document.getElementById('大地图传送按钮');
if (大地图状态.标记模式) {
    大地图状态.传送模式 = false;
    传送按钮.classList.remove('active');
    传送按钮.style.borderColor = '';

    按钮.classList.add('active');
    按钮.style.borderColor = '#2196f3';
    大地图画布容器.style.cursor = 'crosshair';
    显示通知("标记模式已开启", "信息");
} else {
    按钮.classList.remove('active');
    按钮.style.borderColor = '';
    大地图画布容器.style.cursor = 'grab';
    显示通知("标记模式已关闭", "信息");
}

}
function 切换大地图传送模式() {
大地图状态.传送模式 = !大地图状态.传送模式;
const 按钮 = document.getElementById('大地图传送按钮');
const 标记按钮 = document.getElementById('大地图标记模式按钮');
if (大地图状态.传送模式) {
    大地图状态.标记模式 = false;
    标记按钮.classList.remove('active');
    标记按钮.style.borderColor = '';

    按钮.classList.add('active');
    按钮.style.borderColor = '#f44336';
    大地图画布容器.style.cursor = 'crosshair';
    显示通知("传送模式已开启", "信息");
} else {
    按钮.classList.remove('active');
    按钮.style.borderColor = '';
    大地图画布容器.style.cursor = 'grab';
    显示通知("传送模式已关闭", "信息");
}

}
function 切换大地图楼层(方向) {
    const 查看楼层 = 大地图状态.当前查看楼层 + 方向;
    if (查看楼层 === 当前层数 || 所有地牢层.has(查看楼层)) {
        大地图状态.当前查看楼层 = 查看楼层;
        居中大地图(false);
        更新大地图楼层显示();
    } else {
        显示通知(`无法查看第 ${查看楼层} 层的地图。`, "警告");
    }
}

function 更新大地图楼层显示() {
    const 标题 = document.getElementById('大地图楼层标题');
    if (标题) {
        标题.textContent = `地牢地图 - 第 ${大地图状态.当前查看楼层} 层`;
    }
    document.getElementById('大地图上一层按钮').disabled = !所有地牢层.has(大地图状态.当前查看楼层 - 1) && (大地图状态.当前查看楼层 - 1) !== 当前层数;
    document.getElementById('大地图下一层按钮').disabled = !所有地牢层.has(大地图状态.当前查看楼层 + 1) && (大地图状态.当前查看楼层 + 1) !== 当前层数;
}

function 绘制大地图() {
    const ctx = 大地图画布.getContext('2d');
    const 容器宽度 = 大地图画布容器.clientWidth;
    const 容器高度 = 大地图画布容器.clientHeight;

    大地图画布.width = 容器宽度 * window.devicePixelRatio;
    大地图画布.height = 容器高度 * window.devicePixelRatio;
    大地图画布.style.width = `${容器宽度}px`;
    大地图画布.style.height = `${容器高度}px`;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim();
    ctx.fillRect(0, 0, 容器宽度, 容器高度);

    ctx.save();
    ctx.translate(大地图状态.平移X, 大地图状态.平移Y);
    ctx.scale(大地图状态.缩放等级, 大地图状态.缩放等级);

    const floorData = 大地图状态.当前查看楼层 === 当前层数
        ? { 地牢, 房间列表, 所有怪物, 玩家位置: 玩家, 已访问房间,地牢生成方式,已揭示洞穴格子 }
        : 所有地牢层.get(大地图状态.当前查看楼层);

    if (!floorData) {
        ctx.restore();
        return;
    }

    const 单元格尺寸 = 16;
    const 玩家定位器地图 = Array.from(玩家装备.values()).find(item => item instanceof 定位器地图);
    const 墙壁线宽 = 2 / 大地图状态.缩放等级;

    let localDungeon = floorData.地牢;
    let 下楼房间 = null
    if (!localDungeon) localDungeon = floorData.地牢数组;
    
    for (let y = 0; y < localDungeon.length; y++) {
        for (let x = 0; x < localDungeon[y].length; x++) {
            const 单元格 = localDungeon[y][x];
            if (!单元格) continue;
            if(floorData.地牢生成方式 === 'cave' && (!floorData.已揭示洞穴格子.has(`${x},${y}`)&&!(玩家定位器地图&&单元格.类型==单元格类型.楼梯下楼)) && 游戏状态!=="地图编辑器") continue;

            let 颜色 = '#000';
            if (单元格.背景类型 === 单元格类型.房间) 颜色 = "#3a506b";
            else if (单元格.背景类型 === 单元格类型.走廊) 颜色 = "#2b2d42";
            else if (单元格.背景类型 === 单元格类型.门) 颜色 = "#8b4513";
            else if (单元格.背景类型 === 单元格类型.上锁的门) 颜色 = 颜色表[单元格.颜色索引];

            ctx.fillStyle = 颜色;
            ctx.fillRect(x * 单元格尺寸, y * 单元格尺寸, 单元格尺寸, 单元格尺寸);
            if (单元格.isOneWay && 单元格.oneWayAllowedDirection && [单元格类型.门, 单元格类型.上锁的门].includes(单元格.背景类型)) {
                            ctx.save();
			                ctx.font = `${单元格尺寸 * 0.7}px Arial`;
			                ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
			                ctx.textAlign = "center";
			                ctx.textBaseline = "middle";
			                let arrow = "";
			
			                if (单元格.oneWayAllowedDirection === "N") arrow = "↑";
			                else if (单元格.oneWayAllowedDirection === "S") arrow = "↓";
			                else if (单元格.oneWayAllowedDirection === "E") arrow = "→";
			                else if (单元格.oneWayAllowedDirection === "W") arrow = "←";
			
			                const arrowX = x*单元格尺寸 + 单元格尺寸 / 2;
			                const arrowY = y*单元格尺寸 + 单元格尺寸 / 2;
			
			                ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
			                ctx.shadowBlur = 3;
			                ctx.shadowOffsetX = 1;
			                ctx.shadowOffsetY = 1;
			                ctx.fillText(arrow, arrowX, arrowY);
                            ctx.restore();
			            }
            

            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 墙壁线宽;
            ctx.beginPath();
            if (单元格.墙壁.上) { ctx.moveTo(x * 单元格尺寸, y * 单元格尺寸); ctx.lineTo((x + 1) * 单元格尺寸, y * 单元格尺寸); }
            if (单元格.墙壁.右) { ctx.moveTo((x + 1) * 单元格尺寸, y * 单元格尺寸); ctx.lineTo((x + 1) * 单元格尺寸, (y + 1) * 单元格尺寸); }
            if (单元格.墙壁.下) { ctx.moveTo((x + 1) * 单元格尺寸, (y + 1) * 单元格尺寸); ctx.lineTo(x * 单元格尺寸, (y + 1) * 单元格尺寸); }
            if (单元格.墙壁.左) { ctx.moveTo(x * 单元格尺寸, (y + 1) * 单元格尺寸); ctx.lineTo(x * 单元格尺寸, y * 单元格尺寸); }
            ctx.stroke();
            const item = 单元格.关联物品;
            let shouldDraw = false;

            
        
            if (单元格.关联物品 && !单元格.关联物品.是否为隐藏物品) {
                if (item.类型 === '楼梯') {
                if (单元格.类型 === 单元格类型.楼梯上楼) {
                    shouldDraw = true;
                } else if (单元格.类型 === 单元格类型.楼梯下楼) {
                    shouldDraw = true;
                    if (玩家定位器地图){
                    if (房间地图[y][x]>0) 下楼房间=房间地图[y][x]
                    floorData?.已揭示洞穴格子?.add(`${x},${y}`);
                    }
                    
                }
                if (shouldDraw) {
                ctx.fillStyle ='#fff'
                ctx.font = `${单元格尺寸 * 0.8}px color-emoji`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(item.图标, (x + 0.5) * 单元格尺寸, (y + 0.5) * 单元格尺寸);
                
            }
            continue;
            }

            
                 ctx.fillStyle = 单元格.关联物品.颜色表[单元格.关联物品.颜色索引];
                 ctx.font = `${单元格尺寸 * 0.8}px color-emoji`;
                 ctx.textAlign = "center";
                 ctx.textBaseline = "middle";
                 ctx.fillText(单元格.关联物品.图标, (x + 0.5) * 单元格尺寸, (y + 0.5) * 单元格尺寸);
            }
        }
    }
    
    if (floorData.所有怪物) {
        floorData.所有怪物.forEach(怪物 => {
            const 房间ID = 房间地图[怪物.y][怪物.x];
            if(floorData.地牢生成方式 === 'cave' && !floorData.已揭示洞穴格子.has(`${怪物.x},${怪物.y}`)&& 游戏状态!=="地图编辑器") return;
            if (怪物.强化) {
                ctx.fillStyle = '#f00';
                ctx.font = `${单元格尺寸 * 0.8}px color-emoji`;
                if (怪物 instanceof 巨人怪物) ctx.fillStyle = ctx.font = `${单元格尺寸 * 1.8}px color-emoji`;
            } else {
                ctx.fillStyle = '#fff';
                ctx.font = `${单元格尺寸 * 0.8}px color-emoji`;
                if (怪物 instanceof 巨人怪物) ctx.font = `${单元格尺寸 * 1.8}px color-emoji`;
            }
            
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            if (怪物 instanceof 巨人怪物) {
                ctx.fillText(怪物.图标, (怪物.x + 1) * 单元格尺寸, (怪物.y + 1) * 单元格尺寸);
                return;
            }
            ctx.fillText(怪物.图标, (怪物.x + 0.5) * 单元格尺寸, (怪物.y + 0.5) * 单元格尺寸);
        });
    }


if (当前出战宠物列表 && 当前出战宠物列表.length) {
当前出战宠物列表.forEach(pet => {
if (!pet || !pet.是否已放置) return;

 if (pet.层数!==大地图状态.当前查看楼层) return
const sx = pet.x * 单元格尺寸 + 单元格尺寸 / 2;
const sy = pet.y * 单元格尺寸 + 单元格尺寸 / 2;
ctx.font = `${Math.max(10, Math.floor(单元格尺寸 * 0.9))}px system-ui`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
const 图标 = pet.图标 || 图标映射.宠物 || "🐾";
ctx.fillStyle =  pet.颜色表[pet.颜色索引]||"#ffffff";
ctx.fillText(图标, sx, sy);
});
}
房间列表.forEach(房间 => {
const 已访问 = floorData?.已访问房间?.has(房间.id);
if  ((已访问 && 房间.id!==下楼房间)||开发者模式||游戏状态==="地图编辑器") return;
const rx = 房间.x * 单元格尺寸;
const ry = 房间.y * 单元格尺寸;

ctx.fillStyle ="#000f";
ctx.fillRect(rx, ry, 房间.w * 单元格尺寸, 房间.h * 单元格尺寸);

});
    const 玩家位置 = floorData.玩家位置;
    if (玩家位置) {
        ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.arc((玩家位置.x + 0.5) * 单元格尺寸, (玩家位置.y + 0.5) * 单元格尺寸, 单元格尺寸 * 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2 / 大地图状态.缩放等级;
        ctx.stroke();
    }

    const markers = 地图标记.get(大地图状态.当前查看楼层) || [];
    markers.forEach(marker => {
        ctx.font = `${单元格尺寸*1.5}px color-emoji`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(marker.icon, (marker.x + 1) * 单元格尺寸, (marker.y + 1) * 单元格尺寸);
    });

    ctx.restore();
    
    if (大地图状态.悬停信息) {
        大地图信息.textContent = 大地图状态.悬停信息;
        大地图信息.style.display = 'block';
    } else {
        大地图信息.style.display = 'none';
    }
}

function 大地图拖拽开始(事件) {
    事件.preventDefault();
    const rect = 大地图画布容器.getBoundingClientRect();
        const x = (事件.clientX || 事件.touches[0].clientX) - rect.left;
        const y = (事件.clientY || 事件.touches[0].clientY) - rect.top;

        const 世界X = Math.floor((x - 大地图状态.平移X) / (16 * 大地图状态.缩放等级));
        const 世界Y = Math.floor((y - 大地图状态.平移Y) / (16 * 大地图状态.缩放等级));
    if (大地图状态.标记模式) {
        

        const markers = 地图标记.get(大地图状态.当前查看楼层) || [];
        const existingIndex = markers.findIndex(m => m.x === 世界X && m.y === 世界Y);

        if (existingIndex > -1) {
            markers.splice(existingIndex, 1);
        } else {
            const icon = prompt("输入标记图标 (例如: ❓, 💀, 💰):", "⭐");
            if (icon) {
                markers.push({ x: 世界X, y: 世界Y, icon: icon });
            }
        }
        地图标记.set(大地图状态.当前查看楼层, markers);
        切换大地图标记模式()
        绘制小地图();
        return;
    }
    if (大地图状态.传送模式) {
    if (大地图状态.当前查看楼层 === 当前层数) {
        if (位置是否可用(世界X, 世界Y, false)) {
            玩家.x = 世界X;
            玩家.y = 世界Y;
            更新视口(true);
            处理玩家着陆效果(世界X, 世界Y, 世界X, 世界Y);
            if (生存挑战激活) {
			        显示通知("强大的结界阻止了传送！", "错误");
			        关闭大地图();
			        return;
			    }
			
			    const 当前玩家房间ID = 房间地图[玩家.y][玩家.x];
			    if (当前玩家房间ID !== -1) {
			        const 当前玩家所在房间 = 房间列表[当前玩家房间ID];
			        if (
			            当前玩家所在房间 &&
			            当前玩家所在房间.类型 === "挑战房间" &&
			            当前玩家所在房间.挑战状态 &&
			            当前玩家所在房间.挑战状态.进行中
			        ) {
			            处理挑战失败(当前玩家所在房间);
			        }
			    }
            显示通知(`已传送到 (${世界X}, ${世界Y})`, "成功");
            关闭大地图();
        } else {
            显示通知("无法传送到该位置！", "错误");
            切换大地图传送模式()
        }
    } else {
        显示通知("只能在当前楼层进行传送！", "错误");
    }
    return;
}
    大地图状态.拖拽中 = true;
    大地图状态.拖拽起始X = (事件.clientX || 事件.touches[0].clientX);
    大地图状态.拖拽起始Y = (事件.clientY || 事件.touches[0].clientY);
    大地图状态.上次平移X = 大地图状态.平移X;
    大地图状态.上次平移Y = 大地图状态.平移Y;
    大地图画布容器.style.cursor = 'grabbing';
}


function 关闭大地图() {
    if (!大地图状态.可见) return;
    大地图状态.可见 = false;
    玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动 - 1);

    大地图遮罩.classList.remove('显示');
    setTimeout(() => {
        let 按钮 = document.getElementById('大地图标记模式按钮');
        大地图遮罩.style.display = 'none';
        大地图状态.标记模式 =false
        按钮.classList.remove('active');
        按钮.style.borderColor = '';
        按钮 = document.getElementById('大地图传送按钮');
        按钮.classList.remove('active');
    按钮.style.borderColor = '';
    大地图状态.传送模式 =false
    }, 400);

    移除大地图事件监听();
    if (大地图状态.动画帧ID) {
        cancelAnimationFrame(大地图状态.动画帧ID);
        大地图状态.动画帧ID = null;
    }
}

function 绘制大地图循环() {
    if (!大地图状态.可见) return;
    绘制大地图();
    大地图状态.动画帧ID = requestAnimationFrame(绘制大地图循环);
}


function 居中大地图(带动画) {
     if(大地图状态.当前查看楼层 != 当前层数) return;
    const 容器宽度 = 大地图画布容器.clientWidth;
    const 容器高度 = 大地图画布容器.clientHeight;
    const 单元格尺寸 = 16;
    
    const 目标平移X = 容器宽度 / 2 - (玩家.x + 0.5) * 单元格尺寸 * 大地图状态.缩放等级;
    const 目标平移Y = 容器高度 / 2 - (玩家.y + 0.5) * 单元格尺寸 * 大地图状态.缩放等级;

    if (带动画 && typeof gsap !== 'undefined') {
        gsap.to(大地图状态, {
            平移X: 目标平移X,
            平移Y: 目标平移Y,
            duration: 0.4,
            ease: 'power2.out'
        });
    } else {
        大地图状态.平移X = 目标平移X;
        大地图状态.平移Y = 目标平移Y;
    }
}

function 调整大地图缩放(缩放因子, 缩放中心X = null, 缩放中心Y = null) {
    const 容器 = 大地图画布容器;
    if(缩放中心X === null) 缩放中心X = 容器.clientWidth / 2;
    if(缩放中心Y === null) 缩放中心Y = 容器.clientHeight / 2;

    const 旧缩放等级 = 大地图状态.缩放等级;
    let 新缩放等级 = 旧缩放等级 * 缩放因子;
    新缩放等级 = Math.max(大地图状态.最小缩放, Math.min(大地图状态.最大缩放, 新缩放等级));
    
    const 实际缩放因子 = 新缩放等级 / 旧缩放等级;
    if (Math.abs(实际缩放因子 - 1) < 0.001) return;

    大地图状态.缩放等级 = 新缩放等级;
    
    const 鼠标世界X = (缩放中心X - 大地图状态.平移X) / 旧缩放等级;
    const 鼠标世界Y = (缩放中心Y - 大地图状态.平移Y) / 旧缩放等级;
    
    大地图状态.平移X = 缩放中心X - 鼠标世界X * 新缩放等级;
    大地图状态.平移Y = 缩放中心Y - 鼠标世界Y * 新缩放等级;
}
function 大地图拖拽移动(事件) {
    if (!大地图状态.拖拽中) return;
    事件.preventDefault();
    const 当前X = (事件.clientX || 事件.touches[0].clientX);
    const 当前Y = (事件.clientY || 事件.touches[0].clientY);
    const 偏移X = 当前X - 大地图状态.拖拽起始X;
    const 偏移Y = 当前Y - 大地图状态.拖拽起始Y;
    大地图状态.平移X = 大地图状态.上次平移X + 偏移X;
    大地图状态.平移Y = 大地图状态.上次平移Y + 偏移Y;
}

function 大地图拖拽结束(事件) {
    大地图状态.拖拽中 = false;
    大地图画布容器.style.cursor = 'grab';
}

function 大地图滚轮缩放(事件) {
    事件.preventDefault();
    const 缩放因子 = 事件.deltaY < 0 ? 1.1 : 1 / 1.1;
    const rect = 大地图画布容器.getBoundingClientRect();
    const 缩放中心X = 事件.clientX - rect.left;
    const 缩放中心Y = 事件.clientY - rect.top;
    调整大地图缩放(缩放因子, 缩放中心X, 缩放中心Y);
}

let 大地图上次触摸距离 = 0;
function 大地图触摸开始(事件) {
    if (事件.touches.length === 2) {
        事件.preventDefault();
        大地图状态.拖拽中 = false; 
        const t1 = 事件.touches[0];
        const t2 = 事件.touches[1];
        大地图上次触摸距离 = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
    } else if (事件.touches.length === 1) {
        大地图拖拽开始(事件);
    }
}

function 大地图触摸移动(事件) {
    if (事件.touches.length === 2) {
        事件.preventDefault();
        const t1 = 事件.touches[0];
        const t2 = 事件.touches[1];
        const 当前触摸距离 = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
        const 缩放因子 = 当前触摸距离 / 大地图上次触摸距离;
        大地图上次触摸距离 = 当前触摸距离;
        
        const rect = 大地图画布容器.getBoundingClientRect();
        const 中心X = (t1.clientX + t2.clientX) / 2 - rect.left;
        const 中心Y = (t1.clientY + t2.clientY) / 2 - rect.top;
        
        调整大地图缩放(缩放因子, 中心X, 中心Y);

    } else if (事件.touches.length === 1) {
        大地图拖拽移动(事件);
    }
}

function 大地图触摸结束(事件) {
     if (事件.touches.length < 2) {
        大地图上次触摸距离 = 0;
    }
    if (事件.touches.length < 1) {
        大地图拖拽结束(事件);
    }
}

function 大地图悬停信息(事件) {
    const rect = 大地图画布容器.getBoundingClientRect();
    const x = 事件.clientX - rect.left;
    const y = 事件.clientY - rect.top;

    const 单元格尺寸 = 16 * 大地图状态.缩放等级;
    const 世界X = Math.floor((x - 大地图状态.平移X) / (16 * 大地图状态.缩放等级));
    const 世界Y = Math.floor((y - 大地图状态.平移Y) / (16 * 大地图状态.缩放等级));

    const 房间ID = 房间地图[世界Y]?.[世界X];
    if (房间ID !== undefined && 房间ID !== -1 && (已访问房间.has(房间ID)||开发者模式||游戏状态=="地图编辑器")) {
        const room = 房间列表.find(r => r && r.id === 房间ID);
        if (room) {
            大地图状态.悬停信息 = `房间 ${room.id}: ${room.名称 || '未命名'} (${room.类型 || '普通'})`;
            return;
        }
    }
    大地图状态.悬停信息 = `(${世界X}, ${世界Y})`;
}

function 添加大地图事件监听() {
    大地图画布容器.addEventListener('mousedown', 大地图拖拽开始);
    window.addEventListener('mousemove', 大地图拖拽移动);
    window.addEventListener('mouseup', 大地图拖拽结束);
    大地图画布容器.addEventListener('wheel', 大地图滚轮缩放, { passive: false });
    
    大地图画布容器.addEventListener('touchstart', 大地图触摸开始, { passive: false });
    大地图画布容器.addEventListener('touchmove', 大地图触摸移动, { passive: false });
    大地图画布容器.addEventListener('touchend', 大地图触摸结束);
    大地图画布容器.addEventListener('mousemove', 大地图悬停信息);
}

function 移除大地图事件监听() {
    大地图画布容器.removeEventListener('mousedown', 大地图拖拽开始);
    window.removeEventListener('mousemove', 大地图拖拽移动);
    window.removeEventListener('mouseup', 大地图拖拽结束);
    大地图画布容器.removeEventListener('wheel', 大地图滚轮缩放);

    大地图画布容器.removeEventListener('touchstart', 大地图触摸开始);
    大地图画布容器.removeEventListener('touchmove', 大地图触摸移动);
    大地图画布容器.removeEventListener('touchend', 大地图触摸结束);
    大地图画布容器.removeEventListener('mousemove', 大地图悬停信息);
}

			function 玩家等待(是否由休息调用 = false) {
				if (玩家属性.允许移动 > 0 || 死亡界面已显示) {
					if (是否由休息调用) 停止休息();
					return;
				}
				if (!是否由休息调用) {
					移动历史.push('等待');
				}
				处理回合逻辑();
				更新视口();
				//绘制();
			}

			function 开始休息() {
				if (玩家正在休息 || 玩家属性.允许移动 > 0 || 死亡界面已显示) return;
				玩家正在休息 = true;
				显示通知("开始休息...", "信息");

				const 休息逻辑 = () => {
					if (!玩家正在休息) return;
					玩家等待(true);
					休息定时器 = setTimeout(休息逻辑, 移动间隔);
				};

				休息逻辑();
			}

			function 停止休息() {
				if (休息定时器) {
					clearTimeout(休息定时器);
					休息定时器 = null;
				}
				玩家正在休息 = false;
			}
			document.getElementById('背包整理按钮').addEventListener('click', () => {
					
					const inGameStates = ["游戏中", "编辑器游玩", "图鉴"];
    if (inGameStates.includes(游戏状态)) {
        整理背包();
    }
				});
			function 整理背包() {
				const 物品数组 = [...玩家背包.values()].filter(item => !item.是否隐藏);
				
				物品数组.sort((a, b) => {
					if (b.品质 !== a.品质) {
						return b.品质 - a.品质;
					}
					return 0; 
				});

				const 隐藏物品 = [...玩家背包.values()].filter(item => item.是否隐藏);

				玩家背包.clear();
				更新背包显示();

				物品数组.forEach(item => 玩家背包.set(item.唯一标识, item));
				隐藏物品.forEach(item => 玩家背包.set(item.唯一标识, item));
				更新背包显示()
				显示通知("背包已整理！", "成功");
			}
			
			function 油漆桶填充(x, y, 新背景类型) {
				if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return;

				const 原始背景类型 = 地牢[y][x].背景类型;
				if (原始背景类型 === 新背景类型) return;
				saveEditorState();

				const 队列 = [{x, y}];
				const 已访问 = new Set([`${x},${y}`]);

				while (队列.length > 0) {
					const 当前 = 队列.shift();
					
					if(新背景类型===单元格类型.墙壁) 重置单元格(当前.x, 当前.y);
					地牢[当前.y][当前.x].背景类型 = 新背景类型;
					


					const 方向 = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
					for (const {dx, dy} of 方向) {
						const 邻居X = 当前.x + dx;
						const 邻居Y = 当前.y + dy;
						const 邻居键 = `${邻居X},${邻居Y}`;
						if (邻居X >= 0 && 邻居X < 地牢大小 && 邻居Y >= 0 && 邻居Y < 地牢大小 &&
							地牢[邻居Y][邻居X].背景类型 === 原始背景类型 && !已访问.has(邻居键)) {
							已访问.add(邻居键);
							队列.push({x: 邻居X, y: 邻居Y});
						}
					}
				}
				生成墙壁();
				//绘制();
				
			}

			function 笔刷绘制(中心X, 中心Y) {
				if (!编辑器状态.当前选中 || 编辑器状态.当前选中.类型 !== '背景') return;
				//saveEditorState();

				const 尺寸 = 编辑器状态.笔刷半径;
				const 形状 = 编辑器状态.笔刷形状;
				const 新背景类型 = 编辑器状态.当前选中.绘制类型;

				const 左 = 中心X - 尺寸 + 1;
				const 右 = 中心X + 尺寸 - 1;
				const 上 = 中心Y - 尺寸 + 1;
				const 下 = 中心Y + 尺寸 - 1;

				for (let y = 上; y <= 下; y++) {
					for (let x = 左; x <= 右; x++) {
						if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;

						let 在范围内 = false;
						if (形状 === '圆形') {
							const dx = x - 中心X;
							const dy = y - 中心Y;
							if (dx * dx + dy * dy < 尺寸 * 尺寸) {
								在范围内 = true;
							}
						} else {
							在范围内 = true;
						}
						
						if (在范围内) {
							if(新背景类型===单元格类型.墙壁) 重置单元格(x, y);
							地牢[y][x].背景类型 = 新背景类型;
							
						}
					}
				}
			
				//生成墙壁();
				//绘制();
			}
			function handleCanvasTouchStart(e) {
				e.preventDefault();
				const touch = e.touches[0];
				touchStartX = touch.clientX;
				touchStartY = touch.clientY;
				touchCurrentX = touch.clientX;
				touchCurrentY = touch.clientY;
				touchStartTime = Date.now();
				if(游戏状态 !== '地图编辑器') {
					isSwiping = true;

					const rect = canvas.getBoundingClientRect();
					const touchX = touch.clientX - rect.left;
					const touchY = touch.clientY - rect.top;
					const 单元格X = Math.floor(当前相机X + touchX / 单元格大小);
					const 单元格Y = Math.floor(当前相机Y + touchY / 单元格大小);

					if (单元格X === 玩家.x && 单元格Y === 玩家.y) {
						if (等待触摸定时器) clearTimeout(等待触摸定时器);
						等待触摸定时器 = setTimeout(() => {
							if (isSwiping && Math.abs(touchCurrentX - touchStartX) < 10 && Math.abs(touchCurrentY - touchStartY) < 10) {
								玩家等待();
								isSwiping = false; 
								clearTimeout(等待触摸定时器);
								等待触摸定时器 = null;
							}
						}, 700);
					}
				}

				if (swipeMoveInterval) {
					clearInterval(swipeMoveInterval);
					swipeMoveInterval = null;
				}
			}

			function handleCanvasTouchMove(e) {
				e.preventDefault();
				if(等待触摸定时器 && (Math.abs(e.touches[0].clientX - touchStartX) > 10 || Math.abs(e.touches[0].clientY - touchStartY) > 10)){
					clearTimeout(等待触摸定时器);
					等待触摸定时器 = null;
				}
				if (!isSwiping) return;

				const touch = e.touches[0];
				touchCurrentX = touch.clientX;
				touchCurrentY = touch.clientY;

				if (swipeMoveInterval === null) {
					processSwipeMove();
					swipeMoveInterval = setInterval(processSwipeMove, 移动间隔);
				}
			}

			function handleCanvasTouchEnd(e) {
				e.preventDefault();
				if(等待触摸定时器){
					clearTimeout(等待触摸定时器);
					等待触摸定时器 = null;
				}
				if (!isSwiping) return;

				isSwiping = false;
				clearInterval(swipeMoveInterval);
				swipeMoveInterval = null;

				const touch = e.changedTouches[0];
				const touchEndX = touch.clientX;
				const touchEndY = touch.clientY;
				const touchEndTime = Date.now();

				const deltaX = touchEndX - touchStartX;
				const deltaY = touchEndY - touchStartY;
				const duration = touchEndTime - touchStartTime;
				const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

				if (distance < swipeThreshold) {
					处理点击(touchEndX, touchEndY);
				}

				touchStartX = 0;
				touchStartY = 0;
			}

			function processSwipeMove() {
				if (!isSwiping) {
					clearInterval(swipeMoveInterval);
					swipeMoveInterval = null;
					return;
				}

				const deltaX = touchCurrentX - touchStartX;
				const deltaY = touchCurrentY - touchStartY;

				if (Math.abs(deltaX) < swipeThreshold && Math.abs(deltaY) < swipeThreshold) {
					return; // 未达到移动阈值
				}

				let moveDx = 0;
				let moveDy = 0;

				if (Math.abs(deltaX) > Math.abs(deltaY)) {
					moveDx = deltaX > 0 ? 1 : -1;
				} else {
					moveDy = deltaY > 0 ? 1 : -1;
				}

				移动玩家(moveDx * 玩家属性.移动步数, moveDy * 玩家属性.移动步数);
			}

			canvas.addEventListener("touchstart", handleCanvasTouchStart);
			canvas.addEventListener("touchmove", handleCanvasTouchMove);
			canvas.addEventListener("touchend", handleCanvasTouchEnd);
			canvas.addEventListener("touchcancel", handleCanvasTouchEnd); // 处理触摸取消事件
			canvas.addEventListener("click", 处理地图单击);
			function 注册全局类() {
			    // --- 基础类 ---
			    window.门 = 门;
			    window.物品 = 物品;
			    window.怪物 = 怪物;
			    window.单元格 = 单元格;
			    window.状态效果 = 状态效果;
			    window.红蓝开关 = 红蓝开关;
			    window.红砖块 = 红砖块;
			    window.蓝砖块 = 蓝砖块;
			    window.刷怪笼 = 刷怪笼;
			    window.传送带 = 传送带;
			    window.巡逻怪物 = 巡逻怪物;
			    window.同步怪物 = 同步怪物;
			    window.绿紫开关 = 绿紫开关;
			    window.绿砖块 = 绿砖块;
			    window.紫砖块 = 紫砖块;
			    window.沉浸式传送门 = 沉浸式传送门;
			    window.卷轴滚动墙 = 卷轴滚动墙;
			
			    // --- 物品子类 ---
			    window.钥匙 = 钥匙;
			    window.金币 = 金币;
			    window.武器类 = 武器类;
			    window.卷轴类 = 卷轴类;
			    window.防御装备类 = 防御装备类;
			    window.棋子 = 棋子;
			    window.药水类 = 药水类;
			    window.宠物 = 宠物;
			    window.重铸台 = 重铸台;
			    window.神秘商人 = 神秘商人;
			    window.探险家 = 探险家;
			    window.祭坛类 = 祭坛类;
			    window.物品祭坛 = 物品祭坛;
			    window.耐久祭坛 = 耐久祭坛;
			    window.背包扩容祭坛 = 背包扩容祭坛;
			    window.寻宝戒指 = 寻宝戒指;
			    window.折跃门 = 折跃门;
			    window.传送门 = 传送门;
			    window.炸弹 = 炸弹;
			    window.旋风物品 = 旋风物品;
			    window.火焰物品 = 火焰物品;
			    window.火把 = 火把;
			    window.毒液物品 = 毒液物品;
			    window.罐子 = 罐子;
			    window.空罐子 = 空罐子;
			    window.泉水 = 泉水;
			    window.书架 = 书架;
			    window.神龛 = 神龛;
			    window.照明弹光源 = 照明弹光源;
			    window.挑战石碑 = 挑战石碑;
			    window.洗身砚 = 洗身砚;
			    window.陷阱基类 = 陷阱基类;
			    window.隐形落石陷阱 = 隐形落石陷阱;
			    window.隐形地刺陷阱 = 隐形地刺陷阱;
			    window.隐形毒气陷阱 = 隐形毒气陷阱;
			    window.远射陷阱 = 远射陷阱;
			    window.隐形失明陷阱 = 隐形失明陷阱;
			    window.召唤怪物陷阱 = 召唤怪物陷阱;
			    window.烈焰触发陷阱 = 烈焰触发陷阱;
			    window.隐形虫洞陷阱 = 隐形虫洞陷阱;
			    window.便携障碍物 = 便携障碍物;
			    window.已放置的障碍物 = 已放置的障碍物;
			    window.旗帜 = 旗帜;
			    window.临时墙壁计时器 = 临时墙壁计时器;
			    window.告示牌 = 告示牌;
			    window.存档点 = 存档点;
			    window.磨刀石 = 磨刀石;
			    window.急救绷带 = 急救绷带;
			    window.照明弹 = 照明弹;
			    window.万能钥匙 = 万能钥匙;
			    window.奖杯物品 = 奖杯物品;
			    window.开关脉冲器 = 开关脉冲器;
			    window.磁铁 = 磁铁;
			    window.蛛网 = 蛛网;
                window.烟雾弹 = 烟雾弹;
                window.烟雾 = 烟雾;
                window.定位器地图 = 定位器地图;
                window.时空罗盘 = 时空罗盘;
			
			    // --- 武器具体子类 ---
			    window.吸血剑 = 吸血剑;
			    window.冰霜法杖 = 冰霜法杖;
			    window.重力锤 = 重力锤;
			    window.剧毒匕首 = 剧毒匕首;
			    window.荆棘鞭 = 荆棘鞭;
			    window.回旋镖 = 回旋镖;
			    window.闪电链法杖 = 闪电链法杖;
			    window.大地猛击锤 = 大地猛击锤;
			    window.穿云箭 = 穿云箭;
			    window.钢制长剑 = 钢制长剑;
			    window.橡木法杖 = 橡木法杖;
			    window.金币手枪 = 金币手枪;
			    window.狙击金币枪 = 狙击金币枪;
			    window.喷火枪 = 喷火枪;
			    window.引雷针护符 = 引雷针护符;
			    window.荆棘种子 = 荆棘种子;
			    window.荆棘丛 = 荆棘丛;
			    window.能量熔炉 = 能量熔炉;
			    window.恐惧魔杖 = 恐惧魔杖;
			    window.斜方刀 = 斜方刀;
			    window.冲撞牛角 = 冲撞牛角;
			    window.护卫种子 = 护卫种子;
			    window.护卫植物 = 护卫植物;
			    window.远射种子 = 远射种子;
			    window.远射植物 = 远射植物;
			    window.能量草 = 能量草;
			    window.吸能种子 = 吸能种子;
			    window.魔法师法杖 = 魔法师法杖;
			    window.大师附魔卷轴 = 大师附魔卷轴;
			    window.小书魔 = 小书魔;
			    window.符文圈 = 符文圈;
			    window.调试工具 = 调试工具;
			    window.渔网 = 渔网;
			    window.渔网陷阱 = 渔网陷阱;
			    window.充能魔杖 = 充能魔杖;
			    window.魔力远射植物 = 魔力远射植物;
			    window.时间卷轴 = 时间卷轴;
			    window.潜行靴子 = 潜行靴子;
			    window.钩索 = 钩索;
			    window.嗜血战斧 = 嗜血战斧;
			    window.毒气瓶 = 毒气瓶;
			    window.毒气 = 毒气;
			    window.陨石法杖 = 陨石法杖;
			    window.神偷手 = 神偷手;
			    window.追踪风弹 = 追踪风弹;
			    window.扫帚=扫帚;
			    window.守卫者盔甲 = 守卫者盔甲;
			    window.死灵法杖 = 死灵法杖;
			
			    // --- 防御装具体子类 ---
			    window.秘银锁甲 = 秘银锁甲;
			    window.钢制板甲 = 钢制板甲;
			    window.锅盖 = 锅盖;
			    window.灵能盾牌 = 灵能盾牌;
			    window.冰盾 = 冰盾;
			
			    // --- 卷轴具体子类 ---
			    window.迅捷卷轴 = 迅捷卷轴;
			    window.神秘卷轴 = 神秘卷轴;
			    window.贪婪卷轴 = 贪婪卷轴;
			    window.清净卷轴 = 清净卷轴;
			    window.附魔卷轴 = 附魔卷轴;
			    window.跃迁卷轴 = 跃迁卷轴;
			    window.真言卷轴 = 真言卷轴;
			    window.湮灭卷轴 = 湮灭卷轴;
			    window.配方卷轴 = 配方卷轴;
			    window.易位卷轴 = 易位卷轴;
			    
			    // --- 饰品具体子类 ---
			    window.饰品 = 饰品;
			    window.陷阱先锋饰品 = 陷阱先锋饰品;
			    window.飞毛腿饰品 = 飞毛腿饰品;
			    window.瞬间移动饰品 = 瞬间移动饰品;
			    window.博士之卷饰品 = 博士之卷饰品;
			    window.恢复之心饰品 = 恢复之心饰品;
			    window.以牙还牙饰品 = 以牙还牙饰品;
			    window.嗅探之鼻饰品 = 嗅探之鼻饰品;
			    
			
			    // --- 药水具体子类 ---
			    window.治疗药水 = 治疗药水;
			    window.能量药水 = 能量药水;
			    window.狂暴药水 = 狂暴药水;
			    window.神龟药水 = 神龟药水;
			    window.隐身药水 = 隐身药水;
			    window.透视药水 = 透视药水;
			
			    // --- 棋子具体子类 ---
			    window.国际象棋车 = 国际象棋车;
			    window.国际象棋马 = 国际象棋马;
			    window.国际象棋象 = 国际象棋象;
			    window.中国象棋炮 = 中国象棋炮;
			
			    // --- 宠物具体子类 ---
			    window.熊猫 = 熊猫;
			    window.水母 = 水母;
			    window.火蜥蜴 = 火蜥蜴;
			    window.魔法水晶 = 魔法水晶;
			
			    // --- 怪物子类 ---
			    window.魔法师 = 魔法师;
			    window.大魔法师 = 大魔法师;
			    window.腐蚀怪物 = 腐蚀怪物;
			    window.盗贼怪物 = 盗贼怪物;
			    window.吸能怪物 = 吸能怪物;
			    window.剧毒云雾怪物 = 剧毒云雾怪物;
			    window.召唤师怪物 = 召唤师怪物;
			    window.幽灵仆从 = 幽灵仆从;
			    window.萨满怪物 = 萨满怪物;
			    window.大史莱姆怪物 = 大史莱姆怪物;
			    window.小史莱姆怪物 = 小史莱姆怪物;
			    window.瞬移怪物 = 瞬移怪物;
			    window.伪装怪物 = 伪装怪物;
			    window.炸弹怪物 = 炸弹怪物;
			    window.盔甲怪物 = 盔甲怪物;
			    window.敏捷怪物 = 敏捷怪物;
			    window.远攻怪物 = 远攻怪物;
			    window.仙人掌怪物 = 仙人掌怪物;
			    window.冰冻怪物 = 冰冻怪物;
			    window.旋风怪物 = 旋风怪物;
			    window.幽灵怪物 = 幽灵怪物;
			    window.旋风 = 旋风;
			    window.恐惧怪物 = 恐惧怪物;
			    window.米诺陶 = 米诺陶;
			    window.超速怪物 = 超速怪物;
			    window.复活怪物 = 复活怪物;
			    window.娃娃怪物 = 娃娃怪物;
			    window.吸血鬼 = 吸血鬼;
			    window.皇家守卫 = 皇家守卫;
			    window.王座守护者 = 王座守护者;
			    window.墓碑 = 墓碑
			    window.分裂怪物 = 分裂怪物;
			    window.巨人怪物 = 巨人怪物;
			    window.巨人部位 = 巨人部位;
			    window.移动弹幕=移动弹幕;
			    window.蜘蛛怪物=蜘蛛怪物;
			    window.骷髅仆从 = 骷髅仆从;
			    window.反弹怪物=反弹怪物;
			    window.蜈蚣怪物 = 蜈蚣怪物;
                window.蜈蚣部位 = 蜈蚣部位;
			}
			           function 获取所有可用的定义() {
			    const 所有物品 = [];
			    const 所有怪物 = [];
			    const 已见物品名 = new Set();
			    const 已见怪物类型 = new Set();
			
			    const 物品池 = 创建物品池();
			    for (const 物品类别 of Object.values(物品池)) {
			        for (const 配置 of 物品类别) {
			            try {
			                const 实例 = new 配置.类({玩家放置:true});
			                if (实例.名称 && !已见物品名.has(实例.名称)) {
			                    所有物品.push(配置);
			                    已见物品名.add(实例.名称);
			                } 
			            } catch (错误) {}
			        }
			    }
			
			    const 怪物池 = 创建怪物池();
			    for (const 怪物类别 of Object.values(怪物池)) {
			        for (const 配置 of 怪物类别) {
			            try {
			                const 实例 = new 配置.类({玩家放置:true});
			                if (实例.类型 && !已见怪物类型.has(实例.类型)) {
			                    所有怪物.push(配置);
			                    已见怪物类型.add(实例.类型);
			                }
			            } catch (错误) {}
			        }
			    }
			
			    const 特殊物品 = [
			        { 类: 渔网陷阱, 品质: 1 }, { 类: 荆棘丛, 品质: 1 },
			        { 类: 火焰物品, 品质: 1 }, { 类: 毒液物品, 品质: 1 },
			        { 类: 旋风物品, 品质: 1 }, { 类: 小书魔, 品质: 4 },
			        { 类: 护卫植物, 品质: 2 },
			        { 类: 远射植物, 品质: 3 }, { 类: 能量草, 品质: 2 },
			        { 类: 大师附魔卷轴, 品质: 5 },
			        { 类: 泉水, 品质: 4 }, { 类: 书架, 品质: 2 },
			        { 类: 灵能盾牌, 品质: 3 }, { 类: 配方卷轴, 品质: 2 },
			        { 类: 国际象棋车, 品质: 1 }, { 类: 国际象棋马, 品质: 1 },
			        { 类: 国际象棋象, 品质: 1 }, { 类: 中国象棋炮, 品质: 1 },
			        { 类: 冲撞牛角, 品质: 5 }, { 类: 魔法师法杖, 品质: 5 },
			
			{ 类: 已放置的障碍物, 品质: 1 },
			{ 类: 传送门, 品质: 5 },
			{ 类: 隐形落石陷阱, 品质: 2 },
			{ 类: 隐形地刺陷阱, 品质: 2 },
			{ 类: 隐形毒气陷阱, 品质: 2 },
			{ 类: 隐形失明陷阱, 品质: 3 },
			{ 类: 召唤怪物陷阱, 品质: 3 },
			{ 类: 烈焰触发陷阱, 品质: 4 },
			{ 类: 隐形虫洞陷阱, 品质: 4 },
			{ 类: 旗帜, 品质: 5 },
			{ 类: 钥匙, 品质: 1 },
			{ 类: 金币, 品质: 1 },
			    ];
			
			    for (const 配置 of 特殊物品) {
			        try {
			            const 实例 = new 配置.类({});
			            if (实例.名称 && !已见物品名.has(实例.名称)) {
			                所有物品.push(配置);
			                已见物品名.add(实例.名称);
			            }
			        } catch (错误) {}
			    }
			
			    const 特殊怪物 = [
			        { 类: 大魔法师, 权重: 5,最小层:10}, { 类: 米诺陶, 权重: 5,最小层:5 },{ 类: 远射陷阱, 权重: 12,最小层:5 },
			        { 类: 小史莱姆怪物, 权重: 11,最小层:5}, { 类: 幽灵仆从, 权重: 11,最小层:5},
			        { 类: 旋风, 权重: 11,最小层:5 }, { 类: 王座守护者, 权重: 1,最小层:15},{ 类: 幽灵怪物, 权重: 12,最小层:5 },{ 类: 巡逻怪物, 权重: 10,最小层:5 },{ 类: 同步怪物, 权重: 10,最小层:5 }
			    ];
			
			    for (const 配置 of 特殊怪物) {
			        try {
			            const 实例 = new 配置.类({});
			            if (实例.类型 && !已见怪物类型.has(实例.类型)) {
			                所有怪物.push(配置);
			                已见怪物类型.add(实例.类型);
			            }
			        } catch (错误) {}
			    }
			
			    return { items: 所有物品, monsters: 所有怪物 };
			}

const 版本信息元素 = document.getElementById("版本信息");
if (版本信息元素) {
    版本信息元素.style.cursor = 'pointer';
    版本信息元素.addEventListener('click', () => {
        versionClickCount++;
        if (versionClickCount >= 7 && !开发者模式) {
            开发者模式 = true;
            显示通知("开发者模式已开启！", "成功", true);
            版本信息元素.style.color = '#4caf50';
            版本信息元素.style.fontWeight = 'bold';
            版本信息元素.textContent += ' (Dev)';
        } else if (!开发者模式) {
            const 剩余点击次数 = 7 - versionClickCount;
            if(剩余点击次数<=3) 显示通知(`再点击 ${剩余点击次数} 次即可开启开发者模式。`, "信息");
            // 进行一个视觉反馈的提供
            gsap.fromTo(版本信息元素, { scale: 1.2 }, { scale: 1, duration: 0.3, ease: 'elastic.out(1, 0.5)' });
        }
    });
}
			function 处理地图点击(e) {
			    e.preventDefault();
			    const touch = e.touches[0];
			    处理点击(touch.clientX, touch.clientY);
			}
			
			function 处理地图单击(e) {
			    处理点击(e.clientX, e.clientY);
			}
			
			//来源对象需要提供应用效果与移除效果（可选）函数
			class 状态效果 {
			    constructor(
			        类型,
			        颜色,
			        图标,
			        持续时间,
			        剩余回合 = null,
			        来源 = null,
			        关联怪物 = null,
			        强度 = 1
			    ) {
			        this.类型 = 类型;
			        this.剩余回合 = 剩余回合 || 持续时间;
			        this.来源 = 来源;
			        this.持续时间 = 持续时间;
			        this.关联怪物 = 关联怪物;
			        this.颜色 = 颜色;
			        this.图标 = 图标;
			        this.强度 = 强度;
			
			        if (!this.关联怪物) {
			            const 现有效果 = 玩家状态.find(
			                (item) => item.类型 === this.类型
			            );
			            if (现有效果) {
			                现有效果.剩余回合 = Math.max(
			                    现有效果.剩余回合,
			                    this.剩余回合
			                );
			                现有效果.强度 = Math.min(
			                    5,
			                    (现有效果.强度 || 1) + (this.强度 || 1)
			                );
			                现有效果.持续时间 = Math.max(
			                    现有效果.持续时间,
			                    this.持续时间
			                );
			                现有效果.进度条实例?.更新({
			                    数值:
			                        (现有效果.剩余回合 / 现有效果.持续时间) *
			                        100,
			                    标签:
			                        `${现有效果.类型} ${现有效果.剩余回合}回合` +
			                        (现有效果.强度 > 1
			                            ? ` (强度 ${现有效果.强度})`
			                            : ""),
			                });
			                return;
			            }
			
			            玩家状态.push(this);
			            this.进度条实例 = new 进度条元素({
			                图标: 图标,
			                颜色: 颜色,
			                初始值: 100,
			                标签:
			                    `${this.类型} ${this.剩余回合}回合` +
			                    (this.强度 > 1 ? ` (强度 ${this.强度})` : ""),
			            });
			            this.来源?.应用效果();
			        } else {
			            const 现有怪物效果 = 怪物状态表.get(this.关联怪物);
			            if (现有怪物效果 && 现有怪物效果.类型 === this.类型) {
			                现有怪物效果.剩余回合 = Math.max(
			                    现有怪物效果.剩余回合,
			                    this.剩余回合
			                );
			                现有怪物效果.强度 = Math.min(
			                    5,
			                    (现有怪物效果.强度 || 1) + (this.强度 || 1)
			                );
			                this.关联怪物.获得效果(现有怪物效果);
			                this.更新状态();
			                this.剩余回合++;
			                return;
			            }
			            怪物状态表.set(this.关联怪物, this);
			            this.关联怪物.获得效果(this);
			        }
			    }
			    更新状态() {
			        let 剩余回合 = this.剩余回合;
			        剩余回合 = Math.max(0, 剩余回合 - 1);
			        this.剩余回合 = 剩余回合;
			
			        if (this.类型 === "中毒" && !this.关联怪物) {
			            伤害玩家(this.强度 || 1, "中毒");
			            添加日志(`你受到 ${this.强度 || 1} 点中毒伤害`, "错误");
			        }
			        if (this.类型 === "火焰" && !this.关联怪物) {
			            
			            Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).forEach(装备 => {
			                if (装备.材质 === 材料.木质 && 装备.自定义数据?.has("耐久") && !装备.自定义数据.get("不可破坏")) {
			                    伤害玩家(this.强度 || 1, "火焰");
			                    const 原耐久 = 装备.自定义数据.get("耐久");
			                    const 新耐久 = Math.max(0, 原耐久 - 1);
			                    装备.自定义数据.set("耐久", 新耐久);
			                    if (原耐久 > 0 && 新耐久 === 0) {
			                        处理销毁物品(装备.唯一标识, true);
			                        显示通知(`${装备.获取名称()} 被火焰烧毁了！`, "错误");
			                    }
			                }
			            });
			            处理燃烧木质卷轴();
			            伤害玩家(this.强度 || 1, "火焰"); // 使用强度作为伤害
			            添加日志(
			                `你被火焰灼烧，受到 ${this.强度 || 1} 点伤害`,
			                "错误"
			            );
			            更新装备显示();
			        }
			        if (
			            this.类型 === "冻结" &&
			            玩家状态.some((s) => s.类型 === "火焰")
			        ) {
			            this.剩余回合--;
			        }
			        if (!this.关联怪物) {
			            const 百分比 = (剩余回合 / this.持续时间) * 100;
			            this.进度条实例?.更新({
			                数值: 百分比,
			                标签:
			                    `${this.类型} ${剩余回合}回合` +
			                    (this.强度 > 1 ? ` (强度 ${this.强度})` : ""),
			            });
			        }
			
			        if (剩余回合 === 0) {
			            this.移除状态();
			        } else {
			            this.来源?.应用效果();
			        }
			    }
			    移除状态() {
			        this.来源?.移除效果();
			
			        if (!this.关联怪物) {
			            玩家状态 = 玩家状态.filter((item) => item !== this);
			        } else {
			            if (怪物状态表.get(this.关联怪物) === this) {
			                怪物状态表.delete(this.关联怪物);
			            }
			        }
			        if (this.进度条实例) {
			            this.进度条实例.销毁();
			            this.进度条实例 = null;
			        }
			        return;
			    }
			}
			let 旧编辑器状态
			//处理canvas的点击
			function 处理点击(clientX, clientY) {
			
			
			        if (游戏状态 !== "游戏中" && 游戏状态 !== "图鉴" && 游戏状态 !== "地图编辑器" && 游戏状态 !== "编辑器游玩") return;
			    
			        if (物品点击监听器) {
			物品点击监听器(clientX, clientY);
			return;
			        }
			    
			        if (界面可见性.背包) {
			切换背包显示();
			document.getElementById("浮动提示框").style.display = "none";
			return;
			        } else if (教程提示已显示) {
			关闭教程提示();
			return;
			        } else if (document.getElementById("设置菜单").classList.contains("显示")) {
			切换设置菜单();
			return;
			        } else if (document.getElementById("教程回放窗口").style.display === "block") {
			关闭教程回放窗口();
			return;
			        }
			
			        if (玩家正在放置障碍物) {
			const rect = canvas.getBoundingClientRect();
			const x = clientX - rect.left;
			const y = clientY - rect.top;
			const gridX = 视口偏移X + Math.floor(x / 单元格大小);
			const gridY = 视口偏移Y + Math.floor(y / 单元格大小);
			    
			if (位置是否可用(gridX, gridY)) {
			    const 障碍物实例 = new 已放置的障碍物({});
			    if (放置物品到单元格(障碍物实例, gridX, gridY)) {
			        显示通知("成功放置障碍物！", "成功");
			        const 物品源 = [...玩家背包.values()].find(i => i instanceof 便携障碍物);
			        if (物品源) {
			            物品源.堆叠数量--;
			            if(物品源.堆叠数量 <= 0) {
			                处理销毁物品(物品源.唯一标识, true);
			            }
			            更新背包显示();
			            更新装备显示();
			        }
			    } else {
			        显示通知("无法在此处放置障碍物！", "错误");
			    }
			} else {
			    显示通知("无法在此处放置障碍物！", "错误");
			}
			玩家正在放置障碍物 = false;
			return;
			        }
			        if (游戏状态 === "地图编辑器") return;
			        if (游戏设置.禁用点击移动) return;
			        const rect = canvas.getBoundingClientRect();
			        const x = clientX - rect.left;
			        const y = clientY - rect.top;
			    
			        const gridX = 视口偏移X + Math.floor(x / 单元格大小);
			        const gridY = 视口偏移Y + Math.floor(y / 单元格大小);
			    
			        const 全路径 = 广度优先搜索路径(
			玩家.x,
			玩家.y,
			gridX,
			gridY,
			30,
			true
			        );
			        const 截断路径 = [];
			        for (const 节点 of 全路径) {
			const 房间ID = 房间地图[节点.y][节点.x];
			if (房间ID !== -1 && !已访问房间.has(房间ID)) {
			    截断路径.push(节点);
			    break;
			}
			截断路径.push(节点);
			        }
			        截断路径.shift();
			        if (截断路径.length > 0) {
			moveQueue = 截断路径;
			startAutoMove();
			        }
			    }
			
			class 门 {
			    constructor(配置) {
			        this.唯一标识 = Symbol(
			            Date.now().toString() + prng().toString()
			        );
			        this.类型 = "门"; //常驻类型
			        this.是否上锁 = false;
			        this.房间ID = 配置.关联房间ID;
			        this.所在位置 = 配置.位置; // {x, y}
			
			        // 自动注册到全局列表
			        门实例列表.set(this.唯一标识, this); // 注册逻辑
			    }
			
			    尝试解锁(玩家背包) {
			        return [...玩家背包.values()].some((item) =>
			            item.可交互目标(this)
			        );
			    }
			}
			// 生成玩家实际路径距离图?什么是效率问题,我不懂
			    function 生成玩家距离图(玩家X, 玩家Y) {
			        const 距离图 = Array.from({ length: 地牢大小 }, () =>
			            Array(地牢大小).fill(Infinity)
			        );
			        const 队列 = [];
			        const 方向映射表 = [
			            { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
			            { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
			            { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
			            { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
			        ];
			
			        // 初始化玩家起始位置
			        距离图[玩家Y][玩家X] = 0;
			        队列.push({ x: 玩家X, y: 玩家Y });
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			
			            方向映射表.forEach((方向) => {
			                const 新X = 当前.x + 方向.dx;
			                const 新Y = 当前.y + 方向.dy;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    return;
			
			                const 当前单元格 = 地牢[当前.y][当前.x];
			                const 目标单元格 = 地牢[新Y][新X];
			
			                // 使用与怪物相同的移动规则
			                if (
			                    当前单元格.墙壁[方向.当前墙] ||
			                    目标单元格.墙壁[方向.目标墙] ||
			                    目标单元格.背景类型 === 单元格类型.墙壁 ||
			                    目标单元格.背景类型 === 单元格类型.上锁的门 ||
			                    (目标单元格.关联物品 && (目标单元格.关联物品 instanceof 已放置的障碍物 || (目标单元格.关联物品.类型 === '开关砖' && 目标单元格.关联物品.阻碍怪物)))
			                )
			                    return;
			
			                // 找到更短路径
			                if (距离图[新Y][新X] > 距离图[当前.y][当前.x] + 1) {
			                    距离图[新Y][新X] = 距离图[当前.y][当前.x] + 1;
			                    队列.push({ x: 新X, y: 新Y });
			                }
			            });
			        }
			
			        return 距离图;
			    }
			class 怪物 {
			    constructor(配置 = {}) {
			        this.房间ID =
			            配置.房间ID === undefined ? null : 配置.房间ID;
			        this.x = 配置.x === undefined ? null : 配置.x;
			        this.y = 配置.y === undefined ? null : 配置.y;
			        this.目标路径 = [];
			        this.状态 = 配置.状态 || 怪物状态.休眠;
			        this.基础生命值 = 配置.基础生命值 || 23;
			        this.基础攻击力 = 配置.基础攻击力 || 3;
			        this.移动率 = 配置.移动率 || 0.7;
			        this.图标 = 配置.图标 || 图标映射.怪物;
			        this.类型 = 配置.类型 || "怪物";
			        this.掉落物 =
			            配置.掉落物 ||
			            new 金币({ 数量: Math.floor(prng() * 5) + 1 });
			        this.掉落概率 = 配置.掉落概率 ?? 0.9,
			        this.血条元素 = null;
			        this.受击动画 = false;
			        this.基础攻击范围 = 配置.基础攻击范围 || 1;
			        this.受伤冻结回合 = 配置.受伤冻结回合 || 1;
			        this.基础移动距离 = 配置.基础移动距离 || 1;
			        this.始终追踪玩家 = 配置.始终追踪玩家 || false;
			        this.跟踪距离 = (配置.跟踪距离+(地牢生成方式=='maze'?10:0)) || (15+(地牢生成方式=='maze'?10:0));
			        this.基础颜色 = 配置.颜色 || "#FFFFFF";
			        this.强化 = 配置.强化 || false;
			        this.当前生命值 = 配置.当前生命值 || this.生命值;
			        this.攻击冷却 = 配置.攻击冷却 || 0;
			        this.受伤冻结回合剩余 = 0;
			        this.攻击冷却回合剩余 = 0;
			        this.当前格 = 配置.当前格 ?? null;
			        if (
			            this.房间ID === null &&
			            this.y !== null &&
			            this.x !== null
			        ) {
			            this.房间ID = 房间地图[this.y][this.x];
			        }
			        this.仇恨 = null;
			        this.残血逃跑 = 配置.残血逃跑 ?? true
			        this.携带药水 = 配置.携带药水 || null;
			        this.永久增益 = 配置.永久增益 || [];
			        this.战斗爽 = null;
			    }
			
			    尝试使用药水() {
			    if (!this.携带药水) return false;
			    const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			    const 视野范围 = Math.floor(相机显示边长 / 2) + 3;
			    if (玩家距离 > 视野范围) return false;
			
			    if (this.药水使用冷却 === undefined) {
			        this.药水使用冷却 = 2;
			    }
			    if (this.药水使用冷却 > 0) {
			        this.药水使用冷却--;
			        return false;
			    }
			
			    let 使用时机 = false;
			    const 药水类型 = this.携带药水.类型;
			
			    if (药水类型 === '一次性治疗' && this.当前生命值 / this.生命值 < 0.2) {
			        使用时机 = true;
			        this.当前生命值 = Math.min(this.生命值, this.当前生命值 + this.携带药水.值);
			        添加日志(`${this.类型} 使用了治疗药水，恢复了 ${this.携带药水.值} 点生命！`, '警告');
			        计划显示格子特效([{ x: this.x, y: this.y }], '00FF00');
			    } else if (药水类型 === '永久强化' && !this.强化 && this.当前生命值 / this.生命值 < 0.7) {
			        使用时机 = true;
			        this.强化 = true;
			        this.当前生命值 = this.生命值;
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标, 值: this.携带药水.值 });
			        添加日志(`${this.类型} 使用了强化药水，变得更强了！`, '警告');
			        计划显示格子特效([{ x: this.x, y: this.y }], 'FF0000');
			    } else if (药水类型 === '永久隐身' && this.当前生命值 / this.生命值 < 0.4 && !this.永久增益.some(b => b.类型 === '永久隐身')) {
			        使用时机 = true;
			        this.图标 = ' ';
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标 });
			        添加日志(`${this.类型} 使用了隐身药水，消失了！`, '警告');
			    } else if (药水类型 === '永久速度' && 玩家距离 > this.跟踪距离 / 2 && !this.永久增益.some(b => b.类型 === '永久速度')) {
			        使用时机 = true;
			        this.永久增益.push({ 类型: '永久速度', 图标: this.携带药水.图标, 值: this.携带药水.值 });
			        添加日志(`${this.类型} 使用了速度药水，移动更快了！`, '警告');
			    } else if (药水类型 === '永久抗火' && 怪物状态表.get(this)?.类型 === '火焰' && !this.永久增益.some(b => b.类型 === '永久抗火')) {
			        使用时机 = true;
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标 });
			        怪物状态表.get(this).移除状态();
			        添加日志(`${this.类型} 获得了永久火焰抗性！`, '警告');
			    } else if (药水类型 === '永久抗毒' && 怪物状态表.get(this)?.类型 === '中毒' && !this.永久增益.some(b => b.类型 === '永久抗毒')) {
			        使用时机 = true;
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标 });
			        怪物状态表.get(this).移除状态();
			        添加日志(`${this.类型} 获得了永久剧毒抗性！`, '警告');
			    } else if (药水类型 === '永久解冻' && 怪物状态表.get(this)?.类型 === '冻结' && !this.永久增益.some(b => b.类型 === '永久解冻')) {
			        使用时机 = true;
			        怪物状态表.get(this)?.移除状态();
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标 });
			        怪物状态表.get(this).移除状态();
			        添加日志(`${this.类型} 解除了冻结并获得了永久抗性！`, '警告');
			    } else if (药水类型 === '永久力量' && !this.永久增益.some(b => b.类型 === '永久力量')) {
			        使用时机 = true;
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标, 值: this.携带药水.值 });
			        添加日志(`${this.类型} 的力量永久增强了！`, '警告');
			    }
			
			    if (使用时机) {
			        this.携带药水 = null;
			        this.绘制血条();
			        return true;
			    }
			    return false;
			}
			
			尝试逃跑() {
			    if (this.当前生命值 / this.生命值 > 0.3 || !this.残血逃跑) {
			        this.目标陷阱 = null
			        return false;
			    }
			    if (this.战斗爽 === null) {
			        if (prng()<0.5) {
			            this.战斗爽=false;
			        } else {
			            this.战斗爽=true;
			        }
			    } else {
			        if (this.战斗爽) return;
			    }
			    let 最佳陷阱路径 = null;
			    if (!this.目标陷阱||!地牢[this.目标陷阱.y][this.目标陷阱.x]?.关联物品?.自定义数据?.get('已触发')){
			
			    const 未触发陷阱列表 = [];
			    const 半径 = 25;
			        const 中心X = this.x;
			        const 中心Y = this.y;
			
			        for (let y = 中心Y - 半径; y <= 中心Y + 半径; y++) {
			            for (let x = 中心X - 半径; x <= 中心X + 半径; x++) {
			            let cell=地牢?.[y]?.[x]
			            if (cell && cell.关联物品 && cell.关联物品 instanceof 陷阱基类 && !cell.关联物品.自定义数据.get('已触发')) {
			                未触发陷阱列表.push(cell.关联物品);
			            }
			         }
			    }
			    
			
			    最佳陷阱路径 = null;
			    let 最短距离到陷阱 = Infinity;
			
			    if (未触发陷阱列表.length > 0) {
			        for (const 陷阱 of 未触发陷阱列表) {
			            const 路径到陷阱 = this.计算目标路径(陷阱.x, 陷阱.y);
			            if (路径到陷阱 && 路径到陷阱.length > 0 && 路径到陷阱.length < 最短距离到陷阱) {
			                最短距离到陷阱 = 路径到陷阱.length;
			                最佳陷阱路径 = 路径到陷阱;
			            }
			        }
			    }
			    添加日志(`${this.类型} 试图引诱你到陷阱处！`, '警告');
			    } else {
			    
			    最佳陷阱路径 = this.计算目标路径(this.目标陷阱.x, this.目标陷阱.y);
			    }
			
			    if (最佳陷阱路径) {
			        this.目标路径 = 最佳陷阱路径;
			        this.目标陷阱 = this.目标路径.slice(-1)[0];
			        
			        
			        return true;
			    } else {
			        const 逃离点 = this.选择逃离目标(玩家.x, 玩家.y, this.跟踪距离);
			        if (逃离点) {
			            this.目标路径 = this.计算目标路径(逃离点.x, 逃离点.y);
			            if (this.目标路径 && this.目标路径.length > 0) {
			                //添加日志(`${this.类型} 正在逃跑！`, '警告');
			                
			                return true;
			            }
			        }
			    }
			    this.战斗爽 = true
			    return false;
			}
			
			    绘制增益效果(屏幕X, 屏幕Y) {
			        if (this.永久增益.length === 0) return;
			        ctx.font = `${单元格大小 * 0.4}px color-emoji`;
			        ctx.textAlign = 'right';
			        ctx.textBaseline = 'top';
			        const 偏移X = 单元格大小 * 0.45;
			        const 偏移Y = -单元格大小 * 0.45;
			        this.永久增益.forEach((增益, 索引) => {
			            if (!增益.图标) return;
			            const x = 屏幕X + 偏移X;
			            const y = 屏幕Y + 偏移Y + (索引 * 单元格大小 * 0.4);
			            ctx.fillText(增益.图标, x, y);
			        });
			    }
			    
			    追踪玩家() {
			        if (this.受伤冻结回合剩余 > 0) {
			            this.受伤冻结回合剩余--;
			            return;
			        }
			        const 当前距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (当前距离 <= 1) return;
			        const 移动选项 = [];
			        const 方向 = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
			        for(const {dx, dy} of 方向) {
			            const 新X = this.x + dx;
			            const 新Y = this.y + dy;
			            if(新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;
			            const 新距离 = Math.abs(新X - 玩家.x) + Math.abs(新Y - 玩家.y);
			            const 目标单元格 = 地牢[新Y]?.[新X];
			            if (新距离 < 当前距离 && 目标单元格 && ![单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.背景类型) && !(目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物) && !目标单元格.关联怪物) {
			                移动选项.push({dx, dy, 新距离});
			            }
			        }
			        if (移动选项.length === 0) return;
			        移动选项.sort((a,b) => a.新距离 - b.新距离);
			        const 最佳移动 = 移动选项[0];
			        const 旧X = this.x;
			        const 旧Y = this.y;
			        this.恢复背景类型();
			        this.x += 最佳移动.dx;
			        this.y += 最佳移动.dy;
			        this.保存新位置类型(this.x, this.y);
			        地牢[this.y][this.x].类型 = 单元格类型.怪物;
			        地牢[this.y][this.x].关联怪物 = this;
			        怪物动画状态.set(this, { 旧逻辑X: 旧X, 旧逻辑Y: 旧Y, 目标逻辑X: this.x, 目标逻辑Y: this.y, 视觉X: 旧X, 视觉Y: 旧Y, 动画开始时间: Date.now(), 正在动画: true, });
			        const 开关 = 地牢[this.y][this.x].关联物品;
			        if (开关 && (开关 instanceof 红蓝开关 || 开关 instanceof 绿紫开关)) {
			            开关.使用();
			        }
			    }
			    尝试添加随机词条到掉落物(物品实例) {
			        if (
			            !(
			                物品实例 instanceof 武器类 ||
			                物品实例 instanceof 防御装备类
			            )
			        ) {
			            return;
			        }
			        if (!物品实例.自定义数据) {
			            物品实例.自定义数据 = new Map();
			        }
			        let 现有词条 = 物品实例.自定义数据.get("fusedBuffs") || [];
			        const 最大词条数 =
			            1 +
			            Math.floor(prng() * 2) *
			                (玩家属性.掉落倍率 > 1 ? 2 : 1);
			        let 添加词条数 = 0;
			
			        const 通用词条池 = [
			            融合Buff类型.耐久加成,
			            融合Buff类型.耐久倍率,
			        ];
			        const 武器词条池 = [
			            融合Buff类型.攻击加成,
			            融合Buff类型.攻击倍率,
			            融合Buff类型.冷却缩减,
			            融合Buff类型.冷却倍率,
			            融合Buff类型.范围加成,
			            融合Buff类型.中毒几率,
			            融合Buff类型.火焰伤害,
			            融合Buff类型.冰冻几率,
			            融合Buff类型.生命偷取,
			            融合Buff类型.暴击几率,
			            融合Buff类型.暴击伤害倍率,
			            融合Buff类型.击退几率,
			            融合Buff类型.攻击吸能,
			            融合Buff类型.幸运一击,
			        ];
			        const 防具词条池 = [
			            融合Buff类型.防御加成,
			            融合Buff类型.防御倍率,
			            融合Buff类型.闪避几率,
			            融合Buff类型.固定伤害减免,
			            融合Buff类型.受击回能,
			            融合Buff类型.中毒几率,
			        ];
			
			        let 适用的额外词条池 = [];
			        if (物品实例 instanceof 武器类) {
			            适用的额外词条池 = [...武器词条池];
			        } else if (物品实例 instanceof 防御装备类) {
			            适用的额外词条池 = [...防具词条池];
			        }
			
			        const 最终词条池 = [...通用词条池, ...适用的额外词条池];
			        if (最终词条池.length === 0) return;
			
			        for (let i = 0; i < 5 && 添加词条数 < 最大词条数; i++) {
			            if (最终词条池.length === 0) break;
			            const 随机词条类型 =
			                最终词条池[
			                    Math.floor(prng() * 最终词条池.length)
			                ];
			            let 词条数值 = 0;
			            let 数值系数 = 0.2 + prng() * 0.4;
			            if (玩家属性.掉落倍率 > 1)
			                数值系数 *= 1 + (玩家属性.掉落倍率 - 1) * 0.5;
			
			            switch (随机词条类型) {
			                case 融合Buff类型.攻击加成:
			                    词条数值 = Math.round(
			                        (1 + prng() * 1) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.攻击倍率:
			                    词条数值 = Math.min(
			                        0.15,
			                        (0.02 + prng() * 0.05) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.耐久加成:
			                    词条数值 = Math.round(
			                        (3 + prng() * 7) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.耐久倍率:
			                    词条数值 = Math.min(
			                        0.75,
			                        (0.05 + prng() * 0.1) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.范围加成:
			                    if (
			                        物品实例 instanceof 武器类 &&
			                        物品实例.自定义数据.has("攻击范围") &&
			                        物品实例.自定义数据.get("攻击范围") > 1 &&
			                        prng() < 0.5
			                    )
			                        词条数值 = Math.round(1 * 数值系数);
			                    break;
			                case 融合Buff类型.冷却缩减:
			                    if (
			                        物品实例 instanceof 武器类 &&
			                        物品实例.自定义数据.has("冷却回合") &&
			                        物品实例.自定义数据.get("冷却回合") > 0 &&
			                        prng() < 0.5
			                    )
			                        词条数值 = Math.round(1 * 数值系数);
			                    break;
			                case 融合Buff类型.冷却倍率:
			                    if (
			                        物品实例 instanceof 武器类 &&
			                        物品实例.自定义数据.has("冷却回合") &&
			                        物品实例.自定义数据.get("冷却回合") > 0 &&
			                        prng() < 0.5
			                    )
			                        词条数值 = Math.min(
			                            0.25,
			                            (0.03 + prng() * 0.08) * 数值系数
			                        );
			                    break;
			                case 融合Buff类型.防御加成:
			                    词条数值 = Math.round(
			                        (1 + prng() * 0.5) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.防御倍率:
			                    词条数值 = Math.min(
			                        0.15,
			                        (0.02 + prng() * 0.05) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.固定伤害减免:
			                    词条数值 = Math.round(
			                        prng() * 1 * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.受击回能:
			                    词条数值 = Math.round(
			                        (1 + prng() * 3) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.中毒几率:
			                case 融合Buff类型.冰冻几率:
			                case 融合Buff类型.生命偷取:
			                case 融合Buff类型.击退几率:
			                case 融合Buff类型.攻击吸能:
			                case 融合Buff类型.火焰伤害:
			                case 融合Buff类型.闪避几率:
			                    词条数值 = Math.min(
			                        0.2,
			                        (0.03 + prng() * 0.1) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.暴击几率:
			                    词条数值 = Math.min(
			                        0.1,
			                        (0.01 + prng() * 0.05) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.暴击伤害倍率:
			                    词条数值 = Math.min(
			                        0.5,
			                        (0.05 + prng() * 0.2) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.幸运一击:
			                    词条数值 = Math.min(
			                        0.08,
			                        (0.01 + prng() * 0.03) * 数值系数
			                    );
			                    break;
			            }
			
			            if (词条数值 > 0 && 随机词条类型) {
			                const 已有同类词条 = 现有词条.find(
			                    (b) => b.type === 随机词条类型
			                );
			                if (已有同类词条) {
			                    if (
			                        typeof 已有同类词条.value === "number" &&
			                        typeof 词条数值 === "number"
			                    ) {
			                        已有同类词条.value += 词条数值;
			
			                        let 上限 = 1.0;
			                        if (
			                            随机词条类型.includes("MULTIPLIER") ||
			                            随机词条类型.includes("CHANCE") ||
			                            随机词条类型.includes("STEAL") ||
			                            随机词条类型.includes("PERCENT")
			                        ) {
			                            上限 =
			                                {
			                                    [融合Buff类型.攻击倍率]: 0.3,
			                                    [融合Buff类型.冷却倍率]: 0.5,
			                                    [融合Buff类型.耐久倍率]: 0.75,
			                                    [融合Buff类型.防御倍率]: 0.3,
			                                    [融合Buff类型.中毒几率]: 0.4,
			                                    [融合Buff类型.冰冻几率]: 0.4,
			                                    [融合Buff类型.生命偷取]: 0.3,
			                                    [融合Buff类型.击退几率]: 0.4,
			                                    [融合Buff类型.攻击吸能]: 0.3,
			                                    [融合Buff类型.火焰伤害]: 0.4,
			                                    [融合Buff类型.闪避几率]: 0.3,
			                                    [融合Buff类型.暴击几率]: 0.2,
			                                    [融合Buff类型.暴击伤害倍率]: 1.0,
			                                    [融合Buff类型.幸运一击]: 0.15,
			                                }[随机词条类型] || 1.0;
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                上限
			                            );
			                        } else if (
			                            随机词条类型 === 融合Buff类型.冷却缩减
			                        ) {
			                            const 武器基础冷却 =
			                                物品实例.自定义数据.get(
			                                    "冷却回合"
			                                ) || 1;
			                            上限 =
			                                武器基础冷却 > 0
			                                    ? 武器基础冷却 - 1
			                                    : 0;
			                            已有同类词条.value = Math.max(
			                                0,
			                                Math.min(已有同类词条.value, 上限)
			                            );
			                            上限 = 99999;
			                        } else if (
			                            随机词条类型 ===
			                            融合Buff类型.固定伤害减免
			                        ) {
			                            上限 = 3;
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                上限
			                            );
			                        } else if (
			                            随机词条类型 === 融合Buff类型.受击回能
			                        ) {
			                            上限 = 10;
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                上限
			                            );
			                        } else if (
			                            随机词条类型 ===
			                                融合Buff类型.范围加成 &&
			                            物品实例.自定义数据.has("攻击范围")
			                        ) {
			                            上限 = Math.floor(
			                                物品实例.自定义数据.get(
			                                    "攻击范围"
			                                ) * 0.3
			                            );
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                上限
			                            );
			                        } else if (随机词条类型.includes("加成")) {
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                5
			                            );
			                        }
			                    }
			                } else {
			                    现有词条.push({
			                        type: 随机词条类型,
			                        value: 词条数值,
			                    });
			                }
			                添加词条数++;
			
			                const 移除索引 = 最终词条池.indexOf(随机词条类型);
			                if (移除索引 > -1) {
			                    最终词条池.splice(移除索引, 1);
			                }
			            }
			        }
			        if (现有词条.length > 0) {
			            物品实例.自定义数据.set("fusedBuffs", 现有词条);
			            const 耐久倍率 = 现有词条.find(b => b.type === 'DURABILITY_MULTIPLIER');
			 if (耐久倍率) {
			     物品实例.自定义数据.set('原耐久',Math.round(物品实例.自定义数据.get('原耐久')*(1+耐久倍率.value)*10)/10);
			     物品实例.自定义数据.set('耐久',Math.round(物品实例.自定义数据.get('耐久')*(1+耐久倍率.value)*10)/10);
			 }
			 const 耐久加成 = 现有词条.find(b => b.type === 'DURABILITY_BONUS');
			 if (耐久加成) {
			     物品实例.自定义数据.set('原耐久',物品实例.自定义数据.get('原耐久')+耐久加成.value);
			     物品实例.自定义数据.set('耐久',物品实例.自定义数据.get('耐久')+耐久加成.value);
			 }
			        }
			    }
			    计算路径(目标X, 目标Y) {
			    const 目标距离 = Math.floor(this.攻击范围 / 2);

        
        let 目标距离图 = 玩家距离图
        if(目标X!==玩家.x||目标Y!==玩家.y) 目标距离图 = 生成玩家距离图(目标X, 目标Y);

        if (目标距离图[this.y][this.x] === 目标距离) {
            跟踪玩家怪物数++;
            return [];
        }

        const 开放列表 = [];
        const 关闭列表 = new Set();
        const 方向映射表 = [
            { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
            { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
            { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
            { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
        ];

        const 起点节点 = {
            x: this.x,
            y: this.y,
            g: 0,
            parent: null,
        };
        开放列表.push(起点节点);
        关闭列表.add(`${起点节点.x},${起点节点.y}`);

        while (开放列表.length > 0) {
            let 当前节点 = 开放列表.shift();
            if (目标距离图[当前节点.y][当前节点.x] === 目标距离) {
                const 路径 = [];
                let 节点 = 当前节点;
                while (节点.parent) {
                    路径.push(节点);
                    节点 = 节点.parent;
                }
                return 路径.reverse();
            }

            方向映射表.forEach((方向) => {
                const 新X = 当前节点.x + 方向.dx;
                const 新Y = 当前节点.y + 方向.dy;

                if (
                    新X < 0 ||
                    新X >= 地牢大小 ||
                    新Y < 0 ||
                    新Y >= 地牢大小
                )
                    return;

                const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                const 目标单元格 = 地牢[新Y][新X];

                if (
                    当前单元格.墙壁[方向.当前墙] ||
                    目标单元格.墙壁[方向.目标墙] ||
                    目标单元格.背景类型 === 单元格类型.墙壁 ||
                    目标单元格.背景类型 === 单元格类型.上锁的门 ||
                    (目标单元格.关联物品?.类型 === '开关砖' && 目标单元格.关联物品?.阻碍怪物) ||
                    开放列表.length > this.跟踪距离 || 目标单元格.关联物品 instanceof 烟雾
                )
                    return;

                const 移动方向 = getMoveDirection(
                    当前节点.x,
                    当前节点.y,
                    新X,
                    新Y
                );
                if (
                    目标单元格.isOneWay &&
                    移动方向 !== 目标单元格.oneWayAllowedDirection
                )
                    return;

                const 位置键 = `${新X},${新Y}`;
                if (!关闭列表.has(位置键)) {
                    关闭列表.add(位置键);
                    开放列表.push({
                        x: 新X,
                        y: 新Y,
                        g: 当前节点.g + 1,
                        parent: 当前节点,
                    });
                }
            });
        
        
    }
    return null;
}
计算目标路径(目标X, 目标Y) {
    //if (地牢生成方式 === 'cave') {
        const 路径 = A星寻路(this.x, this.y, 目标X, 目标Y,999);
        
        if (路径?.length>0) {
            路径.shift()
            return 路径;
        }
        return null;
    //} else {
        const 开放列表 = [];
        const 关闭列表 = new Set();
        const 方向映射表 = [
            {
                dx: 1,
                dy: 0,
                当前墙: "右",
                目标墙: "左",
            },
            {
                dx: -1,
                dy: 0,
                当前墙: "左",
                目标墙: "右",
            },
            {
                dx: 0,
                dy: 1,
                当前墙: "下",
                目标墙: "上",
            },
            {
                dx: 0,
                dy: -1,
                当前墙: "上",
                目标墙: "下",
            },
        ];

        const 起点节点 = {
            x: this.x,
            y: this.y,
            g: 0,
            parent: null,
        };
        开放列表.push(起点节点);

        while (开放列表.length > 0) {
            let 当前节点 = 开放列表.shift();

            if (当前节点.x === 目标X && 当前节点.y === 目标Y) {
                const 路径 = [];
                while (当前节点.parent) {
                    路径.push(当前节点);
                    当前节点 = 当前节点.parent;
                }
                return 路径.reverse();
            }

            方向映射表.forEach((方向) => {
                const 新X = 当前节点.x + 方向.dx;
                const 新Y = 当前节点.y + 方向.dy;
                if (
                    新X < 0 ||
                    新X >= 地牢大小 ||
                    新Y < 0 ||
                    新Y >= 地牢大小
                )
                    return;
                const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                const 目标单元格 = 地牢[新Y][新X];
                const 当前墙阻挡 = 当前单元格.墙壁[方向.当前墙];
                const 目标墙阻挡 = 目标单元格.墙壁[方向.目标墙];
                const 硬阻挡 =
                    目标单元格.背景类型 === 单元格类型.墙壁 ||
                    目标单元格.背景类型 === 单元格类型.上锁的门 || (目标单元格.关联物品?.类型 === '开关砖' && 目标单元格.关联物品?.阻碍怪物) || 目标单元格.关联物品 instanceof 烟雾

                if (
                    当前墙阻挡 ||
                    目标墙阻挡 ||
                    硬阻挡 ||
                    开放列表.length > this.跟踪距离
                )
                    return;

                const 移动方向 = getMoveDirection(
                    当前节点.x,
                    当前节点.y,
                    新X,
                    新Y
                );
                if (
                    目标单元格.isOneWay &&
                    移动方向 !== 目标单元格.oneWayAllowedDirection
                )
                    return;

                const 位置键 = `${新X},${新Y}`;
                if (!关闭列表.has(位置键)) {
                    开放列表.push({
                        x: 新X,
                        y: 新Y,
                        g: 当前节点.g + 1,
                        parent: 当前节点,
                    });
                    关闭列表.add(位置键);
                }
            });
       // }
        return null;
    }
}
			
			    寻找最近怪物目标() {
			        let 最近距离 = Infinity;
			        let 最近目标 = null;
			
			        所有怪物.forEach((其他怪物) => {
			            if (
			                其他怪物 === this ||
			                其他怪物.当前生命值 <= 0 ||
			                其他怪物.状态 === 怪物状态.休眠 ||
			                ["冻结", "魅惑"].includes(
			                    怪物状态表.get(其他怪物)?.类型
			                ) ||
			                其他怪物 instanceof 大魔法师
			            )
			                return;
			
			            const 距离 =
			                Math.abs(this.x - 其他怪物.x) +
			                Math.abs(this.y - 其他怪物.y);
			            if (
			                距离 < 最近距离 &&
			                检查视线(this.x, this.y, 其他怪物.x, 其他怪物.y)
			            ) {
			                最近距离 = 距离;
			                最近目标 = 其他怪物;
			            }
			        });
			        this.魅惑目标怪物 = 最近目标;
			        return 最近目标
			            ? { x: 最近目标.x, y: 最近目标.y }
			            : { x: this.x, y: this.y };
			    }
			    寻找并远离危险炸弹() {
			        const 危险炸弹列表 = [];
			        所有计时器.forEach(计时器 => {
			            if (计时器 instanceof 炸弹 && 计时器.自定义数据.get('来源') === '怪物') {
			                const 距离 = Math.abs(this.x - 计时器.x) + Math.abs(this.y - 计时器.y);
			                if (距离 <= (计时器.自定义数据.get('爆炸范围') || 3)) {
			                    危险炸弹列表.push(计时器);
			                }
			            }
			        });
			
			        if (危险炸弹列表.length > 0) {
			            const 最近炸弹 = 危险炸弹列表.sort((a,b) => (Math.abs(this.x - a.x) + Math.abs(this.y - a.y)) - (Math.abs(this.x - b.x) + Math.abs(this.y - b.y)))[0];
			            const 逃离点 = this.选择逃离目标(最近炸弹.x, 最近炸弹.y, 10);
			            if (逃离点) {
			                this.目标路径 = this.计算路径(逃离点.x, 逃离点.y);
			                if (this.目标路径 && this.目标路径.length > 0) {
			                     添加日志(`${this.类型} 正在逃离炸弹！`, "信息");
			                     return true;
			                }
			            }
			        }
			        return false;
			    }
			    尝试移动() {
			        if (this.尝试使用药水()) return;
			        this.尝试逃跑()
			        let 移动率 = this.移动率;
			        const 我的状态 = 怪物状态表.get(this);
			        switch (我的状态?.类型) {
			            case "冻结":
			                if (!当前天气效果.includes("严寒")) return;
			            case "火焰":
			                this.受伤(3, "火焰");
			                this.受伤冻结回合剩余 = 0;
			                break;
			            case "魅惑":
			                移动率 = 1;
			                break;
			            case "缓慢":
			                移动率 = 0.5;
			                break;
			            case "中毒":
			                this.受伤(我的状态.强度 || 1, "中毒");
			                this.受伤冻结回合剩余 = 0;
			                break;
			            case "恐惧":
			                this.逃离目标 = { x: 玩家.x, y: 玩家.y };
			                const 逃离点 = this.选择逃离目标(
			                    玩家.x,
			                    玩家.y,
			                    this.跟踪距离
			                );
			                if (逃离点) {
			                    this.目标路径 = this.计算路径(
			                        逃离点.x,
			                        逃离点.y
			                    );
			                } else {
			                    this.目标路径 = [];
			                }
			                break;
			            case "牵制":
			                return;
			                break;
			            case "眩晕":
			                return;
			                break;
			                
			        }
			        if (this.当前生命值 <= 0) return;
			        if (房间地图[玩家.y][玩家.x] === 0 && 游戏状态==='游戏中' && !是否是自定义关卡) return;
			        if (!this.目标路径) return;
			        if (this.受伤冻结回合剩余 > 0) {
			            this.受伤冻结回合剩余 -= 1;
			        } else {
			            if (
			                this.跟踪距离 >= this.目标路径.length &&
			                怪物状态表.get(this)?.类型 !== "魅惑"
			            ) {
			                跟踪玩家怪物数++;
			            }
			            if (
			                (this.目标路径.length === 0 ||
			                (prng() > 移动率 && !切换动画) ||
			                (this.跟踪距离 < this.通向目标路径.length || this.目标路径.length > this.通向目标路径.length)) &&
			                !this.目标陷阱
			            ) {
			                this.追击玩家中 = false;
			                return;
			            }
			            if (!(this instanceof 炸弹怪物)) this.寻找并远离危险炸弹();
			            const 旧X = this.x;
			            const 旧Y = this.y;
			            const 下一步 =
			                this.目标路径[
			                    Math.min(
			                        this.移动距离 - 1,
			                        this.目标路径.length - 1
			                    )
			                ];
			            let 最终位置 = null;
			            if (下一步) {
			                const dx = 下一步.x - this.x;
			                const dy = 下一步.y - this.y;
			                最终位置 = this.规划移动路径(dx, dy);
			                if (最终位置) {
			                    const 移动步数 = this.通向目标路径.findIndex(p => p.x === 最终位置.x && p.y === 最终位置.y);
			                    if (移动步数 !== -1 && this.通向目标路径) {
			                        this.通向目标路径 = this.通向目标路径.slice(移动步数 + 1);
			                    }
			                    }
			            }
			
			            if (最终位置) {
			                const 目标单元格实例 =
			                    地牢[最终位置.y]?.[最终位置.x];
			                if (
			                    目标单元格实例 &&
			                    目标单元格实例.关联物品 instanceof 罐子 &&
			                    !目标单元格实例.关联物品.自定义数据.get(
			                        "已破碎"
			                    )
			                ) {
			                    const 罐子要碎了 = 目标单元格实例.关联物品;
			                    罐子要碎了.破碎并释放内容(this);
			
			                    if (
			                        地牢[最终位置.y]?.[最终位置.x]?.关联怪物 &&
			                        地牢[最终位置.y][最终位置.x].关联怪物 !==
			                            this
			                    ) {
			                        if (this.接受萨满治疗) {
			                            计划显示格子特效(
			                                [{ x: this.x, y: this.y }],
			                                "00FF00",
			                                0
			                            );
			                            this.接受萨满治疗 = false;
			                        }
			                        this.绘制血条();
			                        return;
			                    }
			                }
			                if (
			                    this instanceof 大魔法师 &&
			                    房间地图[最终位置.y][最终位置.x] === -1
			                ) {
			                    if (this.接受萨满治疗) {
			                        计划显示格子特效(
			                            [{ x: this.x, y: this.y }],
			                            "00FF00",
			                            0
			                        );
			                        this.接受萨满治疗 = false;
			                    }
			                    this.绘制血条();
			                    return;
			                }
			
			                this.恢复背景类型();
			                this.保存新位置类型(最终位置.x, 最终位置.y);
			                this.x = 最终位置.x;
			                this.y = 最终位置.y;
			                地牢[this.y][this.x].类型 = 单元格类型.怪物;
			                地牢[this.y][this.x].关联怪物 = this;
			                this.处理地形效果();
			                怪物动画状态.set(this, {
			                    旧逻辑X: 旧X,
			                    旧逻辑Y: 旧Y,
			                    目标逻辑X: this.x,
			                    目标逻辑Y: this.y,
			                    视觉X: 旧X,
			                    视觉Y: 旧Y,
			                    动画开始时间: Date.now(),
			                    正在动画: true,
			                });
			            }
			        }
			        if (this.接受萨满治疗) {
			            计划显示格子特效(
			                [{ x: this.x, y: this.y }],
			                "00FF00",
			                0
			            );
			            this.接受萨满治疗 = false;
			        }
			        this.绘制血条();
			    }
			    处理地形效果() {
			        const 开关 = 地牢[this.y][this.x]?.关联物品;
			        if (开关 && (开关 instanceof 红蓝开关 || 开关 instanceof 绿紫开关)) {
			            开关.使用();
			        }
			        if (地牢[this.y][this.x]?.关联物品 instanceof 火焰物品) {
			            const 火焰实例移动后 = 地牢[this.y][this.x].关联物品;
			            const 强度移动后 =
			                火焰实例移动后.自定义数据.get("火焰强度") ?? 1;
			            const 持续移动后 =
			                火焰实例移动后.自定义数据.get("火焰持续") ?? 3;
			            new 状态效果(
			                "火焰",
			                效果颜色编号映射[效果名称编号映射.火焰],
			                "火",
			                持续移动后,
			                null,
			                null,
			                this,
			                强度移动后
			            );
			            添加日志(`${this.类型} 踩到了火焰，着火了！`, "警告");
			        } else if (
			            地牢[this.y][this.x]?.关联物品 instanceof 荆棘丛
			        ) {
			            const 伤害量 =
			                地牢[this.y][this.x]?.关联物品?.自定义数据.get(
			                    "伤害"
			                );
			            this.受伤(伤害量, "荆棘丛");
			            添加日志(
			                `${this.类型} 踩进了荆棘丛，受到 ${伤害量} 点伤害！`,
			                "警告"
			            );
			            地牢[this.y][this.x].关联物品.发挥效果 = true;
			            if (
			                prng() <
			                地牢[this.y][this.x]?.关联物品?.自定义数据.get(
			                    "减速概率"
			                )
			            ) {
			                new 状态效果(
			                    "缓慢",
			                    效果颜色编号映射[效果名称编号映射.缓慢],
			                    "慢",
			                    地牢[this.y][this.x]?.关联物品?.自定义数据.get(
			                        "减速回合"
			                    ),
			                    null,
			                    null,
			                    this,
			                    1
			                );
			                添加日志(
			                    `${this.类型} 被荆棘缠绕，移动变慢了！`,
			                    "警告"
			                );
			            }
			        } else if (地牢[this.y][this.x]?.关联物品) {
			            地牢[this.y][this.x]?.关联物品?.当被收集(this);
			        }
			    }
			    规划移动路径() {
			        let 当前位置 = { x: this.x, y: this.y };
			        let 有效位置 = null;
			        let 可行距离 = this.移动距离 + 1;
			        for (
			            let i = 0;
			            i < Math.min(this.目标路径.length, 可行距离);
			            i++
			        ) {
			            const 节点 = this.目标路径[i];
			
			            const nextX = 节点.x;
			            const nextY = 节点.y;
			            if (地牢[nextY][nextX].类型 === 单元格类型.怪物) {
			                可行距离 = this.移动距离 + 1;
			            }
			            if (
			                this.检查移动可行性(
			                    当前位置.x,
			                    当前位置.y,
			                    nextX,
			                    nextY
			                ) && !(地牢[nextY][nextX].关联物品 && (地牢[nextY][nextX].关联物品 instanceof 已放置的障碍物 || (地牢[nextY][nextX].关联物品.类型 === '开关砖' && 地牢[nextY][nextX].关联物品.阻碍怪物)))
			            ) {
			                if (this.位置合法(nextX, nextY)) {
			                    有效位置 = { x: nextX, y: nextY };
			                }
			            } else {
			                this.目标路径 = this.目标路径.slice(i);
			                return 当前位置;
			            }
			            当前位置 = { x: nextX, y: nextY };
			
			            if (
			                有效位置 &&
			                i >=
			                    Math.min(this.移动距离, this.目标路径.length) -
			                        1
			            ) {
			                this.目标路径 = this.目标路径.slice(i);
			                return 有效位置;
			            }
			        }
			        return 有效位置;
			    }
			
			    检查移动可行性(fromX, fromY, toX, toY) {
			        const dx = toX - fromX;
			        const dy = toY - fromY;
			        const steps = Math.max(Math.abs(dx), Math.abs(dy));
			        const xStep = dx / steps;
			        const yStep = dy / steps;
			
			        let currentX = fromX;
			        let currentY = fromY;
			
			        for (let i = 0; i <= steps; i++) {
			            const x = Math.round(currentX);
			            const y = Math.round(currentY);
			
			            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
			                return false;
			
			            if (i > 0) {
			                const prevX = Math.round(currentX - xStep);
			                const prevY = Math.round(currentY - yStep);
			                const 移动方向 = 获取移动方向(prevX, prevY, x, y);
			
			                const 当前单元格 = 地牢[y][x];
			                const 前单元格 = 地牢[prevY][prevX];
			
			                if (
			                    当前单元格.墙壁[移动方向.反方向墙] ||
			                    前单元格.墙壁[移动方向.当前墙]
			                ) {
			                    return false;
			                }
			            }
			
			            if (x === toX && y === toY) break;
			
			            currentX += xStep;
			            currentY += yStep;
			        }
			        return true;
			    }
			    位置合法(x, y) {
			        if (
			            (地牢[y][x].类型 === 单元格类型.物品 &&
			            地牢[y][x].关联物品?.阻碍怪物) || 地牢[y][x].关联物品 instanceof 烟雾
			        ) {
			            return false;
			        }
			        if (
			            房间地图[y][x] !== -1 &&
			            !已访问房间.has(房间地图[y][x]) &&
			            !this.目标陷阱
			        ) {
			            return false;
			        }
			        if (房间地图[y][x]===0) return false;
			        const 怪物所在房间 =
			            房间地图[this.y]?.[this.x] !== -1
			                ? 房间列表[房间地图[this.y][this.x]]
			                : null;
			        if (
			            怪物所在房间 &&
			            怪物所在房间.类型 === "黑暗房间" &&
			            房间地图[y]?.[x] !== 怪物所在房间.id
			        ) {
			            return false;
			        }
			        if (地牢[y][x].关联怪物) return false;
			        return (
			            [
			                单元格类型.房间,
			                单元格类型.走廊,
			                单元格类型.门,
			            ].includes(地牢[y][x].背景类型) &&
			            ![
			                单元格类型.楼梯上楼,
			                单元格类型.楼梯下楼,
			                单元格类型.怪物,
			            ].includes(地牢[y][x].类型)
			        );
			    }
			
			    恢复背景类型() {
			        地牢[this.y][this.x].类型 = this.当前格;
			        if (
			            this.当前格 === 单元格类型.物品 &&
			            地牢[this.y][this.x].关联物品 === null
			        ) {
			            地牢[this.y][this.x].类型 = null;
			        }
			        地牢[this.y][this.x].关联怪物 = null;
			    }
			
			    保存新位置类型(x, y) {
			        this.当前格 = 地牢[y][x].类型;
			    }
			                    选择逃离目标(目标X, 目标Y, 范围 = 10) {
			        const 可达点 = [];
			        const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
			        const 已访问 = new Set([`${this.x},${this.y}`]);
			        const 怪物所在房间ID = 房间地图[this.y][this.x];
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			            const 距离目标 =
			                Math.abs(当前.x - 目标X) + Math.abs(当前.y - 目标Y);
			            const 距离自身 = 当前.距离;
			
			            if (
			                距离自身 <= 范围 &&
			                距离目标 >
			                    Math.abs(this.x - 目标X) +
			                        Math.abs(this.y - 目标Y)
			            ) {
			                const 点所在房间ID = 房间地图[当前.y][当前.x];
			                if (
			                    点所在房间ID === 怪物所在房间ID ||
			                    点所在房间ID === -1 ||
			                    (已访问房间.has(点所在房间ID) &&
			                        房间列表[点所在房间ID]?.类型?.slice(
			                            0,
			                            2
			                        ) !== "隐藏")
			                ) {
			                    if (this.位置合法(当前.x, 当前.y)) {
			                        可达点.push({
			                            x: 当前.x,
			                            y: 当前.y,
			                            距离目标: 距离目标,
			                        });
			                    }
			                }
			            }
			
			            if (当前.距离 >= 范围) continue;
			
			            const 方向 = [
			                { dx: 1, dy: 0 },
			                { dx: -1, dy: 0 },
			                { dx: 0, dy: 1 },
			                { dx: 0, dy: -1 },
			            ];
			            for (const { dx, dy } of 方向) {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			                const 位置键 = `${新X},${新Y}`;
			
			                if (
			                    新X >= 0 &&
			                    新X < 地牢大小 &&
			                    新Y >= 0 &&
			                    新Y < 地牢大小 &&
			                    !已访问.has(位置键)
			                ) {
			                    const 当前单元格 = 地牢[当前.y]?.[当前.x];
			                    const 目标单元格 = 地牢[新Y]?.[新X];
			                    const 移动方向 = getMoveDirection(当前.x, 当前.y, 新X, 新Y);
			                    if (目标单元格.isOneWay && 移动方向 !== 目标单元格.oneWayAllowedDirection) {
			                        continue;
			                    }
			                    if (
			                        当前单元格 &&
			                        目标单元格 &&
			                        ![
			                            单元格类型.墙壁,
			                            单元格类型.上锁的门,
			                        ].includes(目标单元格.背景类型) &&
			                        检查移动可行性(当前.x, 当前.y, 新X, 新Y) &&
			                        this.位置合法(新X, 新Y)
			                    ) {
			                        已访问.add(位置键);
			                        队列.push({
			                            x: 新X,
			                            y: 新Y,
			                            距离: 当前.距离 + 1,
			                        });
			                    }
			                }
			            }
			        }
			
			        if (可达点.length > 0) {
			            可达点.sort((a, b) => b.距离目标 - a.距离目标);
			            return 可达点[0];
			        }
			        return null;
			    }
			    选择目标() {
    if (怪物状态表.get(this)?.类型 === "魅惑") {
        return this.寻找最近怪物目标();
    }
    if (this.仇恨 instanceof 怪物 && this.仇恨.当前生命值 > 0) {
        return this.仇恨;
    }

    const 潜在目标列表 = [玩家, ...当前出战宠物列表, ...玩家仆从列表];
    let 最近目标 = null;
    let 最小距离 = Infinity;

    潜在目标列表.forEach(目标 => {
        if (目标 && (目标.当前生命值 > 0 || 目标 === 玩家) && (目标.是否已放置 || 目标 === 玩家)) {
            const 距离 = Math.abs(this.x - 目标.x) + Math.abs(this.y - 目标.y);
            if (距离 < 最小距离) {
                最小距离 = 距离;
                最近目标 = 目标;
            }
        }
    });
    
    return 最近目标 || 玩家;
}
			    尝试攻击() {
			        let 目标 = this.目标;
			        if (!目标) return false;
			        if (怪物状态表.get(this)?.类型 === "冻结") return;
			        const 距离目标 = Math.abs(this.x - 目标.x) + Math.abs(this.y - 目标.y);
			        if (距离目标>this.攻击范围) return;
			        if (this.通向目标路径&&this.通向目标路径?.length > this.攻击范围) return false;
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余 -= 1;
			            return false;
			        }
			        if (!this.通向目标路径) return false;
			        this.绘制血条();
			        if (目标.x === 玩家.x && 目标.y === 玩家.y) {
			            
			            伤害玩家(this.攻击力, this);
			        } else if (目标 instanceof 宠物) {
			            目标.受伤(this.攻击力,this);
			            添加日志(`${this.类型} 攻击了你的宠物 ${目标.名称}！`, "警告");
			        } else if (目标 instanceof 怪物) { 
			             目标.受伤(this.攻击力, this);
			        } else {
			            return false;
			        }
			        
			        this.攻击冷却回合剩余 = this.攻击冷却;
			        if (!this.通向目标路径) {
			            
			        } else {
			            计划显示格子特效(this.通向目标路径);
			        }
			    
			        return true;
			    }
			    get 攻击范围() {
			        return this.基础攻击范围 + (this.强化 ? 1 : 0);
			    }
			    get 攻击力() {
			        let 基础攻击 = this.基础攻击力 + (this.强化 ? this.基础攻击力 * 0.5 : 0);
			        const 力量增益 = this?.永久增益?.find(b => b.类型 === '永久力量');
			        if (力量增益) {
			            基础攻击 += 力量增益.值;
			        }
			        return 基础攻击;
			    }
			    get 颜色() {
			        if (怪物状态表.get(this)) {
			            return 怪物状态表.get(this)?.颜色;
			        }
			        return this.强化 ? "#ff0000" : this.基础颜色;
			    }
			    get 移动距离() {
			        let 距离 = this.基础移动距离 + (this.强化 ? 1 : 0);
			        const 速度增益 = this.永久增益?.find(增益 => 增益.类型 === '永久速度');
			        if (速度增益) {
			            距离 += 速度增益.值;
			        }
			        return 距离;
			    }
			    get 生命值() {
			        let 基础生命 = this.基础生命值 + (this.强化 ? 30 : 0);
			        const 强化增益 = this.永久增益?.find(b => b.类型 === '永久强化');
			        if (强化增益) {
			            基础生命 = Math.round(基础生命 * (1 + 强化增益.值 / 10));
			        }
			        return 基础生命;
			    }
			    get 物品掉率() {
			        return this.掉落概率 + (this.强化 ? 0.1 : 0);
			    }
			    获得效果(状态效果) {
			        return true;
			    }
			    计算最大甩飞位置(起始X, 起始Y, 方向DX, 方向DY, 最大距离) {
			        let 最远有效位置 = { x: 起始X, y: 起始Y };
			
			        if (方向DX === 0 && 方向DY === 0) return 最远有效位置;
			
			        for (let i = 1; i <= 最大距离 + 1; i++) {
			            const 尝试X = 起始X + 方向DX * i;
			            const 尝试Y = 起始Y + 方向DY * i;
			            if (
			                尝试X < 0 ||
			                尝试X >= 地牢大小 ||
			                尝试Y < 0 ||
			                尝试Y >= 地牢大小
			            ) {
			                break;
			            }
			            if (
			                !检查直线移动可行性(
			                    起始X,
			                    起始Y,
			                    尝试X,
			                    尝试Y,
			                    true
			                )
			            ) {
			                break;
			            }
			            if (this.位置合法(尝试X, 尝试Y, false)) {
			                最远有效位置 = { x: 尝试X, y: 尝试Y };
			            }
			        }
			        return 最远有效位置;
			    }
			    受伤(伤害, 来源 = null) {
			        
			        if (来源 === "火焰" && this?.永久增益.some(b => b.类型 === '永久抗火')) 伤害 *= 0.1;
			        if (来源 === "中毒" && this?.永久增益?.some(b => b.类型 === '永久抗毒')) 伤害 *= 0.1;
			        if (怪物状态表.get(this)?.类型 === '冻结' && this?.永久增益?.some(b => b.类型 === '永久解冻')) {
			             怪物状态表.get(this).移除状态();
			        }
			
			        if (this.当前生命值 > 0) {
			            this.当前生命值 -= 伤害;
			            let 触发击退 = false;
			            let 来源坐标 = null;
			
			            let 伤害来源是玩家 = 来源 === "玩家" || (来源?.x===玩家.x&&来源?.y===玩家.y);
			            let 伤害来源是宠物 = 来源 instanceof 宠物;
						let 来源宠物 = 伤害来源是宠物 ? 来源 : null;
			            
			            if (来源 instanceof 武器类) {
			                if (当前出战宠物列表.some(p => p?.自定义数据.get("装备")?.武器 === 来源)) {
			                    伤害来源是宠物 = true;
								来源宠物 = 当前出战宠物列表.find(p => p?.自定义数据.get("装备")?.武器 === 来源)
			                } else {
			                    伤害来源是玩家 = true;
			                }
			            }
			
			            if (伤害来源是玩家) {
			                触发击退 = true;
			                来源坐标 = { x: 玩家.x, y: 玩家.y };
			                this.受伤冻结回合剩余 = this.受伤冻结回合;
			                if (玩家属性.怪物反伤) {
			                    伤害玩家(1, '诅咒反伤');
			                }
			            } else if (伤害来源是宠物) {
			                触发击退 = true;
			                来源坐标 = { x: 来源?.x, y: 来源?.y };
			                this.受伤冻结回合剩余 = this.受伤冻结回合;
			            } else if (来源 instanceof 怪物 && 来源 !== this) {
			                触发击退 = true;
			                来源坐标 = { x: 来源?.x, y: 来源?.y };
			                if (!(来源 instanceof 大魔法师)) this.仇恨 = 来源;
			            }
			             if (this instanceof 蜈蚣怪物 || this instanceof 蜈蚣部位)  触发击退=false
			            if (中文模式) this.触发受击动画();
			            if (this.当前生命值 <= 0) {
			                if (伤害来源是玩家 || 伤害来源是宠物) {
			                    已击杀怪物数++;
			                    const 能量条 =
			                        document.querySelector(".power-bar");
			                    const 当前能量 =
			                        parseFloat(能量条.style.width) || 100;
			                    能量条.style.width = `${Math.min(
			                        100,
			                        当前能量 + 1.5/自定义全局设置.初始能量值*100
			                    )}%`;
			                    击杀提示.更新({
			                        内容: `已击杀怪物：${已击杀怪物数}`,
			                    });
			
			                    if (伤害来源是宠物 && 来源宠物) {
			                        const 经验值 = Math.floor(this.基础生命值 / 10);
			                        来源宠物.获得经验(经验值);
			                    }
			                }
			                this.恢复背景类型();
			                if (!(this instanceof 复活怪物) && !(this instanceof 娃娃怪物)) {
			                    for (let 怪物 of 所有怪物) {
			                    if (怪物 instanceof 复活怪物) {
			                        怪物.加入复活怪物({ 类名: this.constructor.name, 冷却: 5,配置: { 强化: this.强化,永久增益: this.永久增益 } });
			                    
			                    }
			                    }
			                }
			                
			                所有怪物 = 所有怪物.filter((m) => m !== this);
			                if (this.永久增益.some(b => b.类型 === '自爆')) {
    const 自爆伤害 = Math.ceil(this.生命值 / 2);
    const 自爆弹 = new 炸弹({
        
            倒计时: 1,
            爆炸时间: 1,
            伤害: 自爆伤害,
            来源: '怪物',
            爆炸范围: 3,
            能否拾起: false,
            颜色索引: 4,
    });
    if(放置物品到单元格(自爆弹, this.x, this.y)){
        自爆弹.使用(false, this.x, this.y);
        添加日志(`${this.类型} 死亡时留下了一颗危险的炸弹！`, '警告');
    }
}
			                if (
			                    当前天气效果.includes("诡魅") &&
			                    !(this instanceof 幽灵怪物) &&
			                    prng() < 0.3
			                ) {
			                    const 新幽灵 = new 幽灵怪物({
			                        x: this.x,
			                        y: this.y,
			                        房间ID: this.房间ID,
			                        状态: 怪物状态.活跃,
			                        强化: this.强化, 
			                    });
			                    if (放置怪物到单元格(新幽灵, this.x, this.y)) {
			                        添加日志(
			                            `一个${新幽灵.类型}从 ${this.类型} 的残骸中浮现！`,
			                            "警告"
			                        );
			                    }
			                } else if (this.掉落物&&
			                    prng() <=
			                    this.物品掉率 * 玩家属性.掉落倍率
			                ) {
			                    if (this.掉落物.自定义数据?.get("耐久"))
			                        this.掉落物.自定义数据.set(
			                            "耐久",
			                            Math.floor(
			                                Math.min(
			                                    this.掉落物.自定义数据.get(
			                                        "耐久"
			                                    ),
			                                    this.掉落物.自定义数据.get(
			                                        "耐久"
			                                    ) *
			                                        玩家属性.掉落倍率 *
			                                        prng() *
			                                        prng()
			                                )
			                            )
			                        );
			                    this.尝试添加随机词条到掉落物(this.掉落物)
			                    放置物品到单元格(this.掉落物, this.x, this.y);
			                }
			                const 玩家单元格 = 地牢[玩家.y][玩家.x];
			                if (
			                    玩家单元格.关联物品 &&
			                    玩家单元格.类型 === 单元格类型.物品
			                ) {
			                    if (尝试收集物品(玩家单元格.关联物品)) {
			                        if(单元格.类型===单元格类型.物品) 玩家单元格.类型 = null;
			                        玩家单元格.关联物品 = null;
			                        单元格.颜色索引 = 颜色表.length
			                    }
			                }
			                
			                if (是否为教程层 && this.房间ID === 2) {
			                    教程阶段 = 2.5; 
			                    教程提示已显示 = false;
			                    setTimeout(() => {
			                        显示教程提示();
			                    }, 200);
			                }
			                return;
			            }
			
			            if (触发击退 && 来源坐标) {
			                let 来源X, 来源Y;
			                来源X = 来源坐标.x;
			                来源Y = 来源坐标.y;
			                let 距离来源 =
			                    Math.abs(this.x - 来源坐标.x) +
			                    Math.abs(this.y - 来源坐标.y);
			                const 最大击退触发距离 = this.基础攻击范围 * 2;
			                if (距离来源 <= 最大击退触发距离) {
			                    let dx = this.x - 来源X;
			                    let dy = this.y - 来源Y;
			
			                    let 方向DX = 0;
			                    let 方向DY = 0;
			                    if (Math.abs(dx) > Math.abs(dy)) {
			                        方向DX = Math.sign(dx);
			                    } else if (Math.abs(dy) > Math.abs(dx)) {
			                        方向DY = Math.sign(dy);
			                    } else if (dx !== 0) {
			                        if (prng() < 0.5)
			                            方向DX = Math.sign(dx);
			                        else 方向DY = Math.sign(dy);
			                    } else {
			                        if (prng() < 0.5)
			                            方向DX = 1;
			                        else 方向DY = 1;
			                    }
			                    if (
			                        方向DX === 0 &&
			                        方向DY === 0 &&
			                        (dx !== 0 || dy !== 0)
			                    ) {
			                        方向DX = Math.sign(dx);
			                        方向DY = Math.sign(dy);
			                        if (Math.abs(dx) > Math.abs(dy)) 方向DY = 0;
			                        else 方向DX = 0;
			                    }
			
			                    if (方向DX !== 0 || 方向DY !== 0) {
			                        const { x: 最终X, y: 最终Y } =
			                            this.计算最大甩飞位置(
			                                this.x,
			                                this.y,
			                                方向DX,
			                                方向DY,
			                                1 
			                            );
			
			                        if (最终X !== this.x || 最终Y !== this.y) {
			                            const 旧X = this.x;
			                            const 旧Y = this.y; 
			                            this.恢复背景类型();
			                            this.x = 最终X;
			                            this.y = 最终Y;
			                            this.保存新位置类型(最终X, 最终Y);
			                            地牢[最终Y][最终X].类型 =
			                                单元格类型.怪物;
			                            地牢[最终Y][最终X].关联怪物 = this;
			                            this.处理地形效果(); 
			                            this.绘制血条(); 
			                            添加日志(
			                                `${this.类型} 被击退了！`,
			                                "信息"
			                            );
			                        }
			                    }
			                }
			            }
			            this.绘制血条();
			        }
			    }
			
			    绘制血条(隐藏血条 = false) {
			        if (隐藏血条 || (this?.永久增益?.some(b => b.类型 === '永久隐身'))) {
			            return;
			        }
			
			        const 怪物所在房间 =
			            房间地图[this.y]?.[this.x] !== -1
			                ? 房间列表[房间地图[this.y][this.x]]
			                : null;
			        if (
			            (当前天气效果.includes("深夜") &&
			                !是否在光源范围内(this.x, this.y)) ||
			            (怪物所在房间?.类型 === "黑暗房间" &&
			                !是否在光源范围内(this.x, this.y))
			        ) {
			            return;
			        }
			        const 动画状态 = 怪物动画状态.get(this);
			        let 绘制逻辑X = this.x;
			        let 绘制逻辑Y = this.y;
			        const 正在动画 = 动画状态?.正在动画;
			
			        if (正在动画) {
			            绘制逻辑X =
			                动画状态.视觉X !== undefined
			                    ? 动画状态.视觉X
			                    : this.x;
			            绘制逻辑Y =
			                动画状态.视觉Y !== undefined
			                    ? 动画状态.视觉Y
			                    : this.y;
			        }
			
			        const 屏幕X = (绘制逻辑X - 当前相机X) * 单元格大小;
			        const 屏幕Y = (绘制逻辑Y - 当前相机Y) * 单元格大小;
			        const 宽度 = 单元格大小;
			
			        const 活跃且区域可见 =
			            this.状态 === 怪物状态.活跃 &&
			            (房间地图[this.y][this.x] === -1 ||
			                已访问房间.has(房间地图[this.y][this.x]));
			
			        if (活跃且区域可见) {
			            const 血条高度 = 4;
			            const 血条Y = 屏幕Y - 12;
			            const 血条背景色 = "#444";
			            const 血条前景色 = "#f00";
			
			            ctx.save();
			            ctx.fillStyle = 血条背景色;
			            ctx.fillRect(屏幕X, 血条Y, 宽度, 血条高度);
			
			            const 血量百分比 = Math.max(
			                0,
			                (this.当前生命值 / this.生命值) * 100
			            );
			            ctx.fillStyle = 血条前景色;
			            ctx.fillRect(
			                屏幕X,
			                血条Y,
			                宽度 * (血量百分比 / 100),
			                血条高度
			            );
			            ctx.restore();
			        }
			    }
			    触发受击动画() {
			        this.受击动画 = true;
			        绘制();
			        setTimeout(() => {
			            this.受击动画 = false;
			            绘制();
			        }, 200);
			    }
			}
			class 幽灵怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.幽灵仆从,
			            基础生命值: 15 + (配置.强化 ? 10 : 0),
			            基础攻击力: 4 + (配置.强化 ? 2 : 0),
			            移动率: 0.8,
			            掉落概率: 0.1,
			            掉落物: new 灵能盾牌({}),
			            基础攻击范围: 1,
			            跟踪距离: 30,
			            受伤冻结回合: 1,
			            ...配置,
			        });
			        if (this.掉落物) {
			            this.尝试添加随机词条到掉落物(this.掉落物);
			        }
			    }
			
			    检查移动可行性(fromX, fromY, toX, toY) {
			        if (
			            toX < 0 ||
			            toX >= 地牢大小 ||
			            toY < 0 ||
			            toY >= 地牢大小
			        )
			            return false;
			
			        const 目标单元格 = 地牢[toY][toX];
			
			        if (目标单元格.背景类型 === 单元格类型.上锁的门) {
			            return false;
			        }
			
			        if (目标单元格.关联怪物 && 目标单元格.关联怪物 !== this) {
			            return false;
			        }
			
			        return true;
			    }
			
			    规划移动路径() {
			        let 当前位置 = { x: this.x, y: this.y };
			        let 有效位置 = null;
			        let 可行距离 = this.移动距离 + 1;
			
			        for (
			            let i = 0;
			            i < Math.min(this.目标路径.length, 可行距离);
			            i++
			        ) {
			            const 节点 = this.目标路径[i];
			            const nextX = 节点.x;
			            const nextY = 节点.y;
			
			            if (
			                this.检查移动可行性(
			                    当前位置.x,
			                    当前位置.y,
			                    nextX,
			                    nextY
			                )
			            ) {
			                if (this.位置合法(nextX, nextY)) {
			                    有效位置 = { x: nextX, y: nextY };
			                }
			            } else {
			                this.目标路径 = this.目标路径.slice(i);
			                return 当前位置;
			            }
			
			            当前位置 = { x: nextX, y: nextY };
			
			            if (
			                有效位置 &&
			                i >=
			                    Math.min(this.移动距离, this.目标路径.length) -
			                        1
			            ) {
			                this.目标路径 = this.目标路径.slice(i + 1);
			                return 有效位置;
			            }
			        }
			
			        if (有效位置) this.目标路径 = [];
			        return 有效位置;
			    }
			
			    位置合法(x, y) {
			        const 单元格 = 地牢[y]?.[x];
			        if (!单元格) return false;
			
			        if ([单元格类型.上锁的门].includes(单元格.背景类型))
			            return false;
			
			        if (
			            (单元格.关联怪物 && 单元格.关联怪物 !== this) ||
			            (单元格.关联物品 && 单元格.关联物品.阻碍怪物)
			        ) {
			            return false;
			        }
			
			        return true;
			    }
			
			    计算目标路径(目标X, 目标Y) {
			        this.目标 = { x: 目标X, y: 目标Y };
			        const 开放列表 = [];
			        const 关闭列表 = new Set();
			        const 方向映射表 = [
			            { dx: 1, dy: 0 },
			            { dx: -1, dy: 0 },
			            { dx: 0, dy: 1 },
			            { dx: 0, dy: -1 },
			        ];
			
			        const 起点节点 = {
			            x: this.x,
			            y: this.y,
			            g: 0,
			            parent: null,
			        };
			        开放列表.push(起点节点);
			        关闭列表.add(`${起点节点.x},${起点节点.y}`);
			
			        while (开放列表.length > 0) {
			            let 当前节点 = 开放列表.shift();
			
			            if (当前节点.x === 目标X && 当前节点.y === 目标Y) {
			                const 路径 = [];
			                while (当前节点.parent) {
			                    路径.push(当前节点);
			                    当前节点 = 当前节点.parent;
			                }
			                return 路径.reverse();
			            }
			
			            方向映射表.forEach((方向) => {
			                const 新X = 当前节点.x + 方向.dx;
			                const 新Y = 当前节点.y + 方向.dy;
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    return;
			
			                const 目标单元格 = 地牢[新Y][新X];
			                if (目标单元格.背景类型 === 单元格类型.上锁的门)
			                    return;
			
			                const 位置键 = `${新X},${新Y}`;
			                if (!关闭列表.has(位置键)) {
			                    开放列表.push({
			                        x: 新X,
			                        y: 新Y,
			                        g: 当前节点.g + 1,
			                        parent: 当前节点,
			                    });
			                    关闭列表.add(位置键);
			                }
			            });
			        }
			        return null;
			    }
			
			    计算路径(目标X, 目标Y) {
			        return this.计算目标路径(目标X, 目标Y);
			    }
			}
			class 超速怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.超速怪物,
			            类型: "超速怪物",
			            强化: 配置.强化 || false,
			            掉落物: new 时空罗盘({
			                数量: 1,
			            }),
			            掉落概率: 0.3,
			            房间ID: 配置.房间ID || null,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.休眠,
			            基础生命值: 配置.基础生命值 || 28,
			            基础攻击力: 配置.基础攻击力 || 4,
			            移动率: 配置.移动率 || 0.85,
			            ...配置
			        });
			        this.加速范围 = 配置.加速范围 ?? 3;
			        this.加速回合数 = 配置.加速回合数 ?? (2 + (配置.强化 ? 1 : 0));
			    }
			}
			class 蜈蚣部位 extends 怪物 {
    constructor(配置 = {}) {
        super({
            图标: '●',
            类型: "蜈蚣部位",
            基础生命值: 25,
            基础攻击力: 5,
            移动率: 1.0,
            掉落概率: 0,
            掉落物: new 金币({ 数量: 10 }),
            ...配置,
        });
        this.主体 = 配置.主体;
        this.跟随 = 配置.跟随;
        this.强化=false
        this.前置X = this.跟随 ? this.跟随.x : this.x;
        this.前置Y = this.跟随 ? this.跟随.y : this.y;
        this.阻碍怪物 = true;
        this.存档ID = 配置.存档ID || `centipede_${prng()}`;
        this.基础颜色 = 配置.基础颜色 || '#FFFFFF';
    }

    执行移动() {
        if (!this.跟随 || this.跟随.当前生命值 <= 0) {
            this.受伤(9999); 
            return;
        }

        const 旧X = this.x;
        const 旧Y = this.y;
        const 目标X = this.跟随.前置X;
        const 目标Y = this.跟随.前置Y;

        if (this.x === 目标X && this.y === 目标Y) return;

        this.恢复背景类型();
        this.x = 目标X;
        this.y = 目标Y;
        this.保存新位置类型(this.x, this.y);
        地牢[this.y][this.x].类型 = 单元格类型.怪物;
        地牢[this.y][this.x].关联怪物 = this;
        怪物动画状态.set(this, {
            旧逻辑X: 旧X, 旧逻辑Y: 旧Y,
            目标逻辑X: this.x, 目标逻辑Y: this.y,
            视觉X: 旧X, 视觉Y: 旧Y,
            动画开始时间: Date.now(), 正在动画: true,
        });

        this.前置X = 旧X;
        this.前置Y = 旧Y;
    }

    受伤(伤害, 来源 = null) {
        if (this.当前生命值 <= 0) return;
        this.当前生命值 -= 伤害;
        if (中文模式) this.触发受击动画();

        if (this.当前生命值 <= 0) {
            this.主体?.执行分裂(this);
            this.移除自身();
        }
        this.主体?.绘制血条();
    }
    
    移除自身(整体删除=false) {
        this.恢复背景类型();
        if (this.血条元素) this.血条元素.remove();
        所有怪物 = 所有怪物.filter(m => m !== this);
        怪物状态表.delete(this);
        
        if (this.主体 && this.主体.身体部位 && !整体删除) {
            const index = this.主体.身体部位.indexOf(this);
            if (index > -1) {
                this.主体.身体部位.splice(index, 1);
            }
        }
    }
    
    绘制血条(隐藏 = false) { }
    尝试移动() {if (!this.跟随 || this.跟随.当前生命值 <= 0) {
            this.受伤(9999); 
            return;
        } } 
    尝试攻击() {
        if ((this.当前生命值 / this.生命值) < 0.4) this.基础攻击力 += 3
        return super.尝试攻击();
        
    }
}

class 蜈蚣怪物 extends 怪物 {
    constructor(配置 = {}) {
        super({
            
            基础生命值: 25 + (配置.强化 ? 15 : 0),
            ...配置,
            图标: 图标映射.蜈蚣怪物,
            类型: "蜈蚣怪物",
            基础攻击力: 6,
            移动率: 0.9,
            掉落物: new 金币({ 数量: 10 }),
            掉落概率: 0.8,
            
        });
        this.前置X = this.x;
        this.前置Y = this.y;
        
        this.朝向 = 配置.朝向 || 'W';
        this.长度 = 配置.长度 ?? (6 + (配置.强化 ? 2 : 0));
        this.身体部位 = 配置.身体部位 || [];
        this.是分裂体 = 配置.是分裂体 || false;
        this.存档ID = 配置.存档ID || `centipede_${prng()}`;
        
        if (配置.玩家放置 || 配置.x == null || this.是分裂体 || !位置是否可用(配置.x,配置.y,false)) {
            return;
        }
        
        this.初始化身体部位()
    }
    
    初始化身体部位() {
        if (this.身体部位.length > 0) return;
    
        const 队列 = [{ x: this.x, y: this.y, path: [{x: this.x, y: this.y}] }];
        const 已访问 = new Set([`${this.x},${this.y}`]);
        let 最终路径 = null;
    
        while (队列.length > 0) {
            const 当前 = 队列.pop();
    
            if (当前.path.length >= this.长度) {
                最终路径 = 当前.path;
                break;
            }
    
            const 方向 = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
            方向.sort(() => prng() - 0.5);
    
            for (const { dx, dy } of 方向) {
                const 新X = 当前.x + dx;
                const 新Y = 当前.y + dy;
                const key = `${当前.x},${当前.y},${新X},${新Y}`;
    
                if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小 || 已访问.has(key)) continue;
                
                if (位置是否可用(新X, 新Y, false) && 快速检查相邻移动(当前.x, 当前.y, 新X, 新Y)) {
                    已访问.add(key);
                    const 新路径 = [...当前.path, { x: 新X, y: 新Y }];
                    队列.push({ x: 新X, y: 新Y, path: 新路径 });
                }
            }
        }
        
        if (!最终路径) 最终路径 = 队列.pop()?.path || [{x: this.x, y: this.y}];

        const interpolateColor = (startHex, endHex, factor) => {
            const r1 = parseInt(startHex.slice(1, 3), 16);
            const g1 = parseInt(startHex.slice(3, 5), 16);
            const b1 = parseInt(startHex.slice(5, 7), 16);
            const r2 = parseInt(endHex.slice(1, 3), 16);
            const g2 = parseInt(endHex.slice(3, 5), 16);
            const b2 = parseInt(endHex.slice(5, 7), 16);
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        };
        const headColor = this.getRandomHexColor(); 
        const tailColor = this.getRandomHexColor(); 

        let 上一个部位 = this;
        for (let i = 1; i < 最终路径.length; i++) {
            const pos = 最终路径[i];
            const colorFactor = (i) / (最终路径.length -1);
            const segmentColor = interpolateColor(headColor, tailColor, colorFactor);
            const 新部位 = new 蜈蚣部位({
                主体: this,
                跟随: 上一个部位,
                x: pos.x,
                y: pos.y,
                
                基础生命值: this.基础生命值,
                基础颜色: segmentColor,
            });
            新部位.当前生命值 = 新部位.生命值;
            this.身体部位.push(新部位);
            
            放置怪物到单元格(新部位, pos.x, pos.y);
            上一个部位 = 新部位;
        }
        this.长度 = this.身体部位.length + 1;
    }
    getRandomHexColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(prng() * 16)];
    }
    return color;
}
    get 尾部() {
        return this.身体部位.length > 0 ? this.身体部位[this.身体部位.length - 1] : this;
    }
    
    _isSelfCollision(nextX, nextY, path, bodyParts) {
        const nextStepIndex = path.length;
        for (let i = 1; i < bodyParts.length; i++) {
            let predictedPos;
            const historyIndex = nextStepIndex - i;

            if (historyIndex >= 0) {
                predictedPos = path[historyIndex];
            } else {
                predictedPos = {x: bodyParts[i - nextStepIndex].x, y: bodyParts[i - nextStepIndex].y};
            }

            if (predictedPos && predictedPos.x === nextX && predictedPos.y === nextY) {
                return true;
            }
        }
        return false;
    }

    _findSinglePath(startNode, endNode, bodyPartsForCollision) {
        const h = (x, y) => Math.abs(x - endNode.x) + Math.abs(y - endNode.y);

        const 开放列表 = [{ x: startNode.x, y: startNode.y, g: 0, f: h(startNode.x, startNode.y), path: [{ x: startNode.x, y: startNode.y }] }];
        const 已关闭集合 = new Set([`${startNode.x},${startNode.y}`]);
        const 方向 = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
        let 最近节点 = 开放列表[0];

        while (开放列表.length > 0) {
            开放列表.sort((a, b) => a.f - b.f);
            const 当前 = 开放列表.shift();

            if (h(当前.x, 当前.y) < h(最近节点.x, 最近节点.y)) {
                最近节点 = 当前;
            }

            if (当前.x === endNode.x && 当前.y === endNode.y) {
                return 当前.path;
            }
            if (当前.path.length > this.跟踪距离 * 1.5) continue;

            for (const { dx, dy } of 方向) {
                const 新X = 当前.x + dx;
                const 新Y = 当前.y + dy;
                const key = `${新X},${新Y}`;

                if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小 || 已关闭集合.has(key)) {
                    continue;
                }

                const 目标单元格 = 地牢[新Y]?.[新X];
                if (!目标单元格 || [单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.背景类型) || (目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物) || (目标单元格.关联怪物 && 目标单元格.关联怪物.主体 !== this) ||!快速检查相邻移动(当前.x,当前.y,新X,新Y)) {
                    continue;
                }

                if (this._isSelfCollision(新X, 新Y, 当前.path, bodyPartsForCollision)) {
                    continue;
                }
                
                已关闭集合.add(key);
                const 新路径 = [...当前.path, { x: 新X, y: 新Y }];
                const g = 当前.g + 1;
                const f = g + h(新X, 新Y);
                开放列表.push({ x: 新X, y: 新Y, g, f, path: 新路径 });
            }
        }
        
        return 最近节点.path.length > 1 ? 最近节点.path : null;
    }

    寻找蜈蚣路径(目标) {
        const pathForward = this._findSinglePath(this, 目标, [this, ...this.身体部位]);

        const reversedBody = [this, ...this.身体部位].reverse();
        const newHead = reversedBody[0];
        
        
        if (pathForward) {
            return { path: pathForward, needsReversal: false };
        }
        const pathReversed = this._findSinglePath(newHead, 目标, reversedBody);
        if (pathReversed) {
            return { path: pathReversed, needsReversal: true };
        }

        return { path: null, needsReversal: false };
    }
    尝试攻击() {
        if ((this.当前生命值 / this.生命值) < 0.4) this.基础攻击力 += 3
        return super.尝试攻击();
        
    }
    尝试移动() {
        if (prng()>this.移动率) return;
        if (this.受伤冻结回合剩余 > 0) {
            this.受伤冻结回合剩余--;
            return;
        }
        
        const isLowHealth = (this.当前生命值 / this.生命值) < 0.4;
        const stepsToTake = isLowHealth ? 2 : 1;

        for (let step = 0; step < stepsToTake; step++) {
            const { path, needsReversal } = this.寻找蜈蚣路径(玩家);

            if (needsReversal) {
                this.反转();
            }
            
            const finalPath = needsReversal ? this.寻找蜈蚣路径(玩家).path : path;

            if (finalPath && finalPath.length > 1) {
                const nextStepNode = finalPath[1];
                
                const oldHeadX = this.x;
                const oldHeadY = this.y;

                const dx = nextStepNode.x - oldHeadX;
                const dy = nextStepNode.y - oldHeadY;
                if (dx > 0) this.朝向 = 'E';
                else if (dx < 0) this.朝向 = 'W';
                else if (dy > 0) this.朝向 = 'S';
                else if (dy < 0) this.朝向 = 'N';

                this.恢复背景类型();
                this.x = nextStepNode.x;
                this.y = nextStepNode.y;
                this.保存新位置类型(this.x, this.y);
                地牢[this.y][this.x].类型 = 单元格类型.怪物;
                地牢[this.y][this.x].关联怪物 = this;

                this.前置X = oldHeadX;
                this.前置Y = oldHeadY;

                怪物动画状态.set(this, {
                    旧逻辑X: oldHeadX, 旧逻辑Y: oldHeadY,
                    目标逻辑X: this.x, 目标逻辑Y: this.y,
                    视觉X: oldHeadX, 视觉Y: oldHeadY,
                    动画开始时间: Date.now(), 正在动画: true,
                });
                this.身体部位.forEach(部位 => 部位.执行移动());
            } else {
                break;
            }
        }
    }

    反转() {
        if (this.身体部位.length === 0) return;

        const allParts = [this, ...this.身体部位];
        const length = allParts.length;
        const mid = Math.floor(length / 2);

        for (let i = 0; i < mid; i++) {
            const partA = allParts[i];
            const partB = allParts[length - 1 - i];

            const posA = { x: partA.x, y: partA.y };
            const posB = { x: partB.x, y: partB.y };
            
            const prevPosA = { x: partA.前置X, y: partA.前置Y };
            const prevPosB = { x: partB.前置X, y: partB.前置Y };

            partA.恢复背景类型();
            partB.恢复背景类型();

            partA.x = posB.x;
            partA.y = posB.y;
            partB.x = posA.x;
            partB.y = posA.y;
            
            partA.前置X = prevPosB.x;
            partA.前置Y = prevPosB.y;
            partB.前置X = prevPosA.x;
            partB.前置Y = prevPosA.y;

            partA.保存新位置类型(partA.x, partA.y);
            地牢[partA.y][partA.x].关联怪物 = partA;
            地牢[partA.y][partA.x].类型 = 单元格类型.怪物;

            partB.保存新位置类型(partB.x, partB.y);
            地牢[partB.y][partB.x].关联怪物 = partB;
            地牢[partB.y][partB.x].类型 = 单元格类型.怪物;
        }
    }

    
    执行分裂(被摧毁部位) {
        const 分裂索引 = this.身体部位.indexOf(被摧毁部位);
        
        if (分裂索引 === -1 && 被摧毁部位 instanceof 蜈蚣部位) return;
        
        const 前段身体 = this.身体部位.slice(0, 分裂索引);
        let 后段身体 = this.身体部位.slice(分裂索引+1);
        if (被摧毁部位 instanceof 蜈蚣怪物) 后段身体 = [...this.身体部位]

        this.身体部位 = 前段身体;
        this.长度 = this.身体部位.length + 1;
    
        if (后段身体.length > 0) {
            const 新头部位 = 后段身体.shift();
            
            所有怪物 = 所有怪物.filter(m => m !== 新头部位);
    
            const 新蜈蚣 = new 蜈蚣怪物({
                ...新头部位,
                是分裂体: true,
                身体部位: [], 
                长度: 后段身体.length + 1,
            });
            
            所有怪物.push(新蜈蚣);
            地牢[新蜈蚣.y][新蜈蚣.x].关联怪物 = 新蜈蚣;
            
            新蜈蚣.身体部位 = 后段身体;
            let 上一个 = 新蜈蚣;
            新蜈蚣.身体部位.forEach(部位 => {
                部位.主体 = 新蜈蚣;
                部位.跟随 = 上一个;
                上一个 = 部位;
            });
        }
    }
    
    受伤(伤害, 来源 = null) {
        const 原始血量 = this.当前生命值;
        super.受伤(伤害, 来源);

        if (this.身体部位.length >= 3) {
            const 半血阈值 = this.生命值 / 2;
            if (原始血量 > 半血阈值 && this.当前生命值 <= 半血阈值) {
                
                this.执行半血分裂();
            }
        }

        if (this.当前生命值 <= 0) {
            this.移除自身();
        }
        this.绘制血条();
    }

    执行半血分裂() {
        const 分裂索引 = Math.floor(this.身体部位.length / 2);
        if (分裂索引 < 1) return;

        const 新头部位原型 = this.身体部位[分裂索引];
        const 前段身体 = this.身体部位.slice(0, 分裂索引);
        const 后段身体 = this.身体部位.slice(分裂索引 + 1);

        this.身体部位 = 前段身体;
        this.长度 = this.身体部位.length + 1;

        所有怪物 = 所有怪物.filter(m => m !== 新头部位原型);

        const 新蜈蚣 = new 蜈蚣怪物({
            ...新头部位原型,
            是分裂体: true,
            身体部位: [],
            长度: 后段身体.length + 1,
            强化:this.强化,
        });
        
        所有怪物.push(新蜈蚣);
        地牢[新蜈蚣.y][新蜈蚣.x].关联怪物 = 新蜈蚣;

        新蜈蚣.身体部位 = 后段身体;
        let 上一个 = 新蜈蚣;
        新蜈蚣.身体部位.forEach(部位 => {
            部位.主体 = 新蜈蚣;
            部位.跟随 = 上一个;
            上一个 = 部位;
        });

        显示通知(`${this.类型} 在战斗中分裂了！`, "警告");
    }
    
    移除自身() {
        this.执行分裂(this)
        this.恢复背景类型();
        if (this.血条元素) this.血条元素.remove();
        所有怪物 = 所有怪物.filter(m => m !== this);
        怪物状态表.delete(this);
    }
}
			class 吸血鬼 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.吸血鬼,
			            类型: "吸血鬼",
			            基础生命值: 25 + (配置.强化 ? 15 : 0),
			            基础攻击力: 6 + (配置.强化 ? 3 : 0),
			            移动率: 0.8,
			            掉落物: new 吸血剑({}),
			            掉落概率: 0.2,
			            攻击冷却: 1,
			            ...配置,
			        });
			        this.吸血比例 = 配置.吸血比例??(0.6 + (配置.强化 ? 0.25 : 0));
			    }
			
			    尝试攻击() {
			        const 原始血量 = this.当前生命值;
			        const 攻击成功 = super.尝试攻击();
			        if (攻击成功) {
			            const 造成伤害 = this.攻击力; 
			            const 吸血量 = Math.ceil(造成伤害 * this.吸血比例);
			            this.当前生命值 = Math.min(this.生命值, this.当前生命值 + 吸血量);
			            添加日志(`${this.类型} 吸取了你的生命，恢复了 ${吸血量} 点生命！`, "警告");
			            this.绘制血条();
			        }
			        return 攻击成功;
			    }
			}
			class 分裂怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.分裂怪物,
			            类型: "分裂怪物",
			            基础生命值: 18 + (配置.强化 ? 12 : 0),
			            基础攻击力: 4 + (配置.强化 ? 2 : 0),
			            移动率: 0.7,
			            掉落概率: 0.1,
			            掉落物: new 金币({ 数量: 5 }),
			            ...配置,
			        });
			        this.分裂冷却 = 配置.分裂冷却 ?? (5 - (配置.强化 ? 1 : 0));
			        this.分裂冷却剩余 = 配置.分裂冷却剩余 ?? this.分裂冷却;
			    }
			
			    尝试移动() {
			        super.尝试移动();
			        if (this.当前生命值 <= 0 || this.状态 !== 怪物状态.活跃) return;
			
			        if (this.分裂冷却剩余 > 0) {
			            this.分裂冷却剩余--;
			        } else {
			            this.尝试分裂();
			            this.分裂冷却剩余 = this.分裂冷却;
			        }
			    }
			
			    尝试分裂() {
			        const 方向列表 = [[0, 1], [0, -1], [1, 0], [-1, 0]];
			        方向列表.sort(() => prng() - 0.5);
			        if (所有怪物.filter((m) => m.状态 === 怪物状态.活跃 && !(m instanceof 巡逻怪物)).length > 12) return;
			
			        for (const [dx, dy] of 方向列表) {
			            const 新X = this.x + dx;
			            const 新Y = this.y + dy;
			            if (位置是否可用(新X, 新Y, true)) {
			                const 克隆体 = new 分裂怪物({ 强化: this.强化,分裂冷却:this.分裂冷却});
			                克隆体.当前生命值 = Math.max(1,this.生命值 - this.当前生命值); 
			                if (放置怪物到单元格(克隆体, 新X, 新Y)) {
			                    克隆体.状态 = 怪物状态.活跃;
			                    
			                    计划显示格子特效([{ x: 新X, y: 新Y }], "FFC0CB");
			                    return;
			                }
			            }
			        }
			    }
			}
			class 追踪风弹弹头 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.旋风,
			            类型: "追踪风弹弹头",
			            基础生命值: 1,
			            基础攻击力: 0,
			            移动率: 1.0,
			            掉落概率: 0,
			            基础移动距离: 1 + (配置.强化?1:0),
			            跟踪距离: 99,
			            ...配置,
			        });
			        this.生命周期 = 25;
			        this.状态 = 怪物状态.活跃;
			    }
			
			    尝试移动() {
			        this.生命周期--;
			        if (this.生命周期 <= 0) {
			            this.受伤(999, '消散');
			            return;
			        }
			
			        const 最近目标 = this.寻找最近怪物目标();
			        if (最近目标) {
			            this.目标路径 = this.计算路径(最近目标.x, 最近目标.y);
			            super.尝试移动();
			
			            if (Math.abs(this.x - 最近目标.x) <= 1 && Math.abs(this.y - 最近目标.y) <= 1) {
			                this.触发爆炸();
			            }
			        } else {
			            this.受伤(999, '无目标');
			        }
			    }
			
			    寻找最近怪物目标() {
			        let 最近距离 = Infinity;
			        let 最近目标 = null;
			        所有怪物.forEach(怪物 => {
			            if (怪物.状态 === 怪物状态.活跃 && !(怪物 instanceof 追踪风弹弹头)) {
			                const 距离 = Math.abs(this.x - 怪物.x) + Math.abs(this.y - 怪物.y);
			                if (距离 < 最近距离) {
			                    最近距离 = 距离;
			                    最近目标 = 怪物;
			                }
			            }
			        });
			        return 最近目标;
			    }
			    
			    触发爆炸() {
			        const 爆炸中心X = this.x;
			        const 爆炸中心Y = this.y;
			        const 影响范围 = 1 + (this.强化?1:0);
			        const 眩晕格子 = [];
			
			        for (let dy = -影响范围; dy <= 影响范围; dy++) {
			            for (let dx = -影响范围; dx <= 影响范围; dx++) {
			                const x = 爆炸中心X + dx;
			                const y = 爆炸中心Y + dy;
			                if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
			                    眩晕格子.push({ x, y })
			                    计划显示格子特效([{x,y}], "ADD8E6");
			                    const 单元格 = 地牢[y]?.[x];
			                    if (单元格?.关联怪物?.当前生命值 > 0 && !(单元格.关联怪物 instanceof 追踪风弹弹头)) {
			                        new 状态效果("眩晕", 效果颜色编号映射[效果名称编号映射.眩晕], 图标映射.眩晕, 4+ (this.强化?2:0), null, null, 单元格.关联怪物);
			                        单元格?.关联怪物?.受伤(9,this);
			                    }
			                }
			            }
			        }
			        
			
			        this.受伤(999, '命中');
			    }
			
			
			
			    绘制血条(隐藏血条 = true) {
			
			    }
			
			    尝试攻击() { return false; }
			}
			class 巨人部位 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.巨人部位,
			            类型: "巨人部位",
			            基础生命值: 9999,
			            基础攻击力: 0,
			            移动率: 0,
			            掉落概率: 0,
			            ...配置,
			        });
			        this.主体 = 配置.主体;
			        this.状态 = 怪物状态.活跃
			    }
			    get 当前生命值() {
			        return this.主体 ? this.主体.当前生命值 : 0;
			    }
			
			    set 当前生命值(值) {
			        if (this.主体) {
			            this.主体.当前生命值 = 值;
			        }
			    }
			
			    get 生命值() {
			        return this.主体 ? this.主体.生命值 : 0;
			    }
			    
			    尝试移动() { return; }
			    尝试攻击() { return false; }
			
			    受伤(伤害, 来源 = null) {
			        if (this.主体) {
			            this.主体.受伤(伤害, 来源);
			        }
			    }
			    
			    获得效果(效果) {
			        if (this.主体) {
			            const 现有主体效果 = 怪物状态表.get(this.主体);
			            if (现有主体效果 && 现有主体效果.类型 === 效果.类型) {
			                 现有主体效果.剩余回合 = Math.max(现有主体效果.剩余回合, 效果.剩余回合);
			                 现有主体效果.强度 = Math.min(5, (现有主体效果.强度 || 1) + (效果.强度 || 1));
			            } else {
			                const 新状态 = new 状态效果(
			                    效果.类型,
			                    效果.颜色,
			                    效果.图标,
			                    效果.持续时间,
			                    效果.剩余回合,
			                    效果.来源,
			                    this.主体, 
			                    效果.强度
			                );
			            }
			            return true;
			        }
			        return false;
			    }
			
			    绘制血条(隐藏血条 = true) { return; }
			}
			
			           
			class 巨人怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.巨人怪物,
			            类型: "巨人怪物",
			            基础生命值: 80 + (配置.强化 ? 80 : 0),
			            基础攻击力: 10 + (配置.强化 ? 6 : 0),
			            移动率: 0.5,
			            掉落概率: 1.0,
			            掉落物: new 大地猛击锤({}),
			            基础攻击范围: 1, 
			            基础移动距离: 1,
			            攻击冷却: 3,
			            ...配置,
			        });
			        this.部位列表 = [
			            new 巨人部位({ 主体: this }),
			            new 巨人部位({ 主体: this }),
			            new 巨人部位({ 主体: this }),
			        ];
			        this.部位偏移 = [{dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: 1, dy: 1}];
			        this.覆盖的单元格状态 = [null, null, null, null];
			    }
			
			    恢复背景类型() {
			        const 检查位置列表 = [{x: this.x, y: this.y}, ...this.部位偏移.map(偏移 => ({x: this.x + 偏移.dx, y: this.y + 偏移.dy}))];
			        
			        检查位置列表.forEach((位置, 索引) => {
			            const 单元格 = 地牢[位置.y]?.[位置.x];
			            const 已保存状态 = this.覆盖的单元格状态[索引];
			
			            if (单元格 && 单元格.关联怪物 && (单元格.关联怪物 === this || 单元格.关联怪物.主体 === this)) {
			                if (已保存状态) {
			                    单元格.类型 = 已保存状态.类型;
			                    
			                } else {
			                    单元格.类型 = null;
			                    
			                }
			                 单元格.关联怪物 = null;
			            }
			        });
			    }
			    
			    保存新位置类型(目标X, 目标Y) {
			        const 检查位置列表 = [{x: 目标X, y: 目标Y}, ...this.部位偏移.map(偏移 => ({x: 目标X + 偏移.dx, y: 目标Y + 偏移.dy}))];
			        
			        this.覆盖的单元格状态 = 检查位置列表.map(位置 => {
			            const 单元格 = 地牢[位置.y]?.[位置.x];
			            if (单元格) {
			                return { 类型: 单元格.类型 };
			            }
			            return null;
			        });
			    }
			    计算路径(目标X, 目标Y) {
			        // 无视单层墙壁
			        const 开放列表 = [{ x: this.x, y: this.y, 距离: 0, parent: null }];
			        const 已关闭集合 = new Set([`${this.x},${this.y}`]);
			        const 前驱节点映射 = new Map();
			
			        while (开放列表.length > 0) {
			            const 当前节点 = 开放列表.shift();
			            
			            if (Math.abs(当前节点.x - 目标X) <= 1 && Math.abs(当前节点.y - 目标Y) <= 1) {
			                const 路径 = [];
			                let 追溯节点 = 当前节点;
			                while(追溯节点) {
			                    路径.unshift({x: 追溯节点.x, y: 追溯节点.y});
			                    追溯节点 = 前驱节点映射.get(`${追溯节点.x},${追溯节点.y}`);
			                }
			                路径.shift();
			                return 路径;
			            }
			
			            const 方向列表 = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
			            for (const 方向 of 方向列表) {
			                const 新X = 当前节点.x + this.移动距离*方向.dx;
			                const 新Y = 当前节点.y + this.移动距离*方向.dy;
			                const 位置标识 = `${新X},${新Y}`;
			                
			                if (已关闭集合.has(位置标识)) continue;
			                
			                let 可以移动 = true;
			                const 新位置列表 = [{x: 新X, y: 新Y}, ...this.部位偏移.map(偏移 => ({x: 新X + 偏移.dx, y: 新Y + 偏移.dy}))];
			                
			                for (const 位置 of 新位置列表) {
			                     const 单元格 = 地牢[位置.y]?.[位置.x];
			                     if (!单元格 || [单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) || (单元格.关联怪物 && 单元格.关联怪物.主体 !== this && 单元格.关联怪物 !== this)) {
			                         可以移动 = false;
			                         break;
			                     }
			                }
			                
			                if (可以移动) {
			                    已关闭集合.add(位置标识);
			                    前驱节点映射.set(位置标识, 当前节点);
			                    开放列表.push({ x: 新X, y: 新Y, 距离: 当前节点.距离 + 1, parent: 当前节点 });
			                }
			            }
			        }
			        return [];
			    }
			    尝试移动() {
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余--;
			        }
			        if (this.当前生命值 <= 0 || this.状态 !== 怪物状态.活跃 || this.移动率 > prng()) return;
			
			        this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			        if (!this.目标路径 || this.目标路径.length <= 1) return;
			
			        const 下一步 = this.目标路径[0];
			        const 方向X = 下一步.x - this.x;
			        const 方向Y = 下一步.y - this.y;
			        
			        let 可以移动 = true;
			        const 新位置列表 = [{x: this.x + 方向X, y: this.y + 方向Y}, ...this.部位偏移.map(偏移 => ({x: this.x + 方向X + 偏移.dx, y: this.y + 方向Y + 偏移.dy}))];
			        
			        for (const 位置 of 新位置列表) {
			             const 单元格 = 地牢[位置.y]?.[位置.x];
			             if (!单元格 || [单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) || (单元格.关联怪物 && 单元格.关联怪物.主体 !== this && 单元格.关联怪物 !== this)) {
			                 可以移动 = false;
			                 break;
			             } else if (单元格.关联物品?.阻碍怪物 &&
			                    !(单元格.关联物品 instanceof 罐子) &&
			                    !(单元格.关联物品 instanceof 祭坛类) &&
			                    !(单元格.关联物品?.类型 === "楼梯")) {
			                    if (单元格.关联物品 instanceof 符文圈) continue;
			            if (单元格.关联物品 instanceof 挑战石碑) continue;
			            if (单元格.关联物品 instanceof 魔法水晶) continue;
			            if (单元格.关联物品 instanceof 传送门) continue;
			            if (单元格.关联物品 instanceof 折跃门) continue;
			            if (单元格.关联物品 instanceof 临时墙壁计时器) continue;
			            if (单元格.关联物品 instanceof 告示牌) continue;
			            if (单元格.关联物品 instanceof 存档点) continue;
			            if (单元格.关联物品 instanceof 传送带) continue;
			            if (单元格.关联物品 instanceof 开关脉冲器) continue;
			            if (单元格.关联物品?.类型 === '开关砖') continue;
			            单元格.关联物品 = null;
			                        if (单元格.类型 === 单元格类型.物品)
			                            单元格.类型 = null;
			                        单元格.颜色索引 = 颜色表.length;
			                
			             }
			        }
			
			        if (可以移动) {
			            const 旧X = this.x, 旧Y = this.y;
			            this.恢复背景类型();
			            this.保存新位置类型(this.x + 方向X, this.y + 方向Y);
			            
			            this.x += 方向X;
			            this.y += 方向Y;
			
			            地牢[this.y][this.x].类型 = 单元格类型.怪物;
			            地牢[this.y][this.x].关联怪物 = this;
			
			            this.部位列表.forEach((部位, 索引) => {
			                const 偏移 = this.部位偏移[索引];
			                部位.x = this.x + 偏移.dx;
			                部位.y = this.y + 偏移.dy;
			                地牢[部位.y][部位.x].类型 = 单元格类型.怪物;
			                地牢[部位.y][部位.x].关联怪物 = 部位;
			            });
			            怪物动画状态.set(this, { 旧逻辑X: 旧X, 旧逻辑Y: 旧Y, 目标逻辑X: this.x, 目标逻辑Y: this.y, 视觉X: 旧X, 视觉Y: 旧Y, 动画开始时间: Date.now(), 正在动画: true });
			        }
			    }
			
			    尝试攻击() {
			        if (this.攻击冷却回合剩余 > 0) return false;
			        const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (玩家距离 > 5) return false;
			
			        const 路径 = 广度优先搜索路径(this.x, this.y, 玩家.x, 玩家.y, 15, true);
			
			        if (!路径 || 路径.length <= 1) return false;
			
			        const 弹道路径 = 路径.slice(0,5);
			        
			        if(弹道路径.length === 0) return false;
			        let 爆炸格子 = [];
			        弹道路径.forEach((节点, 索引) => {
			            setTimeout(() => {
			                const 弹头格子 = [
			                    {x: 节点.x, y: 节点.y},
			                    {x: 节点.x + 1, y: 节点.y},
			                    {x: 节点.x, y: 节点.y + 1},
			                    {x: 节点.x + 1, y: 节点.y + 1},
			                ];
			                
			                计划显示格子特效(弹头格子, "FFA500", 0);
			                
			                弹头格子.forEach(位置 => {
			                    if (玩家.x === 位置.x && 玩家.y === 位置.y) {
			                        伤害玩家(this.攻击力 * 0.8, this);
			                    }
			                });
			                
			                if (索引 === 弹道路径.length - 1) {
			                    setTimeout(() => {
			                        const 爆炸范围 = 2;
			                        const 爆炸中心X = 节点.x;
			                        const 爆炸中心Y = 节点.y;
			                        
			
			                        for (let dy = -爆炸范围; dy <= 爆炸范围; dy++) {
			                            for (let dx = -爆炸范围; dx <= 爆炸范围; dx++) {
			                               if (Math.abs(dx) + Math.abs(dy) <= 爆炸范围) {
			                                   
			                                   计划显示格子特效([{x: 爆炸中心X + dx, y: 爆炸中心Y + dy}], "A52A2A")
			                               }
			                            }
			                        }
			                        
			                        
			                        爆炸格子.forEach(位置 => {
			                             if (玩家.x === 位置.x && 玩家.y === 位置.y) {
			                                 伤害玩家(this.攻击力 * 1.2, this);
			                             }
			                        });
			
			                    }, 150);
			                }
			            }, 索引 * 120);
			        });
			        
			        this.攻击冷却回合剩余 = this.攻击冷却;
			        return true;
			    }
			    
			    计算巨人最大甩飞位置(起始X, 起始Y, 方向DX, 方向DY, 最大距离) {
			        let 最远有效位置 = { x: 起始X, y: 起始Y };
			
			        if (方向DX === 0 && 方向DY === 0) return 最远有效位置;
			
			        for (let i = 1; i <= 最大距离; i++) {
			            const 尝试X = 起始X + 方向DX * i;
			            const 尝试Y = 起始Y + 方向DY * i;
			
			            let 区域是否可用 = true;
			            const 检查区域 = [{dx: 0, dy: 0}, ...this.部位偏移];
			
			            for(const 偏移 of 检查区域) {
			                const 检查X = 尝试X + 偏移.dx;
			                const 检查Y = 尝试Y + 偏移.dy;
			                const 单元格 = 地牢[检查Y]?.[检查X];
			
			                if (!单元格 || [单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) || (单元格.关联怪物 && 单元格.关联怪物.主体 !== this && 单元格.关联怪物 !== this) || 单元格.关联物品?.阻碍怪物) {
			                    区域是否可用 = false;
			                    break;
			                }
			            }
			            
			            if (!区域是否可用) {
			                break;
			            } else {
			                最远有效位置 = { x: 尝试X, y: 尝试Y };
			            }
			        }
			        return 最远有效位置;
			    }
			    
			    受伤(伤害, 来源 = null) {
			        if (this.当前生命值 <= 0) return;
			        
			        this.当前生命值 -= 伤害;
			        if (中文模式) this.触发受击动画();
			
			        if (this.当前生命值 <= 0) {
			            this.恢复背景类型();
			            所有怪物 = 所有怪物.filter(m => m !== this && m.主体 !== this);
			            
			            return;
			        }
			
			        let 触发击退 = false;
			        let 来源坐标 = null;
			        if (来源 === "玩家" || 来源 instanceof 武器类 || (来源 instanceof 怪物 && 来源 !== this)) {
			            触发击退 = true;
			            来源坐标 = { x: 来源?.x ?? 玩家.x, y: 来源?.y ?? 玩家.y };
			            this.受伤冻结回合剩余 = this.受伤冻结回合;
			        }
			
			        if (触发击退 && 来源坐标) {
			            let 方向X = this.x - 来源坐标.x;
			            let 方向Y = this.y - 来源坐标.y;
			            let 击退方向DX = 0, 击退方向DY = 0;
			
			            if (Math.abs(方向X) > Math.abs(方向Y)) {
			                击退方向DX = Math.sign(方向X);
			            } else {
			                击退方向DY = Math.sign(方向Y);
			            }
			            if (击退方向DX === 0 && 击退方向DY === 0 && (方向X !== 0 || 方向Y !== 0)) {
			                 击退方向DX = Math.sign(方向X);
			                 击退方向DY = Math.sign(方向Y);
			                 if (Math.abs(方向X) > Math.abs(方向Y)) 击退方向DY = 0; else 击退方向DX = 0;
			            }
			
			            if (击退方向DX !== 0 || 击退方向DY !== 0) {
			                const { x: 最终X, y: 最终Y } = this.计算巨人最大甩飞位置(this.x, this.y, 击退方向DX, 击退方向DY, 1);
			                
			                if (最终X !== this.x || 最终Y !== this.y) {
			                    const 旧X = this.x, 旧Y = this.y;
			                    this.恢复背景类型();
			                    this.保存新位置类型(最终X, 最终Y);
			                    this.x = 最终X;
			                    this.y = 最终Y;
			                    
			                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
			                    地牢[this.y][this.x].关联怪物 = this;
			
			                    this.部位列表.forEach((部位, 索引) => {
			                        const 偏移 = this.部位偏移[索引];
			                        部位.x = this.x + 偏移.dx;
			                        部位.y = this.y + 偏移.dy;
			                        地牢[部位.y][部位.x].类型 = 单元格类型.怪物;
			                        地牢[部位.y][部位.x].关联怪物 = 部位;
			                    });
			                    怪物动画状态.set(this, { 旧逻辑X: 旧X, 旧逻辑Y: 旧Y, 目标逻辑X: this.x, 目标逻辑Y: this.y, 视觉X: 旧X, 视觉Y: 旧Y, 动画开始时间: Date.now(), 正在动画: true });
			                    
			                }
			            }
			        }
			        this.绘制血条();
			    }
			}
			
			
			
			class 复活怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.复活怪物,
			            类型: "复活怪物",
			            基础生命值: 40 + (配置.强化 ? 30 : 0),
			            基础攻击力: 6 + (配置.强化 ? 3 : 0),
			            移动率: 0.7,
			            掉落物: null,
			            掉落概率: 0,
			            ...配置,
			        });
			        this.复活冷却 = 配置.复活冷却??5;
			        //this.复活冷却剩余 = 配置.复活冷却剩余??5;
			        this.最近击杀列表 = [];
			    }
			    加入复活怪物(怪物) {
			        if (this.最近击杀列表.length > 10) { 
			                        this.最近击杀列表.shift();
			                    }
			        this.最近击杀列表.push(怪物)
			    }
			
			    尝试移动() {
			        if (this.最近击杀列表.length > 0) {
			            const 被复活的数据 = this.最近击杀列表.slice(-1)[0];
			            const 怪物类 = window[被复活的数据.类名];
			            if (怪物类 && 被复活的数据.类名!=='大魔法师' && 被复活的数据.类名!=='米诺陶' && 被复活的数据.类名!=='墓碑' && 被复活的数据.类名!=='王座守护者' && 被复活的数据.类名!=='皇家守卫' && 被复活的数据.类名!=='复活怪物' && 被复活的数据.类名!=='巨人怪物' && 被复活的数据.类名!=='追踪风弹弹头' && 被复活的数据.类名!=='蜈蚣怪物' && 被复活的数据.类名!=='蜈蚣部位') {
			                if (被复活的数据.冷却>0) {
			                    被复活的数据.冷却-=this.强化?2:1;
			                    
			                }
			                
			            } else {
			                this.最近击杀列表.pop();
			            }
			        }
			        super.尝试移动();
			    }
			
			    尝试攻击() {
			        let ret=super.尝试攻击();
			        if (this.最近击杀列表.length > 0 && ret) {
			            const 被复活的数据 = this.最近击杀列表.slice(-1)[0];
			            const 怪物类 = window[被复活的数据.类名];
			            if (怪物类 && 被复活的数据.类名!=='大魔法师' && 被复活的数据.类名!=='米诺陶' && 被复活的数据.类名!=='墓碑' && 被复活的数据.类名!=='王座守护者' && 被复活的数据.类名!=='皇家守卫' && 被复活的数据.类名!=='复活怪物' && 被复活的数据.类名!=='巨人怪物' && 被复活的数据.类名!=='追踪风弹弹头' && 被复活的数据.类名!=='蜈蚣怪物' && 被复活的数据.类名!=='蜈蚣部位') {
			                if (被复活的数据.冷却>0) {
			                    return;
			                }
			                const 放置位置 = 寻找可放置位置(this.x, this.y);
			                if (放置位置) {
			                    const 新怪物 = new 怪物类({ ...被复活的数据.配置, 状态: 怪物状态.活跃 });
			                    放置怪物到单元格(新怪物, 放置位置.x, 放置位置.y);
			                    显示通知(`${this.类型} 复活了 ${新怪物.类型}!`, "警告");
			                    计划显示格子特效([{x: 放置位置.x, y: 放置位置.y}], "8A2BE2");
			                    //this.复活冷却剩余 = this.复活冷却;
			                    this.最近击杀列表.pop();
			                    return true;
			                }
			            } else {
			                this.最近击杀列表.pop();
			            }
			        }
			        return ret;
			    }
			
			    受伤(伤害, 来源 = null) {
			        const 原始血量 = this.当前生命值;
			        super.受伤(伤害, 来源);
			        if (原始血量 > 0 && this.当前生命值 <= 0) {
			            const 娃娃 = new 娃娃怪物({ x: this.x, y: this.y, 房间ID: this.房间ID, 状态: 怪物状态.活跃, 强化: this.强化 });
			            放置怪物到单元格(娃娃, this.x, this.y);
			        }
			    }
			}
			class 娃娃怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.娃娃怪物,
			            类型: "娃娃怪物",
			            基础生命值: 15 + (配置.强化 ? 10 : 0),
			            基础攻击力: 0,
			            移动率: 1.0,
			            掉落物: new 金币({数量: 20}),
			            掉落概率: 1,
						追踪距离: 15,
			            ...配置,
			        });
			        this.生命周期 = 10;
			    }
			
			    尝试移动() {
			        this.生命周期--;
			        if (this.生命周期 <= 0) {
			            this.变形();
			            return;
			        }
			
			        const 逃离点 = this.选择逃离目标(玩家.x, 玩家.y, 99);
			        if (逃离点) {
			            this.目标路径 = this.计算路径(逃离点.x, 逃离点.y);
			            super.尝试移动();
			        }
			    }
			
			    变形() {
			        this.恢复背景类型();
			        所有怪物 = 所有怪物.filter(m => m !== this);
			        const 复活者 = new 复活怪物({ x: this.x, y: this.y, 房间ID: this.房间ID, 状态: 怪物状态.活跃, 强化: this.强化 });
			        放置怪物到单元格(复活者, this.x, this.y);
			        显示通知(`${this.类型} 变回了 ${复活者.类型}!`, "警告");
			        计划显示格子特效([{x: this.x, y: this.y}], "FF00FF");
			    }
			
			    尝试攻击() {
			        return false;
			    }
			}
			            class 皇家守卫 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.皇家守卫,
			            类型: "皇家守卫",
			            基础生命值: 120,
			            基础攻击力: 10,
			            移动率: 0.9,
			            基础移动距离: 1,
			            攻击冷却: 2,
			            掉落概率: 0.2,
			            掉落物: new 秘银锁甲({ 强化: true }),
			            ...配置,
			        });
			        this.守护距离 = 3;
			        this.独立 = 配置.独立??false
			        
			        this.闪避几率 = 0.25; // 25%的几率闪避攻击
			        this.技能冷却 = {
			            居合斩: 5,
			            召唤: 8,
			        };
			        this.技能冷却剩余 = {
			            居合斩: 2, // 初始冷却，避免开场就用
			            召唤: 5,
			        };
			    }
			
			    
			    更新技能冷却() {
			        for (const 技能名称 in this.技能冷却剩余) {
			            if (this.技能冷却剩余[技能名称] > 0) {
			                this.技能冷却剩余[技能名称]--;
			            }
			        }
			    }
			
			    尝试移动() {
			        const 守护者 = 所有怪物.find(m => m instanceof 王座守护者);
			        if (守护者 && !this.独立) {
			            const 距离 = Math.abs(this.x - 守护者.x) + Math.abs(this.y - 守护者.y);
			            if (距离 > this.守护距离) {
			                this.目标路径 = this.计算路径(守护者.x, 守护者.y);
			            } else {
			                this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			            }
			        } else {
			            this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			        }
			        super.尝试移动();
			    }
			
			    // 修改：重构攻击AI以使用新技能
			    尝试攻击() {
			        this.更新技能冷却();
			
			        const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        
			        // 技能优先级判断
			        if (this.技能冷却剩余.居合斩 <= 0 && 玩家距离 > 1 && 玩家距离 <= 6) {
			            if (this.执行居合斩()) {
			                return true;
			            }
			        }
			        
			        if (this.技能冷却剩余.召唤 <= 0) {
			            if (this.执行召唤()) {
			                return true;
			            }
			        }
			        
			        // 如果技能不满足条件，则执行普通攻击
			        return super.尝试攻击();
			    }
			
			    执行居合斩() {
			        const 冲锋距离 = 10;
			        const vecX = 玩家.x - this.x;
			        const vecY = 玩家.y - this.y;
			    
			        if (vecX === 0 && vecY === 0) return false;
			    
			        const len = Math.sqrt(vecX * vecX + vecY * vecY);
			        const normX = vecX / len;
			        const normY = vecY / len;
			    
			        const 终点X = Math.round(this.x + normX * 冲锋距离);
			        const 终点Y = Math.round(this.y + normY * 冲锋距离);
			    
			        const 冲锋路径 = 获取直线路径(this.x, this.y, 终点X, 终点Y).slice(1);
			        if (冲锋路径.length === 0) return false;
			    
			        let 最终落点 = { x: this.x, y: this.y };
			        let 实际冲锋路径 = [];
			    
			        for (const 路径节点 of 冲锋路径) {
			            const 单元格 = 地牢[路径节点.y]?.[路径节点.x];
			            if (!单元格 || 单元格.背景类型 === 单元格类型.墙壁 || (单元格.关联物品 && 单元格.关联物品.阻碍怪物)||!位置是否可用(路径节点.x,路径节点.y,false)) {
			                break;
			            }
			            实际冲锋路径.push(路径节点);
			            最终落点 = 路径节点;
			        }
			    
			        if (实际冲锋路径.length === 0) return false;
			    
			        计划显示格子特效(实际冲锋路径, "FFFFFF", 10);
			        
			        if (实际冲锋路径.some(点 => 点.x === 玩家.x && 点.y === 玩家.y)) {
			             伤害玩家(this.攻击力 * 1.2, this);
			        }
					当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && 实际冲锋路径.some(点 => 点.x === pet.x && 点.y === pet.y) && pet.层数==当前层数) {
        pet.受伤(this.攻击力 * 1.2);
        添加日志(`${pet.名称} 被王权冲锋击中了！`, "警告");
    }
});
			       
			        const 旧X = this.x, 旧Y = this.y;
			        怪物动画状态.set(this, {
			    旧逻辑X: 旧X,
			    旧逻辑Y: 旧Y,
			    目标逻辑X: 最终落点.x,
			    目标逻辑Y: 最终落点.y,
			    视觉X: 旧X,
			    视觉Y: 旧Y,
			    动画开始时间: Date.now(),
			    正在动画: true,
			});
			        this.恢复背景类型();
			        this.x = 最终落点.x; 
			        this.y = 最终落点.y;
			        this.保存新位置类型(this.x, this.y);
			        地牢[this.y][this.x].类型 = 单元格类型.怪物;
			        地牢[this.y][this.x].关联怪物 = this;
			        
			
			        this.技能冷却剩余.居合斩 = this.技能冷却.居合斩;
			        显示通知(`${this.类型} 发动了居合斩！`, '警告');
			        return true;
			    }
			
			    // 新增：随机召唤技能实现
			    执行召唤() {
			        const 放置位置 = 寻找可放置位置(this.x, this.y);
			        if (!放置位置 || 所有怪物.length>15) return false;
			
			        const 怪物池选择 = 怪物池.上锁房间.filter(m => !['大魔法师', '米诺陶', '皇家守卫','复活怪物','萨满怪物','巨人怪物','蜈蚣怪物'].includes(m.类.name));
			        const 选定怪物类 = 怪物池选择[Math.floor(prng() * 怪物池选择.length)];
			        
			        
			        const 新怪物 = new 选定怪物类.类({状态: 怪物状态.活跃});
			        if (放置怪物到单元格(新怪物, 放置位置.x, 放置位置.y)) {
			            计划显示格子特效([{x: 放置位置.x, y: 放置位置.y}], "483D8B");
			            显示通知(`${this.类型} 召唤了 ${新怪物.类型}！`, '警告');
			            this.技能冷却剩余.召唤 = this.技能冷却.召唤;
			            return true;
			        }
			        return false;
			    }
			
			    // 修改：受伤时有几率闪避
			    受伤(伤害, 来源 = null) {
			        if (prng() < this.闪避几率) {
			            显示通知(`${this.类型} 灵巧地闪开了攻击！`, '成功');
			            计划显示格子特效([{x: this.x, y: this.y}], "FFFFFF"); // 显示一个白色闪光特效
			            return; // 直接返回，不承受伤害
			        }
			        
			        // 如果没有闪避，则调用父类的受伤方法
			        super.受伤(伤害, 来源);
			        
			        if (this.当前生命值 <= 0) {
			            添加日志(`${this.类型} 倒下了，守护者的护盾产生了一丝裂痕...`, '信息');
			        }
			    }
			}
			class 移动弹幕 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.移动弹幕,
			            类型: "移动弹幕",
			            基础生命值: 1, // 一击即碎
			            基础攻击力: 8 + (配置.强化 ? 4 : 0),
			            移动率: 1.0, 
			            掉落概率: 0,
			            基础攻击范围: 1,
			            跟踪距离: 99,
			            基础移动距离: 2,
			            ...配置,
			        });
			        this.生命周期 = 15; // 存在15回合
			        this.状态 = 怪物状态.活跃;
			    }
			
			    尝试移动() {
			        this.生命周期--;
			        if (this.生命周期 <= 0) {
			            this.受伤(999, '消散');
			            return;
			        }
			        // 始终朝向玩家移动
			        this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			        super.尝试移动();
			    }
			
			    尝试攻击() {
			        const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (玩家距离 <= 1) {
			            伤害玩家(this.攻击力, this);
			            this.受伤(999, '撞击');
			            计划显示格子特效([{x: this.x, y: this.y}], "8A2BE2");
			        }
			        return false; // 不进行常规攻击判定
			    }
			
			    受伤(伤害, 来源 = null) {
			        this.恢复背景类型();
			        if(this.血条元素) this.血条元素.remove();
			        所有怪物 = 所有怪物.filter(m => m !== this);
			        怪物状态表.delete(this);
			    }
			
			     绘制血条(隐藏血条 = true) {
			        if (this.血条元素) {
			            this.血条元素.style.display = "none";
			        }
			    }
			}
			
			class 墓碑 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.墓碑,
			            类型: "墓碑",
			            基础生命值: 40 + (配置.强化 ? 40 : 0),
			            基础攻击力: 0,
			            移动率: 0, // 不会移动
			            掉落概率: 0.1,
			            掉落物: new 金币({数量: 50}),
			            ...配置,
			        });
			        this.召唤冷却 = 5;
			        this.召唤冷却剩余 = Math.floor(prng() * 5);
			        this.守护者 = 配置.守护者; // 引用Boss实例
			        this.状态 = 怪物状态.活跃;
			    }
			
			    尝试移动() {
			        if (地牢[this.y][this.x].关联怪物 !== this) this.受伤(999,'玩家')
			    }
			    
			    尝试攻击() {
			        this.召唤冷却剩余--;
			        if (this.召唤冷却剩余 <= 0) {
			            this.召唤冷却剩余 = this.召唤冷却;
			            const 放置位置 = 寻找可放置位置(this.x, this.y);
			            if (放置位置) {
			                const 新怪物 = new 幽灵仆从({状态: 怪物状态.活跃});
			                放置怪物到单元格(新怪物, 放置位置.x, 放置位置.y);
			                计划显示格子特效([{x: 放置位置.x, y: 放置位置.y}], "483D8B");
			            }
			        }
			        return false;
			    }
			
			    受伤(伤害, 来源 = null) {
			        super.受伤(伤害, 来源);
			        if (this.当前生命值 <= 0) {
			            if (this.守护者) {
			                this.守护者.激活的墓碑列表 = this.守护者.激活的墓碑列表.filter(墓碑 => 墓碑 !== this);
			                if (this.守护者.激活的墓碑列表.length === 0) {
			                    this.守护者.无敌 = false;
			                    显示通知("所有墓碑已被摧毁，守护者的屏障消失了！", "成功", true);
			                }
			            }
			        }
			    }
			}
			class 王座守护者 extends 怪物{
				constructor(配置={}){
					super({
						图标:图标映射.王座守护者,
						类型:"王座守护者",
						基础生命值:800,
						基础攻击力:10,
						移动率:0.8,
						掉落概率:0,
						掉落物:new 冲撞牛角({强化:true}),
						基础攻击范围:5,
						跟踪距离:100,
						攻击冷却:1,
						残血逃跑: false,
						...配置,
					});
					this.当前阶段=1;
					this.技能冷却={
					    三连重劈:5,
						召唤皇家卫队:20,
						王权冲锋:6,
						圣光弹幕:5,
						幽魂弹幕:9,
						墓碑召唤:20,
						裂隙跳跃:5,
						领域脉冲:8,
						召唤混沌回响:10,
						混沌风暴:15,
						生成混沌裂隙:9,
						无尽回响:7,
						螺旋圣光:10,
						十字审判:12,
					};
					this.技能冷却剩余={...this.技能冷却};
					this.皇家守卫列表=[];
					this.无敌=false;
					this.激活的墓碑列表=[];
					this.无敌次数 = 0
				}
				更新技能冷却(){
					for(const 技能 in this.技能冷却剩余){
						if(this.技能冷却剩余[技能]>0){
							if(!(技能==='墓碑召唤'&&this.无敌) && !(技能==='召唤皇家卫队'&&this.皇家守卫列表.length>2)) this.技能冷却剩余[技能]--;
						}
					}
				}
				受伤(伤害,来源=null){
					if(!(来源 instanceof 武器类)&&(来源?.x!==玩家.x||来源?.y!==玩家.y))
						return;
					if(this.当前阶段===3&&prng()<0.75){
						显示通知("守护者的身影变得虚幻，躲开了攻击！","信息");
						this.裂隙跳跃();
						return;
					}
					if(this.无敌){
						显示通知("守护者被无形的力量保护着！","警告");
						return;
					}
					let 实际伤害=伤害;
					const 附近宿卫数量=this.皇家守卫列表.filter(卫兵=>卫兵.当前生命值>0&&Math.abs(this.x-卫兵.x)+Math.abs(this.y-卫兵.y)<=3).length;
					if(附近宿卫数量>0){
						const 减伤率=1-(0.4*附近宿卫数量);
						实际伤害*=Math.max(0.1,减伤率);
						添加日志(`${this.类型} 被皇家守卫保护，伤害被大幅削弱！`,"警告");
					}
					const 原始生命值=this.当前生命值;
					super.受伤(实际伤害,来源);
					if((来源==="玩家"||来源 instanceof 武器类||来源 instanceof 宠物)&&!this.无敌){
						this.强制释放随机技能();
					}
					if(this.当前生命值<=0){
						this.皇家守卫列表.forEach(卫兵=>卫兵?.受伤(9999,"守护者陨落"));
						显示通知("破碎的王座终于迎来了安息...","成功",true,5000);
						
						
						for (let 纵坐标 = 房间列表[房间列表.length - 1].y; 纵坐标 < 房间列表[房间列表.length - 1].y + 房间列表[房间列表.length - 1].h; 纵坐标++) {
			        for (let 横坐标 = 房间列表[房间列表.length - 1].x; 横坐标 < 房间列表[房间列表.length - 1].x + 房间列表[房间列表.length - 1].w; 横坐标++) {
			            const 单元格 = 地牢[纵坐标]?.[横坐标];
			            if (单元格) {
			                // 移除物品
			                if (单元格.关联物品) {
			                    // 如果物品在计时器列表中，也一并移除
			                    const 计时器索引 = 所有计时器.findIndex(计时器 => 计时器.唯一标识 === 单元格.关联物品.唯一标识);
			                    if (计时器索引 !== -1) {
			                        所有计时器.splice(计时器索引, 1);
			                    }
			                    单元格.关联物品 = null;
			                }
			                // 移除怪物
			                if (单元格.关联怪物) {
			                    所有怪物 = 所有怪物.filter(怪物 => 怪物 !== 单元格.关联怪物);
			                    单元格.关联怪物 = null;
			                }
			                // 重置单元格类型，但保留背景类型
			                if (单元格.类型 !== null) {
			                    单元格.类型 = null;
			                }
			            }
			        }
			    }
			    if(游戏状态 !== '图鉴'){
						    放置物品到房间(new 奖杯物品({}), 房间列表[房间列表.length - 1]);
							
						}
			
						return;
					}
					if(this.当前阶段===1&&this.当前生命值/this.生命值<=0.65){
					    this.无敌次数 = 0;
						this.当前阶段=2;
						this.王座崩坏();
					}else if(this.当前阶段===2&&this.当前生命值/this.生命值<=0.30){
					    this.无敌次数=4;
						this.当前阶段=3;
						this.混沌化身();
					}
				}
				尝试移动(){
					if(this.当前阶段===3){
						const 玩家距离=Math.abs(this.x-玩家.x)+Math.abs(this.y-玩家.y);
						if(玩家距离<5){
							const 逃离点=this.选择逃离目标(玩家.x,玩家.y,10);
							if(逃离点)
								this.目标路径=this.计算路径(逃离点.x,逃离点.y);
						}else{
							this.目标路径=this.计算路径(玩家.x,玩家.y);
						}
					}else{
						this.目标路径=this.计算路径(玩家.x,玩家.y);
					}
					super.尝试移动();
				}
				尝试攻击(){
					this.更新技能冷却();
					switch(this.当前阶段){
						case 1:
							return this.执行阶段一AI();
						case 2:
							return this.执行阶段二AI();
						case 3:
							return this.执行阶段三AI();
					}
					return false;
				}
				执行阶段一AI(){
					this.皇家守卫列表=this.皇家守卫列表.filter(卫兵=>卫兵.当前生命值>0&&所有怪物.includes(卫兵));
					const 可用技能列表=[];
					if(this.技能冷却剩余.墓碑召唤<=0&&this.当前生命值/this.生命值<0.85&&!this.无敌&&this.激活的墓碑列表.length===0&&this.无敌次数<=3)
						可用技能列表.push('墓碑召唤');
					if(this.技能冷却剩余.圣光弹幕<=0)
						可用技能列表.push('圣光弹幕');
					if(this.技能冷却剩余.幽魂弹幕<=0)
						可用技能列表.push('幽魂弹幕');
					if(this.技能冷却剩余.王权冲锋<=0)
						可用技能列表.push('王权冲锋');
					if(this.技能冷却剩余.召唤皇家卫队<=0&&this.皇家守卫列表.length<2)
						可用技能列表.push('召唤皇家卫队');
					if(可用技能列表.length>0){
						const 选定技能名=可用技能列表[Math.floor(prng()*可用技能列表.length)];
						return this[选定技能名]();
					}
					return this.三连重劈();
				}
				执行阶段二AI(){
					const 可用技能列表=[];
					this.皇家守卫列表=this.皇家守卫列表.filter(卫兵=>卫兵.当前生命值>0&&所有怪物.includes(卫兵));
					if(this.技能冷却剩余.螺旋圣光<=0)
						可用技能列表.push('螺旋圣光');
					if(this.技能冷却剩余.十字审判<=0)
						可用技能列表.push('十字审判');
					if(this.技能冷却剩余.领域脉冲<=0)
						可用技能列表.push('领域脉冲');
					if(this.技能冷却剩余.裂隙跳跃<=0)
						可用技能列表.push('裂隙跳跃');
					if(this.技能冷却剩余.召唤混沌回响<=0)
						可用技能列表.push('召唤混沌回响');
					if(this.技能冷却剩余.墓碑召唤<=0&&!this.无敌&&this.激活的墓碑列表.length===0&&this.无敌次数<=3)
						可用技能列表.push('墓碑召唤');
					if(this.技能冷却剩余.圣光弹幕<=0)
						可用技能列表.push('圣光弹幕');
					if(this.技能冷却剩余.幽魂弹幕<=0)
						可用技能列表.push('幽魂弹幕');
					if(this.技能冷却剩余.王权冲锋<=0)
						可用技能列表.push('王权冲锋');
					if(this.技能冷却剩余.召唤皇家卫队<=0&&this.皇家守卫列表.length<2)
						可用技能列表.push('召唤皇家卫队');
					if(可用技能列表.length>0){
						const 选定技能名=可用技能列表[Math.floor(prng()*可用技能列表.length)];
						return this[选定技能名]();
					}
					const 随机数=prng();
					if(随机数<0.5){
						return this.三连重劈();
					}else{
						return this.混沌之触();
					}
				}
				执行阶段三AI(){
					const 可用技能列表=[];
					if(this.技能冷却剩余.混沌风暴<=0)
						可用技能列表.push('混沌风暴','混沌风暴');
					if(this.技能冷却剩余.生成混沌裂隙<=0)
						可用技能列表.push('生成混沌裂隙','生成混沌裂隙');
					if(this.技能冷却剩余.无尽回响<=0)
						可用技能列表.push('无尽回响');
					if(this.技能冷却剩余.螺旋圣光<=0)
						可用技能列表.push('螺旋圣光');
					if(this.技能冷却剩余.十字审判<=0)
						可用技能列表.push('十字审判');
					if(this.技能冷却剩余.领域脉冲<=0)
						可用技能列表.push('领域脉冲');
					if(this.技能冷却剩余.裂隙跳跃<=0)
						可用技能列表.push('裂隙跳跃');
					if(this.技能冷却剩余.召唤混沌回响<=0)
						可用技能列表.push('召唤混沌回响');
					if(this.技能冷却剩余.墓碑召唤<=0&&!this.无敌&&this.激活的墓碑列表.length===0&&this.无敌次数<=3)
						可用技能列表.push('墓碑召唤');
					if(this.技能冷却剩余.圣光弹幕<=0)
						可用技能列表.push('圣光弹幕');
					if(this.技能冷却剩余.幽魂弹幕<=0)
						可用技能列表.push('幽魂弹幕');
					if(this.技能冷却剩余.王权冲锋<=0)
						可用技能列表.push('王权冲锋');
					if(this.技能冷却剩余.召唤皇家卫队<=0&&this.皇家守卫列表.length<2)
						可用技能列表.push('召唤皇家卫队');
					if(可用技能列表.length>0){
						const 选定技能名=可用技能列表[Math.floor(prng()*可用技能列表.length)];
						return this[选定技能名]();
					}
					return this.混沌之触();
				}
				王权冲锋(){
					this.技能冷却剩余.王权冲锋=this.技能冷却.王权冲锋;
					const 冲锋路径原始=获取直线路径(this.x,this.y,玩家.x,玩家.y);
					if(冲锋路径原始.length<2)
						return this.三连重劈();
					const 实际路径=[];
					let 最后有效点={x:this.x,y:this.y};
					for(const 节点 of 冲锋路径原始.slice(1)){
						const 单元格=地牢[节点.y]?.[节点.x];
						if(!单元格||单元格.背景类型===单元格类型.墙壁||(单元格.关联物品&&单元格.关联物品.阻碍怪物)||!位置是否可用(节点.x,节点.y,false)){
							break;
						}
						实际路径.push(节点);
						最后有效点=节点;
					}
					if(实际路径.length===0)
						return this.三连重劈();
					计划显示格子特效(实际路径,"FF4500");
					实际路径.forEach(节点=>{
						if(节点.x===玩家.x&&节点.y===玩家.y){
							伤害玩家(this.攻击力*1.5,this);
						}
						当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.层数==当前层数 && 节点.x === pet.x && 节点.y === pet.y) {
        pet.受伤(this.攻击力 * 1.5);
			        添加日志(`${pet?.名称} 被王权冲锋击中了！`, "警告");
    }
});

						const 单元格=地牢[节点.y]?.[节点.x];
						if(单元格?.关联物品&&单元格.关联物品!==this){
							if(!([单元格类型.楼梯下楼,单元格类型.楼梯上楼].includes(单元格.类型)||单元格.关联物品 instanceof 挑战石碑)){
								添加日志(`${单元格.关联物品.名称} 被冲锋摧毁了！`,'警告');
								单元格.关联物品.移除自身?.();
								单元格.关联物品=null;
								if(单元格.类型===单元格类型.物品)
									单元格.类型=null;
							}
						}
					});
					const 旧X=this.x,旧Y=this.y;
					this.恢复背景类型();
					this.x=最后有效点.x;
					this.y=最后有效点.y;
					this.保存新位置类型(最后有效点.x,最后有效点.y);
					地牢[最后有效点.y][最后有效点.x].类型=单元格类型.怪物;
					地牢[最后有效点.y][最后有效点.x].关联怪物=this;
					return true;
				}
				召唤皇家卫队(){
					this.技能冷却剩余.召唤皇家卫队=this.技能冷却.召唤皇家卫队;
					const 召唤数量=2-this.皇家守卫列表.filter(g=>g.当前生命值>0).length;
					let 成功召唤数=0;
					for(let i=0;i<召唤数量;i++){
						const 放置位置=寻找可放置位置(this.x,this.y);
						if(放置位置){
							const 新宿卫=new 皇家守卫({状态:怪物状态.活跃});
							if (所有怪物.length <= 15){
							if(放置怪物到单元格(新宿卫,放置位置.x,放置位置.y)){
								this.皇家守卫列表.push(新宿卫);
								成功召唤数++;
							}
							}
						}
					}
					if(成功召唤数>0){
						显示通知(`${this.类型} 召唤了 ${成功召唤数} 名皇家守卫！`,"警告");
					}
					return true;
				}
			    王座崩坏() {
			        显示通知("王座的力量正在崩溃，整个大厅都在颤抖！", "错误", true);
			        const 房间ID = 房间地图[this.y][this.x];
			        if (房间ID === -1) return;
			    
			        const 房间 = 房间列表[房间ID];
			        const 中心X = 房间.x + Math.floor(房间.w / 2);
			        const 中心Y = 房间.y + Math.floor(房间.h / 2);
			        const 内圈半径 = 房间.w * 0.45;
			    
			        const 安全位置列表 = [];
			        for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			            for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			                const 距离中心 = Math.sqrt(Math.pow(x - 中心X, 2) + Math.pow(y - 中心Y, 2));
			                if (距离中心 <= 内圈半径 && 位置是否可用(x, y, false)) {
			                    安全位置列表.push({ x, y });
			                }
			            }
			        }
			    
			        if (安全位置列表.length < 2) {
			            console.error("王座崩坏失败：内圈没有足够的安全位置放置玩家和首领！");
			            this.领域脉冲(); 
			            return;
			        }
			    
			        安全位置列表.sort(() => prng() - 0.5);
			    
			        const 玩家新位置 = 安全位置列表.pop();
			        const 首领新位置 = 安全位置列表.pop();
			    
			        for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			            for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			                const 距离中心 = Math.sqrt(Math.pow(x - 中心X, 2) + Math.pow(y - 中心Y, 2));
			                if (距离中心 > 内圈半径) {
			                    重置单元格(x, y);
			                } else {
			                    const 单元格 = 地牢[y]?.[x];
			                    if(单元格 && 单元格.背景类型 === 单元格类型.墙壁) {
			                        单元格.背景类型 = 单元格类型.房间;
			                    }
			                }
			            }
			        }
			    
			        玩家.x = 玩家新位置.x;
			        玩家.y = 玩家新位置.y;
			    
			        this.恢复背景类型();
			        this.x = 首领新位置.x;
			        this.y = 首领新位置.y;
			        this.保存新位置类型(this.x, this.y);
			        地牢[this.y][this.x].类型 = 单元格类型.怪物;
			        地牢[this.y][this.x].关联怪物 = this;
			
			        const 墙壁候选位置 = [...安全位置列表];
			        墙壁候选位置.sort(() => prng() - 0.5); 
			        const 尝试放置墙壁数量 = Math.floor(墙壁候选位置.length * 0.25);
			
			        for (let i = 0; i < 尝试放置墙壁数量 && i < 墙壁候选位置.length; i++) {
			            const 位置 = 墙壁候选位置[i];
			            const 单元格 = 地牢[位置.y]?.[位置.x];
			            
			            if (!单元格) continue;
			
			            单元格.背景类型 = 单元格类型.墙壁;
			            
			            const 连通路径 = 广度优先搜索路径(
			                玩家新位置.x, 
			                玩家新位置.y, 
			                首领新位置.x, 
			                首领新位置.y, 
			                999,
			                true
			            );
			
			            if (连通路径.length === 0) {
			                单元格.背景类型 = 单元格类型.房间; 
			            }
			        }
			
			        生成墙壁();
			    
			        更新视口();
			        绘制();
			    }
				三连重劈(){
					this.技能冷却剩余.三连重劈=this.技能冷却.三连重劈;
					const 攻击序列=[
						{范围:3,延时:0},
						{范围:6,延时:300},
						{范围:12,延时:600}
					];
					攻击序列.forEach((攻击,index)=>{
						setTimeout(()=>{
							const 攻击路径=获取直线路径(this.x,this.y,玩家.x,玩家.y).slice(1,攻击.范围+1);
							计划显示格子特效(攻击路径,"FFA500");
							攻击路径.forEach(node=>{
								if(node.x===玩家.x&&node.y===玩家.y){
									伤害玩家(this.攻击力*(0.8+index*0.2),this);
								}
								当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.层数==当前层数 && node.x === pet.x && node.y === pet.y) {
        pet.受伤(this.攻击力 * (0.8 + index * 0.2));
        添加日志(`${pet.名称} 被三连重劈击中了！`, "警告");
    }
});
							});
						},攻击.延时);
					});
					return true;
				}
				裂隙跳跃() {
					this.技能冷却剩余.裂隙跳跃 = this.技能冷却.裂隙跳跃;
					const 旧X = this.x, 旧Y = this.y;
					const 房间ID = 房间地图[this.y][this.x];
					if (房间ID === -1) return false;
				
					const 房间 = 房间列表[房间ID];
					let 目标X, 目标Y;
					let 尝试次数 = 0;
					let 放置成功 = false;
				
					while (尝试次数 < 100 && !放置成功) {
						目标X = 房间.x + Math.floor(prng() * 房间.w);
						目标Y = 房间.y + Math.floor(prng() * 房间.h);
						if (位置是否可用(目标X, 目标Y, false) && 广度优先搜索路径(玩家.x, 玩家.y, 目标X, 目标Y, 999)) {
							放置成功 = true;
						}
						尝试次数++;
					}
				
					if (!放置成功) return false;
				
					this.恢复背景类型();
					怪物动画状态.set(this, {
			    旧逻辑X: this.x,
			    旧逻辑Y: this.y,
			    目标逻辑X: 目标X,
			    目标逻辑Y: 目标Y,
			    视觉X: this.x,
			    视觉Y: this.y,
			    动画开始时间: Date.now(),
			    正在动画: true,
			});
					this.x = 目标X;
					this.y = 目标Y;
					this.保存新位置类型(目标X, 目标Y);
					地牢[目标Y][目标X].类型 = 单元格类型.怪物;
					地牢[目标Y][目标X].关联怪物 = this;
					计划显示格子特效([{ x: 旧X, y: 旧Y }, { x: 目标X, y: 目标Y }], "8A2BE2");
					this.混沌之触();
					return true;
				}
				领域脉冲(){
					this.技能冷却剩余.领域脉冲=this.技能冷却.领域脉冲;
					const 最大半径=15;
					for(let 半径=1;半径<=最大半径;半径++){
						setTimeout(()=>{
							const 环形格子=[];
							for(let dx=-半径;dx<=半径;dx++){
								for(let dy=-半径;dy<=半径;dy++){
									if(Math.max(Math.abs(dx),Math.abs(dy))===半径){
										const x=this.x+dx;
										const y=this.y+dy;
										if(x>=0&&x<地牢大小&&y>=0&&y<地牢大小){
											环形格子.push({x,y});
										}
									}
								}
							}
							计划显示格子特效(环形格子,"8A2BE2",0);
							if(环形格子.some(格子=>格子.x===玩家.x&&格子.y===玩家.y)){
								伤害玩家(this.攻击力*1.2,this);
								let 方向DX,方向DY;
								if(玩家.x===this.x&&玩家.y===this.y){
									const 随机方向=[{dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:0},{dx:-1,dy:0}][Math.floor(prng()*4)];
									方向DX=随机方向.dx;
									方向DY=随机方向.dy;
								}else{
									方向DX=玩家.x-this.x;
									方向DY=玩家.y-this.y;
								}
								const{x:最终X,y:最终Y}=this.计算最大玩家击退位置(玩家.x,玩家.y,方向DX,方向DY);
								if(最终X!==玩家.x||最终Y!==玩家.y){
									const 旧玩家X=玩家.x,旧玩家Y=玩家.y;
									玩家.x=最终X;
									玩家.y=最终Y;
									处理玩家着陆效果(旧玩家X,旧玩家Y,最终X,最终Y);
									更新视口();
									显示通知("你被强大的冲击波猛烈推开！","警告");
									绘制();
								}
							}
						},半径*70);
					}
					return true;
				}
				计算最大玩家击退位置(起始X,起始Y,方向DX,方向DY){
					let 最终X=起始X;
					let 最终Y=起始Y;
					let 步进X=Math.sign(方向DX)||0;
					let 步进Y=Math.sign(方向DY)||0;
					if(步进X===0&&步进Y===0){
						if(Math.abs(方向DX)>Math.abs(方向DY))
							步进X=Math.sign(方向DX)||1;
						else
							步进Y=Math.sign(方向DY)||1;
					}
					for(let i=1;i<地牢大小;i++){
						const 下一步X=最终X+步进X;
						const 下一步Y=最终Y+步进Y;
						if(检查移动可行性(最终X,最终Y,下一步X,下一步Y)){
							最终X=下一步X;
							最终Y=下一步Y;
						}else{
							break;
						}
					}
					return{x:最终X,y:最终Y};
				}
				召唤混沌回响(){
					this.技能冷却剩余.召唤混沌回响=this.技能冷却.召唤混沌回响;
					const 召唤数量=2+(this.强化?1:0);
					let 成功召唤数=0;
					const 怪物池选择=怪物池.上锁房间.filter(m=>!['大魔法师','米诺陶','皇家守卫','复活怪物','萨满怪物','巨人怪物','蜈蚣怪物'].includes(m.类.name));
					for(let i=0;i<召唤数量;i++){
						const 选中配置=怪物池选择[Math.floor(prng()*怪物池选择.length)];
						
						if (所有怪物.length <= 15) {
						const 新怪物=new 选中配置.类({强化:true,状态:怪物状态.活跃});
						if(放置怪物到房间(新怪物,房间列表[房间地图[this.y][this.x]])){
							成功召唤数++;
						}
						}
					}
			
					
					return true;
				}
				混沌化身(){
					const 房间ID=房间地图[this.y][this.x];
					if(房间ID===-1)
						return;
					const 房间=房间列表[房间ID];
					for(let y=房间.y;y<房间.y+房间.h;y++){
						for(let x=房间.x;x<房间.x+房间.w;x++){
							const 单元格=地牢[y]?.[x];
							if(单元格&&单元格.背景类型===单元格类型.墙壁&&!单元格.是否强制墙壁){
								单元格.背景类型=单元格类型.房间;
							}
							if(单元格?.关联物品&&(单元格.关联物品 instanceof 火焰物品||单元格.关联物品 instanceof 毒液物品)){
								单元格.关联物品.移除自身();
							}
						}
					}
					生成墙壁();
				}
				混沌风暴(){
					this.技能冷却剩余.混沌风暴=this.技能冷却.混沌风暴;
					this.攻击冷却剩余=3;
					const 陨石数量=8+(this.强化?4:0);
					const 冲击半径=2;
					const 玩家区域半径=6;
					for(let i=0;i<陨石数量;i++){
						setTimeout(()=>{
							const 目标X=玩家.x+Math.floor((prng()-0.5)*玩家区域半径*2);
							const 目标Y=玩家.y+Math.floor((prng()-0.5)*玩家区域半径*2);
							const 陨石冲击实例=new 炸弹({能否拾起: false,爆炸范围:冲击半径,伤害:this.攻击力*1.8,来源:'boss'});
							陨石冲击实例.x=目标X;
							陨石冲击实例.y=目标Y;
							const 冲击格子=[];
							for(let dy=-冲击半径;dy<=冲击半径;dy++){
								for(let dx=-冲击半径;dx<=冲击半径;dx++){
									冲击格子.push({x:目标X+dx,y:目标Y+dy});
								}
							}
							计划显示格子特效(冲击格子,"FF4500",0);
							setTimeout(()=>{
								陨石冲击实例.触发爆炸();
							},600);
						},i*150);
					}
					显示通知("混沌风暴来袭！","错误");
					return true;
				}
				圣光弹幕(){
					this.技能冷却剩余.圣光弹幕=this.技能冷却.圣光弹幕;
					const 弹幕数量=8;
					for(let i=0;i<弹幕数量;i++){
						const 角度=(i/弹幕数量)*Math.PI*2;
						const dx=Math.cos(角度);
						const dy=Math.sin(角度);
						const 路径=[];
						for(let j=1;j<=10;j++){
							const x=Math.round(this.x+dx*j);
							const y=Math.round(this.y+dy*j);
							if(x<0||x>=地牢大小||y<0||y>=地牢大小||(地牢[y]?.[x]?.背景类型===单元格类型.墙壁))
								break;
							路径.push({x,y});
							if(x===玩家.x&&y===玩家.y){
								伤害玩家(this.攻击力*0.9,this);
							}
				当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && x === pet.x && y === pet.y) {
        pet.受伤(this.攻击力*0.9);
			        添加日志(`${pet?.名称} 被圣光弹幕击中了！`, "警告");
    }
});
						}
						计划显示格子特效(路径,"FFD700",20);
					}
					显示通知("守护者释放了圣光弹幕！","警告");
					return true;
				}
				幽魂弹幕(){
					this.技能冷却剩余.幽魂弹幕=this.技能冷却.幽魂弹幕;
					const 幽魂数量=3+(this.强化?2:0);
					const 方向列表=[[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1]];
					for(let i=0;i<幽魂数量;i++){
						const 方向=方向列表[i%方向列表.length];
						const 生成位置={x:this.x+方向[0],y:this.y+方向[1]};
						if(位置是否可用(生成位置.x,生成位置.y,false)){
							const 幽魂实例=new 移动弹幕({强化:this.强化});
							放置怪物到单元格(幽魂实例,生成位置.x,生成位置.y);
						}
					}
					return true;
				}
				墓碑召唤() {
					this.技能冷却剩余.墓碑召唤 = this.技能冷却.墓碑召唤;
					this.无敌 = true;
					this.激活的墓碑列表 = [];
					this.无敌次数++
					const 墓碑数量 = 3;
					const 房间 = 房间列表[房间地图[this.y][this.x]];
					if (!房间) return false;
				
					const 可用位置 = [];
					for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
						for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
							if (位置是否可用(x, y, false) && 广度优先搜索路径(玩家.x, 玩家.y, x, y, 999)) {
								可用位置.push({x, y});
							}
						}
					}
					可用位置.sort(() => prng() - 0.5);
				
					for (let i = 0; i < Math.min(墓碑数量, 可用位置.length); i++) {
						const 放置位置 = 可用位置[i];
						const 墓碑实例 = new 墓碑({ 守护者: this, 强化: this.强化 });
						放置怪物到单元格(墓碑实例, 放置位置.x, 放置位置.y);
						this.激活的墓碑列表.push(墓碑实例);
					}
					显示通知("守护者召唤了不详的墓碑，它现在无敌了！", "错误", true);
					return true;
				}
				强制释放随机技能(){
					const 反击技能池=[];
					if(this.当前阶段>=1){
						反击技能池.push('圣光弹幕','幽魂弹幕','召唤皇家卫队');
					}
					if(this.当前阶段>=2){
						反击技能池.push('混沌之触','裂隙跳跃');
					}
					if(this.当前阶段>=3){
						反击技能池.push('生成混沌裂隙','无尽回响');
					}
					if(反击技能池.length>0){
						const 选定技能名=反击技能池[Math.floor(prng()*反击技能池.length)];
			
						this[选定技能名]();
					}
				}
				无尽回响(){
					this.技能冷却剩余.无尽回响=this.技能冷却.无尽回响;
					const 旧X=this.x,旧Y=this.y;
					if(this.裂隙跳跃()){
						const 路径=获取直线路径(旧X,旧Y,this.x,this.y);
						路径.forEach(node=>{
							if(位置是否可用(node.x,node.y,false)){
								放置物品到单元格(new 火焰物品({倒计时:3,火焰强度:5}),node.x,node.y);
							}
						});
						return true;
					}
					return false;
				}
				生成混沌裂隙(){
					this.技能冷却剩余.生成混沌裂隙=this.技能冷却.生成混沌裂隙;
					const 房间ID=房间地图[this.y][this.x];
					if(房间ID===-1)
						return false;
					const riftCount=6+(this.强化?2:0);
					const radius=5;
					for(let i=0;i<riftCount;i++){
						const angle=(i/riftCount)*Math.PI*2;
						const x=Math.round(玩家.x+Math.cos(angle)*radius);
						const y=Math.round(玩家.y+Math.sin(angle)*radius);
						if(位置是否可用(x,y,false)){
							const 裂隙=new 远射陷阱({x:x,y:y,房间ID:房间ID,强化:this.强化,基础生命值:1,攻击冷却:1,掉落概率:0,});
							裂隙.状态=怪物状态.活跃;
							裂隙.生命周期=12;
							裂隙.更新倒计时=()=>{
								裂隙.生命周期--;
								if(裂隙.生命周期<=0){
									裂隙.受伤(999,'消散');
									所有计时器=所有计时器.filter(t=>t!==裂隙);
								}
							};
							所有计时器.push(裂隙);
							放置怪物到单元格(裂隙,x,y);
							计划显示格子特效([{x,y}],"4B0082");
						}
					}
					显示通知("混沌裂隙被撕开！","警告");
					return true;
				}
				混沌之触(){
					this.技能冷却剩余.攻击冷却=1;
					const 攻击路径=获取直线路径(this.x,this.y,玩家.x,玩家.y);
					if(攻击路径.length>1){
						计划显示格子特效(攻击路径.slice(1),"9932CC");
						if(攻击路径.some(p=>p.x===玩家.x&&p.y===玩家.y)){
							伤害玩家(this.攻击力*0.7,this);
						}
						当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && 攻击路径.some(p => p.x === pet.x && p.y === pet.y)) {
        pet.受伤(this.攻击力 * 0.7);
        添加日志(`${pet.名称} 被混沌之触击中了！`, "警告");
    }
});
						return true;
					}
					return false;
				}
				螺旋圣光(){
					this.技能冷却剩余.螺旋圣光=this.技能冷却.螺旋圣光;
					const 圈数=5+(this.强化?2:0);
					const 每圈粒子数=12;
					for(let i=1;i<=圈数;i++){
						setTimeout(()=>{
							const 路径=[];
							for(let j=0;j<每圈粒子数;j++){
								const 角度=(j/每圈粒子数)*Math.PI*2+(i*0.5);
								const x=Math.round(this.x+i*Math.cos(角度));
								const y=Math.round(this.y+i*Math.sin(角度));
								if(x>=0&&x<地牢大小&&y>=0&&y<地牢大小){
									if(!路径.some(p=>p.x===x&&p.y===y)){
										路径.push({x,y});
									}
								}
							}
							计划显示格子特效(路径,"FFD700");
							路径.forEach(点=>{
								if(点.x===玩家.x&&点.y===玩家.y){
									伤害玩家(this.攻击力*0.8,this);
								}
								当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && 点.x === pet.x && 点.y === pet.y) {
        pet.受伤(this.攻击力 * 0.8);
        添加日志(`${pet.名称} 被螺旋圣光击中了！`, "警告");
    }
});
							});
						},i*100);
					}
					显示通知(`${this.类型}释放了螺旋圣光！`,'警告');
					return true;
				}
				十字审判(){
					this.技能冷却剩余.十字审判=this.技能冷却.十字审判;
					const 弹道长度=7;
					const 爆炸长度=4;
					const 方向=[[0,-1],[1,0],[0,1],[-1,0]];
					const 终点列表=[];
					方向.forEach(dir=>{
						const 路径=[];
						let 终点={x:this.x,y:this.y};
						for(let i=1;i<=弹道长度;i++){
							const x=this.x+dir[0]*i;
							const y=this.y+dir[1]*i;
							if(x<0||x>=地牢大小||y<0||y>=地牢大小||地牢[y]?.[x]?.背景类型===单元格类型.墙壁){
								break;
							}
							路径.push({x,y});
							终点={x,y};
						}
						if(路径.length>0){
							终点列表.push(终点);
							计划显示格子特效(路径,"8A2BE2",50);
							if(路径.some(点=>点.x===玩家.x&&点.y===玩家.y)){
								伤害玩家(this.攻击力,this);
							}
							当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && 路径.some(点 => 点.x === pet.x && 点.y === pet.y)) {
        pet.受伤(this.攻击力 * 0.9);
        添加日志(`${pet.名称} 被十字审判击中了！`, "警告");
    }
});
						}
					});
					setTimeout(()=>{
						终点列表.forEach(终点=>{
							const 爆炸路径=[];
							for(let i=-爆炸长度;i<=爆炸长度;i++){
								const x=终点.x+i;
								const y=终点.y;
								if(x>=0&&x<地牢大小)
									爆炸路径.push({x,y});
							}
							for(let i=-爆炸长度;i<=爆炸长度;i++){
								const x=终点.x;
								const y=终点.y+i;
								if(y>=0&&y<地牢大小&&i!==0)
									爆炸路径.push({x,y});
							}
							计划显示格子特效(爆炸路径,"E0B0FF");
							if(爆炸路径.some(点=>点.x===玩家.x&&点.y===玩家.y)){
								伤害玩家(this.攻击力*1.2,this);
							}
							当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && 爆炸路径.some(点 => 点.x === pet.x && 点.y === pet.y)) {
        pet.受伤(this.攻击力 * 1.2);
        添加日志(`${pet.名称} 被十字审判击中了！`, "警告");
    }
});
						});
					},弹道长度*50+100);
					显示通知(`${this.类型}降下十字审判！`,'警告');
					return true;
				}
				获得效果(状态效果) {
					const 免疫效果列表 = ['冻结', '魅惑', '缓慢', '中毒', '恐惧', '牵制', '眩晕'];
					if (免疫效果列表.includes(状态效果.类型)) {
						状态效果.移除状态();
						return false;
					}
					return super.获得效果(状态效果);
				}
			}
			
			class 魔法师 extends 怪物 {
    constructor(配置 = {}) {
        super({
            图标: 图标映射.魔法师,
            类型: "魔法师",
            基础生命值: 40 + (配置.强化 ? 20 : 0),
            基础攻击力: 1,
            移动率: 0.6,
            掉落物: new 附魔卷轴({}),
            掉落概率: 0.25,
            攻击冷却: 5 + (配置.强化 ? -1 : 0),
            ...配置,
        });
        this.变形范围 = 配置.变形范围??(4 + (配置.强化 ? 1 : 0));
        this.普通怪物类名列表 = [
            '怪物', '盔甲怪物', '敏捷怪物', '远攻怪物', '仙人掌怪物', '冰冻怪物', '大史莱姆怪物',
            '瞬移怪物', '伪装怪物', '腐蚀怪物', '盗贼怪物', '吸能怪物', '剧毒云雾怪物', '旋风怪物',
            '恐惧怪物', '超速怪物', '吸血鬼', '分裂怪物', '反弹怪物', '蜘蛛怪物'
        ];
    }

    尝试攻击() {
        if (this.攻击冷却回合剩余 > 0) {
            this.攻击冷却回合剩余--;
            super.尝试攻击();
            return;
        }

        const 附近怪物 = [];
        for (let dy = -this.变形范围; dy <= this.变形范围; dy++) {
            for (let dx = -this.变形范围; dx <= this.变形范围; dx++) {
                const x = this.x + dx;
                const y = this.y + dy;
                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
                const 单元格 = 地牢[y]?.[x];
                const 怪物 = 单元格?.关联怪物;
                if (怪物 && 怪物 !== this && this.普通怪物类名列表.includes(怪物.constructor.name) && 怪物.状态 === 怪物状态.活跃 && 所有怪物.includes(怪物)) {
                    附近怪物.push(怪物);
                }
            }
        }

        if (附近怪物.length > 0) {
            this.攻击冷却回合剩余 = this.攻击冷却;
            const 目标怪物 = 附近怪物[Math.floor(prng() * 附近怪物.length)];
            const 新怪物类名 = this.普通怪物类名列表[Math.floor(prng() * this.普通怪物类名列表.length)];
            const 新怪物类 = window[新怪物类名];

            if (新怪物类) {
                const 旧生命值 = 目标怪物.当前生命值;
                const 是否强化 = 目标怪物.强化;
                const 旧X = 目标怪物.x;
                const 旧Y = 目标怪物.y;
                const 旧房间ID = 目标怪物.房间ID;

                目标怪物.恢复背景类型();
                所有怪物 = 所有怪物.filter(m => m !== 目标怪物);
                怪物状态表.delete(目标怪物);

                const 新怪物 = new 新怪物类({
                    x: 旧X, y: 旧Y, 房间ID: 旧房间ID,
                    强化: 是否强化, 状态: 怪物状态.活跃
                });
                新怪物.当前生命值 = 旧生命值;

                放置怪物到单元格(新怪物, 旧X, 旧Y);
                添加日志(`${this.类型} 将 ${目标怪物.类型} 变成了 ${新怪物.类型}！`, "警告");
                计划显示格子特效([{ x: 旧X, y: 旧Y }], "8A2BE2", 50);
                return true;
            }
        }
        return super.尝试攻击();
    }
}
			class 大魔法师 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.大魔法师,
			            类型: "大魔法师",
			            房间ID: 配置.房间ID || null,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.活跃,
			            基础生命值: 配置.基础生命值 || 80,
			            基础攻击力: 配置.基础攻击力 || 8,
			            强化: 配置.强化 || false,
			            移动率: 配置.移动率 || 0.8,
			            基础攻击范围: 4,
			            跟踪距离: 20,
			            攻击冷却: 3,
			            受伤冻结回合: 1,
			            掉落物: new 真言卷轴({
			                品质: 4,
			                已解锁: true,
			                强化: true,
			            }),
			            掉落概率: 1,
			            残血逃跑: false,
			            ...配置,
			        });
			        this.当前生命值 = 配置.当前生命值 || this.生命值;
			        this.技能冷却 = {
			            隐身术: 0,
			            分身术: 0,
			            火球术: 0,
			            冰冻术: 0,
			            传送术: 0,
			            召唤术: 0,
			        };
			        this.每回合恢复量 = 配置.每回合恢复量??2;
			        this.隐身中 = false;
			        this.逃离目标 = null;
			        this.原始移动距离 = this.基础移动距离;
			        this.isClone = false;
			        this.隐身提示间隔 = 2;
			        this.隐身提示计数 = 0;
			    }
			
			    尝试移动() {
			        if (this.隐身中) {
			            this.隐身移动();
			            return;
			        }
			
			        if (this.当前生命值 <= 0) return;
			        super.尝试移动();
			
			        this.绘制血条();
			    }
			
			    选择逃离目标() {
			        const 最大距离 = this.跟踪距离; // 最大逃离距离
			        const 可达点 = [];
			
			        const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0 }];
			        const 已访问 = new Set([`${this.x},${this.y}`]);
			        const 已在房间中 = 房间地图[this.y][this.x] !== -1;
			        const 已在房间 = 房间地图[this.y][this.x];
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			
			            const 房间ID = 房间地图[当前.y][当前.x];
			            if (已访问房间.has(房间ID)) {
			                if (!已在房间中) {
			                    可达点.push({
			                        x: 当前.x,
			                        y: 当前.y,
			                        距离: 当前.距离,
			                    }); // 记录距离
			                } else {
			                    if (房间ID === 已在房间)
			                        可达点.push({
			                            x: 当前.x,
			                            y: 当前.y,
			                            距离: 当前.距离,
			                        });
			                }
			            }
			
			            if (当前.距离 > 最大距离) continue;
			
			            const 方向 = [
			                { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
			                { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
			                { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
			                { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
			            ];
			
			            for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			                const 位置键 = `${新X},${新Y}`;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    continue;
			                const 当前单元格 = 地牢[当前.y][当前.x];
			                const 目标单元格 = 地牢[新Y][新X];
			                const 移动方向 = getMoveDirection(当前.x, 当前.y, 新X, 新Y);
			                    if (目标单元格.isOneWay && 移动方向 !== 目标单元格.oneWayAllowedDirection) {
			                        continue;
			                    }
			                if (
			                    当前单元格.墙壁[当前墙] ||
			                    目标单元格.墙壁[目标墙]
			                )
			                    continue;
			                if (
			                    [单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                        目标单元格.背景类型
			                    )
			                )
			                    continue;
			
			                if (
			                    !已访问.has(位置键) &&
			                    this.位置合法(新X, 新Y)
			                ) {
			                    已访问.add(位置键);
			                    队列.push({
			                        x: 新X,
			                        y: 新Y,
			                        距离: 当前.距离 + 1,
			                    });
			                }
			            }
			        }
			
			        let 最远点 = null;
			        let 最大自身距离 = -1;
			
			        for (const 点 of 可达点) {
			            if (点.距离 > 最大自身距离) {
			                最大自身距离 = 点.距离;
			                最远点 = 点;
			            }
			        }
			
			        return 最远点;
			    }
			
			    隐身移动() {
			        if (this.当前生命值 < this.生命值) {
			            this.当前生命值 = Math.min(
			                this.生命值,
			                this.当前生命值 + this.每回合恢复量
			            );
			            this.绘制血条();
			        } else {
			            this.隐身中 = false;
			            this.基础移动距离 = this.原始移动距离;
			            添加日志(`${this.类型} 现形了!`, "信息");
			            显示通知(
			                "使用分身迷惑你后，隐身的大魔法师缓缓现出真身..."
			            );
			            this.绘制血条();
			            return;
			        }
			        if (
			            this.目标路径.length === 0 ||
			            (prng() > this.移动率 && !切换动画) ||
			            this.跟踪距离 < this.目标路径.length
			        ) {
			            this.追击玩家中 = false;
			            return;
			        }
			        if (!this.逃离目标) {
			            this.逃离目标 = this.选择逃离目标();
			        }
			        this.目标路径 = this.计算目标路径(
			            this.逃离目标.x,
			            this.逃离目标.y
			        );
			        if (this.目标路径) {
			            const 下一步 =
			                this.目标路径[
			                    Math.min(
			                        this.移动距离 - 1,
			                        this.目标路径.length - 1
			                    )
			                ];
			            const 最终位置 = this.规划移动路径();
			            if (
			                !最终位置 ||
			                (this.y === this.逃离目标.y &&
			                    this.x === this.逃离目标.x)
			            ) {
			                this.逃离目标 = null;
			                return;
			            }
			            this.恢复背景类型();
			            this.保存新位置类型(最终位置.x, 最终位置.y);
			            this.x = 最终位置.x;
			            this.y = 最终位置.y;
			            地牢[this.y][this.x].类型 = 单元格类型.怪物;
			            地牢[this.y][this.x].关联怪物 = this;
			        } else {
			            this.逃离目标 = null;
			        }
			
			        this.绘制血条();
			        this.隐身提示计数++;
			        if (this.隐身提示计数 >= this.隐身提示间隔) {
			            this.隐身提示计数 = 0;
			
			            const 画布Rect = canvas.getBoundingClientRect();
			            let 屏幕X = (this.x - 相机目标X) * 单元格大小;
			            let 屏幕Y = (this.y - 相机目标Y) * 单元格大小;
			            if (
			                屏幕X + 单元格大小 < 0 ||
			                屏幕X > 画布Rect.width ||
			                屏幕Y + 单元格大小 < 0 ||
			                屏幕Y > 画布Rect.height
			            ) {
			                return;
			            }
			            计划显示格子特效([{ x: this.x, y: this.y }], "000000");
			        }
			    }
			
			    尝试攻击() {
			        if (怪物状态表.get(this)?.类型 === "冻结") return;
			
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余 -= 1;
			            return false;
			        }
			        if (this.通向目标路径.length > this.攻击范围) return false;
			        if (!this.isClone) {
			            if (
			                this.当前生命值 < this.生命值 * 0.3 &&
			                !this.隐身中
			            ) {
			                this.隐身术();
			                this.分身术();
			                添加日志(`${this.类型} 负伤逃跑了!`, "信息");
			
			                return true;
			            } else if (this.隐身中) {
			                return true;
			            }
			        }
			
			        if (prng() < 0.5) {
			            const 技能列表 = [
			                "火球术",
			                "冰冻术",
			                "传送术",
			                "召唤术",
			            ];
			            const 随机技能 =
			                技能列表[
			                    Math.floor(prng() * 技能列表.length)
			                ];
			
			            switch (随机技能) {
			                case "火球术":
			                    if (!this.火球术()) {
			                        this.普通攻击();
			                        this.攻击冷却回合剩余 = this.攻击冷却;
			                    }
			                    break;
			                case "冰冻术":
			                    if (!this.冰冻术()) {
			                        this.普通攻击();
			                        this.攻击冷却回合剩余 = this.攻击冷却;
			                    }
			                    break;
			                case "传送术":
			                    this.传送术();
			                    break;
			                case "召唤术":
			                    if (!this.召唤术()) {
			                        this.普通攻击();
			                        this.攻击冷却回合剩余 = this.攻击冷却;
			                    }
			                    break;
			            }
			            return true;
			        } else {
			            this.普通攻击();
			            this.攻击冷却回合剩余 = this.攻击冷却;
			            return true;
			        }
			    }
			    普通攻击() {
			        const 攻击模式 = Math.floor(prng() * 4);
			        let 方向列表 = [];
			
			        switch (攻击模式) {
			            case 0:
			                方向列表 = [
			                    { dx: 0, dy: -1 },
			                    { dx: 0, dy: 1 },
			                    { dx: -1, dy: 0 },
			                    { dx: 1, dy: 0 },
			                ];
			                break;
			            case 1:
			                方向列表 = [
			                    { dx: -1, dy: -1 },
			                    { dx: 1, dy: -1 },
			                    { dx: -1, dy: 1 },
			                    { dx: 1, dy: 1 },
			                ];
			                break;
			            case 2:
			            case 3:
			                const 基本方向 = [
			                    { dx: 0, dy: -1 },
			                    { dx: 1, dy: 0 },
			                    { dx: 0, dy: 1 },
			                    { dx: -1, dy: 0 },
			                ];
			
			                const 顺时针方向变化 = [
			                    { dx: 1, dy: 0 },
			                    { dx: 0, dy: 1 },
			                    { dx: -1, dy: 0 },
			                    { dx: 0, dy: -1 },
			                ];
			
			                const 逆时针方向变化 = [
			                    { dx: 0, dy: -1 },
			                    { dx: -1, dy: 0 },
			                    { dx: 0, dy: 1 },
			                    { dx: 1, dy: 0 },
			                ];
			
			                基本方向.forEach((起始方向) => {
			                    let 当前方向 = 起始方向;
			                    let 当前X = this.x;
			                    let 当前Y = this.y;
			                    let 路径 = [];
			
			                    let 层数 = 0;
			                    while (
			                        Math.abs(当前X - this.x) +
			                            Math.abs(当前Y - this.y) <=
			                        this.攻击范围
			                    ) {
			                        层数++;
			                        let 步数 = 层数 * 2 - 1;
			
			                        if (层数 > 1) {
			                            const 方向变化 =
			                                攻击模式 === 2
			                                    ? 顺时针方向变化
			                                    : 逆时针方向变化;
			                            let 方向索引 = 方向变化.findIndex(
			                                (d) =>
			                                    d.dx === 当前方向.dx &&
			                                    d.dy === 当前方向.dy
			                            );
			
			                            方向索引 = (方向索引 + 1) % 4;
			                            当前方向 = 方向变化[方向索引];
			
			                            当前X += 当前方向.dx;
			                            当前Y += 当前方向.dy;
			                            if (
			                                !检查移动可行性(
			                                    当前X - 当前方向.dx,
			                                    当前Y - 当前方向.dy,
			                                    当前X,
			                                    当前Y
			                                )
			                            )
			                                break;
			
			                            const 单元格 = 地牢[当前Y]?.[当前X];
			                            if (
			                                单元格?.关联怪物 &&
			                                单元格.类型 === 单元格类型.怪物 &&
			                                单元格.关联怪物?.状态 ===
			                                    怪物状态.活跃 &&
			                                !(
			                                    单元格.关联怪物 instanceof
			                                    大魔法师
			                                )
			                            ) {
			                                单元格.关联怪物.受伤(
			                                    this.攻击力,
			                                    this
			                                );
			                            } else if (
			                                当前X === 玩家.x &&
			                                当前Y === 玩家.y
			                            ) {
			                                伤害玩家(this.攻击力, this);
			                            } else if (当前出战宠物列表.some(pet => pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === 当前X && pet.y === 当前Y)) {
    当前出战宠物列表.forEach(pet => {
        if (pet.x === 当前X && pet.y === 当前Y && pet.层数==当前层数 ) {
            pet.受伤(this.攻击力);
        }
    });
}
			
			                            路径.push({ x: 当前X, y: 当前Y });
			                            步数--;
			                        }
			
			                        for (let i = 0; i < 步数; i++) {
			                            当前X += 当前方向.dx;
			                            当前Y += 当前方向.dy;
			
			                            if (
			                                !检查移动可行性(
			                                    当前X - 当前方向.dx,
			                                    当前Y - 当前方向.dy,
			                                    当前X,
			                                    当前Y
			                                )
			                            )
			                                break;
			
			                            const 单元格 = 地牢[当前Y]?.[当前X];
			
			                            if (
			                                单元格?.关联怪物 &&
			                                单元格.类型 === 单元格类型.怪物 &&
			                                单元格.关联怪物?.状态 ===
			                                    怪物状态.活跃
			                            ) {
			                                单元格.关联怪物.受伤(
			                                    this.攻击力,
			                                    this
			                                );
			                            } else if (
			                                当前X === 玩家.x &&
			                                当前Y === 玩家.y
			                            ) {
			                                伤害玩家(this.攻击力, this);
			                            } else if (当前出战宠物列表.some(pet => pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === 当前X && pet.y === 当前Y)) {
    当前出战宠物列表.forEach(pet => {
        if (pet.x === 当前X && pet.y === 当前Y && pet.层数==当前层数 ) {
            pet.受伤(this.攻击力);
        }
    });
}
			                            路径.push({ x: 当前X, y: 当前Y });
			                        }
			                        if (
			                            Math.abs(当前X - this.x) +
			                                Math.abs(当前Y - this.y) >
			                            this.攻击范围
			                        )
			                            break;
			                    }
			
			                    计划显示格子特效(路径);
			                });
			                return;
			        }
			
			        方向列表.forEach((方向) => {
			            let 当前X = this.x + 方向.dx;
			            let 当前Y = this.y + 方向.dy;
			            let 路径 = [];
			
			            while (
			                Math.abs(当前X - this.x) +
			                    Math.abs(当前Y - this.y) <=
			                this.攻击范围
			            ) {
			                if (
			                    !检查移动可行性(
			                        当前X - 方向.dx,
			                        当前Y - 方向.dy,
			                        当前X,
			                        当前Y
			                    )
			                )
			                    break;
			
			                const 单元格 = 地牢[当前Y]?.[当前X];
			
			                if (
			                    单元格?.关联怪物 &&
			                    单元格.类型 === 单元格类型.怪物 &&
			                    单元格.关联怪物?.状态 === 怪物状态.活跃
			                ) {
			                    单元格.关联怪物.受伤(this.攻击力, this);
			                    break;
			                } else if (当前X === 玩家.x && 当前Y === 玩家.y) {
			                    伤害玩家(this.攻击力, this);
			                    break;
			                } else if (当前出战宠物列表.some(pet => pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === 当前X && pet.y === 当前Y)) {
    当前出战宠物列表.forEach(pet => {
        if (pet.x === 当前X && pet.y === 当前Y && pet.层数==当前层数 ) {
            pet.受伤(this.攻击力);
        }
    });
}
			
			                路径.push({ x: 当前X, y: 当前Y });
			                当前X += 方向.dx;
			                当前Y += 方向.dy;
			            }
			            计划显示格子特效(路径);
			        });
			    }
			
			    召唤术() {
			        if (this.技能冷却.召唤术 > 0) return false;
			        const 方向 = [
			            { dx: -1, dy: -1 },
			            { dx: 1, dy: -1 },
			            { dx: -1, dy: 1 },
			            { dx: 1, dy: 1 },
			        ];
			        let 召唤位置 = null;
			        for (const { dx, dy } of 方向) {
			            const x = this.x + dx;
			            const y = this.y + dy;
			            if (
			                this.位置合法(x, y) &&
			                !地牢[y][x].关联怪物 &&
			                !地牢[y][x].关联物品
			            ) {
			                召唤位置 = { x, y };
			                break;
			            }
			        }
			        if (!召唤位置) {
			            添加日志(
			                `${this.类型} 尝试召唤，但周围没有可用空间！`,
			                "信息"
			            );
			            return false;
			        }
			        const 追踪数 = 跟踪玩家怪物数;
			        let 召唤数量 = 2;
			        if (追踪数 >= 5) {
			            return false;
			        } else if (追踪数 >= 3) {
			            召唤数量 = 1;
			        }
			        const 可召唤怪物 = [];
			        for (let 房间类型 in 怪物池) {
			            怪物池[房间类型].forEach((怪物配置) => {
			                if (怪物配置.类 !== 大魔法师 && !(怪物配置.类 instanceof 大魔法师)
				 && !(怪物配置.类 instanceof 米诺陶) 
				 && !(怪物配置.类 instanceof 墓碑) && !(怪物配置.类 instanceof 王座守护者)
				 && !(怪物配置.类 instanceof 皇家守卫)
				 && !(怪物配置.类 instanceof 复活怪物)
				 && !(怪物配置.类 instanceof 巨人怪物)
				 && !(怪物配置.类 instanceof 追踪风弹弹头)
				 && !(怪物配置.类 instanceof 蜈蚣部位)) {
			                    可召唤怪物.push(怪物配置);
			                }
			            });
			        }
			        for (let i = 0; i < 召唤数量; i++) {
			            const 总权重 = 可召唤怪物.reduce(
			                (sum, m) => sum + m.权重,
			                0
			            );
			            let 随机值 = prng() * 总权重;
			            let 选中配置 = null;
			
			            for (const m of 可召唤怪物) {
			                if (随机值 <= m.权重) {
			                    选中配置 = m;
			                    break;
			                }
			                随机值 -= m.权重;
			            }
			            if (召唤位置) {
			                if (!this.位置合法(召唤位置.x, 召唤位置.y)) break;
			            }
			            const 新怪物 = new 选中配置.类({
			                x: 召唤位置.x,
			                y: 召唤位置.y,
			                房间ID: 房间地图[召唤位置.y][召唤位置.x],
			                状态: 怪物状态.活跃,
			                强化: prng() < 0.3,
			            });
			            放置怪物到单元格(新怪物, 召唤位置.x, 召唤位置.y);
			            新怪物.处理地形效果();
			
			            计划显示格子特效(
			                [{ x: 召唤位置.x, y: 召唤位置.y }],
			                "800080"
			            );
			            for (const { dx, dy } of 方向) {
			                const x = this.x + dx;
			                const y = this.y + dy;
			                if (
			                    this.位置合法(x, y) &&
			                    !地牢[y][x].关联怪物 &&
			                    !地牢[y][x].关联物品
			                ) {
			                    召唤位置 = { x, y };
			                    break;
			                }
			            }
			        }
			        显示通知(`${this.类型} 使用了召唤术！`, "信息");
			        this.技能冷却.召唤术 = 8;
			        return true;
			    }
			
			    隐身术() {
			        if (this.隐身中) return;
			
			        this.逃离目标 = this.选择逃离目标();
			        this.隐身中 = true;
			        this.基础移动距离 = 2;
			        this.绘制血条(true);
			        添加日志(`${this.类型} 使用了隐身术!`, "信息");
			    }
			
			    分身术() {
			        if (
			            this.技能冷却.分身术 > 0 ||
			            this.分身?.当前生命值 > 0 ||
			            this.isClone
			        )
			            return;
			        if (this.分身?.当前生命值 > 0) {
			            this.分身.恢复背景类型();
			            this.分身.血条元素.remove();
			            所有怪物 = 所有怪物.filter((m) => m !== this.分身);
			        }
			        let x = this.x;
			        let y = this.y;
			        const 分身 = new 大魔法师({
			            x: x,
			            y: y,
			            当前生命值: this.当前生命值,
			            房间ID: this.房间ID,
			        });
			        this.分身 = 分身;
			        分身.isClone = true;
			        let 放置 = 怪物放置物品(分身, x, y);
			        if (放置.x === null) {
			            this.分身.当前生命值 = 0;
			        }
			        this.尝试移动();
			        添加日志(`${this.类型} 使用了分身术!`, "信息");
			        this.技能冷却.分身术 = 10;
			    }
			
			    火球术() {
			        if (this.技能冷却.火球术 > 0) return false;
			
			        const 最大距离 = 8;
			        const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;
			
			        if (玩家距离 > 0 && 玩家距离 <= 最大距离) {
			            const 攻击路径 = this.计算目标路径(玩家.x, 玩家.y);
			            if (攻击路径) {
			                计划显示格子特效(攻击路径);
			
			                const 扔出炸弹 = new 炸弹({
			                    能否拾起: false,
			                    颜色索引: 4,
			                });
			                let 目标 = {};
			                目标 = 玩家放置物品(扔出炸弹);
			                if (目标.x !== null || 目标.y !== null) {
			                    扔出炸弹.使用(false, 目标.x, 目标.y);
			                }
			                添加日志(`${this.类型} 使用了火球术!`, "信息");
			                this.技能冷却.火球术 = 4;
			                return true;
			            } else {
			                return false;
			            }
			        }
			    }
			
			    冰冻术() {
			        if (this.技能冷却.冰冻术 > 0) return false;
			        const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;
			        const 范围 = 2;
			        if (玩家距离 > 范围) return false;
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                const x = this.x + dx;
			                const y = this.y + dy;
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小
			                ) {
			                    const 单元格 = 地牢[y][x];
			
			                    if (
			                        单元格.关联怪物 &&
			                        单元格.关联怪物.类型 !== "冰冻怪物" &&
			                        单元格.关联怪物.类型 !== "大魔法师"
			                    ) {
			                        new 状态效果(
			                            "冻结",
			                            "#2196F3",
			                            "冻",
			                            3,
			                            null,
			                            null,
			                            单元格.关联怪物
			                        );
			                    }
			                    if (
			                        x === 玩家.x &&
			                        y === 玩家.y &&
			                        !Array.from(
			                            { length: 装备栏每页装备数 },
			                            (_, i) =>
			                                玩家装备.get(
			                                    当前装备页 * 装备栏每页装备数 +
			                                        i +
			                                        1
			                                )
			                        )
			                            .filter((v) => v != null)
			                            .some((item) => item.名称 === "冰盾")
			                    ) {
			                        伤害玩家(this.攻击力, this);
			                        new 状态效果(
			                            "冻结",
			                            "#2196F3",
			                            图标映射.冰冻怪物,
			                            3,
			                            3
			                        );
			                    }
								if (当前出战宠物列表.some(pet => pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === x && pet.y === y)) {
    当前出战宠物列表.forEach(pet => {
        if (pet.x === x && pet.y === y && pet.层数==当前层数 ) {
            pet.受伤(999);
        }
    });
}
			                    if (单元格.关联物品 instanceof 炸弹) {
			                        if (!单元格.关联物品.能否拾起) {
			                            单元格.关联物品.自定义数据.set(
			                                "倒计时",
			                                单元格.关联物品.自定义数据.get(
			                                    "爆炸时间"
			                                )
			                            );
			                            单元格.关联物品.能否拾起 = true;
			                            所有计时器 = 所有计时器.filter(
			                                    (item) =>
			                                        item.x !== 单元格.关联物品.x || item.y !== 单元格.关联物品.y
			                                );
			                            单元格.关联物品.x = null;
			                            单元格.关联物品.y = null;
			                            添加日志("炸弹已被熄灭！", "信息");
			                            绘制();
			                        }
			                    }
			                    if (单元格.关联物品 instanceof 火焰物品) {
			                        单元格.关联物品 = null;
			                        if (单元格.类型 === 单元格类型.物品)
			                            单元格.类型 = null;
			                        单元格.颜色索引 = 颜色表.length;
			                    }
			                }
			                if (单元格.关联怪物?.类型 !== "大魔法师") {
			                    计划显示格子特效([{ x: x, y: y }], "0000DD");
			                }
			            }
			        }
			        添加日志(`${this.类型} 使用了冰冻术!`, "信息");
			        this.技能冷却.冰冻术 = 6;
			        return true;
			    }
			    传送术() {
			        if (this.技能冷却.传送术 > 0) return;
			
			        const 最小距离 = 5;
			        const 最大距离 = 10;
			
			        const 可达点 = [];
			        const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
			        const 已访问 = new Set([`${this.x},${this.y} `]);
			
			        const 方向 = [
			            { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
			            { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
			            { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
			            { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
			        ];
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			
			            if (
			                当前.距离 >= 最小距离 &&
			                当前.距离 <= 最大距离 &&
			                已访问房间.has(房间地图[当前.y][当前.x])
			            ) {
			                可达点.push({ x: 当前.x, y: 当前.y });
			            }
			
			            if (当前.距离 > 最大距离) continue;
			
			            for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			                const 位置键 = `${新X},${新Y} `;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    continue;
			                const 当前单元格 = 地牢[当前.y][当前.x];
			                const 目标单元格 = 地牢[新Y][新X];
			                if (
			                    当前单元格.墙壁[当前墙] ||
			                    目标单元格.墙壁[目标墙]
			                )
			                    continue;
			                if (
			                    [单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                        目标单元格.背景类型
			                    )
			                )
			                    continue;
			
			                if (
			                    !已访问.has(位置键) &&
			                    this.位置合法(新X, 新Y)
			                ) {
			                    已访问.add(位置键);
			                    队列.push({
			                        x: 新X,
			                        y: 新Y,
			                        距离: 当前.距离 + 1,
			                    });
			                }
			            }
			        }
			
			        const 旧X = this.x;
			        const 旧Y = this.y;
			        if (可达点.length > 0) {
			            const 目标点 =
			                可达点[Math.floor(prng() * 可达点.length)];
			            this.恢复背景类型();
			            this.保存新位置类型(目标点.x, 目标点.y);
			            this.x = 目标点.x;
			            this.y = 目标点.y;
			            地牢[this.y][this.x].类型 = 单元格类型.怪物;
			            地牢[this.y][this.x].关联怪物 = this;
			            添加日志(`${this.类型} 使用了传送术!`, "信息");
			            this.技能冷却.传送术 = 7;
			            this.处理地形效果();
			            怪物动画状态.set(this, {
			                旧逻辑X: 旧X,
			                旧逻辑Y: 旧Y,
			                目标逻辑X: this.x,
			                目标逻辑Y: this.y,
			                视觉X: 旧X,
			                视觉Y: 旧Y,
			                动画开始时间: Date.now(),
			                正在动画: true,
			            });
			        }
			    }
			    受伤(伤害, 来源 = null) {
			        const 获取房间 = (名称) =>
			            房间列表.find((r) => r.名称 === 名称);
			        if (来源?.x!==玩家.x||来源?.y!==玩家.y) return false;
			        if (this.当前生命值 > 0) {
			            this.当前生命值 -= 伤害;
			            if (中文模式) this.触发受击动画();
			
			            if (this.当前生命值 <= 0) {
			                已击杀怪物数++;
			                const 能量条 = document.querySelector(".power-bar");
			                const 当前能量 =
			                    parseFloat(能量条.style.width) || 100;
			                能量条.style.width = `${Math.min(
			                    100,
			                    当前能量 + 7/自定义全局设置.初始能量值*100
			                )}%`;
			                击杀提示.更新({
			                    内容: `已击杀怪物：${已击杀怪物数} `,
			                });
			                const 装备宠物列表 = Array.from(
			                    { length: 装备栏每页装备数 },
			                    (_, i) =>
			                        玩家装备.get(
			                            当前装备页 * 装备栏每页装备数 + i + 1
			                        )
			                )
			                    .filter((v) => v != null)
			                    .filter((装备) => 装备 instanceof 宠物);
			                装备宠物列表.forEach((宠物) => {
			                    const 经验值 = Math.floor(this.基础生命值 / 10);
			                    宠物.获得经验(经验值);
			                });
			
			                this.恢复背景类型();
			                
			                所有怪物 = 所有怪物.filter((m) => m !== this);
			                for (let 纵坐标 = 获取房间("最终秘室").y; 纵坐标 < 获取房间("最终秘室").y + 获取房间("最终秘室").h; 纵坐标++) {
			        for (let 横坐标 = 获取房间("最终秘室").x; 横坐标 < 获取房间("最终秘室").x + 获取房间("最终秘室").w; 横坐标++) {
			            const 单元格 = 地牢[纵坐标]?.[横坐标];
			            if (单元格) {
			                // 移除物品
			                if (单元格.关联物品) {
			                    // 如果物品在计时器列表中，也一并移除
			                    const 计时器索引 = 所有计时器.findIndex(计时器 => 计时器.唯一标识 === 单元格.关联物品.唯一标识);
			                    if (计时器索引 !== -1) {
			                        所有计时器.splice(计时器索引, 1);
			                    }
			                    单元格.关联物品 = null;
			                }
			                // 移除怪物
			                if (单元格.关联怪物) {
			                    所有怪物 = 所有怪物.filter(怪物 => 怪物 !== 单元格.关联怪物);
			                    单元格.关联怪物 = null;
			                }
			                // 重置单元格类型，但保留背景类型
			                if (单元格.类型 !== null) {
			                    单元格.类型 = null;
			                }
			            }
			            }
			        }
			
			                if (
			                    this.isClone !== true &&
			                    prng() <=
			                        this.物品掉率 * 玩家属性.掉落倍率
			                ) {
			                    if (this.掉落物.自定义数据.get("耐久"))
			                        this.掉落物.自定义数据.set(
			                            "耐久",
			                            Math.floor(
			                                Math.min(
			                                    this.掉落物.自定义数据.get(
			                                        "耐久"
			                                    ),
			                                    this.掉落物.自定义数据.get(
			                                        "耐久"
			                                    ) *
			                                        玩家属性.掉落倍率 *
			                                        prng() *
			                                        prng()
			                                )
			                            )
			                        );
			                    if (房间列表[房间地图[this.y][this.x]]) {
			                        放置物品到单元格(
			                            this.掉落物,
			                            this.x,
			                            this.y
			                        );
			                        生成奖励(
			                            房间列表[房间地图[this.y][this.x]]
			                        );
			                        放置物品到房间(
			                            new 魔法师法杖({}),
			                            获取房间("最终秘室")
			                        );
			                        放置物品到房间(
			                            new 大师附魔卷轴({}),
			                            获取房间("最终秘室")
			                        );
			                        放置物品到房间(
			                            new 小书魔({}),
			                            获取房间("最终秘室")
			                        );
			                        if (游戏状态 === '地图编辑器' || 游戏状态 === '编辑器游玩') {
			                        
			                        放置物品到房间(new 旗帜(),获取房间("最终秘室"));
									} else if (游戏状态 !== '图鉴') {
										放置楼梯(
											获取房间("最终秘室"),
											楼梯图标.下楼,
											单元格类型.楼梯下楼
										);
									}
			                        
			                        显示通知("大魔法师被彻底抹除了...");
			                    }
			                }
			
			                const 玩家单元格 = 地牢[玩家.y][玩家.x];
			                if (
			                    玩家单元格.关联物品 &&
			                    玩家单元格.类型 === 单元格类型.物品
			                ) {
			                    if (尝试收集物品(玩家单元格.关联物品)) {
			                        玩家单元格.类型 = null;
			                        玩家单元格.关联物品 = null;
			                    }
			                }
			                return;
			            }
			            this.绘制血条();
			        }
			    }
			
			    更新技能冷却() {
			        for (const 技能 in this.技能冷却) {
			            if (this.技能冷却[技能] > 0) {
			                this.技能冷却[技能]--;
			            }
			        }
			    }
			    绘制血条(隐藏血条 = false) {
			        if (this.隐身中) {
			            
			            return;
			        }
			        super.绘制血条(隐藏血条);
			    }
			}
			

	        class 反弹怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.反弹怪物,
			            类型: "反弹怪物",
			            基础生命值: 30 + (配置.强化 ? 10 : 0),
			            基础攻击力: 6,
			            移动率: 0.7,
			            掉落物: new 钢制板甲({强化: true}),
