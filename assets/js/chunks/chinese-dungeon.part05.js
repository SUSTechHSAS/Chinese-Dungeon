			                    旧X: 玩家.x,
			                    旧Y: 玩家.y,
			                    类型: "玩家",
			                });
			            }
			        }
			    }
			
			    const 已执行 = new Set();
			    const 待处理实例列表 = Array.from(移动计划.keys());
			
			    待处理实例列表
			        .filter((实例) => 实例 instanceof 物品)
			        .forEach((物品实例) => {
			            尝试执行吹动(
			                物品实例,
			                移动计划,
			                已执行,
			                风向DX,
			                风向DY
			            );
			        });
			
			    待处理实例列表
			        .filter((实例) => 实例 instanceof 怪物)
			        .forEach((怪物实例) => {
			            尝试执行吹动(
			                怪物实例,
			                移动计划,
			                已执行,
			                风向DX,
			                风向DY
			            );
			        });
			
			    //let 玩家被吹动 = false;
			    let 玩家目标X = 玩家.x;
			    let 玩家目标Y = 玩家.y;
			
			    if (移动计划.has(玩家) && !已执行.has(玩家)) {
			        const { 新X, 新Y } = 移动计划.get(玩家);
			
			        const 最终目标单元格 = 地牢[新Y]?.[新X];
			        const 最终占用者 = 最终目标单元格?.关联物品;
			        const 最终占用者不可移动 =
			            最终占用者 &&
			            (不可移动类型列表.includes(最终占用者.类型) ||
			                最终占用者.能否拾起 === false);
			
			        if (!最终占用者不可移动) {
			            玩家动画状态 = {
			正在动画: true,
			旧逻辑X: 玩家.x,
			旧逻辑Y: 玩家.y,
			目标逻辑X: 新X,
			目标逻辑Y: 新Y,
			视觉X: 玩家.x,
			视觉Y: 玩家.y,
			动画开始时间: Date.now()
			        };
			            let 旧X = 玩家.x
			            let 旧Y = 玩家.y
			            玩家.x = 新X;
			            玩家.y = 新Y;
			            //玩家被吹动 = true;
			            玩家目标X = 新X;
			            玩家目标Y = 新Y;
			            处理玩家着陆效果(旧X, 旧Y, 玩家目标X, 玩家目标Y);
			            添加日志("你被大风吹动了！", "警告");
			            已执行.add(玩家);
			        } else {
			            添加日志("你试图被风吹动，但撞到了障碍物！", "信息");
			        }
			    }
			
			    更新物体指示器();
			    所有怪物.forEach((m) => m.绘制血条());
			}
			function 开始挑战(房间实例) {
			    if (
			        !房间实例 ||
			        房间实例.类型 !== "挑战房间" ||
			        !房间实例.挑战状态 ||
			        房间实例.挑战状态.进行中 ||
			        房间实例.挑战状态.已完成
			    ) {
			        return;
			    }
			
			    显示通知(
			        `挑战开始于房间 ${房间实例.id}！门已封锁！`,
			        "警告",
			        true,
			        3000
			    );
			
			    房间实例.挑战状态.进行中 = true;
			    房间实例.挑战状态.当前波次 = 0;
			    房间实例.挑战状态.波次内怪物 = [];
			    房间实例.挑战状态.原始门数据 = [];
			
			    // 封锁门
			    房间实例.门.forEach((门坐标) => {
			        const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
			        if (
			            门单元格 &&
			            (门单元格.背景类型 === 单元格类型.门 ||
			                门单元格.背景类型 === 单元格类型.上锁的门)
			        ) {
			            房间实例.挑战状态.原始门数据.push({
			                x: 门坐标.x,
			                y: 门坐标.y,
			                原类型: 门单元格.背景类型,
			                原标识: 门单元格.标识, // 保存门实例的标识
			                原颜色索引: 门单元格.颜色索引,
			                原钥匙ID: 门单元格.钥匙ID,
			            });
			            门单元格.背景类型 = 单元格类型.墙壁;
			            门单元格.标识 = null; // 清除门标识，使其不再是功能性门
			            门单元格.颜色索引 = 颜色表.length; // 恢复默认墙壁颜色
			            门单元格.钥匙ID = null;
			            重置单元格(门坐标.x,门坐标.y)
			        }
			        // 同时处理配对门单元格（如果存在）
			        if (门单元格 && 门单元格.配对单元格位置) {
			            const 配对X = 门单元格.配对单元格位置.x;
			            const 配对Y = 门单元格.配对单元格位置.y;
			            const 配对单元格 = 地牢[配对Y]?.[配对X];
			            if (
			                配对单元格 &&
			                (配对单元格.背景类型 === 单元格类型.门 ||
			                    配对单元格.背景类型 === 单元格类型.上锁的门)
			            ) {
			                房间实例.挑战状态.原始门数据.push({
			                    x: 配对X,
			                    y: 配对Y,
			                    原类型: 配对单元格.背景类型,
			                    原标识: 配对单元格.标识,
			                    原颜色索引: 配对单元格.颜色索引,
			                    原钥匙ID: 配对单元格.钥匙ID,
			                });
			                配对单元格.背景类型 = 单元格类型.墙壁;
			                配对单元格.标识 = null;
			                配对单元格.颜色索引 = 颜色表.length;
			                配对单元格.钥匙ID = null;
			                重置单元格(配对X,配对Y)
			            }
			        }
			    });
			
			    生成墙壁(); // 更新墙壁连接信息，确保封锁效果
			    绘制(); // 立即重绘以显示锁住的门
			
			    刷新挑战房间下一波(房间实例);
			}
			
			function 刷新挑战房间下一波(房间实例) {
			    if (!房间实例.挑战状态.进行中) return;
			
			    房间实例.挑战状态.当前波次++;
			    if (房间实例.挑战状态.当前波次 > 房间实例.挑战状态.总波次) {
			        完成挑战(房间实例);
			        return;
			    }
			
			    显示通知(
			        `房间 ${房间实例.id}：第 ${房间实例.挑战状态.当前波次} 波！`,
			        "警告",
			        true,
			        2000
			    );
			
			    房间实例.挑战状态.波次当前回合数 =
			        房间实例.挑战状态.波次最大回合数; // 重置计时器
			
			    const 怪物数量 =
			        1 +
			        Math.floor((房间实例.挑战状态?.挑战怪物层级 ?? 当前层数) / 3) +
			        Math.floor(房间实例.挑战状态.当前波次 / 2);
			    生成挑战房间怪物(房间实例, 怪物数量);
			    绘制(); // 确保新生成的怪物显示
			}
			
			function 生成挑战房间怪物(房间实例, 数量) {
			    let 候选怪物配置;
			    let 怪物层级 = 房间实例.挑战状态?.挑战怪物层级 ?? 当前层数;
			    const { monsters: allMonsters } = 获取所有可用的定义();

			    if (房间实例.挑战状态?.候选怪物池 && 房间实例.挑战状态.候选怪物池.length > 0) {
			        候选怪物配置 = allMonsters.filter(def => 房间实例.挑战状态.候选怪物池.includes(def.类.name));
			        if (候选怪物配置.length === 0) {
			            console.warn(`挑战房间 ${房间实例.id} 的自定义怪物池无效或为空，回退到默认怪物池。`);
			            const 挑战怪物池 = [];
			            for (let i = 0; i <= 怪物层级; i++) {
			                if (怪物引入计划.has(i)) {
			                    怪物引入计划.get(i).forEach(怪物定义 => {
			                        if (!挑战怪物池.some(m => m.类.name === 怪物定义.类.name)) {
			                            挑战怪物池.push(怪物定义);
			                        }
			                    });
			                }
			            }
			            候选怪物配置 = 挑战怪物池;
			        } else {
			            怪物层级 = 3;
			        }
			    } else {
			        const 挑战怪物池 = [];
			        for (let i = 0; i <= 怪物层级; i++) {
			            if (怪物引入计划.has(i)) {
			                怪物引入计划.get(i).forEach(怪物定义 => {
			                    if (!挑战怪物池.some(m => m.类.name === 怪物定义.类.name)) {
			                        挑战怪物池.push(怪物定义);
			                    }
			                });
			            }
			        }
			        候选怪物配置 = 挑战怪物池;
			    }

			    const 最终候选怪物 = 候选怪物配置;

			    if (最终候选怪物.length === 0) {
			        console.warn(`挑战房间 ${房间实例.id} 在层数 ${怪物层级} 无法找到合适的怪物生成。`);
			        return;
			    }

			    for (let i = 0; i < 数量; i++) {
			        let 选中配置;
			        if (最终候选怪物[0].权重 !== undefined) {
			            const 总权重 = 最终候选怪物.reduce((sum, m) => sum + m.权重, 0);
			            let 随机值 = prng() * 总权重;
			            选中配置 = 最终候选怪物[0];
			            for (const m of 最终候选怪物) {
			                if (随机值 <= m.权重) {
			                    选中配置 = m;
			                    break;
			                }
			                随机值 -= m.权重;
			            }
			        } else {
			            选中配置 = 最终候选怪物[Math.floor(prng() * 最终候选怪物.length)];
			        }
			
			        let 放置成功 = false;
			        for (let 尝试次数 = 0; 尝试次数 < 20; 尝试次数++) {
			            const x = 房间实例.x + Math.floor(prng() * 房间实例.w);
			            const y = 房间实例.y + Math.floor(prng() * 房间实例.h);
			
			            if (位置是否可用(x, y, true)) {
			                const 强化概率 = 0.15 + 怪物层级 * 0.025 + 房间实例.挑战状态.当前波次 * 0.06;
			                const 怪物基础攻击 = (选中配置.类.prototype.基础攻击力 || 3) + Math.floor(怪物层级 / 4) + Math.floor(房间实例.挑战状态.当前波次 / 2);
			                const 怪物基础生命 = (选中配置.类.prototype.基础生命值 || 20) + 怪物层级 * 2 + 房间实例.挑战状态.当前波次 * 4;
			
			                const 新怪物 = new 选中配置.类({
			                    x: x,
			                    y: y,
			                    房间ID: 房间实例.id,
			                    强化: prng() < 强化概率,
			                    状态: 怪物状态.活跃,
			                    基础攻击力: 怪物基础攻击,
			                    基础生命值: 怪物基础生命,
			                });
			
			                新怪物.基础生命值 = 怪物基础生命;
			                新怪物.当前生命值 = 新怪物.基础生命值;
			
			                放置怪物到单元格(新怪物, x, y);
			                房间实例.挑战状态.波次内怪物.push(新怪物);
			                新怪物.绘制血条();
			                放置成功 = true;
			                break;
			            }
			        }
			    }
			}
			function 完成挑战(房间实例) {
			    显示通知(
			        `房间 ${房间实例.id} 挑战成功！门已开启。`,
			        "成功",
			        true,
			        3000
			    );
			
			    房间实例.挑战状态.进行中 = false;
			    房间实例.挑战状态.已完成 = true;
			
			    // 恢复门
			    房间实例.挑战状态.原始门数据.forEach((门数据) => {
			        const 门单元格 = 地牢[门数据.y]?.[门数据.x];
			        if (门单元格) {
			            门单元格.背景类型 = 门数据.原类型;
			            门单元格.标识 = 门数据.原标识; // 恢复门实例的标识
			            门单元格.颜色索引 = 门数据.原颜色索引;
			            门单元格.钥匙ID = 门数据.原钥匙ID;
			            // 如果原先是上锁的门，并且门实例列表中有记录，则恢复门实例状态
			            if (
			                门数据.原类型 === 单元格类型.上锁的门 &&
			                门数据.原标识
			            ) {
			                const 门实例 = 门实例列表.get(门数据.原标识);
			                if (门实例) {
			                    门实例.类型 = "上锁的门";
			                    门实例.是否上锁 = true;
			                }
			            } else if (
			                门数据.原类型 === 单元格类型.门 &&
			                门数据.原标识
			            ) {
			                const 门实例 = 门实例列表.get(门数据.原标识);
			                if (门实例) {
			                    门实例.类型 = "门";
			                    门实例.是否上锁 = false;
			                }
			            }
			        }
			    });
			
			    生成墙壁(); // 重新生成墙壁以正确显示恢复的门
			    生成奖励(房间实例); // 在房间内生成奖励物品
			    绘制();
			}
			function 处理挑战失败(房间实例) {
			    if (
			        !房间实例 ||
			        房间实例.类型 !== "挑战房间" ||
			        !房间实例.挑战状态 ||
			        !房间实例.挑战状态.进行中
			    ) {
			        return;
			    }
			    显示通知(
			        `由于你的离开，房间 ${房间实例.id} 的挑战失败了！`,
			        "错误",
			        true,
			        3000
			    );
			    房间实例.挑战状态.进行中 = false;
			    房间实例.挑战状态.已完成 = true;
			
			    房间实例.挑战状态.原始门数据.forEach((门数据) => {
			        const 门单元格 = 地牢[门数据.y]?.[门数据.x];
			        if (门单元格) {
			            门单元格.背景类型 = 门数据.原类型;
			            门单元格.标识 = 门数据.原标识;
			            门单元格.颜色索引 = 门数据.原颜色索引;
			            门单元格.钥匙ID = 门数据.原钥匙ID;
			            if (
			                门数据.原类型 === 单元格类型.上锁的门 &&
			                门数据.原标识
			            ) {
			                const 门实例 = 门实例列表.get(门数据.原标识);
			                if (门实例) {
			                    门实例.类型 = "上锁的门";
			                    门实例.是否上锁 = true;
			                }
			            } else if (
			                门数据.原类型 === 单元格类型.门 &&
			                门数据.原标识
			            ) {
			                const 门实例 = 门实例列表.get(门数据.原标识);
			                if (门实例) {
			                    门实例.类型 = "门";
			                    门实例.是否上锁 = false;
			                }
			            }
			        }
			    });
			    生成墙壁();
			    绘制();
			}
			function 获取方向中文(dx, dy) {
			    if (dx === 1) return "东";
			    if (dx === -1) return "西";
			    if (dy === 1) return "南";
			    if (dy === -1) return "北";
			    return "原地";
			}
			function 处理回合逻辑() {
			    if (玩家属性.允许移动 > 0) return;
			    if (地牢.length !== 地牢大小) return;
			    
			    玩家总移动回合数++;
			    更新胜利条件显示();
			    处理传送带效果();
			    更新武器冷却();
			    
			    if (当前出战宠物列表.length > 0) {
					当前出战宠物列表.forEach(pet => {if(pet.层数==当前层数) pet.执行回合AI()});
				}
				if(当前天气效果.includes('深夜')) 更新光源地图();
				if(房间列表.find(item=>item.id==房间地图[玩家.y][玩家.x])?.类型==='黑暗房间') 更新光源地图();
			
			    if (跳过怪物回合剩余次数 > 0) {
			    跳过怪物回合剩余次数--;
			    添加日志(`时空扭曲，怪物们停止了行动... (剩余 ${跳过怪物回合剩余次数} 回合)`, "信息");
			} else {
			    处理怪物回合();
			}
			绘制小地图();
			    所有怪物.forEach((m) => {
			        m.绘制血条();
			    });
			    处理天气效果();
			    更新物体指示器();
			    if (当前层数 === 5) {
			        const 怪物数量下限 = 10;
			        if (所有怪物.length < 怪物数量下限) {
			            const 需生成数量 = 怪物数量下限 - 所有怪物.length;
			            生成迷宫怪物(需生成数量);
			        }
			    }
			    const 能量条 = document.querySelector(".power-bar");
			    const 当前能量 = parseFloat(能量条?.style.width) || 100;
			    let 能量变化 = 0;
			    if(当前能量 < 70) 能量变化 += (Math.round(prng() * 5) / 5)/自定义全局设置.初始能量值*100;
			    if(玩家属性.能量流失 > 0) 能量变化 -= 玩家属性.能量流失/自定义全局设置.初始能量值*100;
			
			    if (能量条 && 能量变化 !== 0) {
			         能量条.style.width = `${Math.max(0, Math.min(100, 当前能量 + 能量变化))}%`;
			    }
			    玩家状态.forEach((item) => {
			        item.更新状态();
			    });
			    所有计时器.forEach((item) => {
			        if(item) item?.更新倒计时();
			    });
			    if (房间列表.length>0) {
			    房间列表.forEach(房间 => {
			        if (房间?.isSurvivalChallenge) {
			            const monstersInRoom = 所有怪物.filter(m => m.房间ID === 房间.id);
			            if (monstersInRoom.length === 0) {
			                 let 石碑 = null;
			                 for(const row of 地牢) {
			                    for(const cell of row) {
			                        if(cell.关联物品 instanceof 挑战石碑 && cell.关联物品.自定义数据.get("已激活") && 房间地图[cell.y][cell.x] === 房间.id) {
			                            石碑 = cell.关联物品;
			                            break;
			                        }
			                    }
			                    if(石碑) break;
			                 }
			                if(石碑) {
			                    石碑.刷新生存挑战下一波(房间);
			                }
			            }
			        }
			    });
			    }
			    Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			        玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			    )
			        .filter((v) => v != null)
			        .forEach((装备) => {
			            if (装备 instanceof 宠物) {
			                装备.恢复生命值();
			            }
			        });
				当前出战宠物列表.forEach(pet => pet.恢复生命值());
			    
			    更新界面状态();
			    if (房间列表.length>0) {
			    房间列表.forEach((房间) => {
			        if (
			            房间.类型 === "挑战房间" &&
			            房间.挑战状态 &&
			            房间.挑战状态.进行中
			        ) {
			            房间.挑战状态.波次当前回合数--;
			            房间.挑战状态.波次内怪物 =
			                房间.挑战状态.波次内怪物.filter(
			                    (m) => m.当前生命值 > 0 && 所有怪物.includes(m)
			                );
			
			            if (房间.挑战状态.波次内怪物.length === 0) {
			                添加日志(
			                    `房间 ${房间.id} 第 ${房间.挑战状态.当前波次} 波怪物已清除！`,
			                    "成功"
			                );
			                刷新挑战房间下一波(房间);
			            } else if (
			                房间.挑战状态.当前波次 < 房间.挑战状态.总波次
			            ) {
			                if (房间.挑战状态.波次当前回合数 <= 0) {
			                    添加日志(
			                        `房间 ${房间.id} 第 ${房间.挑战状态.当前波次} 波时间到！`,
			                        "警告"
			                    );
			                    刷新挑战房间下一波(房间);
			                }
			            }
			        }
			    });
			    }
			}
			function 处理玩家着陆效果(旧X, 旧Y, 新X, 新Y) {
			    const 目标单元格 = 地牢[新Y]?.[新X];
			    if (!目标单元格) return false;
			    const 旧玩家房间ID = 房间地图[旧Y][旧X];
			        if (旧玩家房间ID !== -1) {
			            const 旧玩家所在房间 = 房间列表.find(t=>t.id==旧玩家房间ID);
			            if (
			                旧玩家所在房间 &&
			                旧玩家所在房间.类型 === "挑战房间" &&
			                旧玩家所在房间.挑战状态 &&
			                旧玩家所在房间.挑战状态.进行中 &&
			                房间地图[新Y][新X] !== 旧玩家房间ID
			            ) {
			                处理挑战失败(旧玩家所在房间);
			            }
			        }
			    if (目标单元格.关联物品?.自定义数据?.get('隐藏')) {
			        目标单元格.关联物品.使用();
			        目标单元格.关联物品.自定义数据.set('隐藏', false);
			        显示通知(`你踩到了一个隐藏的 ${目标单元格.关联物品.名称}！`, "警告");
			    }
			
			    if (
			        目标单元格.关联物品 &&
			        目标单元格.类型 === 单元格类型.物品 &&
			        目标单元格.关联物品.能否拾起 &&
			        !目标单元格.关联物品.是否被丢弃
			    ) {
			        if (尝试收集物品(目标单元格.关联物品)) {
			            目标单元格.类型 = null;
			            目标单元格.关联物品 = null;
			        }
			    } else if (
			        [单元格类型.楼梯下楼, 单元格类型.楼梯上楼].includes(
			            目标单元格.类型
			        )
			    ) {
			        if (
			            是否为教程层 &&
			            目标单元格.类型 === 单元格类型.楼梯下楼
			        ) {
			            是否为教程层 = false;
			            所有怪物.forEach((m) => {
			                m.绘制血条(true);
			                if (地牢[m.y] && 地牢[m.y][m.x])
			                    地牢[m.y][m.x].关联怪物 = null;
			            });
			            所有怪物 = [];
			            document.getElementById("跳过教程按钮").style.display =
			                "none";
			            重置玩家状态();
			            切换楼层(0);
			            return true;
			        } else if (目标单元格.关联物品?.使用) {
			            目标单元格.关联物品.使用();
			            return true;
			        }
			    } else if (目标单元格.关联物品 instanceof 折跃门) {
			        if (目标单元格.关联物品.使用()) {
			            return true;
			        }
			    }
			
			    const 目标房间ID = 房间地图[新Y][新X];
			    处理单向房间(旧X, 旧Y, 新X, 新Y);
			    if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
			        moveQueue = [];
			        isAutoMoving = false;
			        已访问房间.add(目标房间ID);
			        const 能量条 = document.querySelector(".power-bar");
			        const 当前能量 = parseFloat(能量条?.style.width) || 100;
			        if (能量条)
			            能量条.style.width = `${Math.min(
			                100,
			                当前能量 + 1.5/自定义全局设置.初始能量值*100
			            )}%`;
			        const 进入的房间 = 房间列表.find(t=>t.id==目标房间ID);
			        if (
			            进入的房间 &&
			            进入的房间.类型 === "挑战房间" &&
			            进入的房间.挑战状态 &&
			            !进入的房间.挑战状态.进行中 &&
			            !进入的房间.挑战状态.已完成
			        ) {
			            开始挑战(进入的房间);
			        }
			        if (是否为教程层) {
			            教程阶段 = 目标房间ID;
			            教程提示已显示 = false;
			            显示教程提示();
			        }
			    }
			    更新洞穴视野();
			
			    if(地牢生成方式==='default') {尝试进入特殊房间(新X, 新Y);}
			    return false;
			}
			function 更新洞穴视野() {
    if (地牢生成方式 !== 'cave' || 游戏状态 === '地图编辑器') return;
    const 视野半径 = 5;
    for (let y = 玩家.y - 视野半径; y <= 玩家.y + 视野半径; y++) {
        for (let x = 玩家.x - 视野半径; x <= 玩家.x + 视野半径; x++) {
            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
            if (Math.pow(x - 玩家.x, 2) + Math.pow(y - 玩家.y, 2) <= 视野半径 * 视野半径) {
                if (广度优先搜索路径(玩家.x, 玩家.y, x, y, 视野半径, false, false, false)) {
                    已揭示洞穴格子.add(`${x},${y}`);
                }
            }
        }
    }
}
			function 处理单向房间(旧X, 旧Y, 新X, 新Y) {
			const 新房间ID = 房间地图[新Y]?.[新X];
			const 进入的房间 = 房间列表.find(t=>t.id==新房间ID);
			if (新房间ID === -1) return;
			进入的房间?.门?.forEach(门坐标 => {
			    const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
			    if (!门单元格 || ![单元格类型.门, 单元格类型.上锁的门].includes(门单元格.背景类型)) {
			        return;
			    }
			
			    const 配对单元格坐标 = 门单元格.配对单元格位置;
			    const 配对单元格 = 配对单元格坐标 ? 地牢[配对单元格坐标.y]?.[配对单元格坐标.x] : null;
			
			    const 是入口门 = 进入的房间?.首次进入的门坐标系统?.some(
			        保存的坐标 => 保存的坐标.x === 门坐标.x && 保存的坐标.y === 门坐标.y
			    );
			
			    if (是入口门) {
			        门单元格.isOneWay = false;
			        门单元格.oneWayAllowedDirection = null;
			        if (配对单元格) {
			            配对单元格.isOneWay = false;
			            配对单元格.oneWayAllowedDirection = null;
			        }
			    }
			});
			
			if ((旧X !== undefined && 房间地图[旧Y]?.[旧X] === 新房间ID)) return;
			
			
			if (!进入的房间 || 进入的房间.类型 !== "单向房间") return;
			
			if (!进入的房间.首次进入的门坐标系统) {
			    进入的房间.首次进入的门坐标系统 = [];
			    let 最小距离 = Infinity;
			    let 最近门坐标 = null;
			
			    for (const 门坐标 of 进入的房间.门) {
			        const 距离 = Math.abs(新X - 门坐标.x) + Math.abs(新Y - 门坐标.y);
			        if (距离 < 最小距离) {
			            最小距离 = 距离;
			            最近门坐标 = 门坐标;
			        }
			    }
			
			    if (最近门坐标) {
			        const 主门单元格实例 = 地牢[最近门坐标.y]?.[最近门坐标.x];
			        if (主门单元格实例) {
			            进入的房间.首次进入的门坐标系统.push({ x: 最近门坐标.x, y: 最近门坐标.y });
			            if (主门单元格实例.配对单元格位置) {
			                进入的房间.首次进入的门坐标系统.push({ ...主门单元格实例.配对单元格位置 });
			            }
			        }
			    }
			}
			
			进入的房间.门.forEach(门坐标 => {
			    const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
			    if (!门单元格 || ![单元格类型.门, 单元格类型.上锁的门].includes(门单元格.背景类型)) {
			        return;
			    }
			
			    const 配对单元格坐标 = 门单元格.配对单元格位置;
			    const 配对单元格 = 配对单元格坐标 ? 地牢[配对单元格坐标.y]?.[配对单元格坐标.x] : null;
			
			    const 是入口门 = 进入的房间.首次进入的门坐标系统.some(
			        保存的坐标 => 保存的坐标.x === 门坐标.x && 保存的坐标.y === 门坐标.y
			    );
			
			    if (!是入口门) {
			        门单元格.isOneWay = true;
			        门单元格.oneWayAllowedDirection = randomlySetOneWayDirection(门单元格);
			        if (配对单元格) {
			            配对单元格.oneWayAllowedDirection = 门单元格.oneWayAllowedDirection;
			        }
			    }
			});
			        }
			
			        async function 移动玩家(dx, dy, 冷却 = true) {
			    if (游戏状态 === '地图编辑器') {
			        相机目标X += dx * 编辑器状态.相机速度;
			        相机目标Y += dy * 编辑器状态.相机速度;
			        let 新X = 玩家.x + dx;
			    let 新Y = 玩家.y + dy;
			    
			    if (
			        新X < 0 ||
			        新X >= 地牢大小 ||
			        新Y < 0 ||
			        新Y >= 地牢大小
			    )
			        return;
			        玩家动画状态 = {
			正在动画: true,
			旧逻辑X: 玩家.x,
			旧逻辑Y: 玩家.y,
			目标逻辑X: 新X,
			目标逻辑Y: 新Y,
			视觉X: 玩家.x,
			视觉Y: 玩家.y,
			动画开始时间: Date.now()
			        };
			    玩家.x = 新X
			    玩家.y = 新Y
			        绘制小地图();
			        更新视口();
			        return;
			    }
			
			    if (
			        玩家属性.允许移动 > 0 ||
			        (游戏状态 !== "游戏中" && 游戏状态 !== "图鉴" && 游戏状态 !== "编辑器游玩")
			    )
			        return false;
			    if (冷却) {
			        const now = Date.now();
			        if (now - 上次移动 < 50) return;
			        上次移动 = now;
			    }
			    const 能量条 = document.querySelector(".power-bar");
			    const 当前能量 = parseFloat(能量条.style.width) || 100;
			    const 眩晕状态 = 玩家状态.some((s) => s.类型 === "眩晕");
			    const 冻结状态 = 玩家状态.some((s) => s.类型 === "冻结");
			    const 缓慢状态 = 玩家状态.some((s) => s.类型 === "缓慢");
			    const 牵制状态 = 玩家状态.some((s) => s.类型 === "牵制");
			    
			
			    if (眩晕状态 && (dx !== 0 || dy !== 0)) {
			        添加日志("你晕头转向，胡乱移动！", "警告");
			        const 方向列表 = [
			            { dx: 0, dy: -1 },
			            { dx: 1, dy: 0 },
			            { dx: 0, dy: 1 },
			            { dx: -1, dy: 0 },
			        ];
			        const 可移动方向 = 方向列表.filter((dir) =>
			            检查移动可行性(
			                玩家.x,
			                玩家.y,
			                玩家.x + dir.dx,
			                玩家.y + dir.dy
			            )
			        );
			
			        if (可移动方向.length > 0) {
			            const 随机方向 =
			                可移动方向[
			                    Math.floor(prng() * 可移动方向.length)
			                ];
			            dx = 随机方向.dx;
			            dy = 随机方向.dy;
			        } else {
			            dx = 0;
			            dy = 0;
			        }
			
			        dx *= 玩家属性.移动步数;
			        dy *= 玩家属性.移动步数;
			
			        if (缓慢状态) {
			            dx = Math.sign(dx);
			            dy = Math.sign(dy);
			        }
			    } else {
			        if (缓慢状态) {
			            dx = Math.sign(dx);
			            dy = Math.sign(dy);
			        }
			    }
			    let 新X = 玩家.x + dx;
			    let 新Y = 玩家.y + dy;
			
			    
			    if (
			        新X < 0 ||
			        新X >= 地牢大小 ||
			        新Y < 0 ||
			        新Y >= 地牢大小
			    )
			        return;
			    相机锁定 = false;
			    if (玩家正在钩索) {
			        玩家正在钩索 = false;
			        clearTimeout(钩索移动定时器);
			    }
			    const 目标X_挖掘 = 玩家.x + Math.sign(dx);
			    const 目标Y_挖掘 = 玩家.y + Math.sign(dy);
			    if (玩家属性.能挖掘墙壁 && (dx !== 0 || dy !== 0) && !生存挑战激活) {
			        if (目标X_挖掘 >= 0 && 目标X_挖掘 < 地牢大小 && 目标Y_挖掘 >= 0 && 目标Y_挖掘 < 地牢大小) {
			            const 目标单元格 = 地牢[目标Y_挖掘]?.[目标X_挖掘];
			            if (目标单元格 && 目标单元格.背景类型 === 单元格类型.墙壁) {
			                 if(扣除能量(5)) {
			                    目标单元格.背景类型 = 地牢[玩家.y][玩家.x].背景类型;
			                    生成墙壁();
			                    
			                 } else {
			                    显示通知("能量不足，无法挖掘！", "错误");
			                    return false;
			                 }
			            }
			        }
			    }
			    let 剩余步数 = 缓慢状态 ? 1 : 玩家属性.移动步数;
			    let 实际移动 = 0;
			    let 目标X,
			        目标Y = 0;
			    let 旧玩家X = 玩家.x
			    let 旧玩家Y = 玩家.y
			    while (
			        剩余步数 > 0 &&
			        !(冻结状态 || 牵制状态) &&
			        (玩家.x !== 新X || 玩家.y !== 新Y)
			    ) {
			        目标X = 玩家.x + Math.sign(dx);
			        目标Y = 玩家.y + Math.sign(dy);
			        let 目标单元格 = 地牢[目标Y]?.[目标X];
			        let 当前单元格 = 地牢[玩家.y]?.[玩家.x];
			        if (!检查移动可行性(玩家.x, 玩家.y, 目标X, 目标Y)) break;
			        if (!目标单元格) {
			            更新视口();
			            绘制();
			            return;
			        }
			        if (
			            目标单元格.isOneWay &&
			            [单元格类型.门, 单元格类型.上锁的门].includes(
			                目标单元格.背景类型
			            )
			        ) {
			            const actualMoveMapDirection = getMoveDirection(
			                玩家.x,
			                玩家.y,
			                目标X,
			                目标Y
			            );
			            if (
			                actualMoveMapDirection !==
			                目标单元格.oneWayAllowedDirection
			            ) {
			                break;
			            }
			        }
			
			        const 旧X = 玩家.x;
			        const 旧Y = 玩家.y;
			        玩家.x = 目标X;
			        玩家.y = 目标Y;
			
			        let 触发中断 = 处理玩家着陆效果(旧X, 旧Y, 目标X, 目标Y);
			        
			
			        if (!触发中断) {
			            
			        } else {
			
			            break;
			        }
			        实际移动++;
			        剩余步数--;
			
			        if (当前激活卷轴列表.size > 0 && 实际移动 > 0) {
			            当前激活卷轴列表.forEach((卷轴) => {
			                卷轴.消耗能量();
			            });
			        }
			        
			    }
			    玩家动画状态 = {
			正在动画: true,
			旧逻辑X: 旧玩家X,
			旧逻辑Y: 旧玩家Y,
			目标逻辑X: 玩家.x,
			目标逻辑Y: 玩家.y,
			视觉X: 旧玩家X,
			视觉Y: 旧玩家Y,
			动画开始时间: Date.now()
			        };
			        玩家距离图=生成玩家距离图(玩家.x,玩家.y)
			        if(地牢生成方式==='default') {尝试进入特殊房间(玩家.x, 玩家.y);}
			    if (!切换动画&&(冻结状态 || 牵制状态 || 实际移动>0)) {
			        处理回合逻辑();
			    }
			    if (地牢[玩家.y][玩家.x].关联物品 instanceof 折跃门) {
			        地牢[玩家.y][玩家.x].关联物品.使用();
			    }
			    
			    if (实际移动 > 0 || 冻结状态) {
			        const 方向 =
			            Math.sign(dy) === -1
			                ? "上"
			                : Math.sign(dy) === 1
			                ? "下"
			                : Math.sign(dx) === -1
			                ? "左"
			                : Math.sign(dx) === 1
			                ? "右"
			                : "";
			        if ((!是否是自定义关卡 && 游戏状态!=='编辑器游玩') || 开发者模式) 移动历史.push(方向);
			
			        if (移动历史.length > 调试序列.length) {
			            移动历史=移动历史.slice(-调试序列.length);
			        }
			        Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			        )
			            .filter((v) => v != null)
			            .forEach((item) => {
			                if (item instanceof 寻宝戒指) {
			                    if (
			                        item.自定义数据.get("生效层数") ===
			                            当前层数 &&
			                        !item.自定义数据.get("已生成折跃门")
			                    ) {
			                        item.尝试生成折跃门();
			                    }
			                }
			            });
			
			        if (移动历史.join(",") === 调试序列.join(",")) {
			            const 当前房间ID = 房间地图[玩家.y][玩家.x];
			            if (当前房间ID !== -1) {
			                const 迅捷卷轴测试 = new 迅捷卷轴({});
			                放置物品到房间(迅捷卷轴测试, 房间列表[当前房间ID]);
			
			                const 秘银锁甲测试 = new 秘银锁甲({});
			                放置物品到房间(秘银锁甲测试, 房间列表[当前房间ID]);
			
			                const 跃迁卷轴测试 = new 跃迁卷轴({});
			                放置物品到房间(跃迁卷轴测试, 房间列表[当前房间ID]);
			
			                const 真言卷轴测试 = new 真言卷轴({});
			                放置物品到房间(真言卷轴测试, 房间列表[当前房间ID]);
			                const 调试工具实例 = new 调试工具({});
			                放置物品到房间(调试工具实例, 房间列表[当前房间ID]);
			
			                const 湮灭卷轴测试 = new 湮灭卷轴({});
			                放置物品到房间(湮灭卷轴测试, 房间列表[当前房间ID]);
			
			                const 贪婪卷轴测试 = new 贪婪卷轴({});
			                放置物品到房间(贪婪卷轴测试, 房间列表[当前房间ID]);
			
			                const 附魔卷轴测试 = new 附魔卷轴({});
			                放置物品到房间(附魔卷轴测试, 房间列表[当前房间ID]);
			
			                const 回旋镖测试 = new 回旋镖({});
			                放置物品到房间(回旋镖测试, 房间列表[当前房间ID]);
			
			                const 冰霜法杖测试 = new 冰霜法杖({});
			                放置物品到房间(冰霜法杖测试, 房间列表[当前房间ID]);
			
			                const 剧毒匕首测试 = new 剧毒匕首({});
			                放置物品到房间(剧毒匕首测试, 房间列表[当前房间ID]);
			
			                const 重力锤测试 = new 重力锤({});
			                放置物品到房间(重力锤测试, 房间列表[当前房间ID]);
			
			                const 闪电链法杖测试 = new 闪电链法杖({});
			                放置物品到房间(
			                    闪电链法杖测试,
			                    房间列表[当前房间ID]
			                );
			
			                const 大地猛击锤测试 = new 大地猛击锤({});
			                放置物品到房间(
			                    大地猛击锤测试,
			                    房间列表[当前房间ID]
			                );
			
			                const 穿云箭测试 = new 穿云箭({});
			                放置物品到房间(穿云箭测试, 房间列表[当前房间ID]);
			
			                const 荆棘鞭测试 = new 荆棘鞭({});
			                放置物品到房间(荆棘鞭测试, 房间列表[当前房间ID]);
			
			                const 能量药水测试 = new 能量药水({});
			                放置物品到房间(能量药水测试, 房间列表[当前房间ID]);
			
			                const 狂暴药水测试 = new 狂暴药水({});
			                放置物品到房间(狂暴药水测试, 房间列表[当前房间ID]);
			
			                const 神龟药水测试 = new 神龟药水({});
			                放置物品到房间(神龟药水测试, 房间列表[当前房间ID]);
			
			                const 治疗药水测试 = new 治疗药水({});
			                放置物品到房间(治疗药水测试, 房间列表[当前房间ID]);
			
			                const 透视药水测试 = new 透视药水({});
			                放置物品到房间(透视药水测试, 房间列表[当前房间ID]);
			
			                const 隐身药水测试 = new 隐身药水({});
			                放置物品到房间(隐身药水测试, 房间列表[当前房间ID]);
			
			                const 橡木法杖测试 = new 橡木法杖({});
			                放置物品到房间(橡木法杖测试, 房间列表[当前房间ID]);
			
			                const 金币手枪测试 = new 金币手枪({});
			                放置物品到房间(金币手枪测试, 房间列表[当前房间ID]);
			
			                const 寻宝戒指测试 = new 寻宝戒指({});
			                放置物品到房间(寻宝戒指测试, 房间列表[当前房间ID]);
			
			                const 炸弹测试 = new 炸弹({});
			                放置物品到房间(炸弹测试, 房间列表[当前房间ID]);
			
			                const 冰盾测试 = new 冰盾({});
			                放置物品到房间(冰盾测试, 房间列表[当前房间ID]);
			
			                const 重铸台测试 = new 重铸台({});
			                放置物品到房间(重铸台测试, 房间列表[当前房间ID]);
			
			                const 神秘商人测试 = new 神秘商人({});
			                放置物品到房间(神秘商人测试, 房间列表[当前房间ID]);
			
			                const 探险家测试 = new 探险家({});
			                放置物品到房间(探险家测试, 房间列表[当前房间ID]);
			
			                const 喷火枪测试 = new 喷火枪({});
			                放置物品到房间(喷火枪测试, 房间列表[当前房间ID]);
			
			                const 背包扩容祭坛测试 = new 背包扩容祭坛({});
			                放置物品到房间(
			                    背包扩容祭坛测试,
			                    房间列表[当前房间ID]
			                );
			
			                const 宠物测试 = new 水母({});
			                放置物品到房间(宠物测试, 房间列表[当前房间ID]);
			
			                const 金币测试 = new 金币({ 数量: 64 });
			                放置物品到房间(金币测试, 房间列表[当前房间ID]);
			                if (!彩蛋3触发) {
			                    显示通知("你被加强了，快上！", "信息", true);
			                    彩蛋3触发 = true;
			                }
			            }
			            移动历史 = [];
			        }
			        更新视口();
			        if (当前天气效果.includes("诡魅")) {
			            处理诡魅房间刷新(
			                玩家.x - dx,
			                玩家.y - dy,
			                玩家.x,
			                玩家.y
			            );
			        }
			    }
			    if (isAutoMoving && (玩家.x !== 新X || 玩家.y !== 新Y)) {
			        moveQueue = [];
			        isAutoMoving = false;
			    }
			    if (玩家属性.随机掉落 && prng() < 0.09) {
			        const 可掉落物品 = [...玩家背包.values()].filter(item => !item.是否隐藏 && !item.已装备);
			        if (可掉落物品.length > 0) {
			            const 掉落物品 = 可掉落物品[Math.floor(prng() * 可掉落物品.length)];
			            if (处理丢弃物品(掉落物品.唯一标识)) {
			                显示通知(`【诅咒】你的 ${掉落物品.获取名称()} 不小心掉了出来！`, "警告");
			            }
			        }
			    }
			    更新界面状态();
			    绘制();
			}
			function 扣除能量(能量, 是否卷轴 = false) {
			    if(调试无限能量) return true;
			    const 能量条 = document.querySelector(".power-bar");
			    let 当前能量 = Math.max(
			        Math.min(parseFloat(能量条.style.width), 100),
			        0
			    );
			    当前能量 -= 能量/自定义全局设置.初始能量值*100;
			    if (当前能量 <= 0) {
			        if (当前激活卷轴列表.size > 0) {
			            当前激活卷轴列表.forEach((卷轴) => {
			                当前激活卷轴列表.delete(卷轴);
			                卷轴.卸下();
			            });
			
			            当前能量 = 0;
			        }
			        更新装备显示();
			        if (是否卷轴)
			            显示通知("能量不足，已自动取消卷轴效果", "信息");
			        return false;
			    }
			    能量条.style.width = `${Math.max(0, 当前能量)}%`;
			    触发HUD显示();
			    return true;
			}
			function 检查移动可行性(
			    fromX,
			    fromY,
			    toX,
			    toY,
			    未解锁房间视作障碍 = false,
			    无视物品 = false
			) {
			    if (toX < 0 || toX >= 地牢大小 || toY < 0 || toY >= 地牢大小)
			        return false;
			
			    const 目标单元格实例 = 地牢[toY]?.[toX];
			    if (目标单元格实例?.关联物品 && !无视物品) {
			        if (目标单元格实例.关联物品 instanceof 红砖块 && 红蓝开关状态 === '红') return false;
			        if (目标单元格实例.关联物品 instanceof 蓝砖块 && 红蓝开关状态 === '蓝') return false;
			        if (目标单元格实例.关联物品 instanceof 绿砖块 && 绿紫开关状态 === '绿') return false;
			        if (目标单元格实例.关联物品 instanceof 紫砖块 && 绿紫开关状态 === '紫') return false;
			    }
			
			    const dx = toX - fromX;
			    const dy = toY - fromY;
			    const 方向 = {
			        dx: dx !== 0 ? (dx > 0 ? 1 : -1) : 0,
			        dy: dy !== 0 ? (dy > 0 ? 1 : -1) : 0,
			    };
			    if (Math.abs(dx) == 0 || Math.abs(dy) == 0) {
			        return 快速直线检查(
			            fromX,
			            fromY,
			            toX,
			            toY,
			            Math.max(Math.abs(dx), Math.abs(dy))
			        );
			    }
			
			    let currentX = fromX;
			    let currentY = fromY;
			
			    while (currentX !== toX || currentY !== toY) {
			        currentX += 方向.dx;
			        currentY += 方向.dy;
			
			        const 当前单元格 = 地牢[currentY][currentX];
			        const 前一单元格 =
			            地牢[currentY - 方向.dy][currentX - 方向.dx];
			
			        const 垂直移动 = 方向.dy !== 0;
			        const 墙方向 = 垂直移动
			            ? 方向.dy > 0
			                ? "下"
			                : "上"
			            : 方向.dx > 0
			            ? "右"
			            : "左";
			
			        if (垂直移动) {
			            if (
			                前一单元格.墙壁[方向.dy > 0 ? "下" : "上"] ||
			                当前单元格.墙壁[方向.dy > 0 ? "上" : "下"]
			            ) {
			                return false;
			            }
			        } else {
			            if (
			                前一单元格.墙壁[方向.dx > 0 ? "右" : "左"] ||
			                当前单元格.墙壁[方向.dx > 0 ? "左" : "右"]
			            ) {
			                return false;
			            }
			        }
			        if((当前单元格.关联物品?.类型 === '开关砖' && 当前单元格.关联物品?.阻碍怪物) &&!无视物品) return false;
			
			        if (
			            [单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                当前单元格.背景类型
			            )
			        ) {
			            return false;
			        }
			        if (
			            房间地图[currentY][currentX] !== 0 &&
			            房间地图[currentY][currentX] !== -1 &&
			            !已访问房间.has(房间地图[currentY][currentX]) &&
			            未解锁房间视作障碍
			        )
			            return false;
			    }
			    return true;
			}
			function 处理丢弃物品(唯一标识) {
			    const 物品实例 = 玩家背包.get(唯一标识);
			    if (!物品实例) return false;
			
			    let 目标X = 玩家.x;
			    let 目标Y = 玩家.y;
			    let 可用 = false;
			
			    if (位置是否可用(目标X, 目标Y, false)) {
			        可用 = true;
			    } else {
			        const 方向 = [
			            [0, -1],
			            [0, 1],
			            [-1, 0],
			            [1, 0],
			            [1, -1],
			            [1, 1],
			            [-1, 1],
			            [-1, -1],
			        ];
			        for (const [dx, dy] of 方向) {
			            const 新X = 玩家.x + dx;
			            const 新Y = 玩家.y + dy;
			
			            if (
			                新X >= 0 &&
			                新X < 地牢大小 &&
			                新Y >= 0 &&
			                新Y < 地牢大小 &&
			                位置是否可用(新X, 新Y) &&
			                检查移动可行性(玩家.x, 玩家.y, 新X, 新Y)
			            ) {
			                目标X = 新X;
			                目标Y = 新Y;
			                可用 = true;
			                break;
			            }
			        }
			    }
			
			    if (!可用) {
			        显示通知("周围没有空间丢弃物品！", "错误");
			        return false;
			    }
			    if (!物品实例.当被丢弃(目标X, 目标Y)) {
			        return false;
			    }
			    玩家背包.delete(唯一标识);
			    if (物品实例.已装备) {
			        物品实例.取消装备();
			        玩家装备.delete(物品实例.装备槽位);
			        物品实例.已装备 = false;
			        物品实例.装备槽位 = null;
			    }
			
			    物品实例.是否被丢弃 = true;
			    物品实例.isActive = false;
			    放置物品到单元格(物品实例, 目标X, 目标Y);
			
			    更新背包显示();
			    更新装备显示();
			    显示通知(`丢弃了 ${物品实例.获取名称()}`, "信息");
			    if (!彩蛋1触发) {
			                 检查Q字形彩蛋(目标X, 目标Y);
			             }
			    document.getElementById("浮动提示框").style.display = "none";
			
			    return true;
			}
			function 处理天气效果() {
			    if (当前天气效果.includes("雷暴")) {
			        处理雷暴效果();
			    }
			    if (当前天气效果.includes("大风")) {
			        处理大风效果();
			    }
			    if (当前天气效果.includes("严寒")) {
			        处理严寒效果();
			    } else {
			        解冻药水();
			    }
			}
			function 是否靠近火源(目标X, 目标Y) {
			    if (目标X === 玩家.x && 目标Y === 玩家.y) {
			        if (玩家状态.some((s) => s.类型 === "火焰")) return true;
			        if (
			            Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			                玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			            )
			                .filter((v) => v != null)
			                .some(
			                    (装备) =>
			                        装备 instanceof 火把 &&
			                        装备.自定义数据?.get("耐久") > 0
			                )
			        )
			            return true;
			    }
			
			    const 方向数组 = [
			        [0, 0],
			        [0, -1],
			        [0, 1],
			        [-1, 0],
			        [1, 0],
			        [-1, -1],
			        [1, -1],
			        [-1, 1],
			        [1, 1],
			    ];
			    for (const [dx, dy] of 方向数组) {
			        const 检查X = 目标X + dx;
			        const 检查Y = 目标Y + dy;
			        if (
			            检查X >= 0 &&
			            检查X < 地牢大小 &&
			            检查Y >= 0 &&
			            检查Y < 地牢大小
			        ) {
			            const 单元格 = 地牢[检查Y]?.[检查X];
			            const 怪物实例 = 单元格?.关联怪物;
			            if (
			                单元格?.关联物品 instanceof 火焰物品 &&
			                单元格.关联物品.自定义数据.get("倒计时") > 0
			            ) {
			                return true;
			            } else if (
			                单元格?.关联物品 instanceof 火把 &&
			                单元格.关联物品.自定义数据.get("耐久") > 0 &&
			                单元格.关联物品.是否被丢弃
			            ) {
			                return true;
			            } else if (
			                怪物实例 &&
			                怪物状态表.get(怪物实例)?.类型 === "火焰"
			            ) {
			                return true;
			            }
			        }
			    }
			    return false;
			}
			function 解冻药水() {
			    let 解冻发生标志 = false;
			    玩家背包.forEach((物品实例) => {
			        if (
			            物品实例 instanceof 药水类 &&
			            物品实例.自定义数据.get("是否冻结")
			        ) {
			            物品实例.自定义数据.set("是否冻结", false);
			
			            解冻发生标志 = true;
			        }
			    });
			    if (解冻发生标志) {
			        添加日志("背包里的药水解冻了。", "信息");
			        更新背包显示();
			    }
			}
			
			function 处理严寒效果() {
			    if (
			        !玩家状态.some((s) => s.类型 === "冻结") &&
			        !是否靠近火源(玩家.x, 玩家.y)
			    ) {
			        if (prng() < 0.1) {
			            new 状态效果(
			                "冻结",
			                "#2196F3",
			                图标映射.冰冻怪物,
			                2,
			                null,
			                null,
			                null,
			                1
			            );
			            添加日志("你被严寒冻结了！", "错误");
			        }
			    }
			
			    let 有药水被冻结 = false;
			    玩家背包.forEach((物品实例) => {
			        if (
			            物品实例 instanceof 药水类 &&
			            !物品实例.自定义数据.get("是否冻结")
			        ) {
			            if (!是否靠近火源(玩家.x, 玩家.y)) {
			                物品实例.自定义数据.set("是否冻结", true);
			                有药水被冻结 = true;
			                添加日志(
			                    `${物品实例.获取名称()} 被冻结了！`,
			                    "警告"
			                );
			            }
			        }
			    });
			    if (有药水被冻结) {
			        更新背包显示();
			    }
			    if (是否靠近火源(玩家.x, 玩家.y)) {
			        解冻药水();
			    }
			}
			function 处理雷暴效果() {
			    let 雷击概率 = 0.1;
			    const 有铜质装备 = Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).some(装备 => 装备.材质 === 材料.铜质);
			    if (有铜质装备) {
			        雷击概率 = 0.25;
			    }
			    if (prng() < 雷击概率) {
			        const 玩家房间ID = 房间地图[玩家.y][玩家.x];
			        let rx=0
			        let ry=0
			        if (玩家房间ID === -1) {
			            rx =
			            玩家.x-7 +
			            Math.floor(prng() * 14);
			            ry =
			            玩家.y-7 +
			            Math.floor(prng() * 14);
			        } else {
			
			        const 玩家所在房间 = 房间列表[玩家房间ID];
			        if (
			            !玩家所在房间 ||
			            玩家所在房间.w < 2 ||
			            玩家所在房间.h < 2
			        )
			            return;
			
			        rx =
			            玩家所在房间.x +
			            Math.floor(prng() * (玩家所在房间.w - 1));
			        ry =
			            玩家所在房间.y +
			            Math.floor(prng() * (玩家所在房间.h - 1));
			        }
			        const 闪电坐标 = [
			            { x: rx, y: ry },
			            { x: rx + 1, y: ry },
			            { x: rx, y: ry + 1 },
			            { x: rx + 1, y: ry + 1 },
			        ];
			
			        计划显示格子特效(闪电坐标, "FFFF00", 50);
			
			        闪电坐标.forEach((坐标) => {
			            if (
			                坐标.x < 0 ||
			                坐标.x >= 地牢大小 ||
			                坐标.y < 0 ||
			                坐标.y >= 地牢大小
			            )
			                return;
			            const 单元格 = 地牢[坐标.y]?.[坐标.x];
			            if (!单元格) return;
			
			            if (
			                单元格.关联物品 &&
			                单元格.关联物品?.类型 !== "楼梯" &&
			                !(单元格.关联物品 instanceof 挑战石碑)
			            ) {
			                const 被毁物品 = 单元格.关联物品;
			                添加日志(`${被毁物品.名称} 被闪电摧毁了！`, "警告");
			                const 计时器索引 = 所有计时器.findIndex(
			                    (t) => t.唯一标识 === 被毁物品.唯一标识
			                );
			                if (计时器索引 !== -1) {
			                    所有计时器.splice(计时器索引, 1);
			                }
			                if (玩家背包.has(被毁物品.唯一标识)) {
			                    处理销毁物品(被毁物品.唯一标识, true);
			                }
			                单元格.关联物品 = null;
			                单元格.类型 = null;
			            }
			
			            if (单元格.关联怪物) {
			                const 怪物 = 单元格.关联怪物;
			                let 被击中日志 = `${怪物.类型} 被闪电击中`;
			                if (怪物.强化) {
			                    怪物.受伤(15, "雷暴");
			                    被击中日志 += `，损失了 15 点生命！`;
			                } else {
			                    怪物.强化 = true;
			                    怪物.绘制血条();
			                    显示通知(`${怪物.类型} 被闪电强化了！`, "警告");
			                    被击中日志 += `，并被强化了！`;
			                    绘制();
			                }
			                const 火焰强度 = 3;
			                const 火焰持续 = 3;
			                new 状态效果(
			                    "火焰",
			                    效果颜色编号映射[效果名称编号映射.火焰],
			                    "火",
			                    火焰持续,
			                    null,
			                    null,
			                    怪物,
			                    火焰强度
			                );
			                被击中日志 += ` 还着火了！`;
			
			                添加日志(被击中日志, "警告");
			            }
			
			            if (玩家.x === 坐标.x && 玩家.y === 坐标.y) {
			                伤害玩家(15, "雷暴");
			                显示通知("你被闪电击中了！", "错误");
			
			                const 火焰强度玩家 = 3;
			                const 火焰持续玩家 = 3;
			                new 状态效果(
			                    "火焰",
			                    效果颜色编号映射[效果名称编号映射.火焰],
			                    图标映射.火焰,
			                    火焰持续玩家,
			                    null,
			                    null,
			                    null,
			                    火焰强度玩家
			                );
			                添加日志("你被闪电点燃了！", "错误");
			            }
						当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === 坐标.x && pet.y === 坐标.y && pet.层数==当前层数 ) {
        pet.受伤(15, "雷暴");
        显示通知(`${pet.名称} 被闪电击中了！`, "错误");
    }
});
			
			            if (位置是否可用(坐标.x, 坐标.y, false)) {
			                const 火焰 = new 火焰物品({
			                    强化: prng() < 0.1,
			                });
			                if (!放置物品到单元格(火焰, 坐标.x, 坐标.y)) {
			                    console.warn(
			                        `未能放置火焰物品在 (${坐标.x}, ${坐标.y})`
			                    );
			                }
			            }
			        });
			        绘制();
			    }
			}
			let 融合区物品 = [null, null, null, null]; // 存储物品的唯一标识 Symbol
			let 融合结果 = null; // 存储融合结果的物品实例
			
			const 融合配方列表 = [
			    {
			        输入: ["治疗药水", "治疗药水"].sort(),
			        输出类: "治疗药水",
			        输出数量: 1,
			        输出配置: { 强化: true },
			    },
			    {
			        输入: ["钢制长剑", "治疗药水"].sort(),
			        输出类: "吸血剑",
			        输出数量: 1,
			    },
			    {
			        输入: ["钢制长剑", "钢制长剑"].sort(),
			        输出类: "钢制长剑",
			        输出数量: 1,
			        输出配置: { 强化: true },
			    },
			];
			
			let fusionGoldQuantities = [0, 0, 0, 0];
			
			function 添加到融合区(物品实例, 起始元素) {
			    if (!物品实例) return;
			
			    const targetSlotIndex = 融合区物品.findIndex(格子 => 格子 === null);
			
			    if (targetSlotIndex === -1) {
			        显示通知("融合区已满！", "错误");
			        return;
			    }
			
			    if (物品实例 instanceof 金币) {
			        let goldSlotIndex = -1;
			        for (let i = 0; i < 4; i++) {
			const itemInSlot = 融合区物品[i];
			if (itemInSlot === null || (itemInSlot instanceof 金币 && fusionGoldQuantities[i] < 最大堆叠数)) {
			    goldSlotIndex = i;
			    break;
			}
			        }
			        if (goldSlotIndex === -1) {
			 显示通知("融合区已满或无合适槽位！", "错误");
			return;
			        }
			        物品实例.堆叠数量--;
			        if (融合区物品[goldSlotIndex] === null) {
			融合区物品[goldSlotIndex] = 物品实例;
			        }
			        fusionGoldQuantities[goldSlotIndex]++;
			        if (物品实例.堆叠数量 <= 0) {
			           玩家背包.delete(物品实例.唯一标识);
			           if (物品实例.装备槽位) 物品实例.取消装备()
			        }
			        const 获取目标元素的函数 = () => document.getElementById(`融合区格子${goldSlotIndex + 1}`);
			        创建并播放物品移动动画(起始元素, 获取目标元素的函数);
			    } else {
			        if (物品实例.堆叠数量 > 1) {
			物品实例.堆叠数量--; 
			const 移出物品 = 克隆物品(物品实例); 
			移出物品.堆叠数量 = 1;
			移出物品.实际唯一标识 = 物品实例.唯一标识
			融合区物品[targetSlotIndex] = 移出物品; 
			        } else {
			玩家背包.delete(物品实例.唯一标识); 
			if (物品实例.装备槽位) 物品实例.取消装备()
			物品实例.实际唯一标识 = 物品实例.唯一标识
			融合区物品[targetSlotIndex] = 物品实例; 
			        }
			        const 获取目标元素的函数 = () => document.getElementById(`融合区格子${targetSlotIndex + 1}`);
			        创建并播放物品移动动画(起始元素, 获取目标元素的函数);
			    }
			    
			    物品实例.isActive = false;
			    if (物品实例.显示元素) 物品实例.显示元素.classList.remove("active");
			    document.getElementById("浮动提示框").style.display = "none";
			    if (typeof gsap !== 'undefined') {
			                setTimeout(()=>{更新融合窗口();
			        检查融合配方();
			        更新背包显示();
			        更新装备显示();}, 320);
			            } else {
			                更新融合窗口();
			        检查融合配方();
			        更新背包显示();
			        更新装备显示();
			            }
			    
			        
			}
			
			let 当前匹配的融合配方 = null;
			
			
			
			function 从融合区移除(格子索引) {
			    const 物品实例 = 融合区物品[格子索引];
			    if (物品实例 === null) return;
			    
			    document.getElementById("浮动提示框").style.display = "none";
			
			    if (物品实例 instanceof 金币) {
			        const goldAmountToReturn = fusionGoldQuantities[格子索引] || 0;
			        if (goldAmountToReturn > 0) {
			             fusionGoldQuantities[格子索引] = 0;
			             融合区物品[格子索引] = null;
			             尝试收集物品(new 金币({ 数量: goldAmountToReturn }), true);
			        } else {
			             融合区物品[格子索引] = null;
			        }
			    } else {
			        融合区物品[格子索引] = null; 
			        const 收集成功 = 尝试收集物品(物品实例, true);
			
			        if (!收集成功) {
			            融合区物品[格子索引] = 物品实例; 
			            显示通知("背包已满，无法取回！", "错误");
			        }
			    }
			    
			    检查融合配方();
			    更新融合窗口();
			    更新背包显示();
			    更新装备显示();
			}
			
			function 执行融合(){
			    if(!融合结果){
			        显示通知("没有有效的融合结果！","错误");
			        return;
			    }
			
			    const originalFusionSlotItems = [...融合区物品];
			    const consumedItemSymbols = new Set();
			    const consumedGoldQuantities = [0, 0, 0, 0];
			
			    if(当前匹配的融合配方 === "卷轴附魔融合"){
			        const 附魔卷轴实例 = originalFusionSlotItems.find(item => item instanceof 附魔卷轴 && item.自定义数据.get("已解锁"));
			        const 目标物品原件 = originalFusionSlotItems.find(item => item && (item instanceof 武器类 || item instanceof 防御装备类));
			
			        if(!附魔卷轴实例 || !目标物品原件){
			显示通知("融合错误：找不到卷轴或目标物品！","错误");
			return;
			        }
			
			        const 输出物品 = 克隆物品(目标物品原件);
			        const 附魔成功 = 附魔卷轴实例.附魔效果.call(附魔卷轴实例, 输出物品);
			
			        if(附魔成功){
			融合结果 = 输出物品;
			consumedItemSymbols.add(附魔卷轴实例.唯一标识);
			consumedItemSymbols.add(目标物品原件.唯一标识);
			输出物品.是否隐藏 = false;
			尝试收集物品(输出物品, true);
			附魔卷轴实例.可用次数 = (附魔卷轴实例.可用次数 === undefined ? 1 : 附魔卷轴实例.可用次数) - 1;
			if (附魔卷轴实例.可用次数 <= 0) {
			     处理销毁物品(附魔卷轴实例.唯一标识, true);
			}
			显示通知(`${输出物品.获取名称()} 附魔成功！`, "成功");
			        }else{
			显示通知("附魔失败！(能量不足或不兼容)", "错误");
			return;
			        }
			    } else if (当前匹配的融合配方 === "药水金币延长") {
			        const 药水实例 = originalFusionSlotItems.find(item => item instanceof 药水类);
			        if(!药水实例) {
			 显示通知("融合错误：找不到药水！", "错误");
			 return;
			        }
			
			        let 总消耗金币数量 = 0;
			        originalFusionSlotItems.forEach((item, index) => {
			if (item instanceof 金币 && fusionGoldQuantities[index] > 0) {
			    总消耗金币数量 += fusionGoldQuantities[index];
			    consumedGoldQuantities[index] = fusionGoldQuantities[index];
			}
			        });
			
			        const potionExtendEnergyCost = 2 * 总消耗金币数量;
			        if (!扣除能量(potionExtendEnergyCost)) {
			显示通知(`能量不足！需要 ${potionExtendEnergyCost} 点能量。`, "错误");
			return;
			        }
			
			        consumedItemSymbols.add(药水实例.唯一标识);
			        originalFusionSlotItems.forEach((item, index) => {
			if (item instanceof 金币 && consumedGoldQuantities[index] > 0) {
			    consumedItemSymbols.add(item.唯一标识);
			}
			        });
			        
			        const 延长后的药水 = 克隆物品(融合结果);
			        延长后的药水.唯一标识 = Symbol("ExtendedPotion_" + Date.now());
			        延长后的药水.是否隐藏 = false;
			        if(尝试收集物品(延长后的药水, true)){
			显示通知(`${延长后的药水.名称} 持续时间已延长！`, "成功");
			        } else {
			 显示通知("融合失败：无法将产物放入背包！", "错误");
			 const 能量条 = document.querySelector(".power-bar");
			 const 当前能量 = parseFloat(能量条.style.width) || 0;
			 if (能量条) 能量条.style.width = `${Math.min(100, 当前能量 + potionExtendEnergyCost/自定义全局设置.初始能量值*100)}%`;
			 return;
			        }
			
			    } else if (当前匹配的融合配方 === "木材转化融合" || 当前匹配的融合配方 === "铁器锈蚀融合") {
			        const energyCost = 10;
			        if (!扣除能量(energyCost)) {
			            显示通知(`能量不足！需要 ${energyCost} 点能量。`, "错误");
			            return;
			        }
			        const 产物 = 克隆物品(融合结果);
			        if (尝试收集物品(产物, true)) {
			            originalFusionSlotItems.forEach(item => {
			                if (item) consumedItemSymbols.add(item.唯一标识);
			            });
			            显示通知(`${产物.获取名称()} 转化成功！`, "成功");
			        } else {
			            显示通知("融合失败：无法将产物放入背包！", "错误");
			            const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            if (能量条) 能量条.style.width = `${Math.min(100, 当前能量 + energyCost/自定义全局设置.初始能量值*100)}%`;
			            return;
			        }
			    } else if (当前匹配的融合配方 && typeof 当前匹配的融合配方 === "object" && 当前匹配的融合配方 !== "装备融合" && 当前匹配的融合配方 !== "词条融合") {
			        const 配方 = 当前匹配的融合配方;
			        const recipeEnergyCost = 5 * 配方.输入.length;
			        if (!扣除能量(recipeEnergyCost)) {
			显示通知(`能量不足！需要 ${recipeEnergyCost} 点能量。`, "错误");
			return;
			        }
			
			        const 实际输出物品 = 克隆物品(融合结果);
			        if (尝试收集物品(实际输出物品, true)) {
			const tempFusionItems = [...originalFusionSlotItems];
			配方.输入.forEach(requiredName => {
			    const foundIndex = tempFusionItems.findIndex(item => item && item.名称 === requiredName);
			    if (foundIndex !== -1) {
			        const itemToConsume = tempFusionItems.splice(foundIndex, 1)[0];
			        consumedItemSymbols.add(itemToConsume.唯一标识);
			    }
			});
			显示通知(`成功融合出 ${实际输出物品.获取名称()}！`, "成功");
			        } else {
			显示通知("融合失败：无法将产物放入背包！", "错误");
			const 能量条 = document.querySelector(".power-bar");
			const 当前能量 = parseFloat(能量条.style.width) || 0;
			if (能量条) 能量条.style.width = `${Math.min(100, 当前能量 + recipeEnergyCost/自定义全局设置.初始能量值*100)}%`;
			return;
			        }
			    } else if (当前匹配的融合配方 === "磨刀石打磨") {
			        const 磨刀石实例 = originalFusionSlotItems.find(item => item instanceof 磨刀石);
			        const 武器实例 = originalFusionSlotItems.find(item => item instanceof 武器类);
			        const energyCost = 15;
			        if (!扣除能量(energyCost)) {
			显示通知(`能量不足！需要 ${energyCost} 点能量。`, "错误");
			return;
			        }
			
			        const buffs = 武器实例.自定义数据.get("fusedBuffs") || [];
			        const buffUses = 20 + Math.floor(prng() * 11);
			        
			        let attackBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石攻击加成);
			        if (attackBuff) {
			attackBuff.value += 1;
			attackBuff.usesLeft = (attackBuff.usesLeft || 0) + buffUses;
			        } else {
			buffs.push({ type: 融合Buff类型.磨刀石攻击加成, value: 1, usesLeft: buffUses });
			        }
			        
			        let cooldownBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石冷却缩减);
			        if (cooldownBuff) {
			cooldownBuff.value += 1;
			cooldownBuff.usesLeft = (cooldownBuff.usesLeft || 0) + buffUses;
			        } else {
			buffs.push({ type: 融合Buff类型.磨刀石冷却缩减, value: 1, usesLeft: buffUses });
			        }
			        
			        武器实例.自定义数据.set("fusedBuffs", buffs);
			        if (武器实例.自定义数据.has('锈蚀度')) {
			            武器实例.自定义数据.set('锈蚀度', 0);
			            显示通知(`${武器实例.获取名称()} 被成功打磨，锈迹斑斑的表面焕然一新！`, "成功");
			        } else {
			            显示通知(`${武器实例.获取名称()} 被成功打磨！`, "成功");
			        }
			        磨刀石实例.自定义数据.set("耐久", 磨刀石实例.自定义数据.get("耐久") - 1);
			       
			        if(磨刀石实例.自定义数据.get("耐久") <= 0) {
			consumedItemSymbols.add(磨刀石实例.唯一标识);
			        } else {
			            从融合区移除(0);
			        }
			        从融合区移除(1)
			        从融合区移除(2)
			        从融合区移除(3)
			
			    } else if (当前匹配的融合配方 === "装备融合") {
			        const item1 = originalFusionSlotItems[0];
			        const item2 = originalFusionSlotItems[1];
			
			        if(!item1 || !item2 || !(item1 instanceof 武器类 || item1 instanceof 防御装备类) || !(item2 instanceof 武器类 || item2 instanceof 防御装备类)){
			显示通知("融合错误：只有武器或装备才能进行此类融合！", "错误");
			return;
			        }
			
			        const equipFusionEnergyCost = 20 + (item1.品质 + item2.品质) * 5;
			        if (!扣除能量(equipFusionEnergyCost)) {
			显示通知(`能量不足！需要 ${equipFusionEnergyCost} 点能量。`, "错误");
			return;
			        }
			        
			        const mergedItem = 克隆物品(融合结果);
			        mergedItem.唯一标识 = Symbol("MergedEquip_" + Date.now());
			        mergedItem.是否隐藏 = false;
			        
			        consumedItemSymbols.add(item1.唯一标识);
			        consumedItemSymbols.add(item2.唯一标识);
			        
			        if (尝试收集物品(mergedItem, true)) {
			显示通知(`${mergedItem.获取名称()} 融合成功！`, "成功");
			        } else {
			显示通知("融合失败：无法将产物放入背包！", "错误");
			return;
			        }
			    } else if (当前匹配的融合配方 === "词条融合") {
			        const 武器原件 = originalFusionSlotItems[0];
			        if (!武器原件 || !是否为有效融合武器(武器原件)) {
			显示通知("融合错误：原始武器无效！", "错误");
			return;
			        }
			
			        const 待消耗材料实例 = [];
			        let 总计消耗金币数量 = 0;
			
			        for (let i = 1; i <= 3; i++) {
			const 物品 = originalFusionSlotItems[i];
			if (物品) {
			    if (物品 instanceof 金币 && fusionGoldQuantities[i] > 0) {
			        总计消耗金币数量 += fusionGoldQuantities[i];
			    } else if (!(物品 instanceof 金币) && 是否为有效融合材料(物品)) {
			        待消耗材料实例.push(物品);
			    }
			}
			        }
			        
			        const energyCostBuff = 10 + 待消耗材料实例.length * 3 + 总计消耗金币数量 * 0.5;
			        if (!扣除能量(energyCostBuff)) {
			显示通知(`能量不足！需要 ${energyCostBuff} 点能量。`, "错误");
			return;
			        }
			
			        待消耗材料实例.forEach(材料 => consumedItemSymbols.add(材料.唯一标识));
			        if (总计消耗金币数量 > 0) {
			originalFusionSlotItems.forEach((item, index) => {
			    if(item instanceof 金币 && fusionGoldQuantities[index] > 0) {
			        consumedItemSymbols.add(item.唯一标识);
			        consumedGoldQuantities[index] = fusionGoldQuantities[index];
			    }
			});
			        }
			        
			        const 应用的Buffs = 融合结果.自定义数据.get("fusedBuffs");
			        if (应用的Buffs && 应用的Buffs.length > 0) {
			 const 旧Buffs = 武器原件.自定义数据.get("fusedBuffs") || [];
			 武器原件.自定义数据.set("fusedBuffs", 合并Buff列表(旧Buffs, 应用的Buffs));
			 const materialChangeBuff = 应用的Buffs.find(b => b.type === 'MATERIAL_CHANGE');
			 if (materialChangeBuff) {
			     武器原件.材质 = materialChangeBuff.value;
			 }
			 const rustIncreaseBuff = 应用的Buffs.find(b => b.type === 'RUST_INCREASE');
			 if (rustIncreaseBuff) {
			     let rust = 武器原件.自定义数据.get('锈蚀度') || 0;
			     武器原件.自定义数据.set('锈蚀度', rust + rustIncreaseBuff.value);
			 }
			 const 耐久倍率 = 应用的Buffs.find(b => b.type === 'DURABILITY_MULTIPLIER');
			 if (耐久倍率) {
			     武器原件.自定义数据.set('原耐久',Math.round(武器原件.自定义数据.get('原耐久')*(1+耐久倍率.value)*10)/10);
			     武器原件.自定义数据.set('耐久',Math.round(武器原件.自定义数据.get('耐久')*(1+耐久倍率.value)*10)/10);
			 }
			 const 耐久加成 = 应用的Buffs.find(b => b.type === 'DURABILITY_BONUS');
			 if (耐久加成) {
			     武器原件.自定义数据.set('原耐久',武器原件.自定义数据.get('原耐久')+耐久加成.value);
			     武器原件.自定义数据.set('耐久',武器原件.自定义数据.get('耐久')+耐久加成.value);
			 }
			 显示通知(`${武器原件.获取名称()} 强化成功！`, "成功");
			        } else {
			 显示通知(`${武器原件.获取名称()} 没有获得强化效果。`, "信息");
			        }
			    }
			
			    for (let i = 0; i < 4; i++) {
			        const 物品实例 = originalFusionSlotItems[i];
			        if (物品实例 && consumedItemSymbols.has(物品实例.唯一标识)) {
			if (物品实例 instanceof 金币) {
			
			} else {
			     处理销毁物品(物品实例.唯一标识,true);
			}
			融合区物品[i] = null;
			if (物品实例 instanceof 金币) fusionGoldQuantities[i] = 0;
			        }
			    }
			    
			    融合结果 = null;
			    当前匹配的融合配方 = null;
			    检查融合配方()
			    更新融合窗口();
			    更新背包显示();
			    更新装备显示();
			}
			function 检查融合配方(){
			    当前匹配的融合配方=null;
			    const 输出格子=document.getElementById("融合输出格子");
			    输出格子.innerHTML="";
			    融合结果=null;
			    输出格子.onclick=null;
			    const 融合槽有效条目=[];
			    for(let i=0;i<4;i++){
			        const 物品实例=融合区物品[i];
			        if(物品实例){
			if(物品实例 instanceof 金币){
			    if(fusionGoldQuantities[i]>0){
			        融合槽有效条目.push({item:物品实例,quantityInSlot:fusionGoldQuantities[i],});
			    }
			}else{
			    融合槽有效条目.push({item:物品实例,quantityInSlot:物品实例.堆叠数量,});
			}
			        }
			    }
			
			    if(融合槽有效条目.length===0){
			        return;
			    }
			
			    const 融合槽物品实例列表=融合槽有效条目.map((entry)=>entry.item);
			    const 融合槽物品名称列表_sorted=融合槽物品实例列表.map((item)=>item.名称).sort();
			
			    const 磨刀石实例=融合槽物品实例列表.find(item=>item instanceof 磨刀石);
			    const 武器实例ForSharpen=融合槽物品实例列表.find(item=>item instanceof 武器类);
			    const 融合区第一个是磨刀石=融合区物品[0] instanceof 磨刀石;
			
			    if(融合槽物品实例列表.length===2&&磨刀石实例&&武器实例ForSharpen&&融合区第一个是磨刀石){
			        if(磨刀石实例.自定义数据.get("耐久")>0){
			当前匹配的融合配方="磨刀石打磨";
			融合结果=克隆物品(武器实例ForSharpen);
			融合结果.唯一标识=Symbol("SharpenPreview_"+Date.now());
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			        }
			    }
			
			    const 附魔卷轴实例=融合槽物品实例列表.find((item)=>item instanceof 附魔卷轴&&item.自定义数据.get("已解锁"));
			    const 其他物品实例列表=融合槽物品实例列表.filter((item)=>!(item instanceof 附魔卷轴));
			
			    if(附魔卷轴实例&&其他物品实例列表.length===1){
			        const 目标物品实例=其他物品实例列表[0];
			        if(目标物品实例 instanceof 武器类||目标物品实例 instanceof 防御装备类){
			const 附魔兼容性={
			    火焰附魔:["武器","防御装备"],
			    保护附魔:["防御装备"],
			    耐久附魔:["武器","防御装备"],
			    锋利附魔:["武器"],
			    爆炸保护附魔:["防御装备"],
			    连锁附魔:["武器"],
			    荆棘附魔:["防御装备"],
			};
			const 附魔种类=附魔卷轴实例.当前附魔效果名;
			const 允许列表=附魔兼容性[附魔种类];
			let 兼容=允许列表&&允许列表.includes(目标物品实例.类型);
			if(兼容&&目标物品实例.自定义数据.get("附魔")?.some((e)=>e.种类===附魔种类&&e.等级>=附魔卷轴实例.品质)){
			    兼容=false;
			}
			
			if(兼容){
			    当前匹配的融合配方="卷轴附魔融合";
			    融合结果=克隆物品(目标物品实例);
			    const 输入物品是否有不可破坏=[附魔卷轴实例,目标物品实例].some(item=>item.自定义数据?.get("不可破坏"));
			    if(输入物品是否有不可破坏){
			        融合结果.自定义数据.set("不可破坏",true);
			    }
			    const 预览元素=融合结果.生成显示元素("融合");
			    const 附魔提示=document.createElement("div");
			    附魔提示.textContent=`将被附魔: ${附魔种类} (${附魔卷轴实例.品质}级)`;
			    附魔提示.style.color="cyan";
			    附魔提示.style.fontSize="0.8em";
			    附魔提示.style.textAlign="center";
			    预览元素.appendChild(附魔提示);
			    输出格子.appendChild(预览元素);
			    输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			    return;
			}
			        }
			    }
			
			    const firstSlotItem=融合区物品[0];
			    if(firstSlotItem&&firstSlotItem instanceof 药水类){
			        let onlyPotionAndGold=true;
			        let totalGold=0;
			        if(融合槽有效条目.length>1){
			for(let i=1;i<4;i++){
			    const itemSymbol=融合区物品[i];
			    if(itemSymbol){
			        const item=itemSymbol;
			        if(item instanceof 金币&&fusionGoldQuantities[i]>0){
			            totalGold+=fusionGoldQuantities[i];
			        }else{
			            onlyPotionAndGold=false;
			            break;
			        }
			    }
			}
			        }else{
			onlyPotionAndGold=false;
			        }
			
			        if(onlyPotionAndGold&&totalGold>0){
			const 新药水=克隆物品(firstSlotItem);
			const 原基础持续=新药水.自定义数据.get("基础持续时间")||3;
			const 延长回合=totalGold;
			新药水.自定义数据.set("基础持续时间",原基础持续+延长回合);
			新药水.效果描述=(新药水.效果描述||"").replace(/持续\s*\d+\s*回合/g,`持续 ${新药水.持续时间} 回合`);
			新药水.唯一标识=Symbol("FusionPotionExtendPreview_"+Date.now());
			融合结果=新药水;
			当前匹配的融合配方="药水金币延长";
			
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			        }
			    }
			
			    const combinedRecipeList=[...已发现的程序生成配方,...融合配方列表,];
			
			    for(const 配方 of combinedRecipeList){
			        const sortedRecipeInputs=[...配方.输入].sort();
			        if(融合槽物品名称列表_sorted.length===sortedRecipeInputs.length&&
			融合槽物品名称列表_sorted.every((name,index)=>name===sortedRecipeInputs[index])){
			const 输出类构造器=window[配方.输出类];
			if(输出类构造器){
			    const 输出配置=配方.输出配置?{...配方.输出配置}:{};
			    const 输入物品是否有不可破坏=融合槽物品实例列表.some(item=>item.自定义数据?.get("不可破坏"));
			    融合结果=new 输出类构造器(输出配置);
			    融合结果.堆叠数量=配方.输出数量||1;
			    融合结果.唯一标识=Symbol("FusionRecipePreview_"+Date.now());
			    if(输入物品是否有不可破坏){
			        融合结果.自定义数据.set("不可破坏",true);
			    }
			    当前匹配的融合配方=配方;
			    const 预览元素=融合结果.生成显示元素("融合");
			    预览元素.style.cursor="pointer";
			    输出格子.appendChild(预览元素);
			    输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			    return;
			}
			        }
			    }
			
			    if(融合槽有效条目.length===2){
			        const item1=融合槽有效条目[0].item;
			        const item2=融合槽有效条目[1].item;
			        if(item1&&item2&&item1.名称===item2.名称&&
			(item1 instanceof 武器类||item1 instanceof 防御装备类)&&
			(item2 instanceof 武器类||item2 instanceof 防御装备类)&&
			item1.constructor.name===item2.constructor.name){
			
			融合结果=克隆物品(item1);
			融合结果.唯一标识=Symbol("FusionEquipPreview_"+Date.now());
			当前匹配的融合配方="装备融合";
			const mergedBuffs=合并Buff列表(item1.自定义数据.get("fusedBuffs"),item2.自定义数据.get("fusedBuffs"));
			if(mergedBuffs.length>0)
			    融合结果.自定义数据.set("fusedBuffs",mergedBuffs);
			else 融合结果.自定义数据.delete("fusedBuffs");
			const mergedEnchantments=合并附魔列表(item1.自定义数据.get("附魔"),item2.自定义数据.get("附魔"));
			融合结果.自定义数据.set("附魔",mergedEnchantments);
			const item1Dur=item1.自定义数据.get("耐久")||0;
			const item1MaxDur=item1.自定义数据.get("原耐久")||item1Dur;
			const item2Dur=item2.自定义数据.get("耐久")||0;
			const item2MaxDur=item2.自定义数据.get("原耐久")||item2Dur;
			const newMaxDur=item1MaxDur+Math.floor(item2MaxDur*0.3);
			const newCurrDur=Math.min(newMaxDur,item1Dur+Math.floor(item2Dur*0.7));
			融合结果.自定义数据.set("耐久",newCurrDur);
			融合结果.自定义数据.set("原耐久",newMaxDur);
			融合结果.强化=item1.强化||item2.强化;
			if(item1.自定义数据.get("不可破坏")||item2.自定义数据.get("不可破坏")){
			    融合结果.自定义数据.set("不可破坏",true);
			}else{
			    融合结果.自定义数据.delete("不可破坏");
			}
			
			融合结果.品质=Math.max(item1.品质,item2.品质);
			融合结果.颜色索引=融合结果.品质-1;
			
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			        }
			    }
			
			    const 武器槽实例=融合区物品[0];
			    if(武器槽实例&&是否为有效融合武器(武器槽实例)){
			        const 材料实例列表=[];
			        let 金币总量=0;
			
			        for(let i=1;i<4;i++){
			const 物品=融合区物品[i];
			if(物品){
			    if(物品 instanceof 金币){
			        金币总量+=fusionGoldQuantities[i];
			    }else if(是否为有效融合材料(物品)){
			        材料实例列表.push(物品);
			    }
			}
			        }
			
			        if(材料实例列表.length>0||金币总量>0){
			const buffs=计算融合Buff(武器槽实例,材料实例列表,金币总量);
			融合结果=克隆物品(武器槽实例);
			融合结果.唯一标识=Symbol("FusionBuffPreview_"+Date.now());
			当前匹配的融合配方="词条融合";
			const 输入物品是否有不可破坏=[武器槽实例,...材料实例列表].some(item=>item.自定义数据?.get("不可破坏"));
			if(输入物品是否有不可破坏){
			    融合结果.自定义数据.set("不可破坏",true);
			}
			
			if(buffs.length>0){
			    融合结果.自定义数据.set("fusedBuffs",buffs);
			}else{
			    融合结果.自定义数据.delete("fusedBuffs");
			}
			
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			        }
			        
			    }
			    if (融合区物品[0] && 融合区物品[1] && 融合区物品[0].材质 === 材料.木质 && 融合区物品[1] instanceof 药水类){
			        当前匹配的融合配方="木材转化融合";
			        融合结果=克隆物品(融合区物品[0]);
			融合结果.唯一标识=Symbol("MaterialChangePreview_"+Date.now());
			融合结果.材质=材料.普通;
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			    }
			}
			
			function 更新融合窗口() {
			    const 窗口 = document.getElementById("融合窗口");
			    if (!窗口) return;
			
			    for (let i = 1; i <= 4; i++) {
			        const 格子 = document.getElementById(`融合区格子${i}`);
			        格子.innerHTML = "";
			        格子.onclick = () =>
			            setTimeout(() => {
			                从融合区移除(i - 1);
			            }, 0);
			    }
			
			    融合区物品.forEach((物品实例, index) => {
			        if (物品实例 !== null) {
			            const 格子 = document.getElementById(
			                `融合区格子${index + 1}`
			            );
			            const 物品元素 = 物品实例.生成显示元素("融合");
			            物品元素.style.cursor = "pointer";
			
			            if (物品实例 instanceof 金币) {
			                let 堆叠元素 = 物品元素.querySelector(".物品堆叠");
			                if (!堆叠元素) {
			                    堆叠元素 = document.createElement("div");
			                    堆叠元素.className = "物品堆叠";
			                    物品元素.appendChild(堆叠元素);
			                }
			                堆叠元素.textContent = `x${fusionGoldQuantities[index]}`;
			            } else {
			                 const 堆叠元素 = 物品元素.querySelector(".物品堆叠");
			                 if (堆叠元素) 堆叠元素.remove();
			            }
			            
			            格子.appendChild(物品元素);
			        }
			    });
			
			    const 输出格子 = document.getElementById("融合输出格子");
			    输出格子.innerHTML = "";
			    输出格子.onclick = null;
			    if (融合结果) {
			        const 结果元素 = 融合结果.生成显示元素("融合");
			        结果元素.style.cursor = "pointer";
			        输出格子.appendChild(结果元素);
			        输出格子.onclick = () =>
			            setTimeout(() => {
			                执行融合();
			            }, 0);
			    }
			}
			
			function 清空融合区() {
			    for (let i = 0; i < 融合区物品.length; i++) {
			        
			        if (
			            融合区物品[i] !== null &&
			            玩家背包.get(融合区物品[i]) instanceof 金币
			        ) {
			            const goldToReturn = fusionGoldQuantities[i];
			            if (goldToReturn > 0) {
			                尝试收集物品(
			                    new 金币({ 数量: goldToReturn }),
			                    true
			                );
			            }
			            玩家背包.get(融合区物品[i]).是否隐藏 = false;
			            fusionGoldQuantities[i] = 0;
			            融合区物品[i] = null;
			        } else if (融合区物品[i] !== null) {
			            从融合区移除(i); 
			        }
			    }
			    融合结果 = null;
			    更新融合窗口();
			    更新背包显示(); 
			}
			
			let 已发现的程序生成配方 = [];
			let 程序生成配方列表 = [];
			function 生成单个随机融合配方(层数) {
			    const MAX_ATTEMPTS = 50;
			    for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
			        const numInputs = Math.round(prng() * 0.7) + 2; 
			        const inputs = [];
			        const inputItemNames = [];
			
			        const 可用物品池 = Object.values(物品池)
			            .flat()
			            .filter(
			                (itemCfg) =>
			                    itemCfg.最小层 <= 层数 &&
			                    itemCfg.类.name !== "配方卷轴" &&
			                    itemCfg.类.name !== "神秘商人" &&
			                    itemCfg.类.name !== "探险家" &&
			                    itemCfg.类.name !== "物品祭坛" &&
			                    itemCfg.类.name !== "耐久祭坛" &&
			                    itemCfg.类.name !== "背包扩容祭坛" &&
			                    itemCfg.类.name !== "重铸台" &&
			                    itemCfg.类.name !== "折跃门" &&
			                    itemCfg.类.name !== "寻宝戒指" &&
			                    itemCfg.类.name !== "罐子" &&
			                    itemCfg.类.name !== "洗身砚" &&
			                    itemCfg.类.name !== "神龛" &&
			                    itemCfg.类.name !== "挑战石碑"
			            );
			
			        if (
			            可用物品池.length < numInputs &&
			            !(
			                numInputs === 2 &&
			                可用物品池.length === 1 &&
			                prng() < 0.5
			            )
			        )
			            continue; 
			
			        let canUseSpecial = true; 
			        for (let i = 0; i < numInputs; i++) {
			            let selectedItemConfig;
			            if (canUseSpecial && prng() < 0.3) {
			                
			                if (prng() < 0.7 && 层数 >= 0) {
			                    
			                    selectedItemConfig = {
			                        类: 金币,
			                        name: "金币",
			                        isSpecial: true,
			                        品质: 1,
			                    };
			                } else if (层数 >= 1) {
			                    
			                    selectedItemConfig = {
			                        类: 钥匙,
			                        name: "钥匙",
			                        isSpecial: true,
			                        品质: 1,
			                    };
			                } else if (可用物品池.length > 0) {
			                    selectedItemConfig =
			                        可用物品池[
			                            Math.floor(
			                                prng() * 可用物品池.length
			                            )
			                        ];
			                } else {
			                    continue; 
			                }
			                if (selectedItemConfig.isSpecial)
			                    canUseSpecial = false; 
			            } else if (可用物品池.length > 0) {
			                selectedItemConfig =
			                    可用物品池[
			                        Math.floor(
			                            prng() * 可用物品池.length
			                        )
			                    ];
			            } else {
			                break; 
			            }
			
			            if (selectedItemConfig) {
			                const tempInstance = new selectedItemConfig.类({});
			                inputs.push(tempInstance.名称); 
			                inputItemNames.push(tempInstance.名称);
			            }
			        }
			
			        if (inputs.length !== numInputs) continue; 
			
			        
			        const outputPool = 可用物品池.filter(
			            (itemCfg) =>
			                (!inputItemNames.includes(
			                    new itemCfg.类({}).名称
			                ) && 
			                    itemCfg.品质 >
			                        Math.min(
			                            ...inputs.map(
			                                (name) =>
			                                    (
			                                        可用物品池.find(
			                                            (cfg) =>
			                                                new cfg.类({})
			                                                    .名称 === name
			                                        ) || { 品质: 1 }
			                                    ).品质
			                            )
			                        ))
			        );
			
			        if (outputPool.length === 0) continue;
			        const outputItemConfig =
			            outputPool[
			                Math.floor(prng() * outputPool.length)
			            ];
			        const outputInstance = new outputItemConfig.类({});
			
			        const recipe = {
			            输入: inputs.sort(),
			            输出类: outputItemConfig.类.name,
			            输出类名称: outputInstance.名称,
			            输出数量: 1,
			            输出配置: {
			                品质: outputInstance.品质,
			                强化: true,
			            },
			            说明: `${inputItemNames.join(" + ")} = ${
			                outputInstance.名称
			            }[强]`,
			            发现层数: 层数,
			        };
			
			        
			        const existingRecipe = 程序生成配方列表.find(
			            (r) =>
			                r.输出类名称 === recipe.输出类名称 &&
			                r.输入.length === recipe.输入.length &&
			                r.输入.every(
			                    (val, index) => val === recipe.输入[index]
			                )
			        );
			        const existingHardcodedRecipe = 融合配方列表.find(
			            (r) =>
			                (r.输出类名称 || r.输出类) === recipe.输出类名称 &&
			                r.输入.length === recipe.输入.length &&
			                r.输入.every(
			                    (val, index) => val === recipe.输入[index]
			                )
			        );
			
			        if (!existingRecipe && !existingHardcodedRecipe) {
			            程序生成配方列表.push(recipe);
			            return recipe;
			        }
			    }
			    return null;
			}
			
			function 生成并放置随机配方卷轴(层数) {
			    if (层数 === null || 层数 < 0 || 是否为教程层) {
			        return;
			    }

			    
			    const 卷轴数量 = 1 + Math.floor(prng() * 层数);
			    let 成功放置数量 = 0;

			    for (let i = 0; i < 卷轴数量; i++) {
			        
			        const 新配方 = 生成单个随机融合配方(层数);

			        if (新配方) {
			            console.log(`为第 ${层数} 层生成了新的配方知识: ${新配方.说明}`);

			            const 配方物品 = new 配方卷轴({
			                recipeData: 新配方,
			                层数: 层数,
			            });

			            
			            const 可用房间 = 房间列表.filter(
			                (房间) => 房间.类型 === "房间" && !上锁房间列表.some(r => r.id === 房间.id)
			            );

			            if (可用房间.length > 0) {
			                
			                const 目标房间 = 可用房间[Math.floor(prng() * 可用房间.length)];
			                if (放置物品到房间(配方物品, 目标房间)) {
			                    成功放置数量++;
			                } else {
			                    console.warn(`无法在房间 ${目标房间.id} 为配方 "${新配方.说明}" 找到放置位置。`);
			                }
			            } else {
			                console.warn("没有找到合适的房间来放置配方卷轴。");
			            }
			        }
			    }

			    if (成功放置数量 > 0) {
			        console.log(`在第 ${层数} 层成功放置了 ${成功放置数量} 个配方卷轴。`);
			    }
			}
			
			function 合并Buff列表(list1, list2) {
			    const merged = new Map();
			
			    function addOrUpdateBuff(buff) {
			        const existing = merged.get(buff.type);
			        if (existing) {
			            if (
			                typeof existing.value === "number" &&
			                typeof buff.value === "number"
			            ) {
			                existing.value += buff.value;
			                let 上限 = 1.0;
			                if (
			                    buff.type.includes("MULTIPLIER") ||
			                    buff.type.includes("CHANCE") ||
			                    buff.type.includes("STEAL") ||
			                    buff.type.includes("PERCENT")
			                ) {
			                    上限 =
			                        {
			                            [融合Buff类型.攻击倍率]: 0.75,
			                            [融合Buff类型.冷却倍率]: 0.9,
			                            [融合Buff类型.耐久倍率]: 1.5,
			                            [融合Buff类型.防御倍率]: 0.75,
			                            [融合Buff类型.中毒几率]: 0.8,
			                            [融合Buff类型.冰冻几率]: 0.8,
			                            [融合Buff类型.生命偷取]: 0.7,
			                            [融合Buff类型.击退几率]: 0.8,
			                            [融合Buff类型.攻击吸能]: 0.7,
			                            [融合Buff类型.火焰伤害]: 0.8,
			                            [融合Buff类型.闪避几率]: 0.7,
			                            [融合Buff类型.暴击几率]: 0.6,
			                            [融合Buff类型.暴击伤害倍率]: 2.5,
			                        }[buff.type] || 1.0;
			                    existing.value = Math.min(existing.value, 上限);
			                } else if (buff.type === 融合Buff类型.冷却缩减) {
			                    
			                    上限 = 5;
			                    existing.value = Math.max(
			                        0,
			                        Math.min(existing.value, 上限)
			                    );
			                } else if (
			                    buff.type === 融合Buff类型.固定伤害减免
			                ) {
			                    上限 = 10;
			                    existing.value = Math.min(existing.value, 上限);
			                } else if (buff.type === 融合Buff类型.受击回能) {
			                    上限 = 30;
			                    existing.value = Math.min(existing.value, 上限);
			                } else if (buff.type === 融合Buff类型.范围加成) {
			                    上限 = 5;
			                    existing.value = Math.min(existing.value, 上限);
			                } else if (buff.type.includes("加成")) {
			                    existing.value = Math.min(existing.value, 15);
			                }
			            }
			        } else {
			            merged.set(buff.type, { ...buff });
			        }
			    }
			
			    (list1 || []).forEach(addOrUpdateBuff);
			    (list2 || []).forEach(addOrUpdateBuff);
			
			    return Array.from(merged.values());
			}
			
			function 合并附魔列表(list1, list2) {
			    const merged = new Map();
			
			    function addOrUpdateEnchantment(enchant) {
			        const existing = merged.get(enchant.种类);
			        if (existing) {
			            if (enchant.等级 > existing.等级) {
			                merged.set(enchant.种类, { ...enchant });
			            }
			        } else {
			            merged.set(enchant.种类, { ...enchant });
			        }
			    }
			    (list1 || []).forEach(addOrUpdateEnchantment);
			    (list2 || []).forEach(addOrUpdateEnchantment);
			    return Array.from(merged.values());
			}
			
			function 哈希字符串(str) {
			    let hash = 0;
			    if (!str || str.length === 0) return hash;
			    for (let i = 0; i < str.length; i++) {
			        const char = str.charCodeAt(i);
			        hash = (hash << 5) - hash + char;
			        hash |= 0;
			    }
			    return Math.abs(hash);
			}
			
			function 种子伪随机数(seed) {
			    let t = (seed += 0x6d2b79f5);
			    t = Math.imul(t ^ (t >>> 15), t | 1);
			    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
			    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
			}
			
			function 是否为有效融合武器(物品) {
			    return 物品 instanceof 武器类 || 物品 instanceof 防御装备类;
			}
			
			function 是否为有效融合材料(物品) {
			    return (
			        物品 instanceof 炸弹 ||
			        物品 instanceof 卷轴类 ||
			        物品.类型 === "药水" ||
			        物品 instanceof 钥匙
			    );
			}
			
			function 计算融合Buff(武器, 材料列表, 金币数量) {
			    if (!武器) return [];
			
			    const 基础种子字符串 = 武器.唯一标识.toString()+材料列表?.[0]?.实际唯一标识?.toString();
			    let 组合种子字符串 = 基础种子字符串;
			    const 有效材料 = 材料列表.filter((m) => m != null);
			    if (有效材料.length === 0 && 金币数量 === 0) return [];
			
			    有效材料.sort((a, b) =>
			        a.constructor.name.localeCompare(b.constructor.name)
			    );
			    有效材料.forEach(
			        (mat) => (组合种子字符串 += mat.constructor.name)
			    );
			    组合种子字符串 += 金币数量;
			
			    const 组合种子 = 哈希字符串(组合种子字符串);
			    const 最终Buff列表 = [];
			    const 金币增幅系数 =
			        1 + Math.log10(Math.max(1, (金币数量 || 0) / 2 + 1)) * 0.45;
			
			    const 是否武器 = 武器 instanceof 武器类;
			    const 是否防具 = 武器 instanceof 防御装备类;
			
			    有效材料.forEach((材料, 索引) => {
			        const 材料种子 = 哈希字符串(
			            组合种子字符串 + 索引 + 最终Buff列表.length
			        );
			        const 随机数生成 = () =>
			            种子伪随机数(材料种子 + 最终Buff列表.length);
			
			        let buff类型 = null;
			        let buff数值 = 0;
			        const 可能的Buff列表 = [];
			
			        if (材料 instanceof 炸弹) {
			            if (是否武器)
			                可能的Buff列表.push(
			                    融合Buff类型.攻击加成,
			                    融合Buff类型.火焰伤害,
			                    融合Buff类型.暴击几率,
			                    融合Buff类型.击退几率
			                );
			            if (是否防具)
			                可能的Buff列表.push(
			                    融合Buff类型.防御加成,
			                    融合Buff类型.固定伤害减免,
			                    融合Buff类型.火焰伤害
			                );
			            可能的Buff列表.push(融合Buff类型.耐久加成);
			        } else if (材料 instanceof 卷轴类) {
			            if (是否武器)
			                可能的Buff列表.push(
			                    融合Buff类型.冷却缩减,
			                    融合Buff类型.范围加成,
			                    融合Buff类型.攻击倍率,
			                    融合Buff类型.攻击吸能,
			                    融合Buff类型.暴击伤害倍率
			                );
			            if (是否防具)
			                可能的Buff列表.push(
			                    融合Buff类型.防御倍率,
			                    融合Buff类型.闪避几率,
			                    融合Buff类型.受击回能,
			                    融合Buff类型.中毒几率
			                );
			            可能的Buff列表.push(
			                融合Buff类型.冰冻几率,
			                融合Buff类型.耐久倍率
			            );
			        } else if (材料.类型 === "药水") {
			            if (是否武器)
			                可能的Buff列表.push(
			                    融合Buff类型.生命偷取,
			                    融合Buff类型.中毒几率,
			                    融合Buff类型.暴击伤害倍率,
			                    融合Buff类型.攻击吸能
			                );
			            if (是否防具)
			                可能的Buff列表.push(
			                    融合Buff类型.防御加成,
			                    融合Buff类型.受击回能,
			                    融合Buff类型.中毒几率
			                );
			            可能的Buff列表.push(融合Buff类型.耐久加成);
			        } else if (材料 instanceof 钥匙) {
			            if (是否武器) {
			                可能的Buff列表.push(融合Buff类型.幸运一击);
			                可能的Buff列表.push(融合Buff类型.暴击几率);
			            }
			            可能的Buff列表.push(融合Buff类型.耐久加成);
			        }
			
			        if (可能的Buff列表.length === 0) return;
			
			        buff类型 =
			            可能的Buff列表[
			                Math.floor(随机数生成() * 可能的Buff列表.length)
			            ];
			
			        switch (buff类型) {
			            case 融合Buff类型.攻击加成:
			                buff数值 = Math.round(
			                    (1 + 随机数生成() * 3) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.攻击倍率:
			                buff数值 = Math.min(
			                    0.3,
			                    (0.03 + 随机数生成() * 0.12) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.冷却缩减:
			                buff数值 = Math.round(
			                    (1 + 随机数生成() * 1) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.冷却倍率:
			                buff数值 = Math.min(
			                    0.5,
			                    (0.05 + 随机数生成() * 0.15) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.耐久加成:
			                if (材料 instanceof 钥匙) {
			                    buff数值 = Math.round(
			                        (2 +
			                            随机数生成() * 5 +
			                            (金币数量 > 0 ? 金币数量 / 5 : 0)) *
			                            金币增幅系数 *
			                            0.8
			                    );
			                } else {
			                    buff数值 = Math.round(
			                        (5 + 随机数生成() * 20) * 金币增幅系数
			                    );
			                }
			                break;
			            case 融合Buff类型.耐久倍率:
			                buff数值 = Math.min(
			                    1.5,
			                    (0.1 + 随机数生成() * 0.25) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.范围加成:
			                buff数值 =
			                    是否武器 &&
			                    武器.自定义数据.has("攻击范围") &&
			                    武器.自定义数据.get("攻击范围") > 1 &&
			                    随机数生成() < 0.7
			                        ? Math.round(1 * 金币增幅系数)
			                        : 0;
			                break;
			            case 融合Buff类型.防御加成:
			                buff数值 = Math.round(
			                    (1 + 随机数生成() * 2) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.防御倍率:
			                buff数值 = Math.min(
			                    0.3,
			                    (0.05 + 随机数生成() * 0.1) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.中毒几率:
			            case 融合Buff类型.冰冻几率:
			            case 融合Buff类型.生命偷取:
			            case 融合Buff类型.击退几率:
			            case 融合Buff类型.攻击吸能:
			            case 融合Buff类型.火焰伤害:
			            case 融合Buff类型.闪避几率:
			                buff数值 = Math.min(
			                    0.4,
			                    (0.05 + 随机数生成() * 0.2) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.暴击几率:
			                if (材料 instanceof 钥匙) {
			                    let 基础值 = 0.025;
			                    let 品质加成 = 材料.品质 * 0.018;
			                    let 金币效应 =
			                        金币数量 > 10
			                            ? 0.025
			                            : 金币数量 > 0
			                            ? 0.012
			                            : 0;
			                    buff数值 = Math.min(
			                        0.22,
			                        (基础值 + 品质加成 + 金币效应) *
			                            金币增幅系数
			                    );
			                } else {
			                    buff数值 = Math.min(
			                        0.25,
			                        (0.03 + 随机数生成() * 0.1) * 金币增幅系数
			                    );
			                }
			                break;
			            case 融合Buff类型.暴击伤害倍率:
			                buff数值 = Math.min(
			                    1.0,
			                    (0.1 + 随机数生成() * 0.4) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.固定伤害减免:
			                buff数值 = Math.round(
			                    (1 + 随机数生成() * 1) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.受击回能:
			                buff数值 = Math.round(
			                    (3 + 随机数生成() * 7) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.幸运一击:
			                if (材料 instanceof 钥匙) {
			                    let 基础值 = 0.035;
			                    let 品质加成 = 材料.品质 * 0.022;
			                    let 金币效应 =
			                        金币数量 > 10
			                            ? 0.03
			                            : 金币数量 > 0
			                            ? 0.018
			                            : 0;
			                    buff数值 = Math.min(
			                        0.28,
			                        (基础值 + 品质加成 + 金币效应) *
			                            金币增幅系数
			                    );
			                } else {
			                    buff数值 = Math.min(
			                        0.25,
			                        (0.02 +
			                            材料.品质 * 0.015 +
			                            (武器.品质 - 1) * 0.01) *
			                            金币增幅系数
			                    );
			                }
			                break;
			            default:
			                buff数值 = 0;
			        }
			
			        if (
			            buff数值 !== null &&
			            buff数值 !== undefined &&
			            !isNaN(buff数值) &&
			            Math.abs(buff数值) > 0.001
			        ) {
			            const 已存在Buff索引 = 最终Buff列表.findIndex(
			                (b) => b.type === buff类型
			            );
			            if (已存在Buff索引 > -1) {
			                if (
			                    typeof 最终Buff列表[已存在Buff索引].value ===
			                        "number" &&
			                    typeof buff数值 === "number"
			                ) {
			                    最终Buff列表[已存在Buff索引].value += buff数值;
			                    let 上限 = 1.0;
			                    if (
			                        buff类型.includes("MULTIPLIER") ||
			                        buff类型.includes("CHANCE") ||
			                        buff类型.includes("STEAL") ||
			                        buff类型.includes("PERCENT")
			                    ) {
			                        上限 =
			                            {
			                                [融合Buff类型.攻击倍率]: 0.75,
			                                [融合Buff类型.冷却倍率]: 0.9,
			                                [融合Buff类型.耐久倍率]: 1.5,
			                                [融合Buff类型.防御倍率]: 0.75,
			                                [融合Buff类型.中毒几率]: 0.8,
			                                [融合Buff类型.冰冻几率]: 0.8,
			                                [融合Buff类型.生命偷取]: 0.7,
			                                [融合Buff类型.击退几率]: 0.8,
			                                [融合Buff类型.攻击吸能]: 0.7,
			                                [融合Buff类型.火焰伤害]: 0.8,
			                                [融合Buff类型.闪避几率]: 0.7,
			                                [融合Buff类型.暴击几率]: 0.6,
			                                [融合Buff类型.暴击伤害倍率]: 2.5,
			                            }[buff类型] || 1.0;
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                上限
			                            );
			                    } else if (buff类型 === 融合Buff类型.冷却缩减) {
			                        
			                        上限 = 5;
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.max(
			                                0,
			                                Math.min(
			                                    最终Buff列表[已存在Buff索引]
			                                        .value,
			                                    上限
			                                )
			                            );
			                    } else if (
			                        buff类型 === 融合Buff类型.固定伤害减免
			                    ) {
			                        上限 = 10;
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                上限
			                            );
			                    } else if (buff类型 === 融合Buff类型.受击回能) {
			                        上限 = 30;
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                上限
			                            );
			                    } else if (
			                        buff类型 === 融合Buff类型.范围加成 &&
			                        武器.自定义数据.has("攻击范围")
			                    ) {
			                        上限 = Math.floor(
			                            武器.自定义数据.get("攻击范围") * 0.5
			                        );
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                上限
			                            );
			                    } else if (buff类型.includes("加成")) {
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                15
			                            );
			                    }
			                }
			            } else {
			                最终Buff列表.push({
			                    type: buff类型,
			                    value: buff数值,
			                });
			            }
			        }
			    });
			
			    if (有效材料.length === 0 && 金币数量 >= 10) {
			        const 金币随机数 = 种子伪随机数(组合种子 + 1);
			        if (
			            金币随机数 <
			            (0.45 + Math.log10(金币数量 / 5 + 1) * 0.1) *
			                金币增幅系数
			        ) {
			            let 所有可能Buff_gold;
			            if (是否武器) {
			                所有可能Buff_gold = [
			                    融合Buff类型.攻击加成,
			                    融合Buff类型.攻击倍率,
			                    融合Buff类型.冷却缩减,
			                    融合Buff类型.耐久加成,
			                    融合Buff类型.暴击几率,
			                    融合Buff类型.范围加成,
			                    融合Buff类型.中毒几率,
			                    融合Buff类型.冰冻几率,
			                    融合Buff类型.火焰伤害,
			                    融合Buff类型.幸运一击,
			                ];
			            } else if (是否防具) {
			                所有可能Buff_gold = [
			                    融合Buff类型.防御加成,
			                    融合Buff类型.防御倍率,
			                    融合Buff类型.耐久加成,
			                    融合Buff类型.闪避几率,
			                    融合Buff类型.固定伤害减免,
			                    融合Buff类型.受击回能,
			                    融合Buff类型.中毒几率,
			                ];
			            } else {
			                所有可能Buff_gold = [融合Buff类型.耐久加成];
			            }
			
			            const 随机Buff类型 =
			                所有可能Buff_gold[
			                    Math.floor(
			                        种子伪随机数(组合种子 + 2) *
			                            所有可能Buff_gold.length
			                    )
			                ];
			            let 随机Buff数值 = 0;
			            switch (随机Buff类型) {
			                case 融合Buff类型.攻击加成:
			                    随机Buff数值 = Math.round(
			                        (1 + 种子伪随机数(组合种子 + 3) * 1.5) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.攻击倍率:
			                    随机Buff数值 = Math.min(
			                        0.1,
			                        (0.01 + 种子伪随机数(组合种子 + 4) * 0.04) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.冷却缩减:
			                    随机Buff数值 = Math.round(
			                        种子伪随机数(组合种子 + 5) *
			                            1 *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.耐久加成:
			                    随机Buff数值 = Math.round(
			                        (5 + 种子伪随机数(组合种子 + 6) * 15) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.防御加成:
			                    随机Buff数值 = Math.round(
			                        (1 + 种子伪随机数(组合种子 + 7) * 1) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.防御倍率:
			                    随机Buff数值 = Math.min(
			                        0.15,
			                        (0.02 + 种子伪随机数(组合种子 + 8) * 0.05) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.暴击几率:
			                    随机Buff数值 = Math.min(
			                        0.08,
			                        (0.01 +
			                            种子伪随机数(组合种子 + 9) * 0.025) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.范围加成:
			                    if (
			                        是否武器 &&
			                        武器.自定义数据.has("攻击范围") &&
			                        武器.自定义数据.get("攻击范围") > 1
			                    )
			                        随机Buff数值 = Math.round(1 * 金币增幅系数);
			                    else 随机Buff数值 = 0;
			                    break;
			                case 融合Buff类型.闪避几率:
			                    随机Buff数值 = Math.min(
			                        0.05,
			                        (0.01 +
			                            种子伪随机数(组合种子 + 10) * 0.02) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.固定伤害减免:
			                    随机Buff数值 = Math.round(
			                        种子伪随机数(组合种子 + 11) *
			                            1 *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.受击回能:
			                    随机Buff数值 = Math.round(
			                        (2 + 种子伪随机数(组合种子 + 12) * 5) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.中毒几率:
			                    随机Buff数值 = Math.min(
			                        0.15,
			                        (0.02 +
			                            种子伪随机数(组合种子 + 13) * 0.05) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.冰冻几率:
			                    随机Buff数值 = Math.min(
			                        0.15,
			                        (0.02 +
			                            种子伪随机数(组合种子 + 14) * 0.05) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.火焰伤害:
			                    随机Buff数值 = Math.min(
			                        0.15,
			                        (0.02 +
			                            种子伪随机数(组合种子 + 15) * 0.05) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.幸运一击:
			                    随机Buff数值 = Math.min(
			                        0.12,
			                        (0.015 +
			                            种子伪随机数(组合种子 + 16) * 0.035) *
			                            金币增幅系数
			                    );
			                    break;
			                default:
			                    随机Buff数值 = 0;
			                    break;
			            }
			            if (随机Buff数值 > 0.001 && 随机Buff类型) {
			                const 已存在Buff索引_gold = 最终Buff列表.findIndex(
			                    (b) => b.type === 随机Buff类型
			                );
			                if (已存在Buff索引_gold > -1) {
			                    最终Buff列表[已存在Buff索引_gold].value +=
			                        随机Buff数值;
			                    let 上限 = 1.0;
			                    if (
			                        随机Buff类型.includes("MULTIPLIER") ||
			                        随机Buff类型.includes("CHANCE") ||
			                        随机Buff类型.includes("STEAL") ||
			                        随机Buff类型.includes("PERCENT")
			                    ) {
			                        上限 =
			                            {
			                                [融合Buff类型.攻击倍率]: 0.5,
			                                [融合Buff类型.冷却倍率]: 0.75,
			                                [融合Buff类型.耐久倍率]: 1.0,
			                                [融合Buff类型.防御倍率]: 0.5,
			                                [融合Buff类型.中毒几率]: 0.6,
			                                [融合Buff类型.冰冻几率]: 0.6,
			                                [融合Buff类型.生命偷取]: 0.5,
			                                [融合Buff类型.击退几率]: 0.6,
			                                [融合Buff类型.攻击吸能]: 0.5,
			                                [融合Buff类型.火焰伤害]: 0.6,
			                                [融合Buff类型.闪避几率]: 0.5,
			                                [融合Buff类型.暴击几率]: 0.4,
			                                [融合Buff类型.暴击伤害倍率]: 1.5,
			                                [融合Buff类型.幸运一击]: 0.3,
			                            }[随机Buff类型] || 1.0;
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                上限
			                            );
			                    } else if (
			                        随机Buff类型 === 融合Buff类型.冷却缩减
			                    ) {
			                        const 武器基础冷却 =
			                            武器.自定义数据.get("冷却回合") || 1;
			                        上限 =
			                            武器基础冷却 > 0 ? 武器基础冷却 - 1 : 0;
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.max(
			                                0,
			                                Math.min(
			                                    最终Buff列表[
			                                        已存在Buff索引_gold
			                                    ].value,
			                                    上限
			                                )
			                            );
			                        上限 = 99999;
			                    } else if (
			                        随机Buff类型 === 融合Buff类型.固定伤害减免
			                    ) {
			                        上限 = 5;
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                上限
			                            );
			                    } else if (
			                        随机Buff类型 === 融合Buff类型.受击回能
			                    ) {
			                        上限 = 20;
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                上限
			                            );
			                    } else if (
			                        随机Buff类型 === 融合Buff类型.范围加成 &&
			                        武器.自定义数据.has("攻击范围")
			                    ) {
			                        上限 = Math.floor(
			                            武器.自定义数据.get("攻击范围") * 0.5
			                        );
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                上限
			                            );
			                    } else if (随机Buff类型.includes("加成")) {
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                15
			                            );
			                    }
			                } else {
			                    最终Buff列表.push({
			                        type: 随机Buff类型,
			                        value: 随机Buff数值,
			                    });
			                }
			            }
			        }
			    }
			
			    let buffMaterialCount = 0;
			    有效材料.forEach((mat) => {
			        if (
			            mat instanceof 卷轴类 ||
			            mat.类型 === "药水" ||
			            mat instanceof 钥匙
			        ) {
			            buffMaterialCount++;
			        }
			    });
			
			    if (有效材料.some(m => m instanceof 药水类)) {
			        if (武器.材质 === 材料.木质) {
			            最终Buff列表.push({ type: 'MATERIAL_CHANGE', value: 材料.普通 });
			        } else if (武器.材质 === 材料.铁质) {
			            最终Buff列表.push({ type: 'RUST_INCREASE', value: Math.round(武器.攻击力*0.5) });
			        }
			    }
			    if (buffMaterialCount >= 2) {
			        const synergySeed = 哈希字符串(
			            组合种子字符串 + "Synergy" + 最终Buff列表.length
			        );
			        let synergyValue = 0;
			        if (是否武器) {
			            synergyValue = Math.round(
			                (1 + 种子伪随机数(synergySeed) * 1) * 金币增幅系数
			            );
			        } else if (是否防具) {
			            synergyValue = Math.round(
			                (1 + 种子伪随机数(synergySeed) * 0.5) * 金币增幅系数
			            );
			        }
			        if (synergyValue > 0) {
			            const existingSynergy = 最终Buff列表.find(
			                (b) => b.type === 融合Buff类型.协同效应
			            );
			            if (existingSynergy) {
			                existingSynergy.value += synergyValue;
			                if (是否武器)
			                    existingSynergy.value = Math.min(
			                        existingSynergy.value,
			                        3
			                    );
			                if (是否防具)
			                    existingSynergy.value = Math.min(
			                        existingSynergy.value,
			                        2
			                    );
			            } else {
			                最终Buff列表.push({
			                    type: 融合Buff类型.协同效应,
			                    value: synergyValue,
			                });
			            }
			        }
			    }
			    return 最终Buff列表;
			}
			
			function 格式化Buff提示(buff) {
			    const 格式化数值 = (类型, 数值) => {
			        if (
			            类型.includes("MULTIPLIER") ||
			            类型.includes("CHANCE") ||
			            类型.includes("STEAL") ||
			            类型.includes("PERCENT") ||
			            类型 === 融合Buff类型.幸运一击
			        )
			            return `${(数值 * 100).toFixed(1)}%`;
			        if (
			            类型.includes("REDUCTION") &&
			            类型 !== 融合Buff类型.固定伤害减免
			        )
			            return `${数值.toFixed(1)}`;
			        return `+${数值.toFixed(1)}`;
			    };
			    switch (buff.type) {
			        case 融合Buff类型.攻击加成:
			            return `攻击力 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.攻击倍率:
			            return `攻击力 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.冷却缩减:
			            return `冷却 -${格式化数值(buff.type, buff.value)}回合`;
			        case 融合Buff类型.冷却倍率:
			            return `冷却缩减 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.耐久加成:
			            return `最大耐久 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.耐久倍率:
			            return `最大耐久 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.范围加成:
			            return `攻击范围 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.中毒几率:
			            return `附加中毒 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.火焰伤害:
			            return `附加燃烧 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.冰冻几率:
			            return `附加冰冻 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.生命偷取:
			            return `生命偷取 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.防御加成:
			            return `防御力 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.防御倍率:
			            return `防御力 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.暴击几率:
			            return `暴击几率 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.暴击伤害倍率:
			            return `暴击伤害 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.击退几率:
			            return `几率击退 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.攻击吸能:
			            return `攻击吸能 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.闪避几率:
			            return `闪避几率 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.固定伤害减免:
			            return `伤害减免 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.受击回能:
			            return `受击回能 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.幸运一击:
			            return `幸运一击 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.协同效应:
			            return `协同效应 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.磨刀石攻击加成:
			            return `磨刀石强化攻击: +${buff.value.toFixed(0)} (剩余${buff.usesLeft}次)`;
			        case 融合Buff类型.磨刀石冷却缩减:
			            return `磨刀石强化冷却: -${buff.value.toFixed(0)} (剩余${buff.usesLeft}次)`;
			        case 'MATERIAL_CHANGE':
			        case 'RUST_INCREASE':
			            return;
			        default:
			            return `未知强化: ${buff.type}`;
			    }
			}
			
			function 伤害玩家(原始攻击力, 伤害来源 = null) {
			    if (调试无限生命) return;
			    if (地牢[玩家.y]?.[玩家.x]?.关联物品 instanceof 烟雾) {
        添加日志("烟雾保护了你！", "成功");
        return;
    }
			    let 最终攻击力 = 原始攻击力;
			    let 伤害来源文本 =
			        伤害来源 instanceof 怪物
			            ? 伤害来源.类型
			            : 伤害来源 || "未知来源";
			
			    let 闪避成功 = false;
			
			    for (const 装备 of Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null)) {
			        if (装备 instanceof 防御装备类) {
			            const buffs = 装备.自定义数据.get("fusedBuffs") || [];
			            const dodgeBuff = buffs.find(
			                (b) => b.type === 融合Buff类型.闪避几率
			            );
			            if (dodgeBuff && prng() < dodgeBuff.value) {
			                闪避成功 = true;
			                添加日志(
			                    `通过 ${装备.获取名称()} 闪避了来自 ${伤害来源文本} 的攻击！`,
			                    "成功"
			                );
			                break;
			            }
			        }
			    }
			
			    if (闪避成功) {
			        触发HUD显示();
			        return;
			    }
			    let 守卫者减伤比例 = 0;
    Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).forEach((装备) => {
        if (装备 instanceof 守卫者盔甲) {
            守卫者减伤比例 += 装备.强化 ? 0.10 : 0.05;
        }
    });

    守卫者减伤比例 = Math.min(0.85, 守卫者减伤比例);

    if (守卫者减伤比例 > 0) {
        最终攻击力 *= (1 - 守卫者减伤比例);
    }
			
			    Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).  forEach((装备) => {
			            if (最终攻击力 <= 0) return; 
			
			            if (
			                装备 instanceof 宠物 &&
			                !装备.自定义数据.get("休眠中")
			            ) {
			                最终攻击力 = 装备.当玩家被攻击(
			                    最终攻击力,
			                    伤害来源
			                );
			            }
			            if (装备 instanceof 防御装备类) {
			                最终攻击力 = 装备.当被攻击(最终攻击力, 伤害来源);
			            }
			        });
			
			    最终攻击力 = Math.max(0, 最终攻击力 - (玩家属性.防御加成 || 0));
			
			    if (最终攻击力 <= 0 && 原始攻击力 > 0)
			        最终攻击力 = Math.round(prng() * 100) / 100;
			
			    if (最终攻击力 > 0) {
			        玩家总受到伤害 += 最终攻击力;
			        if (isAutoMoving) {
			        moveQueue = [];
			        isAutoMoving = false;
			    }
			    }
			
			    更新装备显示();
			    触发扣血特效();
			
			    const 玩家最大生命值 = 100 + (玩家属性.最大生命值加成 || 0);
			
			    const 生命条 = document.querySelector(".health-bar");
			    const 当前宽度 = parseFloat(生命条.style.width) || 100;
			    let 新宽度 = Math.max(0, 当前宽度 - (最终攻击力 / 玩家最大生命值) * 100);
			    if (游戏状态 === "图鉴" && 最终攻击力 > 0)
			        新宽度 = Math.max(1, 新宽度);
			    生命条.style.width = `${新宽度}%`;
			    更新胜利条件显示();
			
			    if (最终攻击力 > 0) {
			        添加日志(
			            `受到了 ${伤害来源文本} 的伤害！损失了 ${最终攻击力.toFixed(
			                1
			            )} 点血量！`,
			            `警告`
			        );
			    } else if (原始攻击力 > 0) {
			        添加日志(`成功抵挡了来自 ${伤害来源文本} 的攻击！`, `成功`);
			    }
			
			    触发HUD显示();
			    let 实际击退 = false;
			    let 击退后X = 玩家.x,
			        原始X = 玩家.x;
			    let 击退后Y = 玩家.y,
			        原始Y = 玩家.y;
			    if (新宽度 > 0 && 伤害来源 instanceof 怪物 && 游戏设置.受伤时击退) {
			        let dx = 玩家.x - 伤害来源?.x;
			        let dy = 玩家.y - 伤害来源?.y;
			        let 击退DX = 0,
			            击退DY = 0;
			
			        if (Math.abs(dx) > Math.abs(dy))
			            击退DX =
			                Math.sign(dx) ||
			                (dy === 0 ? (prng() < 0.5 ? 1 : -1) : 0);
			        else if (Math.abs(dy) > Math.abs(dx))
			            击退DY =
			                Math.sign(dy) ||
			                (dx === 0 ? (prng() < 0.5 ? 1 : -1) : 0);
			        else if (dx !== 0 && dy !== 0) {
			            if (prng() < 0.5) 击退DX = Math.sign(dx);
			            else 击退DY = Math.sign(dy);
			        }
			        if (击退DX === 0 && 击退DY === 0) {
			            if (prng() < 0.5)
			                击退DX = prng() < 0.5 ? 1 : -1;
			            else 击退DY = prng() < 0.5 ? 1 : -1;
			        }
			
			        if (击退DX !== 0 || 击退DY !== 0) {
			            const 新X = 玩家.x + 击退DX;
			            const 新Y = 玩家.y + 击退DY;
			            if (
			                新X >= 0 &&
			                新X < 地牢大小 &&
			                新Y >= 0 &&
			                新Y < 地牢大小 &&
			                检查移动可行性(玩家.x, 玩家.y, 新X, 新Y) &&
			                ![单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                    地牢[新Y]?.[新X]?.背景类型
			                )
			            ) {
			                const 目标单元格 = 地牢[新Y]?.[新X];
			                const 目标物品 = 目标单元格?.关联物品;
			                const 不可移动类型列表 = ["楼梯"];
			                const 目标不可移动 =
			                    目标物品 &&
			                    (不可移动类型列表.includes(目标物品.类型) ||
			                        目标物品.能否拾起 === false);
			                if (!目标不可移动) {
			                    玩家.x = 新X;
			                    玩家.y = 新Y;
			                    击退后X = 新X;
			                    击退后Y = 新Y;
			                    实际击退 = true;
			                }
			            }
			        }
			    }
			    if (实际击退) {
			        const 触发中断 = 处理玩家着陆效果(
			            原始X,
			            原始Y,
			            击退后X,
			            击退后Y
			        );
			        if (!触发中断) 更新视口();
			    }
			
			    if (新宽度 <= 0) {
			        玩家死亡();
			    }
			}
			function 更新武器冷却() {
			    const 时间加速 = 当前激活卷轴列表.has(Array.from(当前激活卷轴列表).find(item => item instanceof 时间卷轴));
			    const 冷却减少量 = 时间加速 ? 2 : 1;
			
			    玩家背包.forEach((item) => {
			        if ((item.类型 === "武器" || item instanceof 钩索) && item.自定义数据.get("冷却剩余") > 0) {
			            item.自定义数据.set("冷却剩余", Math.max(0, item.自定义数据.get("冷却剩余") - 冷却减少量));
			        }
			    });
			    更新装备显示();
			}
			function 寻找传送带最远可达点(起始X, 起始Y, 向量DX, 向量DY, 力度) {
			    let 最终X = 起始X;
			    let 最终Y = 起始Y;
			
			    for (let i = 1; i <= 力度; i++) {
			        const 下一步X = 起始X + 向量DX * i;
			        const 下一步Y = 起始Y + 向量DY * i;
			
			        if (下一步X < 0 || 下一步X >= 地牢大小 || 下一步Y < 0 || 下一步Y >= 地牢大小) {
			            break;
			        }
			
			        const 上一步X = 起始X + 向量DX * (i - 1);
			        const 上一步Y = 起始Y + 向量DY * (i - 1);
			
			        if (!检查移动可行性(上一步X, 上一步Y, 下一步X, 下一步Y)) {
			            break;
			        }
			
			        const 目标单元格 = 地牢[下一步Y]?.[下一步X];
			        if (!目标单元格 || (目标单元格.关联怪物) || (目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物)) {
			            break;
			        }
			
			        最终X = 下一步X;
			        最终Y = 下一步Y;
			    }
			
			    return { x: 最终X, y: 最终Y };
			}
			function 处理传送带效果() {
			    const 传送带列表 = [];
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			const 物品 = 地牢[y]?.[x]?.关联物品;
			if (物品 instanceof 传送带) {
			    传送带列表.push(物品);
			}
			        }
			    }
			
			    if (传送带列表.length === 0) return;
			
			    const 移动计划 = new Map();
			
			    for (const 带 of 传送带列表) {
			        const 单元格 = 地牢[带.y]?.[带.x];
			        const 怪物 = 单元格?.关联怪物;
			        const 物品 = 单元格?.关联物品 !== 带 ? 单元格?.关联物品 : null;
			        
			        let 移动方向 = 带.自定义数据.get('方向');
			        
			        const 向量 = { N: {dx: 0, dy: -1}, S: {dx: 0, dy: 1}, E: {dx: 1, dy: 0}, W: {dx: -1, dy: 0} }[移动方向];
			        const 力度 = 带.自定义数据.get('力度') ?? 1;
			
			        if (向量 && 力度 >= 0) {
			const 检查并计划移动 = (实体, 类型) => {
			    if (实体) {
			        const { x: 新X, y: 新Y } = 寻找传送带最远可达点(带.x, 带.y, 向量.dx, 向量.dy, 力度);
			        if (新X !== 带.x || 新Y !== 带.y) {
			             移动计划.set(实体, { 新X, 新Y, 旧X: 带.x, 旧Y: 带.y, 类型 });
			        }
			        if (带.自定义数据?.get('开关激发')) 红蓝开关状态 = 红蓝开关状态 === '红' ? '蓝' : '红';
			    }
			};
			
			检查并计划移动(怪物, "怪物");
			if (物品 && 物品.能否拾起) {
			    检查并计划移动(物品, "物品");
			}
			if (玩家.x === 带.x && 玩家.y === 带.y) {
			    检查并计划移动(玩家, "玩家");
			}
			        }
			    }
			
			    const 成功移动列表 = [];
			    移动计划.forEach((计划, 生物) => {
			        const { 新X, 新Y, 旧X, 旧Y, 类型 } = 计划;
			        const 目标单元格 = 地牢[新Y]?.[新X];
			
			        if (目标单元格 && !(目标单元格.关联怪物 && 类型!=='玩家') && !(目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物)) {
			if (类型 === "怪物") {
			    if(!检查移动可行性(旧X,旧Y,新X,新Y)) {
			        推开生物(生物.x,生物.y);
			        return;
			    }
			     生物.恢复背景类型();
			     怪物动画状态.set(生物, {
			    旧逻辑X: 旧X,
			    旧逻辑Y: 旧Y,
			    目标逻辑X: 新X,
			    目标逻辑Y: 新Y,
			    视觉X: 旧X,
			    视觉Y: 旧Y,
			    动画开始时间: Date.now(),
			    正在动画: true,
			});
			
			     生物.x = 新X;
			     生物.y = 新Y;
			     生物.保存新位置类型(新X, 新Y);
			     目标单元格.类型 = 单元格类型.怪物;
			     目标单元格.关联怪物 = 生物;
			     成功移动列表.push(生物);
			} else if (类型 === "物品") {
			     地牢[旧Y][旧X].关联物品 = 地牢[旧Y][旧X].关联物品 === 生物 ? null : 地牢[旧Y][旧X].关联物品;
			     if(地牢[旧Y][旧X].关联物品 === null) 地牢[旧Y][旧X].类型 = null;
			     生物.x = 新X;
			     生物.y = 新Y;
			     
			     目标单元格.类型 = 单元格类型.物品;
			     目标单元格.关联物品 = 生物;
			     成功移动列表.push(生物);
			} else if (类型 === "玩家") {
			     玩家.x = 新X;
			     玩家.y = 新Y;
			     玩家动画状态 = {
			正在动画: true,
			旧逻辑X: 旧X,
			旧逻辑Y: 旧Y,
			目标逻辑X: 玩家.x,
			目标逻辑Y: 玩家.y,
			视觉X: 旧X,
			视觉Y: 旧Y,
			动画开始时间: Date.now()
			        };
			     处理玩家着陆效果(旧X, 旧Y, 新X, 新Y);
			     
			     更新视口();
			     成功移动列表.push(玩家);
			}
			        }
			    });
			}
			function 处理怪物回合() {
			    
			    if (地牢.length !== 地牢大小) return;
			        const 当前房间ID = 房间地图[玩家.y][玩家.x];
			        跟踪玩家怪物数 = 0;
			        所有怪物.forEach((m) => {
			            if (地牢[m.y]?.[m.x]?.关联物品 instanceof 传送带) return;
			            if (房间地图[m.y][m.x] === 当前房间ID) {
			                m.状态 = 怪物状态.活跃;
			            }
			        });
			        const 玩家穿了潜行靴子 = Array.from(玩家装备.values()).some(item => item instanceof 潜行靴子);
			        const 有金质装备 = Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).some(装备 => 装备.材质 === 材料.金质);
			        
			        所有怪物.forEach(m => {
			            if (m instanceof 超速怪物 && m.状态 === 怪物状态.活跃) {
			                const 范围 = m.加速范围;
			                const 加速值 = m.加速回合数;
			                for (let dy = -范围; dy <= 范围; dy++) {
			                    for (let dx = -范围; dx <= 范围; dx++) {
			                        const x = m.x + dx;
			                        const y = m.y + dy;
			                        const 邻居 = 地牢[y]?.[x]?.关联怪物;
			                        if (邻居 && 邻居.状态 === 怪物状态.活跃) {
			                            邻居.本回合行动次数 = 加速值;
			                        }
			                    }
			                }
			            }
			        });
			
			        所有怪物.forEach((m) => {
			            if (m.状态 === 怪物状态.活跃 || m.始终追踪玩家) {
			                
			                const 我的状态 = 怪物状态表.get(m);
			                我的状态?.更新状态();
			
			                if (地牢[m.y]?.[m.x]?.关联物品 instanceof 传送带) return;
			                const 行动次数 = m.本回合行动次数 || 1;
			                const 原始移动距离 = m.基础移动距离;
			                    for (let i = 0; i < 行动次数; i++) {
			                if (m instanceof 同步怪物 || m instanceof 巡逻怪物) {
			                    m.尝试移动();
			                    m.目标 = m.选择目标();
			                    
			                    m.尝试攻击();
			                    return;
			                }else if (m.始终追踪玩家) {
			                    m.追踪玩家();
			                }
			                
			                const 距离玩家 = Math.abs(m.x - 玩家.x) + Math.abs(m.y - 玩家.y);
			                if(有金质装备 && 距离玩家 > 5) {
			                    m.基础移动距离 += 1;
			                }
			
			                let 目标 = m.选择目标();
			                m.目标 = 目标;
			                let { x, y } = 目标;
			
			                let 可以追踪 = true;
			                if (玩家穿了潜行靴子 && 怪物状态表.get(m)?.类型 !== "魅惑" && 目标 === 玩家) {
			                    可以追踪 = 快速直线检查(m.x, m.y, 玩家.x, 玩家.y, m.跟踪距离);
			                }
			
			                const 曼哈顿距离 = Math.abs(m.x - x) + Math.abs(m.y - y);
			
			                if (可以追踪 && 曼哈顿距离 <= m.跟踪距离) {
			                    m.通向目标路径 = m.计算目标路径(x, y);
			                    if (m.通向目标路径) {
			                        const 截断点 = Math.max(0, m.通向目标路径.length - Math.floor(m.攻击范围 / 2));
			                        m.目标路径 = m.通向目标路径.slice(0, 截断点);
			                    } else {
			                        m.目标路径 = null;
			                    }
			                } else {
			                    m.通向目标路径 = null;
			                    m.目标路径 = null;
			                    if (玩家穿了潜行靴子) { 
			                        const 方向列表 = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
			                        const 可移动方向 = 方向列表.filter(dir => 检查移动可行性(m.x, m.y, m.x + dir.dx, m.y + dir.dy));
			                        if (可移动方向.length > 0) {
			                            const 随机方向 = 可移动方向[Math.floor(prng() * 可移动方向.length)];
			                            const 随机路径 = [{ x: m.x + 随机方向.dx, y: m.y + 随机方向.dy }];
			                            m.通向目标路径 = 随机路径;
			                            m.目标路径 = 随机路径;
			                            m.目标 = {x:玩家.x,y:玩家.y}
			                        }
			                    }
			                }
			                if (m.通向目标路径) {
			                    
			                        if (m.目标路径 && m.目标路径.length > 0 && !(m.通向目标路径.length > 1 && 玩家状态.some((s) => s.类型 === "隐身") && 怪物状态表.get(m)?.类型 !== "魅惑" && !(m instanceof 王座守护者 && m.当前阶段 === 3))) {
			                            if (怪物状态表.get(m)?.类型 !== "魅惑") m.追击玩家中 = true;
			                            m.尝试移动();
			                            if (m.目标路径 && m.通向目标路径) {
			                            m.通向目标路径.shift()
			                            m.目标路径.shift()
			                            }
			                        } else {
			                            m.追击玩家中 = false;
			                            if (m.x==m.目标.x&&m.y==m.目标.y) {
			                                m.追击玩家中 = true;
			                                跟踪玩家怪物数++;
			                            }
			                            if (m instanceof 王座守护者 && !m.强制释放随机技能()) {
			                        const 方向列表 = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
			                        const 可移动方向 = 方向列表.filter(dir => 检查移动可行性(m.x, m.y, m.x + dir.dx, m.y + dir.dy));
			                        if (可移动方向.length > 0) {
			                            const 随机方向 = 可移动方向[Math.floor(prng() * 可移动方向.length)];
			                            m.目标路径 = [{ x: m.x + 随机方向.dx, y: m.y + 随机方向.dy }];
			                            m.目标 = {x: m.x + 随机方向.dx, y: m.y + 随机方向.dy};
			                            m.尝试移动();
			                            if (m.目标路径 && m.通向目标路径) {
			                            m.通向目标路径.shift()
			                            m.目标路径.shift()
			                            }
			                        }
			                    }
			                        }
			
			                        if (m.通向目标路径 && !(m.通向目标路径.length > 1 && 玩家状态.some((s) => s.类型 === "隐身") && 怪物状态表.get(m)?.类型 !== "魅惑")) {
			                            m.尝试攻击();
			                        } else {
			                            m.绘制血条();
			                        }
			                        if (m.当前生命值 <= 0) break;
			                        if (m instanceof 大魔法师) {
			                        m.更新技能冷却();
			                    }
			                    
			                    
			                } else {
			                    m.追击玩家中 = false;
			                    if (m instanceof 王座守护者 && !m.强制释放随机技能()) {
			                        const 方向列表 = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
			                        const 可移动方向 = 方向列表.filter(dir => 检查移动可行性(m.x, m.y, m.x + dir.dx, m.y + dir.dy));
			                        if (可移动方向.length > 0) {
			                            const 随机方向 = 可移动方向[Math.floor(prng() * 可移动方向.length)];
			                            m.目标路径 = [{ x: m.x + 随机方向.dx, y: m.y + 随机方向.dy }];
			                            m.目标 = {x: m.x + 随机方向.dx, y: m.y + 随机方向.dy};
			                            m.尝试移动();
			                        }
			                    }
			                }
			                }
			                    if (!(m instanceof 超速怪物) && m?.本回合行动次数 > 1) m.本回合行动次数 = 1;
			                m.基础移动距离 = 原始移动距离;
			            }
			        });
			    
			
			    const 提示元素 =
			        怪物追踪提示.容器元素.querySelector(".hud-label");
			    if (跟踪玩家怪物数 > 3) {
			        提示元素.classList.add("怪物数量警告");
			    } else {
			        提示元素.classList.remove("怪物数量警告");
			    }
			    怪物追踪提示.更新({
			        内容: `追踪怪物：${跟踪玩家怪物数}`,
			    });
			}
			
			function 切换日志显示() {
			    日志面板可见 = !日志面板可见;
			    const 按钮 = document.querySelector(
			        "#设置菜单 button:nth-child(1)"
			    ); 
			    if (日志面板可见) {
			        document.querySelector(".日志面板").classList.add("可见");
			        按钮.textContent = "关闭日志界面"; 
			    } else {
			        document
			            .querySelector(".日志面板")
			            .classList.remove("可见");
			        按钮.textContent = "打开日志界面"; 
			    }
			}
			function 打开游戏内设置() {
    const 菜单 = document.getElementById("设置菜单");
    if (菜单.classList.contains("显示")) {
        关闭设置菜单();
    }

    打开设置窗口();

    玩家属性.允许移动++; 
}

			            function 切换背包显示() {
			    const 弹窗 = document.querySelector(".背包弹窗");
			    const 融合窗口 = document.getElementById("融合窗口");
			    const 背包标题元素 = 弹窗.querySelector(":scope > .弹窗头部 > h3");
			    const 当前状态 = 弹窗.classList.contains("显示中");
			    
			    if (当前状态) {
			        玩家属性.允许移动 -= 1;
			        融合窗口.style.display = 'none';
			        融合窗口.classList.remove("显示中");
			        document.querySelectorAll(".物品条目").forEach((el) => {
			            el.classList.remove("active");
			            if (el.__物品实例) {
			                el.__物品实例.isActive = false;
			            }
			        });
			    } else {
			        玩家属性.允许移动 += 1;
			        if (游戏状态 === '地图编辑器') {
			             融合窗口.style.display = 'none';
			             
			             if (背包标题元素) {
			                背包标题元素.innerHTML = `编辑器工具箱`;
			             }
			        } else {
			            更新融合窗口();
			            融合窗口.style.display = "flex";
			            requestAnimationFrame(() => {
			                融合窗口.classList.add("显示中");
			                融合窗口.style.opacity = 1;
			                融合窗口.style.transform = "translateX(0)";
			                融合窗口.style.pointerEvents = "auto";
			                融合窗口.style["flex-direction"] = "row";
			            });
			            if (背包标题元素) {
			                背包标题元素.innerHTML = `背包 (容量：<span id="当前容量">0</span>/<span id="最大容量">${最大背包容量}</span>)`;
			            }
			            更新背包显示();
			        }
			    }
			    
			    界面可见性.背包 = !当前状态;
			    
			    弹窗.classList.toggle("显示中", !当前状态);
			    document.getElementById("浮动提示框").style.display = "none";
			}
			function 初始化背包事件监听() {
			    const 容器 = document.getElementById("背包物品栏");
			
			    const 显示提示框 = (事件, 物品实例) => {
			        const 提示框 = document.getElementById("浮动提示框");
			        提示框.innerHTML = 物品实例.获取提示().replace(/\n/g, "<br>");
			        提示框.style.display = "block";
			
			        const 提示框宽度 = 提示框.offsetWidth;
			        const 提示框高度 = 提示框.offsetHeight;
			        const 视口宽度 = window.innerWidth;
			        const 视口高度 = window.innerHeight;
			        let left = 事件.pageX + 15;
			        let top = 事件.pageY + 15;
			
			        if (left + 提示框宽度 > 视口宽度 - 10) {
			left = 事件.pageX - 提示框宽度 - 15;
			        }
			        if (top + 提示框高度 > 视口高度 - 10) {
			top = 视口高度 - 提示框高度 - 10;
			        }
			        
			        left = Math.max(5, Math.min(left, 视口宽度 - 提示框宽度 - 5));
			        top = Math.max(5, Math.min(top, 视口高度 - 提示框高度 - 5));
			        
			        提示框.style.left = `${left}px`;
			        提示框.style.top = `${top}px`;
			    };
			
			    const 隐藏提示框 = () => {
			        document.getElementById("浮动提示框").style.display = "none";
			    };
			
			    容器.addEventListener('click', (事件) => {
			        const 物品条目 = 事件.target.closest('.物品条目');
			        if (!物品条目) return;
			        
			        const 物品实例 = 物品条目.__物品实例;
			        if (!物品实例) return;
			
			        const 目标按钮 = 事件.target.closest('button');
			
			        if (目标按钮) {
			事件.stopPropagation();
			if (目标按钮.classList.contains('装备按钮')) {
			    const 起始元素 = 物品条目;
			    if (物品实例.已装备) {
			        物品实例.取消装备();
			        显示通知("已卸下", "成功");
			        更新装备显示();
			    } else {
			        if (物品实例.装备()) {
			            显示通知("已装备", "成功");
			            更新背包显示();
			            
			            const 获取目标元素的函数 = () => document.getElementById(`装备槽${((物品实例.装备槽位 - 1) % 装备栏每页装备数) + 1}`);
			            创建并播放物品移动动画(起始元素, 获取目标元素的函数);
			            if (typeof gsap !== 'undefined') {
			                setTimeout(更新装备显示,260);
			            } else {
			                更新装备显示();
			            }
			            
			        } else {
			            显示通知("槽位已满", "错误");
			        }
			    }
			    目标按钮.style.background = 物品实例.已装备 ? "#f44336" : "#FF9800";
			    
			    隐藏提示框();
			} else if (目标按钮.classList.contains('丢弃按钮')) {
			    处理丢弃物品(物品实例.唯一标识);
			} else if (目标按钮.classList.contains('使用按钮')) {
			    使用背包物品(物品实例.唯一标识);
			} else if (目标按钮.classList.contains('上屏按钮')) {
			     添加到融合区(物品实例, 物品条目);
			}
			        } else { 
			const 当前是否已激活 = 物品条目.classList.contains('active');
			document.querySelectorAll('.物品容器 .物品条目.active').forEach(el => el.classList.remove('active'));
			
			if (!当前是否已激活) {
			    物品条目.classList.add('active');
			    显示提示框(事件, 物品实例);
			} else {
			    隐藏提示框();
			}
			        }
			    });
			
			    容器.addEventListener('contextmenu', (e) => {
			        const 物品条目 = e.target.closest('.物品条目');
			        if (!物品条目) return;
			        e.preventDefault();
			        const 物品实例 = 物品条目.__物品实例;
			        if (!物品实例) return;
			
			        const 起始元素 = 物品条目;
			        if (物品实例.已装备) {
			物品实例.取消装备();
			显示通知("已卸下", "成功");
			更新装备显示();
			        } else {
			if (物品实例.装备()) {
			    显示通知("已装备", "成功");
			    更新背包显示();
			    
			    const 获取目标元素的函数 = () => document.getElementById(`装备槽${((物品实例.装备槽位 - 1) % 装备栏每页装备数) + 1}`);
			    创建并播放物品移动动画(起始元素, 获取目标元素的函数);
			    if (typeof gsap !== 'undefined') {
			                setTimeout(更新装备显示,260);
			            } else {
			                更新装备显示();
			            }
			} else {
			    显示通知("槽位已满！", "错误");
			}
			        }
			        const 装备按钮 = 物品条目.querySelector('.装备按钮');
			        if (装备按钮) {
			装备按钮.style.background = 物品实例.已装备 ? '#f44336' : '#FF9800';
			        }
			        
			    });
			    
			    容器.addEventListener('mouseover', (事件) => {
			        if (事件.target.closest('button')) return;
			        const 物品条目 = 事件.target.closest('.物品条目');
			        if (物品条目 && !物品条目.classList.contains('active')) {
			const 物品实例 = 物品条目.__物品实例;
			if (物品实例) {
			    显示提示框(事件, 物品实例);
			}
			        }
			    });
			
			    容器.addEventListener('mouseout', (事件) => {
			        const 物品条目 = 事件.target.closest('.物品条目');
			        if (物品条目 && !物品条目.classList.contains('active')) {
			 隐藏提示框();
			        }
			    });
			    已初始化--;
			}

			document.addEventListener("click", (e) => {
			    const 弹窗 = document.querySelector(".背包弹窗");
			    const 背包区域 = document.querySelector(".背包弹窗 .物品容器");
			    if (document.getElementById("全局设置窗口").style.display === 'block' && !e.target.closest("#全局设置窗口") && !e.target.closest('#全局设置按钮')) {
			        关闭全局设置窗口();
			    }
			    if (
			        界面可见性.背包 &&
			        !e.target.closest(".背包弹窗") &&
			        !e.target.closest("#背包按钮")
			    ) {
			        切换背包显示();
			    } else if (
			        教程提示已显示 &&
			        !e.target.closest("#教程提示窗口") &&
			        !e.target.closest("#游戏模式选择菜单")
			    ) {
			        关闭教程提示();
			    } else if (
			        document
			            .getElementById("设置菜单")
			            .classList.contains("显示") &&
			        !e.target.closest("#设置按钮")
			    ) {
			        切换设置菜单();
			    } else if (
			        document.getElementById("教程回放窗口").style.display ===
			            "block" &&
			        !e.target.closest(".教程提示窗口") &&
			        !e.target.closest("#回放教程按钮")
			    ) {
			        关闭教程回放窗口();
			    }
			    if (!e.target.closest(".物品条目") && 界面可见性.背包) {
			        document.getElementById("浮动提示框").style.display =
			            "none";
			        document.querySelectorAll(".物品条目").forEach((el) => {
			            el.classList.remove("active");
			            if (el.__物品实例) {
			                el.__物品实例.isActive = false;
			                //console.log(el.__物品实例.类型);
			            }
			        });
			    }
			});
			function showGameInfo() {
    const overlay = document.getElementById('gameInfoOverlay');
    if (!overlay) return;

    
    overlay.style.display = 'flex';
    requestAnimationFrame(() => {
        overlay.classList.add('show');
    });
}

function hideGameInfo() {
    const overlay = document.getElementById('gameInfoOverlay');
    if (!overlay) return;

    overlay.classList.remove('show');
    
    setTimeout(() => {
        overlay.style.display = 'none';
    }, 300); 
}



const gameTitle = document.getElementById('游戏标题');
const gameInfoOverlay = document.getElementById('gameInfoOverlay');
const closeGameInfoBtn = document.getElementById('closeGameInfoBtn');

if (gameTitle) {
    gameTitle.addEventListener('click', showGameInfo);
    
    gameTitle.style.cursor = 'pointer'; 
}

if (closeGameInfoBtn) {
    closeGameInfoBtn.addEventListener('click', hideGameInfo);
}

if (gameInfoOverlay) {
    
    gameInfoOverlay.addEventListener('click', (event) => {
        if (event.target === gameInfoOverlay) {
            hideGameInfo();
        }
    });
}
			
			document.addEventListener("keydown", (e) => {
			    if(!e.key) return;
if (e.key === "Escape") {
    const settingsOverlay = document.getElementById("设置窗口遮罩");
    const backpackWindow = document.querySelector(".背包弹窗");

    
    // 1. 关闭主设置窗口
    if (settingsOverlay && settingsOverlay.classList.contains('显示')) {
        e.preventDefault(); 
        关闭设置窗口();
        return; 
    }

    // 2. 关闭游戏内简易设置菜单
    const gameMenu = document.getElementById("设置菜单");
    if (gameMenu && gameMenu.classList.contains('显示')) {
        e.preventDefault();
        关闭设置菜单();
        return;
    }
    
    // 3. 关闭背包窗口
    if (backpackWindow && backpackWindow.classList.contains('显示中')) {
        e.preventDefault();
        切换背包显示();
        return;
    }

    // 4. 如果没有其他窗口打开，并且在游戏场景中，则打开主设置窗口
    const inGameStates = ["游戏中", "编辑器游玩", "图鉴", "地图编辑器"];
    if (inGameStates.includes(游戏状态)) {
        e.preventDefault();
        打开游戏内设置(); 
		return;
    }
}
			    if (游戏状态 === '地图编辑器') {
                    const editorHotkeys = 游戏设置.热键绑定;
                    const key = e.key.toLowerCase();
			        if (e.key === editorHotkeys.编辑器确认) {
			            const activeElement = document.activeElement;
			            if (activeElement && activeElement.tagName.toLowerCase() === 'textarea' && activeElement.dataset.key === '内容') {
			            } else {
			                e.preventDefault();
			                if (document.getElementById('编辑器属性面板遮罩').style.display === 'block') {
			                    document.getElementById('保存属性按钮').click();
			                } else if (document.getElementById('全局设置窗口').style.display === 'block') {
			                    document.getElementById('保存全局设置按钮').click();
			                }
			            }
			        } else if (key === editorHotkeys.编辑器游玩.toLowerCase()) {
			            从当前位置开始游玩();
			        } else if (key === editorHotkeys.编辑器删除工具.toLowerCase()) {
			            设置编辑器选中项({ 名称: '删除工具', 图标: 图标映射.删除, 类型: '工具' });
			            显示通知('已选中: 删除工具', '信息');
			        } else if ((e.ctrlKey || e.metaKey)) {
			            e.preventDefault();
			            if (key === editorHotkeys.编辑器撤销.toLowerCase()) {
			                if (e.shiftKey) {
			                    redoEditorAction();
			                } else {
			                    undoEditorAction();
			                }
			                return;
			            }
			            if (key === editorHotkeys.编辑器重做.toLowerCase()) {
			                redoEditorAction();
			                return;
			            }
			        }
			    }
				if (动画帧运行过) {
					const keyMap = {
						ArrowUp: "up", w: "up", W: "up",
						ArrowLeft: "left", a: "left", A: "left",
						ArrowDown: "down", s: "down", S: "down",
						ArrowRight: "right", d: "right", D: "right",
					};
					if (e.key.toLowerCase() === (游戏设置.热键绑定.等待 || ' ').toLowerCase() && !休息定时器 && 玩家属性.允许移动 <= 0 && !玩家正在休息) {
						e.preventDefault();
						休息定时器 = setTimeout(开始休息, 500);
					} else if (keyMap[e.key] && 玩家属性.允许移动 <= 0) {
						const direction = keyMap[e.key];
						if (移动状态[direction]) return;
						移动状态[direction] = true;
						const dx = 移动状态.left ? -玩家属性.移动步数 : 移动状态.right ? 玩家属性.移动步数 : 0;
						const dy = 移动状态.up ? -玩家属性.移动步数 : 移动状态.down ? 玩家属性.移动步数 : 0;
						if (dx !== 0 || dy !== 0) {
				移动玩家(dx, dy);
						}
						clearTimeout(开始移动定时器);
						开始移动定时器 = setTimeout(开始移动, 250);
						e.preventDefault();
					} else if (功能键映射[e.key.toLowerCase()]) {
						功能键映射[e.key.toLowerCase()]();
					} else if (e.key === "Escape" && 界面可见性.背包) {
						切换背包显示();
					}
				}
			});
			
			
			document.addEventListener("keyup", (e) => {
			    const keyMap = {
			        ArrowUp: "up",
			        w: "up",
			        W: "up",
			        ArrowLeft: "left",
			        a: "left",
			        A: "left",
			        ArrowDown: "down",
			        s: "down",
			        S: "down",
			        ArrowRight: "right",
			        d: "right",
			        D: "right",
			    };
			    if (e.key.toLowerCase() === (游戏设置.热键绑定.等待 || ' ').toLowerCase()) {
					if (休息定时器) {
						clearTimeout(休息定时器);
						休息定时器 = null;
						if (!玩家正在休息) {
							玩家等待();
						}
					}
					if (玩家正在休息) {
						停止休息();
					}
					e.preventDefault();
				}
			    if (keyMap[e.key]) {
			        const direction = keyMap[e.key];
			        移动状态[direction] = false; // 清除移动状态
			        clearTimeout(开始移动定时器); // 重要！清除 开始移动 定时器
			        停止移动();
			        e.preventDefault();
			    }
			});
			function 获取玩家视野范围() {
			    if (玩家状态.some(s => s.类型 === '失明')) return 0;
			    const 玩家房间ID = 房间地图[玩家.y]?.[玩家.x];
			    const 玩家所在房间 =
			        玩家房间ID !== undefined && 玩家房间ID !== -1
			            ? 房间列表[玩家房间ID]
			            : null;
			    if (玩家所在房间?.类型==="黑暗房间") return 1;
			    const 画布 = document.getElementById("dungeonCanvas");
			    const 画布Rect = 画布.getBoundingClientRect();
			    if (!当前天气效果.includes("深夜")) return Math.floor(画布Rect.width / 单元格大小 / 2);
			    
			    let 基础视野 = 3; // 默认视野范围
			    let 视野加成 = 0;
			    玩家装备.forEach((物品) => {
			        if (物品 instanceof 火把) {
			            视野加成 += 物品.自定义数据.get("视野加成") || 0;
			        }
			    });
			    return 基础视野 + 视野加成;
			}
let 光源地图 = new Set();
			
function 是否在光源范围内(目标X, 目标Y) {
    const 玩家房间ID = 房间地图[玩家.y]?.[玩家.x];
    const 玩家所在房间 = (玩家房间ID !== undefined && 玩家房间ID !== -1) ? 房间列表[玩家房间ID] : null;

    // 优先处理最简单的逻辑
    if (玩家状态.some(s => s.类型 === '失明')) return false;


    
    const 目标房间ID = 房间地图[目标Y]?.[目标X];
    if (目标房间ID !== -1) {
        const 目标房间 = 房间列表[目标房间ID];
        // 如果目标在黑暗房间，而玩家不在，则目标不可见
        if (目标房间 && 目标房间.类型 === "黑暗房间" && 玩家房间ID !== 目标房间ID) {
            return false;
        }
    }
// 如果不是深夜且不在黑暗房间，则默认可见
    if (!当前天气效果.includes("深夜") && (!玩家所在房间 || 玩家所在房间.类型 !== "黑暗房间")) {
        return true;
    }
    // 核心优化：直接查询预先计算好的光源地图
    return 光源地图.has(`${目标X},${目标Y}`);
}

function 更新光源地图() {
    光源地图.clear();
    const 玩家视野 = 获取玩家视野范围(); // 现在这个函数很快

    // 1. 计算玩家自身视野
    if (玩家视野 > 0) {
        // 使用一个更优的圆形范围近似算法
        for (let y = 玩家.y - 玩家视野; y <= 玩家.y + 玩家视野; y++) {
            for (let x = 玩家.x - 玩家视野; x <= 玩家.x + 玩家视野; x++) {
                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
                
                // 使用曼哈顿距离或圆形距离来初步筛选，减少视线检查次数
                if (Math.abs(x - 玩家.x) + Math.abs(y - 玩家.y) <= 玩家视野) {
                    if (检查视线(玩家.x, 玩家.y, x, y, 玩家视野 + 1)) {
                        光源地图.add(`${x},${y}`);
                    }
                }
            }
        }
    }

    // 2. 遍历所有潜在的外部光源（一次性完成）
    const 检查并添加光源 = (光源) => {
        const 光照范围 = 光源.自定义数据?.get("光照范围");
        if (光照范围 > 0 && 光源.x >= 0 && 光源.y >= 0) {
            for (let dy = -光照范围; dy <= 光照范围; dy++) {
                for (let dx = -光照范围; dx <= 光照范围; dx++) {
                    const 目标X = 光源.x + dx;
                    const 目标Y = 光源.y + dy;
                    if (
			                目标X < 0 ||
			                目标X >= 地牢大小 ||
			                目标Y < 0 ||
			                目标Y >= 地牢大小
			            )
			                continue;
                    if (Math.abs(dx) + Math.abs(dy) <= 光照范围) {
                         if (检查视线(光源.x, 光源.y, 目标X, 目标Y, 光照范围 + 1)) {
                            光源地图.add(`${目标X},${目标Y}`);
                        }
                    }
                }
            }
        }
    };
    
    // 检查计时器中的光源 (如地上的火把, 照明弹光源)
    所有计时器.forEach(计时器 => {
        if (计时器 && 计时器.自定义数据?.has("光照范围") && 计时器?.x) {
             检查并添加光源(计时器);
        }
    });
    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const cell = 地牢[y][x];
			            if (cell?.关联物品?.自定义数据?.has("光照范围")) {
			                检查并添加光源(cell?.关联物品);
			        }
			        }
			    }

    // 检查怪物身上的光源 (如燃烧状态)
    所有怪物.forEach(怪物 => {
        if (怪物状态表.get(怪物)?.类型 === "火焰") {
            检查并添加光源({ x: 怪物.x, y: 怪物.y, 自定义数据: new Map([['光照范围', 2]]) });
        }
    });
}

			const 图标映射_原始 = { ...图标映射 };
			function 切换中文模式() {
			    图标映射 = 中文模式 ? 图标映射_原始 : 中文对照图标映射;
			    楼梯图标 = {
			        下楼: 图标映射.下楼楼梯,
			        上楼: 图标映射.上楼楼梯,
			    };
			    中文模式 = !中文模式;
			
			    const 主菜单切换按钮 = document.getElementById("切换中文按钮");
			    if (主菜单切换按钮) {
			        主菜单切换按钮.textContent = 中文模式
			            ? "已切换为中文"
			            : "已切换为 Emoji";
			    }
			
			    document.querySelector("#背包按钮").innerHTML = `${图标映射.背包按钮}`;
			    document.querySelector("#互动按钮").innerHTML = `${图标映射.互动按钮}`;

				const 整理图标 = document.querySelector("#背包整理按钮 .整理图标");
				const 整理文本 = document.querySelector("#背包整理按钮 .整理文本");
				if(整理图标 && 整理文本){
					整理图标.style.display = 中文模式 ? 'none' : 'inline';
					整理文本.style.display = 中文模式 ? 'inline' : 'none';
				}
			
			    切换HUD模式();
			    切换HUD模式();
			    切换HUD模式();
			}
			let 切换动画 = false;
			function 切换动画模式() {
			    切换动画 = !切换动画; // 切换状态
			
			    
			    const 主菜单切换按钮 = document.getElementById("切换动画按钮");
			    if (主菜单切换按钮) {
			        主菜单切换按钮.textContent = 切换动画
			            ? "已切换为自动"
			            : "已切换为回合制";
			    }
			}
			
			function 使用装备槽物品(槽位编号) {
			    const 物品实例 = 玩家装备.get(槽位编号);
			
			    if (!物品实例) return;
			
			    // 无需考虑堆叠
			    if (物品实例.类型 === "武器") {
			        if (
			            物品实例.堆叠数量 > 0 &&
			            物品实例.自定义数据.get("冷却剩余") == 0
			        ) {
			            const { 怪物, 路径 } = 获取周围怪物(
			                物品实例.自定义数据.get("攻击目标数"),
			                物品实例.最终攻击范围
			            );
			            if (怪物 !== null) {
			                if (物品实例.使用(怪物, 路径,玩家)) {
			                    Array.from(
			                        { length: 装备栏每页装备数 },
			                        (_, i) =>
			                            玩家装备.get(
			                                当前装备页 * 装备栏每页装备数 +
			                                    i +
			                                    1
			                            )
			                    )
			                        .filter((v) => v != null)
			                        .forEach((装备) => {
			                            if (
			                                装备 instanceof 宠物 &&
			                                !装备.自定义数据.get("休眠中")
			                            ) {
			                                装备.当玩家攻击(怪物);
			                            }
			                        });
			                    更新装备显示();
			                    绘制();
			                    return true;
			                }
			            } else {
			                if (当前天气效果.includes("诡魅")) {
			                    显示通知(
			                        "太远了...看不清怪物的真实位置了...",
			                        "错误"
			                    );
			                } else {
			                    if(物品实例.自定义数据.get("攻击目标数")>0) 显示通知("附近没有目标", "错误");
			                }
			            }
			        } else {
			            显示通知("武器还未准备好", "错误");
			            return false;
			        }
			    }
			    if (物品实例.类型 === "卷轴") {
			        显示通知("请使用卷轴键使用该物品", "错误");
			        return false;
			    }
			    if (物品实例.使用()) {
			        if (物品实例.堆叠数量 <= 0) {
			            if (物品实例.装备槽位)
			                玩家装备.delete(物品实例.装备槽位);
			            玩家背包.delete(物品实例.唯一标识);
			        }
			        更新背包显示();
			        更新装备显示();
			        显示通知("已使用物品", "成功");
			        return true;
			    } else {
			        if (物品实例.类型 !== "武器") {
			            显示通知("无法使用该物品", "错误");
			        }
			    }
			    return false;
			}
			
			function 卸下装备槽物品(槽位编号) {
			    const 当前物品 = 玩家装备.get(槽位编号);
			
			    if (当前物品) {
			        当前物品.取消装备();
			        显示通知("已卸下", "成功");
			        更新装备显示();
			        更新背包显示();
			
			        const 槽位 = document.getElementById(`装备槽${槽位编号}`);
			        槽位.style.transform = "scale(0.95)";
			        setTimeout(() => (槽位.style.transform = "scale(1)"), 200);
			    }
			}
			function 处理销毁物品(唯一标识, 直接清理 = false) {
			    const 目标物品 = 玩家背包.get(唯一标识);
			    if (!直接清理) {
			        if (!confirm("确定要销毁这个物品吗？")) return false;
			    }
			    if (!目标物品) return false;
			
			    const 物品元素 = 目标物品.显示元素;
			    document.getElementById("浮动提示框").style.display = "none";
			
			    if (!直接清理 && 物品元素 && document.body.contains(物品元素)) {
			        const 烟花容器 = document.createElement("div");
			        烟花容器.style.position = "fixed";
			        const rect = 物品元素.getBoundingClientRect();
			        烟花容器.style.left = `${rect.left + rect.width / 2}px`;
			        烟花容器.style.top = `${rect.top + rect.height / 2}px`;
			        烟花容器.style.zIndex = 99999;
			        document.body.appendChild(烟花容器);
			
			        for (let i = 0; i < 12; i++) {
			            const 粒子 = document.createElement("div");
			            粒子.className = "烟花粒子";
			            粒子.innerHTML = ["✨", "❄️", "⚡", "⭐", "💥", "🔥"][
			                i % 6
			            ];
			            粒子.style.color =
			                目标物品.颜色表[目标物品.颜色索引] || "#fff";
			            粒子.style.setProperty(
			                "--tx",
			                Math.cos((i * 30 * Math.PI) / 180)
			            );
			            粒子.style.setProperty(
			                "--ty",
			                Math.sin((i * 30 * Math.PI) / 180)
			            );
			            烟花容器.appendChild(粒子);
			        }
			        setTimeout(() => 烟花容器.remove(), 800);
			        物品元素.style.opacity = "0";
			        物品元素.style.transition = "opacity 0.2s";
			    }
			
			    if (目标物品.安全销毁()) {
			        [...玩家背包.values()].forEach((item) => {
			            if (item instanceof 宠物) {
			                for (let 槽位 in item.自定义数据.get("装备")) {
			                    if (
			                        item.自定义数据.get("装备")[槽位] ===
			                        目标物品
			                    ) {
			                        item.自定义数据.get("装备")[槽位] = null;
			                        item.更新宠物管理窗口();
			                    }
			                }
			            }
			        });
			        if (目标物品.装备槽位) 玩家装备.delete(目标物品.装备槽位);
			        玩家背包.delete(唯一标识);
			        更新背包显示();
			        更新装备显示();
			    }
			    return true;
			}
			function 尝试收集物品(新物品, 直接收集 = false) {
			    if (!新物品) return;
			    if (新物品.当被收集 && !新物品.当被收集("玩家")) {
			        return false;
			    }
			    if (!新物品.能否拾起) return false;
			
			    // 查找可堆叠物品
			    const 现有物品 = [...玩家背包.values()].find((item) =>
			        item.可堆叠于(新物品)
			    );
			
			    // 处理可堆叠情况
			    if (现有物品) {
			        if (现有物品.堆叠数量 < 现有物品.最大堆叠数量) {
			            if (
			                现有物品.堆叠数量 + 新物品.堆叠数量 >=
			                现有物品.最大堆叠数量
			            ) {
			                新物品.堆叠数量 -=
			                    现有物品.最大堆叠数量 - 现有物品.堆叠数量;
			                现有物品.堆叠数量 = 现有物品.最大堆叠数量;
			                return 尝试收集物品(新物品, 直接收集);
			            } else {
			                现有物品.堆叠数量 += 新物品.堆叠数量;
			                更新背包显示();
			                更新装备显示();
			                const 特效元素 = document.createElement("div");
			                特效元素.className = "收集特效";
			                特效元素.style.cssText = `
			   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
			   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
			 `;
			                if (新物品.类型 === "金币") {
			                    特效元素.style.cssText = `
			   --辉光颜色: ${颜色表[2]};
			   color: ${颜色表[2]};
			 `;
			                }
			                特效元素.innerHTML = 新物品.显示图标;
			                if (!直接收集) {
			                    document.body.appendChild(特效元素);
			                }
			                setTimeout(() => 特效元素.remove(), 1100);
			                return true;
			            }
			        }
			        // 当前堆叠已满则创建新堆叠
			    }
			
			    // 处理新物品，需要考虑该函数会被递归调用，故需要刷新（刷新准没错（（（
			    if (
			        [...玩家背包.values()].reduce(
			            (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
			            0
			        ) >= 最大背包容量
			    ) {
			        更新背包显示();
			        更新装备显示();
			        显示通知("背包已满！", "错误");
			        return false;
			    }
			    if (新物品.堆叠数量 > 0) {
			        新物品.是否被丢弃 = false;
			        玩家背包.set(新物品.唯一标识, 新物品);
			        添加日志(`已收集物品 ${新物品.获取名称()}`, "信息");
			    }
			    更新背包显示();
			    更新装备显示();
			    const 特效元素 = document.createElement("div");
			    特效元素.className = "收集特效";
			    特效元素.style.cssText = `
			   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
			   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
			 `;
			    if (新物品.类型 === "金币") {
			        特效元素.style.cssText = `
			   --辉光颜色: ${颜色表[2]};
			   color: ${颜色表[2]};
			 `;
			    }
			    特效元素.innerHTML = 新物品.显示图标;
			    if (!直接收集) {
			        document.body.appendChild(特效元素);
			    }
			    setTimeout(() => 特效元素.remove(), 1100);
			    return true;
			}
			
			function 使用背包物品(物品标识) {
			    const 物品实例 = 玩家背包.get(物品标识);
			    if (!物品实例) return false;
			    if (物品实例.类型 === "武器") {
			        if (
			            物品实例.堆叠数量 > 0 &&
			            物品实例.自定义数据.get("冷却剩余") == 0
			        ) {
			            const { 怪物, 路径 } = 获取周围怪物(
			                物品实例.自定义数据.get("攻击目标数"),
			                物品实例.最终攻击范围
			            );
			            if (怪物 !== null) {
			                if (物品实例.使用(怪物, 路径)) {
			                    Array.from(
			                        { length: 装备栏每页装备数 },
			                        (_, i) =>
			                            玩家装备.get(
			                                当前装备页 * 装备栏每页装备数 +
			                                    i +
			                                    1
			                            )
			                    )
			                        .filter((v) => v != null)
			                        .forEach((装备) => {
			                            if (
			                                装备 instanceof 宠物 &&
			                                !装备.自定义数据.get("休眠中")
			                            ) {
			                                装备.当玩家攻击(怪物);
			                            }
			                        });
			                    更新装备显示();
			                    绘制();
			                    互动 = true;
			                    return true;
			                }
			                //失败后回退到 物品实例.使用()
			            } else {
			                if (当前天气效果.includes("诡魅")) {
			                    显示通知(
			                        "太远了...看不清怪物的真实位置了...",
			                        "错误"
			                    );
			                } else {
			                    显示通知("附近没有目标", "错误");
			                }
			            }
			        } else {
			            显示通知("武器还未准备好", "错误");
			            return false;
			        }
			    }
			    if (物品实例.类型 === "卷轴") {
			        显示通知("请在装备栏中使用该物品", "错误");
			        return false;
			    }
			    if (物品实例.使用()) {
			        document.getElementById("浮动提示框").style.display =
			            "none";
			        if (物品实例.堆叠数量 <= 0) {
			            if (物品实例.装备槽位)
			                玩家装备.delete(物品实例.装备槽位);
			            玩家背包.delete(物品标识);
			            物品实例.isActive = false;
			        }
			        更新背包显示();
			        更新装备显示();
			        显示通知("已使用物品", "成功");
			        return true;
			    } else {
			        显示通知("无法使用该物品", "错误");
			    }
			    return false;
			}
			
			function 更新背包显示() {
			    const 容器 = document.getElementById("背包物品栏");
			    document.getElementById("最大容量").textContent = 最大背包容量;
			
			    const domItemMap = new Map();
			    for (const child of 容器.children) {
			        if (child.__物品实例) {
			            domItemMap.set(child.__物品实例.唯一标识, child);
			        }
			    }
			
			    const backpackItemSymbols = new Set(玩家背包.keys());
			
			    for (const [symbol, item] of 玩家背包.entries()) {
			        if (item.是否隐藏) {
			            if (domItemMap.has(symbol)) {
			                domItemMap.get(symbol).remove();
			                domItemMap.delete(symbol);
			            }
			            continue;
			        }
			
			        let 元素 = domItemMap.get(symbol);
			
			        if (元素) {
			            const 堆叠元素 = 元素.querySelector(".物品堆叠");
			            if (item.堆叠数量 > 1) {
			                if (堆叠元素) {
			                    堆叠元素.textContent = `x${item.堆叠数量}`;
			                } else {
			                    const newStackEl = document.createElement("div");
			                    newStackEl.className = "物品堆叠";
			                    newStackEl.textContent = `x${item.堆叠数量}`;
			                    元素.appendChild(newStackEl);
			                }
			            } else {
			                if (堆叠元素) 堆叠元素.remove();
			            }
			            
			            const 名称元素 = 元素.querySelector('.物品名称');
			            if (名称元素) 名称元素.textContent = item.获取名称();
			
			            domItemMap.delete(symbol);
			        } else {
			            元素 = item.生成显示元素();
			            容器.appendChild(元素);
			        }
			    }
			
			    for (const symbolToDelete of domItemMap.keys()) {
			         domItemMap.get(symbolToDelete).remove();
			    }
			
			    document.getElementById("当前容量").textContent = [...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0);
			}
			
			function 初始化装备系统() {
			    const 装备栏元素 = document.querySelector(".装备栏");
			
			    const 处理装备槽点击 = (槽位, 实际槽位编号) => {
			        const 当前物品 = 玩家装备.get(实际槽位编号);
			        if (!当前物品) return;
			
			        if (当前物品 instanceof 卷轴类) {
			            if (当前激活卷轴列表.has(当前物品)) {
			                当前激活卷轴列表.delete(当前物品);
			                当前物品.卸下();
			                const 物品元素 = 槽位.querySelector(".物品条目");
			                if (物品元素) 物品元素.classList.remove("卷轴闪烁");
			                显示通知("已禁用卷轴", "成功");
			            } else {
			                当前激活卷轴列表.add(当前物品);
			                if (当前物品.使用()) {
			                    显示通知("已启用卷轴", "成功");
			                    const 物品元素 =
			                        槽位.querySelector(".物品条目");
			                    if (物品元素)
			                        物品元素.classList.add("卷轴闪烁");
			                } else {
			                    当前激活卷轴列表.delete(当前物品);
			                }
			                更新装备显示();
			            }
			        } else {
			            使用装备槽物品(实际槽位编号);
			        }
			    };
			
			    if ("ontouchstart" in window && 装备栏元素) {
			        装备栏元素.addEventListener(
			            "touchstart",
			            (e) => {
			                触摸起始X = e.touches[0].clientX;
			                触摸移动X = 触摸起始X;
			                装备栏滑动中 = false;
			            },
			            { passive: true }
			        );
			
			        装备栏元素.addEventListener("touchmove", (e) => {
			            if (!触摸起始X) return;
			            触摸移动X = e.touches[0].clientX;
			            const deltaX = 触摸移动X - 触摸起始X;
			            if (Math.abs(deltaX) > 20) {
			                装备栏滑动中 = true;
			            }
			        });
			
			        装备栏元素.addEventListener("touchend", (e) => {
			            if (!触摸起始X || !装备栏滑动中) {
			                触摸起始X = 0;
			                return;
			            }
			            const deltaX = 触摸移动X - 触摸起始X;
			            const 滑动阈值 = 50;
			            if (deltaX < -滑动阈值) {
			                切换装备页(1);
			            } else if (deltaX > 滑动阈值) {
			                切换装备页(-1);
			            }
			            触摸起始X = 0;
			            触摸移动X = 0;
			            装备栏滑动中 = false;
			        });
			
			        装备栏元素.addEventListener("touchcancel", (e) => {
			            触摸起始X = 0;
			            触摸移动X = 0;
			            装备栏滑动中 = false;
			        });
			    }
			

			
			    document.querySelectorAll(".装备槽").forEach((槽位, index) => {
			        const handleTouchEnd = (e) => {
			            if (装备栏滑动中) return;
			            const 实际槽位编号 =
			                当前装备页 * 装备栏每页装备数 + (index + 1);
			            处理装备槽点击(槽位, 实际槽位编号);
			        };
			
			        槽位.addEventListener("touchend", handleTouchEnd);
			        槽位.addEventListener("touchcancel", handleTouchEnd);
			
			        if (!("ontouchstart" in window)) {
			            槽位.addEventListener("contextmenu", (e) => {
			                e.preventDefault();
			                卸下装备槽物品(
			                    当前装备页 * 装备栏每页装备数 + (index + 1)
			                );
			            });
			            槽位.addEventListener("click", (e) => {
			                const 实际槽位编号 =
			                    当前装备页 * 装备栏每页装备数 + (index + 1);
			                处理装备槽点击(槽位, 实际槽位编号);
			            });
			        }
			    });
			}
			function 切换装备页(方向) {
			    const 旧页 = 当前装备页;
			    当前装备页 += 方向;
			
			    let 最高槽位 = 最大背包容量;
			    const 最大有效页 = Math.min(最大装备页-1,Math.max(0, Math.ceil(最高槽位 / 装备栏每页装备数) - 1));
			
			    当前装备页 = Math.max(0, Math.min(当前装备页, 最大有效页));
			
			    if (当前装备页 !== 旧页) {
			        更新装备显示();
			
			        const 装备栏元素 = document.querySelector(".装备栏");
			        if (装备栏元素) {
			            装备栏元素.style.transition = "transform 0.1s ease-out";
			            装备栏元素.style.transform = `translateX(${
			                方向 > 0 ? "-" : ""
			            }5px)`;
			            setTimeout(() => {
			                装备栏元素.style.transform = "";
			            }, 100);
			        }
			    }
			}
			function 更新装备显示() {
			    for (
			        let i = 1 + 当前装备页 * 装备栏每页装备数;
			        i <= 装备栏每页装备数 + 当前装备页 * 装备栏每页装备数;
			        i++
			    ) {
			        const 槽位 = document.getElementById(
			            `装备槽${((i - 1) % 装备栏每页装备数) + 1}`
			        );
			        if (!槽位) continue;
			
			        const 装备物品 = 玩家装备.get(i);
			
			        if (装备物品 && !装备物品.是否隐藏) {
			            const 克隆元素 = 装备物品
			                .生成显示元素("装备")
			                .cloneNode(true);
			            if (window.outerWidth < 770) {
			                克隆元素.style.transform = "scale(0.55)";
			            }
			            克隆元素.classList.remove("active");
			            克隆元素.classList.remove("hover");
			            克隆元素.__物品实例 = 装备物品;
			            克隆元素.removeAttribute("data-quality");
			
			            [
			                "丢弃按钮",
			                "使用按钮",
			                "装备按钮",
			                "上屏按钮",
			            ].forEach((className) => {
			                克隆元素.querySelector(`.${className}`)?.remove();
			            });
			
			            if (
			                装备物品 instanceof 武器类 &&
			                (装备物品.自定义数据.get("冷却剩余") > 0 ||
			                    槽位.querySelector(`.冷却遮罩`))
			            ) {
			                if (槽位.innerHTML === "" || 槽位?.firstChild?.__物品实例!== 装备物品) {
			                    槽位.innerHTML = ""
			                    if (!(装备物品 instanceof 追踪风弹)){
			                    const 耐久标签 = document.createElement("div");
			                    耐久标签.className = "耐久标签";
			                    耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
			                        "耐久"
			                    )}`;
			                    克隆元素.appendChild(耐久标签);
			                    槽位.appendChild(克隆元素);
			                    }
			                }
			                let 遮罩 = 槽位.querySelector(`.冷却遮罩`);
			                if (!遮罩) {
			                    遮罩 = document.createElement("div");
			                }
			                遮罩.className = "冷却遮罩";
			                const 进度 =
			                    1 -
			                    装备物品.自定义数据.get("冷却剩余") /
			                        装备物品.最终冷却回合;
			                遮罩.style.clipPath = `inset(${进度 * 100}% 0 0 0)`;
			                if (!槽位.querySelector(`.冷却遮罩`)) {
			                    槽位.appendChild(遮罩);
			                }
			                if (进度 === 1) {
			                    setTimeout(() => 遮罩.remove(), 220);
			                }
			                continue;
			            }
			            if (
			                装备物品 instanceof 防御装备类 ||
			                (装备物品 instanceof 武器类 &&
			                    !槽位.querySelector(`.冷却遮罩`))
			            ) {
			                if (!(装备物品 instanceof 追踪风弹)){
			                const 耐久标签 = document.createElement("div");
			                耐久标签.className = "耐久标签";
			                耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
			                    "耐久"
			                )}`;
			                克隆元素.appendChild(耐久标签);
			                }
			            }
			            if (
			                装备物品 instanceof 卷轴类 &&
			                当前激活卷轴列表.has(装备物品)
			            ) {
			                克隆元素.classList.add("卷轴闪烁");
			            }
			            if (装备物品 instanceof 宠物) {
			                const 血量标签 = document.createElement("div");
			                血量标签.className = "宠物血量标签";
			                血量标签.textContent = `HP: ${装备物品.自定义数据.get(
			                    "当前生命值"
			                )} / ${装备物品.自定义数据.get("最大生命值")}`;
			                克隆元素.appendChild(血量标签);
			            }
			            槽位.innerHTML = "";
			            槽位.appendChild(克隆元素);
			        } else {
			            槽位.innerHTML = "";
			        }
			    }
			}
			function 怪物放置物品(物品, x, y, 能否拾起 = false) {
			    let 目标X = x;
			    let 目标Y = y;
			    let 可用 = false;
			    if (位置是否可用(目标X, 目标Y, false)) {
			        可用 = true;
			    } else {
			        const 主要方向 = [
			            [0, -1],
			            [0, 1],
			            [-1, 0],
			            [1, 0],
			        ];
			
			        const 次要方向 = [
			            [1, -1],
			            [1, 1],
			            [-1, 1],
			            [-1, -1],
			        ];
			
			        for (const [dx, dy] of 主要方向) {
			            const 新X = x + dx;
			            const 新Y = y + dy;
			
			            if (
			                新X < 0 ||
			                新X >= 地牢大小 ||
			                新Y < 0 ||
			                新Y >= 地牢大小
			            )
			                continue;
			            if (位置是否可用(新X, 新Y)) {
			                目标X = 新X;
			                目标Y = 新Y;
			                可用 = true;
			                break;
			            }
			        }
			
			        if (!可用) {
			            for (const [dx, dy] of 次要方向) {
			                const 新X = x + dx;
			                const 新Y = y + dy;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    continue;
			                if (位置是否可用(新X, 新Y)) {
			                    目标X = 新X;
			                    目标Y = 新Y;
			                    可用 = true;
			                    break;
			                }
			            }
			        }
			    }
			    if (!可用) {
			        添加日志("怪物放置物品：没有可放置的位置");
			        return { x: null, y: null, 新物品: null };
			    }
			    let 放置物品 = 物品;
			    放置物品.堆叠数量 = 1;
			    放置物品.能否拾起 = 能否拾起;
			    放置怪物到单元格(放置物品, 目标X, 目标Y);
			    return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
			}
			
			function 玩家放置物品(物品, 能否拾起 = false) {
			    let 目标X = 玩家.x;
			    let 目标Y = 玩家.y;
			    let 可用 = false;
			    if (位置是否可用(目标X, 目标Y, false)) {
			        可用 = true;
			    } else {
			        const 主要方向 = [
			            [0, -1],
			            [0, 1],
			            [-1, 0],
			            [1, 0],
			        ];
			
			        const 次要方向 = [
			            [1, -1],
			            [1, 1],
			            [-1, 1],
			            [-1, -1],
			        ];
			
			        for (const [dx, dy] of 主要方向) {
			            const 新X = 玩家.x + dx;
			            const 新Y = 玩家.y + dy;
			
			            if (
			                新X < 0 ||
			                新X >= 地牢大小 ||
			                新Y < 0 ||
			                新Y >= 地牢大小
			            )
			                continue;
			            if (位置是否可用(新X, 新Y)) {
			                目标X = 新X;
			                目标Y = 新Y;
			                可用 = true;
			                break;
			            }
			        }
			
			        if (!可用) {
			            for (const [dx, dy] of 次要方向) {
			                const 新X = 玩家.x + dx;
			                const 新Y = 玩家.y + dy;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    continue;
			                if (位置是否可用(新X, 新Y)) {
			                    目标X = 新X;
			                    目标Y = 新Y;
			                    可用 = true;
			                    break;
			                }
			            }
			        }
			    }
			    if (!可用) {
			        添加日志("玩家放置物品：没有可放置的位置");
			        return { x: null, y: null, 新物品: null };
			    }
			    let 放置物品 = 克隆物品(物品);
			    放置物品.堆叠数量 = 1;
			    放置物品.能否拾起 = 能否拾起;
			    放置物品到单元格(放置物品, 目标X, 目标Y);
			    return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
			}
			function 放置怪物到单元格(怪物, x, y) {
			    if (位置是否可用(x, y,false) || (地牢[y][x].类型==单元格类型.物品&&!地牢[y][x].关联物品?.阻碍怪物)) {
			        地牢[y][x].类型 = 单元格类型.怪物;
			        地牢[y][x].关联怪物 = 怪物;
			        怪物.x = x;
			        怪物.y = y;
			        怪物.房间ID = 房间地图[y][x];
			        所有怪物.push(怪物);
			        //绘制();
			        return true;
			    }
			    return false;
			}
			function 刷新房间内容(房间) {
			    添加日志(`房间 ${房间.id} 的气息变得混乱不清...`, "警告");
			    已访问房间.delete(房间.id);
			
			    for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			        for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			            const 单元格 = 地牢[y]?.[x];
			            if (!单元格) continue;
			
			            if (单元格.关联物品) {
			                const 物品实例 = 单元格.关联物品;
			                if (
			                    物品实例 instanceof 钥匙 ||
			                    物品实例.类型 === "楼梯"
			                ) {
			                    continue;
			                }
			
			                所有计时器 = 所有计时器.filter(
			                    (计时器) =>
			                        计时器.唯一标识 !== 物品实例.唯一标识
			                );
			
			                if (玩家背包.has(物品实例.唯一标识)) {
			                    处理销毁物品(物品实例.唯一标识, true);
			                } else {
			                }
			                单元格.关联物品 = null;
			                单元格.类型 = null;
			                单元格.颜色索引 = 颜色表.length;
			            }
			
			            if (单元格.关联怪物) {
			                const 怪物实例 = 单元格.关联怪物;
			
			                所有怪物 = 所有怪物.filter((m) => m !== 怪物实例);
			
			                怪物状态表.delete(怪物实例);
			
			                怪物实例.血条元素?.remove();
			                单元格.关联怪物 = null;
			            }
			        }
			    }
			
			    const 怪物生成层级 = (游戏状态 === '地图编辑器' || 游戏状态 === '编辑器游玩' || 是否是自定义关卡) 
			                    ? (自定义全局设置.诡魅天气怪物层级?? 1) 
			                    : 当前层数;
			
			    const 怪物数量 = Math.floor(prng() * 3) + 1;
			    const 诡魅怪物池 = [];
			    for (let i = 0; i <= 怪物生成层级; i++) {
			        if (怪物引入计划.has(i)) {
			            怪物引入计划.get(i).forEach(怪物定义 => {
			                if (!诡魅怪物池.some(m => m.类.name === 怪物定义.类.name)) {
			                    诡魅怪物池.push(怪物定义);
			                }
			            });
			        }
			    }
			    const 候选怪物 = 诡魅怪物池.filter(m => m.类.name !== "大魔法师");

			    if (候选怪物.length > 0) {
			        for (let i = 0; i < 怪物数量; i++) {
			            const 总权重 = 候选怪物.reduce(
			                (sum, m) => sum + m.权重,
			                0
			            );
			            let 随机值 = prng() * 总权重;
			            let 选中配置 = 候选怪物[0];
			            for (const m of 候选怪物) {
			                if (随机值 <= m.权重) {
			                    选中配置 = m;
			                    break;
			                }
			                随机值 -= m.权重;
			            }
			
			            let 放置成功 = false;
			            for (let 尝试 = 0; 尝试 < 10; 尝试++) {
			                const x =
			                    房间.x + Math.floor(prng() * 房间.w);
			                const y =
			                    房间.y + Math.floor(prng() * 房间.h);
			                if (位置是否可用(x, y, false)) {
			                    const 新怪物 = new 选中配置.类({
			                        x: x,
			                        y: y,
			                        房间ID: 房间.id,
			                        强化: prng() < 0.1,
			                    });
			                    放置怪物到单元格(新怪物, x, y);
			                    放置成功 = true;
			                    break;
			                }
			            }
			        }
			    }
			
			    if (prng() < 0.5) {
			        const 数量 = Math.floor(prng() * (5 + 当前层数)) + 1;
			        放置物品到房间(new 金币({ 数量: 数量 }), 房间);
			    } else if (prng() < 0.3) {
			        生成物品([房间]);
			    }
			}
			function 解谜成功(房间) {
			    for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			        for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			            if (
			                地牢[y][x].类型 === 单元格类型.物品 &&
			                地牢[y][x].关联物品 instanceof 棋子
			            ) {
			                地牢[y][x].类型 = null;
			                地牢[y][x].关联物品 = null;
			            }
			        }
			    }
			    生成奖励(房间);
			    显示通知("解谜成功！获得了丰厚奖励！", "成功");
			    绘制();
			}
			function 检查解谜是否成功(棋子数量) {
			    const 当前房间ID = 房间地图[玩家.y][玩家.x];
			    if (当前房间ID === -1) return false;
			
			    const 当前房间 = 房间列表[当前房间ID];
			    if (当前房间.类型 !== "隐藏解谜棋盘") return false;
			    let 棋子现存数量 = 0;
			    const 棋盘宽度 = 当前房间.w;
			    const 棋盘高度 = 当前房间.h;
			    const 棋盘 = Array(棋盘高度)
			        .fill(null)
			        .map(() => Array(棋盘宽度).fill(0));
			    const 棋子列表 = [];
			
			    for (let y = 当前房间.y; y < 当前房间.y + 当前房间.h; y++) {
			        for (let x = 当前房间.x; x < 当前房间.x + 当前房间.w; x++) {
			            if (
			                地牢[y][x].类型 === 单元格类型.物品 &&
			                地牢[y][x].关联物品 instanceof 棋子 &&
			                地牢[y][x].关联物品.堆叠数量 === 1
			            ) {
			                棋盘[y - 当前房间.y][x - 当前房间.x] =
			                    地牢[y][x].关联物品;
			                棋子列表.push({
			                    x: x - 当前房间.x,
			                    y: y - 当前房间.y,
			                    棋子: 地牢[y][x].关联物品,
			                });
			                棋子现存数量++;
			            }
			        }
			    }
			    if (棋子现存数量 >= 棋子数量) {
			        for (const 棋子信息 of 棋子列表) {
			            const 攻击位置 = 棋子信息.棋子.可攻击位置(
			                棋子信息.x,
			                棋子信息.y,
			                棋盘
			            );
			            for (const 其他棋子信息 of 棋子列表) {
			                if (棋子信息 === 其他棋子信息) continue;
			                if (
			                    攻击位置.some(
			                        (pos) =>
			                            pos.x === 其他棋子信息.x &&
			                            pos.y === 其他棋子信息.y
			                    )
			                ) {
			                    return false;
			                }
			            }
			        }
			
			        解谜成功(当前房间);
			        return true;
			    }
			    return false;
			}
			function 生成解谜棋盘(房间) {
			    const 棋盘大小 = Math.min(房间.w, 房间.h);
			    const 棋盘 = Array(棋盘大小)
			        .fill(null)
			        .map(() => Array(棋盘大小).fill(0));
			    const 棋子种类 = {
			        A: [国际象棋车, 国际象棋象],
			        B: [国际象棋马, 中国象棋炮],
			    };
			
			    const 首个棋子层级 = prng() < 0.6 ? "A" : "B";
			    const 首个棋子类 =
			        棋子种类[首个棋子层级][
			            Math.floor(
			                prng() * 棋子种类[首个棋子层级].length
			            )
			        ];
			    棋盘[0][0] = new 首个棋子类({});
			
			    for (let y = 0; y < 棋盘大小; y++) {
			        for (let x = 0; x < 棋盘大小; x++) {
			            if (x === 0 && y === 0) continue;
			            if (棋盘[y][x]) continue;
			
			            let 当前层级 = "A";
			            while (当前层级) {
			                const 可放置棋子 = [];
			                for (const 棋子类 of 棋子种类[当前层级]) {
			                    if (可以放置(x, y, 棋子类, 棋盘)) {
			                        可放置棋子.push(棋子类);
			                    }
			                }
			
			                if (可放置棋子.length > 0) {
			                    const 权重 = 可放置棋子.map((棋子类) => {
			                        const 威胁数 = 计算新增威胁格子数(
			                            x,
			                            y,
			                            棋子类,
			                            棋盘
			                        );
			                        return 1 / (威胁数 + 1);
			                    });
			
			                    const 最小权重 = Math.min(...权重);
			
			                    if (当前层级 === "A") {
			                        可放置棋子.push("下一层");
			                        权重.push(最小权重);
			                    }
			
			                    const 总权重 = 权重.reduce(
			                        (sum, w) => sum + w,
			                        0
			                    );
			                    let 随机数 = prng() * 总权重;
			                    let 选中棋子类 = null;
			                    for (let i = 0; i < 可放置棋子.length; i++) {
			                        if (随机数 < 权重[i]) {
			                            选中棋子类 = 可放置棋子[i];
			                            break;
			                        }
			                        随机数 -= 权重[i];
			                    }
			
			                    if (选中棋子类) {
			                        if (选中棋子类 === "下一层") {
			                            当前层级 = "B";
			                        } else {
			                            棋盘[y][x] = new 选中棋子类({});
			                            break;
			                        }
			                    }
			                } else {
			                    if (当前层级 === "A") {
			                        当前层级 = "B";
			                    } else {
			                        break;
			                    }
			                }
			            }
			        }
			    }
			    const 棋子 = [];
			    房间.棋子数量 = 0;
			    for (let i = 0; i < 棋盘大小; i++) {
			        for (let j = 0; j < 棋盘大小; j++) {
			            if (棋盘[j][i]) {
			                棋子.push(棋盘[j][i]);
			            }
			        }
			    }
			    棋子.forEach((棋子) => {
			        放置物品到房间(棋子, 房间);
			        房间.棋子数量++;
			    });
			    return { 棋盘 };
			}
			
			function 可以放置(x, y, 棋子类, 棋盘) {
			    if (棋盘[y][x]) return false;
			
			    for (let i = 0; i < 棋盘.length; i++) {
			        for (let j = 0; j < 棋盘[i].length; j++) {
			            const 已放置棋子 = 棋盘[j][i];
			            if (已放置棋子) {
			                const 攻击位置 = 已放置棋子.可攻击位置(i, j, 棋盘);
			                if (
			                    攻击位置.some(
			                        (pos) => pos.x === x && pos.y === y
			                    )
			                ) {
			                    return false;
			                }
			            }
			        }
			    }
			
			    const 临时棋盘 = 棋盘.map((row) =>
			        row.map((cell) => (cell ? new cell.constructor() : null))
			    );
			    临时棋盘[y][x] = new 棋子类();
			    const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(
			        x,
			        y,
			        临时棋盘
			    );
			    for (let i = 0; i < 棋盘.length; i++) {
			        for (let j = 0; j < 棋盘.length; j++) {
			            if (临时棋盘[j][i] && (i !== x || j !== y)) {
			                if (
			                    新棋子攻击位置.some(
			                        (pos) => pos.x === i && pos.y === j
			                    )
			                ) {
			                    return false;
			                }
			            }
			        }
			    }
			
			    for (let i = 0; i < 棋盘.length; i++) {
			        for (let j = 0; j < 棋盘.length; j++) {
			            if (临时棋盘[j][i] instanceof 中国象棋炮) {
			                const 炮的攻击位置 = 临时棋盘[j][i].可攻击位置(
			                    i,
			                    j,
			                    临时棋盘
			                );
			                for (let m = 0; m < 棋盘.length; m++) {
			                    for (let n = 0; n < 棋盘.length; n++) {
			                        if (
			                            临时棋盘[n][m] &&
			                            (m !== i || n !== j)
			                        ) {
			                            if (
			                                炮的攻击位置.some(
			                                    (pos) =>
			                                        pos.x === m && pos.y === n
			                                )
			                            ) {
			                                return false;
			                            }
			                        }
			                    }
			                }
			            }
			        }
			    }
			    return true;
			}
			
			function 计算新增威胁格子数(x, y, 棋子类, 棋盘) {
			    const 临时棋盘 = 棋盘.map((row) =>
			        row.map((cell) => (cell ? new cell.constructor() : null))
			    );
			    临时棋盘[y][x] = new 棋子类();
			    const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(
			        x,
			        y,
			        临时棋盘
			    );
			
			    let 新增威胁数 = 0;
			
			    for (let i = 0; i < 棋盘.length; i++) {
			        for (let j = 0; j < 棋盘[i].length; j++) {
			            if (临时棋盘[j][i] === null) {
			                if (
			                    新棋子攻击位置.some(
			                        (pos) => pos.x === i && pos.y === j
			                    ) ||
			                    !可以放置(i, j, 棋子类, 临时棋盘)
			                ) {
			                    新增威胁数++;
			                }
			            }
			        }
			    }
			    return 新增威胁数;
			}
			
			        function 显示通知(内容, 类型 = "信息", 强制显示 = false, 持续时间 = 1500) {
			添加日志(内容, 类型);
			if (!是否显示通知 && !强制显示) {
			    return;
			}
			
			const 容器 = document.querySelector(".通知容器") || document.createElement("div");
			if (!document.body.contains(容器)) {
			    容器.className = "通知容器";
			    document.body.appendChild(容器);
			}
			
			const 最大通知数 = 2;
			
			// 当通知数量达到或超过上限时，立即移除最旧的通知
			while (容器.children.length >= 最大通知数) {
			    const 待移除通知 = Array.from(容器.children).find(n => !n.classList.contains('持久'));
			    if (待移除通知) {
			        clearTimeout(待移除通知._timer); // 清除其自动消失的计时器
			        待移除通知.remove(); // 立即从DOM中移除
			    } else {
			        // 如果所有通知都是持久性的，则无法添加新通知
			        console.warn("无法显示新通知，因为所有可见通知都是持久性的。");
			        return;
			    }
			}
			
			const 图标表 = {
			    信息: "ℹ️",
			    成功: 图标映射.成功,
			    警告: "⚠️",
			    错误: 图标映射.错误,
			};
			const 通知 = document.createElement("div");
			通知.className = `通知条目 ${类型}`;
			if(强制显示) 通知.classList.add('持久');
			
			通知.innerHTML = `
			    <span class="通知图标">${图标表[类型]}</span>
			    <span class="通知内容">${内容}</span>
			    <button class="关闭按钮">×</button>
			`;//其实这里也可以xss注入...
			
			通知.querySelector('.关闭按钮').addEventListener('click', () => {
			    if (通知._timer) clearTimeout(通知._timer);
			    隐藏通知(通知);
			});
			
			
			    通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
			    通知.addEventListener('mouseenter', () => clearTimeout(通知._timer));
			    通知.addEventListener('mouseleave', () => {
			        通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
			    });
			
			
			容器.appendChild(通知);
			        }
			
			function 生成天气效果() {
			    当前天气效果 = [];
			
			    const 乱序天气列表 = [...所有天气列表].sort(
			        () => prng() - 0.5
			    );
			
			    const 要选择的数量 =
			        prng() < 0.5 ? 1 : Math.min(2, 乱序天气列表.length);
			
			    当前天气效果 = 乱序天气列表.slice(0, 要选择的数量);
			
			    if (当前天气效果.includes("深夜")) {
			        显示通知("夜幕降临，周围变得一片漆黑...", "警告");
			    }
			    if (当前天气效果.includes("雷暴")) {
			        显示通知("乌云密布，雷声滚滚...", "警告");
			    }
			    if (当前天气效果.includes("大风")) {
			        显示通知("狂风呼啸，站稳脚跟！", "警告");
			    }
			    if (当前天气效果.includes("严寒")) {
			        显示通知("严冬将至...", "警告");
			    }
			    if (当前天气效果.includes("诡魅")) {
			        显示通知(
			            "空气中弥漫着诡异的气息，你的感知似乎受到了干扰...",
			            "警告"
			        );
			    }
			}
			function 放置巨人(巨人实例, x, y) {
			    const 区域 = [
			        {x: x, y: y},
			        {x: x + 1, y: y},
			        {x: x, y: y + 1},
			        {x: x + 1, y: y + 1}
			    ];
			
			    for (const 位置 of 区域) {
			        if (!位置是否可用(位置.x, 位置.y, false)) {
			            return false; 
			        }
			    }
			    
			    巨人实例.保存新位置类型(x, y);
			    放置怪物到单元格(巨人实例, x, y);
			    巨人实例.部位列表.forEach((部位, 索引) => {
			        const 偏移 = 巨人实例.部位偏移[索引];
			        放置怪物到单元格(部位, x + 偏移.dx, y + 偏移.dy);
			    });
			    
			    return true;
			}
			function 处理诡魅房间刷新(旧玩家X, 旧玩家Y, 玩家X, 玩家Y) {
			    const 旧视野房间ID集合 = 获取视野内房间ID(旧玩家X, 旧玩家Y);
			    const 新视野房间ID集合 = 获取视野内房间ID(玩家X, 玩家Y);
			    房间列表.forEach((房间) => {
			        if (
			            房间.类型?.slice(0, 2) === "隐藏" ||
			            !已访问房间.has(房间.id) ||
			            新视野房间ID集合.has(房间.id) ||
			            房间.id === 0
			        ) {
			            return;
			        }
			        if (旧视野房间ID集合.has(房间.id)) {
			            刷新房间内容(房间);
			        }
			    });
			}
			
			function 获取视野内房间ID(中心X, 中心Y) {
			    const 视野范围 = 获取玩家视野范围() + 2;
			    const 房间ID集合 = new Set();
			    const 检查范围 = 视野范围;
			
			    for (let dy = -检查范围; dy <= 检查范围; dy++) {
			        for (let dx = -检查范围; dx <= 检查范围; dx++) {
			            const 检查X = 中心X + dx;
			            const 检查Y = 中心Y + dy;
			
			            if (
			                检查X >= 0 &&
			                检查X < 地牢大小 &&
			                检查Y >= 0 &&
			                检查Y < 地牢大小
			            ) {
			                const 距离 = Math.abs(dx) + Math.abs(dy);
			                if (距离 <= 视野范围) {
			                    const 房间ID = 房间地图[检查Y][检查X];
			                    if (房间ID !== -1) {
			                        房间ID集合.add(房间ID);
			                    }
			                }
			            }
			        }
			    }
			    return 房间ID集合;
			}
			
			
			function 隐藏通知(通知元素) {
			    if (!通知元素 || !通知元素.parentElement) return;
			
			    通知元素.classList.add("离场");
			    通知元素.addEventListener("animationend", () => {
			        通知元素.remove();
			
			        const 容器 = document.querySelector(".通知容器");
			        if (容器 && 容器.children.length === 0) {
			            容器.remove();
			        }
			    });
			}
			function 添加日志(内容, 类型 = "信息") {
			    const 时间戳 = new Date().toLocaleTimeString();
			    const 条目 = document.createElement("div");
			    条目.className = `日志条目 ${类型}`;
			    条目.innerHTML = `<span class="日志时间">[${时间戳}]</span> ${内容}`;
			
			    document.getElementById("logContent").appendChild(条目);
			
			    条目.scrollIntoView({ behavior: "smooth" });
			    日志历史.push({ 时间戳, 内容, 类型 });
			}
			function 收纳通知() {
			    是否显示通知 = !是否显示通知;
			    let 按钮 = document.querySelector(
			        "#设置菜单 button:nth-child(2)"
			    );
			    if (是否显示通知) {
			        按钮.innerHTML = "收纳通知";
			        显示通知("已重新显示通知", "信息");
			        按钮.textContent = "收纳通知";
			    } else {
			        按钮.innerHTML = "显示通知";
			        显示通知("已将通知收纳入日志中", "信息");
			        按钮.textContent = "显示通知";
			    }
			}
			
			function 关闭重铸界面() {
			    const 遮罩 = window.当前重铸遮罩;
			    if (!遮罩) return;
			
			    const 弹窗 = 遮罩.querySelector(".重铸弹窗");
			    if (!弹窗) return;
			
			    弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
			    弹窗.style.opacity = 0;
			
			    弹窗.querySelectorAll(".重铸物品").forEach((el) => {
			        el.__物品实例 = null;
			    });
			
			    setTimeout(() => {
			        遮罩.remove();
			        window.当前重铸遮罩 = null
			        window.当前重铸台 = null;
			        更新背包显示();
			        玩家属性.允许移动 -= 1;
			    }, 300);
			}
			function 显示修复界面(修复台实例) {
			 if (界面可见性.背包) 切换背包显示();
			 玩家属性.允许移动++;
			
			 const 遮罩 = document.createElement("div");
			 遮罩.id = "repairOverlay";
			 遮罩.className = "重铸遮罩";
			
			 const 弹窗 = document.createElement("div");
			 弹窗.id = "repairWindow";
			 弹窗.className = "重铸弹窗";
			 弹窗.innerHTML = `
			     <div class="重铸弹窗-header">
			         <h3>装备修复 (修复台耐久: ${修复台实例.自定义数据.get("耐久")}/${修复台实例.自定义数据.get("最大耐久")})</h3>
			         <button class="关闭按钮" id="closeRepairBtn">×</button>
			     </div>
			     <div id="repairableItemsContainer" class="重铸弹窗-items" style="max-height: 60vh;">
			         <!-- 物品们排排站 -->
			     </div>
			     <div class="交易底部" style="justify-content: space-around; padding-top: 15px; border-top: 1px solid #444;">
			         <span>修复费用: <span id="repairCostDisplay" style="color: var(--yellow); font-weight: bold;">-</span> 金币</span>
			         <button id="executeRepairBtn" class="菜单按钮" style="min-width: 150px;">修复选中装备</button>
			     </div>
			 `;
			
			 遮罩.appendChild(弹窗);
			 document.body.appendChild(遮罩);
			
			 const 物品列表容器 = document.getElementById('repairableItemsContainer');
			 const 费用显示 = document.getElementById('repairCostDisplay');
			 let 已选物品元素 = null;
			
			 const 填充可修复物品 = () => {
			     物品列表容器.innerHTML = '';
			     const 可修复物品 = [...玩家背包.values(), ...玩家装备.values()].filter(item =>
			         item && (item instanceof 武器类 || item instanceof 防御装备类) &&
			         item.自定义数据.has('耐久') && item.自定义数据.has('原耐久') &&
			         item.自定义数据.get('耐久') < item.自定义数据.get('原耐久') &&
			         !item.自定义数据.get('不可破坏')
			     );
			
			     if (可修复物品.length === 0) {
			         物品列表容器.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">没有需要修复的装备。</p>';
			         return;
			     }
			
			     可修复物品.forEach(item => {
			         const 元素 = document.createElement("div");
			         元素.className = "重铸物品"; // 复用样式
			         元素.innerHTML = `
			             ${item.强化 ? '<div class="重铸台强化标识">★</div>' : ""}
			             <div class="物品图标">${item.图标}</div>
			             <div class="物品名称">${item.名称}</div>
			             <div class="重铸台耐久标签">耐久 ${item.自定义数据.get("耐久")}/${item.自定义数据.get("原耐久")}</div>
			         `;
			         元素.__物品实例 = item;
			         元素.onclick = () => {
			             if (已选物品元素) {
			                 已选物品元素.classList.remove('selected');
			             }
			             元素.classList.add('selected');
			             已选物品元素 = 元素;
			             const cost = 修复台实例.计算修复消耗(item);
			             费用显示.textContent = cost;
			         };
			         物品列表容器.appendChild(元素);
			     });
			 };
			
			 填充可修复物品();
			
			 document.getElementById('closeRepairBtn').onclick = 关闭修复界面;
			 document.getElementById('executeRepairBtn').onclick = () => 执行修复(修复台实例);
			 
			 // 动画效果
			 遮罩.style.display = 'block';
			 requestAnimationFrame(() => {
			     弹窗.style.opacity = 1;
			     弹窗.style.transform = "translate(-50%, -50%) scale(1)";
			 });
			}
			
			function 关闭修复界面() {
			 const 遮罩 = document.getElementById("repairOverlay");
			 if (!遮罩) return;
			
			 const 弹窗 = 遮罩.querySelector(".重铸弹窗");
			 if (弹窗) {
			     弹窗.style.opacity = 0;
			     弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
			 }
			
			 setTimeout(() => {
			     遮罩.remove();
			     玩家属性.允许移动--;
			     玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
			 }, 300);
			}
			
			function 执行修复(修复台实例) {
			 const 选中元素 = document.querySelector("#repairableItemsContainer .selected");
			 if (!选中元素) {
			     显示通知("请先选择一件需要修复的装备！", "错误");
			     return;
			 }
			
			 const 待修复物品 = 选中元素.__物品实例;
			 const 修复费用 = 修复台实例.计算修复消耗(待修复物品);
			 if (待修复物品 instanceof 时空罗盘) {
			    显示通知("该物品无法被修复。", "信息");
			    return;
			 }
			 if (修复费用 <= 0) {
			     显示通知("该物品无需修复。", "信息");
			     return;
			 }
			 
			 if (!扣除金币(修复费用)) {
			     显示通知(`金币不足！需要 ${修复费用} 金币。`, "错误");
			     return;
			 }
			
			 const 剩余耐久 = 修复台实例.自定义数据.get("耐久") - 1;
			 修复台实例.自定义数据.set("耐久", 剩余耐久);
			 修复台实例.效果描述 = `消耗金币，可将一件装备/武器的耐久完全修复。\n剩余使用次数：${剩余耐久}/${修复台实例.自定义数据.get("最大耐久")}`;
			
			 待修复物品.自定义数据.set('耐久', 待修复物品.自定义数据.get('原耐久'));
			
			 显示通知(`成功修复 ${待修复物品.获取名称()}，花费了 ${修复费用} 金币！`, "成功");
			 
			 关闭修复界面();
			 更新背包显示();
			 更新装备显示();
			}
			function 执行重铸() {
			    const 源元素 = document.querySelector("#sourceItems .selected");
			    const 材料元素 = document.querySelector(
			        "#materialItems .selected"
			    );
			
			    const 源物品 = 源元素?.__物品实例;
			    const 材料物品 = 材料元素?.__物品实例;
			
			    if (!源物品 || !材料物品) {
			        显示通知("需要选择两个有效装备", "错误");
			        return;
			    }
			    if (源物品 === 材料物品) {
			        显示通知("需要选择两个不同装备", "错误");
			        return;
			    }
			    if (源物品.名称 !== 材料物品.名称) {
			        显示通知("装备名称不一致", "错误");
			        return;
			    }
			
			    const 当前耐久 = 源物品.自定义数据.get("耐久");
			    const 最大耐久 = 源物品.自定义数据.get("原耐久");
			    const 可用空间 = 最大耐久 - 当前耐久;
			    const 可转移量 = Math.min(
			        材料物品.自定义数据.get("耐久"),
			        可用空间
			    );
			
			    if (可转移量 <= 0) {
			        显示通知(
			            可用空间 <= 0 ? "目标已满耐久" : "材料无可用耐久",
			            "错误"
			        );
			        return;
			    }
			    const 消耗金币 = 当前重铸台.计算消耗(源物品, 材料物品);
			    if (!扣除金币(消耗金币)) {
			        显示通知("金币不足！", "错误");
			        return false;
			    }
			
			    源物品.自定义数据.set("耐久", 当前耐久 + 可转移量);
			    处理销毁物品(材料物品.唯一标识, true);
			
			    const 剩余耐久 = 当前重铸台.自定义数据.get("耐久") - 1;
			    当前重铸台.自定义数据.set("耐久", 剩余耐久);
			    当前重铸台.效果描述 = `将同名装备的耐久融合\n剩余耐久：${剩余耐久}/${当前重铸台.自定义数据.get(
			        "最大耐久"
			    )}`;
			
			    显示通知(`消耗 ${消耗金币} 金币成功修复！`, "成功");
			    关闭重铸界面();
			}
			function 扣除金币(数量) {
			    const 可用金币总量 = [...玩家背包.values()]
			        .filter(
			            (i) =>
			                i instanceof 金币 && !i.是否隐藏 && i.堆叠数量 > 0
			        )
			        .reduce((sum, i) => sum + i.堆叠数量, 0);
			
			    if (可用金币总量 < 数量) {
			        return false;
			    }
			
			    const 可见金币列表 = [...玩家背包.values()].filter(
			        (i) => i instanceof 金币 && !i.是否隐藏 && i.堆叠数量 > 0
			    );
			
			    let 剩余扣除 = 数量;
			
			    for (const 金币实例 of 可见金币列表) {
			        if (剩余扣除 === 0) break;
			        const 本次可扣除 = Math.min(金币实例.堆叠数量, 剩余扣除);
			        金币实例.堆叠数量 -= 本次可扣除;
			        剩余扣除 -= 本次可扣除;
			
			        if (金币实例.堆叠数量 === 0) {
			            玩家背包.delete(金币实例.唯一标识);
			        }
			    }
			    return 剩余扣除 === 0;
			}
			
			function 触发扣血特效() {
			    const 特效 = document.getElementById("扣血特效");
			    特效.style.animation = "none";
			    特效.offsetHeight;
			    特效.style.animation = "扣血脉冲 0.8s ease-out";
			}
			
			let 指示器缓存 = new Map();
			
			function 计算精确边缘位置(怪物) {
			    const 画布 = document.getElementById("dungeonCanvas");
			    const 画布Rect = 画布.getBoundingClientRect();
			
			    const 视口左边界 = 当前相机X;
			    const 视口右边界 =
			        当前相机X + Math.floor(画布Rect.width / 单元格大小) - 1;
			    const 视口上边界 = 当前相机Y;
			    const 视口下边界 =
			        当前相机Y + Math.floor(画布Rect.height / 单元格大小) - 1;
			
			    if (
			        怪物.x >= 视口左边界 &&
			        怪物.x <= 视口右边界 &&
			        怪物.y >= 视口上边界 &&
			        怪物.y <= 视口下边界
			    ) {
			        return null;
			    }
			
			    const 玩家像素X =
			        (玩家.x - 当前相机X) * 单元格大小 + 单元格大小 / 2;
			    const 玩家像素Y =
			        (玩家.y - 当前相机Y) * 单元格大小 + 单元格大小 / 2;
			
			    const dx =
			        (怪物.x - 当前相机X) * 单元格大小 +
			        单元格大小 / 2 -
			        玩家像素X;
			    const dy =
			        (怪物.y - 当前相机Y) * 单元格大小 +
			        单元格大小 / 2 -
			        玩家像素Y;
			
			    // 计算射线方向向量
			    const 方向长度 = Math.sqrt(dx * dx + dy * dy);
			    if (方向长度 === 0) return null;
			    const dirX = dx / 方向长度;
			    const dirY = dy / 方向长度;
			
			    // 计算与画布边界的交点（使用视口实际尺寸）
			    const 画布左 = 0;
			    const 画布右 = 画布Rect.width;
			    const 画布上 = 0;
			    const 画布下 = 画布Rect.height;
			
			    let t = Infinity;
			
			    if (dirX < 0) {
			        const tLeft = (画布左 - 玩家像素X) / dirX;
			        const y = 玩家像素Y + dirY * tLeft;
			        if (y >= 画布上 && y <= 画布下) t = tLeft;
			    }
			
			    if (dirX > 0) {
			        const tRight = (画布右 - 玩家像素X) / dirX;
			        const y = 玩家像素Y + dirY * tRight;
			        if (y >= 画布上 && y <= 画布下) t = Math.min(t, tRight);
			    }
			
			    if (dirY < 0) {
			        const tTop = (画布上 - 玩家像素Y) / dirY;
			        const x = 玩家像素X + dirX * tTop;
			        if (x >= 画布左 && x <= 画布右) t = Math.min(t, tTop);
			    }
			
			    if (dirY > 0) {
			        const tBottom = (画布下 - 玩家像素Y) / dirY;
			        const x = 玩家像素X + dirX * tBottom;
			        if (x >= 画布左 && x <= 画布右) t = Math.min(t, tBottom);
			    }
			
			    if (t === Infinity) return null;
			
			    // 计算最终交点位置（页面坐标）
			    return {
			        x: 玩家像素X + dirX * t + 画布Rect.left,
			        y: 玩家像素Y + dirY * t + 画布Rect.top,
			    };
			}
			
			function 更新物体指示器() {
			    const 容器 = document.getElementById("怪物指示器容器");
			    const 可见怪物 = new Set();

			    所有怪物.forEach((怪物, index) => {
			        if (怪物.状态 !== 怪物状态.活跃) return;
			        if (!怪物.追击玩家中) return;
			        if (怪物 instanceof 巨人部位 || 怪物 instanceof 蜈蚣部位) return;
			
			        const 位置 = 计算精确边缘位置(怪物);
			        if (!位置) {
			            if (指示器缓存.has(index))
			                指示器缓存.get(index).remove();
			            return;
			        }
			
			        let 指示器 = 指示器缓存.get(index);
			        if (!指示器) {
			            指示器 = document.createElement("div");
			            指示器.className = "怪物指示器";
			            容器.appendChild(指示器);
			            指示器缓存.set(index, 指示器);
			        }
			
			        指示器.style.transform = `translate(${位置.x}px, ${位置.y}px)`;
			        可见怪物.add(index);
			    });
			
			    指示器缓存.forEach((指示器, key) => {
			        if (!可见怪物.has(key)) {
			            指示器.remove();
			            指示器缓存.delete(key);
			        }
			    });
			    const 玩家寻宝戒指列表 = Array.from(
			        { length: 装备栏每页装备数 },
			        (_, i) =>
			            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			    )
			        .filter((v) => v != null)
			        .filter((item) => item instanceof 寻宝戒指);
			    let 玩家寻宝戒指 = null;
			    if (玩家寻宝戒指列表) {
			        玩家寻宝戒指 = 玩家寻宝戒指列表.find(
			            (item) => item.自定义数据.get("生效层数") === 当前层数
			        );
			    } else {
			        const 指示器 = document.querySelector(".折跃门指示器");
			        if (指示器) {
			            指示器.style.display = "none";
			        }
			    }
			    if (玩家寻宝戒指) {
			        const 折跃门位置 =
			            玩家寻宝戒指.自定义数据.get("折跃门位置");
			        if (折跃门位置) {
			            const 屏幕位置 = 计算精确边缘位置({
			                x: 折跃门位置.x,
			                y: 折跃门位置.y,
			            });
			
			            let 指示器 = document.querySelector(".折跃门指示器");
			            if (!指示器) {
			                指示器 = document.createElement("div");
			                指示器.className = "怪物指示器 折跃门指示器";
			                指示器.style.background = "gold";
			                指示器.style.boxShadow = "0 0 8px gold";
			                容器.appendChild(指示器);
			            }
			            if (屏幕位置) {
			                指示器.style.transform = `translate(${屏幕位置.x}px, ${屏幕位置.y}px)`;
			                指示器.style.display = "block";
			            } else {
			                指示器.style.display = "none";
			            }
			        } else {
			            const 指示器 = document.querySelector(".折跃门指示器");
			            if (指示器) {
			                指示器.style.display = "none";
			            }
			        }
			    } else {
			        const 指示器 = document.querySelector(".折跃门指示器");
			        if (指示器) {
			            指示器.style.display = "none";
			        }
			    }

			    const 玩家定位器地图 = Array.from(玩家装备.values()).find(item => item instanceof 定位器地图);
			    let 楼梯指示器 = document.querySelector(".楼梯指示器");

			    if (玩家定位器地图) {
			        let 楼梯位置 = null;
			        for (let y = 0; y < 地牢大小; y++) {
			            for (let x = 0; x < 地牢大小; x++) {
			                if (地牢[y]?.[x]?.类型 === 单元格类型.楼梯下楼) {
			                    楼梯位置 = { x, y };
			                    break;
			                }
			            }
			            if (楼梯位置) break;
			        }

			        if (楼梯位置) {
			            const 屏幕位置 = 计算精确边缘位置(楼梯位置);
			            if (!楼梯指示器) {
			                楼梯指示器 = document.createElement("div");
			                楼梯指示器.className = "怪物指示器 楼梯指示器";
			                楼梯指示器.style.background = "#2196f3";
			                楼梯指示器.style.boxShadow = "0 0 8px #2196f3";
			                容器.appendChild(楼梯指示器);
			            }
			            
			            if (屏幕位置) {
			                楼梯指示器.style.transform = `translate(${屏幕位置.x}px, ${屏幕位置.y}px)`;
			                楼梯指示器.style.display = "block";
			            } else {
			                楼梯指示器.style.display = "none";
			            }
			        } else if (楼梯指示器) {
			            楼梯指示器.style.display = "none";
			        }
			    } else if (楼梯指示器) {
			        楼梯指示器.style.display = "none";
			    }
			}
			function hexToRgba(hex, alpha) {
			    let r = parseInt(hex.slice(0, 2), 16),
			        g = parseInt(hex.slice(2, 4), 16),
			        b = parseInt(hex.slice(4, 6), 16);
			
			    if (alpha) {
			        return (
			            "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")"
			        );
			    } else {
			        return "rgb(" + r + ", " + g + ", " + b + ")";
			    }
			}
			// Hex转RGB
			function hexToRgb(hex) {
			    hex = hex.replace(/^#/, "");
			    if (hex.length === 3) {
			        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
			    }
			    const num = parseInt(hex, 16);
			    return [(num >> 16) & 0xff, (num >> 8) & 0xff, num & 0xff];
			}
			function blendColors(hexArray) {
			    if (hexArray.length === 0) return "#000000"; // 处理空数组情况
			
			    // RGB转HSL
			    function rgbToHsl(r, g, b) {
			        (r /= 255), (g /= 255), (b /= 255);
			        const max = Math.max(r, g, b),
			            min = Math.min(r, g, b);
			        let h,
			            s,
			            l = (max + min) / 2;
			
			        if (max === min) {
			            h = s = 0;
			        } else {
			            const d = max - min;
			            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			            switch (max) {
			                case r:
			                    h = (g - b) / d + (g < b ? 6 : 0);
			                    break;
			                case g:
			                    h = (b - r) / d + 2;
			                    break;
			                case b:
			                    h = (r - g) / d + 4;
			                    break;
			            }
			            h *= 60;
			        }
			        return [h, s, l];
			    }
			
			    // HSL转RGB
			    function hslToRgb(h, s, l) {
			        let r, g, b;
			        if (s === 0) {
			            r = g = b = l; // 灰色
			        } else {
			            const hue2rgb = (p, q, t) => {
			                if (t < 0) t += 1;
			                if (t > 1) t -= 1;
			                if (t < 1 / 6) return p + (q - p) * 6 * t;
			                if (t < 1 / 2) return q;
			                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
			                return p;
			            };
			            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
			            const p = 2 * l - q;
			            r = hue2rgb(p, q, h / 360 + 1 / 3);
			            g = hue2rgb(p, q, h / 360);
			            b = hue2rgb(p, q, h / 360 - 1 / 3);
			        }
			        return [
			            Math.round(r * 255),
			            Math.round(g * 255),
			            Math.round(b * 255),
			        ];
			    }
			
			    // RGB转Hex
			    function rgbToHex(r, g, b) {
			        return (
			            "#" +
			            [r, g, b]
			                .map((x) => {
			                    const hex = x.toString(16);
			                    return hex.length === 1 ? "0" + hex : hex;
			                })
			                .join("")
			        );
			    }
			
			    // 处理每个Hex颜色
			    const hslArray = hexArray.map((hex) => {
			        const [r, g, b] = hexToRgb(hex);
			        return rgbToHsl(r, g, b);
			    });
			
			    // 计算平均H（向量平均）
			    let sumSin = 0,
			        sumCos = 0;
			    for (const [h] of hslArray) {
			        const radians = (h * Math.PI) / 180;
			        sumSin += Math.sin(radians);
			        sumCos += Math.cos(radians);
			    }
			    const avgH =
			        (Math.atan2(
			            sumSin / hexArray.length,
			            sumCos / hexArray.length
			        ) *
			            180) /
			        Math.PI;
			    const normalizedH = (avgH + 360) % 360; // 确保在0-360度之间
			
			    // 计算平均S和L
			    const avgS =
			        hslArray.reduce((sum, [, s]) => sum + s, 0) /
			        hexArray.length;
			    const avgL =
			        hslArray.reduce((sum, [, , l]) => sum + l, 0) /
			        hexArray.length;
			
			    // 转换回RGB并转为Hex
			    const [r, g, b] = hslToRgb(normalizedH, avgS, avgL);
			    return rgbToHex(r, g, b);
			}
			function 打开收购窗口(npc) {
			    if (界面可见性.背包) 切换背包显示();
			    玩家属性.允许移动 += 1;
			    NPC互动中 = true; // 标记互动中
			    当前NPC = npc; // 保存当前NPC引用
			
			    const 窗口 = document.getElementById("收购窗口");
			    const 需求列表容器 = document.getElementById("收购需求列表");
			    const 玩家列表容器 = document.getElementById("玩家可售列表");
			    const 金币显示 = document.getElementById("收购窗口金币");
			
			    需求列表容器.innerHTML = "";
			    玩家列表容器.innerHTML = "";
			
			    金币显示.textContent = [...玩家背包.values()]
			        .filter((i) => i instanceof 金币)
			        .reduce((sum, i) => sum + i.堆叠数量, 0);
			
			    // 显示收购需求
			    const 需求 = npc.自定义数据.get("收购需求") || [];
			    需求.forEach((req) => {
			        const 元素 = document.createElement("div");
			        元素.className = "收购需求条目";
			        元素.innerHTML = `
			         <span class="需求图标" style="color:${
			             物品池[
			                 Object.keys(物品池).find((key) =>
			                     物品池[key].some(
			                         (item) => item.类.name === req.类名
			                     )
			                 )
			             ]?.find((item) => item.类.name === req.类名)?.类
			                 ?.prototype?.颜色表?.[req.颜色索引] ?? "#FFF"
			         }">${req.图标}</span>
			         <span class="需求名称">${req.名称}${
			            req.强化需求 ? " [强]" : ""
			        } </span>
			         <span class="需求价格">??? 金币</span> <!-- 价格在点击玩家物品时计算 -->
			     `;
			        需求列表容器.appendChild(元素);
			    });
			
			    // 显示玩家可出售物品
			    玩家背包.forEach((item) => {
			        // 检查是否满足任一收购需求
			        const 匹配需求 = 需求.find(
			            (req) =>
			                item.名称 === req.名称 &&
			                (req.强化需求 ? item.强化 === true : true) // 强化需求匹配
			        );
			
			        if (匹配需求) {
			            const 价格 = npc.计算收购价格(item, 匹配需求);
			            if (价格 > 0) {
			                // 价格为0表示不满足强化需求等硬性条件
			                const 元素 = document.createElement("div");
			                元素.className = "玩家可售条目";
			                元素.innerHTML = `
			                <span class="物品图标" style="color:${
			                    item.颜色表[item.颜色索引] ?? "#FFF"
			                }">${item.图标}</span>
			                <span class="物品名称">${item.获取名称()} ${
			                    item.堆叠数量 > 1 ? `x${item.堆叠数量}` : ""
			                }</span>
			                <span class="出售价格">${价格} 金币</span>
			            `;
			                元素.onclick = () => 尝试出售(item, 价格, npc);
			                玩家列表容器.appendChild(元素);
			            }
			        }
			    });
			
			    窗口.style.display = "flex"; // 使用 flex 以便内部布局生效
			}
			
			function 关闭收购窗口() {
			    const 窗口 = document.getElementById("收购窗口");
			    窗口.classList.add("关闭中");
			    setTimeout(() => {
			        窗口.style.display = "none";
			        窗口.classList.remove("关闭中");
			        玩家属性.允许移动 -= 1;
			    }, 300);
			    NPC互动中 = false; // 结束互动
			    当前NPC = null;
			}
			
			function 尝试出售(物品实例, 价格, npc) {
			    if (npc.自定义数据.get("交易次数") <= 0) {
			        显示通知("探险家已经不想再收购了。", "警告");
			        关闭收购窗口();
			        return;
			    }
			
			    // 1. 预计算出售后的背包容量变化
			    let 潜在空格子 = 0;
			    if (物品实例.堆叠数量 === 1) {
			        潜在空格子 = 1; // 如果物品完全移除，会空出一个格子
			    }
			    const 当前物品数量 = [...玩家背包.values()].reduce(
			        (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
			        0
			    );
			    const 预计出售后物品数量 = 当前物品数量 - 潜在空格子;
			
			    // 2. 检查是否有足够的空间放金币
			    const 金币实例 = [...玩家背包.values()].find(
			        (i) => i instanceof 金币
			    );
			    let 需要的金币格子 = 0;
			    if (金币实例) {
			        const 可堆叠空间 = 最大堆叠数 - 金币实例.堆叠数量;
			        const 剩余金币 = 价格 - Math.min(价格, 可堆叠空间);
			        if (剩余金币 > 0) {
			            需要的金币格子 = Math.ceil(剩余金币 / 最大堆叠数); // 计算需要多少个新格子放剩余金币
			        }
			    } else {
			        需要的金币格子 = Math.ceil(价格 / 最大堆叠数); // 没有金币实例，计算需要多少新格子
			    }
			
			    // 比较预计的背包占用和最大容量
			    if (预计出售后物品数量 + 需要的金币格子 > 最大背包容量) {
			        显示通知("背包空间不足，无法完成交易！", "错误");
			        return; // 出售失败
			    }
			    if (物品实例.堆叠数量 > 1) {
			        物品实例.堆叠数量 -= 1;
			    } else {
			        玩家背包.delete(物品实例.唯一标识);
			        if (物品实例.已装备) {
			            玩家装备.delete(物品实例.装备槽位);
			            物品实例.已装备 = false;
			            物品实例.装备槽位 = null;
			        }
			    }
			
			    尝试收集物品(new 金币({ 数量: 价格 }), true); // 直接收集
			
			    npc.自定义数据.set(
			        "交易次数",
			        npc.自定义数据.get("交易次数") - 1
			    );
			
			    // 6. 刷新收购窗口内容
			    玩家属性.允许移动 -= 1;
			    打开收购窗口(npc); // 重新打开以刷新列表和金币
			
			    // 7. 更新UI
			    更新背包显示();
			    更新装备显示();
			    显示通知(
			        `成功出售 ${物品实例.名称}，获得 ${价格} 金币！`,
			        "成功"
			    );
			
			    // 8. 如果交易次数用完，自动关闭窗口
			    if (npc.自定义数据.get("交易次数") <= 0) {
			        显示通知("探险家满意地离开了。", "信息");
			        关闭收购窗口();
			    }
			}
			function 打开交易窗口(npc) {
			    if (npc.自定义数据.get("刷新次数") === 0) {
			        显示通知("货物已告罄", "信息");
			        return;
			    }
			    玩家属性.允许移动 += 1;
			
			    当前NPC = npc;
			    const 窗口 = document.getElementById("交易窗口");
			    窗口.querySelector("#交易次数").textContent =
			        npc.自定义数据.get("刷新次数");
			    窗口.querySelector("#当前金币").textContent = [
			        ...玩家背包.values(),
			    ]
			        .filter((i) => i instanceof 金币)
			        .reduce((sum, i) => sum + i.堆叠数量, 0);
			
			    const 库存容器 = 窗口.querySelector(".库存列表");
			    库存容器.innerHTML = "";
			
			    npc.自定义数据.get("库存").forEach((物品) => {
			        let 价格 = npc.获取价格(物品);
			        const 元素 = document.createElement("div");
			        元素.className = "交易物品条目";
			        元素.innerHTML = `
			<div class="物品头">
			    <span style="color:${
			        物品.颜色表[物品.颜色索引]
			    }; font-family: color-emoji">${物品.图标}</span>
			    ${物品.获取名称()}
			    <span class="物品价格">${价格} 金币</span>
			</div>
			<div class="物品描述">${物品.效果描述 || "神秘物品"}</div>
			        `;
			
			        元素.addEventListener("click", () => 尝试购买(物品, 价格));
			        库存容器.appendChild(元素);
			    });
			
			    窗口.style.display = "block";
			    窗口.classList.remove("关闭中");
			    document.body.appendChild(窗口);
			}
			
			function 尝试购买(物品, 价格) {
			    const npc = 当前NPC;
			    const 金币列表 = [...玩家背包.values()].filter(
			        (i) => i instanceof 金币
			    );
			    const 总金币 = 金币列表.reduce((sum, i) => sum + i.堆叠数量, 0);
			
			    if (总金币 < 价格) {
			        显示通知("金币不足！", "错误");
			        return;
			    }
			    // 添加物品
			    if (物品.类型 === "NPC" && !彩蛋2触发) {
			        显示通知("就是你小子在酒吧里点了一个酒吧!?", "信息", true);
			        彩蛋2触发 = true;
			    }
			    const 新物品 = 克隆物品(物品);
			    if (!尝试收集物品(新物品, true)) {
			        //注意：如果购买物品数量多，则会出现部分成功收集并返回false的情况
			        return;
			    }
			
			    if (!扣除金币(价格)) {
			        显示通知("金币不足！", "错误");
			        return;
			    }
			
			    // 更新NPC状态
			    npc.自定义数据.set(
			        "刷新次数",
			        npc.自定义数据.get("刷新次数") - 1
			    );
			
			    更新背包显示();
			    显示通知(`购买 ${物品.名称} 成功！`, "成功");
			    关闭交易窗口();
			}
			
			function 关闭交易窗口() {
			    document.getElementById("交易窗口").classList.add("关闭中");
			    setTimeout(() => {
			        document.getElementById("交易窗口").style.display = "none";
			        玩家属性.允许移动 -= 1;
			    }, 300);
			
			    当前NPC = null;
			    NPC互动中 = false;
			}
			
			function 进入教程层() {
			    是否为教程层 = true;
			    教程阶段 = 0;
			    教程提示已显示 = false;
			    document.getElementById("跳过教程按钮").style.display = "block";
			    生成教程地牢();
			    setTimeout(() => {
			        显示教程提示();
			    }, 200);
			    更新物体指示器();
			    所有怪物.forEach((m) => {
			        m.绘制血条();
			    });
			    更新洞穴视野();
			}
			
			function 跳过教程() {
			    是否为教程层 = false;
			    document.getElementById("跳过教程按钮").style.display = "none";
			    所有怪物.forEach((m) => {
			        m.绘制血条(true);
			        if (地牢[m.y] && 地牢[m.y][m.x])
			            地牢[m.y][m.x].关联怪物 = null;
			    });
			    所有怪物 = [];
			    当前出战宠物列表 = [];
			    重置玩家状态();
			    最高教程阶段 = 6;
			    切换楼层(0);
			    更新洞穴视野();
			}
			
			function 重置玩家状态() {
			    最大背包容量 = 12;
			    if (当前激活卷轴列表.size > 0) {
			        当前激活卷轴列表.forEach((卷轴) => {
			            当前激活卷轴列表.delete(卷轴);
			            卷轴.卸下();
			        });
			    }
			    玩家属性 = { ...初始玩家属性 };
			    玩家背包.clear();
			    玩家装备.clear();
			    玩家状态.forEach((m) => {
			        m.移除状态();
			    });
			    玩家状态 = [];
			    // 重置 HUD
			    document.querySelector(".health-bar").style.width = "100%";
			    document.querySelector(".power-bar").style.width = "100%";
			    更新装备显示();
			    更新背包显示();
			    应用职业效果(玩家职业);
			    if (开发者模式) {
try {
尝试收集物品(new 调试工具({}), true);
} catch (e) {}
}
			}
			
			function 生成教程地牢() {
			    地牢 = Array(地牢大小)
			        .fill()
			        .map((_, y) =>
			            Array(地牢大小)
			                .fill()
			                .map((_, x) => new 单元格(x, y))
			        );
			    房间列表 = [];
			    上锁房间列表 = [];
			    所有怪物 = [];
			    门实例列表 = new Map();
			    房间地图 = Array(地牢大小)
			        .fill()
			        .map(() => Array(地牢大小).fill(-1));
			    已访问房间 = new Set();
			
			    const 教程房间配置 = [
			        { x: 10, y: 10, w: 7, h: 5, id: 0, 门: [] }, // 初始房间：移动教学
			        { x: 20, y: 10, w: 7, h: 5, id: 1, 门: [] }, // 背包、装备教学：钢制长剑
			        { x: 30, y: 10, w: 7, h: 5, id: 2, 门: [] }, // 战斗、HUD、互动教学：普通怪物
			        { x: 40, y: 10, w: 7, h: 5, id: 3, 门: [] }, // 上锁房间、药水、强化：上锁的门，房间内有狂暴药水
			        { x: 50, y: 10, w: 7, h: 5, id: 4, 门: [] }, // 卷轴、冰冻怪物：冰冻怪物，清净卷轴（未鉴定）
			        { x: 60, y: 10, w: 7, h: 5, id: 5, 门: [] }, // 新物品：商人、祭坛、宠物
			        { x: 70, y: 10, w: 7, h: 5, id: 6, 门: [] }, // 下楼
			    ];
			
			    for (const 房间配置 of 教程房间配置) {
			        房间列表.push(房间配置);
			        放置房间(房间配置);
			    }
			    房间列表.sort((a,b)=>a.id-b.id)
			
			    for (let i = 0; i < 房间列表.length - 1; i++) {
			        let 路径 = 连接房间(房间列表[i], 房间列表[i + 1]);
			        if (路径) {
			            生成走廊(路径);
			        }
			    }
			    生成墙壁();
			
			    const 颜色索引 = 3 % 颜色表.length;
			    房间列表[3].门.forEach((门) => {
			        const 单元格 = 地牢[门.y][门.x];
			        门实例列表.get(单元格.标识).类型 = "上锁的门";
			        if (单元格.背景类型 === 单元格类型.门) {
			            单元格.背景类型 = 单元格类型.上锁的门;
			            单元格.钥匙ID = 房间列表[3].id;
			            单元格.颜色索引 = 颜色索引;
			        }
			    });
			    上锁房间列表.push({ ...房间列表[3], 颜色索引 });
			
			    const 第一个房间 = 房间列表[0];
			    玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
			    玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			    已访问房间.add(第一个房间.id);
			
			    放置物品到房间(new 钢制长剑({ 不可破坏: true }), 房间列表[1]);
			    放置怪物到单元格(
			        new 怪物({
			            掉落概率: 1,
			            基础攻击力: 1,
			            基础生命值: 15,
			            掉落物: new 钥匙({
			                对应门ID: 上锁房间列表[0].id,
			                颜色索引: 上锁房间列表[0].颜色索引,
			                地牢层数: -1,
			            }),
			        }),
			        房间列表[2].x + 3,
			        房间列表[2].y + 2
			    );
			
			    放置怪物到单元格(
			        new 怪物({
			            基础攻击力: 1,
			            基础生命值: 15,
			            强化: true,
			            掉落物: new 金币({ 数量: 64 }),
			        }),
			        房间列表[3].x + 3,
			        房间列表[3].y + 2
			    );
			    放置物品到房间(
			        new 清净卷轴({ 已解锁: false, 强化: true }),
			        房间列表[3]
			    );
			    放置物品到房间(new 狂暴药水({ 强化: true }), 房间列表[3]);
			
			    放置怪物到单元格(
			        new 冰冻怪物({
			            基础攻击力: 3,
			            基础生命值: 45,
			            掉落物: new 冰盾({}),
			            掉落概率: 1,
			        }),
			        房间列表[4].x + 2,
			        房间列表[4].y + 2
			    );
			    放置物品到房间(new 神秘商人({}), 房间列表[5]);
			    放置物品到房间(new 物品祭坛({}), 房间列表[5]);
			    放置物品到房间(new 宠物({}), 房间列表[5]);
			    //生成解谜棋盘(房间列表[1]);
			    //房间列表[1].类型 = "隐藏解谜棋盘"
			    放置楼梯(
			        房间列表[房间列表.length - 1],
			        楼梯图标.下楼,
			        单元格类型.楼梯下楼
			    );
			    房间列表.forEach((房间) => 更新房间墙壁(房间));
			    更新视口();
			    绘制();
			}
			function 显示教程提示(强制 = false) {
			    if (教程提示已显示 && !强制) return;
			
			    const 提示窗口 = document.getElementById("教程提示窗口");
			    const 提示内容元素 = document.getElementById("教程提示内容");
			
			    if (教程阶段 > 最高教程阶段) {
			        最高教程阶段 = 教程阶段;
			    }
			
			    let 提示文本 = 获取教程文本(教程阶段);
			
			    if (提示文本 === "未知教程阶段") {
			        提示窗口.style.display = "none";
			        return;
			    }
			
			    提示内容元素.innerHTML = 提示文本;
			    提示窗口.style.display = "block";
			    玩家属性.允许移动++;
			    教程提示已显示 = true;
			}
			
			function 打开教程回放窗口() {
			    if (教程提示已显示) 关闭教程提示();
			    const 回放窗口 = document.getElementById("教程回放窗口");
			    当前回放阶段 = 0;
			    显示回放教程页(当前回放阶段);
			    回放窗口.style.display = "block";
			    玩家属性.允许移动 += 1;
			
			    document.getElementById("上一页教程按钮").onclick = () => {
			        if (当前回放阶段 > 0) {
			            当前回放阶段 = 获取上一个有效阶段(当前回放阶段);
			            显示回放教程页(当前回放阶段);
			        }
			    };
			    document.getElementById("下一页教程按钮").onclick = () => {
			        const 下一阶段 = 获取下一个有效阶段(当前回放阶段);
			        if (下一阶段 !== null && 下一阶段 <= 最高教程阶段) {
			            当前回放阶段 = 下一阶段;
			            显示回放教程页(当前回放阶段);
			        }
			    };
			}
			
			function 获取上一个有效阶段(当前阶段) {
			    let 上一阶段 = 当前阶段;
			    do {
			        if (上一阶段 === 2.5) 上一阶段 = 2;
			        else 上一阶段 = Math.floor(上一阶段 - 1);
			    } while (
			        上一阶段 > 0 &&
			        获取教程文本(上一阶段) === "未知教程阶段"
			    );
			    return Math.max(0, 上一阶段);
			}
			
			function 获取下一个有效阶段(当前阶段) {
			    let 下一阶段 = 当前阶段;
			    do {
			        if (下一阶段 === 2) 下一阶段 = 2.5;
			        else 下一阶段 = Math.ceil(下一阶段 + 1);
			    } while (
			        获取教程文本(下一阶段) === "未知教程阶段" &&
			        下一阶段 <= 6
			    ); // 假设最大阶段是6
			
			    return 下一阶段 <= 6 ? 下一阶段 : null; // 如果超过最大阶段，返回null
			}
			
			function 显示回放教程页(阶段) {
			    const 内容元素 = document.getElementById("教程回放内容");
			    const 页码元素 = document.getElementById("教程页码");
			    const 上一页按钮 = document.getElementById("上一页教程按钮");
			    const 下一页按钮 = document.getElementById("下一页教程按钮");
			
			    内容元素.innerHTML = 获取教程文本(阶段);
			
			    let 当前页码 = 1;
			    let 总页数 = 1;
			    let temp阶段 = 0;
			    while (temp阶段 < 最高教程阶段) {
			        const 下一阶段 = 获取下一个有效阶段(temp阶段);
			        if (下一阶段 === null || 下一阶段 > 最高教程阶段) break;
			        总页数++;
			        if (下一阶段 <= 阶段) 当前页码++;
			        temp阶段 = 下一阶段;
			    }
			
			    页码元素.textContent = `${当前页码} / ${总页数}`;
			
			    上一页按钮.disabled = 阶段 <= 0;
			    const 下一阶段 = 获取下一个有效阶段(阶段);
			    下一页按钮.disabled =
			        下一阶段 === null || 下一阶段 > 最高教程阶段;
			}
			
			function 关闭教程回放窗口() {
			    const 回放窗口 = document.getElementById("教程回放窗口");
			    回放窗口.classList.add("关闭中"); // 复用关闭动画类
			    setTimeout(() => {
			        回放窗口.style.display = "none";
			        回放窗口.classList.remove("关闭中");
			    }, 300);
			    玩家属性.允许移动 -= 1;
			}
			function 获取教程文本(阶段) {
			    let 提示文本 = "";
			    const isMobile = window.innerWidth < 769;
			
			    switch (阶段) {
			        case 0:
			            提示文本 = isMobile
			                ? `欢迎来到中文地牢！<br>
			    <b>基础移动：</b><br>
			    - 长按方向键可以连续移动。<br>
			    - 直接点击地图上的目标位置，角色会自动寻路。<br>
			    <br>
			    <b>注意：</b>长按移动会忽略攻击和互动，适合快速探索。<br>
			    <b>兼容模式:</b>如果 emoji 无法显示，可以点击设置按钮⚙️再点击'切换为中文模式'按钮`
			                : `欢迎来到中文地牢！<br>
			    <b>基础移动：</b><br>
			    - 使用 W (上)、A (左)、S (下)、D (右) 键 或 ↑↓←→ 方向键移动。<br>
			    - 直接点击地图上的目标位置，角色会自动寻路。<br>
			    <br>
			    <b>兼容模式:</b>如果 emoji 无法显示，可以在主菜单切换成汉字模式`;
			            break;
			        case 1:
			            提示文本 = isMobile
			                ? `<b>背包与装备：</b><br>
			    - 打开背包：点击屏幕下方的背包图标 ${图标映射.背包按钮}。<br>
			    - 背包功能：<br>
			        - 点击物品：使用、丢弃或装备物品。丢弃的物品按互动键可以捡回。<br>
			        - 装备武器：点击武器，再点击“装备”按钮（${图标映射.装备按钮}）。<br>
			       
			    - 装备栏 (屏幕右下角的“田”字格)：<br>
			        - 单击装备槽内物品以使用，左右滑动可以换页<br>
			    请尝试打开背包，装备上你找到的钢制长剑。`
			                : `<b>背包与装备：</b><br>
			    - 打开背包：按 E 键。<br>
			    - 背包功能：<br>
			        - 点击物品：使用、丢弃或装备物品。丢弃的物品按互动键可以捡回。<br>
			        - 装备武器：点击武器，再点击“装备”按钮（${图标映射.装备按钮}）。<br>
			      
			    - 装备栏 (屏幕右下角的“田”字格)：<br>
			        - 使用数字键 1-4 使用对应槽位物品，右键卸下，J、K键可以换页。<br>
			    请尝试打开背包，装备上你找到的钢制长剑。`;
			            break;
			        case 2: // 进入房间时的提示
			            提示文本 = isMobile
			                ? `<b>战斗与HUD：</b><br>
			    - HUD（屏幕左上角）：<br>
			         - 显示/隐藏：点击眼睛图标 ${图标映射.HUD智能} 按钮。<br>
			        - ❤️ 生命条：显示你的生命值。<br>
			        - ⚡ 能量条：显示你的能量值（使用卷轴等特殊物品会消耗）。<br>
			    - 武器有冷却时间与耐久，耐久即将耗尽时可以停止使用，后续等待机会修补<br>
			    <b>战斗：</b><br>
			    - 靠近怪物，使用已装备的武器攻击它（点击装备栏中武器）。<br>
			    - 击败怪物可获得战利品。<br>`
			                : `<b>战斗与HUD：</b><br>
			    - HUD（屏幕左上角）：<br>
			        - 显示/隐藏：按 Q 键。<br>
			        - ❤️ 生命条：显示你的生命值。<br>
			        - ⚡ 能量条：显示你的能量值（使用卷轴等特殊物品会消耗）。<br>
			     - 武器有冷却时间与耐久，耐久即将耗尽时可以停止使用，后续等待机会修补<br>
			    <b>战斗：</b><br>
			    - 靠近怪物，使用已装备的武器攻击它（按对应数字键）。<br>
			    - 击败怪物可获得战利品。<br>`;
			            break;
			
			        case 2.5: // 击败怪物后的提示
			            提示文本 = isMobile
			                ? `<b>互动：</b><br>
			    - 点击屏幕下方的互动按钮 ${图标映射.互动按钮}。<br>
			    - 互动功能：<br>
			        - 拾取周围的物品（直接走到物品的格子上也可以拾取）。<br>
			        - 打开上锁的门（需要拥有对应颜色的钥匙）。<br>
			        - 与 NPC、祭坛等互动。<br>
			        - 自动选择武器并攻击范围内的敌人。<br>
			     <b>提示：</b>掉落的钥匙有光晕，门的颜色和钥匙发出的光晕的颜色要一致才能解锁。<br>
			     请使用互动键拾取钥匙,并尝试打开下一道门.`
			                : `<b>互动：</b><br>
			    - 按 F 键。<br>
			    - 互动功能：<br>
			        - 拾取周围的物品（直接走到物品的格子上也可以拾取）。<br>
			        - 打开上锁的门（需要拥有对应颜色的钥匙）。<br>
			        - 与 NPC、祭坛等互动。<br>
			        - 自动选择武器并攻击范围内的敌人。<br>
			    <b>提示：</b>掉落的钥匙有光晕，门的颜色和钥匙发出的光晕的颜色要一致才能解锁。<br>
			     请使用互动键拾取钥匙,并尝试打开下一道门.`;
			            break;
			        case 3:
			            提示文本 = `你成功打开了上锁的房间！<br>
			    <b>强化物品：</b><br>
			    - 上锁房间内通常有更高品质的物品，它们带有强化效果，属性更强。<br>
			    - 注意：怪物也会被强化！<br>
			    <br>
			    <b>药水：</b><br>
			    - 药水有持续时间，效果会在一定回合后消失。<br>
			    - 在关键时候打开背包使用药水,它可以救你一命！`;
			            break;
			        case 4:
			            提示文本 = isMobile
			                ? `<b>卷轴与能量：</b><br>
			    - 卷轴是强大的消耗品，但使用需要消耗能量，能量条在左上角的HUD中显示，并随玩家移动恢复。<br>
			    - 卷轴使用方法：<br>
			        1. 装备：打开背包(${图标映射.背包按钮})，点击卷轴，再点击“装备”按钮(${图标映射.装备按钮})。<br>
			        2. 激活：点击屏幕下方的卷轴图标 ${图标映射.卷轴按钮} 按钮,再点击装备栏中高亮的卷轴。<br>
			    - 你获得的清净卷轴可以移除自身的所有状态效果。<br>
			    - 卷轴需要使用特殊卷轴解读后才能知道效果。<br>
			    - 激活后再点击装备槽中高亮的卷轴可以取消激活`
			                : `<b>卷轴与能量：</b><br>
			    - 卷轴是强大的消耗品，但使用需要消耗能量，能量条在左上角的HUD中显示。玩家移动/探索房间/击杀怪物均可恢复能量，但是只依靠玩家移动恢复能量是不可取的。<br>
			    - 卷轴使用方法：<br>
			        1. 装备：打开背包(E)，点击卷轴，再点击“装备”按钮(${图标映射.装备按钮})。<br>
			        2. 激活：按 R 键。<br>
			     - 你获得的清净卷轴可以移除自身的所有状态效果。<br>
			    - 卷轴需要使用特殊卷轴解读后才能知道效果。<br>
			    - 激活后再点击装备槽中高亮的卷轴可以取消激活`;
			            break;
			
			        case 5:
			            提示文本 = `<b>探索更多：</b><br>
			   这个房间里有一些特殊的物品，为你展示地牢物品的多样。<br>
			    如果背包已满，你可以尝试丢掉一些物品或将它们装备给宠物。<br>
			    如果装备槽已满，长按或右键已装备物品可以将其卸下<br>
			    遇到未知物品尝试与其互动 或 拾起后在背包中使用。`;
			            break;
			        case 6:
			            提示文本 = isMobile
			                ? `<b>开始游戏：</b><br>
			    点击设置⚙️可以打开功能菜单<br>
			    - 地牢有很多层，每层都有不同的怪物和宝藏。<br>
			    - 找到并走下楼梯 ${图标映射.下楼楼梯} 即可进入下一层，开始你的冒险！`
			                : `<b>开始游戏：</b><br>
			    按 G 键可以打开日志界面。<br>
			    按 Z 键可以导出存档。<br>
			    按 U 键可以自杀。<br>
			    - 地牢有很多层，每层都有不同的怪物和宝藏。<br>
			    - 找到并走下楼梯 ${图标映射.下楼楼梯} 即可进入下一层，开始你的冒险！`;
			            break;
			        case "首领挑战":
    提示文本 = `<b>首领挑战模式：</b><br>你将面对一系列强大的首领和怪物组合。祝你好运！`;
    break;
			        default:
			            提示文本 = "未知教程阶段"; // 或者返回空字符串
			    }
			    return 提示文本;
			}
			function 关闭教程提示() {
			    const 提示窗口 = document.getElementById("教程提示窗口");
			    if (提示窗口) {
			        提示窗口.classList.add("关闭中");
			        教程提示已显示 = false;
			        setTimeout(() => {
			            提示窗口.style.display = "none";
			            提示窗口.classList.remove("关闭中");
			            玩家属性.允许移动 -= 1;
			            玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
			        }, 300);
			    }
			}
			
			const 安全参数 = {
			    方程组: [
			        {
			            a: 7,
			            b: 3,
			            c: 2,
			            d: 5,
			        },
			        {
			            a: 4,
			            b: 9,
			            c: 6,
			            d: 8,
			        },
			    ],
			    模数: 9973,
			};
			
			function 生成死亡凭证(L) {
			    let R;
			    do {
			        // R ≡ (L^2 + 1) mod 13
			        const 基础值 = (L * L + 1) % 13;
			        R =
			            基础值 +
			            Math.floor(prng() * (安全参数.模数 - 基础值)) *
			                13;
			    } while (R >= 安全参数.模数 || R === 0);
			
			    const 方程计算 = (系数, L, R) => {
			        const 项1 = 系数.a * L;
			        const 项2 = 系数.b * R * R;
			        const 项3 = 系数.c * L * R;
			        const 项4 = 系数.d * R * R * R;
			        return (项1 + 项2 + 项3 + 项4) % 安全参数.模数;
			    };
			
			    const C1 = 方程计算(安全参数.方程组[0], L, R);
			    const C2 = 方程计算(安全参数.方程组[1], L, R);
			
			    const 组件 = [
			        L.toString().padStart(3, "0"),
			        R.toString().padStart(4, "0"),
			        (C1 + C2).toString().padStart(3, "0"),
			    ];
			
			    return 组件.join("-");
			}
			
			function 验证死亡凭证(凭证, 待验层数) {
			    const [L部分, R部分, C部分] = 凭证.split("-");
			    const L = parseInt(L部分);
			    const R = parseInt(R部分);
			    const 总校验码 = parseInt(C部分);
			
			    if (L !== 待验层数 || R <= 0 || R >= 安全参数.模数)
			        return false;
			
			    // R ≡ (L² +1) mod 13
			    if (R % 13 !== (L * L + 1) % 13) return false;
			
			    const 方程计算 = (系数, L, R) => {
			        const 计算值 =
			            系数.a * L +
			            系数.b * R * R +
			            系数.c * L * R +
			            系数.d * R * R * R;
			        return 计算值 % 安全参数.模数;
			    };
			
			    const 真实C1 = 方程计算(安全参数.方程组[0], L, R);
			    const 真实C2 = 方程计算(安全参数.方程组[1], L, R);
			
			    return 真实C1 + 真实C2 === 总校验码;
			}
			
			function CopyTextToClipboard(val) {
			    const textArea = document.createElement("textArea");
			    textArea.value = val;
			    textArea.style.width = 0;
			    textArea.style.position = "fixed";
			    textArea.style.left = "-999px";
			    textArea.style.top = "10px";
			    textArea.setAttribute("readonly", "readonly");
			    document.body.appendChild(textArea);
			
			    textArea.select();
			    document.execCommand("copy");
			    document.body.removeChild(textArea);
			}
			function 获取附魔描述(enchantments) {
			    const numberToRoman = (num) => {
			        const romanMap = {
			            1: "I",
			            2: "II",
			            3: "III",
			            4: "IV",
			            5: "V",
			            6: "VI",
			            7: "VII",
			            8: "VIII",
			            9: "IX",
			            10: "X",
			        };
			        return romanMap[num] || "";
			    };
			
			    return enchantments
			        .map((enchant) => {
			            const romanLevel = numberToRoman(enchant.等级);
			            return `[${enchant.种类}] ${romanLevel}级`;
			        })
			        .join("\n");
			}
			
			function 切换设置菜单() {
    const 菜单 = document.getElementById("设置菜单");
    const 重置按钮 = document.getElementById("重置关卡按钮");
    const 导出按钮 = document.getElementById("导出存档按钮");
    const 导出当前状态按钮 = document.getElementById("导出当前状态按钮"); // 新增

    if (菜单.classList.contains("显示")) {
        菜单.classList.remove("显示");
        菜单.classList.add("隐藏"); // 添加隐藏类以触发动画
        setTimeout(() => {
            菜单.classList.remove("隐藏");
            玩家属性.允许移动 -= 1;
        }, 300);
    } else {
        if (重置按钮) {
             重置按钮.style.display = 是否是自定义关卡 ? 'block' : 'none';
        }
        if (导出按钮) {
             导出按钮.style.display = 是否是自定义关卡 ? 'none' : 'block';
             if (是否为教程层) {
            导出按钮.style.display = 'none';
        }
        if (游戏状态 === "图鉴") {
            导出按钮.style.display = 'none';
        }
        }
        if (导出当前状态按钮) {
            导出当前状态按钮.style.display = (游戏状态 === '编辑器游玩' && 开发者模式) ? 'block' : 'none';
        }
        菜单.classList.remove("隐藏");
        菜单.classList.add("显示");
        玩家属性.允许移动 += 1;
    }
}
			
			function 关闭设置菜单() {
			    const 菜单 = document.getElementById("设置菜单");
			    菜单.classList.remove("显示");
			    菜单.classList.add("隐藏"); // 添加隐藏类以触发动画
			    setTimeout(() => {
			        菜单.classList.remove("隐藏");
			        玩家属性.允许移动 -= 1;
			        玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
			    }, 300);
			}
			async function 导出当前状态为创意关卡() {
    if (游戏状态 !== '编辑器游玩' || !开发者模式) {
        显示通知("此功能仅在开发者模式下的编辑器游玩中使用。", "错误");
        return;
    }

    const 关卡标题 = prompt("请输入关卡标题：", "我的实时状态关卡");
    if (关卡标题 === null || 关卡标题.trim() === "") {
        显示通知("已取消发布。", "信息");
        return;
    }

    try {
        const 实时状态字符串 = 保存游戏状态();
        if (!实时状态字符串) {
            throw new Error("无法获取当前游戏状态。");
        }
        
        const 地图数据 = JSON.parse(实时状态字符串);

        // 设置为已发布状态
        地图数据.关卡标题 = 关卡标题;
        地图数据.isPublished = true;
        地图数据.强制动画模式 = 切换动画;
        
        // 清理不应包含在发布文件中的编辑器特定数据
        delete 地图数据.编辑器状态数据;
        delete 地图数据.配方信息;

        // --- 签名开始 ---
        delete 地图数据.signature;
        const 数据字符串 = JSON.stringify(地图数据);
        地图数据.signature = await 生成签名(数据字符串);
        // --- 签名结束 ---
        
        const 地图字符串最终 = JSON.stringify(地图数据);
        const 数据块 = new Blob([地图字符串最终], { type: 'application/json' });
        const 下载链接 = URL.createObjectURL(数据块);
        const 链接元素 = document.createElement('a');
        链接元素.href = 下载链接;
        const 时间戳 = new Date().toISOString().replace(/[:.]/g, "-");
        链接元素.download = `[DEV]${关卡标题}_${时间戳}.json`;
        document.body.appendChild(链接元素);
        链接元素.click();
        document.body.removeChild(链接元素);
        URL.revokeObjectURL(下载链接);
        显示通知('当前状态已作为创意关卡导出!', '成功');
    } catch (e) {
        显示通知('导出当前状态时发生错误！', '错误');
        console.error(e);
    }
}
			function 更新视口(直接更新 = false, x = 玩家.x, y = 玩家.y) {
			    const 视野偏移 = Math.floor(相机显示边长 / 2);
			    let 目标X = x - 视野偏移;
			    let 目标Y = y - 视野偏移;
			
			    const 检查视口碰撞 = (试探X, 试探Y) => {
			        for (let viewY = 0; viewY < 相机显示边长; viewY++) {
			            for (let viewX = 0; viewX < 相机显示边长; viewX++) {
			                const worldX = 试探X + viewX;
			                const worldY = 试探Y + viewY;
			
			                if (worldX < 0 || worldX >= 地牢大小 || worldY < 0 || worldY >= 地牢大小) continue;
			
			                const 单元格 = 地牢[worldY]?.[worldX];
			                if (单元格?.关联物品?.阻碍视野 && 游戏状态!=='地图编辑器') {
			                    return false; 
			                }
			            }
			        }
			        return true;
			    };
			
			    let 最终目标X = 当前相机X;
			    let 最终目标Y = 当前相机Y;
			
			    let 试探X = Math.max(0, Math.min(目标X, 地牢大小 - 相机显示边长));
			    if (检查视口碰撞(Math.floor(试探X), Math.floor(当前相机Y))) {
			        最终目标X = 试探X;
			    } else {
			        最终目标X = Math.floor(当前相机X);
			    }
			
			    let 试探Y = Math.max(0, Math.min(目标Y, 地牢大小 - 相机显示边长));
			    if (检查视口碰撞(Math.floor(最终目标X), Math.floor(试探Y))) {
			        最终目标Y = 试探Y;
			    } else {
			        最终目标Y = Math.floor(当前相机Y);
			    }
			
			    if (相机目标X !== 最终目标X || 相机目标Y !== 最终目标Y) {
			        相机锁定 = true;
			        相机目标X = 最终目标X;
			        相机目标Y = 最终目标Y;
			        if (直接更新) {
			            视口偏移X = Math.floor(最终目标X);
			            视口偏移Y = Math.floor(最终目标Y);
			            当前相机X = 最终目标X;
			            当前相机Y = 最终目标Y;
			        }
			    }
			}
			function 查找配对传送门(源传送门) {
			    if (!源传送门) return null;
			    for (const 传送门 of 所有传送门) {
			        if ((传送门.y !== 源传送门.y || 传送门.x !== 源传送门.x) && 传送门.自定义数据.get('传送门ID') === 源传送门.自定义数据.get('传送门ID')) {
			            return 传送门;
			        }
			    }
			    return null;
			}
			
			function 寻找传送出口(传送门) {
			    const 方向 = [[0, 1], [0, -1], [1, 0], [-1, 0]];
			    for (const [dx, dy] of 方向) {
			        const x = 传送门.x + dx;
			        const y = 传送门.y + dy;
			        if (位置是否可用(x, y, false)) {
			            return { x, y };
			        }
			    }
			    return null; 
			}
			
			function 方向到向量(方向) {
			    if (方向 === 'N') return { dx: 0, dy: -1 };
			    if (方向 === 'S') return { dx: 0, dy: 1 };
			    if (方向 === 'E') return { dx: 1, dy: 0 };
			    if (方向 === 'W') return { dx: -1, dy: 0 };
			    return null;
			}
			
			function 向量到角度(dx, dy) {
			    return (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
			}
			function 旋转方向(原始方向, 旋转角度) {
			    const 方向列表 = ['N', 'E', 'S', 'W'];
			    const 角度 = ((旋转角度 % 360) + 360) % 360;
			
			    const 当前索引 = 方向列表.indexOf(原始方向);
			    if (当前索引 === -1) {
			        return 原始方向; 
			    }
			
			    if (角度 === 0) {
			        return 原始方向;
			    }
			
			    const 步数 = 角度 / 90;
			    const 新索引 = (当前索引 + 步数) % 4;
			    
			    return 方向列表[新索引];
			}
			
			function 应用旋转({ dx, dy }, 旋转角度) {
			    const 弧度 = 旋转角度 * Math.PI / 180;
			    const cos = Math.cos(弧度);
			    const sin = Math.sin(弧度);
			    const 新dx = Math.round(dx * cos - dy * sin);
			    const 新dy = Math.round(dx * sin + dy * cos);
			    return { dx: 新dx, dy: 新dy };
			}
			
			function 寻找传送门出口向量(传送门) {
			    const { x, y } = 传送门;
			    const 检查方向 = [
			        { dir: 'N', dx: 0, dy: -1 }, { dir: 'S', dx: 0, dy: 1 },
			        { dir: 'E', dx: 1, dy: 0 }, { dir: 'W', dx: -1, dy: 0 }
			    ];
			    for (const { dx, dy } of 检查方向) {
			        const 邻居X = x + dx;
			        const 邻居Y = y + dy;
			        const 邻居单元格 = 地牢[邻居Y]?.[邻居X];
			        if (邻居单元格 && [单元格类型.房间, 单元格类型.走廊].includes(邻居单元格.背景类型) && !邻居单元格?.阻碍视野) {
			            return { dx, dy };
			        }
			    }
			    return null; // 如果周围都被墙堵住了，则没有出口
			}
			function 旋转墙壁属性(墙壁对象, 旋转角度) {
			    const 新墙壁 = { 上: false, 右: false, 下: false, 左: false };
			    const 角度 = ((旋转角度 % 360) + 360) % 360;
			
			    if (角度 === 0) {
			        return { ...墙壁对象 };
			    }
			
			    if (角度 === 90) {
			        if (墙壁对象.上) 新墙壁.右 = true;
			        if (墙壁对象.右) 新墙壁.下 = true;
			        if (墙壁对象.下) 新墙壁.左 = true;
			        if (墙壁对象.左) 新墙壁.上 = true;
			    } else if (角度 === 180) {
			        if (墙壁对象.上) 新墙壁.下 = true;
			        if (墙壁对象.下) 新墙壁.上 = true;
			        if (墙壁对象.左) 新墙壁.右 = true;
			        if (墙壁对象.右) 新墙壁.左 = true;
			    } else if (角度 === 270) {
			        if (墙壁对象.上) 新墙壁.左 = true;
			        if (墙壁对象.左) 新墙壁.下 = true;
			        if (墙壁对象.下) 新墙壁.右 = true;
			        if (墙壁对象.右) 新墙壁.上 = true;
			    } else {
			        return { ...墙壁对象 };
			    }
			
			    return 新墙壁;
			}
			function 快速检查相邻移动(起始X, 起始Y, 目标X, 目标Y,无视物品=false) {
			
			
			    const 起始单元格 = 地牢[起始Y]?.[起始X];
			    const 目标单元格 = 地牢[目标Y]?.[目标X];
			
			    if (!起始单元格 || !目标单元格) {
			        return false;
			    }
			
			    if ((目标单元格.关联物品?.类型 === '开关砖' && 目标单元格.关联物品?.阻碍怪物 &&!无视物品) || 单元格类型.墙壁===目标单元格.背景类型 || (单元格类型.上锁的门===目标单元格.背景类型&&!无视物品)) {
			        return false;
			    }
			    const dx = 目标X - 起始X;
			    const dy = 目标Y - 起始Y;
			
			    if (dx === 1 && (起始单元格.墙壁.右 || 目标单元格.墙壁.左)) return false;
			    if (dx === -1 && (起始单元格.墙壁.左 || 目标单元格.墙壁.右)) return false;
			    if (dy === 1 && (起始单元格.墙壁.下 || 目标单元格.墙壁.上)) return false;
			    if (dy === -1 && (起始单元格.墙壁.上 || 目标单元格.墙壁.下)) return false;
			
			    return true;
			}
			function 处理沉浸式传送门() {
			    if(所有传送门.length===0) return;
			    显示通知('正在生成循环回廊...','信息');
			    setTimeout(() => {
			    const 渲染距离上限 = 4999;
			    const 传送深度上限 = 9999;
			    
			    
			    // 队列状态: { x, y (世界坐标), 距离, 深度, 偏移X, 偏移Y (已旋转的累积屏幕偏移), 旋转 (0, 90, 180, 270) }
			    const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0, 深度: 0, 偏移X: 0, 偏移Y: 0, 旋转: 0,出传送门:null}];
			    const 已访问 = new Set();
			    const 待绘制列表 = [];
			    let 完全生成=true
			
			    while (队列.length > 0) {
			        let { x, y, 距离, 深度, 偏移X, 偏移Y, 旋转,出传送门 } = 队列.shift();
			
			        let 访问键 = `${x},${y},${偏移X},${偏移Y}`;
			        if (已访问.has(访问键)) continue;
			        if (距离 > 渲染距离上限 || 深度 > 传送深度上限) {
			            完全生成=false
			            continue;
			        }
			        已访问.add(访问键);
			
			        const 单元格 = 地牢[y]?.[x];
			        if (!单元格) continue;
			        
			        待绘制列表.push({单元格, 偏移X, 偏移Y, 旋转});
			
			        const 标准方向 = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
			        
			        for (const 方向 of 标准方向) {
			            const 变换后方向 = 应用旋转(方向, 旋转);
			            const 邻居X = x + 方向.dx;
			            const 邻居Y = y + 方向.dy;
			            访问键 = `${邻居X},${邻居Y},${偏移X+方向.dx-变换后方向.dx},${偏移Y+方向.dy-变换后方向.dy}`;
			            if (已访问.has(访问键)) continue;
			
			            if (邻居X-(偏移X+方向.dx-变换后方向.dx) >= 0 && 邻居X-(偏移X+方向.dx-变换后方向.dx) < 地牢大小 && 邻居Y-(偏移Y+方向.dy-变换后方向.dy) >= 0 && 邻居Y-(偏移Y+方向.dy-变换后方向.dy) < 地牢大小 && 快速检查相邻移动(x, y, 邻居X, 邻居Y,true)) {
			                const 邻居单元格 = 地牢[邻居Y][邻居X];
			                const 邻居物品 = 邻居单元格?.关联物品;
			
			                if (邻居物品 instanceof 沉浸式传送门) {
			                if (邻居物品.x===出传送门?.x&&邻居物品.y===出传送门?.y) continue
			                    const 目标传送门 = 查找配对传送门(邻居物品);
			                    if (目标传送门) {
			                        
			                        const 出口向量 = 寻找传送门出口向量(目标传送门);
			                        if (出口向量) {
			                            const 进入向量 = { dx: 邻居X - x, dy: 邻居Y - y };
			                            
			                            const 进入角度 = 向量到角度(进入向量.dx, 进入向量.dy);
			                            const 出口角度 = 向量到角度(出口向量.dx, 出口向量.dy);
			                            
			                            const 传送门旋转 = (出口角度 - 进入角度 + 720) % 360;
			                            const 新旋转 = (720-(-旋转 + 传送门旋转)) % 360;
			                            const 位移向量 = { dx: 目标传送门.x - 邻居物品.x, dy: 目标传送门.y - 邻居物品.y };
			                            
			                            const 旋转后位移 = 应用旋转(位移向量, 0);
			
			
			                            const 新偏移X = 偏移X+旋转后位移.dx+方向.dx-变换后方向.dx;
			                            const 新偏移Y = 偏移Y+旋转后位移.dy+方向.dy-变换后方向.dy;
			
			                            const 出口坐标X = 目标传送门.x;
			                            const 出口坐标Y = 目标传送门.y;
			
			                            队列.push({ x: 出口坐标X, y: 出口坐标Y, 距离: 距离 + 2, 深度: 深度 + 1, 偏移X: 新偏移X, 偏移Y: 新偏移Y, 旋转: 新旋转,出传送门:{x:目标传送门?.x,y:目标传送门?.y}  });
			                        }
			                    }
			                } else {
			                    
			                    队列.push({ x: 邻居X, y: 邻居Y, 距离: 距离 + 1, 深度, 偏移X:偏移X+方向.dx-变换后方向.dx, 偏移Y:偏移Y+方向.dy-变换后方向.dy, 旋转,出传送门 });
			                }
			            }
			        }
			    }
			    
			    待绘制列表.forEach(({单元格, 偏移X, 偏移Y, 旋转}) => {
			        if (偏移X==0&&偏移Y==0){
			            单元格.阻碍视野 = false;
			            return;
			        } else if(单元格.阻碍视野) return;
			        let cell=克隆单元格(单元格)
			        cell.x = 单元格.x-偏移X
			        cell.y = 单元格.y-偏移Y
			        if (地牢[cell.y][cell.x].阻碍视野) return;
			        if (cell.关联物品?.x && cell.关联物品?.y) {
			            cell.关联物品.x = cell.x
			            cell.关联物品.y = cell.y
			            if (cell.关联物品 instanceof 沉浸式传送门) {
			                cell.关联物品=null
			                if (cell.类型===单元格类型.物品) cell.类型=null
			            } else if(cell.关联物品 instanceof 传送带){
			                cell.关联物品.自定义数据.set('方向',旋转方向(cell.关联物品.自定义数据.get('方向'),旋转))
			            }
			        }
			        if (cell.关联怪物?.x && cell.关联怪物?.y) {
			            cell.关联怪物.x = cell.x
			            cell.关联怪物.y = cell.y
			            所有怪物.push(cell.关联怪物)
			        }
			        if (cell.是否强制墙壁) {
			            const 新墙壁 = 旋转墙壁属性(cell.墙壁,旋转)
			            cell.墙壁 = 新墙壁;
			        }
			        cell.阻碍视野 = true;
			        
			        if (地牢[cell.y]?.[cell.x]) 地牢[cell.y][cell.x] = cell
			        
			    });
			    生成墙壁()
			    if (!完全生成) 显示通知('超过追踪上限，回廊生成不完全','警告');
			    }, 500);
			    
			}
			let 动画帧运行过 = false;
			function 动画帧() {
			    if (!动画帧运行过) {
			        动画帧运行过 = true;
			        已初始化--;
			    }
			    const dx = 相机目标X - 当前相机X;
			    const dy = 相机目标Y - 当前相机Y;
			
			    当前相机X += dx * 相机移动速度;
			    当前相机Y += dy * 相机移动速度;
			    const 当前时间 = Date.now();
			    // 检测移动完成
			    if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) {
			        当前相机X = 相机目标X;
			        当前相机Y = 相机目标Y;
			
			        
			
			        更新物体指示器();
			    }
			    if (待显示格子特效队列.length > 0) {
			        for (let i = 待显示格子特效队列.length - 1; i >= 0; i--) {
			            const 路径数据 = 待显示格子特效队列[i];
			            显示格子特效(
			                路径数据.路径,
			                路径数据.颜色,
			                路径数据.间隔
			            );
			        }
			        待显示格子特效队列 = [];
			    }
			
			    if (活动DOM特效.length > 0) {
			        const 画布RectUpdate = canvas.getBoundingClientRect(); // 获取最新的画布位置信息
			        活动DOM特效.forEach((item) => {
			            // 检查元素是否还存在于 DOM 中，防止意外移除导致错误
			            if (document.body.contains(item.element)) {
			                // 使用平滑插值的相机位置 (当前相机X/Y) 计算屏幕坐标
			                const 屏幕X =
			                    (item.worldX - 当前相机X) * 单元格大小;
			                const 屏幕Y =
			                    (item.worldY - 当前相机Y) * 单元格大小;
			                // 更新 DOM 元素的屏幕位置
			                item.element.style.left = `${
			                    屏幕X + 画布RectUpdate.left
			                }px`;
			                item.element.style.top = `${
			                    屏幕Y + 画布RectUpdate.top
			                }px`;
			            } else {
			                // 如果元素意外地不在 DOM 中了，从跟踪数组中清理掉
			                活动DOM特效 = 活动DOM特效.filter(
			                    (trackedItem) =>
			                        trackedItem.element !== item.element
			                );
			            }
			        });
			    }
			    所有怪物.forEach((怪物) => {
			        const 动画状态 = 怪物动画状态.get(怪物);
			        if (动画状态?.正在动画) {
			            const 已过时间 = 当前时间 - 动画状态.动画开始时间;
			            const t = Math.min(1, 已过时间 / 怪物移动动画时长); // 插值因子 (0 到 1)
			
			            // 使用线性插值计算视觉逻辑坐标
			            动画状态.视觉X =
			                动画状态.旧逻辑X +
			                (动画状态.目标逻辑X - 动画状态.旧逻辑X) * t;
			            动画状态.视觉Y =
			                动画状态.旧逻辑Y +
			                (动画状态.目标逻辑Y - 动画状态.旧逻辑Y) * t;
			
			            // 如果动画完成
			            if (t >= 1) {
			                动画状态.正在动画 = false;
			                动画状态.视觉X = 动画状态.目标逻辑X; // 确保最终位置精确
			                动画状态.视觉Y = 动画状态.目标逻辑Y;
			            }
			        }
			    });
			    const 动画状态玩家 = 玩家动画状态;
			if (动画状态玩家.正在动画) {
			    const 已过时间 = 当前时间 - 动画状态玩家.动画开始时间;
			    const 动画时长 = 120;
			    const t = Math.min(1, 已过时间 / 动画时长);
			
			    动画状态玩家.视觉X = 动画状态玩家.旧逻辑X + (动画状态玩家.目标逻辑X - 动画状态玩家.旧逻辑X) * t;
			    动画状态玩家.视觉Y = 动画状态玩家.旧逻辑Y + (动画状态玩家.目标逻辑Y - 动画状态玩家.旧逻辑Y) * t;
			
			    if (t >= 1) {
			        动画状态玩家.正在动画 = false;
			    }
			}
			当前出战宠物列表.forEach(pet => {
    if (!pet || !pet.是否已放置) return;

    const 动画状态 = 怪物动画状态.get(pet);
    if (动画状态?.正在动画) {
        const 已过时间 = 当前时间 - 动画状态.动画开始时间;
        const t = Math.min(1, 已过时间 / 怪物移动动画时长); // 插值因子 (0 到 1)

        // 使用线性插值计算视觉逻辑坐标
        动画状态.视觉X =
            动画状态.旧逻辑X +
            (动画状态.目标逻辑X - 动画状态.旧逻辑X) * t;
        动画状态.视觉Y =
            动画状态.旧逻辑Y +
            (动画状态.目标逻辑Y - 动画状态.旧逻辑Y) * t;

        // 如果动画完成
        if (t >= 1) {
            动画状态.正在动画 = false;
            动画状态.视觉X = 动画状态.目标逻辑X; // 确保最终位置精确
            动画状态.视觉Y = 动画状态.目标逻辑Y;
        }
    }
});
			    if (待显示爆炸范围.length > 0) {
			        const 画布RectExplosion = canvas.getBoundingClientRect();
			
			        待显示爆炸范围.forEach((explosionData) => {
			             if (explosionData && explosionData.爆炸范围.length > 0) {
			             const 特效容器 = document.getElementById("effectsContainer");
			                explosionData.爆炸范围.forEach(({ x, y, 距离 }) => {
			                    const 屏幕X = (x - 当前相机X) * 单元格大小;
			                    const 屏幕Y = (y - 当前相机Y) * 单元格大小;
			                    if (
			                        屏幕X + 单元格大小 < 0 || 
			                        屏幕X > 画布RectExplosion.width || 
			                        屏幕Y + 单元格大小 < 0 || 
			                        屏幕Y > 画布RectExplosion.height
			                    ) {
			                        return;
			                    }
			                    const 特效 = document.createElement("div");
			                    特效.style.cssText = `
			                        position: absolute;
			                        left: ${屏幕X + 画布RectExplosion.left}px;
			                        top: ${屏幕Y + 画布RectExplosion.top}px;
			                        width: ${单元格大小}px;
			                        height: ${单元格大小}px;
			                        background: ${获取爆炸颜色(距离, explosionData.范围)};
			                        opacity: 0.7;
			                        animation: 爆炸闪烁 ${0.4 + (距离 / explosionData.范围) * 0.1}s;
			                        pointer-events: none;
			                        z-index: 999;
			                    `;
			
			                    特效容器.appendChild(特效);
			
			                    const worldX = x;
			                    const worldY = y;
			                    const effectData = {
			                        element: 特效,
			                        worldX: worldX,
			                        worldY: worldY,
			                    };
			                    活动DOM特效.push(effectData);
			
			                    setTimeout(() => {
			                        特效.remove();
			                        活动DOM特效 = 活动DOM特效.filter(
			                            (item) => item.element !== 特效
			                        );
			                    }, 500); 
			                });
			            }
			        });
			
			        待显示爆炸范围 = [];
			    }
			
			    if (
			        (游戏状态 === "图鉴" || 游戏状态 === "游戏中" || 游戏状态 === "编辑器游玩") &&
			        当前时间 - 上次自动回合时间 >= 自动回合间隔 &&
			        切换动画
			    ) {
			        if (!死亡界面已显示 && 玩家属性.允许移动 <= 0) {
			            处理回合逻辑();
			            上次自动回合时间 = 当前时间;
			        }
			    }
			
			    // 更新整数视口
			    视口偏移X = Math.floor(当前相机X);
			    视口偏移Y = Math.floor(当前相机Y);
			
			    if (所有传送门.length > 0 && 游戏状态 !== '地图编辑器') {
			    //处理沉浸式传送门();
			    绘制()
			} else {
			    绘制();
			}
			    requestAnimationFrame(动画帧);
			}
			function 获取爆炸颜色(距离) {
			    const 渐变 = [
			        "radial-gradient(circle, #ff0000 0%, #ff4500 70%, transparent 100%)",
			        "radial-gradient(circle, #ff4500 0%, #ff8c00 70%, transparent 100%)",
			        "radial-gradient(circle, #ff8c00 0%, #ffd700 70%, transparent 100%)",
			    ];
			    return 渐变[Math.min(距离, 2)];
			}
			function 绘制() {
			
			    const 缓冲区域 = 1;
			    const 起始X = Math.max(0, Math.floor(当前相机X - 缓冲区域));
			    const 结束X = Math.min(
			        地牢大小,
			        起始X + 相机显示边长 + 缓冲区域 * 2
			    );
			    const 起始Y = Math.max(0, Math.floor(当前相机Y - 缓冲区域));
			    const 结束Y = Math.min(
			        地牢大小,
			        起始Y + 相机显示边长 + 缓冲区域 * 2
			    );
			    const 清理X = (起始X - 当前相机X) * 单元格大小 - 单元格大小;
			    const 清理Y = (起始Y - 当前相机Y) * 单元格大小 - 单元格大小;
			    const 清理宽 = (结束X - 起始X + 2) * 单元格大小;
			    const 清理高 = (结束Y - 起始Y + 2) * 单元格大小;
			    ctx.clearRect(清理X, 清理Y, 清理宽, 清理高);
			
			    const 小数偏移X = (当前相机X % 1) * 单元格大小;
			    const 小数偏移Y = (当前相机Y % 1) * 单元格大小;
			
			    for (let y = 起始Y; y < 结束Y; y++) {
			        for (let x = 起始X; x < 结束X; x++) {
			            if (地牢.length > 0 && 地牢[y]?.[x]) {
			                地牢[y][x].绘制();
			            }
			        }
			    }
			    
			    if (moveQueue.length > 0) {
			        drawPath(moveQueue);
			    }
			    
			    所有怪物.forEach((怪物实例) => {
			        if (怪物实例 instanceof 巨人部位) return;
			
			        const 动画状态 = 怪物动画状态.get(怪物实例);
			        let 绘制逻辑X = 怪物实例.x;
			        let 绘制逻辑Y = 怪物实例.y;
			        const 正在动画 = 动画状态?.正在动画;
			
			        if (正在动画) {
			            绘制逻辑X =
			                动画状态.视觉X !== undefined
			                    ? 动画状态.视觉X
			                    : 怪物实例.x;
			            绘制逻辑Y =
			                动画状态.视觉Y !== undefined
			                    ? 动画状态.视觉Y
			                    : 怪物实例.y;
			        }
			
			        const 怪物视口X = 绘制逻辑X - 视口偏移X;
			        const 怪物视口Y = 绘制逻辑Y - 视口偏移Y;
			        const 怪物所在房间ID = 房间地图[怪物实例.y]?.[怪物实例.x];
			        const 怪物所在房间 =
			            怪物所在房间ID !== -1 ? 房间列表[怪物所在房间ID] : null;
			        if (
			            怪物视口X >= -缓冲区域 &&
			            怪物视口X < 相机显示边长 + 缓冲区域 &&
			            怪物视口Y >= -缓冲区域 &&
			            怪物视口Y < 相机显示边长 + 缓冲区域 &&
			            (怪物实例.隐身中 ?? false) === false &&
			            (怪物所在房间ID === -1 ||
			                已访问房间.has(怪物所在房间ID) ||
			                (玩家属性.透视 && !当前天气效果.includes("诡魅") && !当前天气效果.includes("深夜")) ||
			                游戏状态 === "图鉴" ||
			                游戏状态 === '地图编辑器') &&
			            (
			                !(玩家状态.some(s => s.类型 === '失明') || (当前天气效果.includes("深夜")&& 游戏状态 !== '地图编辑器') ||
			                    (怪物所在房间 &&
			                        怪物所在房间.类型 === "黑暗房间") && 游戏状态 !== '地图编辑器') ||
			                是否在光源范围内(怪物实例.x, 怪物实例.y)
			            ) && 
			            !(地牢生成方式 === 'cave' && !已揭示洞穴格子.has(`${怪物实例.x},${怪物实例.y}`) && 游戏状态 !== '地图编辑器' && !玩家属性.透视)
			        ) {
			            let 怪物屏幕X, 怪物屏幕Y, 怪物图标大小;
			            if (怪物实例 instanceof 巨人怪物) {
			                怪物屏幕X = (绘制逻辑X - 当前相机X + 1) * 单元格大小;
			                怪物屏幕Y = (绘制逻辑Y - 当前相机Y + 1) * 单元格大小;
			                怪物图标大小 = 单元格大小 * 1.8;
			            } else {
			                怪物屏幕X = (绘制逻辑X - 当前相机X + 0.5) * 单元格大小;
			                怪物屏幕Y = (绘制逻辑Y - 当前相机Y + 0.5) * 单元格大小;
			                怪物图标大小 = 单元格大小 * 0.8;
			            }
			
			            ctx.font = `${怪物图标大小}px color-emoji`;
			            ctx.textAlign = "center";
			            ctx.textBaseline = "middle";
			
			            if (怪物实例.受击动画 && !(怪物实例 instanceof 蜈蚣部位)) {
			                ctx.fillStyle = "#FF0000";
			            } else {
			                ctx.fillStyle = 怪物实例.颜色 || "#FFFFFF";
			            }
			
			            if (怪物实例 instanceof 巡逻怪物) {
			                ctx.save();
			                ctx.translate(怪物屏幕X, 怪物屏幕Y);
			                const dir = 怪物实例.巡逻方向;
			                if (dir === 'S') {
			                    ctx.rotate(-Math.PI / 2);
			                } else if (dir === 'N') {
			                    ctx.rotate(Math.PI / 2);
			                } else if (dir === 'E') {
			                    ctx.scale(-1, 1);
			                }
			                ctx.fillText(怪物实例.图标, 0, 0);
			                ctx.restore();
			            } else if (怪物实例 instanceof 蜈蚣怪物) {
                ctx.save();
                ctx.translate(怪物屏幕X, 怪物屏幕Y);
                switch (怪物实例.朝向) {
                    case 'E': ctx.scale(-1, 1); break;
                    case 'N': ctx.rotate(Math.PI / 2); break;
                    case 'S': ctx.rotate(-Math.PI / 2); break;
                    case 'W': 
                    default:
                        break;
                }
                ctx.fillText(怪物实例.图标, 0, 0);
                ctx.restore();
            } else {
			                ctx.fillText(怪物实例.图标, 怪物屏幕X, 怪物屏幕Y);
			            }
			            怪物实例.绘制增益效果(怪物屏幕X, 怪物屏幕Y);
			
			            const 怪物当前状态 = 怪物状态表.get(怪物实例);
			            if (怪物当前状态) {
			                ctx.fillStyle = 怪物当前状态.颜色 || "#FFFFFF";
			                ctx.font = `${单元格大小 * 0.5}px Arial`;
			                const 状态图标X = 怪物屏幕X + 单元格大小 * 0.3;
			                const 状态图标Y = 怪物屏幕Y - 单元格大小 * 0.3;
			                ctx.fillText(
			                    怪物当前状态.图标 || "?",
			                    状态图标X,
			                    状态图标Y
			                );
			            } else if (怪物实例.强化 && 怪物实例.类型 != "伪装怪物") {
			                ctx.fillStyle = "#FF0000";
			                ctx.font = `${单元格大小 * 0.5}px Arial`;
			                const 强化标记X = 怪物屏幕X + 单元格大小 * 0.3;
			                const 强化标记Y = 怪物屏幕Y - 单元格大小 * 0.3;
			                ctx.fillText("强", 强化标记X, 强化标记Y);
			            }
			            if(游戏状态 !== '地图编辑器') 怪物实例.绘制血条();
			        }
			    });
				当前出战宠物列表.forEach(pet => {
					const 宠物所在房间ID = 房间地图[pet?.y]?.[pet?.x];
			        const 宠物所在房间 =
			            宠物所在房间ID !== -1 ? 房间列表[宠物所在房间ID] : null;
    if (pet && pet.是否已放置  && pet.层数==当前层数 && (
        !(玩家状态.some(s => s.类型 === '失明') || 当前天气效果.includes("深夜") ||
            (宠物所在房间 &&
                宠物所在房间.类型 === "黑暗房间") && 游戏状态 !== '地图编辑器') ||
        是否在光源范围内(pet.x, pet.y)
    ) && !(地牢生成方式 === 'cave' && !已揭示洞穴格子.has(`${pet.x},${pet.y}`) && 游戏状态 !== '地图编辑器' && !玩家属性.透视)) {
        const 动画状态 = 怪物动画状态.get(pet);
			        let 绘制逻辑X = pet.x;
			        let 绘制逻辑Y = pet.y;
			        const 正在动画 = 动画状态?.正在动画;
			
			        if (正在动画) {
			            绘制逻辑X = 动画状态.视觉X !== undefined ? 动画状态.视觉X : pet.x;
			            绘制逻辑Y = 动画状态.视觉Y !== undefined ? 动画状态.视觉Y : pet.y;
			        }
			        
			        const 宠物屏幕X = (绘制逻辑X - 当前相机X + 0.5) * 单元格大小;
			        const 宠物屏幕Y = (绘制逻辑Y - 当前相机Y + 0.5) * 单元格大小;
			
			        ctx.font = `${单元格大小 * 0.8}px color-emoji`;
			        ctx.textAlign = "center";
			        ctx.textBaseline = "middle";
			        ctx.fillStyle = pet.颜色表[pet.颜色索引] || '#FFFFFF';
			        ctx.shadowColor = pet.颜色表[pet.颜色索引] || '#FFFFFF';
			        ctx.shadowBlur = 10;
			        ctx.fillText(pet.图标, 宠物屏幕X, 宠物屏幕Y);
			        ctx.shadowBlur = 0;
			
			        const 血条高度 = 4;
			        const 血条Y = (绘制逻辑Y - 当前相机Y) * 单元格大小 - 6;
			        const 宽度 = 单元格大小;
			        const 血条X = (绘制逻辑X - 当前相机X) * 单元格大小;
			        
			        const 血量百分比 = Math.max(0, (pet.自定义数据.get("当前生命值") / pet.自定义数据.get("最大生命值")) * 100);
			        ctx.fillStyle = '#444';
			        ctx.fillRect(血条X, 血条Y, 宽度, 血条高度);
			        ctx.fillStyle = '#33cc33';
			        ctx.fillRect(血条X, 血条Y, 宽度 * (血量百分比 / 100), 血条高度);
    }
});
			    
			    if(编辑器状态.正在划区 || (编辑器状态.正在复制选区 && 编辑器状态.当前选中?.名称 === '复制工具')) {
			        ctx.save();
			        ctx.fillStyle = 'rgba(0, 150, 255, 0.3)';
			        ctx.strokeStyle = '#0096FF';
			        ctx.lineWidth = 2;
			        const 起点 = 编辑器状态.正在划区 ? 编辑器状态.划区起点 : 编辑器状态.复制起点;
			        const startScreenX = (起点.x - 当前相机X) * 单元格大小;
			        const startScreenY = (起点.y - 当前相机Y) * 单元格大小;
			        const currentScreenX = (玩家.x - 当前相机X) * 单元格大小;
			        const currentScreenY = (玩家.y - 当前相机Y) * 单元格大小;
			        const rectX = Math.min(startScreenX, currentScreenX);
			        const rectY = Math.min(startScreenY, currentScreenY);
			        const rectW = Math.abs(startScreenX - currentScreenX) + 单元格大小;
			        const rectH = Math.abs(startScreenY - currentScreenY) + 单元格大小;
			        ctx.fillRect(rectX, rectY, rectW, rectH);
			        ctx.strokeRect(rectX, rectY, rectW, rectH);
			        ctx.restore();
			    } else if (编辑器剪贴板 && 编辑器状态.当前选中?.名称 === '复制工具') {
			        ctx.save();
			        ctx.globalAlpha = 0.6;
			        const { 宽度, 高度, 数据, 只包含实体 } = 编辑器剪贴板;
			        for (const 条目 of 数据) {
			            const 目标X = 玩家.x + 条目.相对X;
			            const 目标Y = 玩家.y + 条目.相对Y;
			            const screenX = (目标X - 当前相机X) * 单元格大小;
			            const screenY = (目标Y - 当前相机Y) * 单元格大小;
			
			            if (只包含实体) {
			                ctx.fillStyle = 'rgba(200, 200, 255, 0.4)';
			                ctx.fillRect(screenX, screenY, 单元格大小, 单元格大小);
			            } else {
			                const tempCell = 克隆单元格(条目.单元格克隆);
			                tempCell.x = 目标X;
			                tempCell.y = 目标Y;
			                tempCell.绘制();
			            }
			        }
			        ctx.restore();
