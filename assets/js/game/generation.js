function 生成墙壁() {
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const 当前单元格 = 地牢[y][x];
			            if (当前单元格.是否强制墙壁) {
			                continue; 
			            }
			                if (
			                    [
			                        单元格类型.墙壁,
			                        单元格类型.走廊,
			                        单元格类型.房间,
			                    ].includes(当前单元格.背景类型)
			                ) {
			                    地牢[y][x].墙壁 = {
			                        上:
			                            y > 0 &&
			                            地牢[y - 1][x].背景类型 !==
			                                地牢[y][x].背景类型 &&
			                            [
			                                单元格类型.墙壁,
			                                单元格类型.走廊,
			                                单元格类型.房间,
			                            ].includes(地牢[y - 1][x].背景类型),
			                        下:
			                            y < 地牢大小 - 1 &&
			                            地牢[y + 1][x].背景类型 !==
			                                地牢[y][x].背景类型 &&
			                            [
			                                单元格类型.墙壁,
			                                单元格类型.走廊,
			                                单元格类型.房间,
			                            ].includes(地牢[y + 1][x].背景类型),
			                        左:
			                            x > 0 &&
			                            地牢[y][x - 1].背景类型 !==
			                                地牢[y][x].背景类型 &&
			                            [
			                                单元格类型.墙壁,
			                                单元格类型.走廊,
			                                单元格类型.房间,
			                            ].includes(地牢[y][x - 1].背景类型),
			                        右:
			                            x < 地牢大小 - 1 &&
			                            地牢[y][x + 1].背景类型 !==
			                                地牢[y][x].背景类型 &&
			                            [
			                                单元格类型.墙壁,
			                                单元格类型.走廊,
			                                单元格类型.房间,
			                            ].includes(地牢[y][x + 1].背景类型),
			                    };
			                } else {
			                    地牢[y][x].墙壁 = {
			                        上:
			                            y > 0 &&
			                            地牢[y - 1][x].背景类型 ===
			                                单元格类型.墙壁,
			                        下:
			                            y < 地牢大小 - 1 &&
			                            地牢[y + 1][x].背景类型 ===
			                                单元格类型.墙壁,
			                        左:
			                            x > 0 &&
			                            地牢[y][x - 1].背景类型 ===
			                                单元格类型.墙壁,
			                        右:
			                            x < 地牢大小 - 1 &&
			                            地牢[y][x + 1].背景类型 ===
			                                单元格类型.墙壁,
			                    };
			                }
			
			            
			        }
			    }
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const 当前单元格 = 地牢[y]?.[x];
			            if (!当前单元格) continue;
			
			            const 配对位置 = 当前单元格.配对单元格位置;
			            if (
			                配对位置 &&
			                [
			                    单元格类型.走廊,
			                    单元格类型.门,
			                    单元格类型.上锁的门,
			                ].includes(当前单元格.背景类型)
			            ) {
			                const 配对单元格 = 地牢[配对位置.y]?.[配对位置.x];
			                if (
			                    配对单元格 &&
			                    配对单元格.背景类型 === 当前单元格.背景类型
			                ) {
			                    if (配对位置.x > x) {
			                        
			                        当前单元格.墙壁.右 = false;
			                        配对单元格.墙壁.左 = false;
			                    } else if (配对位置.x < x) {
			                        
			                        当前单元格.墙壁.左 = false;
			                        配对单元格.墙壁.右 = false;
			                    } else if (配对位置.y > y) {
			                        
			                        当前单元格.墙壁.下 = false;
			                        配对单元格.墙壁.上 = false;
			                    } else if (配对位置.y < y) {
			                        
			                        当前单元格.墙壁.上 = false;
			                        配对单元格.墙壁.下 = false;
			                    }
			                }
			            }
			        }
			    }
			}

function 切换楼层(
			    新层数,
			    完全重生 = false,
			    目标坐标 = null,
			    通过楼梯切换 = false,
			    onCompleteCallback = null
			) {
			    const 遮罩 = document.getElementById("transitionMask");
			    const 标题 = document.getElementById("floorTitle");
			
			    遮罩.style.opacity = 1;
			    if (新层数 === 5 && 当前层数 !== 5) {
			        标题.textContent = `米诺陶的迷宫`;
			    } else if (新层数 === 10 && 当前层数 !== 10) {
			        标题.textContent = `法师图书馆`;
			    } else if (新层数 === 15 && 当前层数 !== 15) {
			        标题.textContent = `最终战场`;
			    } else {
			        标题.textContent = `地牢 ${
			            新层数 < 0 ? 当前层数 - 1 : 新层数
			        }`;
			    }
			    if (新层数 > 当前层数 && !所有地牢层.has(新层数)) {
			            const 定位器地图实例 = [...玩家装备.values()].find(item => item instanceof 定位器地图) || [...玩家背包.values()].find(item => item instanceof 定位器地图);
			            if (定位器地图实例) {
			                if (定位器地图实例.堆叠数量 > 1) {
			                    定位器地图实例.堆叠数量--;
			                    添加日志("消耗了一张定位器地图。", "信息");
			                } else {
			                    处理销毁物品(定位器地图实例.唯一标识, true);
			                    添加日志("消耗了最后一张定位器地图！", "警告");
			                }
			                更新背包显示();
			                更新装备显示();
			            }
			        }
			    setTimeout(() => {
			        标题.style.opacity = 1;
			        标题.style.transform = "scale(1)";
			    }, 200);
			
			    setTimeout(() => {
			        const 旧楼层数据 = 所有地牢层.get(当前层数);
			        const 当前数据 = {
			            地牢数组: 地牢,
			            房间列表: 房间列表,
			            门实例列表: 门实例列表,
			            玩家位置: { x: 玩家.x, y: 玩家.y },
			            上锁房间列表: 上锁房间列表,
			            已访问房间: 已访问房间,
			            地牢生成方式: 地牢生成方式,
			            已揭示洞穴格子: deepClone(已揭示洞穴格子),
			            房间地图: 房间地图,
			            所有怪物: 所有怪物,
			            玩家初始位置: { x: 玩家初始位置.x, y: 玩家初始位置.y },
			            所有计时器: 所有计时器,
			            当前天气效果: [...当前天气效果],
			        };
			
			        所有怪物.forEach((m) => {
			            m.绘制血条(true);
			        });
			
			        if (当前层数 !== null && !完全重生) {
			            const 待保存楼层数据 = 所有地牢层.get(当前层数) || {};
			            待保存楼层数据.地牢数组 = 地牢;
			            待保存楼层数据.房间列表 = 房间列表;
			            待保存楼层数据.门实例列表 = 门实例列表;
			            if (通过楼梯切换) {
			                待保存楼层数据.玩家位置 = { x: 玩家.x, y: 玩家.y };
			            } else {
			                if (!待保存楼层数据.玩家位置) {
			                    待保存楼层数据.玩家位置 = { x: 玩家初始位置.x, y: 玩家初始位置.y };
			                }
			            }
			            待保存楼层数据.上锁房间列表 = 上锁房间列表;
			            待保存楼层数据.已访问房间 = 已访问房间;
			            待保存楼层数据.地牢生成方式 = 地牢生成方式;
			            待保存楼层数据.已揭示洞穴格子 = deepClone(已揭示洞穴格子);
			            待保存楼层数据.房间地图 = 房间地图;
			            待保存楼层数据.所有怪物 = 所有怪物;
			            待保存楼层数据.玩家初始位置 = { x: 玩家初始位置.x, y: 玩家初始位置.y };
			            待保存楼层数据.所有计时器 = 所有计时器;
			            待保存楼层数据.当前天气效果 = [...当前天气效果];
			            所有地牢层.set(当前层数, 待保存楼层数据);
			        } else {
			            传送点列表 = [];
			        }
			
			        当前层数 = 新层数;
			        已揭示洞穴格子.clear();
			
			        if (所有地牢层.has(新层数)) {
			            const 新地牢数据 = 所有地牢层.get(新层数);
			            地牢 = 新地牢数据.地牢数组;
			            地牢大小 = 地牢.length;
			            房间列表 = 新地牢数据.房间列表;
			            门实例列表 = 新地牢数据.门实例列表;
			            上锁房间列表 = 新地牢数据.上锁房间列表;
			            已访问房间 = 新地牢数据.已访问房间;
			            已揭示洞穴格子 = deepClone(新地牢数据.已揭示洞穴格子);
			            地牢生成方式 = 新地牢数据.地牢生成方式;
			            房间地图 = 新地牢数据.房间地图;
			            所有怪物 = 新地牢数据.所有怪物;
			            所有计时器 = 新地牢数据.所有计时器;
			            玩家初始位置 = 新地牢数据.玩家初始位置;
			            当前天气效果 = 新地牢数据.当前天气效果 || [];
			            if (目标坐标 && 位置是否可用(目标坐标.x, 目标坐标.y, false)) {
			                玩家.x = 目标坐标.x;
			                玩家.y = 目标坐标.y;
			            } else {
			                玩家.x = 新地牢数据.玩家位置.x;
			                玩家.y = 新地牢数据.玩家位置.y;
			            }
			        } else if (当前层数 === 5) {
			            初始化随机数生成器(当前游戏种子);
			            生成迷宫关卡();
			        } else if (当前层数 === 10) {
			            初始化随机数生成器(当前游戏种子);
			            生成法师图书馆();
			        } else if (当前层数 === 15) {
			            初始化随机数生成器(当前游戏种子);
			            生成最终首领楼层();
			        } else if (当前层数 > 15){
			            初始化随机数生成器(当前游戏种子);
			            生成沉没的迷宫();
			            显示通知('喜悦...或是不甘？','信息');
			            彩蛋1触发 = true;
			        } else {
			            初始化随机数生成器(当前游戏种子);
			            for (let i=0;i<当前层数;i++) prng()
			            if(当前层数===0) {
			                当前出战宠物列表 = [];
			                
			            }
			            const 能量条 = document.querySelector(".power-bar");
			        if (能量条 && 玩家属性.初始能量加成 > 0) {
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            能量条.style.width = `${Math.min(100, 当前能量 + 玩家属性.初始能量加成/自定义全局设置.初始能量值*100)}%`;
			        }
			            房间列表 = [];
			            上锁房间列表 = [];
			            所有怪物 = [];
			            所有计时器 = [];
			            已访问房间 = new Set();
			            房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
			            门实例列表 = new Map();
			            
			            if (当前层数 !== null && 当前层数 % 3 === 0 && 当前层数 !== 0) {
			                生成天气效果();
			            } else {
			                当前天气效果 = [];
			            }
			            生成地牢();
			            //更新洞穴视野();
			            生成并放置随机配方卷轴(当前层数);
			            玩家.x = 玩家初始位置.x;
			            玩家.y = 玩家初始位置.y;
			        }
						当前出战宠物列表.forEach(pet => {
    if (!pet || !pet.是否已放置) return;
	const 瞬间移动 = Object.values(pet.自定义数据.get("装备") || {}).find(item => item instanceof 瞬间移动饰品);
			            if (瞬间移动) {
			                pet.瞬移到玩家身旁();
			            }
});
			
			        更新视口();
			        绘制小地图();
			        更新界面状态();
			        更新物体指示器();
			        更新洞穴视野();
			        所有怪物.forEach((m) => { m.绘制血条(true); });
			        移动玩家(0, 0);
			        if (typeof onCompleteCallback === 'function') {
			            onCompleteCallback(); 
			        }
			        
			
			        标题.style.opacity = 0;
			        标题.style.transform = "scale(0.5)";
			        遮罩.style.opacity = 0;
			    }, 1200);
			
			}

function 进入教程层() {
			    是否为教程层 = true;
			    教程阶段 = 0;
			    教程提示已显示 = false;
			    document.getElementById("跳过教程按钮").style.display = "block";
			    生成教程地牢();
			    setTimeout(() => {
			        显示教程提示();
			    }, 200);
			    更新物体指示器();
			    所有怪物.forEach((m) => {
			        m.绘制血条();
			    });
			    更新洞穴视野();
			}

