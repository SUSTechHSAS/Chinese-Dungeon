<!DOCTYPE html>
<html lang="zh-cmn-Hans">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=0.1" />
		<title>Dungeon Game</title>
		<style>
			/*或哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈*/
			/* General Styles */
			/* Welcome to Chinese Dungeon 这里是中文世界*/
			body {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: flex-start;
			height: 100vh;
			margin: 0;
			padding-top: 5vh;
			background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%);
			background-color: #1a1a1a;
			overflow: hidden;
			justify-content: flex-start;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			}
			/*隐藏滚轮*/
			::-webkit-scrollbar {
			display: none;
			}
			/* 不可选中 */
			.不可选中 {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			}
			/* Dungeon Canvas */
			#dungeonCanvas {
			border: 2px solid #2e2e2e;
			border-radius: 8px;
			box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
			margin-bottom: 5vh;
			transition: transform 0.15s ease-out;
			filter: contrast(1.1) brightness(1.1);
			}

			/* --- 游戏信息弹窗 --- */
.game-info-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(8px);
    z-index: 10015; /* 确保在最上层 */
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

.game-info-overlay.show {
    opacity: 1;
    pointer-events: auto;
}

.game-info-window {
    background: linear-gradient(160deg, #1e1e1e 0%, #2c2c2c 100%);
    border: 1px solid #4caf50;
    border-radius: 12px;
    padding: 25px;
    box-shadow: 0 0 50px rgba(76, 175, 80, 0.25);
    width: 90%;
    max-width: 700px;
    max-height: 85vh;
    display: flex;
    flex-direction: column;
    color: #e0e0e0;
    transform: scale(0.95);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.game-info-overlay.show .game-info-window {
    transform: scale(1);
}

.game-info-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(76, 175, 80, 0.3);
    padding-bottom: 15px;
    margin-bottom: 20px;
    flex-shrink: 0;
}

.game-info-header h2 {
    margin: 0;
    font-size: 1.6em;
    color: #4caf50;
    text-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
}

.game-info-content {
    overflow-y: auto;
    flex-grow: 1;
    padding-right: 15px; /* for scrollbar */
    line-height: 1.7;
}

.game-info-content h3 {
    font-size: 1.3em;
    color: #e0e0e0;
    border-bottom: 1px dashed #555;
    padding-bottom: 8px;
    margin-top: 20px;
    margin-bottom: 15px;
}
.game-info-content h3:first-child {
    margin-top: 0;
}

.game-info-content ul {
    list-style-type: disc;
    padding-left: 25px;
}

.game-info-content li {
    margin-bottom: 10px;
}

.info-version-tag {
    background: #4caf50;
    color: #1a1a1a;
    font-size: 0.7em;
    padding: 3px 8px;
    border-radius: 4px;
    vertical-align: middle;
    margin-left: 10px;
    font-weight: bold;
}
			#种子筛选器按钮 {
    width: 42px;
    height: 42px;
    padding: 0;
    font-size: 1.5em;
    font-family: "color-emoji";
    border-radius: 6px;
    border: 1px solid var(--ui-border-color);
    background-color: var(--ui-bg-color);
    color: var(--ui-text-color);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    display: flex;
    align-items: center;
    justify-content: center;
}

#种子筛选器按钮:hover {
    border-color: #2196f3; /* 蓝色高亮 */
    box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
}
			#职业选择遮罩 {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.7);
			backdrop-filter: blur(8px);
			z-index: 10005;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0;
			pointer-events: none;
			transition: none;
			animation: none;
			}
			#职业选择窗口 {
			position: absolute;
			background: linear-gradient(160deg, #1a1a1a 0%, #2a2a2a 100%);
			border: 1px solid #4caf50;
			border-radius: 12px;
			padding: 25px;
			box-shadow: 0 0 40px rgba(76, 175, 80, 0.2);
			width: 90%;
			display: flex;
			flex-direction: column;
			color: #e0e0e0;
			font-family: inherit;
			opacity: 0; /* 初始状态由 GSAP 控制 */
			visibility: hidden; /* 初始状态由 GSAP 控制 */
			transition: none;
			animation: none;
			}
			.职业选择标题 {
			font-size: 1.6em;
			color: #4caf50;
			text-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
			margin: 0 0 20px 0;
			padding-bottom: 15px;
			border-bottom: 1px solid rgba(76, 175, 80, 0.3);
			text-align: center;
			}
		    .职业选择页脚 {
			display: flex;
			justify-content: space-between;
			gap: 15px;
			margin-top: 20px;
			padding-top: 20px;
			border-top: 1px solid rgba(76, 175, 80, 0.3);
			}
			.种子输入容器 {
			display: flex;
			align-items: center;
			gap: 10px;
			}
			#游戏种子输入 {
			flex-grow: 1;
			}
			#每日挑战按钮 {
			flex-shrink: 0;
			width: 42px;
			height: 42px;
			padding: 0;
			font-size: 1.5em;
			font-family: "color-emoji";
			border-radius: 6px;
			border: 1px solid var(--ui-border-color);
			background-color: var(--ui-bg-color);
			color: var(--ui-text-color);
			cursor: pointer;
			transition: all 0.2s ease-in-out;
			display: flex;
			align-items: center;
			justify-content: center;
			}
			#每日挑战按钮:hover {
			border-color: var(--ui-accent-color);
			box-shadow: 0 0 10px var(--ui-accent-glow);
			}
			.职业选项容器 {
			display: flex;
			flex-direction: row;
			align-items: center;
			overflow-x: auto;
			padding: 20px 0;
			margin: 15px -25px;
			scrollbar-width: none;
			-ms-overflow-style: none;
			scroll-snap-type: x mandatory;
			-webkit-overflow-scrolling: touch;
			}
			.职业选项容器::-webkit-scrollbar {
			display: none;
			}
			.职业按钮 {
			flex: 0 0 140px;
			padding: 20px 15px;
			margin: 0 10px;
			border: 2px solid #555;
			border-radius: 12px;
			background: rgba(255,255,255,0.05);
			color: #ccc;
			cursor: pointer;
			transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
			text-align: center;
			transform: scale(0.85);
			opacity: 0.6;
			scroll-snap-align: center;
			}
			.职业按钮:first-child {
			margin-left: calc(50% - 80px);
			}
			.职业按钮:last-child {
			margin-right: calc(50% - 80px);
			}
			.职业按钮:hover {
			transform: scale(0.9) translateY(-2px);
			}
			.职业按钮.active {
			background: rgba(76, 175, 80, 0.2);
			border-color: #4caf50;
			transform: scale(1.1) translateY(-5px);
			box-shadow: 0 6px 20px rgba(76, 175, 80, 0.3);
			color: #fff;
			opacity: 1;
			}
			.职业按钮 .职业图标 {
			font-size: 3em;
			display: block;
			margin-bottom: 10px;
			color: white;
			font-family: 'color-emoji';
			transition: transform 0.4s ease;
			}
			.职业按钮.active .职业图标 {
			transform: rotate(-10deg) scale(1.1);
			}
			/*   设置窗口    */
			#设置窗口遮罩 {
			position: fixed;
			top: -2vh;
			left: 2.5vw;
			width: 95vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.7);
			backdrop-filter: blur(8px);
			z-index: 10010;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
			}
			#设置窗口 {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%) scale(0.95);
			background: linear-gradient(160deg, #1a1a1a 0%, #2a2a2a 100%);
			border: 1px solid #4caf50;
			border-radius: 12px;
			padding: 25px;
			box-shadow: 0 0 40px rgba(76, 175, 80, 0.2);
			width: 90%;
			max-width: 700px;
			max-height: 90vh;
			display: flex;
			flex-direction: column;
			color: #e0e0e0;
			font-family: inherit;
			transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			}
			#设置窗口遮罩.显示 #设置窗口 {
			transform: translate(-50%, -50%) scale(1);
			}
			#设置窗口遮罩.显示 {
			opacity: 1;
			pointer-events: auto;
			}
			.设置标题行 {
			display: flex;
			justify-content: space-between;
			align-items: center;
			border-bottom: 1px solid rgba(76, 175, 80, 0.3);
			padding-bottom: 15px;
			margin-bottom: 20px;
			}
			.设置标题行 .设置标题 {
			margin: 0;
			font-size: 1.6em;
			color: #4caf50;
			text-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
			}
			.设置内容 {
			overflow-y: auto;
			flex-grow: 1;
			padding-right: 10px;
			}
			.设置分区 {
			margin-bottom: 25px;
			}
			.设置分区 h3 {
			font-size: 1.2em;
			color: #e0e0e0;
			border-bottom: 1px dashed #555;
			padding-bottom: 8px;
			margin-bottom: 15px;
			}
			.设置行 {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 15px;
			padding: 8px 0;
			}
			.设置标签 {
			flex-shrink: 0;
			margin-right: 20px;
			color: #ccc;
			}
			.设置页脚 {
			padding-top: 20px;
			margin-top: 20px;
			border-top: 1px solid rgba(76, 175, 80, 0.3);
			display: flex;
			justify-content: flex-end;
			}
			.热键绑定网格 {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
			gap: 12px;
			}
			.热键绑定条目 {
			display: flex;
			align-items: center;
			justify-content: space-between;
			background: rgba(255, 255, 255, 0.05);
			padding: 8px 12px;
			border-radius: 6px;
			}
			.热键输入 {
			background: #1e1e1e;
			border: 1px solid #555;
			color: #4caf50;
			padding: 8px;
			border-radius: 4px;
			width: 100px;
			text-align: center;
			font-weight: bold;
			cursor: pointer;
			transition: all 0.2s;
			}
			.热键输入:focus,
			.热键输入.capturing {
			border-color: #4caf50;
			box-shadow: 0 0 8px rgba(76, 175, 80, 0.5);
			outline: none;
			}
			input[type="range"] {
			-webkit-appearance: none;
			appearance: none;
			width: 50%;
			height: 8px;
			background: #333;
			outline: none;
			border-radius: 4px;
			border: 1px solid #555;
			}
			input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 20px;
			height: 20px;
			background: #4caf50;
			cursor: pointer;
			border-radius: 50%;
			border: 2px solid #1a1a1a;
			transition: background 0.2s;
			}
			input[type="range"]::-moz-range-thumb {
			width: 20px;
			height: 20px;
			background: #4caf50;
			cursor: pointer;
			border-radius: 50%;
			border: 2px solid #1a1a1a;
			}
			input[type="range"]:hover::-webkit-slider-thumb {
			background: #66bb6a;
			}
			input[type="range"]:active::-webkit-slider-thumb {
			box-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
			}
			.设置行 span {
			width: 60px;
			text-align: left;
			color: #aaa;
			}
			.设置切换按钮 {
			position: relative;
			width: 60px;
			height: 30px;
			background-color: #333;
			border: 1px solid #555;
			border-radius: 15px;
			cursor: pointer;
			transition: background-color 0.3s;
			}
			.设置切换按钮::before {
			content: "";
			position: absolute;
			top: 3px;
			left: 4px;
			width: 22px;
			height: 22px;
			background-color: #ccc;
			border-radius: 50%;
			transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			}
			.设置切换按钮.active {
			background-color: #4caf50;
			}
			.设置切换按钮.active::before {
			transform: translateX(29px);
			background-color: #fff;
			}
			/* --- 编辑器与设置窗口UI --- */
			.重铸弹窗,
			#编辑器属性面板,
			#全局设置窗口 {
			--ui-bg-color: #2c2c2e;
			--ui-border-color: #4a4a4a;
			--ui-text-color: #e0e0e0;
			--ui-accent-color: #4caf50;
			--ui-accent-glow: rgba(76, 175, 80, 0.5);
			--ui-label-color: #aaa;
			}
			.重铸弹窗 input,
			.重铸弹窗 select,
			.重铸弹窗 textarea,
			#编辑器属性面板 input,
			#编辑器属性面板 select,
			#编辑器属性面板 textarea,
			#全局设置窗口 input,
			#全局设置窗口 select,
			#全局设置窗口 textarea {
			background-color: var(--ui-bg-color);
			border: 1px solid var(--ui-border-color);
			color: var(--ui-text-color);
			padding: 10px 12px;
			border-radius: 6px;
			font-family: inherit;
			font-size: 1em;
			width: 100%;
			box-sizing: border-box;
			transition: all 0.2s ease-in-out;
			-webkit-appearance: none;
			-moz-appearance: none;
			appearance: none;
			}
			.重铸弹窗 input:focus,
			.重铸弹窗 select:focus,
			.重铸弹窗 textarea:focus,
			#编辑器属性面板 input:focus,
			#编辑器属性面板 select:focus,
			#编辑器属性面板 textarea:focus,
			#全局设置窗口 input:focus,
			#全局设置窗口 select:focus,
			#全局设置窗口 textarea:focus {
			border-color: var(--ui-accent-color);
			box-shadow: 0 0 10px var(--ui-accent-glow);
			outline: none;
			}
			.重铸弹窗 select,
			#编辑器属性面板 select,
			#全局设置窗口 select {
			background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23cccccc' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E");
			background-repeat: no-repeat;
			background-position: right 12px center;
			background-size: 16px;
			padding-right: 40px;
			}
			.重铸弹窗 textarea,
			#编辑器属性面板 textarea,
			#全局设置窗口 textarea {
			min-height: 80px;
			resize: vertical;
			}
			.重铸弹窗 .设置项目,
			#编辑器属性面板 .设置项目,
			#全局设置窗口 .设置项目 {
			display: flex;
			flex-direction: row;
			align-items: center;
			justify-content: space-between;
			gap: 15px;
			margin-bottom: 10px;
			}
			.重铸弹窗 .设置项目 label,
			#编辑器属性面板 .设置项目 label,
			#全局设置窗口 .设置项目 label {
			flex-shrink: 0;
			color: var(--ui-label-color);
			font-size: 0.95em;
			}
			.重铸弹窗 input[type="checkbox"],
			#编辑器属性面板 input[type="checkbox"],
			#全局设置窗口 input[type="checkbox"] {
			position: relative;
			width: 22px;
			height: 22px;
			cursor: pointer;
			border-radius: 4px;
			}
			.重铸弹窗 input[type="checkbox"]::before,
			#编辑器属性面板 input[type="checkbox"]::before,
			#全局设置窗口 input[type="checkbox"]::before {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: var(--ui-bg-color);
			border: 1px solid var(--ui-border-color);
			border-radius: 4px;
			transition: all 0.2s ease-in-out;
			}
			.重铸弹窗 input[type="checkbox"]:checked::before,
			#编辑器属性面板 input[type="checkbox"]:checked::before,
			#全局设置窗口 input[type="checkbox"]:checked::before {
			background-color: var(--ui-accent-color);
			border-color: var(--ui-accent-color);
			}
			.重铸弹窗 input[type="checkbox"]:checked::after,
			#编辑器属性面板 input[type="checkbox"]:checked::after,
			#全局设置窗口 input[type="checkbox"]:checked::after {
			content: '✓';
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: white;
			font-size: 16px;
			line-height: 1;
			}
			#返回游戏模式选择按钮:hover {
			background: rgba(76, 175, 80, 0.4);
			transform: scale(1.1);
			border-color: #66bb6a;
			}
			/* --- 主菜单 --- */
			#主菜单容器 {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%);
			display: nonr;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			z-index: 10005;
			opacity: 1;
			transition: opacity 0.5s ease-out;
			color: #e0e0e0;
			font-family: "HarmonyOS Sans SC", "MiSans", system-ui,
			"color-emoji";
			overflow: scroll;
			}
			#游戏标题 {
			font-size: 5rem;
			margin-bottom: 3rem;
			color: #4caf50;
			text-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
			font-family: "Arial Black", Gadget, sans-serif;
			letter-spacing: 2px;
			animation: 标题浮动 3s ease-in-out infinite;
			}
			@keyframes 标题浮动 {
			0%,
			100% {
			transform: translateY(0);
			}
			50% {
			transform: translateY(-10px);
			}
			}
			#菜单选项 {
			display: flex;
			flex-direction: column;
			gap: 1.5rem;
			}
			.菜单按钮 {
			padding: 1rem 2.5rem;
			font-size: 1.4rem;
			border: 2px solid #4caf50;
			border-radius: 8px;
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.2),
			rgba(67, 160, 71, 0.1));
			color: #e0e0e0;
			cursor: pointer;
			transition: all 0.3s ease;
			text-align: center;
			font-family: inherit;
			}
			.菜单按钮:hover {
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.4),
			rgba(67, 160, 71, 0.3));
			transform: translateY(-3px);
			box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
			border-color: #66bb6a;
			}
			.菜单按钮:active {
			transform: translateY(1px);
			box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
			}
			.菜单按钮:disabled {
			background: rgba(100, 100, 100, 0.2);
			border-color: #666;
			color: #888;
			cursor: not-allowed;
			transform: none;
			box-shadow: none;
			}
			#版本信息 {
			position: fixed;
			bottom: 10px;
			right: 10px;
			font-size: 0.8rem;
			color: #555;
			}
			/* --- 游戏状态控制 --- */
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #dungeonCanvas,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) .hud,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) .control-pad,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) .装备栏,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #小地图容器,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) .control-row,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #怪物指示器容器,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #浮动提示框,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) .背包弹窗,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #日志面板,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #交易窗口,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) .附魔弹窗,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) .宠物遮罩,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #教程提示窗口,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #跳过教程按钮,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #回放教程按钮,
			body:not(.游戏进行中):not(.地图编辑器模式):not(.编辑器游玩模式) #设置菜单 {
			display: none;
			opacity: 0;
			pointer-events: none;
			}
			body.游戏进行中 #主菜单容器,
			body.地图编辑器模式 #主菜单容器,
			body.编辑器游玩模式 #主菜单容器 {
			opacity: 0;
			pointer-events: none;
			}
			body.初始化 {
			display: none;
			opacity: 0;
			pointer-events: none;
			}
			body:not(.地图编辑器模式) #编辑器工具栏,
			body:not(.地图编辑器模式) #编辑器属性面板遮罩,
			body:not(.地图编辑器模式):not(.编辑器游玩模式) #返回编辑器按钮 {
			display: none;
			}
			.地图编辑器模式 .hud,
			.地图编辑器模式 #怪物指示器容器,
			.地图编辑器模式 #日志面板,
			.地图编辑器模式 #设置菜单,
			.地图编辑器模式 #hudToggle,
			.地图编辑器模式 #回放教程按钮,
			.地图编辑器模式 #跳过教程按钮,
			.地图编辑器模式 #设置按钮 {
			display: none !important;
			}
			.地图编辑器模式 #融合窗口,
			.编辑器游玩模式 #编辑器工具栏,
			.编辑器游玩模式 #编辑器属性面板遮罩 {
			display: none;
			}
			body:not(.编辑器游玩模式) #返回编辑器按钮 {
			display: none;
			}
			.编辑器游玩模式 #回放教程按钮 {
			display: none !important
			}
			body:is(.地图编辑器模式, .编辑器游玩模式) #跳过教程按钮 {
			display: none !important
			}
			/* --- HUD --- */
			.hud {
			position: absolute;
			top: 5px;
			left: 5px;
			color: white;
			background: rgba(0, 0, 0, 0.7);
			padding: 12px;
			border-radius: 8px;
			font-family: Arial;
			display: flex;
			opacity: 0;
			transition: opacity 0.3s ease;
			pointer-events: none;
			min-width: 180px;
			flex-direction: column;
			}
			.hud.可见 {
			opacity: 1;
			pointer-events: auto;
			}
			/* --- 地图实体 --- */
			.怪物图标 {
			position: absolute;
			font-size: 1.2em;
			text-shadow: 0 0 8px #ff0000;
			transition: transform 0.2s;
			}
			/* 扣血特效 */
			.扣血遮罩 {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(255, 0, 0, 0.3);
			opacity: 0;
			pointer-events: none;
			animation: 扣血脉冲 0.8s ease-out;
			}
			@keyframes 扣血脉冲 {
			0% {
			opacity: 0.8;
			}
			100% {
			opacity: 0;
			}
			}
			.怪物指示器 {
			position: fixed;
			left: 0;
			top: 0;
			width: 12px;
			height: 12px;
			background: #ff4444;
			border-radius: 50%;
			box-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
			pointer-events: none;
			transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
			z-index: 1000;
			}
			/* 调整触发按钮样式 */
			#hudToggle {
			width: 6vmin;
			height: 6vmin;
			font-size: 3vmin;
			background: #2196f3;
			position: absolute;
			left: 48%;
			transform: translateX(-50%);
			bottom: 120%;
			z-index: 1000;
			}
			.hud-item {
			display: flex;
			align-items: center;
			gap: 8px;
			margin-bottom: 12px;
			/* 增加条目间距 */
			}
			.hud-icon {
			font-family: "color-emoji";
			font-size: 1.2em;
			width: 24px;
			text-align: center;
			}
			.hud-bar-container {
			position: relative;
			flex-grow: 1;
			height: 14px;
			margin-top: 4px;
			/* 进度条与图标间距 */
			height: 18px;
			/* 增大容器高度 */
			}
			.health-bar {
			background: linear-gradient(to right, #ff4444, #ff7676);
			}
			.power-bar {
			background: linear-gradient(to right, #1554db, #2c73f7);
			}
			.hud-label {
			color: #4caf50;
			font-size: 0.9em;
			}
			.怪物数量警告 {
			color: #ff4444;
			}
			.界面文本行 {
			color: #4caf50;
			font-size: 0.9em;
			display: flex;
			justify-content: space-between;
			}
			.进度条标签 {
			position: absolute;
			left: 4px;
			/* 改为左侧定位 */
			white-space: nowrap;
			bottom: 1px;
			color: rgba(255, 255, 255, 0.9);
			font-size: 0.75em;
			text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
			z-index: 2;
			/* 确保文字在上层 */
			}
			.hud-bar {
			position: relative;
			height: 100%;
			border-radius: 4px;
			transition: width 0.3s ease;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
			}
			@keyframes 进度条呼吸 {
			0% {
			opacity: 0.9;
			}
			50% {
			opacity: 0.7;
			}
			100% {
			opacity: 0.9;
			}
			}
			.低数值警告 {
			animation: 进度条呼吸 1.5s ease infinite;
			}
			/* --- Control Panel --- */
			.control-pad {
    position: fixed;
    pointer-events: none;
    left: 2vw;
    bottom: 220px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
			#方向键容器 {
			position: fixed;
			left: 20px;
			top: 50%;
			display: flex;
			gap: 1rem;
			}
			.control-row {
			display: flex;
			justify-content: center;
			margin: 5px 0;
			gap: 1.2rem;
			}
			.control-btn {
			font-family: "color-emoji";
			pointer-events: auto;
			width: 13vmin;
			height: 13vmin;
			border-radius: 3vmin;
			margin: 0 2px;
			font-size: 3vmin;
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.9) 30%,
			rgba(67, 160, 71, 0.9) 100%);
			transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
			box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
			color: white;
			border: 2px solid #fff;
			opacity: 0.95;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			}
			.control-btn:active {
			background: #45a049;
			transform: scale(0.9);
			box-shadow: 0 0 5px rgba(76, 175, 80, 0.8);
			}
			#upBtn {
			margin-bottom: -12px;
			z-index: 2;
			}
			#leftBtn,
			#rightBtn {
			margin-left: -64px;
			margin: 0 1rem;
			}
			#downBtn {
			margin-top: -12px;
			z-index: 1;
			}
			#背包按钮 {
			/* Backpack Button */
			background: #2196f3;
			box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
			}
			/* --- Inventory (背包) --- */
			.背包弹窗 {
			/* Inventory Popup */
			position: fixed;
			bottom: -1200px;
			left: 50%;
			transform: translateX(-50%);
			width: 80vmin;
			background: rgba(0, 0, 0, 0.9);
			border-radius: 12px;
			padding: 15px;
			transition: bottom 0.3s ease;
			z-index: 1001;
			max-height: 50vh;
			display: flex;
			flex-direction: column;
			}
			.背包弹窗.显示中 {
			bottom: 17vh;
			}
			.弹窗头部 {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 10px;
			}
			.弹窗头部 h3 {
			color: #4caf50;
			margin: 0;
			font-size: 1.2em;
			}
			.关闭按钮 {
			background: transparent;
			border: none;
			color: white;
			font-size: 1.5em;
			cursor: pointer;
			padding: 8px;
			}
			.物品容器 {
			flex: 1;
			overflow-y: auto;
			padding: 5px;
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
			gap: 8px;
			}
			.物品条目 {
			position: relative;
			border-radius: 8px;
			padding: 12px;
			cursor: pointer;
			transition: all 0.2s;
			}
			.hover:hover {
			background: rgba(255, 255, 255, 0.2);
			transform: translateY(-2px);
			}
			.物品图标 {
			font-family: "color-emoji";
			font-size: 2em;
			text-align: center;
			margin-bottom: 8px;
			filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
			transition: transform 0.3s;
			}
			.汉字图标 {
			font-family: "Microsoft YaHei", sans-serif;
			}
			.hover:hover .物品图标 {
			transform: scale(1.2) rotate(-15deg);
			}
			.物品名称 {
			font-size: 0.9em;
			text-align: center;
			color: #fff;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			}
			.物品堆叠 {
			position: absolute;
			bottom: 5px;
			right: 5px;
			background: linear-gradient(45deg,
			rgba(0, 0, 0, 0.6),
			rgba(50, 50, 50, 0.8));
			color: #fff;
			padding: 2px 6px;
			border-radius: 10px;
			font-size: 0.7em;
			font-weight: bold;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
			}
			.装备按钮,
			.上屏按钮,
			.丢弃按钮,
			.使用按钮 {
			font-family: "color-emoji";
			position: absolute;
			width: 24px;
			height: 24px;
			border-radius: 50%;
			border: none;
			color: white;
			cursor: pointer;
			opacity: 0;
			transition: all 0.3s;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			padding: 0;
			z-index: 1;
			pointer-events: none;
			}
			.物品条目:hover .装备按钮,
			.物品条目:hover .丢弃按钮,
			.物品条目:hover .上屏按钮,
			.物品条目:hover .使用按钮,
			.物品条目.active .装备按钮,
			.物品条目.active .丢弃按钮,
			.物品条目.active .上屏按钮,
			.物品条目.active .使用按钮 {
			opacity: 1;
			pointer-events: auto;
			}
			.装备按钮 {
			bottom: 3px;
			left: 3px;
			background: linear-gradient(145deg, #ffb74d, #ff9800);
			/* 橙色渐变 */
			}
			.装备按钮:hover {
			background: linear-gradient(145deg, #ffa726, #fb8c00);
			box-shadow: 0 2px 6px rgba(255, 152, 0, 0.4);
			}
			.上屏按钮 {
			bottom: 3px;
			right: 3px;
			background: linear-gradient(145deg, #4fc3f7, #29b6f6);
			}
			.丢弃按钮 {
			top: 3px;
			right: 3px;
			background: linear-gradient(145deg, #bdbdbd, #9e9e9e);
			/* 灰色渐变 */
			}
			.丢弃按钮:hover {
			background: linear-gradient(145deg, #aeaeae, #8e8e8e);
			box-shadow: 0 2px 6px rgba(158, 158, 158, 0.4);
			}
			.使用按钮 {
			top: 3px;
			left: 3px;
			background: linear-gradient(145deg, #81c784, #4caf50);
			/* 绿色渐变 */
			}
			.使用按钮:hover {
			background: linear-gradient(145deg, #66bb6a, #43a047);
			box-shadow: 0 2px 6px rgba(76, 175, 80, 0.4);
			}
			.物品条目:hover .装备按钮,
			.物品条目:hover .丢弃按钮,
			.物品条目:hover .上屏按钮,
			.物品条目:hover .使用按钮 {
			opacity: 1;
			}
			.物品条目.active .物品图标 {
			transform: scale(1.2) rotate(-15deg);
			}
			.冷却标签 {
			position: absolute;
			bottom: 2px;
			background: rgba(0, 0, 0, 0.7);
			color: #fff;
			padding: 2px 5px;
			border-radius: 3px;
			font-size: 0.8em;
			}
			.耐久标签 {
			position: absolute;
			bottom: 2px;
			background: rgba(0, 0, 0, 0.7);
			color: #fff;
			padding: 2px 5px;
			border-radius: 3px;
			font-size: 0.8em;
			z-index: 2;
			white-space: nowrap;
			}
			/* 怪物血条 */
			.怪物血条 {
			position: fixed;
			height: 4px;
			background: rgba(0, 0, 0, 0.5);
			border-radius: 2px;
			pointer-events: none;
			z-index: 100;
			}
			.血条背景 {
			height: 100%;
			background: #444;
			}
			.当前血量 {
			height: 100%;
			background: #f00;
			transition: width 0.3s;
			}
			/* 死亡动画 */
			.骷髅图标 {
			font-family: "color-emoji";
			font-size: 80px;
			animation: 骷髅抖动 1s infinite;
			}
			.死亡文字 {
			color: white;
			font-size: 40px;
			text-shadow: 0 0 10px red;
			margin-top: 20px;
			}
			.重生选项 {
			margin-top: 20px;
			display: flex;
			flex-direction: column;
			gap: 15px;
			}
			.重生按钮 {
			font-family: "color-emoji";
			padding: 12px 24px;
			font-size: 18px;
			border: 2px solid #fff;
			border-radius: 8px;
			background: rgba(255, 255, 255, 0.1);
			color: white;
			cursor: pointer;
			transition: all 0.3s;
			}
			.重生按钮:hover {
			background: rgba(255, 255, 255, 0.3);
			transform: scale(1.05);
			}
			.死亡内容 {
			text-align: center;
			animation: 死亡浮现 1s ease-out;
			}
			#死亡遮罩 {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: linear-gradient(45deg,
			rgba(20, 0, 0, 0.9) 0%,
			rgba(60, 0, 0, 0.95) 100%);
			backdrop-filter: blur(10px);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 10007;
			animation: 界面浮现 0.8s cubic-bezier(0.4, 0, 0.2, 1);
			}
			@keyframes 界面浮现 {
			from {
			opacity: 0;
			transform: translateY(20px);
			}
			to {
			opacity: 1;
			transform: translateY(0);
			}
			}
			.死亡内容容器 {
			font-family: "color-emoji";
			background: rgba(10, 0, 0, 0.8);
			border: 2px solid #ff444480;
			border-radius: 16px;
			padding: 40px 60px;
			box-shadow: 0 0 40px rgba(255, 50, 50, 0.3);
			text-align: center;
			}
			.骷髅容器 {
			position: relative;
			margin-bottom: 30px;
			}
			.动态骷髅 {
			font-size: 6rem;
			text-shadow: 0 0 30px #ff0000;
			animation: 骷髅呼吸 2s ease-in-out infinite;
			display: inline-block;
			}
			@keyframes 骷髅呼吸 {
			0% {
			transform: scale(1) rotate(-5deg);
			opacity: 0.9;
			}
			50% {
			transform: scale(1.1) rotate(5deg);
			opacity: 1;
			}
			100% {
			transform: scale(1) rotate(-5deg);
			opacity: 0.9;
			}
			}
			.重生选项 {
			font-family: "color-emoji";
			display: grid;
			gap: 20px;
			margin-top: 30px;
			}
			.重生按钮 {
			font-family: "color-emoji";
			padding: 16px 32px;
			font-size: 1.2rem;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.3s ease;
			background: linear-gradient(145deg,
			rgba(100, 0, 0, 0.8),
			rgba(150, 0, 0, 0.6));
			color: #fff;
			position: relative;
			overflow: hidden;
			border: 1px solid #ff4444;
			}
			.重生按钮::before {
			content: "";
			position: absolute;
			top: 0;
			left: -100%;
			width: 100%;
			height: 100%;
			background: linear-gradient(90deg,
			transparent,
			rgba(255, 255, 255, 0.2),
			transparent);
			transition: 0.5s;
			}
			.重生按钮:hover::before {
			left: 100%;
			}
			.重生按钮:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 20px rgba(255, 50, 50, 0.4);
			}
			.重生按钮:active {
			transform: translateY(1px);
			}
			#重新开始 {
			background: linear-gradient(145deg,
			rgba(50, 50, 50, 0.8),
			rgba(30, 30, 30, 0.6));
			border-color: #666;
			}
			@keyframes 粒子飘落 {
			0% {
			transform: translate(0, 0) scale(1);
			opacity: 0.8;
			}
			100% {
			transform: translate(calc(var(--random) * 100 - 50) px,
			100vh) scale(0);
			opacity: 0;
			}
			}
			/* 添加点击态样式 */
			.物品条目.active {
			background: rgba(255, 255, 255, 0.2) !important;
			transform: translateY(-2px) !important;
			}
			.物品条目.active .装备按钮,
			.物品条目.active .丢弃按钮,
			.物品条目.active .上屏按钮,
			.物品条目.active .使用按钮 {
			opacity: 1 !important;
			}
			.物品条目[data-quality="1"] {
			border: 1px solid #00ff00;
			}
			.物品条目[data-quality="2"] {
			border: 1px solid #0000ff;
			}
			.物品条目[data-quality="3"] {
			border: 1px solid #ffff00;
			}
			.物品条目[data-quality="4"] {
			animation: 紫光脉动 2s infinite;
			}
			@keyframes 紫光脉动 {
			0%,
			100% {
			box-shadow: 0 0 12px rgba(224, 64, 251, 0.3);
			}
			50% {
			box-shadow: 0 0 24px rgba(224, 64, 251, 0.6);
			}
			}
			.物品条目[data-quality="5"] {
			animation: 红光脉动 2s infinite;
			}
			@keyframes 红光脉动 {
			0%,
			100% {
			box-shadow: 0 0 12px #ff0000;
			}
			50% {
			box-shadow: 0 0 24px #ff0000;
			}
			}
			.装备栏 {
			position: fixed;
			bottom: 10px;
			width: 30%;
			min-width: 400px;
			background: rgba(0, 0, 0, 0.7);
			padding: 10px;
			border-radius: 12px;
			display: flex;
			justify-content: center;
			gap: 1vw;
			z-index: 1000;
			transition: opacity 0.3s ease;
			}
			.装备槽 {
			flex: 1;
			aspect-ratio: 1 / 1;
			max-width: 80px;
			background: rgba(255, 255, 255, 0.1);
			border-radius: 8px;
			position: relative;
			overflow: hidden;
			display: flex;
			align-items: center;
			justify-content: center;
			transition: all 0.2s;
			}
			.冷却遮罩 {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.7);
			clip-path: inset(0 0 100% 0);
			transition: clip-path 0.22s linear;
			pointer-events: none;
			}
			.装备槽 .物品条目 {
			transform: scale(0.65);
			margin: -5px 0;
			}
			.装备槽:hover {
			background: rgba(255, 255, 255, 0.2);
			}
			/* --- Staircase (楼梯) --- */
			.楼梯 {
			background-color: #4a4a4a;
			font-size: 1.5em;
			text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
			}
			/* --- Tooltip (浮动提示框) --- */
			#浮动提示框 {
			/* Tooltip */
			position: absolute;
			background: rgba(0, 0, 0, 0.9);
			color: white;
			padding: 10px;
			border-radius: 6px;
			font-family: Arial;
			font-size: 12px;
			max-width: 200px;
			pointer-events: none;
			z-index: 1002;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
			display: none;
			line-height: 1.4;
			}
			#浮动提示框 br {
			margin: 4px 0;
			content: "";
			display: block;
			}
			/* --- Level Transition (楼层过渡遮罩) --- */
			.楼层过渡遮罩 {
			/* Level Transition Overlay */
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: black;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.5s ease;
			z-index: 10001;
			display: flex;
			align-items: center;
			justify-content: center;
			}
			.层数标题 {
			/* Level Number Title */
			color: #ffffff;
			font-size: 4em;
			text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
			opacity: 0;
			transform: scale(3);
			transition: all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55);
			font-family: "Arial Black", sans-serif;
			letter-spacing: 4px;
			}
			/* --- Notifications (通知) --- */
			.通知容器 {
			/* Notification Container */
			position: fixed;
			top: 20px;
			left: 50%;
			transform: translateX(-50%);
			z-index: 9999999;
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 10px;
			font-family: Arial, "微软雅黑";
			}
			.通知条目 {
			/* Notification Item */
			background: rgba(40, 40, 40, 0.95);
			color: #e0e0e0;
			padding: 12px 24px;
			border-radius: 6px;
			min-width: 280px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
			border-left: 4px solid;
			opacity: 0;
			transform: translateY(-30px);
			animation: 通知入场 0.3s ease-out forwards;
			transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
			opacity 0.2s linear;
			display: flex;
			align-items: center;
			gap: 12px;
			backdrop-filter: blur(5px);
			}
			.通知条目.离场 {
			/* Leaving Notification */
			animation: 通知离场 0.3s ease-in forwards;
			transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
			opacity 0.2s linear;
			}
			@keyframes 通知入场 {
			to {
			opacity: 1;
			transform: translateY(0);
			}
			}
			@keyframes 通知离场 {
			to {
			opacity: 0;
			transform: translateY(-20px) scale(0.95);
			}
			}
			.通知条目.成功 {
			border-color: #4caf50;
			}
			.通知条目.警告 {
			border-color: #ff9800;
			}
			.通知条目.错误 {
			border-color: #f44336;
			}
			.通知条目.信息 {
			border-color: #2196f3;
			}
			.通知图标 {
			font-family: "color-emoji";
			width: 24px;
			height: 24px;
			flex-shrink: 0;
			}
			.关闭按钮 {
			font-family: "color-emoji";
			background: none;
			border: none;
			color: #888;
			cursor: pointer;
			margin-left: auto;
			padding-left: 20px;
			transition: color 0.2s;
			}
			.关闭按钮:hover {
			color: #fff;
			}
			/* --- Responsive Design --- */
			#小地图容器 {
			position: fixed;
			bottom: 160px;
			right: 20px;
			mix-blend-mode: lighten;
			transition: opacity 0.3s ease;
			}
			#小地图容器:hover {
			mix-blend-mode: normal;
			}
			#跳过教程按钮 {
			font-size: 0.8em;
			display: block;
			position: fixed;
			top: 185px;
			right: 22px;
			height: 5vmin;
			width: 20vmin;
			}
.control-pad-actions {
    position: fixed;
    pointer-events: none;
    left: 9vw;
    bottom: 100px;
    display: flex;
    flex-direction: column;
}
.settings-container {
    position: fixed;
    right: 23px;
    bottom: 80px;
    display: flex;
}
@media (min-width: 769px) {
    .control-pad {
        
        bottom: 40px;
        }
    .control-pad-actions {
        right: 2vw;
        left: auto;
        top: 42%;
        bottom: auto;
        transform: translateY(-50%);
    }
    .settings-container {
        right: 2vw;
        left: auto;
        
        bottom: 5px;
    }
    body:not(.手机模式启用) .control-pad,
    body:not(.手机模式启用) .control-pad-actions,
    body:not(.手机模式启用) .settings-container {
        display: none;
    }
    #小地图容器 {
        position: fixed;
        bottom: 13vmin;
        right: 20px;
        transform: none;
    }
    #跳过教程按钮 { top: 75px; }
    #回放教程按钮 { top: 15px; }
}
@media (max-width: 768px) {
    #跳过教程按钮 {
    top: 40px;
    }
    #回放教程按钮 {
    top: 10px;
    }
}


body.手机模式启用 .control-pad,
body.手机模式启用 .control-pad-actions,
body.手机模式启用 .settings-container {
    display: flex;
}
body.方向键隐藏 .control-pad {
    display: none !important;
}
			canvas {
			mix-blend-mode: lighten;
			}
			/* 烟花动画 */
			@keyframes 烟花炸裂 {
			0% {
			transform: translate(0, 0) scale(1);
			opacity: 1;
			}
			100% {
			transform: translate(calc(var(--tx) * 100px),
			calc(var(--ty) * 100px)) scale(0);
			opacity: 0;
			}
			}
			.烟花粒子 {
			font-family: "color-emoji";
			position: fixed;
			z-index: 99999;
			font-size: 1.2em;
			animation: 烟花炸裂 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
			pointer-events: none;
			}
			@keyframes 收集脉冲 {
			0% {
			transform: scale(0);
			opacity: 0;
			}
			50% {
			transform: scale(1.2);
			opacity: 1;
			text-shadow: 0 0 30px var(--辉光颜色),
			0 0 40px var(--辉光颜色);
			}
			100% {
			transform: scale(1);
			opacity: 0;
			text-shadow: 0 0 10px var(--辉光颜色),
			0 0 20px var(--辉光颜色);
			}
			}
			.收集特效 {
			font-family: "color-emoji";
			position: fixed;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			font-size: 3em;
			z-index: 99998;
			animation: 收集脉冲 1.1s ease-out forwards;
			text-shadow: 0 0 10px var(--辉光颜色);
			}
			/*卷轴类待点击动画*/
			.卷轴闪烁 {
			animation: 卷轴脉冲 0.8s ease-in-out infinite;
			position: relative;
			}
			@keyframes 卷轴脉冲 {
			0% {
			box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
			background: rgba(255, 215, 0, 0.1);
			}
			50% {
			box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
			background: rgba(255, 215, 0, 0.3);
			}
			100% {
			box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
			background: rgba(255, 215, 0, 0.1);
			}
			}
			.卷轴闪烁::after {
			content: "";
			position: absolute;
			top: -5px;
			left: -5px;
			right: -5px;
			bottom: -5px;
			border-radius: 8px;
			background: linear-gradient(45deg,
			rgba(255, 215, 0, 0.3) 0%,
			rgba(255, 215, 0, 0.1) 50%,
			rgba(255, 215, 0, 0.3) 100%);
			z-index: -1;
			animation: 光晕扩散 1.2s infinite;
			}
			@keyframes 光晕扩散 {
			0% {
			opacity: 0.8;
			}
			100% {
			opacity: 0;
			}
			}
			/* 日志容器 */
			.日志面板 {
			position: fixed;
			right: 20px;
			bottom: -600px;
			width: 250px;
			height: 200px;
			background: rgba(0, 0, 0, 0.9);
			border-radius: 8px;
			padding: 12px;
			transition: bottom 0.3s ease;
			color: #c0c0c0;
			display: flex;
			flex-direction: column;
			}
			.日志内容 {
			flex: 1;
			overflow-y: auto;
			font-size: 0.9em;
			line-height: 1.4;
			scrollbar-width: thin;
			scrollbar-color: #4caf50 #2a2a2a;
			}
			.日志面板.可见 {
			bottom: 135px;
			}
			.日志内容 .成功 {
			color: green;
			}
			.日志内容 .错误 {
			color: red;
			}
			.日志内容 .警告 {
			color: yellow;
			}
			/* 滚动条样式 */
			.日志内容::-webkit-scrollbar {
			width: 6px;
			}
			.日志内容::-webkit-scrollbar-track {
			background: #2a2a2a;
			}
			.日志内容::-webkit-scrollbar-thumb {
			background: #4caf50;
			border-radius: 3px;
			}
			@keyframes 爆炸闪烁 {
			0% {
			transform: scale(0);
			opacity: 1;
			}
			50% {
			transform: scale(1.2);
			opacity: 0.8;
			}
			100% {
			transform: scale(1);
			opacity: 0;
			}
			}
			/* --- NPC-------流浪奸商 --- */
			#交易窗口 {
			position: fixed;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			width: 85%;
			max-width: 500px;
			background: linear-gradient(145deg,
			rgba(20, 20, 20, 0.95),
			rgba(40, 40, 40, 0.98));
			border: 2px solid #4caf50;
			border-radius: 12px;
			box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
			color: #e0e0e0;
			z-index: 1001;
			backdrop-filter: blur(5px);
			animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			display: none;
			flex-direction: column;
			transition: all 0.7s cubic-bezier(0.4, 0, 0.2, 1);
			max-height: 80vh;
			}
			.重铸弹窗.关闭中 {
			opacity: 0;
			transform: translate(-50%, -50%) scale(0.9);
			pointer-events: none;
			}
			#交易窗口.关闭中 {
			opacity: 0;
			transform: translate(-50%, -50%) scale(0.9);
			pointer-events: none;
			}
			.窗口标题 {
			padding: 15px 20px;
			font-size: 1.3em;
			color: #4caf50;
			border-bottom: 1px solid rgba(76, 175, 80, 0.3);
			text-shadow: 0 0 5px rgba(76, 175, 80, 0.4);
			text-align: center;
			font-weight: bold;
			flex-shrink: 0;
			}
			.库存列表 {
			display: grid;
			gap: 12px;
			padding: 20px;
			overflow-y: auto;
			flex-grow: 1;
			}
			.交易物品条目 {
			background: rgba(255, 255, 255, 0.05);
			padding: 15px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			flex-direction: column;
			gap: 8px;
			}
			.交易物品条目 .物品头 {
			display: flex;
			justify-content: flex-start;
			align-items: center;
			font-weight: bold;
			}
			.交易物品条目 .物品描述 {
			font-size: 0.85em;
			color: #aaa;
			line-height: 1.4;
			}
			.交易物品条目:hover {
			border-color: #4caf50;
			background: rgba(76, 175, 80, 0.15);
			transform: translateY(-2px);
			box-shadow: 0 3px 10px rgba(76, 175, 80, 0.2);
			}
			.物品价格 {
			color: #ffd700;
			font-size: 0.9em;
			font-weight: bold;
			white-space: nowrap;
			margin-left: 10px;
			}
			.交易底部 {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 15px 20px;
			border-top: 1px solid rgba(76, 175, 80, 0.3);
			background: rgba(0, 0, 0, 0.2);
			flex-shrink: 0;
			}
			.玩家金币 {
			color: #ffd700;
			font-weight: bold;
			}
			#交易窗口 .按钮 {
			padding: 8px 20px;
			font-size: 1em;
			border: 2px solid #4caf50;
			border-radius: 6px;
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.4),
			rgba(67, 160, 71, 0.3));
			color: #e0e0e0;
			cursor: pointer;
			transition: all 0.3s ease;
			font-family: inherit;
			}
			#交易窗口 .按钮:hover {
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.6),
			rgba(67, 160, 71, 0.5));
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
			border-color: #66bb6a;
			}
			#交易窗口 .按钮:active {
			transform: translateY(0px);
			box-shadow: 0 2px 5px rgba(76, 175, 80, 0.2);
			}
			/* --- NPC-------探险家收购 --- */
			#收购窗口 {
			display: none;
			position: fixed;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			width: 90%;
			max-width: 700px;
			background: linear-gradient(145deg,
			rgba(20, 20, 20, 0.95),
			rgba(40, 40, 40, 0.98));
			border: 2px solid #ff9800;
			border-radius: 12px;
			box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
			color: #e0e0e0;
			z-index: 1001;
			backdrop-filter: blur(5px);
			animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			flex-direction: column;
			max-height: 85vh;
			}
			#收购窗口.关闭中 {
			opacity: 0;
			transform: translate(-50%, -50%) scale(0.9);
			pointer-events: none;
			}
			#收购窗口 .窗口标题 {
			color: #ff9800;
			border-bottom: 1px solid rgba(255, 152, 0, 0.3);
			text-shadow: 0 0 5px rgba(255, 152, 0, 0.4);
			padding: 15px 20px;
			font-size: 1.3em;
			text-align: center;
			font-weight: bold;
			flex-shrink: 0;
			}
			.收购内容 {
			display: flex;
			flex-grow: 1;
			overflow: hidden;
			padding: 15px;
			gap: 15px;
			}
			.收购物品列表,
			.玩家背包预览 {
			flex: 1;
			display: flex;
			flex-direction: column;
			background: rgba(255, 255, 255, 0.03);
			border-radius: 8px;
			padding: 10px;
			overflow: hidden;
			}
			.收购物品列表 h4,
			.玩家背包预览 h4 {
			margin-bottom: 10px;
			text-align: center;
			color: #ffcc80;
			flex-shrink: 0;
			padding-bottom: 5px;
			border-bottom: 1px dashed rgba(255, 152, 0, 0.2);
			}
			#收购需求列表,
			#玩家可售列表 {
			align-content: start;
			padding: 10px 5px;
			overflow-y: auto;
			flex-grow: 1;
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
			gap: 8px;
			}
			.收购需求条目,
			.玩家可售条目 {
			background: rgba(255, 255, 255, 0.05);
			padding: 10px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 6px;
			transition: all 0.2s ease;
			text-align: center;
			}
			.玩家可售条目 {
			cursor: pointer;
			}
			.收购需求条目 .需求图标,
			.玩家可售条目 .物品图标 {
			font-size: 1.8em;
			display: block;
			margin-bottom: 5px;
			font-family: "color-emoji";
			}
			.玩家可售条目 .物品图标 {
			text-shadow: 0 0 5px currentColor;
			}
			.收购需求条目 .需求名称,
			.玩家可售条目 .物品名称 {
			font-size: 0.85em;
			display: block;
			margin-bottom: 5px;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			}
			.收购需求条目 .需求价格,
			.玩家可售条目 .出售价格 {
			font-size: 0.9em;
			color: #ffd700;
			font-weight: bold;
			display: block;
			}
			.玩家可售条目:hover {
			border-color: #ff9800;
			background: rgba(255, 152, 0, 0.15);
			transform: translateY(-2px);
			box-shadow: 0 3px 10px rgba(255, 152, 0, 0.2);
			}
			#收购窗口 .交易底部 {
			border-top: 1px solid rgba(255, 152, 0, 0.3);
			}
			#收购窗口 .玩家金币 {
			color: #ffd700;
			font-weight: bold;
			}
			#收购窗口 .按钮 {
			padding: 8px 20px;
			font-size: 1em;
			border: 2px solid #ff9800;
			border-radius: 6px;
			background: linear-gradient(145deg,
			rgba(255, 152, 0, 0.4),
			rgba(245, 124, 0, 0.3));
			color: #e0e0e0;
			cursor: pointer;
			transition: all 0.3s ease;
			font-family: inherit;
			}
			#收购窗口 .按钮:hover {
			background: linear-gradient(145deg,
			rgba(255, 152, 0, 0.6),
			rgba(245, 124, 0, 0.5));
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
			border-color: #ffb74d;
			}
			#收购窗口 .按钮:active {
			transform: translateY(0px);
			box-shadow: 0 2px 5px rgba(255, 152, 0, 0.2);
			}
			/* 附魔系统 */
			.附魔弹窗 {
			font-family: "color-emoji";
			position: fixed;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			background: linear-gradient(45deg, #2a0a3a 0%, #1a1a2f 100%);
			border: 2px solid #634b7d;
			border-radius: 12px;
			padding: 20px;
			box-shadow: 0 0 40px #6b2fa070;
			z-index: 10000;
			min-width: 400px;
			max-width: 90vw;
			backdrop-filter: blur(5px);
			animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
			}
			.附魔弹窗.关闭中 {
			opacity: 0;
			transform: translate(-50%, -50%) scale(0.9);
			pointer-events: none;
			}
			@keyframes 弹窗浮现 {
			from {
			opacity: 0;
			transform: translate(-50%, -45%) scale(0.9);
			/* 初始缩小并偏移 */
			}
			to {
			opacity: 1;
			transform: translate(-50%, -50%) scale(1);
			/* 恢复原大小和位置 */
			}
			}
			.附魔头 {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 20px;
			padding-bottom: 15px;
			border-bottom: 1px solid #4a3560;
			}
			.附魔标题 {
			color: #c792ea;
			font-size: 1.4em;
			text-shadow: 0 0 10px #c792ea80;
			font-family: "微软雅黑", sans-serif;
			}
			.附魔装备容器 {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
			gap: 15px;
			max-height: 60vh;
			overflow-y: auto;
			padding: 10px;
			margin-bottom: 20px;
			}
			.可附魔 {
			cursor: pointer;
			transition: all 0.3s;
			position: relative;
			overflow: hidden;
			background: #2d1b3c;
			border-radius: 8px;
			padding: 15px;
			border: 1px solid #4a3560;
			}
			.可附魔:hover {
			transform: translateY(-3px);
			box-shadow: 0 0 25px #c792ea80;
			background: #3a254d;
			}
			.可附魔:hover .物品图标 {
			animation: 装备浮动 1.5s ease-in-out infinite;
			}
			@keyframes 装备浮动 {
			0% {
			transform: translateY(0);
			}
			50% {
			transform: translateY(-5px);
			}
			100% {
			transform: translateY(0);
			}
			}
			.附魔特效 {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			}
			.魔幻粒子 {
			will-change: transform, opacity;
			filter: blur(2px);
			mix-blend-mode: screen;
			position: absolute;
			width: var(--size);
			height: var(--size);
			border-radius: 50%;
			background: hsla(var(--hue), 80%, var(--lightness), 0.8);
			transition: all 0.3s;
			animation: 粒子脉动 1.2s var(--delay) both,
			光晕闪烁 1.4s var(--delay) linear infinite;
			}
			@keyframes 粒子脉动 {
			0% {
			opacity: 1;
			transform: translate(0, 0) scale(0.3);
			}
			100% {
			opacity: 0;
			transform: translate(var(--target-x), var(--target-y)) scale(0.2);
			}
			}
			@keyframes 光晕闪烁 {
			0%,
			100% {
			box-shadow: 0 0 15px 3px hsl(var(--hue), 100%, 60%);
			}
			50% {
			box-shadow: 0 0 25px 6px hsl(var(--hue), 100%, 70%);
			}
			}
			.附魔确认按钮 {
			background: linear-gradient(145deg, #c792ea, #9c27b0);
			color: white;
			border: none;
			padding: 12px 24px;
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.3s;
			font-size: 1.1em;
			margin-top: 20px;
			display: block;
			width: 100%;
			}
			.附魔确认按钮:hover {
			transform: scale(1.05);
			box-shadow: 0 0 20px #c792ea80;
			}
			/* 关闭按钮优化 */
			.附魔弹窗 .关闭按钮 {
			background: none;
			border: none;
			color: #c792ea;
			font-size: 1.8em;
			cursor: pointer;
			transition: all 0.3s;
			padding: 5px;
			line-height: 1;
			}
			.附魔弹窗 .关闭按钮:hover {
			color: #ff4081;
			transform: rotate(90deg);
			}
			/* 移动端适配 */
			@media (max-width: 768px) {
			.附魔弹窗 {
			min-width: 300px;
			padding: 15px;
			}
			.附魔标题 {
			font-size: 1.2em;
			}
			.附魔装备容器 {
			grid-template-columns: repeat(2, 1fr);
			}
			}
			/* 状态提示动画 */
			@keyframes 成功闪光 {
			0% {
			background-color: #4caf5050;
			}
			50% {
			background-color: #4caf5020;
			}
			100% {
			background-color: transparent;
			}
			}
			.附魔成功 {
			animation: 成功闪光 1.5s ease-out;
			}
			.重铸弹窗 {
			position: fixed;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			background: #1a1a1ae6;
			border: 2px solid #4a4a4a;
			border-radius: 12px;
			padding: 20px;
			width: 80vmin;
			max-width: 600px;
			color: #e0e0e0;
			z-index: 10000;
			box-shadow: 0 0 30px #00000080;
			animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			transition: opacity 0.3s ease,
			transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
			}
			.重铸弹窗-header {
			display: flex;
			justify-content: space-between;
			margin-bottom: 15px;
			border-bottom: 1px solid #444;
			padding-bottom: 10px;
			}
			.重铸弹窗-column {
			flex: 1;
			padding: 10px;
			}
			.重铸弹窗-items {
			display: grid;
			grid-template-rows: repeat(auto-fill, minmax(100px, 1fr));
			max-height: 50vh;
			overflow-y: scroll;
			gap: 10px;
			}
			#传送点列表容器 {
			grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
			}
			.重铸物品 {
			border: 1px solid #444;
			padding: 10px;
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
			transform-origin: center;
			position: relative;
			}
			.重铸物品.selected {
			border-color: #4caf50;
			background: #2b2b2b;
			transform: scale(1.1);
			z-index: 1;
			}
			.重铸台耐久标签 {
			font-size: 0.8em;
			color: #888;
			}
			.重铸物品:hover {
			transform: translateY(-3px) scale(1.05);
			box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
			}
			.重铸遮罩 {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.5);
			backdrop-filter: blur(3px);
			z-index: 9999;
			}
			#repairCost {
			font-family: "Arial Black";
			text-shadow: 0 0 5px currentColor;
			transition: color 0.3s ease;
			}
			/* 强化标识 */
			.重铸台强化标识 {
			position: absolute;
			top: 2px;
			right: 2px;
			color: #ffd700;
			font-size: 0.8em;
			text-shadow: 0 0 3px #ffd700;
			}
			/*------小地图-------*/
			#小地图 {
			position: relative;
			right: 10px;
			border: 2px solid #4caf50;
			border-radius: 8px;
			box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
			background: rgba(0, 0, 0, 0.9);
			z-index: 999;
			image-rendering: pixelated;
			}
			#小地图:hover {
			mix-blend-mode: normal;
			}
			.宠物管理窗口 {
			position: fixed;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			background: #1a1a1ae6;
			border: 2px solid #4a4a4a;
			border-radius: 12px;
			padding: 20px;
			width: 90%;
			max-width: 500px;
			color: #e0e0e0;
			z-index: 10000;
			box-shadow: 0 0 30px #00000080;
			transition: opacity 0.3s ease,
			transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
			max-height: 80vh;
			overflow-y: auto;
			}
			.宠物遮罩 {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.75);
			z-index: 9999;
			}
			.宠物状态栏 {
			margin: 15px 0;
			}
			.条容器,
			.宠物经验条容器 {
			height: 20px;
			background: #333;
			border-radius: 10px;
			margin: 10px 0;
			position: relative;
			}
			.宠物血量条 {
			height: 100%;
			background: linear-gradient(90deg, #f44336, #ff7043);
			border-radius: 10px;
			transition: width 0.3s;
			}
			.宠物经验条 {
			height: 100%;
			background: linear-gradient(90deg, #2196f3, #4dabf5);
			border-radius: 10px;
			transition: width 0.3s;
			}
			.宠物血量文本,
			.宠物经验文本 {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: white;
			font-size: 0.9em;
			}
			.宠物属性 {
			display: flex;
			justify-content: space-between;
			margin-top: 10px;
			color: #ddd;
			font-size: 0.9em;
			}
			.宠物装备格子容器 {
			display: grid;
			grid-template-columns: repeat(2, 1fr);
			gap: 15px;
			margin-top: 15px;
			}
			.宠物装备格子 {
			border: 1px solid #555;
			padding: 10px;
			border-radius: 5px;
			position: relative;
			min-height: 80px;
			background: #2b2b2b;
			}
			.宠物装备槽位名 {
			position: relative;
			top: 4px;
			left: 10px;
			padding: 0 5px;
			font-size: 0.8em;
			color: #aaa;
			}
			.宠物装备选择按钮,
			.宠物装备卸下按钮 {
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.9) 30%,
			rgba(67, 160, 71, 0.9) 100%);
			box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
			color: #fff;
			border: 2px solid #fff;
			opacity: 0.95;
			border: none;
			border-radius: 5px;
			padding: 5px 10px;
			color: white;
			cursor: pointer;
			transition: background 0.2s;
			font-family: inherit;
			}
			.宠物装备卸下按钮 {
			background: linear-gradient(145deg,
			rgba(244, 67, 54, 0.9) 30%,
			rgba(206, 61, 49, 0.9) 100%);
			box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
			position: absolute;
			bottom: 5px;
			right: 5px;
			}
			.宠物技能容器 {
			display: grid;
			grid-template-columns: repeat(2, 1fr);
			gap: 10px;
			margin-top: 15px;
			}
			.宠物技能 {
			border: 1px solid #555;
			padding: 10px;
			border-radius: 5px;
			background-color: #333;
			}
			.宠物装备选择弹窗 {
			position: fixed;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			background: #1a1a1ae6;
			border: 2px solid #4a4a4a;
			border-radius: 12px;
			padding: 20px;
			width: 80%;
			max-width: 400px;
			color: #e0e0e0;
			z-index: 10001;
			box-shadow: 0 0 30px #00000080;
			transition: opacity 0.3s ease,
			transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
			max-height: 75vh;
			overflow: scroll;
			}
			.可装备物品容器 {
			max-height: 60vh;
			overflow-y: auto;
			/* 滚动 */
			padding: 10px;
			}
			/* 可选装备样式 */
			.宠物可选装备 {
			display: flex;
			align-items: center;
			padding: 8px;
			border: 1px solid #2c3e50;
			border-radius: 6px;
			margin-bottom: 5px;
			background-color: #41586b;
			transition: background-color 0.2s;
			}
			.宠物可选装备:hover {
			background-color: #546e7a;
			}
			.宠物装备名称 {
			position: relative;
			top: 4px;
			left: 2px;
			padding: 0 5px;
			font-size: 0.8em;
			color: #aaa;
			}
			.宠物可选装备图标 {
			font-family: "color-emoji";
			margin-right: 10px;
			font-size: 1.2em;
			}
			.宠物装备图标 {
			font-family: "color-emoji";
			}
			.宠物装备选择弹窗 .关闭按钮 {
			position: absolute;
			top: 10px;
			right: 10px;
			background: none;
			border: none;
			font-size: 1.5em;
			color: #e74c3c;
			cursor: pointer;
			padding: 5px;
			z-index: 1;
			}
			.宠物装备选择确认按钮 {
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.9) 30%,
			rgba(67, 160, 71, 0.9) 100%);
			box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
			color: #fff;
			border: none;
			border-radius: 5px;
			padding: 6px 12px;
			font-size: 0.9em;
			cursor: pointer;
			transition: background-color 0.2s, transform 0.2s;
			font-family: inherit;
			margin-left: auto;
			}
			.宠物装备选择确认按钮:hover {
			background: linear-gradient(145deg,
			rgba(67, 160, 71, 0.9) 30%,
			rgba(58, 140, 62, 0.9) 100%);
			transform: translateY(-2px);
			/* 上浮效果 */
			box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
			}
			.通用按钮:hover {
			background: linear-gradient(145deg,
			rgba(67, 160, 71, 0.9) 30%,
			rgba(58, 140, 62, 0.9) 100%);
			transform: translateY(-2px);
			/* 上浮效果 */
			box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
			}
			.宠物装备选择确认按钮:active {
			transform: scale(0.95);
			}
			.宠物可选装备 {
			padding: 10px;
			}
			.可装备物品容器 {
			max-height: 65vh;
			overflow-y: auto;
			padding: 10px;
			margin-bottom: 10px;
			}
			.宠物管理窗口,
			.宠物装备选择弹窗 {
			animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			}
			.宠物可选装备 {
			justify-content: space-between;
			}
			.宠物基本信息面板 p,
			.宠物技能面板 p {
			line-height: 1.6;
			}
			.宠物已装备物品 {
			display: flex;
			align-items: center;
			justify-content: space-between;
			width: 100%;
			}
			/* 无装备提示 */
			.无装备提示,
			.无技能提示 {
			color: #aaa;
			text-align: center;
			padding: 20px;
			}
			.宠物管理窗口 .关闭按钮 {
			position: absolute;
			top: 10px;
			right: 10px;
			background: none;
			border: none;
			font-size: 1.5em;
			color: #e74c3c;
			cursor: pointer;
			transition: transform 0.3s;
			padding: 5px;
			}
			.宠物管理窗口 .关闭按钮:hover {
			color: #ff4081;
			transform: rotate(90deg);
			/* 旋转动画 */
			}
			.宠物管理窗口 .通用按钮 {
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.9) 30%,
			rgba(67, 160, 71, 0.9) 100%);
			box-shadow: 0 4px 20px #4caf504d;
			color: #fff;
			border: 2px solid #fff;
			opacity: 0.95;
			border: none;
			border-radius: 5px;
			padding: 5px 10px;
			color: white;
			cursor: pointer;
			transition: background-color 0.2s, transform 0.2s;
			font-family: inherit;
			margin-top: 10px;
			width: 100%;
			}
			.宠物血量标签 {
			position: absolute;
			bottom: 5px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.7);
			color: #fff;
			padding: 2px 8px;
			border-radius: 4px;
			font-size: 0.75em;
			white-space: nowrap;
			z-index: 1;
			}
			/* --- 自定义确认对话框 --- */
			.确认对话框遮罩 {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.6);
			backdrop-filter: blur(8px);
			z-index: 10008;
			/* 比死亡遮罩高一级 */
			display: flex;
			justify-content: center;
			align-items: center;
			animation: 界面浮现 0.3s ease;
			}
			.确认对话框 {
			background: linear-gradient(145deg, #1e0000, #3c0000);
			border: 2px solid #ff4444;
			border-radius: 12px;
			padding: 30px 40px;
			box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
			text-align: center;
			color: #e0e0e0;
			font-family: inherit;
			max-width: 80%;
			animation: 界面浮现 0.4s cubic-bezier(0.4, 0, 0.2, 1);
			}
			.确认对话框 h3 {
			margin-top: 0;
			font-size: 1.4em;
			color: #ff8a80;
			text-shadow: 0 0 8px #ff0000;
			}
			.确认对话框 p {
			margin: 15px 0 25px 0;
			font-size: 1em;
			line-height: 1.6;
			color: #ccc;
			}
			.确认按钮容器 {
			display: flex;
			justify-content: center;
			gap: 20px;
			}
			.确认按钮 {
			padding: 12px 28px;
			font-size: 1.1em;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.3s ease;
			font-family: inherit;
			min-width: 120px;
			}
			.确认按钮-确认 {
			background: linear-gradient(145deg, #c62828, #e53935);
			color: white;
			}
			.确认按钮-确认:hover {
			background: linear-gradient(145deg, #d32f2f, #f44336);
			transform: translateY(-2px);
			box-shadow: 0 4px 15px rgba(255, 82, 82, 0.4);
			}
			.确认按钮-取消 {
			background: linear-gradient(145deg, #424242, #616161);
			color: #e0e0e0;
			}
			.确认按钮-取消:hover {
			background: linear-gradient(145deg, #616161, #757575);
			transform: translateY(-2px);
			box-shadow: 0 4px 15px rgba(100, 100, 100, 0.3);
			}
			/* --------------教程---------------*/
			.教程提示窗口 {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: linear-gradient(135deg, #282828f2, #3a3a3af2);
			color: #e0e0e0;
			padding: 20px 30px;
			border-radius: 12px;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
			z-index: 10002;
			width: 85%;
			text-align: center;
			border: 2px solid #4caf50;
			animation: 弹窗浮现 0.4s cubic-bezier(0.4, 0, 0.2, 1);
			display: none;
			font-family: "HarmonyOS Sans SC", "MiSans", system-ui,
			"color-emoji";
			}
			.教程提示窗口 p {
			font-size: 1.1em;
			line-height: 1.5;
			margin-bottom: 15px;
			}
			.教程提示窗口 .关闭按钮 {
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.9) 30%,
			rgba(67, 160, 71, 0.9) 100%);
			box-shadow: 0 2px 8px #4caf5066;
			color: #fff;
			padding: 8px 16px;
			border: none;
			border-radius: 6px;
			cursor: pointer;
			transition: all 0.3s ease;
			font-size: 1em;
			font-family: inherit;
			}
			.教程提示窗口 .关闭按钮:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 12px #4caf5080;
			background: linear-gradient(145deg,
			rgba(67, 160, 71, 0.9) 30%,
			rgba(58, 140, 62, 0.9) 100%);
			}
			.教程提示窗口.关闭中 {
			animation: 弹窗消失 0.3s ease-out forwards;
			}
			@keyframes 弹窗消失 {
			to {
			opacity: 0;
			transform: translate(-50%, -50%) scale(0.9);
			}
			}
			#回放教程按钮 {
			position: fixed;
			right: 22px;
			width: 20vmin;
			}
			#教程回放窗口 {
			display: none;
			max-width: 90%;
			}
			.教程导航 {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin: 15px 0;
			color: #aaa;
			}
			.教程导航 button {
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.7) 30%,
			rgba(67, 160, 71, 0.7) 100%) !important;
			box-shadow: 0 2px 6px #4caf504d !important;
			padding: 6px 12px !important;
			font-size: 0.9em !important;
			}
			.教程导航 button:disabled {
			background: #555 !important;
			cursor: not-allowed;
			opacity: 0.6;
			box-shadow: none !important;
			}
			/* -----------设置----------*/
			.设置菜单 {
			position: fixed;
			bottom: -500px;
			right: 20px;
			background: #000000e5;
			border-radius: 12px;
			padding: 15px;
			transition: bottom 0.3s ease;
			z-index: 1003;
			text-align: center;
			}
			.设置菜单 button {
			display: block;
			width: 100%;
			margin: 10px 0;
			padding: 10px;
			background: linear-gradient(145deg,
			rgba(76, 175, 80, 0.9) 30%,
			rgba(67, 160, 71, 0.9) 100%);
			box-shadow: 0 4px 20px #4caf504d;
			color: #fff;
			border: 2px solid #fff;
			opacity: 0.95;
			border-radius: 8px;
			cursor: pointer;
			font-family: inherit;
			font-size: 1em;
			}
			.设置菜单 button:active {
			background: #45a049;
			transform: scale(0.9);
			box-shadow: 0 0 5px #4caf50cc;
			}
			.设置菜单.显示 {
			bottom: 160px;
			}
			.设置菜单.隐藏 {
			animation: 弹窗消失 0.3s ease-out forwards;
			}
			@keyframes 扭曲 {
			0% {
			transform: scale(1) skew(0deg);
			}
			25% {
			transform: scale(1.1) skew(5deg);
			}
			50% {
			transform: scale(0.9) skew(-5deg);
			}
			75% {
			transform: scale(1.05) skew(2deg);
			}
			100% {
			transform: scale(1) skew(0deg);
			opacity: 0;
			}
			}
			/* --- 传送菜单按钮 --- */
			#传送点菜单 {
			position: fixed;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			background: #1a1a1ae6;
			border: 2px solid #4a4a4a;
			border-radius: 12px;
			padding: 20px;
			width: 80vmin;
			max-width: 600px;
			color: #e0e0e0;
			z-index: 10000;
			box-shadow: 0 0 30px #00000080;
			animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			transition: opacity 0.3s ease,
			transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
			}
			#传送点菜单 .菜单操作按钮 {
			padding: 5px 10px;
			/* 统一基础内边距 */
			font-size: 0.9em;
			/* 统一基础字号 */
			border: 1px solid transparent;
			/* 初始透明边框 */
			border-radius: 5px;
			color: #e0e0e0;
			cursor: pointer;
			transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
			/* 平滑过渡 */
			font-family: inherit;
			box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
			/* 基础阴影 */
			text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
			display: inline-flex;
			/* 保证图标和文字对齐 */
			align-items: center;
			gap: 4px;
			/* 图标和文字间距 */
			}
			#传送点菜单 .菜单操作按钮:hover {
			transform: translateY(-2px);
			/* 悬浮上移 */
			box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
			/* 更深的阴影 */
			}
			#传送点菜单 .菜单操作按钮:active {
			transform: translateY(0px) scale(0.95);
			/* 按下效果 */
			box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
			/* 内阴影 */
			}
			/* 传送按钮 (绿色系) */
			#传送点菜单 .传送菜单按钮-传送 {
			background: linear-gradient(145deg, #4caf50, #388e3c);
			border-color: #66bb6a;
			box-shadow: 0 2px 5px rgba(76, 175, 80, 0.3);
			}
			#传送点菜单 .传送菜单按钮-传送:hover {
			background: linear-gradient(145deg, #66bb6a, #4caf50);
			border-color: #81c784;
			box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
			}
			/* 删除按钮 (深红/灰红系) */
			#传送点菜单 .传送菜单按钮-删除 {
			background: linear-gradient(145deg, #7f0000, #9e2b25);
			/* 更深的红色 */
			border-color: #b71c1c;
			box-shadow: 0 2px 5px rgba(127, 0, 0, 0.3);
			}
			#传送点菜单 .传送菜单按钮-删除:hover {
			background: linear-gradient(145deg, #9e2b25, #b71c1c);
			border-color: #d32f2f;
			box-shadow: 0 4px 12px rgba(127, 0, 0, 0.4);
			}
			#传送点菜单 .传送菜单按钮-保存 {
			background: linear-gradient(145deg, #4caf50, #388e3c);
			/* 青色系 */
			border-color: #009688;
			box-shadow: 0 2px 5px rgba(0, 121, 107, 0.3);
			/* 微调标题栏内按钮的样式 */
			font-size: 0.9em;
			margin-left: 10px;
			}
			#传送点菜单 .传送菜单按钮-保存:hover {
			background: linear-gradient(145deg, #66bb6a, #4caf50);
			border-color: #81c784;
			box-shadow: 0 4px 12px rgba(0, 121, 107, 0.4);
			}
			#图鉴分区选择窗口 {
			position: fixed;
			left: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			background: #1a1a1ae6;
			border: 2px solid #4a4a4a;
			border-radius: 12px;
			padding: 20px;
			width: 80vmin;
			max-width: 600px;
			color: #e0e0e0;
			z-index: 10000;
			box-shadow: 0 0 30px #00000080;
			animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
			transition: opacity 0.3s ease,
			transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
			}
			#融合窗口 {
			position: absolute;
			bottom: 100%;
			/* 调整垂直位置，使其在背包上方或旁边 */
			right: 0%;
			/* 调整水平位置 */
			width: 330px;
			/* 根据需要调整宽度 */
			background: rgba(0, 0, 0, 0.9);
			padding: 15px;
			z-index: 1002;
			/* 比背包高一级 */
			display: flex;
			/* 改为 flex 布局 */
			flex-direction: column;
			/* 垂直排列 */
			align-items: center;
			/* 居中对齐 */
			gap: 10px;
			/* 元素间距 */
			box-shadow: 0 3px 15px rgba(0, 0, 0, 0.5);
			transition: opacity 0.3s ease, transform 0.3s ease;
			/* 添加过渡效果 */
			opacity: 0;
			/* 初始隐藏 */
			transform: translateX(20px);
			/* 初始向右偏移一点，用于动画 */
			pointer-events: none;
			/* 初始不可交互 */
			}
			#融合窗口.显示中 {
			opacity: 1;
			transform: translateX(0);
			pointer-events: auto;
			}
			.融合标题 {
			color: #4caf50;
			font-size: 1.1em;
			margin-bottom: 10px;
			text-align: center;
			width: 100%;
			}
			.融合区域 {
			display: grid;
			grid-template-columns: repeat(2, 60px);
			/* 2x2 网格 */
			grid-template-rows: repeat(2, 60px);
			gap: 8px;
			/* 格子间距 */
			margin-bottom: 10px;
			/* 与箭头间距 */
			justify-content: center;
			top: 5px;
			position: relative;
			}
			.融合区格子,
			.融合输出格子 {
			width: 60px;
			/* 格子大小 */
			height: 60px;
			background: rgba(255, 255, 255, 0.1);
			border: 1px dashed #555;
			/* 虚线边框 */
			border-radius: 6px;
			display: flex;
			align-items: center;
			justify-content: center;
			position: relative;
			/* 用于定位物品 */
			cursor: pointer;
			/* 添加指针手势 */
			}
			.融合区格子:hover,
			.融合输出格子:hover {
			background: rgba(255, 255, 255, 0.15);
			border-color: #888;
			}
			.融合箭头 {
			font-size: 1.8em;
			color: #888;
			margin: 0 10px;
			}
			#融合窗口 .物品条目 {
			transform: scale(0.65);
			/* 缩小物品显示 */
			padding: 0;
			margin: 0;
			border: none;
			/* 移除边框 */
			background: transparent;
			/* 透明背景 */
			box-shadow: none;
			width: 100%;
			height: 100%;
			cursor: pointer;
			/* 明确指针 */
			}
			#融合窗口 .物品条目 .物品图标 {
			font-size: 1.8em;
			/* 调整图标大小 */
			margin-bottom: 2px;
			}
			#融合窗口 .物品条目 .物品名称 {
			font-size: 0.7em;
			/* 调整名称大小 */
			display: none;
			/* 默认隐藏名称，空间太小 */
			}
			#融合窗口 .物品条目 .物品堆叠 {
			font-size: 0.6em;
			/* 调整堆叠数字大小 */
			bottom: 2px;
			right: 2px;
			padding: 1px 4px;
			}
			/* -------------地图编辑器------------ */
			#笔刷工具容器 {
				position: fixed;
				top: 215px;
				right: 5px;
				background: rgba(0,0,0,0.7);
				padding: 10px;
				border-radius: 8px;
				z-index: 999;
				display: none;
				flex-direction: column;
				gap: 10px;
				width: 150px;
				box-sizing: border-box;
			}
			.地图编辑器模式 #hudToggle {
			display: flex !important;
			}
			.地图编辑器模式 #hudToggle {
			pointer-events: auto;
			}
			设置项目 {
			display: flex;
			flex-direction: column;
			gap: 5px;
			}
			.设置项目 label {
			font-size: 0.9em;
			color: #ccc;
			}
			.设置项目 input {
			background: #333;
			border: 1px solid #555;
			color: #fff;
			padding: 8px;
			border-radius: 4px;
			width: 100%;
			box-sizing: border-box;
			}
			.天气选择容器 {
			grid-column: 1 / -1;
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
			gap: 10px;
			margin-top: 5px;
			}
			.天气选项 {
			display: flex;
			align-items: center;
			gap: 5px;
			font-size: 0.9em;
			}
			.天气选项 input {
			width: auto;
			}
			#游戏模式选择菜单 {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%);
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			z-index: 10004;
			opacity: 0;
			transition: opacity 0.5s ease-out;
			color: #e0e0e0;
			font-family: "HarmonyOS Sans SC", "MiSans", system-ui, "color-emoji";
			pointer-events: auto;
			}
			#游戏模式内容 {
			text-align: center;
			}
			#游戏模式标题 {
			font-size: 3.5rem;
			margin-bottom: 3rem;
			color: #e0e0e0;
			text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
			}
			#游戏模式选项 {
			display: flex;
			flex-direction: column;
			gap: 1.5rem;
			}
			#effectsContainer {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			pointer-events: none;
			overflow: hidden;
			z-index: 997;
			}
			/*-------------结局界面-----------*/
			#结算界面遮罩 {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.8);
			backdrop-filter: blur(12px);
			z-index: 10009;
			display: flex;
			justify-content: center;
			align-items: center;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.5s ease;
			overflow: hidden;
			}
			#结算粒子容器 {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			pointer-events: none;
			}
			.结算粒子 {
			position: absolute;
			bottom: -20px;
			width: 2px;
			height: 2px;
			background: rgba(255, 215, 0, 0.6);
			border-radius: 50%;
			animation: 粒子上浮 15s linear infinite;
			box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
			}
			@keyframes 粒子上浮 {
			from {
			transform: translateY(0) scale(1);
			opacity: 0.7;
			}
			to {
			transform: translateY(-105vh) scale(1.5);
			opacity: 0;
			}
			}
			.结算界面 {
			position: relative;
			background: linear-gradient(160deg, rgba(30, 30, 30, 0.95) 0%, rgba(10, 10, 10, 0.95) 100%);
			border: 1px solid rgba(255, 215, 0, 0.3);
			border-radius: 16px;
			padding: 30px 40px;
			box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
			text-align: center;
			color: #e0e0e0;
			font-family: inherit;
			width: 90%;
			max-width: 650px;
			transform: translateY(20px) scale(0.95);
			opacity: 0;
			transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
			}
			#结算界面遮罩.显示 {
			opacity: 1;
			pointer-events: auto;
			}
			#结算界面遮罩.显示 .结算界面 {
			transform: translateY(0) scale(1);
			opacity: 1;
			}
			.结算标题 {
			font-size: 2.2rem;
			color: #E0E0E0;
			text-shadow: none;
			margin-bottom: 20px;
			letter-spacing: 1px;
			font-weight: 300;
			}
			.结局评级 {
			font-family: "Arial Black", Gadget, sans-serif;
			font-size: 5rem;
			font-weight: bold;
			margin-bottom: 0px;
			display: inline-block;
			background: none;
			line-height: 1;
			animation: 评级出现 0.8s 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28) backwards;
			}
			.评级-S-plus {
			color: #ff00ff;
			text-shadow: 0 0 20px #ff00ff, 0 0 10px #ffd700;
			}
			.评级-S {
			color: #ff4500;
			text-shadow: 0 0 15px #ff4500;
			}
			.评级-A {
			color: #4caf50;
			text-shadow: 0 0 15px #4caf50;
			}
			.评级-B {
			color: #2196f3;
			text-shadow: 0 0 15px #2196f3;
			}
			.评级-C {
			color: #9e9e9e;
			text-shadow: 0 0 10px #9e9e9e;
			}
			.评级-D {
			color: #795548;
			text-shadow: 0 0 10px #795548;
			}
			.结束评语 {
			white-space: pre-wrap;
			font-style: italic;
			color: #bbb;
			margin-top: 5px;
			margin-bottom: 25px;
			height: 1.2em;
			animation: 评级出现 0.8s 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28) backwards;
			}
			.结算内容容器 {
			display: flex;
			gap: 30px;
			margin-bottom: 30px;
			}
			.结算统计容器,
			.结算时间轴 {
			flex: 1;
			text-align: left;
			}
			.结算时间轴 {
			border-left: 2px solid rgba(255, 215, 0, 0.2);
			padding-left: 20px;
			}
			.时间轴标题 {
			font-size: 1.1rem;
			color: #ffd700;
			margin-bottom: 15px;
			padding-bottom: 5px;
			border-bottom: 1px solid rgba(255, 215, 0, 0.2);
			}
			.时间轴事件 {
			position: relative;
			padding: 2px 0 15px 15px;
			font-size: 0.9rem;
			color: #ccc;
			opacity: 0;
			transform: translateX(-15px);
			animation: 统计条目出现 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
			}
			.时间轴事件::before {
			content: '';
			position: absolute;
			left: -27px;
			top: 7px;
			width: 9px;
			height: 9px;
			border-radius: 50%;
			background: #e0e0e0;
			border: 2px solid #1a1a1a;
			}
			.时间轴事件.关键::before {
			background: #ffd700;
			box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
			}
			.结算统计容器 {
			display: flex;
			flex-direction: column;
			gap: 12px;
			}
			.统计条目 {
			background: none;
			padding: 0;
			border-left: none;
			}
			.统计标签 {
			font-size: 0.9rem;
			color: #aaa;
			}
			.统计数值 {
			font-size: 1.2rem;
			font-weight: normal;
			color: #fff;
			}
			.通关凭证容器 {
			margin-top: 20px;
			animation: 评级出现 0.8s 1.2s cubic-bezier(0.18, 0.89, 0.32, 1.28) backwards;
			}
			.结算统计容器 {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
			gap: 20px;
			margin-bottom: 30px;
			padding: 20px 0;
			border-top: 1px solid rgba(255, 215, 0, 0.2);
			border-bottom: 1px solid rgba(255, 215, 0, 0.2);
			}
			.统计条目 {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			background: none;
			padding: 0;
			border-left: none;
			opacity: 0;
			transform: translateY(20px);
			animation: 统计条目出现 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
			}
			.结算统计容器 .统计条目:nth-child(1) {
			animation-delay: 0.6s;
			}
			.结算统计容器 .统计条目:nth-child(2) {
			animation-delay: 0.7s;
			}
			.结算统计容器 .统计条目:nth-child(3) {
			animation-delay: 0.8s;
			}
			.结算统计容器 .统计条目:nth-child(4) {
			animation-delay: 0.9s;
			}
			.结算统计容器 .统计条目:nth-child(5) {
			animation-delay: 1.0s;
			}
			.结算统计容器 .统计条目:nth-child(6) {
			animation-delay: 1.1s;
			}
			.统计图标 {
			font-size: 2.5rem;
			line-height: 1;
			margin-bottom: 8px;
			color: #ffd700;
			text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
			}
			.统计数值 {
			font-size: 1.4rem;
			font-weight: bold;
			color: #fff;
			line-height: 1.2;
			}
			.统计标签 {
			font-size: 0.8rem;
			color: #aaa;
			margin-top: 2px;
			}
			@keyframes 统计条目出现 {
			from {
			opacity: 0;
			transform: translateY(20px);
			}
			to {
			opacity: 1;
			transform: translateY(0);
			}
			}
			.收集特效-滤镜 {
				font-family: "color-emoji";
				position: fixed;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				font-size: 3em;
				z-index: 99998;
				animation: 收集脉冲-滤镜 1.1s ease-out forwards;
				filter: drop-shadow(0 0 10px var(--辉光颜色));
			}

			@keyframes 收集脉冲-滤镜 {
				0% {
					transform: scale(0);
					opacity: 0;
				}
				50% {
					transform: scale(1.2);
					opacity: 1;
					filter: drop-shadow(0 0 30px var(--辉光颜色)) drop-shadow(0 0 40px var(--辉光颜色));
				}
				100% {
					transform: scale(1);
					opacity: 0;
					filter: drop-shadow(0 0 10px var(--辉光颜色)) drop-shadow(0 0 20px var(--辉光颜色));
				}
			}
			/*-----------大地图窗口------------*/
			#扳手工具菜单 {
	position: fixed;
	top: 215px;
	right: 5px;
	background: rgba(0,0,0,0.7);
	padding: 10px;
	border-radius: 8px;
	z-index: 998;
	display: none;
	flex-direction: column;
	gap: 10px;
	width: 150px;
	box-sizing: border-box;
	border: 1px solid #4caf50;
}
#扳手工具菜单 h4 {
	margin: 0 0 5px 0;
	text-align: center;
	color: #4caf50;
	font-size: 1em;
}
#扳手规则容器 {
	display: flex;
	flex-direction: column;
	gap: 8px;
	max-height: 200px;
	overflow-y: auto;
	padding-right: 5px;
}
.扳手规则条目 {
	display: flex;
	align-items: center;
	gap: 5px;
	background: rgba(255,255,255,0.05);
	padding: 5px;
	border-radius: 4px;
}
.扳手规则条目 select, .扳手规则条目 input {
	background: #333;
	border: 1px solid #555;
	color: #fff;
	padding: 5px;
	border-radius: 4px;
	font-size: 0.8em;
}


.扳手规则条目 .删除规则按钮 {
	background: #c62828;
	color: white;
	border: none;
	border-radius: 50%;
	width: 20px;
	height: 20px;
	cursor: pointer;
	padding: 0;
	line-height: 20px;
	text-align: center;
	flex-shrink: 0;
}
#添加扳手规则按钮 {
	padding: 5px;
	font-size: 0.8em;
	min-width: unset;
}
			#大地图遮罩 {
    position: fixed;
    top: -5%;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.75);
    backdrop-filter: blur(10px);
    z-index: 10020;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

#大地图遮罩.显示 {
    opacity: 1;
    pointer-events: auto;
}

#大地图窗口 {
    background: linear-gradient(160deg, #181818 0%, #282828 100%);
    border: 1px solid var(--ui-accent-color);
    border-radius: 16px;
    width: 95vw;
    height: 90vh;
    max-width: 1600px;
    max-height: 900px;
    box-shadow: 0 10px 60px rgba(0, 0, 0, 0.5);
    display: flex;
    flex-direction: column;
    transform: scale(0.95) translateY(10px);
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
}

#大地图遮罩.显示 #大地图窗口 {
    transform: scale(1) translateY(0);
}

.大地图头部 {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 25px;
    border-bottom: 1px solid rgba(76, 175, 80, 0.3);
    flex-shrink: 0;
}

.大地图头部 h2 {
    margin: 0;
    font-size: 1.5em;
    color: var(--ui-accent-color);
    text-shadow: 0 0 8px var(--ui-accent-glow);
}

#大地图画布容器 {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
    cursor: grab;
    background-color: var(--canvas-bg);
}

#大地图画布容器:active {
    cursor: grabbing;
}

#大地图画布 {
    position: absolute;
    top: 0;
    left: 0;
    image-rendering: pixelated;
}

.大地图控制栏 {
    display: flex;
    gap: 12px;
    padding: 12px 25px;
    border-top: 1px solid rgba(76, 175, 80, 0.3);
    background: rgba(0,0,0,0.2);
    flex-shrink: 0;
    justify-content: center;
}

.大地图控制栏 .菜单按钮 {
    padding: 8px 18px;
    font-size: 1.2rem;
    min-width: 50px;
    line-height: 1;
}

.大地图信息 {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.6);
    color: #ccc;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 0.8em;
    pointer-events: none;
    z-index: 1;
}
/*-------------命令行风格------------*/
body.命令行风格 {
	background: #000000;
	font-family: 'Courier New', 'Lucida Console', monospace;
	color: #FFFFFF;
}
body.命令行风格 #dungeonCanvas {
	border: 1px solid #FFFFFF;
	box-shadow: none;
	filter: none;
}
body.命令行风格 .hud {
	background: rgba(0,0,0,0.8);
	border: 1px solid #FFFFFF;
	border-radius: 0;
	font-family: 'Courier New', 'Lucida Console', monospace;
}
body.命令行风格 .hud-bar-container {
	height: 10px;
	border: 1px solid #FFF;
	background: #333;
	margin-top: 0;
	border-radius: 0;
}
body.命令行风格 .hud-bar {
	border-radius: 0;
	box-shadow: none;
}
body.命令行风格 .health-bar {
	background: #FFFFFF;
}
body.命令行风格 .power-bar {
	background: #AAAAAA;
}
body.命令行风格 .进度条标签 {
	color: #fff;
	left: 50%;
	transform: translateX(-50%);
	text-shadow: none;
	font-size: 0.8em;
	bottom: auto;
	top: -1px;
}
body.命令行风格 .control-btn {
	background: #000000;
	border: 1px solid #FFFFFF;
	color: #FFFFFF;
	border-radius: 0;
	box-shadow: none;
	font-family: 'Courier New', 'Lucida Console', monospace;
	font-weight: bold;
}
body.命令行风格 .control-btn:active {
	background: #FFFFFF;
	color: #000000;
	transform: none;
	box-shadow: none;
}
body.命令行风格 .背包弹窗 {
	background: rgba(0,0,0,0.9);
	border: 1px solid #FFFFFF;
	border-radius: 0;
}
body.命令行风格 .弹窗头部 h3 {
	color: #FFFFFF;
	text-shadow: none;
	font-family: 'Courier New', 'Lucida Console', monospace;
}
body.命令行风格 .物品容器 {
	display: block;
	font-family: 'Courier New', 'Lucida Console', monospace;
	padding-right: 0;
}
body.命令行风格 .物品条目 {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 2px 10px;
	border: none;
	border-radius: 0;
	cursor: pointer;
	background: transparent;
	color: #FFFFFF;
}
body.命令行风格 .物品条目:hover {
	background: #FFFFFF;
	color: #000000;
	transform: none;
}
body.命令行风格 .物品条目.active {
	background: #555555;
	color: #FFFFFF;
}
body.命令行风格 .物品条目 pre {
	margin: 0;
	white-space: pre;
	font-family: inherit;
}
body.命令行风格 .物品条目 .操作按钮 {
	display: flex;
	gap: 5px;
}
body.命令行风格 .物品条目 .操作按钮 a {
	color: #888;
	text-decoration: none;
}
body.命令行风格 .物品条目:hover .操作按钮 a {
	color: #000;
}
 body.命令行风格 .物品名称 {
	display: none !important;
}
body.命令行风格 .装备栏 {
	background: rgba(0,0,0,0.8);
	border: 1px solid #FFFFFF;
	border-radius: 0;
}
body.命令行风格 .装备槽 {
	background: transparent;
	border: 1px dashed #555;
	border-radius: 0;
}
body.命令行风格 .楼层过渡遮罩 .层数标题 {
	font-family: 'Courier New', 'Lucida Console', monospace;
	font-size: 2.5em;
	text-shadow: none;
	letter-spacing: 0;
	animation: none;
	transform: scale(1);
	opacity: 1;
}
body.命令行风格 .设置菜单 {
    background: #000;
    border: 1px solid #FFF;
    border-radius: 0;
}
body.命令行风格 .设置菜单 button {
    background: #000;
    border: 1px solid #FFF;
    color: #FFF;
    border-radius: 0;
    font-family: 'Courier New', monospace;
}
body.命令行风格 .设置菜单 button:active {
    background: #FFF;
    color: #000;
    transform: none;
    box-shadow: none;
}

#扳手规则窗口遮罩 {
	position: fixed;
	top: 0; left: 0;
	width: 100vw; height: 100vh;
	background: rgba(0,0,0,0.7);
	backdrop-filter: blur(5px);
	z-index: 10008;
	display: flex;
	align-items: center;
	justify-content: center;
	opacity: 0;
	pointer-events: none;
	transition: opacity 0.3s ease-out;
}
#扳手规则窗口遮罩.显示 {
	opacity: 1;
	pointer-events: auto;
}
#扳手规则窗口 {
	background: #2a2a2a;
	color: #e0e0e0;
	padding: 20px;
	border-radius: 8px;
	width: 90%;
	max-width: 500px;
	border: 1px solid #4caf50;
	transform: scale(0.95);
	opacity: 0;
	transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s ease-out;
}
#扳手规则窗口遮罩.显示 #扳手规则窗口 {
	transform: scale(1);
	opacity: 1;
}
#扳手规则窗口 h4 {
	margin: 0 0 15px 0;
	text-align: center;
	color: #4caf50;
}
#扳手规则容器 {
	display: flex;
	flex-direction: column;
	gap: 8px;
	max-height: 40vh;
	overflow-y: auto;
	padding: 5px;
	margin-bottom: 10px;
	border: 1px solid #444;
	border-radius: 4px;
}
.扳手规则条目 {
	display: flex;
	align-items: center;
	gap: 5px;
	background: rgba(255,255,255,0.05);
	padding: 8px;
	border-radius: 4px;
}
.扳手规则条目 input, .扳手规则条目 select {
	background: #333;
	border: 1px solid #555;
	color: #fff;
	padding: 8px;
	border-radius: 4px;
	font-size: 0.9em;
}
.扳手规则条目 .属性输入 { flex: 1; min-width: 0;}
.扳手规则条目 .操作选择 { flex: 0.5; min-width: 0;}
.扳手规则条目 .数值输入 {
	flex: 1.5;
	display: flex;
	gap: 4px;
	min-width: 0;
}
.扳手规则条目 .数值输入 input {
	flex: 1;
	width: 100%;
	min-width: 30px;
	box-sizing: border-box;
}
.扳手规则条目 .删除规则按钮 {
	background: #c62828;
	color: white;
	border: none;
	border-radius: 50%;
	width: 24px;
	height: 24px;
	cursor: pointer;
	padding: 0;
	line-height: 24px;
	text-align: center;
	flex-shrink: 0;
}
#扳手窗口按钮容器 {
	display: flex;
	justify-content: space-between;
	margin-top: 15px;
}
body.命令行风格 .物品条目 .操作链接 {
	display: flex;
	
	font-family: 'Courier New', 'Lucida Console', monospace;
}
body.命令行风格 .物品条目 .操作链接 a {
	color: #888;
	text-decoration: none;
}
body.命令行风格 .物品条目:hover .操作链接 a {
	color: #000;
	text-decoration: underline;
}
body.命令行风格 .设置菜单 {
    background: #000;
    border: 1px solid #FFF;
    border-radius: 0;
}
body.命令行风格 .设置菜单 button {
    background: #000;
    border: 1px solid #FFF;
    color: #FFF;
    border-radius: 0;
    font-family: 'Courier New', monospace;
}
body.命令行风格 .设置菜单 button:active {
    background: #FFF;
    color: #000;
    transform: none;
    box-shadow: none;
}
			/* -----------优化字体适配------------- */
			body,
        .hud,
        .控制按钮 {
            font-family: "HarmonyOS Sans SC", "MiSans", system-ui, "color-emoji";
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        @font-face {
            font-family: "color-emoji";
            src: local("Fluent Emoji Color"),
                url('./FluentEmojiColor.ttf') format('truetype'),
            
                local("Apple Color Emoji"),
                url('./AppleColorEmoji.woff') format('woff'),
                
                local("Segoe UI Emoji"),
                local("Segoe UI Symbol"),
                local("Noto Color Emoji"),
                local("Arial");
        }
			
		</style>
	</head>
	<body class="初始化">
		<div id="effectsContainer"></div>
		<div id="大地图遮罩">
    <div id="大地图窗口">
        <div class="大地图头部">
            <h2 id="大地图楼层标题" style="color:white;">地牢地图</h2>
            <button id="关闭大地图按钮" class="关闭按钮">×</button>
        </div>
        <div id="大地图画布容器">
             <canvas id="大地图画布"></canvas>
             <div id="大地图信息" class="大地图信息"></div>
        </div>
        <div class="大地图控制栏">
            <button id="大地图上一层按钮" class="菜单按钮" title="上一层">🔼</button>
            <button id="大地图下一层按钮" class="菜单按钮" title="下一层">🔽</button>
            <button id="大地图缩放放大按钮" class="菜单按钮" title="放大">+</button>
            <button id="大地图缩放缩小按钮" class="菜单按钮" title="缩小">-</button>
            <button id="大地图居中按钮" class="菜单按钮" title="居中玩家">🎯</button>
            <button id="大地图标记模式按钮" class="菜单按钮" title="标记模式">📌</button>
            <button id="大地图传送按钮" class="菜单按钮" title="传送" style="display: none;">🚀</button>
        </div>
    </div>
</div>
		<div id="设置窗口遮罩" style="display: none;">
			<div id="设置窗口">
				<div class="设置标题行">
					<h2 class="设置标题">游戏设置</h2>
					<button id="关闭设置窗口按钮" class="关闭按钮">×</button>
				</div>
				<div class="设置内容">
					<div class="设置分区">
						<h3>热键绑定</h3>
						<div id="热键绑定容器" class="热键绑定网格">
						</div>
					</div>
					<div class="设置分区">
						<h3>操控</h3>
						<div class="设置行">
							<label for="方向键大小滑块" class="设置标签">方向键大小</label>
							<input type="range" id="方向键大小滑块" min="8" max="20" value="13">
							<span id="方向键大小值">13vmin</span>
						</div>
						<div class="设置行">
							<label class="设置标签">显示方向键</label>
							<button id="显示方向键切换" class="设置切换按钮"></button>
						</div>
						<div class="设置行">
							<label class="设置标签">禁用点击寻路</label>
							<button id="禁用点击寻路切换" class="设置切换按钮"></button>
						</div>
						<div class="设置行">
							<label for="移动速度滑块" class="设置标签">长按触发速度</label>
							<input type="range" id="移动速度滑块" min="0" max="200" value="100" step="5">
							<span id="移动速度值">100ms</span>
						</div>
						<div class="设置行">
							<label class="设置标签">强制手机模式</label>
							<button id="手机模式切换" class="设置切换按钮"></button>
						</div>
						<div class="设置行">
							<label class="设置标签">玩家受伤时击退</label>
							<button id="受伤击退切换" class="设置切换按钮"></button>
						</div>
					</div>
					<div class="设置分区">
						<h3>显示</h3>
						<div class="设置行">
							
							<label for="emoji样式选择" class="设置标签">Emoji 风格</label>
							<select id="emoji样式选择" style="background-color: var(--ui-bg-color); border: 1px solid var(--ui-border-color); color: var(--ui-text-color); padding: 10px 12px; border-radius: 6px; font-family: inherit; font-size: 1em; width: 50%; box-sizing: border-box; transition: all 0.2s ease-in-out; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23cccccc' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E&quot;); background-repeat: no-repeat; background-position: right 12px center; background-size: 16px;">
								<option value="local">本地字体</option>
								<option value="microsoft-3D-fluent">微软 3D</option>
								<option value="google">谷歌</option>
								<option value="apple">苹果</option>
								<option value="samsung">三星</option>
								<option value="microsoft">微软 2D</option>
								<option value="whatsapp">WhatsApp</option>
								<option value="twitter">推特</option>
								<option value="facebook">脸书</option>
								<option value="huawei">华为</option>
								<option value="joypixels">JoyPixels</option>
								<option value="lg">LG</option>
								<option value="telegram">Telegram</option>
								<option value="microsoft-teams">Microsoft Teams</option>
								<option value="skype">Skype</option>
								<option value="twitter-emoji-stickers">Twitter Stickers</option>
								<option value="serenityos">SerenityOS</option>
								<option value="toss-face">Toss Face</option>
								<option value="sony">索尼</option>
								<option value="noto-emoji">Noto Emoji</option>
								<option value="openmoji">OpenMoji</option>
								<option value="icons8">Icons8</option>
								<option value="emojidex">Emojidex</option>
								<option value="messenger">Messenger</option>
								<option value="htc">HTC</option>
								<option value="softbank">Softbank</option>
								<option value="docomo">Docomo</option>
								<option value="au-kddi">au by KDDI</option>
								<option value="mozilla">Mozilla</option>
							</select>
						</div>
						<div class="设置行">
							<label class="设置标签">命令行风格</label>
							<button id="命令行风格切换" class="设置切换按钮"></button>
						</div>
						<div class="设置行">
							<label class="设置标签">动画模式</label>
							<button id="动画模式切换" class="设置切换按钮"></button>
						</div>
						<div class="设置行">
							<label class="设置标签">文本模式</label>
							<button id="文本模式切换" class="设置切换按钮"></button>
						</div>
						<div class="设置行">
							<label for="相机视野滑块" class="设置标签">相机视野大小</label>
							<input type="range" id="相机视野滑块" min="5" max="30" value="15">
							<span id="相机视野值">15</span>
						</div>
						<div class="设置行">
							<label for="小地图大小滑块" class="设置标签">小地图大小</label>
							<input type="range" id="小地图大小滑块" min="0" max="250" value="150">
							<span id="小地图大小值">150px</span>
						</div>
					</div>
				</div>
				<div class="设置页脚">
					<button id="保存设置按钮" class="菜单按钮">保存并应用</button>
				</div>
			</div>
		</div>
		<canvas id="dungeonCanvas"></canvas>
		<div id="结算界面遮罩" style="display: none;">
			<div id="结算粒子容器"></div>
			<div class="结算界面">
				<h2 class="结算标题"></h2>
				<div id="结局评级" class="结局评级"></div>
				<p id="结束评语" class="结束评语"></p>
				<div class="结算统计容器">
				</div>
				<div class="通关凭证容器">
					<span class="凭证标签">通关凭证</span>
					<div class="凭证码" id="通关凭证码"></div>
				</div>
				<div class="结算按钮容器">
					<button id="结算返回主菜单按钮" class="菜单按钮">返回主菜单</button>
				</div>
			</div>
		</div>
		<div id="创意关卡浏览器" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%); z-index: 10003; color: #e0e0e0; font-family: 'HarmonyOS Sans SC', 'MiSans', system-ui, 'color-emoji'; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 5vh; box-sizing: border-box; overflow-y: auto;">
			<button id="返回游戏模式选择按钮" style="position: fixed;
				top: 20px;
				left: 20px;
				z-index: 10004;
				width: 45px;
				height: 45px;
				border-radius: 50%;
				background: rgba(40, 40, 40, 0.7);
				border: 1px solid #4caf50;
				color: #e0e0e0;
				font-size: 24px;
				font-weight: bold;
				display: flex;
				align-items: center;
				justify-content: center;
				cursor: pointer;
				transition: all 0.3s ease;
				padding: 0;
				line-height: 1;
				box-shadow: 0 2px 8px rgba(0,0,0,0.5);
				backdrop-filter: blur(3px);">←</button>
			<div id="关卡详情界面" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%); z-index: 10004; color: #e0e0e0; font-family: 'HarmonyOS Sans SC', 'MiSans', system-ui, 'color-emoji'; flex-direction: column; align-items: center; justify-content: flex-start; padding: 5vh 2vh; box-sizing: border-box; overflow-y: auto;">
				<div id="关卡详情容器" style="display: flex; flex-wrap: wrap; width: 95%; max-width: 900px; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; gap: 20px;">
					<div id="关卡详情_左侧" style="flex: 1; min-width: 280px; display: flex; flex-direction: column;">
						<h2 id="详情_标题" style="font-size: 2rem; color: #66bb6a; margin: 0 0 10px 0; word-break: break-all;"></h2>
						<div style="color: #aaa; border-bottom: 1px solid #444; padding-bottom: 15px; margin-bottom: 15px;">
							<span id="详情_作者"></span> | <span id="详情_版本"></span>
						</div>
						<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; font-size: 1.1em; margin-bottom: 20px;">
							<span id="详情_游玩次数" title="游玩次数">👁️ 0</span>
							<span id="详情_通关次数" title="通关人数">🏆 0</span>
							<span id="详情_赞" title="赞">👍 0</span>
							<span id="详情_踩" title="踩">👎 0</span>
						</div>
						<div id="详情_操作按钮容器" style="display: flex; flex-direction: column; gap: 1rem; margin-top: auto;">
						</div>
					</div>
					<div id="关卡详情_右侧" style="flex: 1; min-width: 280px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
						<h4 style="margin: 0 0 10px 0; color: #888;">关卡预览</h4>
						<canvas id="详情_小地图" style="width: 100%; max-width: 300px; aspect-ratio: 1 / 1; border: 1px solid #444; border-radius: 8px; background: #000;"></canvas>
					</div>
				</div>
				<button id="返回浏览器按钮" class="菜单按钮" style="margin-top: 1.5rem; margin-bottom: 2vh; border-color: #aaa; background: rgba(150,150,150,0.1); flex-shrink: 0;">返回工坊</button>
			</div>
			<h2 style="font-size: 2.5rem; color: #4caf50; margin-bottom: 2rem;">创意工坊</h2>
			<div id="上传区域" style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 8px; margin-bottom: 20px; width: 80%; max-width: 500px; display: flex; flex-direction: column; gap: 10px;">
				<h3 style="margin: 0; text-align: center; color: #66bb6a;">上传你的关卡</h3>
				<input type="file" id="关卡文件输入" accept=".json" style="color: #ccc; background: #333; border: 1px solid #555; border-radius: 4px; padding: 8px;">
				<input type="text" id="关卡标题输入" placeholder="关卡标题" style="background: #333; border: 1px solid #555; color: #fff; padding: 8px; border-radius: 4px;">
				<input type="text" id="关卡作者输入" placeholder="作者" style="background: #333; border: 1px solid #555; color: #fff; padding: 8px; border-radius: 4px;">
				<input type="text" id="关卡标签输入" placeholder="标签（逗号分隔）" style="background: #333; border: 1px solid #555; color: #fff; padding: 8px; border-radius: 4px;">
				<input type="password" id="关卡上传密码输入" placeholder="设置一个删除密码" style="background: #333; border: 1px solid #555; color: #fff; padding: 8px; border-radius: 4px;">
				<button id="上传关卡按钮" class="菜单按钮" style="min-width: unset; width: 100%;">上传关卡</button>
			</div>
			<hr style="width: 80%; border-color: #444;">
			<div id="搜索与列表区域" style="width: 80%; max-width: 700px; margin-top: 20px; flex-grow: 1; display: flex; flex-direction: column;">
				<div id="搜索行" style="display: flex; gap: 10px; margin-bottom: 20px;">
					<input type="text" id="搜索关卡输入" placeholder="搜索标题..." style="flex-grow: 1; background: #333; border: 1px solid #555; color: #fff; padding: 10px; border-radius: 4px;">
					<button id="搜索关卡按钮" class="菜单按钮" style="min-width: unset; padding: 10px 20px;">搜索/刷新</button>
				</div>
				<ul id="关卡列表" style="list-style: none; padding: 0; margin: 0 0 5vh 0; overflow-y: auto; max-height: none;">
				</ul>
			</div>
		</div>
		<div id="游戏模式选择菜单" style="display: none;">
			<div id="游戏模式内容">
				<h2 id="游戏模式标题">选择游戏模式</h2>
				<div id="游戏模式选项">
					<button id="无尽地牢按钮" class="菜单按钮">无尽地牢</button>
					<button id="无尽洞穴按钮" class="菜单按钮">无尽洞穴</button>
					<button id="无尽迷宫按钮" class="菜单按钮">无尽迷宫</button>
					<button id="创意关卡按钮" class="菜单按钮">创意工坊</button>
				</div>
				<button id="返回主菜单按钮" class="菜单按钮" style="margin-top: 2rem; border-color: #aaa; background: rgba(150,150,150,0.1);">返回主菜单</button>
			</div>
		</div>
		<div id="职业选择遮罩">
			<div id="职业选择窗口" class="重铸弹窗">
				<h2 class="职业选择标题">开始新的冒险</h2>
				<div class="设置项目">
					<label for="游戏种子输入" style="margin-bottom: 5px;">输入种子 (留空则随机)</label>
					<div class="种子输入容器">
						<input type="text" id="游戏种子输入" placeholder="输入自定义种子...">
						<button id="每日挑战按钮" title="每日挑战">📅</button>
						<button id="种子筛选器按钮" title="种子筛选器">🔍</button>
					</div>
				</div>
				<h3 style="font-size: 1.2em; color: #e0e0e0; border-bottom: 1px dashed #555; padding-bottom: 8px; margin: 20px 0 15px 0;">选择你的职业</h3>
				<div id="职业选项容器" class="职业选项容器">
				</div>
				<div class="职业选择页脚">
					<button id="返回模式选择按钮" class="菜单按钮" style="background: rgba(150,150,150,0.1); border-color: #aaa; flex: 1;">返回</button>
					<button id="开始游戏自定义按钮" class="菜单按钮" style="flex: 2;">踏上征程</button>
				</div>
			</div>
		</div>
		<input type="file" id="创意关卡文件输入" accept=".json" style="display: none" />
		<div id="楼层选择遮罩" class="重铸遮罩" style="display: none; z-index: 10006;">
			<div id="楼层选择窗口" class="重铸弹窗">
				<div class="重铸弹窗-header">
					<h3>选择要导入的楼层</h3>
					<button class="关闭按钮" id="关闭楼层选择按钮">×</button>
				</div>
				<div id="楼层选择列表" class="重铸弹窗-items" style="max-height: none; display: grid;">
				</div>
			</div>
		</div>
		<div id="图鉴分区选择遮罩" class="重铸遮罩" style="display: none; z-index: 10005">
			<div id="图鉴分区选择窗口">
				<div class="重铸弹窗-header">
					<h3>选择图鉴分区</h3>
					<button class="关闭按钮" id="关闭图鉴选择按钮">×</button>
				</div>
				<div id="图鉴分区列表容器" class="重铸弹窗-items" style="
					max-height: 60vh;
					grid-template-columns: repeat(
					auto-fill,
					minmax(150px, 1fr)
					);
					"></div>
			</div>
		</div>
		<button id="返回编辑器按钮" class="菜单按钮 不可选中" style="display: none; position: fixed; top: 5px; right: 5px; z-index: 10006; min-width: 120px; padding: 8px 15px; font-size: 0.9em; background: #f44336;">返回编辑器</button>
		<div id="编辑器工具栏" class="不可选中" style="position: fixed; top: 5px; right: 5px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; z-index: 1000; display: flex; flex-direction: column; gap: 8px;">
			<button id="全局设置按钮" class="菜单按钮" style="min-width: 120px; padding: 8px 15px; font-size: 0.9em;">全局/地图设置</button>
			<button id="编辑器撤回按钮" class="菜单按钮" style="min-width: 120px; padding: 8px 15px; font-size: 0.9em;">撤回</button>
			<button id="编辑器重做按钮" class="菜单按钮" style="min-width: 120px; padding: 8px 15px; font-size: 0.9em;">重做</button>
			<button id="编辑器游玩按钮" class="菜单按钮" style="min-width: 120px; padding: 8px 15px; font-size: 0.9em; background: #2196f3;">开始游玩</button>
		</div>
		<div id="扳手工具菜单" class="不可选中">
			<button id="打开扳手规则按钮" class="菜单按钮" style="min-width: 120px; padding: 8px 15px; font-size: 0.9em;">编辑规则</button>
		</div>

		<div id="扳手规则窗口遮罩">
			<div id="扳手规则窗口">
				<h4>扳手规则编辑器</h4>
				<div id="扳手规则容器"></div>
				<div id="扳手窗口按钮容器">
					<button id="添加扳手规则按钮" class="菜单按钮">添加规则</button>
					<button id="关闭扳手规则按钮" class="菜单按钮">保存并关闭</button>
				</div>
			</div>
		</div>
		<div id="笔刷工具容器" class="不可选中" style="display: none;">
			<div class="设置项目" style="gap: 8px;">
				<label for="编辑器工具选择" style="color: #ccc;">工具模式</label>
				<select id="编辑器工具选择" style="background: #333; border: 1px solid #555; color: #fff; padding: 5px; border-radius: 4px; width: 100%;">
					<option value="单个">单个放置</option>
					<option value="笔刷">笔刷</option>
					<option value="油漆桶">油漆桶</option>
				</select>
			</div>
			<div id="笔刷设置容器" style="display: none; flex-direction: column; gap: 8px;">
				<div class="设置项目" style="gap: 8px;">
					<label for="笔刷形状选择" style="color: #ccc;">笔刷形状</label>
					<select id="笔刷形状选择" style="background: #333; border: 1px solid #555; color: #fff; padding: 5px; border-radius: 4px; width: 100%;">
						<option value="圆形">圆形</option>
						<option value="矩形">矩形</option>
					</select>
				</div>
				<div class="设置项目" style="gap: 8px;">
					<label for="笔刷尺寸滑块" style="color: #ccc;">笔刷尺寸: <span id="笔刷尺寸值">3</span></label>
					<input type="range" id="笔刷尺寸滑块" min="1" max="15" value="3" style="width: 100%;">
				</div>
			</div>
		</div>
		<div id="编辑器属性面板遮罩" class="重铸遮罩" style="display: none; z-index: 10006;">
			<div id="编辑器属性面板" class="重铸弹窗" style="max-width: 500px; max-height: 80vh; overflow-y: scroll;">
				<div class="重铸弹窗-header">
					<h3 id="属性面板标题">编辑属性</h3>
					<button class="关闭按钮" id="关闭属性面板按钮">×</button>
				</div>
				<div id="属性面板内容" class="重铸弹窗-items" style="display: block; padding: 15px;"></div>
				<div style="display: flex; justify-content: space-between; padding: 10px 0;">
					<button id="删除对象按钮" class="菜单按钮" style="background: #c62828; border-color: #e53935; min-width: 100px; padding: 8px 15px; font-size: 0.9em;">删除</button>
					<button id="保存属性按钮" class="菜单按钮" style="min-width: 100px; padding: 8px 15px; font-size: 0.9em;">应用</button>
				</div>
			</div>
		</div>
		<div id="全局设置窗口" class="重铸弹窗" style="max-width: 500px; max-height: 80vh; overflow-y: scroll; display: none;">
			<div class="重铸弹窗-header">
				<h3>全局/地图设置</h3>
				<button class="关闭按钮" id="关闭全局设置按钮">×</button>
			</div>
			<div id="全局设置内容" class="重铸弹窗-items" style="display: flex; flex-direction: column; gap: 15px; padding: 15px;">
				<h4 style="margin-bottom: -5px; border-bottom: 1px solid #444; padding-bottom: 5px;">地图操作</h4>
				<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
					<button id="编辑器保存按钮" class="菜单按钮" style="padding: 8px 15px; font-size: 0.9em; margin:0; min-width:0px;">导出地图</button>
					<button id="编辑器加载按钮" class="菜单按钮" style="padding: 8px 15px; font-size: 0.9em; margin:0; min-width:0px;">导入地图</button>
					<button id="编辑器设置起点按钮" class="菜单按钮" style="padding: 8px 15px; font-size: 0.9em; margin:0; min-width:0px;">设置起点</button>
					<button id="编辑器模板按钮" class="菜单按钮" style="padding: 8px 15px; font-size: 0.9em; margin:0; min-width:0px;">生成地牢模板</button>
					<button id="编辑器洞穴模板按钮" class="菜单按钮" style="padding: 8px 15px; font-size: 0.9em; margin:0; min-width:0px;">生成洞穴模板</button>
					<button id="编辑器迷宫模板按钮" class="菜单按钮" style="padding: 8px 15px; font-size: 0.9em; margin:0; min-width:0px;">生成迷宫模板</button>
				</div>
				<h4 style="margin-top: 15px; border-bottom: 1px solid #444; padding-top: 10px;">初始状态</h4>
				<div style="display: flex; gap: 10px; flex-direction: column;">
					<div class="设置项目">
						<label for="设置_初始生命值">初始生命值</label>
						<input type="number" id="设置_初始生命值" value="100" min="1">
					</div>
					<div class="设置项目">
						<label for="设置_初始能量值">初始能量值</label>
						<input type="number" id="设置_初始能量值" value="100" min="0">
					</div>
					<div class="设置项目">
						<label for="设置_初始背包容量">初始背包容量</label>
						<input type="number" id="设置_初始背包容量" value="12" min="1" max="24">
					</div>
					<div class="设置项目">
						<label for="设置_初始移动步数">初始移动步数</label>
						<input type="number" id="设置_初始移动步数" value="1" min="1">
					</div>
					<div class="设置项目">
						<label for="设置_初始攻击加成">初始攻击加成</label>
						<input type="number" id="设置_初始攻击加成" value="0" min="0">
					</div>
					<div class="设置项目">
						<label for="设置_初始防御加成">初始防御加成</label>
						<input type="number" id="设置_初始防御加成" value="0" min="0">
					</div>
				</div>
				<h4 style="margin-top: 15px; border-bottom: 1px solid #444; padding-top: 10px;">胜利/失败条件 (0为不限制)</h4>
				<div style="display: flex; flex-direction: column; gap: 10px;">
					<div class="设置项目">
						<label for="设置_回合数限制">回合数限制</label>
						<input type="number" id="设置_回合数限制" value="0" min="0">
					</div>
					<div class="设置项目">
						<label for="设置_伤害限制">总受伤限制</label>
						<input type="number" id="设置_伤害限制" value="0" min="0">
					</div>
					<div class="设置项目">
						<label for="设置_生命下限">最低生命值</label>
						<input type="number" id="设置_生命下限" value="0" min="0">
					</div>
					<div class="设置项目">
						<label for="设置_死亡次数限制">死亡次数限制</label>
						<input type="number" id="设置_死亡次数限制" value="0" min="0">
					</div>
					<div class="设置项目">
						<label for="设置_清除所有怪物">清除所有怪物</label>
						<input type="checkbox" id="设置_清除所有怪物">
					</div>
				</div>
				<h4 style="margin-top: 15px; border-bottom: 1px solid #444; padding-top: 10px;">编辑器设置</h4>
				<div class="设置项目">
					<label for="设置_禁用传送菜单">禁用传送菜单</label>
					<input type="checkbox" id="设置_禁用传送菜单">
				</div>
				<div class="设置项目">
					<label for="设置_禁用休息">禁用休息</label>
					<input type="checkbox" id="设置_禁用休息">
				</div>
				<div class="设置项目">
					<label for="设置_禁用大地图">禁用大地图</label>
					<input type="checkbox" id="设置_禁用大地图">
				</div>
				<div class="设置项目">
					<label for="设置_相机视野大小">视野大小 (仅单次生效)</label>
					<input type="number" id="设置_相机视野大小" value="15" min="5" max="50">
				</div>
				<div class="设置项目">
					<label for="设置_诡魅天气怪物层级">诡魅天气怪物层级</label>
					<input type="number" id="设置_诡魅天气怪物层级" value="1" min="0">
				</div>
				<div class="设置项目">
					<label for="设置_奖励物品层级">奖励物品层级</label>
					<input type="number" id="设置_奖励物品层级" value="1" min="0">
				</div>
				<h4 style="grid-column: 1 / -1; margin-top: 15px; border-bottom: 1px solid #444; padding-top: 10px;">全局天气</h4>
				<div id="天气选择容器" class="天气选择容器">
				</div>
			</div>
			<div style="display: flex; justify-content: flex-end; padding: 10px;">
				<button id="保存全局设置按钮" class="菜单按钮" style="min-width: 100px; padding: 8px 15px; font-size: 0.9em;">应用</button>
			</div>
		</div>
		<div id="主菜单容器">
			<h1 id="游戏标题">中文地牢</h1>
			<div id="菜单选项">
				<button id="新建游戏按钮" class="菜单按钮">开始新游戏</button>
				<button id="读取存档按钮" class="菜单按钮">读取存档</button>
				<button id="图鉴按钮" class="菜单按钮">图鉴</button>
				<button id="地图编辑器按钮" class="菜单按钮">地图编辑器</button>
				<button id="读凭证按钮" class="菜单按钮">读取凭证</button>
				<button id="设置按钮_主菜单" class="菜单按钮">设置</button>
			</div>
			<div id="版本信息">游戏似乎崩溃了!请尝试反馈!</div>
		</div>
		<div id="教程提示窗口" class="教程提示窗口">
			<p id="教程提示内容"></p>
			<button class="关闭按钮" onclick="关闭教程提示()">我知道了</button>
		</div>
		<button id="回放教程按钮" class="control-btn" onclick="打开教程回放窗口()" style="display: block; height: 5vmin; font-size: 0.8em">
		回看教程
		</button>
		<button id="跳过教程按钮" class="control-btn" onclick="跳过教程()">
		跳过
		</button>
		<div id="教程回放窗口" class="教程提示窗口">
			<p id="教程回放内容"></p>
			<div class="教程导航">
				<button id="上一页教程按钮" class="关闭按钮" style="margin-left: unset">
				上一页
				</button>
				<span id="教程页码" style="margin-left: auto">1 / 1</span>
				<button id="下一页教程按钮" class="关闭按钮">下一页</button>
			</div>
			<button class="关闭按钮" onclick="关闭教程回放窗口()">关闭</button>
		</div>
		<div id="扣血特效" class="扣血遮罩"></div>
		<div id="怪物指示器容器"></div>
		<div class="装备栏">
			<div class="装备槽" id="装备槽1"></div>
			<div class="装备槽" id="装备槽2"></div>
			<div class="装备槽" id="装备槽3"></div>
			<div class="装备槽" id="装备槽4"></div>
			<div class="装备槽" id="装备槽5"></div>
			<div class="装备槽" id="装备槽6"></div>
			<div class="装备槽" id="装备槽7"></div>
		</div>
		<div class="control-pad 不可选中" style="z-index: 1000">
			<div class="control-row">
				<div class="control-btn directional-btn" id="upBtn">↑</div>
			</div>
			<div class="control-row">
				<div class="control-btn directional-btn" id="leftBtn">←</div>
				<div class="control-btn directional-btn" id="rightBtn">→</div>
			</div>
			<div class="control-row">
				<div class="control-btn directional-btn" id="downBtn">↓</div>
			</div>
		</div>
		<div class="control-pad-actions 不可选中" style="z-index: 1000">
			<div class="control-row">
				<button id="背包按钮" onclick="切换背包显示()" class="control-btn">🎒</button>
				<button id="互动按钮" onclick="尝试互动()" class="control-btn">⚡</button>
				<button id="hudToggle" class="control-btn" style="position: absolute; bottom: 110%" onclick="处理HUD切换按钮点击()">👁️</button>
			</div>
		</div>
		<div class="settings-container 不可选中" style="z-index: 999">
			<div class="control-row">
				<button id="设置按钮" class="control-btn" onclick="切换设置菜单()" style="font-size: 1em">⚙️</button>
			</div>
		</div>
		<div id="gameInfoOverlay" class="game-info-overlay">
			<div id="gameInfoWindow" class="game-info-window">
				<div class="game-info-header">
					<h2>关于 中文地牢</h2>
					<button id="closeGameInfoBtn" class="关闭按钮">×</button>
				</div>
				<div id="gameInfoContent" class="game-info-content">
					<h3>灵感来源</h3>
					<p><strong>《Pixel Dungeon》:</strong> 未知道具系统、职业系统、陷阱</p>
					<p><strong>《Super Mario Maker》:</strong> 地图编辑器</p>
					<p><strong>《NetHack》:</strong> 道具融合系统</p>
					<p><strong>《Rogue》:</strong> 程序生成地牢</p>
					<h3>更新日志 <span class="info-version-tag">v</span></h3>
					<ul>
						<li><strong>新功能:</strong> 内置了多种 Emoji 风格选择，增加了命令行模式。</li>
						<li><strong>新功能:</strong> 在地图编辑器增加休息功能调控。</li>
						<li><strong>新元素:</strong> 在地图编辑器增加扳手工具。</li>
						<li><strong>调整:</strong> 优化了大地图渲染。</li>
						<li><strong>修复:</strong> 修复了若干问题。</li>
					</ul>
					
					<h3>游戏简介</h3>
					<p>《中文地牢》是一款基于字符和Emoji的轻量级Roguelike地牢探索游戏。在这个由未知构成的世界里，每一次冒险都是独一无二的。</p>
				</div>
			</div>
		</div>
		<div id="浮动提示框"></div>
		<div id="配方书遮罩" class="重铸遮罩" style="display: none; z-index: 10005">
			<div id="配方书窗口" style="
				position: fixed;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				background: #1a1a1ae6;
				border: 2px solid #4a4a4a;
				border-radius: 12px;
				padding: 20px;
				width: 80vmin;
				max-width: 700px;
				color: #e0e0e0;
				z-index: 10006;
				box-shadow: 0 0 30px #00000080;
				animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
				transition: opacity 0.3s ease,
				transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
				display: flex;
				flex-direction: column;
				max-height: 85vh;
				">
				<div class="重铸弹窗-header" style="border-bottom: 1px solid #4caf50">
					<h3 style="color: #4caf50">配方书</h3>
					<button class="关闭按钮" id="关闭配方书按钮" style="color: #4caf50">
					×
					</button>
				</div>
				<div id="配方书内容容器" class="重铸弹窗-items" style="
					max-height: calc(85vh - 100px);
					overflow-y: auto;
					padding: 15px;
					display: flex;
					flex-direction: column;
					gap: 10px;
					"></div>
			</div>
		</div>
		<div id="设置菜单" class="设置菜单">
			
			<button onclick="切换日志显示()">打开日志菜单</button>
			<button onclick="收纳通知()">收纳通知</button>
			<button onclick="打开传送菜单()">打开传送菜单</button>
			<button onclick="打开配方书()">配方书</button>
			<button id="导出存档按钮" onclick="导出存档()">导出存档</button>
			<button id="重置关卡按钮" onclick="重置创意关卡()" style="display: none;">重新开始关卡</button>
			<button id="自杀按钮" onclick="玩家死亡()">自杀</button>
			<button onclick="打开游戏内设置()">游戏设置</button>
			<button id="导出当前状态按钮" onclick="导出当前状态为创意关卡()" style="display: none; border-color: #ffd700;">导出当前状态(开发者)</button>
			<button id="复制画面按钮" onclick="复制命令行画面()" style="display: none;">复制画面</button>
		</div>
		<div id="传送点遮罩" class="重铸遮罩" style="display: none; z-index: 10001">
			<div id="传送点菜单">
				<div class="重铸弹窗-header">
					<h3>选择传送目标</h3>
					<button class="关闭按钮" onclick="关闭传送菜单()">×</button>
				</div>
				<div id="传送点列表容器" class="重铸弹窗-items" style="max-height: 60vh"></div>
			</div>
		</div>
		<input type="file" id="存档文件输入" accept=".json" style="display: none" />
		<div id="小地图容器">
			<canvas id="小地图"></canvas>
		</div>
		<div class="hud">
			<div class="hud-item">
				<span class="hud-icon">♥️</span>
				<div class="hud-bar-container">
					<div class="hud-bar health-bar" style="width: 100%"></div>
				</div>
			</div>
			<div class="hud-item">
				<span class="hud-icon">⚡︎</span>
				<div class="hud-bar-container">
					<div class="hud-bar power-bar" style="width: 100%"></div>
				</div>
			</div>
			<div class="hud-item">
				<div class="界面文本行">
					<span class="hud-label"
						>已探索房间：<span id="roomCount">0</span></span>
				</div>
			</div>
		</div>
		<div class="背包弹窗">
			<div id="融合窗口" style="display: none">
				<div class="弹窗头部">
					<h3>物品融合</h3>
				</div>
				<div class="融合区域">
					<div class="融合区格子" id="融合区格子1"></div>
					<div class="融合区格子" id="融合区格子2"></div>
					<div class="融合区格子" id="融合区格子3"></div>
					<div class="融合区格子" id="融合区格子4"></div>
				</div>
				<div class="融合箭头">➡️</div>
				<div class="融合输出格子" id="融合输出格子"></div>
			</div>
			<div class="弹窗头部">
				<h3>
					背包 (容量：<span id="当前容量">0</span>/<span id="最大容量"
						>12</span>)
				</h3>
				<button id="背包整理按钮" title="整理背包" class="关闭按钮" style="margin-right: auto; margin-left: 10px; font-size: 1em; display: flex; align-items: center; gap: 5px;">
					<span class="整理图标">🔀</span>
					<span class="整理文本" style="display: none;">整理</span>
				</button>
				<button onclick="切换背包显示()" class="关闭按钮">×</button>
			</div>
			<div id="背包物品栏" class="物品容器"></div>
		</div>
		<div id="transitionMask" class="楼层过渡遮罩">
			<div id="floorTitle" class="层数标题"></div>
		</div>
		<div class="日志面板" id="日志面板" style="z-index: 1002">
			<div class="日志内容" id="logContent"></div>
		</div>
		<div id="交易窗口">
			<div class="窗口标题">
				神秘商人（剩余交易次数：<span id="交易次数">3</span>）
			</div>
			<div class="库存列表"></div>
			<div class="交易底部">
				<div class="玩家金币">
					持有金币：<span id="当前金币">0</span>
				</div>
				<button onclick="关闭交易窗口()" class="按钮">离开</button>
			</div>
		</div>
		<div id="收购窗口" class="游戏窗口">
			<div class="窗口标题">探险家收购</div>
			<div class="收购内容">
				<div class="收购物品列表">
					<h4>探险家想收购的物品：</h4>
					<div id="收购需求列表" class="库存列表"></div>
				</div>
				<div class="玩家背包预览">
					<h4>你拥有的（点击出售）：</h4>
					<div id="玩家可售列表" class="库存列表"></div>
				</div>
			</div>
			<div class="交易底部">
				<div class="玩家金币">
					持有金币：<span id="收购窗口金币">0</span>
				</div>
				<button onclick="关闭收购窗口()" class="按钮">告辞</button>
			</div>
		</div>
		<div id="种子筛选器遮罩" class="重铸遮罩" style="display: none; z-index: 10007;">
			<div id="种子筛选器窗口" class="重铸弹窗">
				<div class="重铸弹窗-header">
					<h3>种子筛选器</h3>
					<button class="关闭按钮" id="关闭筛选器按钮">×</button>
				</div>
				<div class="重铸弹窗-items" style="display: flex; flex-direction: column; gap: 15px; padding: 15px;">
					<div class="设置项目">
						<label for="sifter-level-input">地牢层数</label>
						<input type="number" id="sifter-level-input" value="0" min="0">
					</div>
					<div class="设置项目">
						<label for="sifter-room-id-input">房间 ID</label>
						<input type="number" id="sifter-room-id-input" value="1" min="1">
					</div>
					<div class="设置项目">
						<label for="sifter-item-select">寻找物品</label>
						<select id="sifter-item-select"></select>
					</div>
					<p id="sifter-status" style="text-align: center; color: #aaa; min-height: 2em; margin-top: 10px;"></p>
				</div>
				<div class="交易底部" style="justify-content: center;">
					<button id="开始筛选按钮" class="菜单按钮" style="min-width: 150px;">开始筛选</button>
					<button id="取消筛选按钮" class="菜单按钮" style="min-width: 150px; display: none; background: #c62828;">取消</button>
				</div>
			</div>
		</div>
		<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
		<script>
			const canvas = document.getElementById("dungeonCanvas");
			const ctx = canvas.getContext("2d");
			let supabase = null;
			let 创意工坊已启用 = false;
			
			async function 初始化创意工坊() {
			    try {
			        if (!window.supabase) {
			            throw new Error("Supabase 客户端库未加载。");
			        }
			        const 创意关卡按钮 = document.getElementById("创意关卡按钮");
			        if (创意关卡按钮) {
			            创意关卡按钮.onclick = 显示创意关卡浏览器;
			        }
			        if (创意关卡文件输入) {
			    创意关卡文件输入.addEventListener("change", (事件) => {
			        const 选择的文件 = 事件.target.files[0];
			        if (!选择的文件) return;
			        const 文件阅读器 = new FileReader();
			        文件阅读器.onload = async (读取事件) => {
			            const 存档字符串 = 读取事件.target.result;
			            if(await 导入创意关卡(存档字符串)) {隐藏游戏模式选择()};
			        };
			        文件阅读器.readAsText(选择的文件);
			        事件.target.value = '';
			    });
			}
			        const supabaseUrl = 'https://xazugujttgmudrtfvwrg.supabase.co';
			        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhhenVndWp0dGdtdWRydGZ2d3JnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI2NzIyNjksImV4cCI6MjA2ODI0ODI2OX0.ycWl0bdX0heyFTm4BJCL-1YpSYZI9uIiDzYwE5rivi4';
			        supabase = window.supabase.createClient(supabaseUrl, supabaseKey); //固若金汤的数据库，坚不可摧的防火墙
			
			        // 验证连接和权限！！！
			        const { error } = await supabase.from('levels').select('id').limit(1);
			        if (error) {
			            throw new Error(`数据库连接测试失败: ${error.message}`);
			        }
			        
			        创意工坊已启用 = true;
			
			
			        document.getElementById('返回游戏模式选择按钮').addEventListener('click', 隐藏创意关卡浏览器);
			        document.getElementById('上传关卡按钮').addEventListener('click', 上传关卡处理函数);
			        document.getElementById('搜索关卡按钮').addEventListener('click', 刷新关卡列表);
			        document.getElementById('搜索关卡输入').addEventListener('keypress', function(e) {
			            if (e.key === 'Enter') {
			                刷新关卡列表();
			            }
			        });
			        document.getElementById('返回浏览器按钮').addEventListener('click', 隐藏关卡详情);
			    } catch (error) {
			        创意工坊已启用 = false;
			        console.warn("创意工坊初始化失败:", error.message);
			        显示通知("创意工坊功能不可用，已切换为本地模式。", "警告");
			        if (创意关卡按钮) {
			            创意关卡按钮.textContent = "加载本地创意关卡";
			            创意关卡按钮.onclick = () => {
			                
			                创意关卡文件输入.click();
			            };
			        }
			    }
			}
			
			// 常量 好吧有些已经变成变量了
			let 单元格大小 = 30;
			let 已初始化 = 2;
			let 画布宽度 = Math.min(
			    window.innerWidth - 20,
			    window.innerHeight - 20
			); // 动态宽度
			let 画布高度 = 画布宽度; // 动态高度
			const 房间尺寸范围 = [7, 10];
			const 最大房间数 = 15;
			let 相机显示边长 = 15;
			const 最大堆叠数 = 64;
			let 地牢大小 = 100;
			const 存档版本 = "v1";
			const 游戏版本 = 1527
			document.querySelector('.info-version-tag').innerHTML=`v${游戏版本}`;
			document.getElementById("版本信息").textContent = `v${游戏版本}`;
			const MAX_EMOJI_FETCH_RETRIES = 3;
			const 所有天气列表 = [
			    "雷暴",
			    "诡魅",
			    "大风",
			    "严寒",
			    "深夜",
			    "深夜",
			];
			const 大风吹动概率 = 0.3;
			let 互动冷却 = false;
			const 怪物移动动画时长 = 300;
			const 数据完整性密钥 = "f_SECRET_KEY_FOR_CHINESE_DUNGEON";
			
			const 调试序列 = ["上", "上", "下", "下", "左", "右", "左", "右"];
			// 单元格类型枚举
			let 当前层数 = 0;
			let 所有地牢层 = new Map(); // 保存各层地牢数据
			let 命令行模式开启 = false;
const 命令行图标映射 = {药水:"!",钢制长剑:"/",橡木法杖:"\\",吸血剑:"v",喷火枪:"F",冰霜法杖:"*",重力锤:"T",剧毒匕首:"~",卷轴:"?",钥匙:"k",金币:"$",锅盖:"O",回旋镖:")",闪电链法杖:"Z",大地猛击锤:"H",穿云箭:"-",荆棘鞭:"#",秘银锁甲:"A",真言卷轴:"R",钢制板甲:"A",金币手枪:"p",狙击金币枪:"P",下楼楼梯:">",上楼楼梯:"<",怪物:"M",炸弹怪物:"b",盔甲怪物:"H",炸弹:"b",罐子:"u",缓慢:"s",敏捷怪物:"f",远攻怪物:"a",仙人掌怪物:"c",大魔法师:"W",寻宝戒指:"o",装备按钮:"e",死亡图标:"X",错误:"x",成功:"v",冰冻怪物:"i",冰盾:"I",重铸台:"T",斜方刀:"d",神秘商人:"S",探险家:"E",祭坛:"^",宠物:"d",熊猫:"P",水母:"J",大史莱姆:"S",小史莱姆:"s",瞬移怪物:"@",伪装怪物:"U",腐蚀怪物:"C",盗贼怪物:"t",萨满怪物:"+",召唤师怪物:"Y",幽灵仆从:"g",吸能怪物:"e",剧毒云雾怪物:"G",旋风怪物:"&",米诺陶:"B",折跃门:"%",传送门:"D",魔法师法杖:"|",符文圈:"O",水晶:"d",能量草:"l",旋风:"&",旋风物品:"&",火焰:"f",引雷针护符:"!",种子:".",荆棘丛:"#",灵能盾牌:"[",恐惧魔杖:"?",恐惧怪物:"!",调试工具:"D",冲撞牛角:"U",护卫植物:"p",远射植物:"p",泉水:"w",书架:"B",渔网:"N",充能魔杖:"*",时间卷轴:"t",潜行靴子:"b",钩索:"j",嗜血战斧:"A",渔网陷阱:"N",磨刀石:"s",急救绷带:"+",照明弹:"L",照明弹光源:"L",挑战石碑:"T",神龛:"H",洗身砚:"C",毒气瓶:"P",万能钥匙:"K",陨石法杖:"*",毒气:"g",落石:"r",地刺:"^",失明:"b",召唤陷阱:"y",烈焰陷阱:"F",虫洞:"o",障碍物:"#",远射陷阱:"T",沙漏:"t",时间:"t",脚印:"'",爱心:"+",修补心:"-",旗帜:"F",门:"+",锁:"#",手形:"h",删除:"x",房间工具:"R",房间编辑:"E",地板:".",走廊:".",墙壁:"#",告示牌:"i",超速怪物:"F",复活怪物:"R",娃娃怪物:"c",吸血鬼:"V",存档点:"S",皇家守卫:"G",王座守护者:"K",墓碑:"T",移动弹幕:"*",奖杯:"*",饰品:"o",分裂怪物:"d",巨人怪物:"G",巨人部位:"g",红蓝开关:"s",红砖块:"#",蓝砖块:"#",追踪风弹:"@",刷怪笼:"S",传送带:">",巡逻怪物:"p",同步怪物:"s",绿砖块:"#",紫砖块:"#",绿紫开关:"s",开关脉冲器:"p",复制工具:"c",沉浸式传送门:"@",卷轴滚动墙:"|",嗅探之鼻:"n",永久抗火:"f",永久解冻:"i",永久力量:"s",永久抗毒:"p",神偷手:"h",小书魔:"b",扫帚:"b",战士:"W",法师:"M",忍者:"N",游侠:"R",死灵:"D",骑士:"K",磁铁:"m",蜘蛛怪物:"s",反弹怪物:"r",蛛网:"w",魔法师:"m",火蜥蜴:"l",烟雾弹:"s",烟雾:"s",蜈蚣怪物:"c",定位器地图:"M",死灵法杖:"y",骷髅仆从:"s",扳手:"u",HUD智能: "I",HUD常隐: "H",HUD常显: "S",互动按钮: "[互动]",背包按钮: "[背包]",隐形毒气陷阱: "P",守卫者盔甲:"h",能量熔炉:"E",};
			const 中文对照图标映射 = {
			    药水: "药",
			    隐形毒气陷阱: "蝳",
			    钢制长剑: "剑",
			    吸血剑: "吸",
			    橡木法杖: "法",
			    卷轴: "卷",
			    钥匙: "钥",
			    金币: "金",
			    喷火枪: "喷",
			    回旋镖: "回",
			    闪电链法杖: "链",
			    大地猛击锤: "震",
			    穿云箭: "穿",
			    荆棘鞭: "鞭",
			    能量草: "草",
			    秘银锁甲: "翈",
			    真言卷轴: "视",
			    钢制板甲: "甲",
			    金币手枪: "枪",
			    狙击金币枪: "狙",
			    下楼楼梯: "下",
			    上楼楼梯: "上",
			    怪物: "怪",
			    炸弹怪物: "爆",
			    炸弹: "炸",
			    罐子: "罐",
			    锅盖: "锅",
			    盔甲怪物: "魁",
			    敏捷怪物: "速",
			    远攻怪物: "远",
			    仙人掌怪物: "刺",
			    大魔法师: "师",
			    寻宝戒指: "戒",
			    装备按钮: "装",
			    死亡图标: "☠︎",
			    错误: "✘",
			    成功: "✔",
			    缓慢: "慢",
			    冰冻怪物: "㓕",
			    冰盾: "栤",
			    重铸台: "铸",
			    斜方刀: "斜",
			    神秘商人: "商",
			    探险家: "探",
			    祭坛: "坛",
			    互动按钮: "互",
			    背包按钮: "背",
			    卷轴按钮: "卷",
			    HUD常显: "显",
			    HUD智能: "䚐",
			    HUD常隐: "隐",
			    魔法师法杖: "法",
			    符文圈: "符",
			    水晶: "晶",
			    宠物: "宠",
			    熊猫: "態",
			    水母: "鲝",
			    冰霜法杖: "霜",
			    重力锤: "引",
			    剧毒匕首: "毒",
			    大史莱姆: "大",
			    小史莱姆: "小",
			    瞬移怪物: "瞬",
			    伪装怪物: "伪",
			    腐蚀怪物: "蚀",
			    盗贼怪物: "盗",
			    萨满怪物: "萨",
			    召唤师怪物: "召",
			    幽灵仆从: "仆",
			    吸能怪物: "吸",
			    剧毒云雾怪物: "雾",
			    旋风怪物: "旋",
			    旋风: "風",
			    旋风物品: "风",
			    米诺陶: "㸴",
			    折跃门: "门",
			    传送门: "门",
			    毒液: "毒",
			    眩晕: "晕",
			    火焰: "火",
			    引雷针护符: "引",
			    种子: "种",
			    荆棘丛: "荆",
			    灵能盾牌: "灵",
			    恐惧魔杖: "惧",
			    恐惧怪物: "恐",
			    调试工具: "调",
			    恐惧: "恐",
			    冲撞牛角: "角",
			    护卫植物: "卫",
			    远射植物: "远",
			    泉水: "泉",
			    书架: "书",
			    渔网: "网",
			    充能魔杖: "充",
			    时间卷轴: "时",
			    潜行靴子: "潜",
			    钩索: "钩",
			    嗜血战斧: "斧",
			    渔网陷阱: "网",
			    磨刀石: "磨",
			    急救绷带: "绷",
			    照明弹: "照",
			    照明弹光源: "光",
			    挑战石碑: "碑",
			    神龛: "龛",
			    洗身砚: "砚",
			    毒气瓶: "瓶",
			    万能钥匙: "万",
			    陨石法杖: "星",
			    毒气: "毒",
			    落石: "石",
			    地刺: "刺",
			    失明: "盲",
			    召唤陷阱: "召",
			    烈焰陷阱: "焰",
			    虫洞: "洞",
			    障碍物: "障",
			    远射陷阱: "塔",
			    沙漏: "时",
			    时间:"时",
			    脚印:"迹",
			    爱心: "伤",
			    修补心: "心",
			    旗帜: "旗",
			    门: "门",
			    锁: "锁",
			    手形: "改",
			    删除: "删",
			    房间工具: "创",
			    房间编辑: "修",
			    地板: "房",
			    走廊: "廊",
			    墙壁: "墙",
			    告示牌: "牌",
			    超速怪物: "超",
			    复活怪物: "复",
			    娃娃怪物: "娃",
			    吸血鬼: "血",
			    存档点: "存",
			    皇家守卫:"卫",
			    王座守护者:"王",
			    墓碑:"墓",
			    移动弹幕:"弹",
			    奖杯:"奖",
			    陷阱先锋: '探',
			    飞毛腿: '腿',
			    瞬间移动: '瞬',
			    博士之卷: '博',
			    恢复之心: '愈',
			    以牙还牙: '牙',
			    饰品: '饰',
			    分裂怪物: "裂",
			    巨人怪物: "巨",
			    巨人部位: "巨",
			    红蓝开关:"控",
			    红砖块:"█",
			    蓝砖块:"▓",
			    追踪风弹:"颩",
			    刷怪笼: "笼",
			    传送带: "传",
			    巡逻怪物: "巡",
			    同步怪物: "同",
			    绿砖块: "▓",
			    紫砖块: "▒",
			    绿紫开关: "切",
			    开关脉冲器: "脉",
			    复制工具:'拷',
			    沉浸式传送门:'传',
			    卷轴滚动墙: '停',
			    嗅探之鼻:'鼻',
			    永久抗火:'火',
			    永久解冻:'冻',
			    永久力量:'力',
			    永久抗毒:'毒',
			    神偷手: '偷',
			    小书魔:'书',
			    扫帚: '帚',
			    战士: '战',
			    法师: '法',
			    忍者: '忍',
			    游侠:'侠',
			    死灵:'灵',
			    骑士:'骑',
			    磁铁: "磁",
			    蜘蛛怪物: "蛛",
			    反弹怪物: "反",
			    蛛网: "网",
			    魔法师: "麽",
            火蜥蜴: "蜥",
            烟雾弹: "烟",
            烟雾: "雾",
            蜈蚣怪物:"虫",
            定位器地图:"图",
            死灵法杖: "杖",
            骷髅仆从: "骸",
            扳手: "扳",
            守卫者盔甲:"守",
            能量熔炉:"炉",
			};
			let 图标映射 = {
			    药水: "🧪",
			    钢制长剑: "🗡️",
			    橡木法杖: "🪄",
			    吸血剑: "🗡️",
			    喷火枪: "💥",
			    冰霜法杖: "🪄",
			    重力锤: "🔨",
			    剧毒匕首: "🐍",
			    卷轴: "📜",
			    钥匙: "🔑",
			    金币: "🪙",
			    锅盖: "🫕",
			    回旋镖: "🪃",
			    闪电链法杖: "🌩️",
			    大地猛击锤: "🔨",
			    穿云箭: "🏹",
			    荆棘鞭: "⛓️",
			    秘银锁甲: "🥼",
			    真言卷轴: "📖",
			    钢制板甲: "🥋",
			    金币手枪: "🔫",
			    狙击金币枪: "🔫",
			    下楼楼梯: "⬇️",
			    上楼楼梯: "⬆️",
			    怪物: "👾",
			    炸弹怪物: "💣",
			    盔甲怪物: "💂",
			    炸弹: "💣",
			    罐子: "🏺",
			    缓慢: "🐌",
			    敏捷怪物: "🏃",
			    远攻怪物: "👼",
			    仙人掌怪物: "🌵",
			    大魔法师: "🧙",
			    寻宝戒指: "💍",
			    装备按钮: "🛡",
			    死亡图标: "💀",
			    错误: "❌",
			    成功: "✅",
			    冰冻怪物: "🧊",
			    冰盾: "❄",
			    重铸台: "⚒️",
			    斜方刀: "💠",
			    神秘商人: "🧙",
			    探险家: "👨‍🌾",
			    祭坛: "🛐",
			    互动按钮: "⚡",
			    背包按钮: "🎒",
			    卷轴按钮: "📜",
			    HUD常显: "👀",
			    HUD智能: "👁️",
			    HUD常隐: "😑",
			    宠物: "🐾",
			    熊猫: "🐼",
			    水母: "🪼",
			    大史莱姆: "🦠",
			    小史莱姆: "🦠",
			    瞬移怪物: "💫",
			    伪装怪物: "👿",
			    腐蚀怪物: "👹",
			    盗贼怪物: "🥷",
			    萨满怪物: "⚕️",
			    召唤师怪物: "🧿",
			    幽灵仆从: "👻",
			    吸能怪物: "😈",
			    剧毒云雾怪物: "☁️",
			    旋风怪物: "🌪️",
			    米诺陶: "🐂",
			    折跃门: "🍥",
			    传送门: "🚪",
			    魔法师法杖: "🔱",
			    符文圈: "⭕",
			    水晶: "💎",
			    毒液: "☢️",
			    能量草: "🌿",
			    旋风: "🌀",
			    旋风物品: "🍃",
			    眩晕: "💫",
			    火焰: "🔥",
			    引雷针护符: "🗼",
			    种子: "🌱",
			    荆棘丛: "🌵",
			    灵能盾牌: "🛡️",
			    恐惧魔杖: "🔮",
			    恐惧怪物: "😨",
			    调试工具: "🛠️",
			    恐惧: "😨",
			    冲撞牛角: "🐂",
			    护卫植物: "🛡️",
			    远射植物: "🎯",
			    泉水: "💧",
			    书架: "📚",
			    渔网: "🕸️",
			    充能魔杖: "🔋",
			    时间卷轴: "⏳",
			    潜行靴子: "👟",
			    钩索: "🪝",
			    嗜血战斧: "🪓",
			    渔网陷阱: "🕸️",
			    磨刀石: "✨",
			    急救绷带: "🩹",
			    照明弹: "🚨",
			    照明弹光源: "💡",
			    挑战石碑: "🏛️",
			    神龛: "⛩️",
			    洗身砚: "🧼",
			    毒气瓶: "⚗️",
			    万能钥匙: "🗝️",
			    陨石法杖: "☄️",
			    毒气: "☣️",
			    落石: "🪨",
			    地刺: "뾰",
			    失明: "🕶️",
			    召唤陷阱: "🧿",
			    烈焰陷阱: "♨️",
			    虫洞: "🌀",
			    障碍物: "🧱",
			    远射陷阱: "🗼",
			    沙漏: "⏳",
			    时间: "⏳",
			    脚印:"👣",
			    爱心: "♥️",
			    修补心: "💔",
			    旗帜: "🚩",
			    门: "🚪",
			    锁: "🔒",
			    手形: "✋",
			    删除: "🗑️",
			    房间工具: "📏",
			    房间编辑: "🏠",
			    地板: "🟩",
			    走廊: "🟫",
			    墙壁: "⬛",
			    告示牌: "🪧",
			    超速怪物: "💨",
			    复活怪物: "🧙🏿‍♂️",
			    娃娃怪物: "👶",
			    吸血鬼: "🧛‍♂️",
			    存档点:"💾",
			    皇家守卫:"💂🏿‍♂️",
			    王座守护者:"⚜️",
			    墓碑:"🪦",
			    移动弹幕:"💀",
			    奖杯:"🏆",
			    陷阱先锋: '🧿',
			    飞毛腿: '👟',
			    瞬间移动: '💫',
			    博士之卷: '🎓',
			    恢复之心: '❤️‍🩹',
			    以牙还牙: '💥',
			    饰品: '💍',
			    分裂怪物: "➗",
			    巨人怪物: "🗿",
			    巨人部位: "🗿",
			    红蓝开关:"🔘",
			    红砖块:"🟥",
			    蓝砖块:"🟦",
			    追踪风弹:"💨",
			    刷怪笼: "⚙️",
			    传送带: "➡️",
			    巡逻怪物: "🚶",
			    同步怪物: "🎯",
			    绿砖块: "🟩",
			    紫砖块: "🟪",
			    绿紫开关: "🟢",
			    开关脉冲器: "📡",
			    复制工具:'📋',
			    沉浸式传送门:"🌀",
			    卷轴滚动墙: '🚫',
			    嗅探之鼻:'👃🏻',
			    永久抗火:'🔥',
			    永久解冻:'🥶',
			    永久力量:'💪🏻',
			    永久抗毒:'🧪',
			    神偷手: '🤏',
			    小书魔:'📖',
			    扫帚: '🧹',
			    战士: '💂‍♀️',
			    法师: '🧙',
			    忍者: '🥷',
			    游侠:'🏹',
			    死灵:'💀',
			    骑士:'🏇',
			    磁铁: "🧲",
			    蜘蛛怪物: "🕷️",
			    反弹怪物: "🪞",
			    蛛网: "🕸️",
			    魔法师: "🧙",
            火蜥蜴: "🦎",
            烟雾弹: "🌫️",
            烟雾: "🌫️",
            蜈蚣怪物:"🐲",
            定位器地图:"🗺️",
            死灵法杖: "🪄",
            骷髅仆从: "💀",
            扳手: "🔧",
            隐形毒气陷阱: "☠️",
            守卫者盔甲:"🛡️",
            能量熔炉:"⚙️",
			};
			// 单元格类型枚举
			const 单元格类型 = {
			    墙壁: 0,
			    房间: 1,
			    走廊: 2,
			    门: 3,
			    上锁的门: 4,
			    物品: 5,
			    楼梯下楼: 6,
			    楼梯上楼: 7,
			    怪物: 8,
			};
			const 怪物状态 = {
			    休眠: 0,
			    活跃: 1,
			    攻击: 2,
			};
			const 颜色表 = [
			    "#00FF00", // 绿色
			    "#0000FF", // 蓝色
			    "#FFFF00", // 黄色
			    "#FF00FF", // 品红
			    "#FF0000", // 红色
			    "#800080", //紫色
			];
			const 效果颜色编号映射 = [
			    "#ff0000",
			    "#00ff00",
			    "#2196F3",
			    "#FF9800",
			    "#808080",
			    "#9C27B0",
			    "#008000",
			    "#888888",
			    "#8FBC8F",
			    "#FFEB3B",
			    "#CC5500",
			    "#FFD700",
			    "#8A2BE2",
			    "#A0522D",
			];
			const 效果名称编号映射 = {
			    治疗: 0,
			    能量: 1,
			    神龟: 2,
			    狂暴: 3,
			    隐身: 4,
			    透视: 5,
			    中毒: 6,
			    缓慢: 7,
			    腐蚀: 8,
			    眩晕: 9,
			    火焰: 10,
			    充能: 11,
			    恐惧: 12,
			    牵制: 13,
			};
			const 颜色名表 = ["绿", "蓝", "黄", "品红", "红", "紫"];
			let 楼梯图标 = { 下楼: 图标映射.下楼楼梯, 上楼: 图标映射.上楼楼梯 };
			const 功能键映射 = {
			    1: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 1),
			    2: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 2),
			    3: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 3),
			    4: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 4),
			    5: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 5),
			    6: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 6),
			    7: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 7),
			    q: () => 处理HUD切换按钮点击(),
			    e: () => {
			        界面可见性.背包 = !界面可见性.背包;
			        切换背包显示();
			    },
			    g: 切换日志显示,
			    f: 尝试互动,
			    z: 导出存档,
			    t: 打开传送菜单,
			    j: () => {
			        切换装备页(-1);
			    },
			    k: () => {
			        切换装备页(1);
			    },
			    u: 玩家死亡,
			    r: 重置创意关卡,
			    c: 打开配方书,
			};
			const 物品生成配置 = {
			    基础概率: {
			        普通房间: 0.4,
			        上锁房间: 0.7,
			    },
			    品质权重: {
			        1: [60, 0], // 品质: [基础刷新概率,随层数增长的附加刷新概率]
			        2: [25, 20],
			        3: [10, 30],
			        4: [5, 40],
			        5: [0, 10],
			    },
			    类型分布: {
			        普通房间: [
			            { 类型: "武器", 权重: 40 },
			            { 类型: "防具", 权重: 30 },
			            { 类型: "药水", 权重: 20 },
			            { 类型: "卷轴", 权重: 10 },
			            { 类型: "工具", 权重: 25 },
			            { 类型: "宠物", 权重: 10 },
			            { 类型: "饰品", 权重: 8 },
			        ],
			        上锁房间: [
			            { 类型: "卷轴", 权重: 30 },
			            { 类型: "武器", 权重: 30 },
			            { 类型: "药水", 权重: 25 },
			            { 类型: "防具", 权重: 15 },
			            { 类型: "工具", 权重: 25 },
			            { 类型: "宠物", 权重: 10 },
			            { 类型: "饰品", 权重: 10 },
			        ],
			    },
			};
			
			const 创建物品池 = () => ({
			    武器: [
			        { 类: 荆棘种子, 品质: 1, 最小层: 1 },
			        { 类: 护卫种子, 品质: 2, 最小层: 1 },
			        { 类: 远射种子, 品质: 3, 最小层: 2 },
			        { 类: 吸能种子, 品质: 2, 最小层: 1 },
			        { 类: 橡木法杖, 品质: 2, 最小层: 3 },
			        { 类: 钢制长剑, 品质: 1, 最小层: 0 },
			        { 类: 吸血剑, 品质: 1, 最小层: 0 },
			        { 类: 喷火枪, 品质: 1, 最小层: 0 },
			        { 类: 炸弹, 品质: 2, 最小层: 1 },
			        { 类: 金币手枪, 品质: 3, 最小层: 2 },
			        { 类: 回旋镖, 品质: 2, 最小层: 1 },
			        { 类: 闪电链法杖, 品质: 3, 最小层: 3 },
			        { 类: 大地猛击锤, 品质: 3, 最小层: 3 },
			        { 类: 穿云箭, 品质: 2, 最小层: 2 },
			        { 类: 荆棘鞭, 品质: 1, 最小层: 1 },
			        { 类: 冰霜法杖, 品质: 3, 最小层: 2 },
			        { 类: 重力锤, 品质: 4, 最小层: 5 },
			        { 类: 剧毒匕首, 品质: 1, 最小层: 1 },
			        { 类: 神秘商人, 品质: 1, 最小层: 1 }, // 奸商武力值要高，所以在武器类（确信）
			        { 类: 恐惧魔杖, 品质: 3, 最小层: 4 },
			        { 类: 斜方刀, 品质: 2, 最小层: 1 },
			        { 类: 充能魔杖, 品质: 4, 最小层: 6 },
			        { 类: 嗜血战斧, 品质: 4, 最小层: 4 },
			        { 类: 陨石法杖, 品质: 4, 最小层: 6 },
			        { 类: 狙击金币枪, 品质: 2, 最小层: 4 },
			        { 类: 追踪风弹, 品质: 3, 最小层: 4 },
			        { 类: 死灵法杖, 品质: 2, 最小层: 7 },
			        { 类: 扫帚, 品质: 2, 最小层: 2 },
			    ],
			    工具: [
			        { 类: 能量熔炉, 品质: 3, 最小层: 4 },
			        { 类: 物品祭坛, 品质: 1, 最小层: 0 },
			        { 类: 耐久祭坛, 品质: 2, 最小层: 0 },
			        { 类: 背包扩容祭坛, 品质: 2, 最小层: 0 },
			        { 类: 重铸台, 品质: 3, 最小层: 2 },
			        { 类: 探险家, 品质: 1, 最小层: 1 },
			        { 类: 火把, 品质: 1, 最小层: 2 },
			        { 类: 罐子, 品质: 1, 最小层: 0 },
			        { 类: 渔网, 品质: 2, 最小层: 1 },
			        { 类: 钩索, 品质: 3, 最小层: 2 },
			        { 类: 急救绷带, 品质: 2, 最小层: 1 },
			        { 类: 磨刀石, 品质: 3, 最小层: 2},
			        { 类: 照明弹, 品质: 2, 最小层: 2},
			        { 类: 挑战石碑, 品质: 4, 最小层: 3},
			        { 类: 神龛, 品质: 5, 最小层: 2},
			        { 类: 洗身砚, 品质: 4, 最小层: 3 },
			        { 类: 毒气瓶, 品质: 2, 最小层: 2 },
			        { 类: 万能钥匙, 品质: 3, 最小层: 3 },
			        { 类: 便携障碍物, 品质: 1, 最小层: 0 },
			        { 类: 时空罗盘, 品质: 5, 最小层: 8 },
			        { 类: 神偷手, 品质: 4, 最小层: 2 },
			        { 类: 磁铁, 品质: 3, 最小层: 2 },
			        { 类: 烟雾弹, 品质: 3, 最小层: 3 },
			        { 类: 定位器地图, 品质: 1, 最小层: 0 },
			    ],
			    防具: [
			        { 类: 引雷针护符, 品质: 3, 最小层: 2 },
			        { 类: 钢制板甲, 品质: 2, 最小层: 0 },
			        { 类: 锅盖, 品质: 2, 最小层: 0 },
			        { 类: 秘银锁甲, 品质: 4, 最小层: 2 },
			        { 类: 冰盾, 品质: 1, 最小层: 1 },
			        { 类: 潜行靴子, 品质: 2, 最小层: 4 },
			        { 类: 守卫者盔甲, 品质: 4, 最小层: 5 },
			    ],
			    药水: [
			        { 类: 治疗药水, 品质: 2, 最小层: 0 },
			        { 类: 狂暴药水, 品质: 2, 最小层: 0 },
			        { 类: 神龟药水, 品质: 3, 最小层: 1 },
			        { 类: 能量药水, 品质: 4, 最小层: 1 },
			        { 类: 隐身药水, 品质: 3, 最小层: 2 },
			        { 类: 透视药水, 品质: 3, 最小层: 1 },
			    ],
			    卷轴: [
			        { 类: 迅捷卷轴, 品质: 2, 最小层: 0 },
			        { 类: 清净卷轴, 品质: 2, 最小层: 0 },
			        { 类: 跃迁卷轴, 品质: 3, 最小层: 2 },
			        { 类: 真言卷轴, 品质: 4, 最小层: 4 },
			        { 类: 湮灭卷轴, 品质: 1, 最小层: 0 },
			        { 类: 贪婪卷轴, 品质: 3, 最小层: 3 },
			        { 类: 神秘卷轴, 品质: 1, 最小层: 0 },
			        { 类: 附魔卷轴, 品质: 1, 最小层: 1 },
			        { 类: 时间卷轴, 品质: 4, 最小层: 5 },
			        { 类: 易位卷轴, 品质: 4, 最小层: 4 },
			    ],
			    宠物: [
			        { 类: 熊猫, 品质: 3, 最小层: 2 },
			        { 类: 水母, 品质: 4, 最小层: 2 },
			        { 类: 火蜥蜴, 品质: 4, 最小层: 4 },
			    ],
			    饰品: [
			        { 类: 陷阱先锋饰品, 品质: 3, 最小层: 3 },
			        { 类: 飞毛腿饰品, 品质: 2, 最小层: 2 },
			        { 类: 瞬间移动饰品, 品质: 4, 最小层: 5 },
			        { 类: 博士之卷饰品, 品质: 3, 最小层: 2 },
			        { 类: 恢复之心饰品, 品质: 2, 最小层: 2 },
			        { 类: 以牙还牙饰品, 品质: 4, 最小层: 4 },
			        { 类: 嗅探之鼻饰品, 品质: 3, 最小层: 2 },
			    ],
			});
			
			const 创建怪物池 = () => ({
			    普通房间: [
			        { 类: 怪物, 权重: 45, 最小层: 0 },
			        { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
			        { 类: 敏捷怪物, 权重: 15, 最小层: 2 },
			        { 类: 远攻怪物, 权重: 25, 最小层: 1 },
			        { 类: 炸弹怪物, 权重: 15, 最小层: 3 },
			        { 类: 冰冻怪物, 权重: 15, 最小层: 2 },
			        { 类: 仙人掌怪物, 权重: 25, 最小层: 1 },
			        { 类: 大史莱姆怪物, 权重: 15, 最小层: 2 },
			        { 类: 瞬移怪物, 权重: 10, 最小层: 3 },
			        { 类: 伪装怪物, 权重: 8, 最小层: 1 },
			        { 类: 腐蚀怪物, 权重: 12, 最小层: 2 },
			        { 类: 盗贼怪物, 权重: 10, 最小层: 4 },
			        { 类: 萨满怪物, 权重: 7, 最小层: 3 },
			        { 类: 召唤师怪物, 权重: 7, 最小层: 4 },
			        { 类: 吸能怪物, 权重: 11, 最小层: 1 },
			        { 类: 剧毒云雾怪物, 权重: 9, 最小层: 2 },
			        { 类: 旋风怪物, 权重: 10, 最小层: 4 },
			        { 类: 恐惧怪物, 权重: 10, 最小层: 3 },
			        { 类: 超速怪物, 权重: 12, 最小层: 4 },
			        { 类: 复活怪物, 权重: 14, 最小层: 5 },
			        { 类: 吸血鬼, 权重: 8, 最小层: 0 },
			        { 类: 分裂怪物, 权重: 10, 最小层: 6 },
			        { 类: 巨人怪物, 权重: 12, 最小层: 7 },
			        { 类: 巡逻怪物, 权重: 5, 最小层: 7 },
			        { 类: 反弹怪物, 权重: 20, 最小层: 2 },
			        { 类: 蜘蛛怪物, 权重: 25, 最小层: 1 },
			        { 类: 魔法师, 权重: 8, 最小层: 6 },
			        { 类: 蜈蚣怪物, 权重: 12, 最小层: 5 },
			    ],
			    上锁房间: [
			        { 类: 炸弹怪物, 权重: 35, 最小层: 1 },
			        { 类: 远攻怪物, 权重: 30, 最小层: 3 },
			        { 类: 敏捷怪物, 权重: 35, 最小层: 2 },
			        { 类: 冰冻怪物, 权重: 15, 最小层: 0 },
			        { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
			        { 类: 仙人掌怪物, 权重: 30, 最小层: 1 },
			        { 类: 大史莱姆怪物, 权重: 20, 最小层: 2 },
			        { 类: 瞬移怪物, 权重: 15, 最小层: 3 },
			        { 类: 伪装怪物, 权重: 12, 最小层: 1 },
			        { 类: 腐蚀怪物, 权重: 18, 最小层: 2 },
			        { 类: 盗贼怪物, 权重: 18, 最小层: 1 },
			        { 类: 萨满怪物, 权重: 5, 最小层: 3 },
			        { 类: 召唤师怪物, 权重: 4, 最小层: 4 },
			        { 类: 吸能怪物, 权重: 9, 最小层: 1 },
			        { 类: 剧毒云雾怪物, 权重: 7, 最小层: 2 },
			        { 类: 旋风怪物, 权重: 12, 最小层: 3 },
			        { 类: 恐惧怪物, 权重: 15, 最小层: 3 },
			        { 类: 超速怪物, 权重: 15, 最小层: 4 },
			        { 类: 复活怪物, 权重: 10, 最小层: 2 },
			        { 类: 吸血鬼, 权重: 8, 最小层: 0 },
			        { 类: 分裂怪物, 权重: 15, 最小层: 6 },
			        { 类: 巨人怪物, 权重: 15, 最小层: 7 },
			        { 类: 巡逻怪物, 权重: 5, 最小层: 7 },
			        { 类: 反弹怪物, 权重: 25, 最小层: 2 },
			        { 类: 蜘蛛怪物, 权重: 25, 最小层: 1 },
			        { 类: 蜈蚣怪物, 权重: 15, 最小层: 5 },
			    ],
			});
			const 融合Buff类型 = {
			    攻击加成: "ATTACK_BONUS",
			    攻击倍率: "ATTACK_MULTIPLIER",
			    冷却缩减: "COOLDOWN_REDUCTION",
			    冷却倍率: "COOLDOWN_MULTIPLIER",
			    耐久加成: "DURABILITY_BONUS",
			    耐久倍率: "DURABILITY_MULTIPLIER",
			    范围加成: "RANGE_BONUS",
			    中毒几率: "POISON_CHANCE",
			    火焰伤害: "FIRE_DAMAGE_CHANCE",
			    冰冻几率: "ICE_CHANCE",
			    生命偷取: "LIFE_STEAL",
			    防御加成: "DEFENSE_BONUS",
			    防御倍率: "DEFENSE_MULTIPLIER",
			    暴击几率: "CRITICAL_CHANCE",
			    暴击伤害倍率: "CRITICAL_DAMAGE_MULTIPLIER",
			    击退几率: "KNOCKBACK_CHANCE",
			    攻击吸能: "ENERGY_STEAL_ON_HIT",
			    闪避几率: "DODGE_CHANCE",
			    固定伤害减免: "FLAT_DAMAGE_REDUCTION",
			    受击回能: "ENERGY_ON_DAMAGE_TAKEN",
			    幸运一击: "LUCKY_STRIKE",
			    协同效应: "SYNERGY_EFFECT",
			    磨刀石攻击加成: "SHARPEN_ATTACK_BONUS",
			    磨刀石冷却缩减: "SHARPEN_COOLDOWN_REDUCTION",
			};
			            const 神龛效果列表 = [
			    {
			        id: '祝福_最大生命值',
			        名称: '生命祝福',
			        描述: '你的体魄变得更加强健，最大生命值永久提升了25点。',
			        类型: '祝福',
			        apply: () => {
			            永久Buffs.最大生命值加成 = (永久Buffs.最大生命值加成 || 0) + 25;
			            应用永久Buffs();
			        },
			        deapply: () => {
			            永久Buffs.最大生命值加成 = -永久Buffs.最大生命值加成;
			        }
			    },
			    {
			        id: '祝福_挖掘墙壁',
			        名称: '开山之力',
			        描述: '你获得了开山之力，现在可以挖掘墙壁了！',
			        类型: '祝福',
			        apply: () => {
			            永久Buffs.能挖掘墙壁 = true;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '祝福_永久攻击',
			        名称: '战神之赐',
			        描述: '武运昌隆！你的基础攻击力永久提升了2点。',
			        类型: '祝福',
			        apply: () => {
			            永久Buffs.攻击加成 = (永久Buffs.攻击加成 || 0) + 2;
			            应用永久Buffs();
			        }
			    },
			     {
			        id: '祝福_初始能量',
			        名称: '启迪之心',
			        描述: '你的心智变得更加敏锐，每层开始时都会获得额外的初始能量。',
			        类型: '祝福',
			        apply: () => {
			            永久Buffs.初始能量加成 = (永久Buffs.初始能量加成 || 0) + 20;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '祝福_装备耐久',
			        名称: '工匠之魂',
			        描述: '你的装备似乎变得更加坚固，所有装备的耐久度消耗降低25%。',
			        类型: '祝福',
			        apply: () => {
			            const i=永久Buffs.耐久消耗减免 || 0;
			            永久Buffs.耐久消耗减免 = i+(Math.pow(1-i,2))/4
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_随机掉落',
			        名称: '失物之咒',
			        描述: '你的口袋似乎有个破洞，移动时偶尔会随机掉落背包中的物品！',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.随机掉落 = true;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_挑战增加',
			        名称: '好战之血',
			        描述: '你变得更好战了，所有挑战房间的波数都将永久增加2波。',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.挑战波数增加 = (永久Buffs.挑战波数增加 || 0) + 2;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_怪物反伤',
			        名称: '荆棘诅咒',
			        描述: '你的攻击似乎会激怒地牢的意志，所有怪物现在都会反弹少量伤害给你。',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.怪物反伤 = true;
			            应用永久Buffs();
			        }
			    },
			     {
			        id: '诅咒_能量流失',
			        名称: '遗忘之咒',
			        描述: '你的精神不再集中，每回合都会缓慢流失少量能量。',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.能量流失 = (永久Buffs.能量流失 || 0) + 0.2;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_商店涨价',
			        名称: '奸商之友',
			        描述: '神秘商人们似乎达成了共识，他们所有商品的价格都上涨了。',
			        类型: '诅咒',
			        apply: () => {
			            永久Buffs.商店价格倍率 = (永久Buffs.商店价格倍率 || 0.2) * 1.5;
			            应用永久Buffs();
			        }
			    },
			    {
			        id: '诅咒_耐久减半',
			        名称: '腐朽之触',
			        描述: '一股腐朽的力量侵蚀了你的装备，所有装备的耐久度立即减半！',
			        类型: '诅咒',
			        apply: () => {
			            [...玩家背包.values(), ...玩家装备.values()].forEach(item => {
			                if (item && item.自定义数据 && item.自定义数据.has('耐久') && !item.自定义数据.get('不可破坏')) {
			                    const 当前耐久 = item.自定义数据.get('耐久');
			                    item.自定义数据.set('耐久', Math.ceil(当前耐久 / 2));
			                }
			            });
			            更新装备显示();
			            更新背包显示();
			        }
			    }
			];
			
			
			// 全局变量
			let 地牢 = [];
			let 房间列表 = [];
			let 临时测试 = false;
			let 玩家距离图 = [];
			let isSifting = false;
			let 当前天气效果 = [];
			let 编辑器剪贴板 = null;
			let 是否是自定义关卡 = false
			let 上次放置的传送带 = null;
			let 上次放置的开关脉冲器 = null;
			let 上次放置的隐形毒气陷阱 = null;
			let 绿紫开关状态 = '绿';
			let 跳过怪物回合剩余次数 = 0;
			let 当前关卡存档数据字符串 = null;
			let 玩家装备 = new Map(); // 以装备槽位为索引，目前有 4 个槽位，索引从 1 开始
			let 玩家 = { x: 0, y: 0 };
			const 材料 = {
			    木质: "木质",
			    铁质: "铁质",
			    玻璃: "玻璃",
			    铜质: "铜质",
			    金质: "金质",
			    普通: "普通",
			};
			let 玩家死亡次数 = 0;
			let 红蓝开关状态 = '红';
			let 小地图Ctx;
			const 小地图缩放 = 3;
			const 小地图Offset = 10;
			let 视口偏移X = 0,
			    视口偏移Y = 0;
			let 跟踪玩家怪物数 = 0;
			let 房间地图 = Array(地牢大小)
			    .fill()
			    .map(() => Array(地牢大小).fill(-1)); // 记录每个单元格所属房间ID
			let 上锁房间列表 = []; // 存储被锁定房间对象
			let 已访问房间 = new Set(); // 记录已访问过的房间
			let 显示HUD计时器 = null;
			let 玩家正在传送 = false;
			let 所有传送门 = [];
			let hud模式 = "默认";
			let 背包可见 = false;
			let 玩家背包 = new Map(); // 以物品唯一标识为索引
			let 最大背包容量 = 12;
			let 门实例列表 = new Map();
			const 通知队列 = [];
			let 移动历史 = [];
			let 传送点列表 = []; // 存储传送点 { id: string, 名称: string, 层数: number, x: number, y: number } 其实这里也可以xss
			const 最大传送点数量 = 5; // 限制最大保存数量
			let 上次移动 = 0;
			let 移动状态 = {
			    up: false,
			    down: false,
			    left: false,
			    right: false,
			};
			let hud显示 = false;
			let 界面可见性 = {
			    hud: false,
			    背包: false,
			};
			let 游戏设置 = {
			 热键绑定: {
			     '等待': ' ',
			     '装备槽1': '1', '装备槽2': '2', '装备槽3': '3', '装备槽4': '4',
			     '装备槽5': '5', '装备槽6': '6', '装备槽7': '7', '切换HUD': 'q',
			     '背包': 'e', '日志': 'g', '互动': 'f', '导出存档': 'z',
			     '传送菜单': 't', '装备页上一页': 'j', '装备页下一页': 'k', '自杀': 'u',
			     '重置关卡': 'r', '配方书': 'c',
                 '编辑器游玩': 'h',
                 '编辑器删除工具': 'b',
                 '编辑器撤销': 'z',
                 '编辑器重做': 'y',
                 '编辑器确认': 'Enter'
			 },
			 热键绑定描述: {
			     '等待': '等待/休息',
			     '装备槽1': '使用装备1', '装备槽2': '使用装备2', '装备槽3': '使用装备3', '装备槽4': '使用装备4',
			     '装备槽5': '使用装备5', '装备槽6': '使用装备6', '装备槽7': '使用装备7', '切换HUD': '切换HUD',
			     '背包': '打开/关闭背包', '日志': '打开/关闭日志', '互动': '互动/攻击', '导出存档': '导出存档',
			     '传送菜单': '传送菜单', '装备页上一页': '装备页(上)', '装备页下一页': '装备页(下)', '自杀': '自杀',
			     '重置关卡': '重置关卡', '配方书': '打开配方书',
                 '编辑器游玩': '开始游玩',
                 '编辑器删除工具': '选择删除工具',
                 '编辑器撤销': '撤销 (Ctrl/Cmd)',
                 '编辑器重做': '重做 (Ctrl/Cmd+Shift)',
                 '编辑器确认': '确认/应用'
			 },
			 方向键大小: 13,
			 显示方向键: true,
			 禁用点击移动: false,
			 手机模式: false,
			 动画模式: false,
			 emoji风格: "microsoft-3D-fluent",
			 emojiCDN是否可用: true,
			 命令行模式: false,
			 文本模式: false,
			 相机视野大小: 15,
			 移动速度: 100,
			 小地图大小: 150,
			 受伤时击退: false,
			};
			
			const 热键绑定描述 = {
			 '等待': '等待/休息',
			 '装备槽1': '使用装备1', '装备槽2': '使用装备2', '装备槽3': '使用装备3', '装备槽4': '使用装备4',
			 '装备槽5': '使用装备5', '装备槽6': '使用装备6', '装备槽7': '使用装备7', '切换HUD': '切换HUD',
			 '背包': '打开/关闭背包', '日志': '打开/关闭日志', '互动': '互动/攻击', '导出存档': '导出存档',
			 '传送菜单': '传送菜单', '装备页上一页': '装备页(上)', '装备页下一页': '装备页(下)', '自杀': '自杀',
			 '重置关卡': '重置关卡', '配方书': '打开配方书',
             '编辑器游玩': '开始游玩',
             '编辑器删除工具': '选择删除工具',
             '编辑器撤销': '撤销 (Ctrl/Cmd)',
             '编辑器重做': '重做 (Ctrl/Cmd+Shift)',
             '编辑器确认': '确认/应用'
			};
			let 玩家正在休息 = false;
			let 休息定时器 = null;
			let 等待触摸定时器 = null;
			let 所有怪物 = [];
			let 玩家动画状态 = { 正在动画: false };
			let 当前出战宠物列表 = [];
			let 当前加载的关卡数据缓存 = null;
			let 当前关卡ID = null;
			let prng = Math.random;
			let 当前游戏种子 = null;
			let 玩家职业 = null;
			const 怪物生成概率 = 0.7;
			const 最大怪物数 = 5; //一个房间内的怪物生成上限
			let 玩家初始位置 = { x: 0, y: 0 };
			let 死亡界面已显示 = false;
			let 单击移动定时器 = null;
			let 开始移动定时器 = null;
			let 长按移动 = false;
			let 当前激活卷轴列表 = new Set();
			let 移动间隔 = 100; // 长按连续移动间隔
			let 首次移动延迟 = 250; // 首次移动后的延迟
			let 最后移动时间 = 0;
			let 移动定时器 = null;
			let 教程阶段 = 0;
			let 教程提示已显示 = false;
			let 是否为教程层 = false;
			let 扳手规则列表 = [];
			let 玩家属性 = {
			    移动步数: 1,
			    攻击加成: 0,
			    防御加成: 0,
			    掉落倍率: 1,
			    透视: false,
			    允许移动: 0,
			    能挖掘墙壁: false,
			    最大生命值加成: 0,
			    怪物反伤: false,
			    挑战波数增加: 0,
			    随机掉落: false,
			    初始能量加成: 0,
			    耐久消耗减免: 0,
			    能量流失: 0,
			    商店价格倍率: 1,
			    已获得神龛效果: [],
			};
			let 初始玩家属性 = {
			    移动步数: 1,
			    攻击加成: 0,
			    防御加成: 0,
			    掉落倍率: 1,
			    透视: false,
			    允许移动: 0,
			    能挖掘墙壁: false,
			    最大生命值加成: 0,
			    怪物反伤: false,
			    挑战波数增加: 0,
			    随机掉落: false,
			    初始能量加成: 0,
			    耐久消耗减免: 0,
			    能量流失: 0,
			    商店价格倍率: 1,
			    已获得神龛效果: [],
			};
			let 自定义全局设置 = {
		    初始生命值: 100,
		    初始能量值: 100,
		    初始背包容量: 12,
		    玩家属性: {
		        移动步数: 1,
		        攻击加成: 0,
		        防御加成: 0,
		    },
		    胜利条件: {
		        回合数限制: 0,
		        伤害限制: 0,
		        生命下限: 0,
		        清除所有怪物: false,
		        死亡次数限制: 0,
		    },
		    全局天气: [],
		    禁用传送菜单: false,
		    禁用大地图: false,
		    诡魅天气怪物层级: 1,
		    奖励物品层级: 1,
		};
			let 胜利条件提示元素组 = {
			    标题: null,
			    回合: null,
			    伤害: null,
			    生命: null,
			    死亡: null
			};
			let 玩家总移动回合数 = 0;
			let 玩家总受到伤害 = 0;
			let 永久Buffs = {
			    已获得效果: new Set(),
			};
			let 相机目标X = 视口偏移X;
			let 相机目标Y = 视口偏移Y;
			let 当前相机X = 视口偏移X;
			let 当前相机Y = 视口偏移Y;
			let 相机锁定 = false; // 防止中途更新目标
			let 玩家仆从列表 = [];
			const 相机移动速度 = 0.2;
			let 显示模式 = "装备"; // 默认显示装备槽
			let 日志历史 = [];
			let 是否显示通知 = true;
			let 日志面板可见 = false;
			let 所有计时器 = [];
			let 玩家状态 = [];
			let NPC互动中 = false;
			let 当前NPC = null;
			let 已击杀怪物数 = 0;
			let 怪物状态表 = new WeakMap(); //好耶！WeakMap！
			let 彩蛋1触发,
			    彩蛋2触发,
			    彩蛋3触发 = false; //卑鄙的人，彩蛋要靠自己寻找才有意义
			let 待显示格子特效队列 = [];
			let 活动DOM特效 = [];
			let 待显示爆炸范围 = [];
			let 物品池;
			let 怪物池;
			let 所有物品定义 = []; // 用于存储图鉴的物品定义
			let 所有怪物定义 = [];
			let 怪物动画状态 = new WeakMap();
			let 玩家正在放置障碍物 = false;
			let 编辑器工具栏模式 = '常显';
			
			
			let moveQueue = [];
			let isAutoMoving = false;
			let 最高教程阶段 = 0;
			let 当前回放阶段 = 0;
			            let 中文模式 = false;
			let 游戏状态 = "主菜单"; // "主菜单", "游戏中", "地图编辑器", "图鉴", "图鉴选择", "编辑器游玩"
			let 编辑器状态 = {
			    当前选中: null, 
			    模式: '编辑',
			    选中实例: null, 
			    相机速度: 1,
			    正在划区: false,
			    划区起点: { x: 0, y: 0 },
			    上次放置的背景: null,
				笔刷模式: '单个',
				笔刷形状: '圆形',
				笔刷半径: 3,
			};
			let undoStack = [];
			let redoStack = [];
			const MAX_UNDO_STEPS = 50;
			let 编辑器最近使用列表 = [];
			let 自动回合间隔 = 350;
			let 上次自动回合时间 = 0;
			let 玩家正在钩索 = false;
			let 钩索移动定时器 = null;
			let 生存挑战激活 = false;
			let 生存挑战备份单元格 = [];
			let 物品点击监听器 = null;
			let 开发者模式 = false;
			let versionClickCount = 0;
			let 地牢生成方式 = 'default';
            let 已揭示洞穴格子 = new Set();
			
			
			//装备栏相关
			let 当前装备页 = 0;
			let 最大装备页 = 3;
			let 最大装备槽数量 = 24;
			let 触摸起始X = 0;
			let 触摸移动X = 0;
			let 装备栏滑动中 = false;
			let 装备栏每页装备数 = 7;
			
			
			let touchStartX = 0;
			let touchStartY = 0;
			let touchCurrentX = 0;
			let touchCurrentY = 0;
			let touchStartTime = 0;
			let isSwiping = false;
			let swipeMoveInterval = null;
			const swipeThreshold = 15; // 移动超过才识别为滑动
			const tapTimeThreshold = 75; // 毫秒内的触摸视为点击
			let 地图标记 = new Map();
			let 大地图状态 = {
				可见: false,
				缩放等级: 1.0,
				最小缩放: 0.2,
				最大缩放: 5.0,
				平移X: 0,
				平移Y: 0,
				拖拽中: false,
				拖拽起始X: 0,
				拖拽起始Y: 0,
				上次平移X: 0,
				上次平移Y: 0,
				动画帧ID: null,
				悬停信息: null,
				当前查看楼层: 0,
				标记模式: false,
				传送模式: false,
				可能是一个点击: false,
				信息计时器: null,
			};
const 大地图画布 = document.getElementById('大地图画布');
const 大地图画布容器 = document.getElementById('大地图画布容器');
const 大地图遮罩 = document.getElementById('大地图遮罩');
const 大地图信息 = document.getElementById('大地图信息');

document.getElementById('小地图容器').addEventListener('click', 打开大地图);
document.getElementById('关闭大地图按钮').addEventListener('click', 关闭大地图);
document.getElementById('大地图缩放放大按钮').addEventListener('click', () => 调整大地图缩放(1.2));
document.getElementById('大地图缩放缩小按钮').addEventListener('click', () => 调整大地图缩放(1 / 1.2));
document.getElementById('大地图居中按钮').addEventListener('click', () => 居中大地图(true));
document.getElementById('大地图上一层按钮').addEventListener('click', () => 切换大地图楼层(-1));
document.getElementById('大地图下一层按钮').addEventListener('click', () => 切换大地图楼层(1));
document.getElementById('大地图标记模式按钮').addEventListener('click', 切换大地图标记模式);
document.getElementById('大地图传送按钮').addEventListener('click', 切换大地图传送模式);

function 大地图点击信息(事件) {
				const rect = 大地图画布容器.getBoundingClientRect();
				const x = (事件.clientX || 事件.touches[0].clientX) - rect.left;
				const y = (事件.clientY || 事件.touches[0].clientY) - rect.top;

				const 世界X = Math.floor((x - 大地图状态.平移X) / (16 * 大地图状态.缩放等级));
				const 世界Y = Math.floor((y - 大地图状态.平移Y) / (16 * 大地图状态.缩放等级));
				const 房间ID = 房间地图[世界Y]?.[世界X];

				if (大地图状态.信息计时器) clearTimeout(大地图状态.信息计时器);
				
				if (房间ID !== undefined && 房间ID !== -1 && (已访问房间.has(房间ID)||开发者模式||游戏状态=="地图编辑器")) {
					const room = 房间列表.find(r => r && r.id === 房间ID);
					if (room) {
						大地图状态.悬停信息 = `房间 ${room.id}: ${room.名称 || '未命名'} (${room.类型 || '普通'})`;
					} else {
						大地图状态.悬停信息 = `(${世界X}, ${世界Y})`;
					}
				} else {
					大地图状态.悬停信息 = `(${世界X}, ${世界Y})`;
				}

				大地图状态.信息计时器 = setTimeout(() => {
					大地图状态.悬停信息 = null;
				}, 2500);
			}
function 打开大地图() {
    if (大地图状态.可见) return;
    if ((是否是自定义关卡 || 游戏状态 === '编辑器游玩') && 自定义全局设置.禁用大地图 && !开发者模式) {
显示通知("此关卡禁用了大地图。", "警告");
return;
}
if (
			        (当前天气效果.includes("诡魅") ||
			        当前天气效果.includes("深夜")) &&
			        游戏状态!=="地图编辑器"
			    ) {
			    return;
			    }
    大地图状态.可见 = true;
    大地图状态.当前查看楼层 = 当前层数;
    大地图状态.标记模式 = false;
    document.getElementById('大地图标记模式按钮').classList.remove('active');
    玩家属性.允许移动++;
    const 传送按钮 = document.getElementById('大地图传送按钮');
    if (开发者模式) {
传送按钮.style.display = 'block';
传送按钮.classList.remove('active');
传送按钮.style.borderColor = '';
} else {
传送按钮.style.display = 'none';
}

    大地图遮罩.style.display = 'flex';
    requestAnimationFrame(() => {
        大地图遮罩.classList.add('显示');
    });

    居中大地图(false);
    添加大地图事件监听();
    大地图状态.动画帧ID = requestAnimationFrame(绘制大地图循环);
    更新大地图楼层显示();
}

function 切换大地图标记模式() {
大地图状态.标记模式 = !大地图状态.标记模式;
const 按钮 = document.getElementById('大地图标记模式按钮');
const 传送按钮 = document.getElementById('大地图传送按钮');
if (大地图状态.标记模式) {
    大地图状态.传送模式 = false;
    传送按钮.classList.remove('active');
    传送按钮.style.borderColor = '';

    按钮.classList.add('active');
    按钮.style.borderColor = '#2196f3';
    大地图画布容器.style.cursor = 'crosshair';
    显示通知("标记模式已开启", "信息");
} else {
    按钮.classList.remove('active');
    按钮.style.borderColor = '';
    大地图画布容器.style.cursor = 'grab';
    显示通知("标记模式已关闭", "信息");
}

}
function 切换大地图传送模式() {
大地图状态.传送模式 = !大地图状态.传送模式;
const 按钮 = document.getElementById('大地图传送按钮');
const 标记按钮 = document.getElementById('大地图标记模式按钮');
if (大地图状态.传送模式) {
    大地图状态.标记模式 = false;
    标记按钮.classList.remove('active');
    标记按钮.style.borderColor = '';

    按钮.classList.add('active');
    按钮.style.borderColor = '#f44336';
    大地图画布容器.style.cursor = 'crosshair';
    显示通知("传送模式已开启", "信息");
} else {
    按钮.classList.remove('active');
    按钮.style.borderColor = '';
    大地图画布容器.style.cursor = 'grab';
    显示通知("传送模式已关闭", "信息");
}

}
function 切换大地图楼层(方向) {
    let 查看楼层 = 大地图状态.当前查看楼层 + 方向;
    const 目标楼层数据 = 所有地牢层.get(查看楼层);
    if (目标楼层数据 && 目标楼层数据.当前天气效果 && 目标楼层数据.当前天气效果.includes("深夜")) {
        显示通知(`第 ${查看楼层} 层一片漆黑，地图无法显示。`, "警告");
        查看楼层 = 大地图状态.当前查看楼层 + 方向;
    }
    if (查看楼层 === 当前层数 || 所有地牢层.has(查看楼层)) {
        大地图状态.当前查看楼层 = 查看楼层;
        居中大地图(false);
        更新大地图楼层显示();
    } else {
        显示通知(`无法查看第 ${查看楼层} 层的地图。`, "警告");
    }
}

function 更新大地图楼层显示() {
    const 标题 = document.getElementById('大地图楼层标题');
    if (标题) {
        标题.textContent = `地牢地图 - 第 ${大地图状态.当前查看楼层} 层`;
    }
    document.getElementById('大地图上一层按钮').disabled = !所有地牢层.has(大地图状态.当前查看楼层 - 1) && (大地图状态.当前查看楼层 - 1) !== 当前层数;
    document.getElementById('大地图下一层按钮').disabled = !所有地牢层.has(大地图状态.当前查看楼层 + 1) && (大地图状态.当前查看楼层 + 1) !== 当前层数;
}

function 绘制大地图() {
    const ctx = 大地图画布.getContext('2d');
    const 容器宽度 = 大地图画布容器.clientWidth;
    const 容器高度 = 大地图画布容器.clientHeight;

    大地图画布.width = 容器宽度 * window.devicePixelRatio;
    大地图画布.height = 容器高度 * window.devicePixelRatio;
    大地图画布.style.width = `${容器宽度}px`;
    大地图画布.style.height = `${容器高度}px`;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg').trim();
    ctx.fillRect(0, 0, 容器宽度, 容器高度);

    ctx.save();
    ctx.translate(大地图状态.平移X, 大地图状态.平移Y);
    ctx.scale(大地图状态.缩放等级, 大地图状态.缩放等级);

    const floorData = 大地图状态.当前查看楼层 === 当前层数
        ? { 地牢, 房间列表, 所有怪物, 玩家位置: 玩家, 已访问房间,地牢生成方式,已揭示洞穴格子 }
        : 所有地牢层.get(大地图状态.当前查看楼层);

    if (!floorData) {
        ctx.restore();
        return;
    }

    const 单元格尺寸 = 16;
    const 玩家定位器地图 = Array.from(玩家装备.values()).find(item => item instanceof 定位器地图);
    const 墙壁线宽 = 2 / 大地图状态.缩放等级;

    let localDungeon = floorData.地牢;
    let 下楼房间 = null
    if (!localDungeon) localDungeon = floorData.地牢数组;
    
    for (let y = 0; y < localDungeon.length; y++) {
        for (let x = 0; x < localDungeon[y].length; x++) {
            const 单元格 = localDungeon[y][x];
            if (!单元格) continue;
            if(floorData.地牢生成方式 === 'cave' && !floorData.已揭示洞穴格子.has(`${x},${y}`)&&!(玩家定位器地图&&单元格.类型==单元格类型.楼梯下楼) &&!(玩家定位器地图&&单元格.关联物品 instanceof 旗帜)&& 游戏状态!=="地图编辑器") continue;
            
            if (命令行模式开启) {
		const 屏幕X = (单元格.x) * 单元格尺寸;
        const 屏幕Y = (单元格.y) * 单元格尺寸;
		ctx.fillStyle = '#FFFFFF';
		ctx.font = `${单元格尺寸}px 'Courier New', monospace`;
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';
		if (单元格.背景类型 === 单元格类型.墙壁) {
			const 墙壁字符 = 获取墙壁字符(单元格);
			ctx.fillText(墙壁字符, 屏幕X + 单元格尺寸 / 2, 屏幕Y + 单元格尺寸 / 2 + 2);
		} else {
			if (单元格.背景类型 === 单元格类型.门) {
				ctx.fillText('+', 屏幕X + 单元格尺寸 / 2, 屏幕Y + 单元格尺寸 / 2);
			} else if (单元格.背景类型 === 单元格类型.上锁的门) {
				ctx.fillStyle = 颜色表[单元格.颜色索引] || '#FFFFFF';
				ctx.fillText('#', 屏幕X + 单元格尺寸 / 2, 屏幕Y + 单元格尺寸 / 2);
			} else if (单元格.背景类型 === 单元格类型.走廊) {
				ctx.fillStyle = '#555';
				ctx.fillText('·', 屏幕X + 单元格尺寸 / 2, 屏幕Y + 单元格尺寸 / 2);
			} else {
				ctx.fillStyle = '#333';
				ctx.fillText('.', 屏幕X + 单元格尺寸 / 2, 屏幕Y + 单元格尺寸 / 2);
			}
			ctx.strokeStyle = '#FFFFFF';
			ctx.lineWidth = 1;
			ctx.beginPath();
			if (单元格.墙壁.上) { ctx.moveTo(屏幕X, 屏幕Y); ctx.lineTo(屏幕X + 单元格尺寸, 屏幕Y); }
			if (单元格.墙壁.右) { ctx.moveTo(屏幕X + 单元格尺寸, 屏幕Y); ctx.lineTo(屏幕X + 单元格尺寸, 屏幕Y + 单元格尺寸); }
			if (单元格.墙壁.下) { ctx.moveTo(屏幕X + 单元格尺寸, 屏幕Y + 单元格尺寸); ctx.lineTo(屏幕X, 屏幕Y + 单元格尺寸); }
			if (单元格.墙壁.左) { ctx.moveTo(屏幕X, 屏幕Y + 单元格尺寸); ctx.lineTo(屏幕X, 屏幕Y); }
			ctx.stroke();
		}
	} else {
            let 颜色 = '#000';
            if (单元格.背景类型 === 单元格类型.房间) 颜色 = "#3a506b";
            else if (单元格.背景类型 === 单元格类型.走廊) 颜色 = "#2b2d42";
            else if (单元格.背景类型 === 单元格类型.门) 颜色 = "#8b4513";
            else if (单元格.背景类型 === 单元格类型.上锁的门) 颜色 = 颜色表[单元格.颜色索引];

            ctx.fillStyle = 颜色;
            ctx.fillRect(x * 单元格尺寸, y * 单元格尺寸, 单元格尺寸, 单元格尺寸);
            if (单元格.isOneWay && 单元格.oneWayAllowedDirection && [单元格类型.门, 单元格类型.上锁的门].includes(单元格.背景类型)) {
                            ctx.save();
			                ctx.font = `${单元格尺寸 * 0.7}px Arial`;
			                ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
			                ctx.textAlign = "center";
			                ctx.textBaseline = "middle";
			                let arrow = "";
			
			                if (单元格.oneWayAllowedDirection === "N") arrow = "↑";
			                else if (单元格.oneWayAllowedDirection === "S") arrow = "↓";
			                else if (单元格.oneWayAllowedDirection === "E") arrow = "→";
			                else if (单元格.oneWayAllowedDirection === "W") arrow = "←";
			
			                const arrowX = x*单元格尺寸 + 单元格尺寸 / 2;
			                const arrowY = y*单元格尺寸 + 单元格尺寸 / 2;
			
			                ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
			                ctx.shadowBlur = 3;
			                ctx.shadowOffsetX = 1;
			                ctx.shadowOffsetY = 1;
			                ctx.fillText(arrow, arrowX, arrowY);
                            ctx.restore();
			            }
            

            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 墙壁线宽;
            ctx.beginPath();
            if (单元格.墙壁.上) { ctx.moveTo(x * 单元格尺寸, y * 单元格尺寸); ctx.lineTo((x + 1) * 单元格尺寸, y * 单元格尺寸); }
            if (单元格.墙壁.右) { ctx.moveTo((x + 1) * 单元格尺寸, y * 单元格尺寸); ctx.lineTo((x + 1) * 单元格尺寸, (y + 1) * 单元格尺寸); }
            if (单元格.墙壁.下) { ctx.moveTo((x + 1) * 单元格尺寸, (y + 1) * 单元格尺寸); ctx.lineTo(x * 单元格尺寸, (y + 1) * 单元格尺寸); }
            if (单元格.墙壁.左) { ctx.moveTo(x * 单元格尺寸, (y + 1) * 单元格尺寸); ctx.lineTo(x * 单元格尺寸, y * 单元格尺寸); }
            ctx.stroke();
            }
            const item = 单元格.关联物品;
            let shouldDraw = false;

            
        
            if (单元格.关联物品 && !单元格.关联物品.是否为隐藏物品) {
                if (item.类型 === '楼梯') {
                if (单元格.类型 === 单元格类型.楼梯上楼) {
                    shouldDraw = true;
                } else if (单元格.类型 === 单元格类型.楼梯下楼) {
                    shouldDraw = true;
                    if (玩家定位器地图){
                    if (房间地图[y][x]>0) 下楼房间=房间地图[y][x]
                    floorData?.已揭示洞穴格子?.add(`${x},${y}`);
                    }
                    
                }
                
                
                if (shouldDraw) {
                ctx.fillStyle ='#fff'
                ctx.font = `${单元格尺寸 * 0.8}px color-emoji`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                //ctx.fillText(item.图标, (x + 0.5) * 单元格尺寸, (y + 0.5) * 单元格尺寸);
                drawIcon(ctx,item.图标, (x + 0.5) * 单元格尺寸, (y + 0.5) * 单元格尺寸,单元格尺寸 * 0.8,ctx.fillStyle);
                
                
            }
            continue;
            }
             if (单元格.关联物品 instanceof 旗帜) {
                    if (玩家定位器地图){
                    if (房间地图[y][x]>0) 下楼房间=房间地图[y][x]
                    floorData?.已揭示洞穴格子?.add(`${x},${y}`);
                    }
                    }

            
                 ctx.fillStyle = 单元格.关联物品.颜色表[单元格.关联物品.颜色索引];
                 ctx.font = `${单元格尺寸 * 0.8}px color-emoji`;
                 ctx.textAlign = "center";
                 ctx.textBaseline = "middle";
                 //ctx.fillText(单元格.关联物品.图标, (x + 0.5) * 单元格尺寸, (y + 0.5) * 单元格尺寸);
                 drawIcon(ctx,单元格.关联物品.图标, (x + 0.5) * 单元格尺寸, (y + 0.5) * 单元格尺寸,单元格尺寸 * 0.8,ctx.fillStyle);
            }
        }
    }
    const horizontalWalls = [];
				const verticalWalls = [];
				for (let y = 0; y < localDungeon.length; y++) {
					for (let x = 0; x < localDungeon[y].length; x++) {
						const cell = localDungeon[y][x];
						if (!cell) continue;
						if (floorData.地牢生成方式 === 'cave' && (!floorData.已揭示洞穴格子.has(`${x},${y}`)&&!(玩家定位器地图&&单元格.类型==单元格类型.楼梯下楼)) && 游戏状态!=="地图编辑器") continue;

						if (cell.墙壁.上 && (x === 0 || !localDungeon[y][x - 1].墙壁.上)) {
							let endX = x;
							while (endX + 1 < localDungeon[y].length && localDungeon[y][endX + 1].墙壁.上) {
								endX++;
							}
							horizontalWalls.push({ x1: x, y1: y, x2: endX + 1, y2: y });
						}
						if (cell.墙壁.左 && (y === 0 || !localDungeon[y - 1][x].墙壁.左)) {
							let endY = y;
							while (endY + 1 < localDungeon.length && localDungeon[endY + 1][x].墙壁.左) {
								endY++;
							}
							verticalWalls.push({ x1: x, y1: y, x2: x, y2: endY + 1 });
						}
					}
				}

				ctx.strokeStyle = '#e0e0e0';
				ctx.lineWidth = 墙壁线宽;
				ctx.beginPath();
				horizontalWalls.forEach(wall => {
					ctx.moveTo(wall.x1 * 单元格尺寸, wall.y1 * 单元格尺寸);
					ctx.lineTo(wall.x2 * 单元格尺寸, wall.y2 * 单元格尺寸);
				});
				verticalWalls.forEach(wall => {
					ctx.moveTo(wall.x1 * 单元格尺寸, wall.y1 * 单元格尺寸);
					ctx.lineTo(wall.x2 * 单元格尺寸, wall.y2 * 单元格尺寸);
				});
				ctx.stroke();
    if (floorData.所有怪物) {
        floorData.所有怪物.forEach(怪物 => {
            const 房间ID = 房间地图[怪物.y][怪物.x];
            if(floorData.地牢生成方式 === 'cave' && !floorData.已揭示洞穴格子.has(`${怪物.x},${怪物.y}`)&& 游戏状态!=="地图编辑器") return;
            if (怪物.强化) {
                ctx.fillStyle = '#f00';
                ctx.font = `${单元格尺寸 * 0.8}px color-emoji`;
                if (怪物 instanceof 巨人怪物) ctx.fillStyle = ctx.font = `${单元格尺寸 * 1.8}px color-emoji`;
            } else {
                ctx.fillStyle = '#fff';
                ctx.font = `${单元格尺寸 * 0.8}px color-emoji`;
                if (怪物 instanceof 巨人怪物) ctx.font = `${单元格尺寸 * 1.8}px color-emoji`;
            }
            
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            if (怪物 instanceof 巨人怪物) {
                //ctx.fillText(怪物.图标, (怪物.x + 1) * 单元格尺寸, (怪物.y + 1) * 单元格尺寸);
                drawIcon(ctx,怪物.图标, (怪物.x + 1) * 单元格尺寸, (怪物.y + 1) * 单元格尺寸,单元格尺寸 * 1.8,ctx.fillStyle);
                return;
            }
            //ctx.fillText(怪物.图标, (怪物.x + 0.5) * 单元格尺寸, (怪物.y + 0.5) * 单元格尺寸);
            drawIcon(ctx,怪物.图标, (怪物.x + 0.5) * 单元格尺寸, (怪物.y + 0.5) * 单元格尺寸,单元格尺寸 * 0.8,ctx.fillStyle);
        });
    }


if (当前出战宠物列表 && 当前出战宠物列表.length) {
当前出战宠物列表.forEach(pet => {
if (!pet || !pet.是否已放置) return;

 if (pet.层数!==大地图状态.当前查看楼层) return
const sx = pet.x * 单元格尺寸 + 单元格尺寸 / 2;
const sy = pet.y * 单元格尺寸 + 单元格尺寸 / 2;
ctx.font = `${Math.max(10, Math.floor(单元格尺寸 * 0.9))}px color-emoji`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
const 图标 = pet.图标 || 图标映射.宠物 || "🐾";
ctx.fillStyle =  pet.颜色表[pet.颜色索引]||"#ffffff";
ctx.fillText(图标, sx, sy);
drawIcon(ctx,图标, sx, sy,Math.max(10, Math.floor(单元格尺寸 * 0.9)),ctx.fillStyle);
});
}
房间列表.forEach(房间 => {
const 已访问 = floorData?.已访问房间?.has(房间.id);
if  ((已访问&&房间.类型!=='黑暗房间')||开发者模式||房间.id==下楼房间||游戏状态==="地图编辑器"||游戏状态=="图鉴") return;
const rx = 房间.x * 单元格尺寸;
const ry = 房间.y * 单元格尺寸;

ctx.fillStyle ="#000f";
ctx.fillRect(rx, ry, 房间.w * 单元格尺寸, 房间.h * 单元格尺寸);

});
    const 玩家位置 = floorData.玩家位置;
    if (命令行模式开启) {
ctx.fillStyle = '#f00';
		ctx.font = `bold ${单元格尺寸 * 0.9}px 'Courier New', monospace`;
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillText('@', (玩家位置.x + 0.5) * 单元格尺寸, (玩家位置.y + 0.5) * 单元格尺寸);
	} else {
		ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.arc((玩家位置.x + 0.5) * 单元格尺寸, (玩家位置.y + 0.5) * 单元格尺寸, 单元格尺寸 * 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2 / 大地图状态.缩放等级;
        ctx.stroke();
	}

    const markers = 地图标记.get(大地图状态.当前查看楼层) || [];
    markers.forEach(marker => {
        ctx.font = `${单元格尺寸*1.5}px color-emoji`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(marker.icon, (marker.x + 1) * 单元格尺寸, (marker.y + 1) * 单元格尺寸);
    });

    ctx.restore();
    
    if (大地图状态.悬停信息) {
        大地图信息.textContent = 大地图状态.悬停信息;
        大地图信息.style.display = 'block';
    } else {
        大地图信息.style.display = 'none';
    }
}

function 大地图拖拽开始(事件) {
			    事件.preventDefault();
				大地图状态.可能是一个点击 = true;
			    const rect = 大地图画布容器.getBoundingClientRect();
		        const x = (事件.clientX || 事件.touches[0].clientX) - rect.left;
		        const y = (事件.clientY || 事件.touches[0].clientY) - rect.top;

		        const 世界X = Math.floor((x - 大地图状态.平移X) / (16 * 大地图状态.缩放等级));
		        const 世界Y = Math.floor((y - 大地图状态.平移Y) / (16 * 大地图状态.缩放等级));
			    if (大地图状态.标记模式) {
			        
			
			        const markers = 地图标记.get(大地图状态.当前查看楼层) || [];
			        const existingIndex = markers.findIndex(m => m.x === 世界X && m.y === 世界Y);
			
			        if (existingIndex > -1) {
			            markers.splice(existingIndex, 1);
			        } else {
			            const icon = prompt("输入标记图标 (例如: ❓, 💀, 💰):", "⭐");
			            if (icon) {
			                markers.push({ x: 世界X, y: 世界Y, icon: icon });
			            }
			        }
			        地图标记.set(大地图状态.当前查看楼层, markers);
			        切换大地图标记模式()
			        绘制小地图();
			        return;
			    }
			    if (大地图状态.传送模式) {
			    if (大地图状态.当前查看楼层 === 当前层数) {
			        if (位置是否可用(世界X, 世界Y, false)) {
			            玩家.x = 世界X;
			            玩家.y = 世界Y;
			            更新视口(true);
			            处理玩家着陆效果(世界X, 世界Y, 世界X, 世界Y);
			            if (生存挑战激活) {
						        显示通知("强大的结界阻止了传送！", "错误");
						        关闭大地图();
						        return;
						    }
						
						    const 当前玩家房间ID = 房间地图[玩家.y][玩家.x];
						    if (当前玩家房间ID !== -1) {
						        const 当前玩家所在房间 = 房间列表[当前玩家房间ID];
						        if (
						            当前玩家所在房间 &&
						            当前玩家所在房间.类型 === "挑战房间" &&
						            当前玩家所在房间.挑战状态 &&
						            当前玩家所在房间.挑战状态.进行中
						        ) {
						            处理挑战失败(当前玩家所在房间);
						        }
						    }
			            显示通知(`已传送到 (${世界X}, ${世界Y})`, "成功");
			            关闭大地图();
			        } else {
			            显示通知("无法传送到该位置！", "错误");
			            切换大地图传送模式()
			        }
			    } else {
			        显示通知("只能在当前楼层进行传送！", "错误");
			    }
			    return;
			}
			    大地图状态.拖拽中 = true;
			    大地图状态.拖拽起始X = (事件.clientX || 事件.touches[0].clientX);
			    大地图状态.拖拽起始Y = (事件.clientY || 事件.touches[0].clientY);
			    大地图状态.上次平移X = 大地图状态.平移X;
			    大地图状态.上次平移Y = 大地图状态.平移Y;
			    大地图画布容器.style.cursor = 'grabbing';
			}


function 关闭大地图() {
    if (!大地图状态.可见) return;
    大地图状态.可见 = false;
    玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动 - 1);

    大地图遮罩.classList.remove('显示');
    setTimeout(() => {
        let 按钮 = document.getElementById('大地图标记模式按钮');
        大地图遮罩.style.display = 'none';
        大地图状态.标记模式 =false
        按钮.classList.remove('active');
        按钮.style.borderColor = '';
        按钮 = document.getElementById('大地图传送按钮');
        按钮.classList.remove('active');
    按钮.style.borderColor = '';
    大地图状态.传送模式 =false
    }, 400);

    移除大地图事件监听();
    if (大地图状态.动画帧ID) {
        cancelAnimationFrame(大地图状态.动画帧ID);
        大地图状态.动画帧ID = null;
    }
}

function 绘制大地图循环() {
    if (!大地图状态.可见) return;
    绘制大地图();
    大地图状态.动画帧ID = requestAnimationFrame(绘制大地图循环);
}


function 居中大地图(带动画) {
     //if(大地图状态.当前查看楼层 != 当前层数) return;
    const 容器宽度 = 大地图画布容器.clientWidth;
    const 容器高度 = 大地图画布容器.clientHeight;
    const 单元格尺寸 = 16;
    let 玩家位置 = 大地图状态.当前查看楼层 === 当前层数
        ? { 玩家位置: 玩家 }
        : 所有地牢层.get(大地图状态.当前查看楼层);
    
    const 目标平移X = 容器宽度 / 2 - (玩家位置.玩家位置.x + 0.5) * 单元格尺寸 * 大地图状态.缩放等级;
    const 目标平移Y = 容器高度 / 2 - (玩家位置.玩家位置.y + 0.5) * 单元格尺寸 * 大地图状态.缩放等级;

    if (带动画 && typeof gsap !== 'undefined') {
        gsap.to(大地图状态, {
            平移X: 目标平移X,
            平移Y: 目标平移Y,
            duration: 0.4,
            ease: 'power2.out'
        });
    } else {
        大地图状态.平移X = 目标平移X;
        大地图状态.平移Y = 目标平移Y;
    }
}

function 调整大地图缩放(缩放因子, 缩放中心X = null, 缩放中心Y = null) {
    const 容器 = 大地图画布容器;
    if(缩放中心X === null) 缩放中心X = 容器.clientWidth / 2;
    if(缩放中心Y === null) 缩放中心Y = 容器.clientHeight / 2;

    const 旧缩放等级 = 大地图状态.缩放等级;
    let 新缩放等级 = 旧缩放等级 * 缩放因子;
    新缩放等级 = Math.max(大地图状态.最小缩放, Math.min(大地图状态.最大缩放, 新缩放等级));
    
    const 实际缩放因子 = 新缩放等级 / 旧缩放等级;
    if (Math.abs(实际缩放因子 - 1) < 0.001) return;

    大地图状态.缩放等级 = 新缩放等级;
    
    const 鼠标世界X = (缩放中心X - 大地图状态.平移X) / 旧缩放等级;
    const 鼠标世界Y = (缩放中心Y - 大地图状态.平移Y) / 旧缩放等级;
    
    大地图状态.平移X = 缩放中心X - 鼠标世界X * 新缩放等级;
    大地图状态.平移Y = 缩放中心Y - 鼠标世界Y * 新缩放等级;
}


function 大地图拖拽移动(事件) {
			    if (!大地图状态.拖拽中) return;
			    事件.preventDefault();

				if (大地图状态.可能是一个点击) {
					const 当前X = (事件.clientX || 事件.touches[0].clientX);
					const 当前Y = (事件.clientY || 事件.touches[0].clientY);
					const 偏移X = Math.abs(当前X - 大地图状态.拖拽起始X);
					const 偏移Y = Math.abs(当前Y - 大地图状态.拖拽起始Y);
					if (偏移X > 5 || 偏移Y > 5) {
						大地图状态.可能是一个点击 = false;
					}
				}

			    const 当前X = (事件.clientX || 事件.touches[0].clientX);
			    const 当前Y = (事件.clientY || 事件.touches[0].clientY);
			    const 偏移X = 当前X - 大地图状态.拖拽起始X;
			    const 偏移Y = 当前Y - 大地图状态.拖拽起始Y;
			    大地图状态.平移X = 大地图状态.上次平移X + 偏移X;
			    大地图状态.平移Y = 大地图状态.上次平移Y + 偏移Y;
			}

function 大地图拖拽结束(事件) {
				const finalEvent = event.changedTouches ? event.changedTouches[0] : event;

				if (大地图状态.可能是一个点击 && !大地图状态.标记模式 && !大地图状态.传送模式) {
					大地图点击信息(finalEvent);
				}

			    大地图状态.拖拽中 = false;
				大地图状态.可能是一个点击 = false;
			    大地图画布容器.style.cursor = 'grab';
			}

function 大地图滚轮缩放(事件) {
    事件.preventDefault();
    const 缩放因子 = 事件.deltaY < 0 ? 1.1 : 1 / 1.1;
    const rect = 大地图画布容器.getBoundingClientRect();
    const 缩放中心X = 事件.clientX - rect.left;
    const 缩放中心Y = 事件.clientY - rect.top;
    调整大地图缩放(缩放因子, 缩放中心X, 缩放中心Y);
}

let 大地图上次触摸距离 = 0;
function 大地图触摸开始(事件) {
				if (事件.touches.length === 2) {
					事件.preventDefault();
					大地图状态.拖拽中 = false; 
					const t1 = 事件.touches[0];
					const t2 = 事件.touches[1];
					大地图状态.上次触摸距离 = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
				} else if (事件.touches.length === 1) {
					大地图拖拽开始(事件);
				}
			}

			function 大地图触摸移动(事件) {
				if (事件.touches.length === 2) {
					事件.preventDefault();
					const t1 = 事件.touches[0];
					const t2 = 事件.touches[1];
					const 当前触摸距离 = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
					const 缩放因子 = 当前触摸距离 / 大地图状态.上次触摸距离;
					大地图状态.上次触摸距离 = 当前触摸距离;
					
					const rect = 大地图画布容器.getBoundingClientRect();
					const 中心X = (t1.clientX + t2.clientX) / 2 - rect.left;
					const 中心Y = (t1.clientY + t2.clientY) / 2 - rect.top;
					
					调整大地图缩放(缩放因子, 中心X, 中心Y);

				} else if (事件.touches.length === 1) {
					大地图拖拽移动(事件);
				}
			}

			function 大地图触摸结束(事件) {
				 if (事件.touches.length < 2) {
					大地图状态.上次触摸距离 = 0;
				}
				if (事件.touches.length < 1) {
					大地图拖拽结束(事件);
				}
			}

			function 添加大地图事件监听() {
			    大地图画布容器.addEventListener('mousedown', 大地图拖拽开始);
			    window.addEventListener('mousemove', 大地图拖拽移动);
			    window.addEventListener('mouseup', 大地图拖拽结束);
			    大地图画布容器.addEventListener('wheel', 大地图滚轮缩放, { passive: false });
			    
			    大地图画布容器.addEventListener('touchstart', 大地图触摸开始, { passive: false });
			    大地图画布容器.addEventListener('touchmove', 大地图触摸移动, { passive: false });
			    大地图画布容器.addEventListener('touchend', 大地图触摸结束);
			    大地图画布容器.addEventListener('mousemove', 大地图悬停信息);
			}

			function 移除大地图事件监听() {
			    大地图画布容器.removeEventListener('mousedown', 大地图拖拽开始);
			    window.removeEventListener('mousemove', 大地图拖拽移动);
			    window.removeEventListener('mouseup', 大地图拖拽结束);
			    大地图画布容器.removeEventListener('wheel', 大地图滚轮缩放);

			    大地图画布容器.removeEventListener('touchstart', 大地图触摸开始);
			    大地图画布容器.removeEventListener('touchmove', 大地图触摸移动);
			    大地图画布容器.removeEventListener('touchend', 大地图触摸结束);
			    大地图画布容器.removeEventListener('mousemove', 大地图悬停信息);
			}

function 大地图悬停信息(事件) {
    const rect = 大地图画布容器.getBoundingClientRect();
    const x = 事件.clientX - rect.left;
    const y = 事件.clientY - rect.top;

    const 单元格尺寸 = 16 * 大地图状态.缩放等级;
    const 世界X = Math.floor((x - 大地图状态.平移X) / (16 * 大地图状态.缩放等级));
    const 世界Y = Math.floor((y - 大地图状态.平移Y) / (16 * 大地图状态.缩放等级));

    const 房间ID = 房间地图[世界Y]?.[世界X];
    if (房间ID !== undefined && 房间ID !== -1 && (已访问房间.has(房间ID)||开发者模式||游戏状态=="地图编辑器")) {
        const room = 房间列表.find(r => r && r.id === 房间ID);
        if (room) {
            大地图状态.悬停信息 = `房间 ${room.id}: ${room.名称 || '未命名'} (${room.类型 || '普通'})`;
            return;
        }
    }
    大地图状态.悬停信息 = `(${世界X}, ${世界Y})`;
}



			function 玩家等待(是否由休息调用 = false) {
				if (玩家属性.允许移动 > 0 || 死亡界面已显示) {
					if (是否由休息调用) 停止休息();
					return;
				}
				if (!是否由休息调用) {
					移动历史.push('等待');
				}
				处理回合逻辑();
				更新视口();
				//绘制();
			}

			function 开始休息() {
				if (玩家正在休息 || 玩家属性.允许移动 > 0 || 死亡界面已显示) return;
				if (玩家状态.length > 0) {
					显示通知("你身中药水效果，无法静心休息。", "警告");
					return;
				}
				if (自定义全局设置.禁用休息) {
					显示通知("这个关卡禁用了休息功能。", "警告");
					return;
				}
				玩家正在休息 = true;
				显示通知("开始休息...", "信息");

				const 休息逻辑 = () => {
					if (!玩家正在休息) return;
					玩家等待(true);
					休息定时器 = setTimeout(休息逻辑, 移动间隔);
				};

				休息逻辑();
			}

			function 停止休息() {
				if (休息定时器) {
					clearTimeout(休息定时器);
					休息定时器 = null;
				}
				玩家正在休息 = false;
			}
			document.getElementById('背包整理按钮').addEventListener('click', () => {
					
					const inGameStates = ["游戏中", "编辑器游玩", "图鉴"];
    if (inGameStates.includes(游戏状态)) {
        整理背包();
    }
				});
			function 整理背包() {
				const 物品数组 = [...玩家背包.values()].filter(item => !item.是否隐藏);
				
				物品数组.sort((a, b) => {
					if (b.品质 !== a.品质) {
						return b.品质 - a.品质;
					}
					return 0; 
				});

				const 隐藏物品 = [...玩家背包.values()].filter(item => item.是否隐藏);

				玩家背包.clear();
				更新背包显示();

				物品数组.forEach(item => 玩家背包.set(item.唯一标识, item));
				隐藏物品.forEach(item => 玩家背包.set(item.唯一标识, item));
				更新背包显示()
				显示通知("背包已整理！", "成功");
			}
			
			function 油漆桶填充(x, y, 新背景类型) {
				if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return;

				const 原始背景类型 = 地牢[y][x].背景类型;
				if (原始背景类型 === 新背景类型) return;
				saveEditorState();

				const 队列 = [{x, y}];
				const 已访问 = new Set([`${x},${y}`]);

				while (队列.length > 0) {
					const 当前 = 队列.shift();
					
					if(新背景类型===单元格类型.墙壁) 重置单元格(当前.x, 当前.y);
					地牢[当前.y][当前.x].背景类型 = 新背景类型;
					


					const 方向 = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
					for (const {dx, dy} of 方向) {
						const 邻居X = 当前.x + dx;
						const 邻居Y = 当前.y + dy;
						const 邻居键 = `${邻居X},${邻居Y}`;
						if (邻居X >= 0 && 邻居X < 地牢大小 && 邻居Y >= 0 && 邻居Y < 地牢大小 &&
							地牢[邻居Y][邻居X].背景类型 === 原始背景类型 && !已访问.has(邻居键)) {
							已访问.add(邻居键);
							队列.push({x: 邻居X, y: 邻居Y});
						}
					}
				}
				生成墙壁();
				//绘制();
				
			}
const emojiImageCache = new Map();
			let emojiCdnCheckInProgress = false;

			async function checkCdnAvailability() {
				return new Promise((resolve) => {
					if (emojiCdnCheckInProgress) {
						const interval = setInterval(() => {
							if (!emojiCdnCheckInProgress) {
								clearInterval(interval);
								resolve(游戏设置.emojiCDN是否可用);
							}
						}, 100);
						return;
					}
					emojiCdnCheckInProgress = true;
					const testImg = new Image();
					testImg.onload = () => {
						游戏设置.emojiCDN是否可用 = true;
						emojiCdnCheckInProgress = false;
						resolve(true);
					};
					testImg.onerror = () => {
						游戏设置.emojiCDN是否可用 = false;
						emojiCdnCheckInProgress = false;
						resolve(false);
					};
					testImg.src = "https://emoji-cdn.mqrio.dev/✅?style=google";
				});
			}

			function getIconChar(key) {
				if (!key) return '❓';
				const map = 游戏设置.文本模式 ? 中文对照图标映射 : 图标映射;
				return map[key] || key;
			}

			function getIconHTML(key) {
				const iconChar = getIconChar(key);
				if (游戏设置.文本模式) {
					return `<span class="汉字图标">${iconChar}</span>`;
				}
				if (游戏设置.emoji风格 === 'local' || !游戏设置.emojiCDN是否可用) {
					return `<span style="font-family: 'color-emoji';">${iconChar}</span>`;
				}
				
				const url = `https://emoji-cdn.mqrio.dev/${iconChar}?style=${游戏设置.emoji风格}`;
				const cacheEntry = emojiImageCache.get(url);

				// 如果图片已加载或加载失败（404），则直接决定渲染方式
				if (cacheEntry && cacheEntry.status === 'failed') {
					return `<span style="font-family: 'color-emoji';">${iconChar}</span>`;
				}
				
				// 默认使用<img>标签，并添加onerror回退逻辑
				return `<img src="${url}" style="width: 1em; height: 1.1em; vertical-align: -0.1em; image-rendering: pixelated;" alt="${iconChar}" onerror="this.outerHTML = '<span style=\\'font-family: color-emoji;\\'>${iconChar}</span>';">`;
			}

			function drawIcon(ctx, key, screenX, screenY, size, color) {
				const iconChar = getIconChar(key);
				if (游戏设置.文本模式) {
					ctx.fillStyle = color || '#FFFFFF';
					ctx.font = `${size}px "Microsoft YaHei", sans-serif`;
					ctx.fillText(iconChar, screenX, screenY);
					return;
				}
				if (游戏设置.emoji风格 === 'local' || !游戏设置.emojiCDN是否可用 || 命令行模式开启) {
					ctx.font = `${size}px color-emoji`;
					ctx.fillText(iconChar, screenX, screenY);
					return;
				}
				const url = `https://emoji-cdn.mqrio.dev/${iconChar}?style=${游戏设置.emoji风格}`;
				const cacheEntry = emojiImageCache.get(url);

				if (cacheEntry) {
					if (cacheEntry.status === 'loaded' && cacheEntry.image?.complete && cacheEntry.image.naturalHeight !== 0) {
						try {
							ctx.drawImage(cacheEntry.image, screenX - size / 2, screenY - size / 2, size, size);
						} catch (e) {
							console.error(`绘制缓存的Emoji时出错: ${key}`, e);
							emojiImageCache.delete(url);
						}
					} else if (cacheEntry.status === 'failed') {
						ctx.font = `${size}px color-emoji`;
						ctx.fillStyle = color || '#FFFFFF';
						ctx.fillText(iconChar, screenX, screenY);
					}
				} else {
					emojiImageCache.set(url, { status: 'loading', image: null, retries: 0 });
					fetchAndCacheEmoji(url, iconChar);
				}
			}
			async function fetchAndCacheEmoji(url, fallbackChar) {
				const cacheEntry = emojiImageCache.get(url);
				if (!cacheEntry || cacheEntry.status !== 'loading') return;

				try {
					const response = await fetch(url, { mode: 'cors' });

					if (!response.ok) {
						if (response.status === 404) {
							console.warn(`Emoji CDN 未找到: ${fallbackChar} (404). 已回退到本地字体。`);
							emojiImageCache.set(url, { status: 'failed', image: null });
						} else {
							throw new Error(`HTTP error! status: ${response.status}`);
						}
						return;
					}

					const blob = await response.blob();
					const img = new Image();
					img.onload = () => {
						emojiImageCache.set(url, { status: 'loaded', image: img });
						URL.revokeObjectURL(img.src);
					};
					img.onerror = () => {
						console.error(`加载Emoji图片数据失败: ${fallbackChar}`);
						emojiImageCache.set(url, { status: 'failed', image: null });
						URL.revokeObjectURL(img.src);
					};
					img.src = URL.createObjectURL(blob);

				} catch (error) {
					console.error(`获取Emoji失败 (${fallbackChar}), 正在重试...`, error);
					cacheEntry.retries++;
					if (cacheEntry.retries < MAX_EMOJI_FETCH_RETRIES) {
						setTimeout(() => fetchAndCacheEmoji(url, fallbackChar), 500 * cacheEntry.retries);
					} else {
						console.error(`获取Emoji ${fallbackChar} 失败次数过多，已放弃。`);
						emojiImageCache.set(url, { status: 'failed', image: null });
						if (游戏设置.emojiCDN是否可用) {
							游戏设置.emojiCDN是否可用 = false;
							显示通知("Emoji CDN 访问失败，已自动切换回本地字体。", "警告");
						}
					}
				}
			}
			function 笔刷绘制(中心X, 中心Y) {
				if (!编辑器状态.当前选中 || 编辑器状态.当前选中.类型 !== '背景') return;
				//saveEditorState();

				const 尺寸 = 编辑器状态.笔刷半径;
				const 形状 = 编辑器状态.笔刷形状;
				const 新背景类型 = 编辑器状态.当前选中.绘制类型;

				const 左 = 中心X - 尺寸 + 1;
				const 右 = 中心X + 尺寸 - 1;
				const 上 = 中心Y - 尺寸 + 1;
				const 下 = 中心Y + 尺寸 - 1;

				for (let y = 上; y <= 下; y++) {
					for (let x = 左; x <= 右; x++) {
						if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;

						let 在范围内 = false;
						if (形状 === '圆形') {
							const dx = x - 中心X;
							const dy = y - 中心Y;
							if (dx * dx + dy * dy < 尺寸 * 尺寸) {
								在范围内 = true;
							}
						} else {
							在范围内 = true;
						}
						
						if (在范围内) {
							if(新背景类型===单元格类型.墙壁) 重置单元格(x, y);
							地牢[y][x].背景类型 = 新背景类型;
							
						}
					}
				}
			
				//生成墙壁();
				//绘制();
			}
			function handleCanvasTouchStart(e) {
				e.preventDefault();
				const touch = e.touches[0];
				touchStartX = touch.clientX;
				touchStartY = touch.clientY;
				touchCurrentX = touch.clientX;
				touchCurrentY = touch.clientY;
				touchStartTime = Date.now();
				if(游戏状态 !== '地图编辑器') {
					isSwiping = true;

					const rect = canvas.getBoundingClientRect();
					const touchX = touch.clientX - rect.left;
					const touchY = touch.clientY - rect.top;
					const 单元格X = Math.floor(当前相机X + touchX / 单元格大小);
					const 单元格Y = Math.floor(当前相机Y + touchY / 单元格大小);

					if (单元格X === 玩家.x && 单元格Y === 玩家.y) {
						if (等待触摸定时器) clearTimeout(等待触摸定时器);
						等待触摸定时器 = setTimeout(() => {
							if (isSwiping && Math.abs(touchCurrentX - touchStartX) < 10 && Math.abs(touchCurrentY - touchStartY) < 10) {
								玩家等待();
								isSwiping = false; 
								clearTimeout(等待触摸定时器);
								等待触摸定时器 = null;
							}
						}, 700);
					}
				}

				if (swipeMoveInterval) {
					clearInterval(swipeMoveInterval);
					swipeMoveInterval = null;
				}
			}

			function handleCanvasTouchMove(e) {
				e.preventDefault();
				if(等待触摸定时器 && (Math.abs(e.touches[0].clientX - touchStartX) > 10 || Math.abs(e.touches[0].clientY - touchStartY) > 10)){
					clearTimeout(等待触摸定时器);
					等待触摸定时器 = null;
				}
				if (!isSwiping) return;

				const touch = e.touches[0];
				touchCurrentX = touch.clientX;
				touchCurrentY = touch.clientY;

				if (swipeMoveInterval === null) {
					processSwipeMove();
					swipeMoveInterval = setInterval(processSwipeMove, 移动间隔);
				}
			}

			function handleCanvasTouchEnd(e) {
				e.preventDefault();
				if(等待触摸定时器){
					clearTimeout(等待触摸定时器);
					等待触摸定时器 = null;
				}
				if (!isSwiping) return;

				isSwiping = false;
				clearInterval(swipeMoveInterval);
				swipeMoveInterval = null;

				const touch = e.changedTouches[0];
				const touchEndX = touch.clientX;
				const touchEndY = touch.clientY;
				const touchEndTime = Date.now();

				const deltaX = touchEndX - touchStartX;
				const deltaY = touchEndY - touchStartY;
				const duration = touchEndTime - touchStartTime;
				const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

				if (distance < swipeThreshold) {
					处理点击(touchEndX, touchEndY);
				}

				touchStartX = 0;
				touchStartY = 0;
			}

			function processSwipeMove() {
				if (!isSwiping) {
					clearInterval(swipeMoveInterval);
					swipeMoveInterval = null;
					return;
				}

				const deltaX = touchCurrentX - touchStartX;
				const deltaY = touchCurrentY - touchStartY;

				if (Math.abs(deltaX) < swipeThreshold && Math.abs(deltaY) < swipeThreshold) {
					return; // 未达到移动阈值
				}

				let moveDx = 0;
				let moveDy = 0;

				if (Math.abs(deltaX) > Math.abs(deltaY)) {
					moveDx = deltaX > 0 ? 1 : -1;
				} else {
					moveDy = deltaY > 0 ? 1 : -1;
				}

				移动玩家(moveDx * 玩家属性.移动步数, moveDy * 玩家属性.移动步数);
			}

			canvas.addEventListener("touchstart", handleCanvasTouchStart);
			canvas.addEventListener("touchmove", handleCanvasTouchMove);
			canvas.addEventListener("touchend", handleCanvasTouchEnd);
			canvas.addEventListener("touchcancel", handleCanvasTouchEnd); // 处理触摸取消事件
			canvas.addEventListener("click", 处理地图单击);
			function 注册全局类() {
			    // --- 基础类 ---
			    window.门 = 门;
			    window.物品 = 物品;
			    window.怪物 = 怪物;
			    window.单元格 = 单元格;
			    window.状态效果 = 状态效果;
			    window.红蓝开关 = 红蓝开关;
			    window.红砖块 = 红砖块;
			    window.蓝砖块 = 蓝砖块;
			    window.刷怪笼 = 刷怪笼;
			    window.传送带 = 传送带;
			    window.巡逻怪物 = 巡逻怪物;
			    window.同步怪物 = 同步怪物;
			    window.绿紫开关 = 绿紫开关;
			    window.绿砖块 = 绿砖块;
			    window.紫砖块 = 紫砖块;
			    window.沉浸式传送门 = 沉浸式传送门;
			    window.卷轴滚动墙 = 卷轴滚动墙;
			
			    // --- 物品子类 ---
			    window.钥匙 = 钥匙;
			    window.金币 = 金币;
			    window.武器类 = 武器类;
			    window.卷轴类 = 卷轴类;
			    window.防御装备类 = 防御装备类;
			    window.棋子 = 棋子;
			    window.药水类 = 药水类;
			    window.宠物 = 宠物;
			    window.重铸台 = 重铸台;
			    window.神秘商人 = 神秘商人;
			    window.探险家 = 探险家;
			    window.祭坛类 = 祭坛类;
			    window.物品祭坛 = 物品祭坛;
			    window.耐久祭坛 = 耐久祭坛;
			    window.背包扩容祭坛 = 背包扩容祭坛;
			    window.寻宝戒指 = 寻宝戒指;
			    window.折跃门 = 折跃门;
			    window.传送门 = 传送门;
			    window.炸弹 = 炸弹;
			    window.旋风物品 = 旋风物品;
			    window.火焰物品 = 火焰物品;
			    window.火把 = 火把;
			    window.毒液物品 = 毒液物品;
			    window.罐子 = 罐子;
			    window.空罐子 = 空罐子;
			    window.泉水 = 泉水;
			    window.书架 = 书架;
			    window.神龛 = 神龛;
			    window.照明弹光源 = 照明弹光源;
			    window.挑战石碑 = 挑战石碑;
			    window.洗身砚 = 洗身砚;
			    window.陷阱基类 = 陷阱基类;
			    window.隐形落石陷阱 = 隐形落石陷阱;
			    window.隐形地刺陷阱 = 隐形地刺陷阱;
			    window.隐形毒气陷阱 = 隐形毒气陷阱;
			    window.远射陷阱 = 远射陷阱;
			    window.隐形失明陷阱 = 隐形失明陷阱;
			    window.召唤怪物陷阱 = 召唤怪物陷阱;
			    window.烈焰触发陷阱 = 烈焰触发陷阱;
			    window.隐形虫洞陷阱 = 隐形虫洞陷阱;
			    window.便携障碍物 = 便携障碍物;
			    window.已放置的障碍物 = 已放置的障碍物;
			    window.旗帜 = 旗帜;
			    window.临时墙壁计时器 = 临时墙壁计时器;
			    window.告示牌 = 告示牌;
			    window.存档点 = 存档点;
			    window.磨刀石 = 磨刀石;
			    window.急救绷带 = 急救绷带;
			    window.照明弹 = 照明弹;
			    window.万能钥匙 = 万能钥匙;
			    window.奖杯物品 = 奖杯物品;
			    window.开关脉冲器 = 开关脉冲器;
			    window.磁铁 = 磁铁;
			    window.蛛网 = 蛛网;
                window.烟雾弹 = 烟雾弹;
                window.烟雾 = 烟雾;
                window.定位器地图 = 定位器地图;
                window.时空罗盘 = 时空罗盘;
			
			    // --- 武器具体子类 ---
			    window.吸血剑 = 吸血剑;
			    window.冰霜法杖 = 冰霜法杖;
			    window.重力锤 = 重力锤;
			    window.剧毒匕首 = 剧毒匕首;
			    window.荆棘鞭 = 荆棘鞭;
			    window.回旋镖 = 回旋镖;
			    window.闪电链法杖 = 闪电链法杖;
			    window.大地猛击锤 = 大地猛击锤;
			    window.穿云箭 = 穿云箭;
			    window.钢制长剑 = 钢制长剑;
			    window.橡木法杖 = 橡木法杖;
			    window.金币手枪 = 金币手枪;
			    window.狙击金币枪 = 狙击金币枪;
			    window.喷火枪 = 喷火枪;
			    window.引雷针护符 = 引雷针护符;
			    window.荆棘种子 = 荆棘种子;
			    window.荆棘丛 = 荆棘丛;
			    window.能量熔炉 = 能量熔炉;
			    window.恐惧魔杖 = 恐惧魔杖;
			    window.斜方刀 = 斜方刀;
			    window.冲撞牛角 = 冲撞牛角;
			    window.护卫种子 = 护卫种子;
			    window.护卫植物 = 护卫植物;
			    window.远射种子 = 远射种子;
			    window.远射植物 = 远射植物;
			    window.能量草 = 能量草;
			    window.吸能种子 = 吸能种子;
			    window.魔法师法杖 = 魔法师法杖;
			    window.大师附魔卷轴 = 大师附魔卷轴;
			    window.小书魔 = 小书魔;
			    window.符文圈 = 符文圈;
			    window.调试工具 = 调试工具;
			    window.渔网 = 渔网;
			    window.渔网陷阱 = 渔网陷阱;
			    window.充能魔杖 = 充能魔杖;
			    window.魔力远射植物 = 魔力远射植物;
			    window.时间卷轴 = 时间卷轴;
			    window.潜行靴子 = 潜行靴子;
			    window.钩索 = 钩索;
			    window.嗜血战斧 = 嗜血战斧;
			    window.毒气瓶 = 毒气瓶;
			    window.毒气 = 毒气;
			    window.陨石法杖 = 陨石法杖;
			    window.神偷手 = 神偷手;
			    window.追踪风弹 = 追踪风弹;
			    window.扫帚=扫帚;
			    window.守卫者盔甲 = 守卫者盔甲;
			    window.死灵法杖 = 死灵法杖;
			
			    // --- 防御装具体子类 ---
			    window.秘银锁甲 = 秘银锁甲;
			    window.钢制板甲 = 钢制板甲;
			    window.锅盖 = 锅盖;
			    window.灵能盾牌 = 灵能盾牌;
			    window.冰盾 = 冰盾;
			
			    // --- 卷轴具体子类 ---
			    window.迅捷卷轴 = 迅捷卷轴;
			    window.神秘卷轴 = 神秘卷轴;
			    window.贪婪卷轴 = 贪婪卷轴;
			    window.清净卷轴 = 清净卷轴;
			    window.附魔卷轴 = 附魔卷轴;
			    window.跃迁卷轴 = 跃迁卷轴;
			    window.真言卷轴 = 真言卷轴;
			    window.湮灭卷轴 = 湮灭卷轴;
			    window.配方卷轴 = 配方卷轴;
			    window.易位卷轴 = 易位卷轴;
			    
			    // --- 饰品具体子类 ---
			    window.饰品 = 饰品;
			    window.陷阱先锋饰品 = 陷阱先锋饰品;
			    window.飞毛腿饰品 = 飞毛腿饰品;
			    window.瞬间移动饰品 = 瞬间移动饰品;
			    window.博士之卷饰品 = 博士之卷饰品;
			    window.恢复之心饰品 = 恢复之心饰品;
			    window.以牙还牙饰品 = 以牙还牙饰品;
			    window.嗅探之鼻饰品 = 嗅探之鼻饰品;
			    
			
			    // --- 药水具体子类 ---
			    window.治疗药水 = 治疗药水;
			    window.能量药水 = 能量药水;
			    window.狂暴药水 = 狂暴药水;
			    window.神龟药水 = 神龟药水;
			    window.隐身药水 = 隐身药水;
			    window.透视药水 = 透视药水;
			
			    // --- 棋子具体子类 ---
			    window.国际象棋车 = 国际象棋车;
			    window.国际象棋马 = 国际象棋马;
			    window.国际象棋象 = 国际象棋象;
			    window.中国象棋炮 = 中国象棋炮;
			
			    // --- 宠物具体子类 ---
			    window.熊猫 = 熊猫;
			    window.水母 = 水母;
			    window.火蜥蜴 = 火蜥蜴;
			    window.魔法水晶 = 魔法水晶;
			
			    // --- 怪物子类 ---
			    window.魔法师 = 魔法师;
			    window.大魔法师 = 大魔法师;
			    window.腐蚀怪物 = 腐蚀怪物;
			    window.盗贼怪物 = 盗贼怪物;
			    window.吸能怪物 = 吸能怪物;
			    window.剧毒云雾怪物 = 剧毒云雾怪物;
			    window.召唤师怪物 = 召唤师怪物;
			    window.幽灵仆从 = 幽灵仆从;
			    window.萨满怪物 = 萨满怪物;
			    window.大史莱姆怪物 = 大史莱姆怪物;
			    window.小史莱姆怪物 = 小史莱姆怪物;
			    window.瞬移怪物 = 瞬移怪物;
			    window.伪装怪物 = 伪装怪物;
			    window.炸弹怪物 = 炸弹怪物;
			    window.盔甲怪物 = 盔甲怪物;
			    window.敏捷怪物 = 敏捷怪物;
			    window.远攻怪物 = 远攻怪物;
			    window.仙人掌怪物 = 仙人掌怪物;
			    window.冰冻怪物 = 冰冻怪物;
			    window.旋风怪物 = 旋风怪物;
			    window.幽灵怪物 = 幽灵怪物;
			    window.旋风 = 旋风;
			    window.恐惧怪物 = 恐惧怪物;
			    window.米诺陶 = 米诺陶;
			    window.超速怪物 = 超速怪物;
			    window.复活怪物 = 复活怪物;
			    window.娃娃怪物 = 娃娃怪物;
			    window.吸血鬼 = 吸血鬼;
			    window.皇家守卫 = 皇家守卫;
			    window.王座守护者 = 王座守护者;
			    window.墓碑 = 墓碑
			    window.分裂怪物 = 分裂怪物;
			    window.巨人怪物 = 巨人怪物;
			    window.巨人部位 = 巨人部位;
			    window.移动弹幕=移动弹幕;
			    window.蜘蛛怪物=蜘蛛怪物;
			    window.骷髅仆从 = 骷髅仆从;
			    window.反弹怪物=反弹怪物;
			    window.蜈蚣怪物 = 蜈蚣怪物;
                window.蜈蚣部位 = 蜈蚣部位;
			}
			           function 获取所有可用的定义() {
			    const 所有物品 = [];
			    const 所有怪物 = [];
			    const 已见物品名 = new Set();
			    const 已见怪物类型 = new Set();
			
			    const 物品池 = 创建物品池();
			    for (const 物品类别 of Object.values(物品池)) {
			        for (const 配置 of 物品类别) {
			            try {
			                const 实例 = new 配置.类({玩家放置:true});
			                if (实例.名称 && !已见物品名.has(实例.名称)) {
			                    所有物品.push(配置);
			                    已见物品名.add(实例.名称);
			                } 
			            } catch (错误) {}
			        }
			    }
			
			    const 怪物池 = 创建怪物池();
			    for (const 怪物类别 of Object.values(怪物池)) {
			        for (const 配置 of 怪物类别) {
			            try {
			                const 实例 = new 配置.类({玩家放置:true});
			                if (实例.类型 && !已见怪物类型.has(实例.类型)) {
			                    所有怪物.push(配置);
			                    已见怪物类型.add(实例.类型);
			                }
			            } catch (错误) {}
			        }
			    }
			
			    const 特殊物品 = [
			        { 类: 渔网陷阱, 品质: 1 }, { 类: 荆棘丛, 品质: 1 },
			        { 类: 火焰物品, 品质: 1 }, { 类: 毒液物品, 品质: 1 },
			        { 类: 旋风物品, 品质: 1 }, { 类: 小书魔, 品质: 4 },
			        { 类: 护卫植物, 品质: 2 },
			        { 类: 远射植物, 品质: 3 }, { 类: 能量草, 品质: 2 },
			        { 类: 大师附魔卷轴, 品质: 5 },
			        { 类: 泉水, 品质: 4 }, { 类: 书架, 品质: 2 },
			        { 类: 灵能盾牌, 品质: 3 }, { 类: 配方卷轴, 品质: 2 },
			        { 类: 国际象棋车, 品质: 1 }, { 类: 国际象棋马, 品质: 1 },
			        { 类: 国际象棋象, 品质: 1 }, { 类: 中国象棋炮, 品质: 1 },
			        { 类: 冲撞牛角, 品质: 5 }, { 类: 魔法师法杖, 品质: 5 },
			
			{ 类: 已放置的障碍物, 品质: 1 },
			{ 类: 传送门, 品质: 5 },
			{ 类: 隐形落石陷阱, 品质: 2 },
			{ 类: 隐形地刺陷阱, 品质: 2 },
			{ 类: 隐形毒气陷阱, 品质: 2 },
			{ 类: 隐形失明陷阱, 品质: 3 },
			{ 类: 召唤怪物陷阱, 品质: 3 },
			{ 类: 烈焰触发陷阱, 品质: 4 },
			{ 类: 隐形虫洞陷阱, 品质: 4 },
			{ 类: 旗帜, 品质: 5 },
			{ 类: 钥匙, 品质: 1 },
			{ 类: 金币, 品质: 1 },
			    ];
			
			    for (const 配置 of 特殊物品) {
			        try {
			            const 实例 = new 配置.类({});
			            if (实例.名称 && !已见物品名.has(实例.名称)) {
			                所有物品.push(配置);
			                已见物品名.add(实例.名称);
			            }
			        } catch (错误) {}
			    }
			
			    const 特殊怪物 = [
			        { 类: 大魔法师, 权重: 5,最小层:10}, { 类: 米诺陶, 权重: 5,最小层:5 },{ 类: 远射陷阱, 权重: 12,最小层:5 },
			        { 类: 小史莱姆怪物, 权重: 11,最小层:5}, { 类: 幽灵仆从, 权重: 11,最小层:5},
			        { 类: 旋风, 权重: 11,最小层:5 }, { 类: 王座守护者, 权重: 1,最小层:15},{ 类: 幽灵怪物, 权重: 12,最小层:5 },{ 类: 巡逻怪物, 权重: 10,最小层:5 },{ 类: 同步怪物, 权重: 10,最小层:5 }
			    ];
			
			    for (const 配置 of 特殊怪物) {
			        try {
			            const 实例 = new 配置.类({});
			            if (实例.类型 && !已见怪物类型.has(实例.类型)) {
			                所有怪物.push(配置);
			                已见怪物类型.add(实例.类型);
			            }
			        } catch (错误) {}
			    }
			
			    return { items: 所有物品, monsters: 所有怪物 };
			}

const 版本信息元素 = document.getElementById("版本信息");
if (版本信息元素) {
    版本信息元素.style.cursor = 'pointer';
    版本信息元素.addEventListener('click', () => {
        versionClickCount++;
        if (versionClickCount >= 7 && !开发者模式) {
            开发者模式 = true;
            显示通知("开发者模式已开启！", "成功", true);
            版本信息元素.style.color = '#4caf50';
            版本信息元素.style.fontWeight = 'bold';
            版本信息元素.textContent += ' (Dev)';
        } else if (!开发者模式) {
            const 剩余点击次数 = 7 - versionClickCount;
            if(剩余点击次数<=3) 显示通知(`再点击 ${剩余点击次数} 次即可开启开发者模式。`, "信息");
            // 进行一个视觉反馈的提供
            gsap.fromTo(版本信息元素, { scale: 1.2 }, { scale: 1, duration: 0.3, ease: 'elastic.out(1, 0.5)' });
        }
    });
}
			function 处理地图点击(e) {
			    e.preventDefault();
			    const touch = e.touches[0];
			    处理点击(touch.clientX, touch.clientY);
			}
			
			function 处理地图单击(e) {
			    处理点击(e.clientX, e.clientY);
			}
			
			//来源对象需要提供应用效果与移除效果（可选）函数
			class 状态效果 {
    constructor(
        类型,
        颜色,
        图标,
        持续时间,
        剩余回合 = null,
        来源 = null,
        关联实体 = null,
        强度 = 1
    ) {
        this.类型 = 类型;
        this.剩余回合 = 剩余回合 || 持续时间;
        this.来源 = 来源;
        this.持续时间 = 持续时间;
        this.关联怪物 = 关联实体; 
        this.颜色 = 颜色;
        this.图标 = 图标;
        this.强度 = 强度;

        if (!this.关联怪物) {
            const 现有效果 = 玩家状态.find(
                (item) => item.类型 === this.类型
            );
            if (现有效果) {
                现有效果.剩余回合 = Math.max(
                    现有效果.剩余回合,
                    this.剩余回合
                );
                现有效果.强度 = Math.min(
                    5,
                    (现有效果.强度 || 1) + (this.强度 || 1)
                );
                现有效果.持续时间 = Math.max(
                    现有效果.持续时间,
                    this.持续时间
                );
                现有效果.进度条实例?.更新({
                    数值:
                        (现有效果.剩余回合 / 现有效果.持续时间) *
                        100,
                    标签:
                        `${现有效果.类型} ${现有效果.剩余回合}回合` +
                        (现有效果.强度 > 1
                            ? ` (强度 ${现有效果.强度})`
                            : ""),
                });
                return;
            }

            玩家状态.push(this);
            this.进度条实例 = new 进度条元素({
                图标: 图标,
                颜色: 颜色,
                初始值: 100,
                标签:
                    `${this.类型} ${this.剩余回合}回合` +
                    (this.强度 > 1 ? ` (强度 ${this.强度})` : ""),
            });
            this.来源?.应用效果();
        } else {
            const 状态表 = (this.关联怪物 instanceof 宠物) ? 宠物状态表 : 怪物状态表;
            const 现有效果 = 状态表.get(this.关联怪物);
            if (现有效果 && 现有效果.类型 === this.类型) {
                现有效果.剩余回合 = Math.max(
                    现有效果.剩余回合,
                    this.剩余回合
                );
                现有效果.强度 = Math.min(
                    5,
                    (现有效果.强度 || 1) + (this.强度 || 1)
                );
                if(this.关联怪物 instanceof 怪物) this.关联怪物.获得效果(现有效果);
                this.更新状态();
                this.剩余回合++;
                return;
            }
            状态表.set(this.关联怪物, this);
            if(this.关联怪物 instanceof 怪物) this.关联怪物.获得效果(this);
        }
    }
    更新状态() {
        let 剩余回合 = this.剩余回合;
        剩余回合 = Math.max(0, 剩余回合 - 1);
        this.剩余回合 = 剩余回合;

        if (this.类型 === "中毒") {
            if (!this.关联怪物) {
                伤害玩家(this.强度 || 1, "中毒");
                添加日志(`你受到 ${this.强度 || 1} 点中毒伤害`, "错误");
            } else if (this.关联怪物 instanceof 宠物) {
                this.关联怪物.受伤(this.强度 || 1, "中毒");
                添加日志(`${this.关联怪物.名称} 受到了 ${this.强度 || 1} 点中毒伤害`, "警告");
            }
        } else if (this.类型 === "腐蚀" && this.关联怪物 instanceof 宠物) {
            const 宠物 = this.关联怪物;
            const 装备 = 宠物.自定义数据.get("装备");
            if (装备) {
                let 发生腐蚀 = false;
                for (const 槽位 in 装备) {
                    const 物品 = 装备[槽位];
                    if (物品 && 物品.自定义数据?.has("耐久") && !物品.自定义数据.get("不可破坏")) {
                        const 原耐久 = 物品.自定义数据.get("耐久");
                        const 新耐久 = Math.max(0, 原耐久 - this.强度);
                        物品.自定义数据.set("耐久", 新耐久);
                        发生腐蚀 = true;
                        if (原耐久 > 0 && 新耐久 <= 0) {
                            添加日志(`${宠物.名称}的${物品.获取名称()}被腐蚀损坏了！`, "错误");
                            装备[槽位] = null;
                        }
                    }
                }
                if (发生腐蚀) {
                    添加日志(`${宠物.名称}的装备被腐蚀了！`, "警告");
                    宠物.更新宠物管理窗口();
                }
            }
        }
        if (this.类型 === "火焰") {
            if (!this.关联怪物) {
                Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).forEach(装备 => {
                    if (装备.材质 === 材料.木质 && 装备.自定义数据?.has("耐久") && !装备.自定义数据.get("不可破坏")) {
                        伤害玩家(this.强度 || 1, "火焰");
                        const 原耐久 = 装备.自定义数据.get("耐久");
                        const 新耐久 = Math.max(0, 原耐久 - 1);
                        装备.自定义数据.set("耐久", 新耐久);
                        if (原耐久 > 0 && 新耐久 === 0) {
                            处理销毁物品(装备.唯一标识, true);
                            显示通知(`${装备.获取名称()} 被火焰烧毁了！`, "错误");
                        }
                    }
                });
                处理燃烧木质卷轴();
                伤害玩家(this.强度 || 1, "火焰");
                添加日志(
                    `你被火焰灼烧，受到 ${this.强度 || 1} 点伤害`,
                    "错误"
                );
                更新装备显示();
            } else if (this.关联怪物 instanceof 宠物) {
                this.关联怪物.受伤(this.强度 || 1, "火焰");
                添加日志(`${this.关联怪物.名称} 被火焰灼烧，受到 ${this.强度 || 1} 点伤害`, "警告");
            }
        }
        if (
            this.类型 === "冻结" &&
            玩家状态.some((s) => s.类型 === "火焰")
        ) {
            this.剩余回合--;
        }
        if (!this.关联怪物) {
            const 百分比 = (剩余回合 / this.持续时间) * 100;
            this.进度条实例?.更新({
                数值: 百分比,
                标签:
                    `${this.类型} ${剩余回合}回合` +
                    (this.强度 > 1 ? ` (强度 ${this.强度})` : ""),
            });
        }

        if (剩余回合 === 0) {
            this.移除状态();
        } else {
            this.来源?.应用效果();
        }
    }
    移除状态() {
        this.来源?.移除效果();

        if (!this.关联怪物) {
            玩家状态 = 玩家状态.filter((item) => item !== this);
        } else {
            const 状态表 = (this.关联怪物 instanceof 宠物) ? 宠物状态表 : 怪物状态表;
            if (状态表.get(this.关联怪物) === this) {
                状态表.delete(this.关联怪物);
            }
        }
        if (this.进度条实例) {
            this.进度条实例.销毁();
            this.进度条实例 = null;
        }
        return;
    }
}
			let 旧编辑器状态
			//处理canvas的点击
			function 处理点击(clientX, clientY) {
			
			
			        if (游戏状态 !== "游戏中" && 游戏状态 !== "图鉴" && 游戏状态 !== "地图编辑器" && 游戏状态 !== "编辑器游玩") return;
			    
			        if (物品点击监听器) {
			物品点击监听器(clientX, clientY);
			return;
			        }
			    
			        if (界面可见性.背包) {
			切换背包显示();
			document.getElementById("浮动提示框").style.display = "none";
			return;
			        } else if (教程提示已显示) {
			关闭教程提示();
			return;
			        } else if (document.getElementById("设置菜单").classList.contains("显示")) {
			切换设置菜单();
			return;
			        } else if (document.getElementById("教程回放窗口").style.display === "block") {
			关闭教程回放窗口();
			return;
			        }
			
			        if (玩家正在放置障碍物) {
			const rect = canvas.getBoundingClientRect();
			const x = clientX - rect.left;
			const y = clientY - rect.top;
			const gridX = 视口偏移X + Math.floor(x / 单元格大小);
			const gridY = 视口偏移Y + Math.floor(y / 单元格大小);
			    
			if (位置是否可用(gridX, gridY)) {
			    const 障碍物实例 = new 已放置的障碍物({});
			    if (放置物品到单元格(障碍物实例, gridX, gridY)) {
			        显示通知("成功放置障碍物！", "成功");
			        const 物品源 = [...玩家背包.values()].find(i => i instanceof 便携障碍物);
			        if (物品源) {
			            物品源.堆叠数量--;
			            if(物品源.堆叠数量 <= 0) {
			                处理销毁物品(物品源.唯一标识, true);
			            }
			            更新背包显示();
			            更新装备显示();
			        }
			    } else {
			        显示通知("无法在此处放置障碍物！", "错误");
			    }
			} else {
			    显示通知("无法在此处放置障碍物！", "错误");
			}
			玩家正在放置障碍物 = false;
			return;
			        }
			        if (游戏状态 === "地图编辑器") return;
			        if (游戏设置.禁用点击移动) return;
			        const rect = canvas.getBoundingClientRect();
			        const x = clientX - rect.left;
			        const y = clientY - rect.top;
			    
			        const gridX = 视口偏移X + Math.floor(x / 单元格大小);
			        const gridY = 视口偏移Y + Math.floor(y / 单元格大小);
			    
					const 目标单元格 = 地牢[gridY]?.[gridX];
					const 是目标楼梯 = 目标单元格 && (目标单元格.类型 === 单元格类型.楼梯下楼 || 目标单元格.类型 === 单元格类型.楼梯上楼);

			        const 全路径 = 广度优先搜索路径(
						玩家.x,
						玩家.y,
						gridX,
						gridY,
						50,
						true,
						false,
						false,
						!是目标楼梯
			        );
			        const 截断路径 = [];
			        for (const 节点 of 全路径) {
			const 房间ID = 房间地图[节点.y][节点.x];
			if (房间ID !== -1 && !已访问房间.has(房间ID)) {
			    截断路径.push(节点);
			    break;
			}
			截断路径.push(节点);
			        }
			        截断路径.shift();
			        if (截断路径.length > 0) {
			moveQueue = 截断路径;
			startAutoMove();
			        }
			    }
			
			class 门 {
			    constructor(配置) {
			        this.唯一标识 = Symbol(
			            Date.now().toString() + prng().toString()
			        );
			        this.类型 = "门"; //常驻类型
			        this.是否上锁 = false;
			        this.房间ID = 配置.关联房间ID;
			        this.所在位置 = 配置.位置; // {x, y}
			
			        // 自动注册到全局列表
			        门实例列表.set(this.唯一标识, this); // 注册逻辑
			    }
			
			    尝试解锁(玩家背包) {
			        return [...玩家背包.values()].some((item) =>
			            item.可交互目标(this)
			        );
			    }
			}
			// 生成玩家实际路径距离图?什么是效率问题,我不懂
			    function 生成玩家距离图(玩家X, 玩家Y) {
			        const 距离图 = Array.from({ length: 地牢大小 }, () =>
			            Array(地牢大小).fill(Infinity)
			        );
			        const 队列 = [];
			        const 方向映射表 = [
			            { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
			            { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
			            { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
			            { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
			        ];
			
			        // 初始化玩家起始位置
			        距离图[玩家Y][玩家X] = 0;
			        队列.push({ x: 玩家X, y: 玩家Y });
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			
			            方向映射表.forEach((方向) => {
			                const 新X = 当前.x + 方向.dx;
			                const 新Y = 当前.y + 方向.dy;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    return;
			
			                const 当前单元格 = 地牢[当前.y][当前.x];
			                const 目标单元格 = 地牢[新Y][新X];
			
			                // 使用与怪物相同的移动规则
			                if (
			                    当前单元格.墙壁[方向.当前墙] ||
			                    目标单元格.墙壁[方向.目标墙] ||
			                    目标单元格.背景类型 === 单元格类型.墙壁 ||
			                    目标单元格.背景类型 === 单元格类型.上锁的门 ||
			                    (目标单元格.关联物品 && (目标单元格.关联物品 instanceof 已放置的障碍物 || (目标单元格.关联物品.类型 === '开关砖' && 目标单元格.关联物品.阻碍怪物)))
			                )
			                    return;
			
			                // 找到更短路径
			                if (距离图[新Y][新X] > 距离图[当前.y][当前.x] + 1) {
			                    距离图[新Y][新X] = 距离图[当前.y][当前.x] + 1;
			                    队列.push({ x: 新X, y: 新Y });
			                }
			            });
			        }
			
			        return 距离图;
			    }
			class 怪物 {
			    constructor(配置 = {}) {
			        this.房间ID =
			            配置.房间ID === undefined ? null : 配置.房间ID;
			        this.x = 配置.x === undefined ? null : 配置.x;
			        this.y = 配置.y === undefined ? null : 配置.y;
			        this.目标路径 = [];
			        this.状态 = 配置.状态 || 怪物状态.休眠;
			        this.基础生命值 = 配置.基础生命值 || 23;
			        this.基础攻击力 = 配置.基础攻击力 || 3;
			        this.移动率 = 配置.移动率 || 0.7;
			        this.图标 = 配置.图标 || 图标映射.怪物;
			        this.类型 = 配置.类型 || "怪物";
			        this.掉落物 =
			            配置.掉落物 ||
			            new 金币({ 数量: Math.floor(prng() * 5) + 1 });
			        this.掉落概率 = 配置.掉落概率 ?? 0.9,
			        this.血条元素 = null;
			        this.受击动画 = false;
			        this.基础攻击范围 = 配置.基础攻击范围 || 1;
			        this.受伤冻结回合 = 配置.受伤冻结回合 || 1;
			        this.基础移动距离 = 配置.基础移动距离 || 1;
			        this.始终追踪玩家 = 配置.始终追踪玩家 || false;
			        this.跟踪距离 = (配置.跟踪距离+(地牢生成方式=='maze'?10:0)) || (15+(地牢生成方式=='maze'?10:0));
			        this.基础颜色 = 配置.颜色 || "#FFFFFF";
			        this.强化 = 配置.强化 || false;
			        this.当前生命值 = 配置.当前生命值 || this.生命值;
			        this.攻击冷却 = 配置.攻击冷却 || 0;
			        this.受伤冻结回合剩余 = 0;
			        this.攻击冷却回合剩余 = 0;
			        this.当前格 = 配置.当前格 ?? null;
			        if (
			            this.房间ID === null &&
			            this.y !== null &&
			            this.x !== null
			        ) {
			            this.房间ID = 房间地图[this.y][this.x];
			        }
			        this.仇恨 = null;
			        this.残血逃跑 = 配置.残血逃跑 ?? true
			        this.携带药水 = 配置.携带药水 || null;
			        this.永久增益 = 配置.永久增益 || [];
			        this.战斗爽 = null;
			    }
			
			    尝试使用药水() {
			    if (!this.携带药水) return false;
			    const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			    const 视野范围 = Math.floor(相机显示边长 / 2) + 3;
			    if (玩家距离 > 视野范围) return false;
			
			    if (this.药水使用冷却 === undefined) {
			        this.药水使用冷却 = 2;
			    }
			    if (this.药水使用冷却 > 0) {
			        this.药水使用冷却--;
			        return false;
			    }
			
			    let 使用时机 = false;
			    const 药水类型 = this.携带药水.类型;
			
			    if (药水类型 === '一次性治疗' && this.当前生命值 / this.生命值 < 0.2) {
			        使用时机 = true;
			        this.当前生命值 = Math.min(this.生命值, this.当前生命值 + this.携带药水.值);
			        添加日志(`${this.类型} 使用了治疗药水，恢复了 ${this.携带药水.值} 点生命！`, '警告');
			        计划显示格子特效([{ x: this.x, y: this.y }], '00FF00');
			    } else if (药水类型 === '永久强化' && !this.强化 && this.当前生命值 / this.生命值 < 0.7) {
			        使用时机 = true;
			        this.强化 = true;
			        this.当前生命值 = this.生命值;
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标, 值: this.携带药水.值 });
			        添加日志(`${this.类型} 使用了强化药水，变得更强了！`, '警告');
			        计划显示格子特效([{ x: this.x, y: this.y }], 'FF0000');
			    } else if (药水类型 === '永久隐身' && this.当前生命值 / this.生命值 < 0.4 && !this.永久增益.some(b => b.类型 === '永久隐身')) {
			        使用时机 = true;
			        this.图标 = ' ';
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标 });
			        添加日志(`${this.类型} 使用了隐身药水，消失了！`, '警告');
			    } else if (药水类型 === '永久速度' && 玩家距离 > this.跟踪距离 / 2 && !this.永久增益.some(b => b.类型 === '永久速度')) {
			        使用时机 = true;
			        this.永久增益.push({ 类型: '永久速度', 图标: this.携带药水.图标, 值: this.携带药水.值 });
			        添加日志(`${this.类型} 使用了速度药水，移动更快了！`, '警告');
			    } else if (药水类型 === '永久抗火' && 怪物状态表.get(this)?.类型 === '火焰' && !this.永久增益.some(b => b.类型 === '永久抗火')) {
			        使用时机 = true;
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标 });
			        怪物状态表.get(this).移除状态();
			        添加日志(`${this.类型} 获得了永久火焰抗性！`, '警告');
			    } else if (药水类型 === '永久抗毒' && 怪物状态表.get(this)?.类型 === '中毒' && !this.永久增益.some(b => b.类型 === '永久抗毒')) {
			        使用时机 = true;
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标 });
			        怪物状态表.get(this).移除状态();
			        添加日志(`${this.类型} 获得了永久剧毒抗性！`, '警告');
			    } else if (药水类型 === '永久解冻' && 怪物状态表.get(this)?.类型 === '冻结' && !this.永久增益.some(b => b.类型 === '永久解冻')) {
			        使用时机 = true;
			        怪物状态表.get(this)?.移除状态();
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标 });
			        怪物状态表.get(this).移除状态();
			        添加日志(`${this.类型} 解除了冻结并获得了永久抗性！`, '警告');
			    } else if (药水类型 === '永久力量' && !this.永久增益.some(b => b.类型 === '永久力量')) {
			        使用时机 = true;
			        this.永久增益.push({ 类型: 药水类型, 图标: this.携带药水.图标, 值: this.携带药水.值 });
			        添加日志(`${this.类型} 的力量永久增强了！`, '警告');
			    }
			
			    if (使用时机) {
			        this.携带药水 = null;
			        this.绘制血条();
			        return true;
			    }
			    return false;
			}
			
			尝试逃跑() {
			    if (this.当前生命值 / this.生命值 > 0.3 || !this.残血逃跑) {
			        this.目标陷阱 = null
			        return false;
			    }
			    if (this.战斗爽 === null) {
			        if (prng()<0.5) {
			            this.战斗爽=false;
			        } else {
			            this.战斗爽=true;
			        }
			    } else {
			        if (this.战斗爽) return;
			    }
			    let 最佳陷阱路径 = null;
			    if (!this.目标陷阱||!地牢[this.目标陷阱.y][this.目标陷阱.x]?.关联物品?.自定义数据?.get('已触发')){
			
			    const 未触发陷阱列表 = [];
			    const 半径 = 25;
			        const 中心X = this.x;
			        const 中心Y = this.y;
			
			        for (let y = 中心Y - 半径; y <= 中心Y + 半径; y++) {
			            for (let x = 中心X - 半径; x <= 中心X + 半径; x++) {
			            let cell=地牢?.[y]?.[x]
			            if (cell && cell.关联物品 && cell.关联物品 instanceof 陷阱基类 && !cell.关联物品.自定义数据.get('已触发')) {
			                未触发陷阱列表.push(cell.关联物品);
			            }
			         }
			    }
			    
			
			    最佳陷阱路径 = null;
			    let 最短距离到陷阱 = Infinity;
			
			    if (未触发陷阱列表.length > 0) {
			        for (const 陷阱 of 未触发陷阱列表) {
			            const 路径到陷阱 = this.计算目标路径(陷阱.x, 陷阱.y);
			            if (路径到陷阱 && 路径到陷阱.length > 0 && 路径到陷阱.length < 最短距离到陷阱) {
			                最短距离到陷阱 = 路径到陷阱.length;
			                最佳陷阱路径 = 路径到陷阱;
			            }
			        }
			    }
			    添加日志(`${this.类型} 试图引诱你到陷阱处！`, '警告');
			    } else {
			    
			    最佳陷阱路径 = this.计算目标路径(this.目标陷阱.x, this.目标陷阱.y);
			    }
			
			    if (最佳陷阱路径) {
			        this.目标路径 = 最佳陷阱路径;
			        this.目标陷阱 = this.目标路径.slice(-1)[0];
			        
			        
			        return true;
			    } else {
			        const 逃离点 = this.选择逃离目标(玩家.x, 玩家.y, this.跟踪距离);
			        if (逃离点) {
			            this.目标路径 = this.计算目标路径(逃离点.x, 逃离点.y);
			            if (this.目标路径 && this.目标路径.length > 0) {
			                //添加日志(`${this.类型} 正在逃跑！`, '警告');
			                
			                return true;
			            }
			        }
			    }
			    this.战斗爽 = true
			    return false;
			}
			
			    绘制增益效果(屏幕X, 屏幕Y) {
			        if (this.永久增益.length === 0) return;
			        ctx.font = `${单元格大小 * 0.4}px color-emoji`;
			        ctx.textAlign = 'right';
			        ctx.textBaseline = 'top';
			        const 偏移X = 单元格大小 * 0.45;
			        const 偏移Y = -单元格大小 * 0.45;
			        this.永久增益.forEach((增益, 索引) => {
			            if (!增益.图标) return;
			            const x = 屏幕X + 偏移X;
			            const y = 屏幕Y + 偏移Y + (索引 * 单元格大小 * 0.4);
			            ctx.fillText(增益.图标, x, y);
			        });
			    }
			    
			    追踪玩家() {
			        if (this.受伤冻结回合剩余 > 0) {
			            this.受伤冻结回合剩余--;
			            return;
			        }
			        const 当前距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (当前距离 <= 1) return;
			        const 移动选项 = [];
			        const 方向 = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
			        for(const {dx, dy} of 方向) {
			            const 新X = this.x + dx;
			            const 新Y = this.y + dy;
			            if(新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;
			            const 新距离 = Math.abs(新X - 玩家.x) + Math.abs(新Y - 玩家.y);
			            const 目标单元格 = 地牢[新Y]?.[新X];
			            if (新距离 < 当前距离 && 目标单元格 && ![单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.背景类型) && !(目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物) && !目标单元格.关联怪物) {
			                移动选项.push({dx, dy, 新距离});
			            }
			        }
			        if (移动选项.length === 0) return;
			        移动选项.sort((a,b) => a.新距离 - b.新距离);
			        const 最佳移动 = 移动选项[0];
			        const 旧X = this.x;
			        const 旧Y = this.y;
			        this.恢复背景类型();
			        this.x += 最佳移动.dx;
			        this.y += 最佳移动.dy;
			        this.保存新位置类型(this.x, this.y);
			        地牢[this.y][this.x].类型 = 单元格类型.怪物;
			        地牢[this.y][this.x].关联怪物 = this;
			        怪物动画状态.set(this, { 旧逻辑X: 旧X, 旧逻辑Y: 旧Y, 目标逻辑X: this.x, 目标逻辑Y: this.y, 视觉X: 旧X, 视觉Y: 旧Y, 动画开始时间: Date.now(), 正在动画: true, });
			        const 开关 = 地牢[this.y][this.x].关联物品;
			        if (开关 && (开关 instanceof 红蓝开关 || 开关 instanceof 绿紫开关)) {
			            开关.使用();
			        }
			    }
			    尝试添加随机词条到掉落物(物品实例) {
			        if (
			            !(
			                物品实例 instanceof 武器类 ||
			                物品实例 instanceof 防御装备类
			            )
			        ) {
			            return;
			        }
			        if (!物品实例.自定义数据) {
			            物品实例.自定义数据 = new Map();
			        }
			        let 现有词条 = 物品实例.自定义数据.get("fusedBuffs") || [];
			        const 最大词条数 =
			            1 +
			            Math.floor(prng() * 2) *
			                (玩家属性.掉落倍率 > 1 ? 2 : 1);
			        let 添加词条数 = 0;
			
			        const 通用词条池 = [
			            融合Buff类型.耐久加成,
			            融合Buff类型.耐久倍率,
			        ];
			        const 武器词条池 = [
			            融合Buff类型.攻击加成,
			            融合Buff类型.攻击倍率,
			            融合Buff类型.冷却缩减,
			            融合Buff类型.冷却倍率,
			            融合Buff类型.范围加成,
			            融合Buff类型.中毒几率,
			            融合Buff类型.火焰伤害,
			            融合Buff类型.冰冻几率,
			            融合Buff类型.生命偷取,
			            融合Buff类型.暴击几率,
			            融合Buff类型.暴击伤害倍率,
			            融合Buff类型.击退几率,
			            融合Buff类型.攻击吸能,
			            融合Buff类型.幸运一击,
			        ];
			        const 防具词条池 = [
			            融合Buff类型.防御加成,
			            融合Buff类型.防御倍率,
			            融合Buff类型.闪避几率,
			            融合Buff类型.固定伤害减免,
			            融合Buff类型.受击回能,
			            融合Buff类型.中毒几率,
			        ];
			
			        let 适用的额外词条池 = [];
			        if (物品实例 instanceof 武器类) {
			            适用的额外词条池 = [...武器词条池];
			        } else if (物品实例 instanceof 防御装备类) {
			            适用的额外词条池 = [...防具词条池];
			        }
			
			        const 最终词条池 = [...通用词条池, ...适用的额外词条池];
			        if (最终词条池.length === 0) return;
			
			        for (let i = 0; i < 5 && 添加词条数 < 最大词条数; i++) {
			            if (最终词条池.length === 0) break;
			            const 随机词条类型 =
			                最终词条池[
			                    Math.floor(prng() * 最终词条池.length)
			                ];
			            let 词条数值 = 0;
			            let 数值系数 = 0.2 + prng() * 0.4;
			            if (玩家属性.掉落倍率 > 1)
			                数值系数 *= 1 + (玩家属性.掉落倍率 - 1) * 0.5;
			
			            switch (随机词条类型) {
			                case 融合Buff类型.攻击加成:
			                    词条数值 = Math.round(
			                        (1 + prng() * 1) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.攻击倍率:
			                    词条数值 = Math.min(
			                        0.15,
			                        (0.02 + prng() * 0.05) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.耐久加成:
			                    词条数值 = Math.round(
			                        (3 + prng() * 7) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.耐久倍率:
			                    词条数值 = Math.min(
			                        0.75,
			                        (0.05 + prng() * 0.1) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.范围加成:
			                    if (
			                        物品实例 instanceof 武器类 &&
			                        物品实例.自定义数据.has("攻击范围") &&
			                        物品实例.自定义数据.get("攻击范围") > 1 &&
			                        prng() < 0.5
			                    )
			                        词条数值 = Math.round(1 * 数值系数);
			                    break;
			                case 融合Buff类型.冷却缩减:
			                    if (
			                        物品实例 instanceof 武器类 &&
			                        物品实例.自定义数据.has("冷却回合") &&
			                        物品实例.自定义数据.get("冷却回合") > 0 &&
			                        prng() < 0.5
			                    )
			                        词条数值 = Math.round(1 * 数值系数);
			                    break;
			                case 融合Buff类型.冷却倍率:
			                    if (
			                        物品实例 instanceof 武器类 &&
			                        物品实例.自定义数据.has("冷却回合") &&
			                        物品实例.自定义数据.get("冷却回合") > 0 &&
			                        prng() < 0.5
			                    )
			                        词条数值 = Math.min(
			                            0.25,
			                            (0.03 + prng() * 0.08) * 数值系数
			                        );
			                    break;
			                case 融合Buff类型.防御加成:
			                    词条数值 = Math.round(
			                        (1 + prng() * 0.5) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.防御倍率:
			                    词条数值 = Math.min(
			                        0.15,
			                        (0.02 + prng() * 0.05) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.固定伤害减免:
			                    词条数值 = Math.round(
			                        prng() * 1 * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.受击回能:
			                    词条数值 = Math.round(
			                        (1 + prng() * 3) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.中毒几率:
			                case 融合Buff类型.冰冻几率:
			                case 融合Buff类型.生命偷取:
			                case 融合Buff类型.击退几率:
			                case 融合Buff类型.攻击吸能:
			                case 融合Buff类型.火焰伤害:
			                case 融合Buff类型.闪避几率:
			                    词条数值 = Math.min(
			                        0.2,
			                        (0.03 + prng() * 0.1) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.暴击几率:
			                    词条数值 = Math.min(
			                        0.1,
			                        (0.01 + prng() * 0.05) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.暴击伤害倍率:
			                    词条数值 = Math.min(
			                        0.5,
			                        (0.05 + prng() * 0.2) * 数值系数
			                    );
			                    break;
			                case 融合Buff类型.幸运一击:
			                    词条数值 = Math.min(
			                        0.08,
			                        (0.01 + prng() * 0.03) * 数值系数
			                    );
			                    break;
			            }
			
			            if (词条数值 > 0 && 随机词条类型) {
			                const 已有同类词条 = 现有词条.find(
			                    (b) => b.type === 随机词条类型
			                );
			                if (已有同类词条) {
			                    if (
			                        typeof 已有同类词条.value === "number" &&
			                        typeof 词条数值 === "number"
			                    ) {
			                        已有同类词条.value += 词条数值;
			
			                        let 上限 = 1.0;
			                        if (
			                            随机词条类型.includes("MULTIPLIER") ||
			                            随机词条类型.includes("CHANCE") ||
			                            随机词条类型.includes("STEAL") ||
			                            随机词条类型.includes("PERCENT")
			                        ) {
			                            上限 =
			                                {
			                                    [融合Buff类型.攻击倍率]: 0.3,
			                                    [融合Buff类型.冷却倍率]: 0.5,
			                                    [融合Buff类型.耐久倍率]: 0.75,
			                                    [融合Buff类型.防御倍率]: 0.3,
			                                    [融合Buff类型.中毒几率]: 0.4,
			                                    [融合Buff类型.冰冻几率]: 0.4,
			                                    [融合Buff类型.生命偷取]: 0.3,
			                                    [融合Buff类型.击退几率]: 0.4,
			                                    [融合Buff类型.攻击吸能]: 0.3,
			                                    [融合Buff类型.火焰伤害]: 0.4,
			                                    [融合Buff类型.闪避几率]: 0.3,
			                                    [融合Buff类型.暴击几率]: 0.2,
			                                    [融合Buff类型.暴击伤害倍率]: 1.0,
			                                    [融合Buff类型.幸运一击]: 0.15,
			                                }[随机词条类型] || 1.0;
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                上限
			                            );
			                        } else if (
			                            随机词条类型 === 融合Buff类型.冷却缩减
			                        ) {
			                            const 武器基础冷却 =
			                                物品实例.自定义数据.get(
			                                    "冷却回合"
			                                ) || 1;
			                            上限 =
			                                武器基础冷却 > 0
			                                    ? 武器基础冷却 - 1
			                                    : 0;
			                            已有同类词条.value = Math.max(
			                                0,
			                                Math.min(已有同类词条.value, 上限)
			                            );
			                            上限 = 99999;
			                        } else if (
			                            随机词条类型 ===
			                            融合Buff类型.固定伤害减免
			                        ) {
			                            上限 = 3;
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                上限
			                            );
			                        } else if (
			                            随机词条类型 === 融合Buff类型.受击回能
			                        ) {
			                            上限 = 10;
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                上限
			                            );
			                        } else if (
			                            随机词条类型 ===
			                                融合Buff类型.范围加成 &&
			                            物品实例.自定义数据.has("攻击范围")
			                        ) {
			                            上限 = Math.floor(
			                                物品实例.自定义数据.get(
			                                    "攻击范围"
			                                ) * 0.3
			                            );
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                上限
			                            );
			                        } else if (随机词条类型.includes("加成")) {
			                            已有同类词条.value = Math.min(
			                                已有同类词条.value,
			                                5
			                            );
			                        }
			                    }
			                } else {
			                    现有词条.push({
			                        type: 随机词条类型,
			                        value: 词条数值,
			                    });
			                }
			                添加词条数++;
			
			                const 移除索引 = 最终词条池.indexOf(随机词条类型);
			                if (移除索引 > -1) {
			                    最终词条池.splice(移除索引, 1);
			                }
			            }
			        }
			        if (现有词条.length > 0) {
			            物品实例.自定义数据.set("fusedBuffs", 现有词条);
			            const 耐久倍率 = 现有词条.find(b => b.type === 'DURABILITY_MULTIPLIER');
			 if (耐久倍率) {
			     物品实例.自定义数据.set('原耐久',Math.round(物品实例.自定义数据.get('原耐久')*(1+耐久倍率.value)*10)/10);
			     物品实例.自定义数据.set('耐久',Math.round(物品实例.自定义数据.get('耐久')*(1+耐久倍率.value)*10)/10);
			 }
			 const 耐久加成 = 现有词条.find(b => b.type === 'DURABILITY_BONUS');
			 if (耐久加成) {
			     物品实例.自定义数据.set('原耐久',物品实例.自定义数据.get('原耐久')+耐久加成.value);
			     物品实例.自定义数据.set('耐久',物品实例.自定义数据.get('耐久')+耐久加成.value);
			 }
			        }
			    }
			    计算路径(目标X, 目标Y) {
			    const 目标距离 = Math.floor(this.攻击范围 / 2);

        
        let 目标距离图 = 玩家距离图
        if(目标X!==玩家.x||目标Y!==玩家.y) 目标距离图 = 生成玩家距离图(目标X, 目标Y);

        if (目标距离图[this.y][this.x] === 目标距离) {
            跟踪玩家怪物数++;
            return [];
        }

        const 开放列表 = [];
        const 关闭列表 = new Set();
        const 方向映射表 = [
            { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
            { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
            { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
            { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
        ];

        const 起点节点 = {
            x: this.x,
            y: this.y,
            g: 0,
            parent: null,
        };
        开放列表.push(起点节点);
        关闭列表.add(`${起点节点.x},${起点节点.y}`);

        while (开放列表.length > 0) {
            let 当前节点 = 开放列表.shift();
            if (目标距离图[当前节点.y][当前节点.x] === 目标距离) {
                const 路径 = [];
                let 节点 = 当前节点;
                while (节点.parent) {
                    路径.push(节点);
                    节点 = 节点.parent;
                }
                return 路径.reverse();
            }

            方向映射表.forEach((方向) => {
                const 新X = 当前节点.x + 方向.dx;
                const 新Y = 当前节点.y + 方向.dy;

                if (
                    新X < 0 ||
                    新X >= 地牢大小 ||
                    新Y < 0 ||
                    新Y >= 地牢大小
                )
                    return;

                const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                const 目标单元格 = 地牢[新Y][新X];

                if (
                    当前单元格.墙壁[方向.当前墙] ||
                    目标单元格.墙壁[方向.目标墙] ||
                    目标单元格.背景类型 === 单元格类型.墙壁 ||
                    目标单元格.背景类型 === 单元格类型.上锁的门 ||
                    (目标单元格.关联物品?.类型 === '开关砖' && 目标单元格.关联物品?.阻碍怪物) ||
                    开放列表.length > this.跟踪距离 || 目标单元格.关联物品 instanceof 烟雾
                )
                    return;

                const 移动方向 = getMoveDirection(
                    当前节点.x,
                    当前节点.y,
                    新X,
                    新Y
                );
                if (
                    目标单元格.isOneWay &&
                    移动方向 !== 目标单元格.oneWayAllowedDirection
                )
                    return;

                const 位置键 = `${新X},${新Y}`;
                if (!关闭列表.has(位置键)) {
                    关闭列表.add(位置键);
                    开放列表.push({
                        x: 新X,
                        y: 新Y,
                        g: 当前节点.g + 1,
                        parent: 当前节点,
                    });
                }
            });
        
        
    }
    return null;
}
计算目标路径(目标X, 目标Y) {
    //if (地牢生成方式 === 'cave') {
        const 路径 = A星寻路(this.x, this.y, 目标X, 目标Y,999);
        
        if (路径?.length>0) {
            路径.shift()
            return 路径;
        }
        return null;
    //} else {
        const 开放列表 = [];
        const 关闭列表 = new Set();
        const 方向映射表 = [
            {
                dx: 1,
                dy: 0,
                当前墙: "右",
                目标墙: "左",
            },
            {
                dx: -1,
                dy: 0,
                当前墙: "左",
                目标墙: "右",
            },
            {
                dx: 0,
                dy: 1,
                当前墙: "下",
                目标墙: "上",
            },
            {
                dx: 0,
                dy: -1,
                当前墙: "上",
                目标墙: "下",
            },
        ];

        const 起点节点 = {
            x: this.x,
            y: this.y,
            g: 0,
            parent: null,
        };
        开放列表.push(起点节点);

        while (开放列表.length > 0) {
            let 当前节点 = 开放列表.shift();

            if (当前节点.x === 目标X && 当前节点.y === 目标Y) {
                const 路径 = [];
                while (当前节点.parent) {
                    路径.push(当前节点);
                    当前节点 = 当前节点.parent;
                }
                return 路径.reverse();
            }

            方向映射表.forEach((方向) => {
                const 新X = 当前节点.x + 方向.dx;
                const 新Y = 当前节点.y + 方向.dy;
                if (
                    新X < 0 ||
                    新X >= 地牢大小 ||
                    新Y < 0 ||
                    新Y >= 地牢大小
                )
                    return;
                const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                const 目标单元格 = 地牢[新Y][新X];
                const 当前墙阻挡 = 当前单元格.墙壁[方向.当前墙];
                const 目标墙阻挡 = 目标单元格.墙壁[方向.目标墙];
                const 硬阻挡 =
                    目标单元格.背景类型 === 单元格类型.墙壁 ||
                    目标单元格.背景类型 === 单元格类型.上锁的门 || (目标单元格.关联物品?.类型 === '开关砖' && 目标单元格.关联物品?.阻碍怪物) || 目标单元格.关联物品 instanceof 烟雾

                if (
                    当前墙阻挡 ||
                    目标墙阻挡 ||
                    硬阻挡 ||
                    开放列表.length > this.跟踪距离
                )
                    return;

                const 移动方向 = getMoveDirection(
                    当前节点.x,
                    当前节点.y,
                    新X,
                    新Y
                );
                if (
                    目标单元格.isOneWay &&
                    移动方向 !== 目标单元格.oneWayAllowedDirection
                )
                    return;

                const 位置键 = `${新X},${新Y}`;
                if (!关闭列表.has(位置键)) {
                    开放列表.push({
                        x: 新X,
                        y: 新Y,
                        g: 当前节点.g + 1,
                        parent: 当前节点,
                    });
                    关闭列表.add(位置键);
                }
            });
       // }
        return null;
    }
}
			
			    寻找最近怪物目标() {
			        let 最近距离 = Infinity;
			        let 最近目标 = null;
			
			        所有怪物.forEach((其他怪物) => {
			            if (
			                其他怪物 === this ||
			                其他怪物.当前生命值 <= 0 ||
			                其他怪物.状态 === 怪物状态.休眠 ||
			                ["冻结", "魅惑"].includes(
			                    怪物状态表.get(其他怪物)?.类型
			                ) ||
			                其他怪物 instanceof 大魔法师
			            )
			                return;
			
			            const 距离 =
			                Math.abs(this.x - 其他怪物.x) +
			                Math.abs(this.y - 其他怪物.y);
			            if (
			                距离 < 最近距离 &&
			                检查视线(this.x, this.y, 其他怪物.x, 其他怪物.y)
			            ) {
			                最近距离 = 距离;
			                最近目标 = 其他怪物;
			            }
			        });
			        this.魅惑目标怪物 = 最近目标;
			        return 最近目标
			            ? { x: 最近目标.x, y: 最近目标.y }
			            : { x: this.x, y: this.y };
			    }
			    寻找并远离危险炸弹() {
			        const 危险炸弹列表 = [];
			        所有计时器.forEach(计时器 => {
			            if (计时器 instanceof 炸弹 && 计时器.自定义数据.get('来源') === '怪物') {
			                const 距离 = Math.abs(this.x - 计时器.x) + Math.abs(this.y - 计时器.y);
			                if (距离 <= (计时器.自定义数据.get('爆炸范围') || 3)) {
			                    危险炸弹列表.push(计时器);
			                }
			            }
			        });
			
			        if (危险炸弹列表.length > 0) {
			            const 最近炸弹 = 危险炸弹列表.sort((a,b) => (Math.abs(this.x - a.x) + Math.abs(this.y - a.y)) - (Math.abs(this.x - b.x) + Math.abs(this.y - b.y)))[0];
			            const 逃离点 = this.选择逃离目标(最近炸弹.x, 最近炸弹.y, 10);
			            if (逃离点) {
			                this.目标路径 = this.计算路径(逃离点.x, 逃离点.y);
			                if (this.目标路径 && this.目标路径.length > 0) {
			                     添加日志(`${this.类型} 正在逃离炸弹！`, "信息");
			                     return true;
			                }
			            }
			        }
			        return false;
			    }
			    尝试移动() {
			        if (this.尝试使用药水()) return;
			        this.尝试逃跑()
			        let 移动率 = this.移动率;
			        const 我的状态 = 怪物状态表.get(this);
			        switch (我的状态?.类型) {
			            case "冻结":
			                if (!当前天气效果.includes("严寒")) return;
			            case "火焰":
			                this.受伤(3, "火焰");
			                this.受伤冻结回合剩余 = 0;
			                break;
			            case "魅惑":
			                移动率 = 1;
			                break;
			            case "缓慢":
			                移动率 = 0.5;
			                break;
			            case "中毒":
			                this.受伤(我的状态.强度 || 1, "中毒");
			                this.受伤冻结回合剩余 = 0;
			                break;
			            case "恐惧":
			                this.逃离目标 = { x: 玩家.x, y: 玩家.y };
			                const 逃离点 = this.选择逃离目标(
			                    玩家.x,
			                    玩家.y,
			                    this.跟踪距离
			                );
			                if (逃离点) {
			                    this.目标路径 = this.计算路径(
			                        逃离点.x,
			                        逃离点.y
			                    );
			                } else {
			                    this.目标路径 = [];
			                }
			                break;
			            case "牵制":
			                return;
			                break;
			            case "眩晕":
			                return;
			                break;
			                
			        }
			        if (this.当前生命值 <= 0) return;
			        if (房间地图[玩家.y][玩家.x] === 0 && 游戏状态==='游戏中' && !是否是自定义关卡) return;
			        if (!this.目标路径) return;
			        if (this.受伤冻结回合剩余 > 0) {
			            this.受伤冻结回合剩余 -= 1;
			        } else {
			            if (
			                this.跟踪距离 >= this.目标路径.length &&
			                怪物状态表.get(this)?.类型 !== "魅惑"
			            ) {
			                跟踪玩家怪物数++;
			            }
			            if (
			                (this.目标路径.length === 0 ||
			                (prng() > 移动率 && !切换动画) ||
			                (this.跟踪距离 < this.通向目标路径.length || this.目标路径.length > this.通向目标路径.length)) &&
			                !this.目标陷阱
			            ) {
			                this.追击玩家中 = false;
			                return;
			            }
			            if (!(this instanceof 炸弹怪物)) this.寻找并远离危险炸弹();
			            const 旧X = this.x;
			            const 旧Y = this.y;
			            const 下一步 =
			                this.目标路径[
			                    Math.min(
			                        this.移动距离 - 1,
			                        this.目标路径.length - 1
			                    )
			                ];
			            let 最终位置 = null;
			            if (下一步) {
			                const dx = 下一步.x - this.x;
			                const dy = 下一步.y - this.y;
			                最终位置 = this.规划移动路径(dx, dy);
			                if (最终位置) {
			                    const 移动步数 = this.通向目标路径.findIndex(p => p.x === 最终位置.x && p.y === 最终位置.y);
			                    if (移动步数 !== -1 && this.通向目标路径) {
			                        this.通向目标路径 = this.通向目标路径.slice(移动步数 + 1);
			                    }
			                    }
			            }
			
			            if (最终位置) {
			                const 目标单元格实例 =
			                    地牢[最终位置.y]?.[最终位置.x];
			                if (
			                    目标单元格实例 &&
			                    目标单元格实例.关联物品 instanceof 罐子 &&
			                    !目标单元格实例.关联物品.自定义数据.get(
			                        "已破碎"
			                    )
			                ) {
			                    const 罐子要碎了 = 目标单元格实例.关联物品;
			                    罐子要碎了.破碎并释放内容(this);
			
			                    if (
			                        地牢[最终位置.y]?.[最终位置.x]?.关联怪物 &&
			                        地牢[最终位置.y][最终位置.x].关联怪物 !==
			                            this
			                    ) {
			                        if (this.接受萨满治疗) {
			                            计划显示格子特效(
			                                [{ x: this.x, y: this.y }],
			                                "00FF00",
			                                0
			                            );
			                            this.接受萨满治疗 = false;
			                        }
			                        this.绘制血条();
			                        return;
			                    }
			                }
			                if (
			                    this instanceof 大魔法师 &&
			                    房间地图[最终位置.y][最终位置.x] === -1
			                ) {
			                    if (this.接受萨满治疗) {
			                        计划显示格子特效(
			                            [{ x: this.x, y: this.y }],
			                            "00FF00",
			                            0
			                        );
			                        this.接受萨满治疗 = false;
			                    }
			                    this.绘制血条();
			                    return;
			                }
			
			                this.恢复背景类型();
			                this.保存新位置类型(最终位置.x, 最终位置.y);
			                this.x = 最终位置.x;
			                this.y = 最终位置.y;
			                地牢[this.y][this.x].类型 = 单元格类型.怪物;
			                地牢[this.y][this.x].关联怪物 = this;
			                this.处理地形效果();
			                怪物动画状态.set(this, {
			                    旧逻辑X: 旧X,
			                    旧逻辑Y: 旧Y,
			                    目标逻辑X: this.x,
			                    目标逻辑Y: this.y,
			                    视觉X: 旧X,
			                    视觉Y: 旧Y,
			                    动画开始时间: Date.now(),
			                    正在动画: true,
			                });
			            }
			        }
			        if (this.接受萨满治疗) {
			            计划显示格子特效(
			                [{ x: this.x, y: this.y }],
			                "00FF00",
			                0
			            );
			            this.接受萨满治疗 = false;
			        }
			        this.绘制血条();
			    }
			    处理地形效果() {
			        const 开关 = 地牢[this.y][this.x]?.关联物品;
			        if (开关 && (开关 instanceof 红蓝开关 || 开关 instanceof 绿紫开关)) {
			            开关.使用();
			        }
			        if (地牢[this.y][this.x]?.关联物品 instanceof 火焰物品) {
			            const 火焰实例移动后 = 地牢[this.y][this.x].关联物品;
			            const 强度移动后 =
			                火焰实例移动后.自定义数据.get("火焰强度") ?? 1;
			            const 持续移动后 =
			                火焰实例移动后.自定义数据.get("火焰持续") ?? 3;
			            new 状态效果(
			                "火焰",
			                效果颜色编号映射[效果名称编号映射.火焰],
			                "火",
			                持续移动后,
			                null,
			                null,
			                this,
			                强度移动后
			            );
			            添加日志(`${this.类型} 踩到了火焰，着火了！`, "警告");
			        } else if (
			            地牢[this.y][this.x]?.关联物品 instanceof 荆棘丛
			        ) {
			            const 伤害量 =
			                地牢[this.y][this.x]?.关联物品?.自定义数据.get(
			                    "伤害"
			                );
			            this.受伤(伤害量, "荆棘丛");
			            添加日志(
			                `${this.类型} 踩进了荆棘丛，受到 ${伤害量} 点伤害！`,
			                "警告"
			            );
			            地牢[this.y][this.x].关联物品.发挥效果 = true;
			            if (
			                prng() <
			                地牢[this.y][this.x]?.关联物品?.自定义数据.get(
			                    "减速概率"
			                )
			            ) {
			                new 状态效果(
			                    "缓慢",
			                    效果颜色编号映射[效果名称编号映射.缓慢],
			                    "慢",
			                    地牢[this.y][this.x]?.关联物品?.自定义数据.get(
			                        "减速回合"
			                    ),
			                    null,
			                    null,
			                    this,
			                    1
			                );
			                添加日志(
			                    `${this.类型} 被荆棘缠绕，移动变慢了！`,
			                    "警告"
			                );
			            }
			        } else if (地牢[this.y][this.x]?.关联物品) {
			            地牢[this.y][this.x]?.关联物品?.当被收集(this);
			        }
			    }
			    规划移动路径() {
			        let 当前位置 = { x: this.x, y: this.y };
			        let 有效位置 = null;
			        let 可行距离 = this.移动距离 + 1;
			        for (
			            let i = 0;
			            i < Math.min(this.目标路径.length, 可行距离);
			            i++
			        ) {
			            const 节点 = this.目标路径[i];
			
			            const nextX = 节点.x;
			            const nextY = 节点.y;
			            if (地牢[nextY][nextX].类型 === 单元格类型.怪物) {
			                可行距离 = this.移动距离 + 1;
			            }
			            if (
			                this.检查移动可行性(
			                    当前位置.x,
			                    当前位置.y,
			                    nextX,
			                    nextY
			                ) && !(地牢[nextY][nextX].关联物品 && (地牢[nextY][nextX].关联物品 instanceof 已放置的障碍物 || (地牢[nextY][nextX].关联物品.类型 === '开关砖' && 地牢[nextY][nextX].关联物品.阻碍怪物)))
			            ) {
			                if (this.位置合法(nextX, nextY)) {
			                    有效位置 = { x: nextX, y: nextY };
			                }
			            } else {
			                this.目标路径 = this.目标路径.slice(i);
			                return 当前位置;
			            }
			            当前位置 = { x: nextX, y: nextY };
			
			            if (
			                有效位置 &&
			                i >=
			                    Math.min(this.移动距离, this.目标路径.length) -
			                        1
			            ) {
			                this.目标路径 = this.目标路径.slice(i);
			                return 有效位置;
			            }
			        }
			        return 有效位置;
			    }
			
			    检查移动可行性(fromX, fromY, toX, toY) {
			        const dx = toX - fromX;
			        const dy = toY - fromY;
			        const steps = Math.max(Math.abs(dx), Math.abs(dy));
			        const xStep = dx / steps;
			        const yStep = dy / steps;
			
			        let currentX = fromX;
			        let currentY = fromY;
			
			        for (let i = 0; i <= steps; i++) {
			            const x = Math.round(currentX);
			            const y = Math.round(currentY);
			
			            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
			                return false;
			
			            if (i > 0) {
			                const prevX = Math.round(currentX - xStep);
			                const prevY = Math.round(currentY - yStep);
			                const 移动方向 = 获取移动方向(prevX, prevY, x, y);
			
			                const 当前单元格 = 地牢[y][x];
			                const 前单元格 = 地牢[prevY][prevX];
			
			                if (
			                    当前单元格.墙壁[移动方向.反方向墙] ||
			                    前单元格.墙壁[移动方向.当前墙]
			                ) {
			                    return false;
			                }
			            }
			
			            if (x === toX && y === toY) break;
			
			            currentX += xStep;
			            currentY += yStep;
			        }
			        return true;
			    }
			    位置合法(x, y) {
			        if (
			            (地牢[y][x].类型 === 单元格类型.物品 &&
			            地牢[y][x].关联物品?.阻碍怪物) || 地牢[y][x].关联物品 instanceof 烟雾
			        ) {
			            return false;
			        }
			        if (
			            房间地图[y][x] !== -1 &&
			            !已访问房间.has(房间地图[y][x]) &&
			            !this.目标陷阱
			        ) {
			            return false;
			        }
			        if (房间地图[y][x]===0 && 游戏状态!=="图鉴") return false;
			        const 怪物所在房间 =
			            房间地图[this.y]?.[this.x] !== -1
			                ? 房间列表[房间地图[this.y][this.x]]
			                : null;
			        if (
			            怪物所在房间 &&
			            怪物所在房间.类型 === "黑暗房间" &&
			            房间地图[y]?.[x] !== 怪物所在房间.id
			        ) {
			            return false;
			        }
			        if (地牢[y][x].关联怪物) return false;
			        return (
			            [
			                单元格类型.房间,
			                单元格类型.走廊,
			                单元格类型.门,
			            ].includes(地牢[y][x].背景类型) &&
			            ![
			                单元格类型.楼梯上楼,
			                单元格类型.楼梯下楼,
			                单元格类型.怪物,
			            ].includes(地牢[y][x].类型)
			        );
			    }
			
			    恢复背景类型() {
			        地牢[this.y][this.x].类型 = this.当前格;
			        if (
			            this.当前格 === 单元格类型.物品 &&
			            地牢[this.y][this.x].关联物品 === null
			        ) {
			            地牢[this.y][this.x].类型 = null;
			        }
			        地牢[this.y][this.x].关联怪物 = null;
			    }
			
			    保存新位置类型(x, y) {
			        this.当前格 = 地牢[y][x].类型;
			    }
			                    选择逃离目标(目标X, 目标Y, 范围 = 10) {
			        const 可达点 = [];
			        const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
			        const 已访问 = new Set([`${this.x},${this.y}`]);
			        const 怪物所在房间ID = 房间地图[this.y][this.x];
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			            const 距离目标 =
			                Math.abs(当前.x - 目标X) + Math.abs(当前.y - 目标Y);
			            const 距离自身 = 当前.距离;
			
			            if (
			                距离自身 <= 范围 &&
			                距离目标 >
			                    Math.abs(this.x - 目标X) +
			                        Math.abs(this.y - 目标Y)
			            ) {
			                const 点所在房间ID = 房间地图[当前.y][当前.x];
			                if (
			                    点所在房间ID === 怪物所在房间ID ||
			                    点所在房间ID === -1 ||
			                    (已访问房间.has(点所在房间ID) &&
			                        房间列表[点所在房间ID]?.类型?.slice(
			                            0,
			                            2
			                        ) !== "隐藏")
			                ) {
			                    if (this.位置合法(当前.x, 当前.y)) {
			                        可达点.push({
			                            x: 当前.x,
			                            y: 当前.y,
			                            距离目标: 距离目标,
			                        });
			                    }
			                }
			            }
			
			            if (当前.距离 >= 范围) continue;
			
			            const 方向 = [
			                { dx: 1, dy: 0 },
			                { dx: -1, dy: 0 },
			                { dx: 0, dy: 1 },
			                { dx: 0, dy: -1 },
			            ];
			            for (const { dx, dy } of 方向) {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			                const 位置键 = `${新X},${新Y}`;
			
			                if (
			                    新X >= 0 &&
			                    新X < 地牢大小 &&
			                    新Y >= 0 &&
			                    新Y < 地牢大小 &&
			                    !已访问.has(位置键)
			                ) {
			                    const 当前单元格 = 地牢[当前.y]?.[当前.x];
			                    const 目标单元格 = 地牢[新Y]?.[新X];
			                    const 移动方向 = getMoveDirection(当前.x, 当前.y, 新X, 新Y);
			                    if (目标单元格.isOneWay && 移动方向 !== 目标单元格.oneWayAllowedDirection) {
			                        continue;
			                    }
			                    if (
			                        当前单元格 &&
			                        目标单元格 &&
			                        ![
			                            单元格类型.墙壁,
			                            单元格类型.上锁的门,
			                        ].includes(目标单元格.背景类型) &&
			                        检查移动可行性(当前.x, 当前.y, 新X, 新Y) &&
			                        this.位置合法(新X, 新Y)
			                    ) {
			                        已访问.add(位置键);
			                        队列.push({
			                            x: 新X,
			                            y: 新Y,
			                            距离: 当前.距离 + 1,
			                        });
			                    }
			                }
			            }
			        }
			
			        if (可达点.length > 0) {
			            可达点.sort((a, b) => b.距离目标 - a.距离目标);
			            return 可达点[0];
			        }
			        return null;
			    }
			    选择目标() {
    if (怪物状态表.get(this)?.类型 === "魅惑") {
        return this.寻找最近怪物目标();
    }
    if (this.仇恨 instanceof 怪物 && this.仇恨.当前生命值 > 0) {
        return this.仇恨;
    } else {
        this.仇恨 = null;
    }

    const 潜在目标列表 = [玩家, ...当前出战宠物列表, ...玩家仆从列表];
    let 最近目标 = null;
    let 最小距离 = Infinity;

    潜在目标列表.forEach(目标 => {
        if (目标 && (目标?.自定义数据?.get('当前生命值') > 0 || 目标 === 玩家) && (目标.是否已放置 || 目标 === 玩家) && (!目标?.自定义数据?.get("休眠中") || 目标 === 玩家)) {
            const 距离 = Math.abs(this.x - 目标.x) + Math.abs(this.y - 目标.y);
            if (距离 < 最小距离) {
                最小距离 = 距离;
                最近目标 = 目标;
            }
        }
    });
    
    return 最近目标 || 玩家;
}
			    尝试攻击() {
			        let 目标 = this.目标;
			        if (!目标) return false;
			        if (怪物状态表.get(this)?.类型 === "冻结") return;
			        const 距离目标 = Math.abs(this.x - 目标.x) + Math.abs(this.y - 目标.y);
			        if (距离目标>this.攻击范围) return;
			        if (this.通向目标路径&&this.通向目标路径?.length > this.攻击范围) return false;
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余 -= 1;
			            return false;
			        }
			        if (!this.通向目标路径) return false;
			        this.绘制血条();
			        if (目标.x === 玩家.x && 目标.y === 玩家.y) {
			            
			            伤害玩家(this.攻击力, this);
			        } else if (目标 instanceof 宠物) {
			            目标.受伤(this.攻击力,this);
			            添加日志(`${this.类型} 攻击了你的宠物 ${目标.名称}！`, "警告");
			        } else if (目标 instanceof 怪物) { 
			             目标.受伤(this.攻击力, this);
			        } else {
			            return false;
			        }
			        
			        this.攻击冷却回合剩余 = this.攻击冷却;
			        if (!this.通向目标路径) {
			            
			        } else {
			            计划显示格子特效(this.通向目标路径);
			        }
			    
			        return true;
			    }
			    get 攻击范围() {
			        return this.基础攻击范围 + (this.强化 ? 1 : 0);
			    }
			    get 攻击力() {
			        let 基础攻击 = this.基础攻击力 + (this.强化 ? this.基础攻击力 * 0.5 : 0);
			        const 力量增益 = this?.永久增益?.find(b => b.类型 === '永久力量');
			        if (力量增益) {
			            基础攻击 += 力量增益.值;
			        }
			        return 基础攻击;
			    }
			    get 颜色() {
			        if (怪物状态表.get(this)) {
			            return 怪物状态表.get(this)?.颜色;
			        }
			        return this.强化 ? "#ff0000" : this.基础颜色;
			    }
			    get 移动距离() {
			        let 距离 = this.基础移动距离 + (this.强化 ? 1 : 0);
			        const 速度增益 = this.永久增益?.find(增益 => 增益.类型 === '永久速度');
			        if (速度增益) {
			            距离 += 速度增益.值;
			        }
			        return 距离;
			    }
			    get 生命值() {
			        let 基础生命 = this.基础生命值 + (this.强化 ? 30 : 0);
			        const 强化增益 = this.永久增益?.find(b => b.类型 === '永久强化');
			        if (强化增益) {
			            基础生命 = Math.round(基础生命 * (1 + 强化增益.值 / 10));
			        }
			        return 基础生命;
			    }
			    get 物品掉率() {
			        return this.掉落概率 + (this.强化 ? 0.1 : 0);
			    }
			    获得效果(状态效果) {
			        return true;
			    }
			    计算最大甩飞位置(起始X, 起始Y, 方向DX, 方向DY, 最大距离) {
			        let 最远有效位置 = { x: 起始X, y: 起始Y };
			
			        if (方向DX === 0 && 方向DY === 0) return 最远有效位置;
			
			        for (let i = 1; i <= 最大距离 + 1; i++) {
			            const 尝试X = 起始X + 方向DX * i;
			            const 尝试Y = 起始Y + 方向DY * i;
			            if (
			                尝试X < 0 ||
			                尝试X >= 地牢大小 ||
			                尝试Y < 0 ||
			                尝试Y >= 地牢大小
			            ) {
			                break;
			            }
			            if (
			                !检查直线移动可行性(
			                    起始X,
			                    起始Y,
			                    尝试X,
			                    尝试Y,
			                    true
			                )
			            ) {
			                break;
			            }
			            if (this.位置合法(尝试X, 尝试Y, false)) {
			                最远有效位置 = { x: 尝试X, y: 尝试Y };
			            }
			        }
			        return 最远有效位置;
			    }
			    受伤(伤害, 来源 = null) {
			        
			        if (来源 === "火焰" && this?.永久增益.some(b => b.类型 === '永久抗火')) 伤害 *= 0.1;
			        if (来源 === "中毒" && this?.永久增益?.some(b => b.类型 === '永久抗毒')) 伤害 *= 0.1;
			        if (怪物状态表.get(this)?.类型 === '冻结' && this?.永久增益?.some(b => b.类型 === '永久解冻')) {
			             怪物状态表.get(this).移除状态();
			        }
			
			        if (this.当前生命值 > 0) {
			            this.当前生命值 -= 伤害;
			            let 触发击退 = false;
			            let 来源坐标 = null;
			
			            let 伤害来源是玩家 = 来源 === "玩家" || (来源?.x===玩家.x&&来源?.y===玩家.y);
			            let 伤害来源是宠物 = 来源 instanceof 宠物;
						let 来源宠物 = 伤害来源是宠物 ? 来源 : null;
			            
			            if (来源 instanceof 武器类) {
			                if (当前出战宠物列表.some(p => p?.自定义数据.get("装备")?.武器 === 来源)) {
			                    伤害来源是宠物 = true;
								来源宠物 = 当前出战宠物列表.find(p => p?.自定义数据.get("装备")?.武器 === 来源)
			                } else {
			                    伤害来源是玩家 = true;
			                }
			            }
			
			            if (伤害来源是玩家) {
			                触发击退 = true;
			                来源坐标 = { x: 玩家.x, y: 玩家.y };
			                this.受伤冻结回合剩余 = this.受伤冻结回合;
			                if (玩家属性.怪物反伤) {
			                    伤害玩家(1, '诅咒反伤');
			                }
			            } else if (伤害来源是宠物) {
			                触发击退 = true;
			                来源坐标 = { x: 来源?.x, y: 来源?.y };
			                this.受伤冻结回合剩余 = this.受伤冻结回合;
			            } else if (来源 instanceof 怪物 && 来源 !== this) {
			                触发击退 = true;
			                来源坐标 = { x: 来源?.x, y: 来源?.y };
			                if (!(来源 instanceof 大魔法师)) this.仇恨 = 来源;
			            }
			             if (this instanceof 蜈蚣怪物 || this instanceof 蜈蚣部位)  触发击退=false
			            if (中文模式) this.触发受击动画();
			            if (this.当前生命值 <= 0) {
			                if (伤害来源是玩家 || 伤害来源是宠物) {
			                    已击杀怪物数++;
			                    const 能量条 =
			                        document.querySelector(".power-bar");
			                    const 当前能量 =
			                        parseFloat(能量条.style.width) || 100;
			                    能量条.style.width = `${Math.min(
			                        100,
			                        当前能量 + 1.5/自定义全局设置.初始能量值*100
			                    )}%`;
			                    击杀提示.更新({
			                        内容: `已击杀怪物：${已击杀怪物数}`,
			                    });
			
			                    if (伤害来源是宠物 && 来源宠物) {
			                        const 经验值 = Math.floor(this.基础生命值 / 10);
			                        来源宠物.获得经验(经验值);
			                    }
			                }
			                this.恢复背景类型();
			                if (!(this instanceof 复活怪物) && !(this instanceof 娃娃怪物)) {
			                    for (let 怪物 of 所有怪物) {
			                    if (怪物 instanceof 复活怪物) {
			                        怪物.加入复活怪物({ 类名: this.constructor.name, 冷却: 5,配置: { 强化: this.强化,永久增益: this.永久增益 } });
			                    
			                    }
			                    }
			                }
			                
			                所有怪物 = 所有怪物.filter((m) => m !== this);
			                if (this.永久增益.some(b => b.类型 === '自爆')) {
    const 自爆伤害 = Math.ceil(this.生命值 / 2);
    const 自爆弹 = new 炸弹({
        
            倒计时: 1,
            爆炸时间: 1,
            伤害: 自爆伤害,
            来源: '怪物',
            爆炸范围: 3,
            能否拾起: false,
            颜色索引: 4,
    });
    if(放置物品到单元格(自爆弹, this.x, this.y)){
        自爆弹.使用(false, this.x, this.y);
        添加日志(`${this.类型} 死亡时留下了一颗危险的炸弹！`, '警告');
    }
}
			                if (
			                    当前天气效果.includes("诡魅") &&
			                    !(this instanceof 幽灵怪物) &&
			                    prng() < 0.3
			                ) {
			                    const 新幽灵 = new 幽灵怪物({
			                        x: this.x,
			                        y: this.y,
			                        房间ID: this.房间ID,
			                        状态: 怪物状态.活跃,
			                        强化: this.强化, 
			                    });
			                    if (放置怪物到单元格(新幽灵, this.x, this.y)) {
			                        添加日志(
			                            `一个${新幽灵.类型}从 ${this.类型} 的残骸中浮现！`,
			                            "警告"
			                        );
			                    }
			                } else if (this.掉落物&&
			                    prng() <=
			                    this.物品掉率 * 玩家属性.掉落倍率
			                ) {
			                    if (this.掉落物.自定义数据?.get("耐久"))
			                        this.掉落物.自定义数据.set(
			                            "耐久",
			                            Math.floor(
			                                Math.min(
			                                    this.掉落物.自定义数据.get(
			                                        "耐久"
			                                    ),
			                                    this.掉落物.自定义数据.get(
			                                        "耐久"
			                                    ) *
			                                        玩家属性.掉落倍率 *
			                                        prng() *
			                                        prng()
			                                )
			                            )
			                        );
			                    this.尝试添加随机词条到掉落物(this.掉落物)
			                    放置物品到单元格(this.掉落物, this.x, this.y);
			                }
			                const 玩家单元格 = 地牢[玩家.y][玩家.x];
			                if (
			                    玩家单元格.关联物品 &&
			                    玩家单元格.类型 === 单元格类型.物品
			                ) {
			                    if (尝试收集物品(玩家单元格.关联物品)) {
			                        if(单元格.类型===单元格类型.物品) 玩家单元格.类型 = null;
			                        玩家单元格.关联物品 = null;
			                        单元格.颜色索引 = 颜色表.length
			                    }
			                }
			                
			                if (是否为教程层 && this.房间ID === 2) {
			                    教程阶段 = 2.5; 
			                    教程提示已显示 = false;
			                    setTimeout(() => {
			                        显示教程提示();
			                    }, 200);
			                }
			                return;
			            }
			
			            if (触发击退 && 来源坐标) {
			                let 来源X, 来源Y;
			                来源X = 来源坐标.x;
			                来源Y = 来源坐标.y;
			                let 距离来源 =
			                    Math.abs(this.x - 来源坐标.x) +
			                    Math.abs(this.y - 来源坐标.y);
			                const 最大击退触发距离 = this.基础攻击范围 * 2;
			                if (距离来源 <= 最大击退触发距离) {
			                    let dx = this.x - 来源X;
			                    let dy = this.y - 来源Y;
			
			                    let 方向DX = 0;
			                    let 方向DY = 0;
			                    if (Math.abs(dx) > Math.abs(dy)) {
			                        方向DX = Math.sign(dx);
			                    } else if (Math.abs(dy) > Math.abs(dx)) {
			                        方向DY = Math.sign(dy);
			                    } else if (dx !== 0) {
			                        if (prng() < 0.5)
			                            方向DX = Math.sign(dx);
			                        else 方向DY = Math.sign(dy);
			                    } else {
			                        if (prng() < 0.5)
			                            方向DX = 1;
			                        else 方向DY = 1;
			                    }
			                    if (
			                        方向DX === 0 &&
			                        方向DY === 0 &&
			                        (dx !== 0 || dy !== 0)
			                    ) {
			                        方向DX = Math.sign(dx);
			                        方向DY = Math.sign(dy);
			                        if (Math.abs(dx) > Math.abs(dy)) 方向DY = 0;
			                        else 方向DX = 0;
			                    }
			
			                    if (方向DX !== 0 || 方向DY !== 0) {
			                        const { x: 最终X, y: 最终Y } =
			                            this.计算最大甩飞位置(
			                                this.x,
			                                this.y,
			                                方向DX,
			                                方向DY,
			                                1 
			                            );
			
			                        if (最终X !== this.x || 最终Y !== this.y) {
			                            const 旧X = this.x;
			                            const 旧Y = this.y; 
			                            this.恢复背景类型();
			                            this.x = 最终X;
			                            this.y = 最终Y;
			                            this.保存新位置类型(最终X, 最终Y);
			                            地牢[最终Y][最终X].类型 =
			                                单元格类型.怪物;
			                            地牢[最终Y][最终X].关联怪物 = this;
			                            this.处理地形效果(); 
			                            this.绘制血条(); 
			                            添加日志(
			                                `${this.类型} 被击退了！`,
			                                "信息"
			                            );
			                        }
			                    }
			                }
			            }
			            this.绘制血条();
			        }
			    }
			
			    绘制血条(隐藏血条 = false) {
			        if (隐藏血条 || (this?.永久增益?.some(b => b.类型 === '永久隐身'))) {
			            return;
			        }
			        if (命令行模式开启) {
        const 动画状态 = 怪物动画状态.get(this);
        let 绘制逻辑X = this.x;
        let 绘制逻辑Y = this.y;
        if (动画状态?.正在动画) {
            绘制逻辑X = 动画状态.视觉X !== undefined ? 动画状态.视觉X : this.x;
            绘制逻辑Y = 动画状态.视觉Y !== undefined ? 动画状态.视觉Y : this.y;
        }
        const 屏幕X = (绘制逻辑X - 当前相机X) * 单元格大小;
        const 屏幕Y = (绘制逻辑Y - 当前相机Y) * 单元格大小;
        const 活跃且区域可见 = this.状态 === 怪物状态.活跃 && (房间地图[this.y][this.x] === -1 || 已访问房间.has(房间地图[this.y][this.x]));
        if (活跃且区域可见) {
            ctx.font = `${单元格大小 * 0.3}px 'Courier New', monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            const 血量百分比 = Math.max(0, (this.当前生命值 / this.生命值));
            const 总格数 = 7;
            const 实心格数 = Math.round(血量百分比 * 总格数);
            const 空心格数 = 总格数 - 实心格数;
            const 血条文本 = `[${'#'.repeat(实心格数)}${'.'.repeat(空心格数)}]`;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(血条文本, 屏幕X + 单元格大小 / 2, 屏幕Y);
        }
        return;
    }
			        const 怪物所在房间 =
			            房间地图[this.y]?.[this.x] !== -1
			                ? 房间列表[房间地图[this.y][this.x]]
			                : null;
			        if (
			            (当前天气效果.includes("深夜") &&
			                !是否在光源范围内(this.x, this.y)) ||
			            (怪物所在房间?.类型 === "黑暗房间" &&
			                !是否在光源范围内(this.x, this.y))
			        ) {
			            return;
			        }
			        const 动画状态 = 怪物动画状态.get(this);
			        let 绘制逻辑X = this.x;
			        let 绘制逻辑Y = this.y;
			        const 正在动画 = 动画状态?.正在动画;
			
			        if (正在动画) {
			            绘制逻辑X =
			                动画状态.视觉X !== undefined
			                    ? 动画状态.视觉X
			                    : this.x;
			            绘制逻辑Y =
			                动画状态.视觉Y !== undefined
			                    ? 动画状态.视觉Y
			                    : this.y;
			        }
			
			        const 屏幕X = (绘制逻辑X - 当前相机X) * 单元格大小;
			        const 屏幕Y = (绘制逻辑Y - 当前相机Y) * 单元格大小;
			        const 宽度 = 单元格大小;
			
			        const 活跃且区域可见 =
			            this.状态 === 怪物状态.活跃 &&
			            (房间地图[this.y][this.x] === -1 ||
			                已访问房间.has(房间地图[this.y][this.x]));
			
			        if (活跃且区域可见) {
			            const 血条高度 = 4;
			            const 血条Y = 屏幕Y - 8;
			            const 血条背景色 = "#444";
			            const 血条前景色 = "#f00";
			
			            ctx.save();
			            ctx.fillStyle = 血条背景色;
			            ctx.fillRect(屏幕X, 血条Y, 宽度, 血条高度);
			
			            const 血量百分比 = Math.max(
			                0,
			                (this.当前生命值 / this.生命值) * 100
			            );
			            ctx.fillStyle = 血条前景色;
			            ctx.fillRect(
			                屏幕X,
			                血条Y,
			                宽度 * (血量百分比 / 100),
			                血条高度
			            );
			            ctx.restore();
			        }
			    }
			    触发受击动画() {
			        this.受击动画 = true;
			        绘制();
			        setTimeout(() => {
			            this.受击动画 = false;
			            绘制();
			        }, 200);
			    }
			}
			class 幽灵怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.幽灵仆从,
			            基础生命值: 15 + (配置.强化 ? 10 : 0),
			            基础攻击力: 4 + (配置.强化 ? 2 : 0),
			            移动率: 0.8,
			            掉落概率: 0.1,
			            掉落物: new 灵能盾牌({}),
			            基础攻击范围: 1,
			            跟踪距离: 30,
			            受伤冻结回合: 1,
			            ...配置,
			        });
			        if (this.掉落物) {
			            this.尝试添加随机词条到掉落物(this.掉落物);
			        }
			    }
			
			    检查移动可行性(fromX, fromY, toX, toY) {
			        if (
			            toX < 0 ||
			            toX >= 地牢大小 ||
			            toY < 0 ||
			            toY >= 地牢大小
			        )
			            return false;
			
			        const 目标单元格 = 地牢[toY][toX];
			
			        if (目标单元格.背景类型 === 单元格类型.上锁的门) {
			            return false;
			        }
			
			        if (目标单元格.关联怪物 && 目标单元格.关联怪物 !== this) {
			            return false;
			        }
			
			        return true;
			    }
			
			    规划移动路径() {
			        let 当前位置 = { x: this.x, y: this.y };
			        let 有效位置 = null;
			        let 可行距离 = this.移动距离 + 1;
			
			        for (
			            let i = 0;
			            i < Math.min(this.目标路径.length, 可行距离);
			            i++
			        ) {
			            const 节点 = this.目标路径[i];
			            const nextX = 节点.x;
			            const nextY = 节点.y;
			
			            if (
			                this.检查移动可行性(
			                    当前位置.x,
			                    当前位置.y,
			                    nextX,
			                    nextY
			                )
			            ) {
			                if (this.位置合法(nextX, nextY)) {
			                    有效位置 = { x: nextX, y: nextY };
			                }
			            } else {
			                this.目标路径 = this.目标路径.slice(i);
			                return 当前位置;
			            }
			
			            当前位置 = { x: nextX, y: nextY };
			
			            if (
			                有效位置 &&
			                i >=
			                    Math.min(this.移动距离, this.目标路径.length) -
			                        1
			            ) {
			                this.目标路径 = this.目标路径.slice(i + 1);
			                return 有效位置;
			            }
			        }
			
			        if (有效位置) this.目标路径 = [];
			        return 有效位置;
			    }
			
			    位置合法(x, y) {
			        const 单元格 = 地牢[y]?.[x];
			        if (!单元格) return false;
			
			        if ([单元格类型.上锁的门].includes(单元格.背景类型))
			            return false;
			
			        if (
			            (单元格.关联怪物 && 单元格.关联怪物 !== this) ||
			            (单元格.关联物品 && 单元格.关联物品.阻碍怪物)
			        ) {
			            return false;
			        }
			
			        return true;
			    }
			
			    计算目标路径(目标X, 目标Y) {
			        this.目标 = { x: 目标X, y: 目标Y };
			        const 开放列表 = [];
			        const 关闭列表 = new Set();
			        const 方向映射表 = [
			            { dx: 1, dy: 0 },
			            { dx: -1, dy: 0 },
			            { dx: 0, dy: 1 },
			            { dx: 0, dy: -1 },
			        ];
			
			        const 起点节点 = {
			            x: this.x,
			            y: this.y,
			            g: 0,
			            parent: null,
			        };
			        开放列表.push(起点节点);
			        关闭列表.add(`${起点节点.x},${起点节点.y}`);
			
			        while (开放列表.length > 0) {
			            let 当前节点 = 开放列表.shift();
			
			            if (当前节点.x === 目标X && 当前节点.y === 目标Y) {
			                const 路径 = [];
			                while (当前节点.parent) {
			                    路径.push(当前节点);
			                    当前节点 = 当前节点.parent;
			                }
			                return 路径.reverse();
			            }
			
			            方向映射表.forEach((方向) => {
			                const 新X = 当前节点.x + 方向.dx;
			                const 新Y = 当前节点.y + 方向.dy;
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    return;
			
			                const 目标单元格 = 地牢[新Y][新X];
			                if (目标单元格.背景类型 === 单元格类型.上锁的门)
			                    return;
			
			                const 位置键 = `${新X},${新Y}`;
			                if (!关闭列表.has(位置键)) {
			                    开放列表.push({
			                        x: 新X,
			                        y: 新Y,
			                        g: 当前节点.g + 1,
			                        parent: 当前节点,
			                    });
			                    关闭列表.add(位置键);
			                }
			            });
			        }
			        return null;
			    }
			
			    计算路径(目标X, 目标Y) {
			        return this.计算目标路径(目标X, 目标Y);
			    }
			}
			class 超速怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.超速怪物,
			            类型: "超速怪物",
			            强化: 配置.强化 || false,
			            掉落物: new 时空罗盘({
			                数量: 1,
			            }),
			            掉落概率: 0.3,
			            房间ID: 配置.房间ID || null,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.休眠,
			            基础生命值: 配置.基础生命值 || 28,
			            基础攻击力: 配置.基础攻击力 || 4,
			            移动率: 配置.移动率 || 0.85,
			            ...配置
			        });
			        this.加速范围 = 配置.加速范围 ?? 3;
			        this.加速回合数 = 配置.加速回合数 ?? (2 + (配置.强化 ? 1 : 0));
			    }
			}
			class 蜈蚣部位 extends 怪物 {
    constructor(配置 = {}) {
        super({
            图标: '●',
            类型: "蜈蚣部位",
            基础生命值: 25,
            基础攻击力: 5,
            移动率: 1.0,
            掉落概率: 0,
            掉落物: new 金币({ 数量: 10 }),
            ...配置,
        });
        this.主体 = 配置.主体;
        this.跟随 = 配置.跟随;
        this.强化=false
        this.前置X = this.跟随 ? this.跟随.x : this.x;
        this.前置Y = this.跟随 ? this.跟随.y : this.y;
        this.阻碍怪物 = true;
        this.存档ID = 配置.存档ID || `centipede_${prng()}`;
        this.基础颜色 = 配置.基础颜色 || '#FFFFFF';
    }

    执行移动() {
        if (!this.跟随 || this.跟随.当前生命值 <= 0) {
            this.受伤(9999); 
            return;
        }

        const 旧X = this.x;
        const 旧Y = this.y;
        const 目标X = this.跟随.前置X;
        const 目标Y = this.跟随.前置Y;

        if (this.x === 目标X && this.y === 目标Y) return;

        this.恢复背景类型();
        this.x = 目标X;
        this.y = 目标Y;
        this.保存新位置类型(this.x, this.y);
        地牢[this.y][this.x].类型 = 单元格类型.怪物;
        地牢[this.y][this.x].关联怪物 = this;
        怪物动画状态.set(this, {
            旧逻辑X: 旧X, 旧逻辑Y: 旧Y,
            目标逻辑X: this.x, 目标逻辑Y: this.y,
            视觉X: 旧X, 视觉Y: 旧Y,
            动画开始时间: Date.now(), 正在动画: true,
        });

        this.前置X = 旧X;
        this.前置Y = 旧Y;
    }

    受伤(伤害, 来源 = null) {
        if (this.当前生命值 <= 0) return;
        this.当前生命值 -= 伤害;
        if (中文模式) this.触发受击动画();

        if (this.当前生命值 <= 0) {
            this.主体?.执行分裂(this);
            this.移除自身();
        }
        this.主体?.绘制血条();
    }
    
    移除自身(整体删除=false) {
        this.恢复背景类型();
        if (this.血条元素) this.血条元素.remove();
        所有怪物 = 所有怪物.filter(m => m !== this);
        怪物状态表.delete(this);
        
        if (this.主体 && this.主体.身体部位 && !整体删除) {
            const index = this.主体.身体部位.indexOf(this);
            if (index > -1) {
                this.主体.身体部位.splice(index, 1);
            }
        }
    }
    
    绘制血条(隐藏 = false) { }
    尝试移动() {if (!this.跟随 || this.跟随.当前生命值 <= 0) {
            this.受伤(9999); 
            return;
        } } 
    尝试攻击() {
        if ((this.当前生命值 / this.生命值) < 0.4) this.基础攻击力 += 3
        return super.尝试攻击();
        
    }
}

class 蜈蚣怪物 extends 怪物 {
    constructor(配置 = {}) {
        super({
            
            基础生命值: 25 + (配置.强化 ? 15 : 0),
            ...配置,
            图标: 图标映射.蜈蚣怪物,
            类型: "蜈蚣怪物",
            基础攻击力: 6,
            移动率: 0.9,
            掉落物: new 金币({ 数量: 10 }),
            掉落概率: 0.8,
            
        });
        this.前置X = this.x;
        this.前置Y = this.y;
        
        this.朝向 = 配置.朝向 || 'W';
        this.长度 = 配置.长度 ?? (6 + (配置.强化 ? 2 : 0));
        this.身体部位 = 配置.身体部位 || [];
        this.是分裂体 = 配置.是分裂体 || false;
        this.存档ID = 配置.存档ID || `centipede_${prng()}`;
        
        if (配置.玩家放置 || 配置.x == null || this.是分裂体 || !位置是否可用(配置.x,配置.y,false)) {
            return;
        }
        
        this.初始化身体部位()
    }
    
    初始化身体部位() {
        if (this.身体部位.length > 0) return;
    
        const 队列 = [{ x: this.x, y: this.y, path: [{x: this.x, y: this.y}] }];
        const 已访问 = new Set([`${this.x},${this.y}`]);
        let 最终路径 = null;
    
        while (队列.length > 0) {
            const 当前 = 队列.pop();
    
            if (当前.path.length >= this.长度) {
                最终路径 = 当前.path;
                break;
            }
    
            const 方向 = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
            方向.sort(() => prng() - 0.5);
    
            for (const { dx, dy } of 方向) {
                const 新X = 当前.x + dx;
                const 新Y = 当前.y + dy;
                const key = `${当前.x},${当前.y},${新X},${新Y}`;
    
                if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小 || 已访问.has(key)) continue;
                
                if (位置是否可用(新X, 新Y, false) && 快速检查相邻移动(当前.x, 当前.y, 新X, 新Y)) {
                    已访问.add(key);
                    const 新路径 = [...当前.path, { x: 新X, y: 新Y }];
                    队列.push({ x: 新X, y: 新Y, path: 新路径 });
                }
            }
        }
        
        if (!最终路径) 最终路径 = 队列.pop()?.path || [{x: this.x, y: this.y}];

        const interpolateColor = (startHex, endHex, factor) => {
            const r1 = parseInt(startHex.slice(1, 3), 16);
            const g1 = parseInt(startHex.slice(3, 5), 16);
            const b1 = parseInt(startHex.slice(5, 7), 16);
            const r2 = parseInt(endHex.slice(1, 3), 16);
            const g2 = parseInt(endHex.slice(3, 5), 16);
            const b2 = parseInt(endHex.slice(5, 7), 16);
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        };
        const headColor = this.getRandomHexColor(); 
        const tailColor = this.getRandomHexColor(); 

        let 上一个部位 = this;
        for (let i = 1; i < 最终路径.length; i++) {
            const pos = 最终路径[i];
            const colorFactor = (i) / (最终路径.length -1);
            const segmentColor = interpolateColor(headColor, tailColor, colorFactor);
            const 新部位 = new 蜈蚣部位({
                主体: this,
                跟随: 上一个部位,
                x: pos.x,
                y: pos.y,
                
                基础生命值: this.基础生命值,
                基础颜色: segmentColor,
            });
            新部位.当前生命值 = 新部位.生命值;
            this.身体部位.push(新部位);
            
            放置怪物到单元格(新部位, pos.x, pos.y);
            上一个部位 = 新部位;
        }
        this.长度 = this.身体部位.length + 1;
    }
    getRandomHexColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(prng() * 16)];
    }
    return color;
}
    get 尾部() {
        return this.身体部位.length > 0 ? this.身体部位[this.身体部位.length - 1] : this;
    }
    
    _isSelfCollision(nextX, nextY, path, bodyParts) {
        const nextStepIndex = path.length;
        for (let i = 1; i < bodyParts.length; i++) {
            let predictedPos;
            const historyIndex = nextStepIndex - i;

            if (historyIndex >= 0) {
                predictedPos = path[historyIndex];
            } else {
                predictedPos = {x: bodyParts[i - nextStepIndex].x, y: bodyParts[i - nextStepIndex].y};
            }

            if (predictedPos && predictedPos.x === nextX && predictedPos.y === nextY) {
                return true;
            }
        }
        return false;
    }

    _findSinglePath(startNode, endNode, bodyPartsForCollision) {
        const h = (x, y) => Math.abs(x - endNode.x) + Math.abs(y - endNode.y);

        const 开放列表 = [{ x: startNode.x, y: startNode.y, g: 0, f: h(startNode.x, startNode.y), path: [{ x: startNode.x, y: startNode.y }] }];
        const 已关闭集合 = new Set([`${startNode.x},${startNode.y}`]);
        const 方向 = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
        let 最近节点 = 开放列表[0];

        while (开放列表.length > 0) {
            开放列表.sort((a, b) => a.f - b.f);
            const 当前 = 开放列表.shift();

            if (h(当前.x, 当前.y) < h(最近节点.x, 最近节点.y)) {
                最近节点 = 当前;
            }

            if (当前.x === endNode.x && 当前.y === endNode.y) {
                return 当前.path;
            }
            if (当前.path.length > this.跟踪距离 * 1.5) continue;

            for (const { dx, dy } of 方向) {
                const 新X = 当前.x + dx;
                const 新Y = 当前.y + dy;
                const key = `${新X},${新Y}`;

                if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小 || 已关闭集合.has(key)) {
                    continue;
                }

                const 目标单元格 = 地牢[新Y]?.[新X];
                if (!目标单元格 || [单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.背景类型) || (目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物) || (目标单元格.关联怪物 && 目标单元格.关联怪物.主体 !== this) ||!快速检查相邻移动(当前.x,当前.y,新X,新Y)) {
                    continue;
                }

                if (this._isSelfCollision(新X, 新Y, 当前.path, bodyPartsForCollision)) {
                    continue;
                }
                
                已关闭集合.add(key);
                const 新路径 = [...当前.path, { x: 新X, y: 新Y }];
                const g = 当前.g + 1;
                const f = g + h(新X, 新Y);
                开放列表.push({ x: 新X, y: 新Y, g, f, path: 新路径 });
            }
        }
        
        return 最近节点.path.length > 1 ? 最近节点.path : null;
    }

    寻找蜈蚣路径(目标) {
        const pathForward = this._findSinglePath(this, 目标, [this, ...this.身体部位]);

        const reversedBody = [this, ...this.身体部位].reverse();
        const newHead = reversedBody[0];
        
        
        if (pathForward) {
            return { path: pathForward, needsReversal: false };
        }
        const pathReversed = this._findSinglePath(newHead, 目标, reversedBody);
        if (pathReversed) {
            return { path: pathReversed, needsReversal: true };
        }

        return { path: null, needsReversal: false };
    }
    尝试攻击() {
        if ((this.当前生命值 / this.生命值) < 0.4) this.基础攻击力 += 3
        return super.尝试攻击();
        
    }
    尝试移动() {
        if (prng()>this.移动率) return;
        if (this.受伤冻结回合剩余 > 0) {
            this.受伤冻结回合剩余--;
            return;
        }
        
        const isLowHealth = (this.当前生命值 / this.生命值) < 0.4;
        const stepsToTake = isLowHealth ? 2 : 1;

        for (let step = 0; step < stepsToTake; step++) {
            const { path, needsReversal } = this.寻找蜈蚣路径(玩家);

            if (needsReversal) {
                this.反转();
            }
            
            const finalPath = needsReversal ? this.寻找蜈蚣路径(玩家).path : path;

            if (finalPath && finalPath.length > 1) {
                const nextStepNode = finalPath[1];
                
                const oldHeadX = this.x;
                const oldHeadY = this.y;

                const dx = nextStepNode.x - oldHeadX;
                const dy = nextStepNode.y - oldHeadY;
                if (dx > 0) this.朝向 = 'E';
                else if (dx < 0) this.朝向 = 'W';
                else if (dy > 0) this.朝向 = 'S';
                else if (dy < 0) this.朝向 = 'N';

                this.恢复背景类型();
                this.x = nextStepNode.x;
                this.y = nextStepNode.y;
                this.保存新位置类型(this.x, this.y);
                地牢[this.y][this.x].类型 = 单元格类型.怪物;
                地牢[this.y][this.x].关联怪物 = this;

                this.前置X = oldHeadX;
                this.前置Y = oldHeadY;

                怪物动画状态.set(this, {
                    旧逻辑X: oldHeadX, 旧逻辑Y: oldHeadY,
                    目标逻辑X: this.x, 目标逻辑Y: this.y,
                    视觉X: oldHeadX, 视觉Y: oldHeadY,
                    动画开始时间: Date.now(), 正在动画: true,
                });
                this.身体部位.forEach(部位 => 部位.执行移动());
            } else {
                break;
            }
        }
    }

    反转() {
        if (this.身体部位.length === 0) return;

        const allParts = [this, ...this.身体部位];
        const length = allParts.length;
        const mid = Math.floor(length / 2);

        for (let i = 0; i < mid; i++) {
            const partA = allParts[i];
            const partB = allParts[length - 1 - i];

            const posA = { x: partA.x, y: partA.y };
            const posB = { x: partB.x, y: partB.y };
            
            const prevPosA = { x: partA.前置X, y: partA.前置Y };
            const prevPosB = { x: partB.前置X, y: partB.前置Y };

            partA.恢复背景类型();
            partB.恢复背景类型();

            partA.x = posB.x;
            partA.y = posB.y;
            partB.x = posA.x;
            partB.y = posA.y;
            
            partA.前置X = prevPosB.x;
            partA.前置Y = prevPosB.y;
            partB.前置X = prevPosA.x;
            partB.前置Y = prevPosA.y;

            partA.保存新位置类型(partA.x, partA.y);
            地牢[partA.y][partA.x].关联怪物 = partA;
            地牢[partA.y][partA.x].类型 = 单元格类型.怪物;

            partB.保存新位置类型(partB.x, partB.y);
            地牢[partB.y][partB.x].关联怪物 = partB;
            地牢[partB.y][partB.x].类型 = 单元格类型.怪物;
        }
    }

    
    执行分裂(被摧毁部位) {
        const 分裂索引 = this.身体部位.indexOf(被摧毁部位);
        
        if (分裂索引 === -1 && 被摧毁部位 instanceof 蜈蚣部位) return;
        
        const 前段身体 = this.身体部位.slice(0, 分裂索引);
        let 后段身体 = this.身体部位.slice(分裂索引+1);
        if (被摧毁部位 instanceof 蜈蚣怪物) 后段身体 = [...this.身体部位]

        this.身体部位 = 前段身体;
        this.长度 = this.身体部位.length + 1;
    
        if (后段身体.length > 0) {
            const 新头部位 = 后段身体.shift();
            
            所有怪物 = 所有怪物.filter(m => m !== 新头部位);
    
            const 新蜈蚣 = new 蜈蚣怪物({
                ...新头部位,
                是分裂体: true,
                身体部位: [], 
                长度: 后段身体.length + 1,
            });
            
            所有怪物.push(新蜈蚣);
            地牢[新蜈蚣.y][新蜈蚣.x].关联怪物 = 新蜈蚣;
            
            新蜈蚣.身体部位 = 后段身体;
            let 上一个 = 新蜈蚣;
            新蜈蚣.身体部位.forEach(部位 => {
                部位.主体 = 新蜈蚣;
                部位.跟随 = 上一个;
                上一个 = 部位;
            });
        }
    }
    
    受伤(伤害, 来源 = null) {
        const 原始血量 = this.当前生命值;
        super.受伤(伤害, 来源);

        if (this.身体部位.length >= 3) {
            const 半血阈值 = this.生命值 / 2;
            if (原始血量 > 半血阈值 && this.当前生命值 <= 半血阈值) {
                
                this.执行半血分裂();
            }
        }

        if (this.当前生命值 <= 0) {
            this.移除自身();
        }
        this.绘制血条();
    }

    执行半血分裂() {
        const 分裂索引 = Math.floor(this.身体部位.length / 2);
        if (分裂索引 < 1) return;

        const 新头部位原型 = this.身体部位[分裂索引];
        const 前段身体 = this.身体部位.slice(0, 分裂索引);
        const 后段身体 = this.身体部位.slice(分裂索引 + 1);

        this.身体部位 = 前段身体;
        this.长度 = this.身体部位.length + 1;

        所有怪物 = 所有怪物.filter(m => m !== 新头部位原型);

        const 新蜈蚣 = new 蜈蚣怪物({
            ...新头部位原型,
            是分裂体: true,
            身体部位: [],
            长度: 后段身体.length + 1,
            强化:this.强化,
        });
        
        所有怪物.push(新蜈蚣);
        地牢[新蜈蚣.y][新蜈蚣.x].关联怪物 = 新蜈蚣;

        新蜈蚣.身体部位 = 后段身体;
        let 上一个 = 新蜈蚣;
        新蜈蚣.身体部位.forEach(部位 => {
            部位.主体 = 新蜈蚣;
            部位.跟随 = 上一个;
            上一个 = 部位;
        });

        显示通知(`${this.类型} 在战斗中分裂了！`, "警告");
    }
    
    移除自身() {
        this.执行分裂(this)
        this.恢复背景类型();
        if (this.血条元素) this.血条元素.remove();
        所有怪物 = 所有怪物.filter(m => m !== this);
        怪物状态表.delete(this);
    }
}
			class 吸血鬼 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.吸血鬼,
			            类型: "吸血鬼",
			            基础生命值: 25 + (配置.强化 ? 15 : 0),
			            基础攻击力: 6 + (配置.强化 ? 3 : 0),
			            移动率: 0.8,
			            掉落物: new 吸血剑({}),
			            掉落概率: 0.2,
			            攻击冷却: 1,
			            ...配置,
			        });
			        this.吸血比例 = 配置.吸血比例??(0.6 + (配置.强化 ? 0.25 : 0));
			    }
			
			    尝试攻击() {
			        const 原始血量 = this.当前生命值;
			        const 攻击成功 = super.尝试攻击();
			        if (攻击成功) {
			            const 造成伤害 = this.攻击力; 
			            const 吸血量 = Math.ceil(造成伤害 * this.吸血比例);
			            this.当前生命值 = Math.min(this.生命值, this.当前生命值 + 吸血量);
			            添加日志(`${this.类型} 吸取了你的生命，恢复了 ${吸血量} 点生命！`, "警告");
			            this.绘制血条();
			        }
			        return 攻击成功;
			    }
			}
			class 分裂怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.分裂怪物,
			            类型: "分裂怪物",
			            基础生命值: 18 + (配置.强化 ? 12 : 0),
			            基础攻击力: 4 + (配置.强化 ? 2 : 0),
			            移动率: 0.7,
			            掉落概率: 0.1,
			            掉落物: new 金币({ 数量: 5 }),
			            ...配置,
			        });
			        this.分裂冷却 = 配置.分裂冷却 ?? (5 - (配置.强化 ? 1 : 0));
			        this.分裂冷却剩余 = 配置.分裂冷却剩余 ?? this.分裂冷却;
			    }
			
			    尝试移动() {
			        super.尝试移动();
			        if (this.当前生命值 <= 0 || this.状态 !== 怪物状态.活跃) return;
			
			        if (this.分裂冷却剩余 > 0) {
			            this.分裂冷却剩余--;
			        } else {
			            this.尝试分裂();
			            this.分裂冷却剩余 = this.分裂冷却;
			        }
			    }
			
			    尝试分裂() {
			        const 方向列表 = [[0, 1], [0, -1], [1, 0], [-1, 0]];
			        方向列表.sort(() => prng() - 0.5);
			        if (所有怪物.filter((m) => m.状态 === 怪物状态.活跃 && !(m instanceof 巡逻怪物)).length > 12) return;
			
			        for (const [dx, dy] of 方向列表) {
			            const 新X = this.x + dx;
			            const 新Y = this.y + dy;
			            if (位置是否可用(新X, 新Y, true)) {
			                const 克隆体 = new 分裂怪物({ 强化: this.强化,分裂冷却:this.分裂冷却});
			                克隆体.当前生命值 = Math.max(1,this.生命值 - this.当前生命值); 
			                if (放置怪物到单元格(克隆体, 新X, 新Y)) {
			                    克隆体.状态 = 怪物状态.活跃;
			                    
			                    计划显示格子特效([{ x: 新X, y: 新Y }], "FFC0CB");
			                    return;
			                }
			            }
			        }
			    }
			}
			class 追踪风弹弹头 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.旋风,
			            类型: "追踪风弹弹头",
			            基础生命值: 1,
			            基础攻击力: 0,
			            移动率: 1.0,
			            掉落概率: 0,
			            基础移动距离: 1 + (配置.强化?1:0),
			            跟踪距离: 99,
			            ...配置,
			        });
			        this.生命周期 = 25;
			        this.状态 = 怪物状态.活跃;
			    }
			
			    尝试移动() {
			        this.生命周期--;
			        if (this.生命周期 <= 0) {
			            this.受伤(999, '消散');
			            return;
			        }
			
			        const 最近目标 = this.寻找最近怪物目标();
			        if (最近目标) {
			            this.目标路径 = this.计算路径(最近目标.x, 最近目标.y);
			            super.尝试移动();
			
			            if (Math.abs(this.x - 最近目标.x) <= 1 && Math.abs(this.y - 最近目标.y) <= 1) {
			                this.触发爆炸();
			            }
			        } else {
			            this.受伤(999, '无目标');
			        }
			    }
			
			    寻找最近怪物目标() {
			        let 最近距离 = Infinity;
			        let 最近目标 = null;
			        所有怪物.forEach(怪物 => {
			            if (怪物.状态 === 怪物状态.活跃 && !(怪物 instanceof 追踪风弹弹头)) {
			                const 距离 = Math.abs(this.x - 怪物.x) + Math.abs(this.y - 怪物.y);
			                if (距离 < 最近距离) {
			                    最近距离 = 距离;
			                    最近目标 = 怪物;
			                }
			            }
			        });
			        return 最近目标;
			    }
			    
			    触发爆炸() {
			        const 爆炸中心X = this.x;
			        const 爆炸中心Y = this.y;
			        const 影响范围 = 1 + (this.强化?1:0);
			        const 眩晕格子 = [];
			
			        for (let dy = -影响范围; dy <= 影响范围; dy++) {
			            for (let dx = -影响范围; dx <= 影响范围; dx++) {
			                const x = 爆炸中心X + dx;
			                const y = 爆炸中心Y + dy;
			                if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
			                    眩晕格子.push({ x, y })
			                    计划显示格子特效([{x,y}], "ADD8E6");
			                    const 单元格 = 地牢[y]?.[x];
			                    if (单元格?.关联怪物?.当前生命值 > 0 && !(单元格.关联怪物 instanceof 追踪风弹弹头)) {
			                        new 状态效果("眩晕", 效果颜色编号映射[效果名称编号映射.眩晕], 图标映射.眩晕, 4+ (this.强化?2:0), null, null, 单元格.关联怪物);
			                        单元格?.关联怪物?.受伤(9,this);
			                    }
			                }
			            }
			        }
			        
			
			        this.受伤(999, '命中');
			    }
			
			
			
			    绘制血条(隐藏血条 = true) {
			
			    }
			
			    尝试攻击() { return false; }
			}
			class 巨人部位 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.巨人部位,
			            类型: "巨人部位",
			            基础生命值: 9999,
			            基础攻击力: 0,
			            移动率: 0,
			            掉落概率: 0,
			            ...配置,
			        });
			        this.主体 = 配置.主体;
			        this.状态 = 怪物状态.活跃
			    }
			    get 当前生命值() {
			        return this.主体 ? this.主体.当前生命值 : 0;
			    }
			
			    set 当前生命值(值) {
			        if (this.主体) {
			            this.主体.当前生命值 = 值;
			        }
			    }
			
			    get 生命值() {
			        return this.主体 ? this.主体.生命值 : 0;
			    }
			    
			    尝试移动() { return; }
			    尝试攻击() { return false; }
			
			    受伤(伤害, 来源 = null) {
			        if (this.主体) {
			            this.主体.受伤(伤害, 来源);
			        }
			    }
			    
			    获得效果(效果) {
			        if (this.主体) {
			            const 现有主体效果 = 怪物状态表.get(this.主体);
			            if (现有主体效果 && 现有主体效果.类型 === 效果.类型) {
			                 现有主体效果.剩余回合 = Math.max(现有主体效果.剩余回合, 效果.剩余回合);
			                 现有主体效果.强度 = Math.min(5, (现有主体效果.强度 || 1) + (效果.强度 || 1));
			            } else {
			                const 新状态 = new 状态效果(
			                    效果.类型,
			                    效果.颜色,
			                    效果.图标,
			                    效果.持续时间,
			                    效果.剩余回合,
			                    效果.来源,
			                    this.主体, 
			                    效果.强度
			                );
			            }
			            return true;
			        }
			        return false;
			    }
			
			    绘制血条(隐藏血条 = true) { return; }
			}
			
			           
			class 巨人怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.巨人怪物,
			            类型: "巨人怪物",
			            基础生命值: 80 + (配置.强化 ? 80 : 0),
			            基础攻击力: 10 + (配置.强化 ? 6 : 0),
			            移动率: 0.5,
			            掉落概率: 1.0,
			            掉落物: new 大地猛击锤({}),
			            基础攻击范围: 1, 
			            基础移动距离: 1,
			            攻击冷却: 3,
			            ...配置,
			        });
			        this.部位列表 = [
			            new 巨人部位({ 主体: this }),
			            new 巨人部位({ 主体: this }),
			            new 巨人部位({ 主体: this }),
			        ];
			        this.部位偏移 = [{dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: 1, dy: 1}];
			        this.覆盖的单元格状态 = [null, null, null, null];
			    }
			
			    恢复背景类型() {
			        const 检查位置列表 = [{x: this.x, y: this.y}, ...this.部位偏移.map(偏移 => ({x: this.x + 偏移.dx, y: this.y + 偏移.dy}))];
			        
			        检查位置列表.forEach((位置, 索引) => {
			            const 单元格 = 地牢[位置.y]?.[位置.x];
			            const 已保存状态 = this.覆盖的单元格状态[索引];
			
			            if (单元格 && 单元格.关联怪物 && (单元格.关联怪物 === this || 单元格.关联怪物.主体 === this)) {
			                if (已保存状态) {
			                    单元格.类型 = 已保存状态.类型;
			                    
			                } else {
			                    单元格.类型 = null;
			                    
			                }
			                 单元格.关联怪物 = null;
			            }
			        });
			    }
			    
			    保存新位置类型(目标X, 目标Y) {
			        const 检查位置列表 = [{x: 目标X, y: 目标Y}, ...this.部位偏移.map(偏移 => ({x: 目标X + 偏移.dx, y: 目标Y + 偏移.dy}))];
			        
			        this.覆盖的单元格状态 = 检查位置列表.map(位置 => {
			            const 单元格 = 地牢[位置.y]?.[位置.x];
			            if (单元格) {
			                return { 类型: 单元格.类型 };
			            }
			            return null;
			        });
			    }
			    计算路径(目标X, 目标Y) {
			        // 无视单层墙壁
			        const 开放列表 = [{ x: this.x, y: this.y, 距离: 0, parent: null }];
			        const 已关闭集合 = new Set([`${this.x},${this.y}`]);
			        const 前驱节点映射 = new Map();
			
			        while (开放列表.length > 0) {
			            const 当前节点 = 开放列表.shift();
			            
			            if (Math.abs(当前节点.x - 目标X) <= 1 && Math.abs(当前节点.y - 目标Y) <= 1) {
			                const 路径 = [];
			                let 追溯节点 = 当前节点;
			                while(追溯节点) {
			                    路径.unshift({x: 追溯节点.x, y: 追溯节点.y});
			                    追溯节点 = 前驱节点映射.get(`${追溯节点.x},${追溯节点.y}`);
			                }
			                路径.shift();
			                return 路径;
			            }
			
			            const 方向列表 = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
			            for (const 方向 of 方向列表) {
			                const 新X = 当前节点.x + this.移动距离*方向.dx;
			                const 新Y = 当前节点.y + this.移动距离*方向.dy;
			                const 位置标识 = `${新X},${新Y}`;
			                
			                if (已关闭集合.has(位置标识)) continue;
			                
			                let 可以移动 = true;
			                const 新位置列表 = [{x: 新X, y: 新Y}, ...this.部位偏移.map(偏移 => ({x: 新X + 偏移.dx, y: 新Y + 偏移.dy}))];
			                
			                for (const 位置 of 新位置列表) {
			                     const 单元格 = 地牢[位置.y]?.[位置.x];
			                     if (!单元格 || [单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) || (单元格.关联怪物 && 单元格.关联怪物.主体 !== this && 单元格.关联怪物 !== this)) {
			                         可以移动 = false;
			                         break;
			                     }
			                }
			                
			                if (可以移动) {
			                    已关闭集合.add(位置标识);
			                    前驱节点映射.set(位置标识, 当前节点);
			                    开放列表.push({ x: 新X, y: 新Y, 距离: 当前节点.距离 + 1, parent: 当前节点 });
			                }
			            }
			        }
			        return [];
			    }
			    尝试移动() {
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余--;
			        }
			        if (this.当前生命值 <= 0 || this.状态 !== 怪物状态.活跃 || this.移动率 > prng()) return;
			
			        this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			        if (!this.目标路径 || this.目标路径.length <= 1) return;
			
			        const 下一步 = this.目标路径[0];
			        const 方向X = 下一步.x - this.x;
			        const 方向Y = 下一步.y - this.y;
			        
			        let 可以移动 = true;
			        const 新位置列表 = [{x: this.x + 方向X, y: this.y + 方向Y}, ...this.部位偏移.map(偏移 => ({x: this.x + 方向X + 偏移.dx, y: this.y + 方向Y + 偏移.dy}))];
			        
			        for (const 位置 of 新位置列表) {
			             const 单元格 = 地牢[位置.y]?.[位置.x];
			             if (!单元格 || [单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) || (单元格.关联怪物 && 单元格.关联怪物.主体 !== this && 单元格.关联怪物 !== this)) {
			                 可以移动 = false;
			                 break;
			             } else if (单元格.关联物品?.阻碍怪物 &&
			                    !(单元格.关联物品 instanceof 罐子) &&
			                    !(单元格.关联物品 instanceof 祭坛类) &&
			                    !(单元格.关联物品?.类型 === "楼梯")) {
			                    if (单元格.关联物品 instanceof 符文圈) continue;
			            if (单元格.关联物品 instanceof 挑战石碑) continue;
			            if (单元格.关联物品 instanceof 魔法水晶) continue;
			            if (单元格.关联物品 instanceof 传送门) continue;
			            if (单元格.关联物品 instanceof 折跃门) continue;
			            if (单元格.关联物品 instanceof 临时墙壁计时器) continue;
			            if (单元格.关联物品 instanceof 告示牌) continue;
			            if (单元格.关联物品 instanceof 存档点) continue;
			            if (单元格.关联物品 instanceof 传送带) continue;
			            if (单元格.关联物品 instanceof 开关脉冲器) continue;
			            if (单元格.关联物品?.类型 === '开关砖') continue;
			            单元格.关联物品 = null;
			                        if (单元格.类型 === 单元格类型.物品)
			                            单元格.类型 = null;
			                        单元格.颜色索引 = 颜色表.length;
			                
			             }
			        }
			
			        if (可以移动) {
			            const 旧X = this.x, 旧Y = this.y;
			            this.恢复背景类型();
			            this.保存新位置类型(this.x + 方向X, this.y + 方向Y);
			            
			            this.x += 方向X;
			            this.y += 方向Y;
			
			            地牢[this.y][this.x].类型 = 单元格类型.怪物;
			            地牢[this.y][this.x].关联怪物 = this;
			
			            this.部位列表.forEach((部位, 索引) => {
			                const 偏移 = this.部位偏移[索引];
			                部位.x = this.x + 偏移.dx;
			                部位.y = this.y + 偏移.dy;
			                地牢[部位.y][部位.x].类型 = 单元格类型.怪物;
			                地牢[部位.y][部位.x].关联怪物 = 部位;
			            });
			            怪物动画状态.set(this, { 旧逻辑X: 旧X, 旧逻辑Y: 旧Y, 目标逻辑X: this.x, 目标逻辑Y: this.y, 视觉X: 旧X, 视觉Y: 旧Y, 动画开始时间: Date.now(), 正在动画: true });
			        }
			    }
			
			    尝试攻击() {
			        if (this.攻击冷却回合剩余 > 0) return false;
			        const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (玩家距离 > 5) return false;
			
			        const 路径 = 广度优先搜索路径(this.x, this.y, 玩家.x, 玩家.y, 15, true);
			
			        if (!路径 || 路径.length <= 1) return false;
			
			        const 弹道路径 = 路径.slice(0,5);
			        
			        if(弹道路径.length === 0) return false;
			        let 爆炸格子 = [];
			        弹道路径.forEach((节点, 索引) => {
			            setTimeout(() => {
			                const 弹头格子 = [
			                    {x: 节点.x, y: 节点.y},
			                    {x: 节点.x + 1, y: 节点.y},
			                    {x: 节点.x, y: 节点.y + 1},
			                    {x: 节点.x + 1, y: 节点.y + 1},
			                ];
			                
			                计划显示格子特效(弹头格子, "FFA500", 0);
			                
			                弹头格子.forEach(位置 => {
			                    if (玩家.x === 位置.x && 玩家.y === 位置.y) {
			                        伤害玩家(this.攻击力 * 0.8, this);
			                    }
			                });
			                
			                if (索引 === 弹道路径.length - 1) {
			                    setTimeout(() => {
			                        const 爆炸范围 = 2;
			                        const 爆炸中心X = 节点.x;
			                        const 爆炸中心Y = 节点.y;
			                        
			
			                        for (let dy = -爆炸范围; dy <= 爆炸范围; dy++) {
			                            for (let dx = -爆炸范围; dx <= 爆炸范围; dx++) {
			                               if (Math.abs(dx) + Math.abs(dy) <= 爆炸范围) {
			                                   
			                                   计划显示格子特效([{x: 爆炸中心X + dx, y: 爆炸中心Y + dy}], "A52A2A")
			                               }
			                            }
			                        }
			                        
			                        
			                        爆炸格子.forEach(位置 => {
			                             if (玩家.x === 位置.x && 玩家.y === 位置.y) {
			                                 伤害玩家(this.攻击力 * 1.2, this);
			                             }
			                        });
			
			                    }, 150);
			                }
			            }, 索引 * 120);
			        });
			        
			        this.攻击冷却回合剩余 = this.攻击冷却;
			        return true;
			    }
			    
			    计算巨人最大甩飞位置(起始X, 起始Y, 方向DX, 方向DY, 最大距离) {
			        let 最远有效位置 = { x: 起始X, y: 起始Y };
			
			        if (方向DX === 0 && 方向DY === 0) return 最远有效位置;
			
			        for (let i = 1; i <= 最大距离; i++) {
			            const 尝试X = 起始X + 方向DX * i;
			            const 尝试Y = 起始Y + 方向DY * i;
			
			            let 区域是否可用 = true;
			            const 检查区域 = [{dx: 0, dy: 0}, ...this.部位偏移];
			
			            for(const 偏移 of 检查区域) {
			                const 检查X = 尝试X + 偏移.dx;
			                const 检查Y = 尝试Y + 偏移.dy;
			                const 单元格 = 地牢[检查Y]?.[检查X];
			
			                if (!单元格 || [单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) || (单元格.关联怪物 && 单元格.关联怪物.主体 !== this && 单元格.关联怪物 !== this) || 单元格.关联物品?.阻碍怪物) {
			                    区域是否可用 = false;
			                    break;
			                }
			            }
			            
			            if (!区域是否可用) {
			                break;
			            } else {
			                最远有效位置 = { x: 尝试X, y: 尝试Y };
			            }
			        }
			        return 最远有效位置;
			    }
			    
			    受伤(伤害, 来源 = null) {
			        if (this.当前生命值 <= 0) return;
			        
			        this.当前生命值 -= 伤害;
			        if (中文模式) this.触发受击动画();
			
			        if (this.当前生命值 <= 0) {
			            this.恢复背景类型();
			            所有怪物 = 所有怪物.filter(m => m !== this && m.主体 !== this);
			            
			            return;
			        }
			
			        let 触发击退 = false;
			        let 来源坐标 = null;
			        if (来源 === "玩家" || 来源 instanceof 武器类 || (来源 instanceof 怪物 && 来源 !== this)) {
			            触发击退 = true;
			            来源坐标 = { x: 来源?.x ?? 玩家.x, y: 来源?.y ?? 玩家.y };
			            this.受伤冻结回合剩余 = this.受伤冻结回合;
			        }
			
			        if (触发击退 && 来源坐标) {
			            let 方向X = this.x - 来源坐标.x;
			            let 方向Y = this.y - 来源坐标.y;
			            let 击退方向DX = 0, 击退方向DY = 0;
			
			            if (Math.abs(方向X) > Math.abs(方向Y)) {
			                击退方向DX = Math.sign(方向X);
			            } else {
			                击退方向DY = Math.sign(方向Y);
			            }
			            if (击退方向DX === 0 && 击退方向DY === 0 && (方向X !== 0 || 方向Y !== 0)) {
			                 击退方向DX = Math.sign(方向X);
			                 击退方向DY = Math.sign(方向Y);
			                 if (Math.abs(方向X) > Math.abs(方向Y)) 击退方向DY = 0; else 击退方向DX = 0;
			            }
			
			            if (击退方向DX !== 0 || 击退方向DY !== 0) {
			                const { x: 最终X, y: 最终Y } = this.计算巨人最大甩飞位置(this.x, this.y, 击退方向DX, 击退方向DY, 1);
			                
			                if (最终X !== this.x || 最终Y !== this.y) {
			                    const 旧X = this.x, 旧Y = this.y;
			                    this.恢复背景类型();
			                    this.保存新位置类型(最终X, 最终Y);
			                    this.x = 最终X;
			                    this.y = 最终Y;
			                    
			                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
			                    地牢[this.y][this.x].关联怪物 = this;
			
			                    this.部位列表.forEach((部位, 索引) => {
			                        const 偏移 = this.部位偏移[索引];
			                        部位.x = this.x + 偏移.dx;
			                        部位.y = this.y + 偏移.dy;
			                        地牢[部位.y][部位.x].类型 = 单元格类型.怪物;
			                        地牢[部位.y][部位.x].关联怪物 = 部位;
			                    });
			                    怪物动画状态.set(this, { 旧逻辑X: 旧X, 旧逻辑Y: 旧Y, 目标逻辑X: this.x, 目标逻辑Y: this.y, 视觉X: 旧X, 视觉Y: 旧Y, 动画开始时间: Date.now(), 正在动画: true });
			                    
			                }
			            }
			        }
			        this.绘制血条();
			    }
			}
			
			
			
			class 复活怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.复活怪物,
			            类型: "复活怪物",
			            基础生命值: 40 + (配置.强化 ? 30 : 0),
			            基础攻击力: 6 + (配置.强化 ? 3 : 0),
			            移动率: 0.7,
			            掉落物: null,
			            掉落概率: 0,
			            ...配置,
			        });
			        this.复活冷却 = 配置.复活冷却??5;
			        //this.复活冷却剩余 = 配置.复活冷却剩余??5;
			        this.最近击杀列表 = [];
			    }
			    加入复活怪物(怪物) {
			        if (this.最近击杀列表.length > 10) { 
			                        this.最近击杀列表.shift();
			                    }
			        this.最近击杀列表.push(怪物)
			    }
			
			    尝试移动() {
			        if (this.最近击杀列表.length > 0) {
			            const 被复活的数据 = this.最近击杀列表.slice(-1)[0];
			            const 怪物类 = window[被复活的数据.类名];
			            if (怪物类 && 被复活的数据.类名!=='大魔法师' && 被复活的数据.类名!=='米诺陶' && 被复活的数据.类名!=='墓碑' && 被复活的数据.类名!=='王座守护者' && 被复活的数据.类名!=='皇家守卫' && 被复活的数据.类名!=='复活怪物' && 被复活的数据.类名!=='巨人怪物' && 被复活的数据.类名!=='追踪风弹弹头' && 被复活的数据.类名!=='蜈蚣怪物' && 被复活的数据.类名!=='蜈蚣部位') {
			                if (被复活的数据.冷却>0) {
			                    被复活的数据.冷却-=this.强化?2:1;
			                    
			                }
			                
			            } else {
			                this.最近击杀列表.pop();
			            }
			        }
			        super.尝试移动();
			    }
			
			    尝试攻击() {
			        let ret=super.尝试攻击();
			        if (this.最近击杀列表.length > 0 && ret) {
			            const 被复活的数据 = this.最近击杀列表.slice(-1)[0];
			            const 怪物类 = window[被复活的数据.类名];
			            if (怪物类 && 被复活的数据.类名!=='大魔法师' && 被复活的数据.类名!=='米诺陶' && 被复活的数据.类名!=='墓碑' && 被复活的数据.类名!=='王座守护者' && 被复活的数据.类名!=='皇家守卫' && 被复活的数据.类名!=='复活怪物' && 被复活的数据.类名!=='巨人怪物' && 被复活的数据.类名!=='追踪风弹弹头' && 被复活的数据.类名!=='蜈蚣怪物' && 被复活的数据.类名!=='蜈蚣部位') {
			                if (被复活的数据.冷却>0) {
			                    return;
			                }
			                const 放置位置 = 寻找可放置位置(this.x, this.y);
			                if (放置位置) {
			                    const 新怪物 = new 怪物类({ ...被复活的数据.配置, 状态: 怪物状态.活跃 });
			                    放置怪物到单元格(新怪物, 放置位置.x, 放置位置.y);
			                    显示通知(`${this.类型} 复活了 ${新怪物.类型}!`, "警告");
			                    计划显示格子特效([{x: 放置位置.x, y: 放置位置.y}], "8A2BE2");
			                    //this.复活冷却剩余 = this.复活冷却;
			                    this.最近击杀列表.pop();
			                    return true;
			                }
			            } else {
			                this.最近击杀列表.pop();
			            }
			        }
			        return ret;
			    }
			
			    受伤(伤害, 来源 = null) {
			        const 原始血量 = this.当前生命值;
			        super.受伤(伤害, 来源);
			        if (原始血量 > 0 && this.当前生命值 <= 0) {
			            const 娃娃 = new 娃娃怪物({ x: this.x, y: this.y, 房间ID: this.房间ID, 状态: 怪物状态.活跃, 强化: this.强化 });
			            放置怪物到单元格(娃娃, this.x, this.y);
			        }
			    }
			}
			class 娃娃怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.娃娃怪物,
			            类型: "娃娃怪物",
			            基础生命值: 15 + (配置.强化 ? 10 : 0),
			            基础攻击力: 0,
			            移动率: 1.0,
			            掉落物: new 金币({数量: 20}),
			            掉落概率: 1,
						追踪距离: 15,
			            ...配置,
			        });
			        this.生命周期 = 10;
			    }
			
			    尝试移动() {
			        this.生命周期--;
			        if (this.生命周期 <= 0) {
			            this.变形();
			            return;
			        }
			
			        const 逃离点 = this.选择逃离目标(玩家.x, 玩家.y, 99);
			        if (逃离点) {
			            this.目标路径 = this.计算路径(逃离点.x, 逃离点.y);
			            super.尝试移动();
			        }
			    }
			
			    变形() {
			        this.恢复背景类型();
			        所有怪物 = 所有怪物.filter(m => m !== this);
			        const 复活者 = new 复活怪物({ x: this.x, y: this.y, 房间ID: this.房间ID, 状态: 怪物状态.活跃, 强化: this.强化 });
			        放置怪物到单元格(复活者, this.x, this.y);
			        显示通知(`${this.类型} 变回了 ${复活者.类型}!`, "警告");
			        计划显示格子特效([{x: this.x, y: this.y}], "FF00FF");
			    }
			
			    尝试攻击() {
			        return false;
			    }
			}
			            class 皇家守卫 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.皇家守卫,
			            类型: "皇家守卫",
			            基础生命值: 120,
			            基础攻击力: 10,
			            移动率: 0.9,
			            基础移动距离: 1,
			            攻击冷却: 2,
			            掉落概率: 0.2,
			            掉落物: new 秘银锁甲({ 强化: true }),
			            ...配置,
			        });
			        this.守护距离 = 3;
			        this.独立 = 配置.独立??false
			        
			        this.闪避几率 = 0.25; // 25%的几率闪避攻击
			        this.技能冷却 = {
			            居合斩: 5,
			            召唤: 8,
			        };
			        this.技能冷却剩余 = {
			            居合斩: 2, // 初始冷却，避免开场就用
			            召唤: 5,
			        };
			    }
			
			    
			    更新技能冷却() {
			        for (const 技能名称 in this.技能冷却剩余) {
			            if (this.技能冷却剩余[技能名称] > 0) {
			                this.技能冷却剩余[技能名称]--;
			            }
			        }
			    }
			
			    尝试移动() {
			        const 守护者 = 所有怪物.find(m => m instanceof 王座守护者);
			        if (守护者 && !this.独立) {
			            const 距离 = Math.abs(this.x - 守护者.x) + Math.abs(this.y - 守护者.y);
			            if (距离 > this.守护距离) {
			                this.目标路径 = this.计算路径(守护者.x, 守护者.y);
			            } else {
			                this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			            }
			        } else {
			            this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			        }
			        super.尝试移动();
			    }
			
			    // 修改：重构攻击AI以使用新技能
			    尝试攻击() {
			        this.更新技能冷却();
			
			        const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        
			        // 技能优先级判断
			        if (this.技能冷却剩余.居合斩 <= 0 && 玩家距离 > 1 && 玩家距离 <= 6) {
			            if (this.执行居合斩()) {
			                return true;
			            }
			        }
			        
			        if (this.技能冷却剩余.召唤 <= 0) {
			            if (this.执行召唤()) {
			                return true;
			            }
			        }
			        
			        // 如果技能不满足条件，则执行普通攻击
			        return super.尝试攻击();
			    }
			
			    执行居合斩() {
			        const 冲锋距离 = 10;
			        const vecX = 玩家.x - this.x;
			        const vecY = 玩家.y - this.y;
			    
			        if (vecX === 0 && vecY === 0) return false;
			    
			        const len = Math.sqrt(vecX * vecX + vecY * vecY);
			        const normX = vecX / len;
			        const normY = vecY / len;
			    
			        const 终点X = Math.round(this.x + normX * 冲锋距离);
			        const 终点Y = Math.round(this.y + normY * 冲锋距离);
			    
			        const 冲锋路径 = 获取直线路径(this.x, this.y, 终点X, 终点Y).slice(1);
			        if (冲锋路径.length === 0) return false;
			    
			        let 最终落点 = { x: this.x, y: this.y };
			        let 实际冲锋路径 = [];
			    
			        for (const 路径节点 of 冲锋路径) {
			            const 单元格 = 地牢[路径节点.y]?.[路径节点.x];
			            if (!单元格 || 单元格.背景类型 === 单元格类型.墙壁 || (单元格.关联物品 && 单元格.关联物品.阻碍怪物)||!位置是否可用(路径节点.x,路径节点.y,false)) {
			                break;
			            }
			            实际冲锋路径.push(路径节点);
			            最终落点 = 路径节点;
			        }
			    
			        if (实际冲锋路径.length === 0) return false;
			    
			        计划显示格子特效(实际冲锋路径, "FFFFFF", 10);
			        
			        if (实际冲锋路径.some(点 => 点.x === 玩家.x && 点.y === 玩家.y)) {
			             伤害玩家(this.攻击力 * 1.2, this);
			        }
					当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && 实际冲锋路径.some(点 => 点.x === pet.x && 点.y === pet.y) && pet.层数==当前层数) {
        pet.受伤(this.攻击力 * 1.2);
        添加日志(`${pet.名称} 被王权冲锋击中了！`, "警告");
    }
});
			       
			        const 旧X = this.x, 旧Y = this.y;
			        怪物动画状态.set(this, {
			    旧逻辑X: 旧X,
			    旧逻辑Y: 旧Y,
			    目标逻辑X: 最终落点.x,
			    目标逻辑Y: 最终落点.y,
			    视觉X: 旧X,
			    视觉Y: 旧Y,
			    动画开始时间: Date.now(),
			    正在动画: true,
			});
			        this.恢复背景类型();
			        this.x = 最终落点.x; 
			        this.y = 最终落点.y;
			        this.保存新位置类型(this.x, this.y);
			        地牢[this.y][this.x].类型 = 单元格类型.怪物;
			        地牢[this.y][this.x].关联怪物 = this;
			        
			
			        this.技能冷却剩余.居合斩 = this.技能冷却.居合斩;
			        显示通知(`${this.类型} 发动了居合斩！`, '警告');
			        return true;
			    }
			
			    执行召唤() {
			        const 放置位置 = 寻找可放置位置(this.x, this.y);
			        if (!放置位置 || 所有怪物.length>15) return false;
			
			        const 怪物池选择 = 怪物池.上锁房间.filter(m => !['大魔法师', '米诺陶', '皇家守卫','复活怪物','萨满怪物','巨人怪物','蜈蚣怪物'].includes(m.类.name));
			        const 选定怪物类 = 怪物池选择[Math.floor(prng() * 怪物池选择.length)];
			        
			        
			        const 新怪物 = new 选定怪物类.类({状态: 怪物状态.活跃});
			        if (放置怪物到单元格(新怪物, 放置位置.x, 放置位置.y)) {
			            计划显示格子特效([{x: 放置位置.x, y: 放置位置.y}], "483D8B");
			            显示通知(`${this.类型} 召唤了 ${新怪物.类型}！`, '警告');
			            this.技能冷却剩余.召唤 = this.技能冷却.召唤;
			            return true;
			        }
			        return false;
			    }
			
			    // 修改：受伤时有几率闪避
			    受伤(伤害, 来源 = null) {
			        if (prng() < this.闪避几率) {
			            显示通知(`${this.类型} 灵巧地闪开了攻击！`, '成功');
			            计划显示格子特效([{x: this.x, y: this.y}], "FFFFFF"); // 显示一个白色闪光特效
			            return; // 直接返回，不承受伤害
			        }
			        
			        // 如果没有闪避，则调用父类的受伤方法
			        super.受伤(伤害, 来源);
			        
			        if (this.当前生命值 <= 0) {
			            添加日志(`${this.类型} 倒下了，守护者的护盾产生了一丝裂痕...`, '信息');
			        }
			    }
			}
			class 移动弹幕 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.移动弹幕,
			            类型: "移动弹幕",
			            基础生命值: 1, // 一击即碎
			            基础攻击力: 8 + (配置.强化 ? 4 : 0),
			            移动率: 1.0, 
			            掉落概率: 0,
			            基础攻击范围: 1,
			            跟踪距离: 99,
			            基础移动距离: 2,
			            ...配置,
			        });
			        this.生命周期 = 15; // 存在15回合
			        this.状态 = 怪物状态.活跃;
			    }
			
			    尝试移动() {
			        this.生命周期--;
			        if (this.生命周期 <= 0) {
			            this.受伤(999, '消散');
			            return;
			        }
			        // 始终朝向玩家移动
			        this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			        super.尝试移动();
			    }
			
			    尝试攻击() {
			        const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (玩家距离 <= 1) {
			            伤害玩家(this.攻击力, this);
			            this.受伤(999, '撞击');
			            计划显示格子特效([{x: this.x, y: this.y}], "8A2BE2");
			        }
			        return false; // 不进行常规攻击判定
			    }
			
			    受伤(伤害, 来源 = null) {
			        this.恢复背景类型();
			        if(this.血条元素) this.血条元素.remove();
			        所有怪物 = 所有怪物.filter(m => m !== this);
			        怪物状态表.delete(this);
			    }
			
			     绘制血条(隐藏血条 = true) {
			        if (this.血条元素) {
			            this.血条元素.style.display = "none";
			        }
			    }
			}
			
			class 墓碑 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.墓碑,
			            类型: "墓碑",
			            基础生命值: 40 + (配置.强化 ? 40 : 0),
			            基础攻击力: 0,
			            移动率: 0, // 不会移动
			            掉落概率: 0.1,
			            掉落物: new 金币({数量: 50}),
			            ...配置,
			        });
			        this.召唤冷却 = 5;
			        this.召唤冷却剩余 = Math.floor(prng() * 5);
			        this.守护者 = 配置.守护者; // 引用Boss实例
			        this.状态 = 怪物状态.活跃;
			    }
			
			    尝试移动() {
			        if (地牢[this.y][this.x].关联怪物 !== this) this.受伤(999,'玩家')
			    }
			    
			    尝试攻击() {
			        this.召唤冷却剩余--;
			        if (this.召唤冷却剩余 <= 0) {
			            this.召唤冷却剩余 = this.召唤冷却;
			            const 放置位置 = 寻找可放置位置(this.x, this.y);
			            if (放置位置) {
			                const 新怪物 = new 幽灵仆从({状态: 怪物状态.活跃});
			                放置怪物到单元格(新怪物, 放置位置.x, 放置位置.y);
			                计划显示格子特效([{x: 放置位置.x, y: 放置位置.y}], "483D8B");
			            }
			        }
			        return false;
			    }
			
			    受伤(伤害, 来源 = null) {
			        super.受伤(伤害, 来源);
			        if (this.当前生命值 <= 0) {
			            if (this.守护者) {
			                this.守护者.激活的墓碑列表 = this.守护者.激活的墓碑列表.filter(墓碑 => 墓碑 !== this);
			                if (this.守护者.激活的墓碑列表.length === 0) {
			                    this.守护者.无敌 = false;
			                    显示通知("所有墓碑已被摧毁，守护者的屏障消失了！", "成功", true);
			                }
			            }
			        }
			    }
			}
			class 王座守护者 extends 怪物{
				constructor(配置={}){
					super({
						图标:图标映射.王座守护者,
						类型:"王座守护者",
						基础生命值:800,
						基础攻击力:10,
						移动率:0.8,
						掉落概率:0,
						掉落物:new 冲撞牛角({强化:true}),
						基础攻击范围:5,
						跟踪距离:100,
						攻击冷却:1,
						残血逃跑: false,
						...配置,
					});
					this.当前阶段=1;
					this.技能冷却={
					    三连重劈:5,
						召唤皇家卫队:20,
						王权冲锋:6,
						圣光弹幕:5,
						幽魂弹幕:9,
						墓碑召唤:20,
						裂隙跳跃:5,
						领域脉冲:8,
						召唤混沌回响:10,
						混沌风暴:15,
						生成混沌裂隙:9,
						无尽回响:7,
						螺旋圣光:10,
						十字审判:12,
					};
					this.技能冷却剩余={...this.技能冷却};
					this.皇家守卫列表=[];
					this.无敌=false;
					this.激活的墓碑列表=[];
					this.无敌次数 = 0
				}
				更新技能冷却(){
					for(const 技能 in this.技能冷却剩余){
						if(this.技能冷却剩余[技能]>0){
							if(!(技能==='墓碑召唤'&&this.无敌) && !(技能==='召唤皇家卫队'&&this.皇家守卫列表.length>2)) this.技能冷却剩余[技能]--;
						}
					}
				}
				受伤(伤害,来源=null){
					if(!(来源 instanceof 武器类)&&(来源?.x!==玩家.x||来源?.y!==玩家.y))
						return;
					if(this.当前阶段===3&&prng()<0.75){
						显示通知("守护者的身影变得虚幻，躲开了攻击！","信息");
						this.裂隙跳跃();
						return;
					}
					if(this.无敌){
						显示通知("守护者被无形的力量保护着！","警告");
						return;
					}
					let 实际伤害=伤害;
					const 附近宿卫数量=this.皇家守卫列表.filter(卫兵=>卫兵.当前生命值>0&&Math.abs(this.x-卫兵.x)+Math.abs(this.y-卫兵.y)<=3).length;
					if(附近宿卫数量>0){
						const 减伤率=1-(0.4*附近宿卫数量);
						实际伤害*=Math.max(0.1,减伤率);
						添加日志(`${this.类型} 被皇家守卫保护，伤害被大幅削弱！`,"警告");
					}
					const 原始生命值=this.当前生命值;
					super.受伤(实际伤害,来源);
					if((来源==="玩家"||来源 instanceof 武器类||来源 instanceof 宠物)&&!this.无敌){
						this.强制释放随机技能();
					}
					if(this.当前生命值<=0){
						this.皇家守卫列表.forEach(卫兵=>卫兵?.受伤(9999,"守护者陨落"));
						显示通知("破碎的王座终于迎来了安息...","成功",true,5000);
						
						
						for (let 纵坐标 = 房间列表[房间列表.length - 1].y; 纵坐标 < 房间列表[房间列表.length - 1].y + 房间列表[房间列表.length - 1].h; 纵坐标++) {
			        for (let 横坐标 = 房间列表[房间列表.length - 1].x; 横坐标 < 房间列表[房间列表.length - 1].x + 房间列表[房间列表.length - 1].w; 横坐标++) {
			            const 单元格 = 地牢[纵坐标]?.[横坐标];
			            if (单元格) {
			                // 移除物品
			                if (单元格.关联物品) {
			                    // 如果物品在计时器列表中，也一并移除
			                    const 计时器索引 = 所有计时器.findIndex(计时器 => 计时器.唯一标识 === 单元格.关联物品.唯一标识);
			                    if (计时器索引 !== -1) {
			                        所有计时器.splice(计时器索引, 1);
			                    }
			                    单元格.关联物品 = null;
			                }
			                // 移除怪物
			                if (单元格.关联怪物) {
			                    所有怪物 = 所有怪物.filter(怪物 => 怪物 !== 单元格.关联怪物);
			                    单元格.关联怪物 = null;
			                }
			                // 重置单元格类型，但保留背景类型
			                if (单元格.类型 !== null) {
			                    单元格.类型 = null;
			                }
			            }
			        }
			    }
			    if(游戏状态 !== '图鉴'){
						    放置物品到房间(new 奖杯物品({}), 房间列表[房间列表.length - 1]);
							
						}
			
						return;
					}
					if(this.当前阶段===1&&this.当前生命值/this.生命值<=0.65){
					    this.无敌次数 = 0;
						this.当前阶段=2;
						this.王座崩坏();
					}else if(this.当前阶段===2&&this.当前生命值/this.生命值<=0.30){
					    this.无敌次数=4;
						this.当前阶段=3;
						this.混沌化身();
					}
				}
				尝试移动(){
					if(this.当前阶段===3){
						const 玩家距离=Math.abs(this.x-玩家.x)+Math.abs(this.y-玩家.y);
						if(玩家距离<5){
							const 逃离点=this.选择逃离目标(玩家.x,玩家.y,10);
							if(逃离点)
								this.目标路径=this.计算路径(逃离点.x,逃离点.y);
						}else{
							this.目标路径=this.计算路径(玩家.x,玩家.y);
						}
					}else{
						this.目标路径=this.计算路径(玩家.x,玩家.y);
					}
					super.尝试移动();
				}
				尝试攻击(){
					this.更新技能冷却();
					switch(this.当前阶段){
						case 1:
							return this.执行阶段一AI();
						case 2:
							return this.执行阶段二AI();
						case 3:
							return this.执行阶段三AI();
					}
					return false;
				}
				执行阶段一AI(){
					this.皇家守卫列表=this.皇家守卫列表.filter(卫兵=>卫兵.当前生命值>0&&所有怪物.includes(卫兵));
					const 可用技能列表=[];
					if(this.技能冷却剩余.墓碑召唤<=0&&this.当前生命值/this.生命值<0.85&&!this.无敌&&this.激活的墓碑列表.length===0&&this.无敌次数<=3)
						可用技能列表.push('墓碑召唤');
					if(this.技能冷却剩余.圣光弹幕<=0)
						可用技能列表.push('圣光弹幕');
					if(this.技能冷却剩余.幽魂弹幕<=0)
						可用技能列表.push('幽魂弹幕');
					if(this.技能冷却剩余.王权冲锋<=0)
						可用技能列表.push('王权冲锋');
					if(this.技能冷却剩余.召唤皇家卫队<=0&&this.皇家守卫列表.length<2)
						可用技能列表.push('召唤皇家卫队');
					if(可用技能列表.length>0){
						const 选定技能名=可用技能列表[Math.floor(prng()*可用技能列表.length)];
						return this[选定技能名]();
					}
					return this.三连重劈();
				}
				执行阶段二AI(){
					const 可用技能列表=[];
					this.皇家守卫列表=this.皇家守卫列表.filter(卫兵=>卫兵.当前生命值>0&&所有怪物.includes(卫兵));
					if(this.技能冷却剩余.螺旋圣光<=0)
						可用技能列表.push('螺旋圣光');
					if(this.技能冷却剩余.十字审判<=0)
						可用技能列表.push('十字审判');
					if(this.技能冷却剩余.领域脉冲<=0)
						可用技能列表.push('领域脉冲');
					if(this.技能冷却剩余.裂隙跳跃<=0)
						可用技能列表.push('裂隙跳跃');
					if(this.技能冷却剩余.召唤混沌回响<=0)
						可用技能列表.push('召唤混沌回响');
					if(this.技能冷却剩余.墓碑召唤<=0&&!this.无敌&&this.激活的墓碑列表.length===0&&this.无敌次数<=3)
						可用技能列表.push('墓碑召唤');
					if(this.技能冷却剩余.圣光弹幕<=0)
						可用技能列表.push('圣光弹幕');
					if(this.技能冷却剩余.幽魂弹幕<=0)
						可用技能列表.push('幽魂弹幕');
					if(this.技能冷却剩余.王权冲锋<=0)
						可用技能列表.push('王权冲锋');
					if(this.技能冷却剩余.召唤皇家卫队<=0&&this.皇家守卫列表.length<2)
						可用技能列表.push('召唤皇家卫队');
					if(可用技能列表.length>0){
						const 选定技能名=可用技能列表[Math.floor(prng()*可用技能列表.length)];
						return this[选定技能名]();
					}
					const 随机数=prng();
					if(随机数<0.5){
						return this.三连重劈();
					}else{
						return this.混沌之触();
					}
				}
				执行阶段三AI(){
					const 可用技能列表=[];
					if(this.技能冷却剩余.混沌风暴<=0)
						可用技能列表.push('混沌风暴','混沌风暴');
					if(this.技能冷却剩余.生成混沌裂隙<=0)
						可用技能列表.push('生成混沌裂隙','生成混沌裂隙');
					if(this.技能冷却剩余.无尽回响<=0)
						可用技能列表.push('无尽回响');
					if(this.技能冷却剩余.螺旋圣光<=0)
						可用技能列表.push('螺旋圣光');
					if(this.技能冷却剩余.十字审判<=0)
						可用技能列表.push('十字审判');
					if(this.技能冷却剩余.领域脉冲<=0)
						可用技能列表.push('领域脉冲');
					if(this.技能冷却剩余.裂隙跳跃<=0)
						可用技能列表.push('裂隙跳跃');
					if(this.技能冷却剩余.召唤混沌回响<=0)
						可用技能列表.push('召唤混沌回响');
					if(this.技能冷却剩余.墓碑召唤<=0&&!this.无敌&&this.激活的墓碑列表.length===0&&this.无敌次数<=3)
						可用技能列表.push('墓碑召唤');
					if(this.技能冷却剩余.圣光弹幕<=0)
						可用技能列表.push('圣光弹幕');
					if(this.技能冷却剩余.幽魂弹幕<=0)
						可用技能列表.push('幽魂弹幕');
					if(this.技能冷却剩余.王权冲锋<=0)
						可用技能列表.push('王权冲锋');
					if(this.技能冷却剩余.召唤皇家卫队<=0&&this.皇家守卫列表.length<2)
						可用技能列表.push('召唤皇家卫队');
					if(可用技能列表.length>0){
						const 选定技能名=可用技能列表[Math.floor(prng()*可用技能列表.length)];
						return this[选定技能名]();
					}
					return this.混沌之触();
				}
				王权冲锋(){
					this.技能冷却剩余.王权冲锋=this.技能冷却.王权冲锋;
					const 冲锋路径原始=获取直线路径(this.x,this.y,玩家.x,玩家.y);
					if(冲锋路径原始.length<2)
						return this.三连重劈();
					const 实际路径=[];
					let 最后有效点={x:this.x,y:this.y};
					for(const 节点 of 冲锋路径原始.slice(1)){
						const 单元格=地牢[节点.y]?.[节点.x];
						if(!单元格||单元格.背景类型===单元格类型.墙壁||(单元格.关联物品&&单元格.关联物品.阻碍怪物)||!位置是否可用(节点.x,节点.y,false)){
							break;
						}
						实际路径.push(节点);
						最后有效点=节点;
					}
					if(实际路径.length===0)
						return this.三连重劈();
					计划显示格子特效(实际路径,"FF4500");
					实际路径.forEach(节点=>{
						if(节点.x===玩家.x&&节点.y===玩家.y){
							伤害玩家(this.攻击力*1.5,this);
						}
						当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.层数==当前层数 && 节点.x === pet.x && 节点.y === pet.y) {
        pet.受伤(this.攻击力 * 1.5);
			        添加日志(`${pet?.名称} 被王权冲锋击中了！`, "警告");
    }
});

						const 单元格=地牢[节点.y]?.[节点.x];
						if(单元格?.关联物品&&单元格.关联物品!==this){
							if(!([单元格类型.楼梯下楼,单元格类型.楼梯上楼].includes(单元格.类型)||单元格.关联物品 instanceof 挑战石碑)){
								添加日志(`${单元格.关联物品.名称} 被冲锋摧毁了！`,'警告');
								单元格.关联物品.移除自身?.();
								单元格.关联物品=null;
								if(单元格.类型===单元格类型.物品)
									单元格.类型=null;
							}
						}
					});
					const 旧X=this.x,旧Y=this.y;
					this.恢复背景类型();
					this.x=最后有效点.x;
					this.y=最后有效点.y;
					this.保存新位置类型(最后有效点.x,最后有效点.y);
					地牢[最后有效点.y][最后有效点.x].类型=单元格类型.怪物;
					地牢[最后有效点.y][最后有效点.x].关联怪物=this;
					return true;
				}
				召唤皇家卫队(){
					this.技能冷却剩余.召唤皇家卫队=this.技能冷却.召唤皇家卫队;
					const 召唤数量=2-this.皇家守卫列表.filter(g=>g.当前生命值>0).length;
					let 成功召唤数=0;
					for(let i=0;i<召唤数量;i++){
						const 放置位置=寻找可放置位置(this.x,this.y);
						if(放置位置){
							const 新宿卫=new 皇家守卫({状态:怪物状态.活跃});
							if (所有怪物.length <= 15){
							if(放置怪物到单元格(新宿卫,放置位置.x,放置位置.y)){
								this.皇家守卫列表.push(新宿卫);
								成功召唤数++;
							}
							}
						}
					}
					if(成功召唤数>0){
						显示通知(`${this.类型} 召唤了 ${成功召唤数} 名皇家守卫！`,"警告");
					}
					return true;
				}
			    王座崩坏() {
			        显示通知("王座的力量正在崩溃，整个大厅都在颤抖！", "错误", true);
			        const 房间ID = 房间地图[this.y][this.x];
			        if (房间ID === -1) return;
			    
			        const 房间 = 房间列表[房间ID];
			        const 中心X = 房间.x + Math.floor(房间.w / 2);
			        const 中心Y = 房间.y + Math.floor(房间.h / 2);
			        const 内圈半径 = 房间.w * 0.45;
			    
			        const 安全位置列表 = [];
			        for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			            for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			                const 距离中心 = Math.sqrt(Math.pow(x - 中心X, 2) + Math.pow(y - 中心Y, 2));
			                if (距离中心 <= 内圈半径 && 位置是否可用(x, y, false)) {
			                    安全位置列表.push({ x, y });
			                }
			            }
			        }
			    
			        if (安全位置列表.length < 2) {
			            console.error("王座崩坏失败：内圈没有足够的安全位置放置玩家和首领！");
			            this.领域脉冲(); 
			            return;
			        }
			    
			        安全位置列表.sort(() => prng() - 0.5);
			    
			        const 玩家新位置 = 安全位置列表.pop();
			        const 首领新位置 = 安全位置列表.pop();
			    
			        for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			            for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			                const 距离中心 = Math.sqrt(Math.pow(x - 中心X, 2) + Math.pow(y - 中心Y, 2));
			                if (距离中心 > 内圈半径) {
			                    重置单元格(x, y);
			                } else {
			                    const 单元格 = 地牢[y]?.[x];
			                    if(单元格 && 单元格.背景类型 === 单元格类型.墙壁) {
			                        单元格.背景类型 = 单元格类型.房间;
			                    }
			                }
			            }
			        }
			    
			        玩家.x = 玩家新位置.x;
			        玩家.y = 玩家新位置.y;
			    
			        this.恢复背景类型();
			        this.x = 首领新位置.x;
			        this.y = 首领新位置.y;
			        this.保存新位置类型(this.x, this.y);
			        地牢[this.y][this.x].类型 = 单元格类型.怪物;
			        地牢[this.y][this.x].关联怪物 = this;
			
			        const 墙壁候选位置 = [...安全位置列表];
			        墙壁候选位置.sort(() => prng() - 0.5); 
			        const 尝试放置墙壁数量 = Math.floor(墙壁候选位置.length * 0.25);
			
			        for (let i = 0; i < 尝试放置墙壁数量 && i < 墙壁候选位置.length; i++) {
			            const 位置 = 墙壁候选位置[i];
			            const 单元格 = 地牢[位置.y]?.[位置.x];
			            
			            if (!单元格) continue;
			
			            单元格.背景类型 = 单元格类型.墙壁;
			            
			            const 连通路径 = 广度优先搜索路径(
			                玩家新位置.x, 
			                玩家新位置.y, 
			                首领新位置.x, 
			                首领新位置.y, 
			                999,
			                true
			            );
			
			            if (连通路径.length === 0) {
			                单元格.背景类型 = 单元格类型.房间; 
			            }
			        }
			
			        生成墙壁();
			    
			        更新视口();
			        绘制();
			    }
				三连重劈(){
					this.技能冷却剩余.三连重劈=this.技能冷却.三连重劈;
					const 攻击序列=[
						{范围:3,延时:0},
						{范围:6,延时:300},
						{范围:12,延时:600}
					];
					攻击序列.forEach((攻击,index)=>{
						setTimeout(()=>{
							const 攻击路径=获取直线路径(this.x,this.y,玩家.x,玩家.y).slice(1,攻击.范围+1);
							计划显示格子特效(攻击路径,"FFA500");
							攻击路径.forEach(node=>{
								if(node.x===玩家.x&&node.y===玩家.y){
									伤害玩家(this.攻击力*(0.8+index*0.2),this);
								}
								当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.层数==当前层数 && node.x === pet.x && node.y === pet.y) {
        pet.受伤(this.攻击力 * (0.8 + index * 0.2));
        添加日志(`${pet.名称} 被三连重劈击中了！`, "警告");
    }
});
							});
						},攻击.延时);
					});
					return true;
				}
				裂隙跳跃() {
					this.技能冷却剩余.裂隙跳跃 = this.技能冷却.裂隙跳跃;
					const 旧X = this.x, 旧Y = this.y;
					const 房间ID = 房间地图[this.y][this.x];
					if (房间ID === -1) return false;
				
					const 房间 = 房间列表[房间ID];
					let 目标X, 目标Y;
					let 尝试次数 = 0;
					let 放置成功 = false;
				
					while (尝试次数 < 100 && !放置成功) {
						目标X = 房间.x + Math.floor(prng() * 房间.w);
						目标Y = 房间.y + Math.floor(prng() * 房间.h);
						if (位置是否可用(目标X, 目标Y, false) && 广度优先搜索路径(玩家.x, 玩家.y, 目标X, 目标Y, 999)) {
							放置成功 = true;
						}
						尝试次数++;
					}
				
					if (!放置成功) return false;
				
					this.恢复背景类型();
					怪物动画状态.set(this, {
			    旧逻辑X: this.x,
			    旧逻辑Y: this.y,
			    目标逻辑X: 目标X,
			    目标逻辑Y: 目标Y,
			    视觉X: this.x,
			    视觉Y: this.y,
			    动画开始时间: Date.now(),
			    正在动画: true,
			});
					this.x = 目标X;
					this.y = 目标Y;
					this.保存新位置类型(目标X, 目标Y);
					地牢[目标Y][目标X].类型 = 单元格类型.怪物;
					地牢[目标Y][目标X].关联怪物 = this;
					计划显示格子特效([{ x: 旧X, y: 旧Y }, { x: 目标X, y: 目标Y }], "8A2BE2");
					this.混沌之触();
					return true;
				}
				领域脉冲(){
					this.技能冷却剩余.领域脉冲=this.技能冷却.领域脉冲;
					const 最大半径=15;
					for(let 半径=1;半径<=最大半径;半径++){
						setTimeout(()=>{
							const 环形格子=[];
							for(let dx=-半径;dx<=半径;dx++){
								for(let dy=-半径;dy<=半径;dy++){
									if(Math.max(Math.abs(dx),Math.abs(dy))===半径){
										const x=this.x+dx;
										const y=this.y+dy;
										if(x>=0&&x<地牢大小&&y>=0&&y<地牢大小){
											环形格子.push({x,y});
										}
									}
								}
							}
							计划显示格子特效(环形格子,"8A2BE2",0);
							if(环形格子.some(格子=>格子.x===玩家.x&&格子.y===玩家.y)){
								伤害玩家(this.攻击力*1.2,this);
								let 方向DX,方向DY;
								if(玩家.x===this.x&&玩家.y===this.y){
									const 随机方向=[{dx:0,dy:1},{dx:0,dy:-1},{dx:1,dy:0},{dx:-1,dy:0}][Math.floor(prng()*4)];
									方向DX=随机方向.dx;
									方向DY=随机方向.dy;
								}else{
									方向DX=玩家.x-this.x;
									方向DY=玩家.y-this.y;
								}
								const{x:最终X,y:最终Y}=this.计算最大玩家击退位置(玩家.x,玩家.y,方向DX,方向DY);
								if(最终X!==玩家.x||最终Y!==玩家.y){
									const 旧玩家X=玩家.x,旧玩家Y=玩家.y;
									玩家.x=最终X;
									玩家.y=最终Y;
									处理玩家着陆效果(旧玩家X,旧玩家Y,最终X,最终Y);
									更新视口();
									显示通知("你被强大的冲击波猛烈推开！","警告");
									绘制();
								}
							}
						},半径*70);
					}
					return true;
				}
				计算最大玩家击退位置(起始X,起始Y,方向DX,方向DY){
					let 最终X=起始X;
					let 最终Y=起始Y;
					let 步进X=Math.sign(方向DX)||0;
					let 步进Y=Math.sign(方向DY)||0;
					if(步进X===0&&步进Y===0){
						if(Math.abs(方向DX)>Math.abs(方向DY))
							步进X=Math.sign(方向DX)||1;
						else
							步进Y=Math.sign(方向DY)||1;
					}
					for(let i=1;i<地牢大小;i++){
						const 下一步X=最终X+步进X;
						const 下一步Y=最终Y+步进Y;
						if(检查移动可行性(最终X,最终Y,下一步X,下一步Y)){
							最终X=下一步X;
							最终Y=下一步Y;
						}else{
							break;
						}
					}
					return{x:最终X,y:最终Y};
				}
				召唤混沌回响(){
					this.技能冷却剩余.召唤混沌回响=this.技能冷却.召唤混沌回响;
					const 召唤数量=2+(this.强化?1:0);
					let 成功召唤数=0;
					const 怪物池选择=怪物池.上锁房间.filter(m=>!['大魔法师','米诺陶','皇家守卫','复活怪物','萨满怪物','巨人怪物','蜈蚣怪物'].includes(m.类.name));
					for(let i=0;i<召唤数量;i++){
						const 选中配置=怪物池选择[Math.floor(prng()*怪物池选择.length)];
						
						if (所有怪物.length <= 15) {
						const 新怪物=new 选中配置.类({强化:true,状态:怪物状态.活跃});
						if(放置怪物到房间(新怪物,房间列表[房间地图[this.y][this.x]])){
							成功召唤数++;
						}
						}
					}
			
					
					return true;
				}
				混沌化身(){
					const 房间ID=房间地图[this.y][this.x];
					if(房间ID===-1)
						return;
					const 房间=房间列表[房间ID];
					for(let y=房间.y;y<房间.y+房间.h;y++){
						for(let x=房间.x;x<房间.x+房间.w;x++){
							const 单元格=地牢[y]?.[x];
							if(单元格&&单元格.背景类型===单元格类型.墙壁&&!单元格.是否强制墙壁){
								单元格.背景类型=单元格类型.房间;
							}
							if(单元格?.关联物品&&(单元格.关联物品 instanceof 火焰物品||单元格.关联物品 instanceof 毒液物品)){
								单元格.关联物品.移除自身();
							}
						}
					}
					生成墙壁();
				}
				混沌风暴(){
					this.技能冷却剩余.混沌风暴=this.技能冷却.混沌风暴;
					this.攻击冷却剩余=3;
					const 陨石数量=8+(this.强化?4:0);
					const 冲击半径=2;
					const 玩家区域半径=6;
					for(let i=0;i<陨石数量;i++){
						setTimeout(()=>{
							const 目标X=玩家.x+Math.floor((prng()-0.5)*玩家区域半径*2);
							const 目标Y=玩家.y+Math.floor((prng()-0.5)*玩家区域半径*2);
							const 陨石冲击实例=new 炸弹({能否拾起: false,爆炸范围:冲击半径,伤害:this.攻击力*1.8,来源:'boss'});
							陨石冲击实例.x=目标X;
							陨石冲击实例.y=目标Y;
							const 冲击格子=[];
							for(let dy=-冲击半径;dy<=冲击半径;dy++){
								for(let dx=-冲击半径;dx<=冲击半径;dx++){
									冲击格子.push({x:目标X+dx,y:目标Y+dy});
								}
							}
							计划显示格子特效(冲击格子,"FF4500",0);
							setTimeout(()=>{
								陨石冲击实例.触发爆炸();
							},600);
						},i*150);
					}
					显示通知("混沌风暴来袭！","错误");
					return true;
				}
				圣光弹幕(){
					this.技能冷却剩余.圣光弹幕=this.技能冷却.圣光弹幕;
					const 弹幕数量=8;
					for(let i=0;i<弹幕数量;i++){
						const 角度=(i/弹幕数量)*Math.PI*2;
						const dx=Math.cos(角度);
						const dy=Math.sin(角度);
						const 路径=[];
						for(let j=1;j<=10;j++){
							const x=Math.round(this.x+dx*j);
							const y=Math.round(this.y+dy*j);
							if(x<0||x>=地牢大小||y<0||y>=地牢大小||(地牢[y]?.[x]?.背景类型===单元格类型.墙壁))
								break;
							路径.push({x,y});
							if(x===玩家.x&&y===玩家.y){
								伤害玩家(this.攻击力*0.9,this);
							}
				当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && x === pet.x && y === pet.y) {
        pet.受伤(this.攻击力*0.9);
			        添加日志(`${pet?.名称} 被圣光弹幕击中了！`, "警告");
    }
});
						}
						计划显示格子特效(路径,"FFD700",20);
					}
					显示通知("守护者释放了圣光弹幕！","警告");
					return true;
				}
				幽魂弹幕(){
					this.技能冷却剩余.幽魂弹幕=this.技能冷却.幽魂弹幕;
					const 幽魂数量=3+(this.强化?2:0);
					const 方向列表=[[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1]];
					for(let i=0;i<幽魂数量;i++){
						const 方向=方向列表[i%方向列表.length];
						const 生成位置={x:this.x+方向[0],y:this.y+方向[1]};
						if(位置是否可用(生成位置.x,生成位置.y,false)){
							const 幽魂实例=new 移动弹幕({强化:this.强化});
							放置怪物到单元格(幽魂实例,生成位置.x,生成位置.y);
						}
					}
					return true;
				}
				墓碑召唤() {
					this.技能冷却剩余.墓碑召唤 = this.技能冷却.墓碑召唤;
					this.无敌 = true;
					this.激活的墓碑列表 = [];
					this.无敌次数++
					const 墓碑数量 = 3;
					const 房间 = 房间列表[房间地图[this.y][this.x]];
					if (!房间) return false;
				
					const 可用位置 = [];
					for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
						for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
							if (位置是否可用(x, y, false) && 广度优先搜索路径(玩家.x, 玩家.y, x, y, 999)) {
								可用位置.push({x, y});
							}
						}
					}
					可用位置.sort(() => prng() - 0.5);
				
					for (let i = 0; i < Math.min(墓碑数量, 可用位置.length); i++) {
						const 放置位置 = 可用位置[i];
						const 墓碑实例 = new 墓碑({ 守护者: this, 强化: this.强化 });
						放置怪物到单元格(墓碑实例, 放置位置.x, 放置位置.y);
						this.激活的墓碑列表.push(墓碑实例);
					}
					显示通知("守护者召唤了不详的墓碑，它现在无敌了！", "错误", true);
					return true;
				}
				强制释放随机技能(){
					const 反击技能池=[];
					if(this.当前阶段>=1){
						反击技能池.push('圣光弹幕','幽魂弹幕','召唤皇家卫队');
					}
					if(this.当前阶段>=2){
						反击技能池.push('混沌之触','裂隙跳跃');
					}
					if(this.当前阶段>=3){
						反击技能池.push('生成混沌裂隙','无尽回响');
					}
					if(反击技能池.length>0){
						const 选定技能名=反击技能池[Math.floor(prng()*反击技能池.length)];
			
						this[选定技能名]();
					}
				}
				无尽回响(){
					this.技能冷却剩余.无尽回响=this.技能冷却.无尽回响;
					const 旧X=this.x,旧Y=this.y;
					if(this.裂隙跳跃()){
						const 路径=获取直线路径(旧X,旧Y,this.x,this.y);
						路径.forEach(node=>{
							if(位置是否可用(node.x,node.y,false)){
								放置物品到单元格(new 火焰物品({倒计时:3,火焰强度:5}),node.x,node.y);
							}
						});
						return true;
					}
					return false;
				}
				生成混沌裂隙(){
					this.技能冷却剩余.生成混沌裂隙=this.技能冷却.生成混沌裂隙;
					const 房间ID=房间地图[this.y][this.x];
					if(房间ID===-1)
						return false;
					const riftCount=6+(this.强化?2:0);
					const radius=5;
					for(let i=0;i<riftCount;i++){
						const angle=(i/riftCount)*Math.PI*2;
						const x=Math.round(玩家.x+Math.cos(angle)*radius);
						const y=Math.round(玩家.y+Math.sin(angle)*radius);
						if(位置是否可用(x,y,false)){
							const 裂隙=new 远射陷阱({x:x,y:y,房间ID:房间ID,强化:this.强化,基础生命值:1,攻击冷却:1,掉落概率:0,});
							裂隙.状态=怪物状态.活跃;
							裂隙.生命周期=12;
							裂隙.更新倒计时=()=>{
								裂隙.生命周期--;
								if(裂隙.生命周期<=0){
									裂隙.受伤(999,'消散');
									所有计时器=所有计时器.filter(t=>t!==裂隙);
								}
							};
							所有计时器.push(裂隙);
							放置怪物到单元格(裂隙,x,y);
							计划显示格子特效([{x,y}],"4B0082");
						}
					}
					显示通知("混沌裂隙被撕开！","警告");
					return true;
				}
				混沌之触(){
					this.技能冷却剩余.攻击冷却=1;
					const 攻击路径=获取直线路径(this.x,this.y,玩家.x,玩家.y);
					if(攻击路径.length>1){
						计划显示格子特效(攻击路径.slice(1),"9932CC");
						if(攻击路径.some(p=>p.x===玩家.x&&p.y===玩家.y)){
							伤害玩家(this.攻击力*0.7,this);
						}
						当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && 攻击路径.some(p => p.x === pet.x && p.y === pet.y)) {
        pet.受伤(this.攻击力 * 0.7);
        添加日志(`${pet.名称} 被混沌之触击中了！`, "警告");
    }
});
						return true;
					}
					return false;
				}
				螺旋圣光(){
					this.技能冷却剩余.螺旋圣光=this.技能冷却.螺旋圣光;
					const 圈数=5+(this.强化?2:0);
					const 每圈粒子数=12;
					for(let i=1;i<=圈数;i++){
						setTimeout(()=>{
							const 路径=[];
							for(let j=0;j<每圈粒子数;j++){
								const 角度=(j/每圈粒子数)*Math.PI*2+(i*0.5);
								const x=Math.round(this.x+i*Math.cos(角度));
								const y=Math.round(this.y+i*Math.sin(角度));
								if(x>=0&&x<地牢大小&&y>=0&&y<地牢大小){
									if(!路径.some(p=>p.x===x&&p.y===y)){
										路径.push({x,y});
									}
								}
							}
							计划显示格子特效(路径,"FFD700");
							路径.forEach(点=>{
								if(点.x===玩家.x&&点.y===玩家.y){
									伤害玩家(this.攻击力*0.8,this);
								}
								当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && 点.x === pet.x && 点.y === pet.y) {
        pet.受伤(this.攻击力 * 0.8);
        添加日志(`${pet.名称} 被螺旋圣光击中了！`, "警告");
    }
});
							});
						},i*100);
					}
					显示通知(`${this.类型}释放了螺旋圣光！`,'警告');
					return true;
				}
				十字审判(){
					this.技能冷却剩余.十字审判=this.技能冷却.十字审判;
					const 弹道长度=7;
					const 爆炸长度=4;
					const 方向=[[0,-1],[1,0],[0,1],[-1,0]];
					const 终点列表=[];
					方向.forEach(dir=>{
						const 路径=[];
						let 终点={x:this.x,y:this.y};
						for(let i=1;i<=弹道长度;i++){
							const x=this.x+dir[0]*i;
							const y=this.y+dir[1]*i;
							if(x<0||x>=地牢大小||y<0||y>=地牢大小||地牢[y]?.[x]?.背景类型===单元格类型.墙壁){
								break;
							}
							路径.push({x,y});
							终点={x,y};
						}
						if(路径.length>0){
							终点列表.push(终点);
							计划显示格子特效(路径,"8A2BE2",50);
							if(路径.some(点=>点.x===玩家.x&&点.y===玩家.y)){
								伤害玩家(this.攻击力,this);
							}
							当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && 路径.some(点 => 点.x === pet.x && 点.y === pet.y)) {
        pet.受伤(this.攻击力 * 0.9);
        添加日志(`${pet.名称} 被十字审判击中了！`, "警告");
    }
});
						}
					});
					setTimeout(()=>{
						终点列表.forEach(终点=>{
							const 爆炸路径=[];
							for(let i=-爆炸长度;i<=爆炸长度;i++){
								const x=终点.x+i;
								const y=终点.y;
								if(x>=0&&x<地牢大小)
									爆炸路径.push({x,y});
							}
							for(let i=-爆炸长度;i<=爆炸长度;i++){
								const x=终点.x;
								const y=终点.y+i;
								if(y>=0&&y<地牢大小&&i!==0)
									爆炸路径.push({x,y});
							}
							计划显示格子特效(爆炸路径,"E0B0FF");
							if(爆炸路径.some(点=>点.x===玩家.x&&点.y===玩家.y)){
								伤害玩家(this.攻击力*1.2,this);
							}
							当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中")  && pet.层数==当前层数 && 爆炸路径.some(点 => 点.x === pet.x && 点.y === pet.y)) {
        pet.受伤(this.攻击力 * 1.2);
        添加日志(`${pet.名称} 被十字审判击中了！`, "警告");
    }
});
						});
					},弹道长度*50+100);
					显示通知(`${this.类型}降下十字审判！`,'警告');
					return true;
				}
				获得效果(状态效果) {
					const 免疫效果列表 = ['冻结', '魅惑', '缓慢', '中毒', '恐惧', '牵制', '眩晕'];
					if (免疫效果列表.includes(状态效果.类型)) {
						状态效果.移除状态();
						return false;
					}
					return super.获得效果(状态效果);
				}
			}
			
			class 魔法师 extends 怪物 {
    constructor(配置 = {}) {
        super({
            图标: 图标映射.魔法师,
            类型: "魔法师",
            基础生命值: 40 + (配置.强化 ? 20 : 0),
            基础攻击力: 1,
            移动率: 0.6,
            掉落物: new 附魔卷轴({}),
            掉落概率: 0.25,
            攻击冷却: 5 + (配置.强化 ? -1 : 0),
            ...配置,
        });
        this.变形范围 = 配置.变形范围??(4 + (配置.强化 ? 1 : 0));
        this.普通怪物类名列表 = [
            '怪物', '盔甲怪物', '敏捷怪物', '远攻怪物', '仙人掌怪物', '冰冻怪物', '大史莱姆怪物',
            '瞬移怪物', '伪装怪物', '腐蚀怪物', '盗贼怪物', '吸能怪物', '剧毒云雾怪物', '旋风怪物',
            '恐惧怪物', '超速怪物', '吸血鬼', '分裂怪物', '反弹怪物', '蜘蛛怪物'
        ];
    }

    尝试攻击() {
        if (this.攻击冷却回合剩余 > 0) {
            this.攻击冷却回合剩余--;
            super.尝试攻击();
            return;
        }

        const 附近怪物 = [];
        for (let dy = -this.变形范围; dy <= this.变形范围; dy++) {
            for (let dx = -this.变形范围; dx <= this.变形范围; dx++) {
                const x = this.x + dx;
                const y = this.y + dy;
                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
                const 单元格 = 地牢[y]?.[x];
                const 怪物 = 单元格?.关联怪物;
                if (怪物 && 怪物 !== this && this.普通怪物类名列表.includes(怪物.constructor.name) && 怪物.状态 === 怪物状态.活跃 && 所有怪物.includes(怪物)) {
                    附近怪物.push(怪物);
                }
            }
        }

        if (附近怪物.length > 0) {
            this.攻击冷却回合剩余 = this.攻击冷却;
            const 目标怪物 = 附近怪物[Math.floor(prng() * 附近怪物.length)];
            const 新怪物类名 = this.普通怪物类名列表[Math.floor(prng() * this.普通怪物类名列表.length)];
            const 新怪物类 = window[新怪物类名];

            if (新怪物类) {
                const 旧生命值 = 目标怪物.当前生命值;
                const 是否强化 = 目标怪物.强化;
                const 旧X = 目标怪物.x;
                const 旧Y = 目标怪物.y;
                const 旧房间ID = 目标怪物.房间ID;

                目标怪物.恢复背景类型();
                所有怪物 = 所有怪物.filter(m => m !== 目标怪物);
                怪物状态表.delete(目标怪物);

                const 新怪物 = new 新怪物类({
                    x: 旧X, y: 旧Y, 房间ID: 旧房间ID,
                    强化: 是否强化, 状态: 怪物状态.活跃
                });
                新怪物.当前生命值 = 旧生命值;

                放置怪物到单元格(新怪物, 旧X, 旧Y);
                添加日志(`${this.类型} 将 ${目标怪物.类型} 变成了 ${新怪物.类型}！`, "警告");
                计划显示格子特效([{ x: 旧X, y: 旧Y }], "8A2BE2", 50);
                return true;
            }
        }
        return super.尝试攻击();
    }
}
			class 大魔法师 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.大魔法师,
			            类型: "大魔法师",
			            房间ID: 配置.房间ID || null,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.活跃,
			            基础生命值: 配置.基础生命值 || 80,
			            基础攻击力: 配置.基础攻击力 || 8,
			            强化: 配置.强化 || false,
			            移动率: 配置.移动率 || 0.8,
			            基础攻击范围: 4,
			            跟踪距离: 20,
			            攻击冷却: 3,
			            受伤冻结回合: 1,
			            掉落物: new 真言卷轴({
			                品质: 4,
			                已解锁: true,
			                强化: true,
			            }),
			            掉落概率: 1,
			            残血逃跑: false,
			            ...配置,
			        });
			        this.当前生命值 = 配置.当前生命值 || this.生命值;
			        this.技能冷却 = {
			            隐身术: 0,
			            分身术: 0,
			            火球术: 0,
			            冰冻术: 0,
			            传送术: 0,
			            召唤术: 0,
			        };
			        this.每回合恢复量 = 配置.每回合恢复量??2;
			        this.隐身中 = false;
			        this.逃离目标 = null;
			        this.原始移动距离 = this.基础移动距离;
			        this.isClone = false;
			        this.隐身提示间隔 = 2;
			        this.隐身提示计数 = 0;
			    }
			
			    尝试移动() {
			        if (this.隐身中) {
			            this.隐身移动();
			            return;
			        }
			
			        if (this.当前生命值 <= 0) return;
			        super.尝试移动();
			
			        this.绘制血条();
			    }
			
			    选择逃离目标() {
			        const 最大距离 = this.跟踪距离; // 最大逃离距离
			        const 可达点 = [];
			
			        const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0 }];
			        const 已访问 = new Set([`${this.x},${this.y}`]);
			        const 已在房间中 = 房间地图[this.y][this.x] !== -1;
			        const 已在房间 = 房间地图[this.y][this.x];
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			
			            const 房间ID = 房间地图[当前.y][当前.x];
			            if (已访问房间.has(房间ID)) {
			                if (!已在房间中) {
			                    可达点.push({
			                        x: 当前.x,
			                        y: 当前.y,
			                        距离: 当前.距离,
			                    }); // 记录距离
			                } else {
			                    if (房间ID === 已在房间)
			                        可达点.push({
			                            x: 当前.x,
			                            y: 当前.y,
			                            距离: 当前.距离,
			                        });
			                }
			            }
			
			            if (当前.距离 > 最大距离) continue;
			
			            const 方向 = [
			                { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
			                { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
			                { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
			                { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
			            ];
			
			            for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			                const 位置键 = `${新X},${新Y}`;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    continue;
			                const 当前单元格 = 地牢[当前.y][当前.x];
			                const 目标单元格 = 地牢[新Y][新X];
			                const 移动方向 = getMoveDirection(当前.x, 当前.y, 新X, 新Y);
			                    if (目标单元格.isOneWay && 移动方向 !== 目标单元格.oneWayAllowedDirection) {
			                        continue;
			                    }
			                if (
			                    当前单元格.墙壁[当前墙] ||
			                    目标单元格.墙壁[目标墙]
			                )
			                    continue;
			                if (
			                    [单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                        目标单元格.背景类型
			                    )
			                )
			                    continue;
			
			                if (
			                    !已访问.has(位置键) &&
			                    this.位置合法(新X, 新Y)
			                ) {
			                    已访问.add(位置键);
			                    队列.push({
			                        x: 新X,
			                        y: 新Y,
			                        距离: 当前.距离 + 1,
			                    });
			                }
			            }
			        }
			
			        let 最远点 = null;
			        let 最大自身距离 = -1;
			
			        for (const 点 of 可达点) {
			            if (点.距离 > 最大自身距离) {
			                最大自身距离 = 点.距离;
			                最远点 = 点;
			            }
			        }
			
			        return 最远点;
			    }
			
			    隐身移动() {
			        if (this.当前生命值 < this.生命值) {
			            this.当前生命值 = Math.min(
			                this.生命值,
			                this.当前生命值 + this.每回合恢复量
			            );
			            this.绘制血条();
			        } else {
			            this.隐身中 = false;
			            this.基础移动距离 = this.原始移动距离;
			            添加日志(`${this.类型} 现形了!`, "信息");
			            显示通知(
			                "使用分身迷惑你后，隐身的大魔法师缓缓现出真身..."
			            );
			            this.绘制血条();
			            return;
			        }
			        if (
			            this.目标路径.length === 0 ||
			            (prng() > this.移动率 && !切换动画) ||
			            this.跟踪距离 < this.目标路径.length
			        ) {
			            this.追击玩家中 = false;
			            return;
			        }
			        if (!this.逃离目标) {
			            this.逃离目标 = this.选择逃离目标();
			        }
			        this.目标路径 = this.计算目标路径(
			            this.逃离目标.x,
			            this.逃离目标.y
			        );
			        if (this.目标路径) {
			            const 下一步 =
			                this.目标路径[
			                    Math.min(
			                        this.移动距离 - 1,
			                        this.目标路径.length - 1
			                    )
			                ];
			            const 最终位置 = this.规划移动路径();
			            if (
			                !最终位置 ||
			                (this.y === this.逃离目标.y &&
			                    this.x === this.逃离目标.x)
			            ) {
			                this.逃离目标 = null;
			                return;
			            }
			            this.恢复背景类型();
			            this.保存新位置类型(最终位置.x, 最终位置.y);
			            this.x = 最终位置.x;
			            this.y = 最终位置.y;
			            地牢[this.y][this.x].类型 = 单元格类型.怪物;
			            地牢[this.y][this.x].关联怪物 = this;
			        } else {
			            this.逃离目标 = null;
			        }
			
			        this.绘制血条();
			        this.隐身提示计数++;
			        if (this.隐身提示计数 >= this.隐身提示间隔) {
			            this.隐身提示计数 = 0;
			
			            const 画布Rect = canvas.getBoundingClientRect();
			            let 屏幕X = (this.x - 相机目标X) * 单元格大小;
			            let 屏幕Y = (this.y - 相机目标Y) * 单元格大小;
			            if (
			                屏幕X + 单元格大小 < 0 ||
			                屏幕X > 画布Rect.width ||
			                屏幕Y + 单元格大小 < 0 ||
			                屏幕Y > 画布Rect.height
			            ) {
			                return;
			            }
			            计划显示格子特效([{ x: this.x, y: this.y }], "000000");
			        }
			    }
			
			    尝试攻击() {
			        if (怪物状态表.get(this)?.类型 === "冻结") return;
			
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余 -= 1;
			            return false;
			        }
			        if (this.通向目标路径.length > this.攻击范围) return false;
			        if (!this.isClone) {
			            if (
			                this.当前生命值 < this.生命值 * 0.3 &&
			                !this.隐身中
			            ) {
			                this.隐身术();
			                this.分身术();
			                添加日志(`${this.类型} 负伤逃跑了!`, "信息");
			
			                return true;
			            } else if (this.隐身中) {
			                return true;
			            }
			        }
			
			        if (prng() < 0.5) {
			            const 技能列表 = [
			                "火球术",
			                "冰冻术",
			                "传送术",
			                "召唤术",
			            ];
			            const 随机技能 =
			                技能列表[
			                    Math.floor(prng() * 技能列表.length)
			                ];
			
			            switch (随机技能) {
			                case "火球术":
			                    if (!this.火球术()) {
			                        this.普通攻击();
			                        this.攻击冷却回合剩余 = this.攻击冷却;
			                    }
			                    break;
			                case "冰冻术":
			                    if (!this.冰冻术()) {
			                        this.普通攻击();
			                        this.攻击冷却回合剩余 = this.攻击冷却;
			                    }
			                    break;
			                case "传送术":
			                    this.传送术();
			                    break;
			                case "召唤术":
			                    if (!this.召唤术()) {
			                        this.普通攻击();
			                        this.攻击冷却回合剩余 = this.攻击冷却;
			                    }
			                    break;
			            }
			            return true;
			        } else {
			            this.普通攻击();
			            this.攻击冷却回合剩余 = this.攻击冷却;
			            return true;
			        }
			    }
			    普通攻击() {
			        const 攻击模式 = Math.floor(prng() * 4);
			        let 方向列表 = [];
			
			        switch (攻击模式) {
			            case 0:
			                方向列表 = [
			                    { dx: 0, dy: -1 },
			                    { dx: 0, dy: 1 },
			                    { dx: -1, dy: 0 },
			                    { dx: 1, dy: 0 },
			                ];
			                break;
			            case 1:
			                方向列表 = [
			                    { dx: -1, dy: -1 },
			                    { dx: 1, dy: -1 },
			                    { dx: -1, dy: 1 },
			                    { dx: 1, dy: 1 },
			                ];
			                break;
			            case 2:
			            case 3:
			                const 基本方向 = [
			                    { dx: 0, dy: -1 },
			                    { dx: 1, dy: 0 },
			                    { dx: 0, dy: 1 },
			                    { dx: -1, dy: 0 },
			                ];
			
			                const 顺时针方向变化 = [
			                    { dx: 1, dy: 0 },
			                    { dx: 0, dy: 1 },
			                    { dx: -1, dy: 0 },
			                    { dx: 0, dy: -1 },
			                ];
			
			                const 逆时针方向变化 = [
			                    { dx: 0, dy: -1 },
			                    { dx: -1, dy: 0 },
			                    { dx: 0, dy: 1 },
			                    { dx: 1, dy: 0 },
			                ];
			
			                基本方向.forEach((起始方向) => {
			                    let 当前方向 = 起始方向;
			                    let 当前X = this.x;
			                    let 当前Y = this.y;
			                    let 路径 = [];
			
			                    let 层数 = 0;
			                    while (
			                        Math.abs(当前X - this.x) +
			                            Math.abs(当前Y - this.y) <=
			                        this.攻击范围
			                    ) {
			                        层数++;
			                        let 步数 = 层数 * 2 - 1;
			
			                        if (层数 > 1) {
			                            const 方向变化 =
			                                攻击模式 === 2
			                                    ? 顺时针方向变化
			                                    : 逆时针方向变化;
			                            let 方向索引 = 方向变化.findIndex(
			                                (d) =>
			                                    d.dx === 当前方向.dx &&
			                                    d.dy === 当前方向.dy
			                            );
			
			                            方向索引 = (方向索引 + 1) % 4;
			                            当前方向 = 方向变化[方向索引];
			
			                            当前X += 当前方向.dx;
			                            当前Y += 当前方向.dy;
			                            if (
			                                !检查移动可行性(
			                                    当前X - 当前方向.dx,
			                                    当前Y - 当前方向.dy,
			                                    当前X,
			                                    当前Y
			                                )
			                            )
			                                break;
			
			                            const 单元格 = 地牢[当前Y]?.[当前X];
			                            if (
			                                单元格?.关联怪物 &&
			                                单元格.类型 === 单元格类型.怪物 &&
			                                单元格.关联怪物?.状态 ===
			                                    怪物状态.活跃 &&
			                                !(
			                                    单元格.关联怪物 instanceof
			                                    大魔法师
			                                )
			                            ) {
			                                单元格.关联怪物.受伤(
			                                    this.攻击力,
			                                    this
			                                );
			                            } else if (
			                                当前X === 玩家.x &&
			                                当前Y === 玩家.y
			                            ) {
			                                伤害玩家(this.攻击力, this);
			                            } else if (当前出战宠物列表.some(pet => pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === 当前X && pet.y === 当前Y)) {
    当前出战宠物列表.forEach(pet => {
        if (pet.x === 当前X && pet.y === 当前Y && pet.层数==当前层数 ) {
            pet.受伤(this.攻击力);
        }
    });
}
			
			                            路径.push({ x: 当前X, y: 当前Y });
			                            步数--;
			                        }
			
			                        for (let i = 0; i < 步数; i++) {
			                            当前X += 当前方向.dx;
			                            当前Y += 当前方向.dy;
			
			                            if (
			                                !检查移动可行性(
			                                    当前X - 当前方向.dx,
			                                    当前Y - 当前方向.dy,
			                                    当前X,
			                                    当前Y
			                                )
			                            )
			                                break;
			
			                            const 单元格 = 地牢[当前Y]?.[当前X];
			
			                            if (
			                                单元格?.关联怪物 &&
			                                单元格.类型 === 单元格类型.怪物 &&
			                                单元格.关联怪物?.状态 ===
			                                    怪物状态.活跃
			                            ) {
			                                单元格.关联怪物.受伤(
			                                    this.攻击力,
			                                    this
			                                );
			                            } else if (
			                                当前X === 玩家.x &&
			                                当前Y === 玩家.y
			                            ) {
			                                伤害玩家(this.攻击力, this);
			                            } else if (当前出战宠物列表.some(pet => pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === 当前X && pet.y === 当前Y)) {
    当前出战宠物列表.forEach(pet => {
        if (pet.x === 当前X && pet.y === 当前Y && pet.层数==当前层数 ) {
            pet.受伤(this.攻击力);
        }
    });
}
			                            路径.push({ x: 当前X, y: 当前Y });
			                        }
			                        if (
			                            Math.abs(当前X - this.x) +
			                                Math.abs(当前Y - this.y) >
			                            this.攻击范围
			                        )
			                            break;
			                    }
			
			                    计划显示格子特效(路径);
			                });
			                return;
			        }
			
			        方向列表.forEach((方向) => {
			            let 当前X = this.x + 方向.dx;
			            let 当前Y = this.y + 方向.dy;
			            let 路径 = [];
			
			            while (
			                Math.abs(当前X - this.x) +
			                    Math.abs(当前Y - this.y) <=
			                this.攻击范围
			            ) {
			                if (
			                    !检查移动可行性(
			                        当前X - 方向.dx,
			                        当前Y - 方向.dy,
			                        当前X,
			                        当前Y
			                    )
			                )
			                    break;
			
			                const 单元格 = 地牢[当前Y]?.[当前X];
			
			                if (
			                    单元格?.关联怪物 &&
			                    单元格.类型 === 单元格类型.怪物 &&
			                    单元格.关联怪物?.状态 === 怪物状态.活跃
			                ) {
			                    单元格.关联怪物.受伤(this.攻击力, this);
			                    break;
			                } else if (当前X === 玩家.x && 当前Y === 玩家.y) {
			                    伤害玩家(this.攻击力, this);
			                    break;
			                } else if (当前出战宠物列表.some(pet => pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === 当前X && pet.y === 当前Y)) {
    当前出战宠物列表.forEach(pet => {
        if (pet.x === 当前X && pet.y === 当前Y && pet.层数==当前层数 ) {
            pet.受伤(this.攻击力);
        }
    });
}
			
			                路径.push({ x: 当前X, y: 当前Y });
			                当前X += 方向.dx;
			                当前Y += 方向.dy;
			            }
			            计划显示格子特效(路径);
			        });
			    }
			
			    召唤术() {
			        if (this.技能冷却.召唤术 > 0) return false;
			        const 方向 = [
			            { dx: -1, dy: -1 },
			            { dx: 1, dy: -1 },
			            { dx: -1, dy: 1 },
			            { dx: 1, dy: 1 },
			        ];
			        let 召唤位置 = null;
			        for (const { dx, dy } of 方向) {
			            const x = this.x + dx;
			            const y = this.y + dy;
			            if (
			                this.位置合法(x, y) &&
			                !地牢[y][x].关联怪物 &&
			                !地牢[y][x].关联物品
			            ) {
			                召唤位置 = { x, y };
			                break;
			            }
			        }
			        if (!召唤位置) {
			            添加日志(
			                `${this.类型} 尝试召唤，但周围没有可用空间！`,
			                "信息"
			            );
			            return false;
			        }
			        const 追踪数 = 跟踪玩家怪物数;
			        let 召唤数量 = 2;
			        if (追踪数 >= 5) {
			            return false;
			        } else if (追踪数 >= 3) {
			            召唤数量 = 1;
			        }
			        const 可召唤怪物 = [];
			        for (let 房间类型 in 怪物池) {
			            怪物池[房间类型].forEach((怪物配置) => {
			                if (怪物配置.类 !== 大魔法师 && !(怪物配置.类 instanceof 大魔法师)
				 && !(怪物配置.类 instanceof 米诺陶) 
				 && !(怪物配置.类 instanceof 墓碑) && !(怪物配置.类 instanceof 王座守护者)
				 && !(怪物配置.类 instanceof 皇家守卫)
				 && !(怪物配置.类 instanceof 复活怪物)
				 && !(怪物配置.类 instanceof 巨人怪物)
				 && !(怪物配置.类 instanceof 追踪风弹弹头)
				 && !(怪物配置.类 instanceof 蜈蚣部位)) {
			                    可召唤怪物.push(怪物配置);
			                }
			            });
			        }
			        for (let i = 0; i < 召唤数量; i++) {
			            const 总权重 = 可召唤怪物.reduce(
			                (sum, m) => sum + m.权重,
			                0
			            );
			            let 随机值 = prng() * 总权重;
			            let 选中配置 = null;
			
			            for (const m of 可召唤怪物) {
			                if (随机值 <= m.权重) {
			                    选中配置 = m;
			                    break;
			                }
			                随机值 -= m.权重;
			            }
			            if (召唤位置) {
			                if (!this.位置合法(召唤位置.x, 召唤位置.y)) break;
			            }
			            const 新怪物 = new 选中配置.类({
			                x: 召唤位置.x,
			                y: 召唤位置.y,
			                房间ID: 房间地图[召唤位置.y][召唤位置.x],
			                状态: 怪物状态.活跃,
			                强化: prng() < 0.3,
			            });
			            放置怪物到单元格(新怪物, 召唤位置.x, 召唤位置.y);
			            新怪物.处理地形效果();
			
			            计划显示格子特效(
			                [{ x: 召唤位置.x, y: 召唤位置.y }],
			                "800080"
			            );
			            for (const { dx, dy } of 方向) {
			                const x = this.x + dx;
			                const y = this.y + dy;
			                if (
			                    this.位置合法(x, y) &&
			                    !地牢[y][x].关联怪物 &&
			                    !地牢[y][x].关联物品
			                ) {
			                    召唤位置 = { x, y };
			                    break;
			                }
			            }
			        }
			        显示通知(`${this.类型} 使用了召唤术！`, "信息");
			        this.技能冷却.召唤术 = 8;
			        return true;
			    }
			
			    隐身术() {
			        if (this.隐身中) return;
			
			        this.逃离目标 = this.选择逃离目标();
			        this.隐身中 = true;
			        this.基础移动距离 = 2;
			        this.绘制血条(true);
			        添加日志(`${this.类型} 使用了隐身术!`, "信息");
			    }
			
			    分身术() {
			        if (
			            this.技能冷却.分身术 > 0 ||
			            this.分身?.当前生命值 > 0 ||
			            this.isClone
			        )
			            return;
			        if (this.分身?.当前生命值 > 0) {
			            this.分身.恢复背景类型();
			            this.分身.血条元素.remove();
			            所有怪物 = 所有怪物.filter((m) => m !== this.分身);
			        }
			        let x = this.x;
			        let y = this.y;
			        const 分身 = new 大魔法师({
			            x: x,
			            y: y,
			            当前生命值: this.当前生命值,
			            房间ID: this.房间ID,
			        });
			        this.分身 = 分身;
			        分身.isClone = true;
			        let 放置 = 怪物放置物品(分身, x, y);
			        if (放置.x === null) {
			            this.分身.当前生命值 = 0;
			        }
			        this.尝试移动();
			        添加日志(`${this.类型} 使用了分身术!`, "信息");
			        this.技能冷却.分身术 = 10;
			    }
			
			    火球术() {
			        if (this.技能冷却.火球术 > 0) return false;
			
			        const 最大距离 = 8;
			        const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;
			
			        if (玩家距离 > 0 && 玩家距离 <= 最大距离) {
			            const 攻击路径 = this.计算目标路径(玩家.x, 玩家.y);
			            if (攻击路径) {
			                计划显示格子特效(攻击路径);
			
			                const 扔出炸弹 = new 炸弹({
			                    能否拾起: false,
			                    颜色索引: 4,
			                });
			                let 目标 = {};
			                目标 = 玩家放置物品(扔出炸弹);
			                if (目标.x !== null || 目标.y !== null) {
			                    扔出炸弹.使用(false, 目标.x, 目标.y);
			                }
			                添加日志(`${this.类型} 使用了火球术!`, "信息");
			                this.技能冷却.火球术 = 4;
			                return true;
			            } else {
			                return false;
			            }
			        }
			    }
			
			    冰冻术() {
			        if (this.技能冷却.冰冻术 > 0) return false;
			        const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;
			        const 范围 = 2;
			        if (玩家距离 > 范围) return false;
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                const x = this.x + dx;
			                const y = this.y + dy;
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小
			                ) {
			                    const 单元格 = 地牢[y][x];
			
			                    if (
			                        单元格.关联怪物 &&
			                        单元格.关联怪物.类型 !== "冰冻怪物" &&
			                        单元格.关联怪物.类型 !== "大魔法师"
			                    ) {
			                        new 状态效果(
			                            "冻结",
			                            "#2196F3",
			                            "冻",
			                            3,
			                            null,
			                            null,
			                            单元格.关联怪物
			                        );
			                    }
			                    if (
			                        x === 玩家.x &&
			                        y === 玩家.y &&
			                        !Array.from(
			                            { length: 装备栏每页装备数 },
			                            (_, i) =>
			                                玩家装备.get(
			                                    当前装备页 * 装备栏每页装备数 +
			                                        i +
			                                        1
			                                )
			                        )
			                            .filter((v) => v != null)
			                            .some((item) => item.名称 === "冰盾")
			                    ) {
			                        伤害玩家(this.攻击力, this);
			                        new 状态效果(
			                            "冻结",
			                            "#2196F3",
			                            图标映射.冰冻怪物,
			                            3,
			                            3
			                        );
			                    }
								if (当前出战宠物列表.some(pet => pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === x && pet.y === y)) {
    当前出战宠物列表.forEach(pet => {
        if (pet.x === x && pet.y === y && pet.层数==当前层数 ) {
            pet.受伤(999);
        }
    });
}
			                    if (单元格.关联物品 instanceof 炸弹) {
			                        if (!单元格.关联物品.能否拾起) {
			                            单元格.关联物品.自定义数据.set(
			                                "倒计时",
			                                单元格.关联物品.自定义数据.get(
			                                    "爆炸时间"
			                                )
			                            );
			                            单元格.关联物品.能否拾起 = true;
			                            所有计时器 = 所有计时器.filter(
			                                    (item) =>
			                                        item.x !== 单元格.关联物品.x || item.y !== 单元格.关联物品.y
			                                );
			                            单元格.关联物品.x = null;
			                            单元格.关联物品.y = null;
			                            添加日志("炸弹已被熄灭！", "信息");
			                            绘制();
			                        }
			                    }
			                    if (单元格.关联物品 instanceof 火焰物品) {
			                        单元格.关联物品 = null;
			                        if (单元格.类型 === 单元格类型.物品)
			                            单元格.类型 = null;
			                        单元格.颜色索引 = 颜色表.length;
			                    }
			                }
			                if (单元格.关联怪物?.类型 !== "大魔法师") {
			                    计划显示格子特效([{ x: x, y: y }], "0000DD");
			                }
			            }
			        }
			        添加日志(`${this.类型} 使用了冰冻术!`, "信息");
			        this.技能冷却.冰冻术 = 6;
			        return true;
			    }
			    传送术() {
			        if (this.技能冷却.传送术 > 0) return;
			
			        const 最小距离 = 5;
			        const 最大距离 = 10;
			
			        const 可达点 = [];
			        const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
			        const 已访问 = new Set([`${this.x},${this.y} `]);
			
			        const 方向 = [
			            { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
			            { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
			            { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
			            { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
			        ];
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			
			            if (
			                当前.距离 >= 最小距离 &&
			                当前.距离 <= 最大距离 &&
			                已访问房间.has(房间地图[当前.y][当前.x])
			            ) {
			                可达点.push({ x: 当前.x, y: 当前.y });
			            }
			
			            if (当前.距离 > 最大距离) continue;
			
			            for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			                const 位置键 = `${新X},${新Y} `;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    continue;
			                const 当前单元格 = 地牢[当前.y][当前.x];
			                const 目标单元格 = 地牢[新Y][新X];
			                if (
			                    当前单元格.墙壁[当前墙] ||
			                    目标单元格.墙壁[目标墙]
			                )
			                    continue;
			                if (
			                    [单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                        目标单元格.背景类型
			                    )
			                )
			                    continue;
			
			                if (
			                    !已访问.has(位置键) &&
			                    this.位置合法(新X, 新Y)
			                ) {
			                    已访问.add(位置键);
			                    队列.push({
			                        x: 新X,
			                        y: 新Y,
			                        距离: 当前.距离 + 1,
			                    });
			                }
			            }
			        }
			
			        const 旧X = this.x;
			        const 旧Y = this.y;
			        if (可达点.length > 0) {
			            const 目标点 =
			                可达点[Math.floor(prng() * 可达点.length)];
			            this.恢复背景类型();
			            this.保存新位置类型(目标点.x, 目标点.y);
			            this.x = 目标点.x;
			            this.y = 目标点.y;
			            地牢[this.y][this.x].类型 = 单元格类型.怪物;
			            地牢[this.y][this.x].关联怪物 = this;
			            添加日志(`${this.类型} 使用了传送术!`, "信息");
			            this.技能冷却.传送术 = 7;
			            this.处理地形效果();
			            怪物动画状态.set(this, {
			                旧逻辑X: 旧X,
			                旧逻辑Y: 旧Y,
			                目标逻辑X: this.x,
			                目标逻辑Y: this.y,
			                视觉X: 旧X,
			                视觉Y: 旧Y,
			                动画开始时间: Date.now(),
			                正在动画: true,
			            });
			        }
			    }
			    受伤(伤害, 来源 = null) {
			        const 获取房间 = (名称) =>
			            房间列表.find((r) => r.名称 === 名称);
			        if (来源?.x!==玩家.x||来源?.y!==玩家.y) return false;
			        if (this.当前生命值 > 0) {
			            this.当前生命值 -= 伤害;
			            if (中文模式) this.触发受击动画();
			
			            if (this.当前生命值 <= 0) {
			                已击杀怪物数++;
			                const 能量条 = document.querySelector(".power-bar");
			                const 当前能量 =
			                    parseFloat(能量条.style.width) || 100;
			                能量条.style.width = `${Math.min(
			                    100,
			                    当前能量 + 7/自定义全局设置.初始能量值*100
			                )}%`;
			                击杀提示.更新({
			                    内容: `已击杀怪物：${已击杀怪物数} `,
			                });
			                const 装备宠物列表 = Array.from(
			                    { length: 装备栏每页装备数 },
			                    (_, i) =>
			                        玩家装备.get(
			                            当前装备页 * 装备栏每页装备数 + i + 1
			                        )
			                )
			                    .filter((v) => v != null)
			                    .filter((装备) => 装备 instanceof 宠物);
			                装备宠物列表.forEach((宠物) => {
			                    const 经验值 = Math.floor(this.基础生命值 / 10);
			                    宠物.获得经验(经验值);
			                });
			
			                this.恢复背景类型();
			                
			                所有怪物 = 所有怪物.filter((m) => m !== this);
			                for (let 纵坐标 = 获取房间("最终秘室").y; 纵坐标 < 获取房间("最终秘室").y + 获取房间("最终秘室").h; 纵坐标++) {
			        for (let 横坐标 = 获取房间("最终秘室").x; 横坐标 < 获取房间("最终秘室").x + 获取房间("最终秘室").w; 横坐标++) {
			            const 单元格 = 地牢[纵坐标]?.[横坐标];
			            if (单元格) {
			                // 移除物品
			                if (单元格.关联物品) {
			                    // 如果物品在计时器列表中，也一并移除
			                    const 计时器索引 = 所有计时器.findIndex(计时器 => 计时器.唯一标识 === 单元格.关联物品.唯一标识);
			                    if (计时器索引 !== -1) {
			                        所有计时器.splice(计时器索引, 1);
			                    }
			                    单元格.关联物品 = null;
			                }
			                // 移除怪物
			                if (单元格.关联怪物) {
			                    所有怪物 = 所有怪物.filter(怪物 => 怪物 !== 单元格.关联怪物);
			                    单元格.关联怪物 = null;
			                }
			                // 重置单元格类型，但保留背景类型
			                if (单元格.类型 !== null) {
			                    单元格.类型 = null;
			                }
			            }
			            }
			        }
			
			                if (
			                    this.isClone !== true &&
			                    prng() <=
			                        this.物品掉率 * 玩家属性.掉落倍率
			                ) {
			                    if (this.掉落物.自定义数据.get("耐久"))
			                        this.掉落物.自定义数据.set(
			                            "耐久",
			                            Math.floor(
			                                Math.min(
			                                    this.掉落物.自定义数据.get(
			                                        "耐久"
			                                    ),
			                                    this.掉落物.自定义数据.get(
			                                        "耐久"
			                                    ) *
			                                        玩家属性.掉落倍率 *
			                                        prng() *
			                                        prng()
			                                )
			                            )
			                        );
			                    if (房间列表[房间地图[this.y][this.x]]) {
			                        放置物品到单元格(
			                            this.掉落物,
			                            this.x,
			                            this.y
			                        );
			                        生成奖励(
			                            房间列表[房间地图[this.y][this.x]]
			                        );
			                        放置物品到房间(
			                            new 魔法师法杖({}),
			                            获取房间("最终秘室")
			                        );
			                        放置物品到房间(
			                            new 大师附魔卷轴({}),
			                            获取房间("最终秘室")
			                        );
			                        放置物品到房间(
			                            new 小书魔({}),
			                            获取房间("最终秘室")
			                        );
			                        if (游戏状态 === '地图编辑器' || 游戏状态 === '编辑器游玩') {
			                        
			                        放置物品到房间(new 旗帜(),获取房间("最终秘室"));
									} else if (游戏状态 !== '图鉴') {
										放置楼梯(
											获取房间("最终秘室"),
											楼梯图标.下楼,
											单元格类型.楼梯下楼
										);
									}
			                        
			                        显示通知("大魔法师被彻底抹除了...");
			                    }
			                }
			
			                const 玩家单元格 = 地牢[玩家.y][玩家.x];
			                if (
			                    玩家单元格.关联物品 &&
			                    玩家单元格.类型 === 单元格类型.物品
			                ) {
			                    if (尝试收集物品(玩家单元格.关联物品)) {
			                        玩家单元格.类型 = null;
			                        玩家单元格.关联物品 = null;
			                    }
			                }
			                return;
			            }
			            this.绘制血条();
			        }
			    }
			
			    更新技能冷却() {
			        for (const 技能 in this.技能冷却) {
			            if (this.技能冷却[技能] > 0) {
			                this.技能冷却[技能]--;
			            }
			        }
			    }
			    绘制血条(隐藏血条 = false) {
			        if (this.隐身中) {
			            
			            return;
			        }
			        super.绘制血条(隐藏血条);
			    }
			}
			

	        class 反弹怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.反弹怪物,
			            类型: "反弹怪物",
			            基础生命值: 30 + (配置.强化 ? 10 : 0),
			            基础攻击力: 6,
			            移动率: 0.7,
			            掉落物: new 钢制板甲({强化: true}),
			            掉落概率: 0.2,
			            ...配置,
			        });
			        this.当前反弹伤害 = 配置.当前反弹伤害??6;
			    }

			    get 攻击力() {
			        return this.当前反弹伤害;
			    }

			    受伤(伤害, 来源 = null) {
			        if (!this.强化) {
			            this.当前反弹伤害 = Math.max(this.当前反弹伤害, Math.floor(伤害));
			        } else {
			            this.当前反弹伤害 += Math.floor(Math.abs(伤害))
			        }
			        super.受伤(伤害, 来源);
			    }

			    尝试攻击() {
			        const 攻击成功 = super.尝试攻击();
			        if (this?.目标.x !== 玩家.x || this?.目标.y !== 玩家.y) {
			            return 攻击成功;
			        }
			        if (攻击成功) {
			            const 自身状态 = 怪物状态表.get(this);
			            const 负面效果列表 = ["中毒", "火焰", "缓慢", "腐蚀", "眩晕", "恐惧", "牵制", "魅惑"];
			            if (自身状态 && 负面效果列表.includes(自身状态.类型)) {
			                const 怪物专属效果 = ["魅惑","恐惧"];
			                let 效果已转移 = false;
			                if (怪物专属效果.includes(自身状态.类型)) {
			                    new 状态效果("中毒", 效果颜色编号映射[效果名称编号映射.中毒], "☠️", 3, null, null, null, 2);
			                    添加日志(`${this.类型} 将 ${自身状态.类型} 效果转化为毒素传递给了你！`, "错误");
			                    效果已转移 = true;
			                } else {
			                    new 状态效果(
			                        自身状态.类型,
			                        自身状态.颜色,
			                        自身状态.图标,
			                        自身状态.持续时间,
			                        null,
			                        null,
			                        null,
			                        自身状态.强度
			                    );
			                    添加日志(`${this.类型} 将 ${自身状态.类型} 效果传递给了你！`, "错误");
			                    效果已转移 = true;
			                }
			                if (效果已转移) {
			                    自身状态.移除状态();
			                }
			            }
			        }
			        return 攻击成功;
			    }
			}
  

			class 蜘蛛怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.蜘蛛怪物,
			            类型: "蜘蛛怪物",
			            基础生命值: 28 + (配置.强化 ? 12 : 0),
			            基础攻击力: 4 + (配置.强化 ? 2 : 0),
			            移动率: 0.8,
			            掉落物: new 渔网({数量: 2}),
			            掉落概率: 0.4,
			            基础攻击范围: 1,
			            ...配置,
			        });
			        this.喷吐冷却 = 配置.喷吐冷却??(3-(配置.强化 ? 1 : 0));
			        this.喷吐冷却剩余 = 配置.喷吐冷却剩余??0;
			    }

			    尝试移动() {
			        const 旧X = this.x;
			        const 旧Y = this.y;
			        super.尝试移动();
			        if ((this.x !== 旧X || this.y !== 旧Y)&&prng()<0.5) {
			            const 蛛网实例 = new 蛛网({强化: this.强化});
			            放置物品到单元格(蛛网实例, 旧X, 旧Y);
			        }
			    }

			    尝试攻击() {
			        if (this.喷吐冷却剩余 > 0) {
			            this.喷吐冷却剩余--;
			        }
			        const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (玩家距离 > 1 && 玩家距离 <= 5 && this.喷吐冷却剩余 <= 0 && 检查视线(this.x, this.y, 玩家.x, 玩家.y)) {
			            const 蛛网实例 = new 蛛网({强化: this.强化});
			            放置物品到单元格(蛛网实例, 玩家.x, 玩家.y);
			            添加日志(`${this.类型} 向你喷吐了蛛网！`, "警告");
			            计划显示格子特效(获取直线路径(this.x, this.y, 玩家.x, 玩家.y), "FFFFFF");
			            this.喷吐冷却剩余 = this.喷吐冷却;
			            return true;
			        }
			        return super.尝试攻击();
			    }
			}
			class 腐蚀怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.腐蚀怪物,
			            类型: "腐蚀怪物",
			            基础生命值: 35 + (配置.强化 ? 15 : 0),
			            基础攻击力: 4 + (配置.强化 ? 2 : 0),
			            掉落物: new 重铸台({}),
			            掉落概率: 0.1,
			            攻击冷却: 1,
			            ...配置,
			        });
			        this.腐蚀强度 = 配置.腐蚀强度??(1 + (配置.强化 ? 1 : 0));
			        this.腐蚀持续 = 配置.腐蚀持续??(4 + (配置.强化 ? 2 : 0));
			    }
			
			    尝试攻击() {
        const 攻击成功 = super.尝试攻击();
        if (攻击成功) {
            if (怪物状态表.get(this)?.类型 === "魅惑") {
            } else if (this.目标 instanceof 宠物){
                 new 状态效果(
                    "腐蚀",
                    "#8FBC8F",
                    "☠️",
                    this.腐蚀持续,
                    null,
                    this,
                    this.目标,
                    this.腐蚀强度
                );
                添加日志(`你的宠物 ${this.目标.名称} 被腐蚀了！`, "错误");
            } else if (this.目标?.x==玩家.x && this.目标?.y==玩家.y){
                new 状态效果(
                    "腐蚀",
                    "#8FBC8F",
                    "☠️",
                    this.腐蚀持续,
                    null,
                    this,
                    null,
                    this.腐蚀强度
                );
                添加日志("你的装备被腐蚀了！", "错误");
            }
            return true;
        }
        return false;
    }
			
			    应用效果() {
			        const 腐蚀量 = 1 + Math.floor(this.腐蚀强度 / 2);
			        let 实际腐蚀 = false;
			        Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter((v) => v != null).forEach((装备) => {
			                if (
			                    装备.自定义数据?.has("耐久") &&
			                    !装备.自定义数据.get("不可破坏")
			                ) {
			                    const 额外腐蚀 = 装备.材质 === 材料.铁质 ? 腐蚀量 : 0;
			                    const 总腐蚀量 = 腐蚀量 + 额外腐蚀;
			                    const 原耐久 = 装备.自定义数据.get("耐久");
			                    装备.自定义数据.set(
			                        "耐久",
			                        Math.max(0, 原耐久 - 总腐蚀量)
			                    );
			                    if (
			                        原耐久 > 0 &&
			                        装备.自定义数据.get("耐久") === 0
			                    ) {
			                        添加日志(
			                            `${装备.名称} 被腐蚀损坏了！`,
			                            "错误"
			                        );
			                        处理销毁物品(装备.唯一标识, true);
			                        实际腐蚀 = true;
			                    } else if (
			                        装备.自定义数据.get("耐久") < 原耐久
			                    ) {
			                        添加日志(
			                            `${装备.名称} 被腐蚀了！损失 ${总腐蚀量} 点耐久。`,
			                            "错误"
			                        );
			                        实际腐蚀 = true;
			                    }
			                }
			            });
			        if (实际腐蚀) {
			            更新装备显示();
			        }
			    }
			    移除效果() {
			        return true;
			    }
			}
			class 盗贼怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.盗贼怪物,
			            类型: "盗贼怪物",
			            基础生命值: 25 + (配置.强化 ? 10 : 0),
			            基础攻击力: 4 + (配置.强化 ? 1 : 0),
			            移动率: 0.8,
			            基础移动距离: 2,
			            掉落物: new 神偷手({}),
			            掉落概率: 0.3,
			            跟踪距离: 20,
			            ...配置,
			        });
			        this.偷窃几率 = 配置.偷窃几率??(0.5 + (配置.强化 ? 0.2 : 0));
			        this.偷窃武器几率 = 配置.偷窃武器几率??(0.15 + (配置.强化 ? 0.1 : 0));
			        this.偷窃装备几率 = 配置.偷窃装备几率??(0.15 + (配置.强化 ? 0.1 : 0));
			        this.偷到的金币 = 0;
			        this.偷到的武器列表 = [];
			    }
			
			    尝试攻击() {
			        if (怪物状态表.get(this)?.类型 === "魅惑") {
			            return super.尝试攻击();
			        }
			
			        const 攻击成功 = super.尝试攻击();
			        if (攻击成功) {
			            if (prng() < this.偷窃几率) {
			                const 玩家金币 = [...玩家背包.values()]
			                    .filter((i) => i instanceof 金币)
			                    .reduce((sum, i) => sum + i.堆叠数量, 0);
			                if (玩家金币 > 0) {
			                    const 偷窃数量 = Math.min(
			                        玩家金币,
			                        Math.floor(
			                            prng() * (5 + this.攻击力)
			                        ) + 1
			                    );
			                    if (扣除金币(偷窃数量)) {
			                        this.偷到的金币 += 偷窃数量;
			                        显示通知(
			                            `${this.类型} 偷走了你的 ${偷窃数量} 金币！`,
			                            "错误"
			                        );
			                        添加日志(
			                            `${this.类型} 偷走了 ${偷窃数量} 金币！`,
			                            "错误"
			                        );
			                    }
			                }
			            
			
			            if (prng() < this.偷窃武器几率) {
			                let 玩家装备武器 = Array.from(
			                    { length: 装备栏每页装备数 },
			                    (_, i) =>
			                        玩家装备.get(
			                            当前装备页 * 装备栏每页装备数 + i + 1
			                        )
			                )
			                    .filter((v) => v != null)
			                    .filter((item) => item instanceof 武器类);
			
			                if (玩家装备武器.length > 1) {
			                    const 目标武器索引 = Math.floor(
			                        prng() * 玩家装备武器.length
			                    );
			                    const 被偷武器 = 玩家装备武器[目标武器索引];
			
			                    玩家装备.delete(被偷武器.装备槽位);
			                    被偷武器.已装备 = false;
			                    const 原槽位 = 被偷武器.装备槽位;
			                    被偷武器.装备槽位 = null;
			
			                    this.偷到的武器列表.push(被偷武器);
			                    玩家背包.delete(被偷武器.唯一标识);
			                    被偷武器.已装备 = false;
			                    被偷武器.装备槽位 = null;
			
			                    显示通知(
			                        `${
			                            this.类型
			                        } 偷走了你的 ${被偷武器.获取名称()}！`,
			                        "错误"
			                    );
			                    添加日志(
			                        `${
			                            this.类型
			                        } 偷走了 ${被偷武器.获取名称()}！`,
			                        "错误"
			                    );
			
			                    更新装备显示();
			                    更新背包显示();
			                }
			                } else if (prng()<this.偷窃装备几率){
			                let 玩家装备装甲 = Array.from(
			                    { length: 装备栏每页装备数 },
			                    (_, i) =>
			                        玩家装备.get(
			                            当前装备页 * 装备栏每页装备数 + i + 1
			                        )
			                )
			                    .filter((v) => v != null)
			                    .filter((item) => item instanceof 防御装备类);
			                if (玩家装备装甲.length <= 1) return 攻击成功;
			
			                const 目标武器索引 = Math.floor(
			                    prng() * 玩家装备装甲.length
			                );
			                const 被偷装甲 = 玩家装备装甲[目标武器索引];
			
			                if (被偷装甲) {
			                    玩家装备.delete(被偷装甲.装备槽位);
			                    被偷装甲.已装备 = false;
			                    const 原槽位 = 被偷装甲.装备槽位;
			                    被偷装甲.装备槽位 = null;
			
			                    this.偷到的武器列表.push(被偷装甲);
			                    玩家背包.delete(被偷装甲.唯一标识);
			                    被偷装甲.已装备 = false;
			                    被偷装甲.装备槽位 = null;
			
			                    显示通知(
			                        `${
			                            this.类型
			                        } 偷走了你的 ${被偷装甲.获取名称()}！`,
			                        "错误"
			                    );
			                    添加日志(
			                        `${
			                            this.类型
			                        } 偷走了 ${被偷装甲.获取名称()}！`,
			                        "错误"
			                    );
			
			                    更新装备显示();
			                    更新背包显示();
			                }
			            }
			            }
			            }
			        
			        return 攻击成功;
			    }
			
			    受伤(伤害, 来源 = null) {
			        const 原始血量 = this.当前生命值;
			        super.受伤(伤害, 来源);
			
			        if (原始血量 > 0 && this.当前生命值 <= 0) {
			            let 掉落成功 = false;
			
			            if (this.偷到的金币 > 0) {
			                const 掉落金币 = new 金币({
			                    数量: this.偷到的金币,
			                });
			                if (放置物品到单元格(掉落金币, this.x, this.y)) {
			                    添加日志(
			                        `${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`,
			                        "成功"
			                    );
			                    掉落成功 = true;
			                } else {
			                    let 方向 = [
			                        [0, -1],
			                        [0, 1],
			                        [-1, 0],
			                        [1, 0],
			                    ];
			                    for (const [dx, dy] of 方向) {
			                        if (
			                            放置物品到单元格(
			                                掉落金币,
			                                this.x + dx,
			                                this.y + dy
			                            )
			                        ) {
			                            添加日志(
			                                `${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`,
			                                "成功"
			                            );
			                            掉落成功 = true;
			                            break;
			                        }
			                    }
			                    if (!掉落成功) {
			                        方向 = [
			                            [1, -1],
			                            [1, 1],
			                            [-1, -1],
			                            [1, -1],
			                        ];
			                        for (const [dx, dy] of 方向) {
			                            if (
			                                放置物品到单元格(
			                                    掉落金币,
			                                    this.x + dx,
			                                    this.y + dy
			                                )
			                            ) {
			                                添加日志(
			                                    `${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`,
			                                    "成功"
			                                );
			                                掉落成功 = true;
			                                break;
			                            }
			                        }
			                    }
			                }
			                if (!掉落成功)
			                    添加日志(
			                        `${this.类型} 死亡，但未能掉落金币（周围无空间）`,
			                        "警告"
			                    );
			            }
			
			            this.偷到的武器列表.forEach((武器) => {
			                掉落成功 = false;
			                if (放置物品到单元格(武器, this.x, this.y)) {
			                    添加日志(
			                        `${
			                            this.类型
			                        } 死亡，掉落了 ${武器.获取名称()}！`,
			                        "成功"
			                    );
			                    掉落成功 = true;
			                } else {
			                    let 方向 = [
			                        [0, -1],
			                        [0, 1],
			                        [-1, 0],
			                        [1, 0],
			                    ];
			                    for (const [dx, dy] of 方向) {
			                        if (
			                            放置物品到单元格(
			                                武器,
			                                this.x + dx,
			                                this.y + dy
			                            )
			                        ) {
			                            添加日志(
			                                `${
			                                    this.类型
			                                } 死亡，掉落了 ${武器.获取名称()}！`,
			                                "成功"
			                            );
			                            掉落成功 = true;
			                            break;
			                        }
			                    }
			
			                }
			                if (!掉落成功) {
			                    添加日志(
			                        `${
			                            this.类型
			                        } 死亡，但未能掉落 ${武器.获取名称()}（周围无空间）`,
			                        "警告"
			                    );
			
			                    if (尝试收集物品(武器, true)) {
			                        添加日志(
			                            `${武器.获取名称()} 已返回你的背包！`,
			                            "成功"
			                        );
			                    } else {
			                        添加日志(
			                            `背包已满，无法返还 ${武器.获取名称()}！`,
			                            "错误"
			                        );
			                    }
			                }
			            });
			            this.偷到的武器列表 = [];
			            更新背包显示();
			        }
			    }
			}
			class 吸能怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.吸能怪物,
			            类型: "吸能怪物",
			            基础生命值: 28 + (配置.强化 ? 12 : 0),
			            基础攻击力: 4 + (配置.强化 ? 2 : 0),
			            掉落物: new 能量药水({ 数量: 1 }),
			            掉落概率: 0.4,
			            基础攻击范围: 2, // 增加攻击范围以便吸附
			            ...配置,
			        });
			        this.吸能比例 = 配置.吸能比例??(0.3 + (配置.强化 ? 0.15 : 0));
			        this.最小吸能 = 配置.最小吸能 ?? (5 + (配置.强化 ? 10 : 0));
			        this.吸附距离 = 配置.吸附距离??(2 + (配置.强化 ? 1 : 0));
			        this.吸附冷却 = 配置.吸附冷却??(3 - (配置.强化 ? 1 : 0)); // 吸附技能冷却时间
			        this.吸附冷却剩余 = 配置.吸附冷却剩余??0;
			    }
			
			    尝试移动() {
			        if (this.吸附冷却剩余 > 0) {
			            this.吸附冷却剩余--;
			        }
			        const 玩家距离 =
			            Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			
			        if (玩家距离 <= this.吸附距离 && this.吸附冷却剩余 <= 0) {
			            const 路径 = 获取直线路径(
			                玩家.x,
			                玩家.y,
			                this.x,
			                this.y
			            );
			            if (路径 && 路径.length > 1) {
			                计划显示格子特效(路径.slice(1, -1), "8A2BE2");
			                const { 成功吸附, 新玩家X, 新玩家Y } =
			                    this.尝试吸附玩家();
			                if (成功吸附) {
			                    const 旧吸附X = 玩家.x,
			                        旧吸附Y = 玩家.y;
			                    玩家.x = 新玩家X;
			                    玩家.y = 新玩家Y;
			                    玩家动画状态 = {
			         正在动画: true,
			         旧逻辑X: 旧吸附X,
			         旧逻辑Y: 旧吸附Y,
			         目标逻辑X: 玩家.x,
			         目标逻辑Y: 玩家.y,
			         视觉X: 旧吸附X,
			         视觉Y: 旧吸附Y,
			         动画开始时间: Date.now()
			     };
			                    添加日志("你被吸能怪物拉近了！", "警告");
			                    处理玩家着陆效果(
			                        旧吸附X,
			                        旧吸附Y,
			                        玩家.x,
			                        玩家.y
			                    );
			                    更新视口();
			                    绘制();
			                    this.吸附冷却剩余 = this.吸附冷却;
			                }
			            }
			        }
			        super.尝试移动();
			    }
			
			    尝试攻击() {
			        if (怪物状态表.get(this)?.类型 === "冻结") return false;
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余 -= 1;
			            return false;
			        }
			        this.绘制血条();
			
			        if (this.通向目标路径.length > this.攻击范围) return false;
			
			        if (怪物状态表.get(this)?.类型 === "魅惑") {
			            if (
			                this.魅惑目标怪物 !== this &&
			                this.魅惑目标怪物 !== null
			            ) {
			                this.魅惑目标怪物?.受伤(this.攻击力, this);
			                this.攻击冷却回合剩余 = this.攻击冷却;
			                计划显示格子特效(this.通向目标路径);
			                return true;
			            } else {
			                return false;
			            }
			        }
			
			        const 攻击成功 = super.尝试攻击();
			        if (攻击成功) {
			            const 造成伤害 = this.攻击力;
			            const 吸取量 = Math.max(
			                this.最小吸能,
			                Math.ceil(造成伤害 * this.吸能比例)
			            );
			            if (扣除能量(吸取量)) {
			                const 能量条 = document.querySelector(".power-bar");
			                const 当前能量 =
			                    parseFloat(能量条.style.width) || 0;
			                添加日志(
			                    `${this.类型} 吸取了你 ${吸取量.toFixed(
			                        0
			                    )} 点能量！`,
			                    "错误"
			                );
			                触发HUD显示();
			            }
			        }
			        return 攻击成功;
			    }
			
			    尝试吸附玩家() {
			        let 成功吸附 = false;
			        let 当前玩家X = 玩家.x;
			        let 当前玩家Y = 玩家.y;
			        let 新玩家X = 玩家.x;
			        let 新玩家Y = 玩家.y;
			
			        for (let i = 0; i < this.吸附距离; i++) {
			            const dx = this.x - 当前玩家X;
			            const dy = this.y - 当前玩家Y;
			            if (dx === 0 && dy === 0) break; // 已经到达怪物位置
			
			            let 移动X = 当前玩家X;
			            let 移动Y = 当前玩家Y;
			
			            if (Math.abs(dx) > Math.abs(dy)) {
			                移动X += Math.sign(dx);
			            } else if (Math.abs(dy) > Math.abs(dx)) {
			                移动Y += Math.sign(dy);
			            } else {
			                if (prng() < 0.5) {
			                    移动X += Math.sign(dx);
			                } else {
			                    移动Y += Math.sign(dy);
			                }
			            }
			
			            if (移动X === this.x && 移动Y === this.y) break; // 不吸入到怪物自身格
			
			            if (
			                检查移动可行性(当前玩家X, 当前玩家Y, 移动X, 移动Y)
			            ) {
			                const 目标单元格 = 地牢[移动Y]?.[移动X];
			                if (
			                    目标单元格 &&
			                    ![
			                        单元格类型.墙壁,
			                        单元格类型.上锁的门,
			                    ].includes(目标单元格.背景类型) &&
			                    !目标单元格.关联怪物
			                ) {
			                    新玩家X = 移动X;
			                    新玩家Y = 移动Y;
			                    当前玩家X = 移动X;
			                    当前玩家Y = 移动Y;
			                    成功吸附 = true;
			                } else {
			                    break; // 遇到障碍
			                }
			            } else {
			                break; // 路径不可行
			            }
			        }
			        return { 成功吸附, 新玩家X, 新玩家Y };
			    }
			}
			
			class 剧毒云雾怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.剧毒云雾怪物,
			            类型: "剧毒云雾怪物",
			            基础生命值: 25 + (配置.强化 ? 15 : 0),
			            基础攻击力: 5 + (配置.强化 ? 2 : 0),
			            移动率: 0.8,
			            掉落物: new 治疗药水({ 数量: 1 }),
			            掉落概率: 0.3,
			            基础攻击范围: 1,
			            ...配置,
			        });
			        this.毒云范围 = 配置.毒云范围??(1 + (配置.强化 ? 1 : 0));
			        this.毒云持续 = 配置.毒云持续??(3 + (配置.强化 ? 1 : 0));
			        this.毒云强度 = 配置.毒云强度??(2 + (配置.强化 ? 1 : 0));
			    }
			
			    受伤(伤害, 来源 = null) {
			        const 原始血量 = this.当前生命值;
			        super.受伤(伤害, 来源);
			
			        if (原始血量 > 0 && this.当前生命值 <= 0) {
			            this.释放毒云();
			        }
			    }
			    尝试移动(){
			        super.尝试移动()
			        return;
			    }
			
			    释放毒云() {
			        添加日志(`${this.类型} 死亡时释放了剧毒云雾！`, "警告");
			        const 范围 = this.毒云范围;
			        const 中心X = this.x;
			        const 中心Y = this.y;
			
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                const x = 中心X + dx;
			                const y = 中心Y + dy;
			
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小
			                ) {
			                    const 单元格 = 地牢[y][x];
			
			                    if (
			                        单元格.背景类型 !== 单元格类型.墙壁 &&
			                        单元格.背景类型 !== 单元格类型.上锁的门
			                    ) {
			                        if (玩家.x === x && 玩家.y === y) {
			                            new 状态效果(
			                                "中毒",
			                                "#008000",
			                                "☠️",
			                                this.毒云持续,
			                                null,
			                                null,
			                                null,
			                                this.毒云强度
			                            );
			                            添加日志("你吸入了剧毒云雾！", "错误");
			                        }
			
			                        if (
			                            单元格.关联怪物 &&
			                            单元格.关联怪物 !== this &&
			                            怪物状态表.get(单元格.关联怪物)
			                                ?.类型 !== "魅惑"
			                        ) {
			                            new 状态效果(
			                                "中毒",
			                                "#008000",
			                                "☠️",
			                                this.毒云持续,
			                                null,
			                                null,
			                                单元格.关联怪物,
			                                this.毒云强度
			                            );
			                            添加日志(
			                                `${单元格.关联怪物.类型} 吸入了剧毒云雾！`,
			                                "信息"
			                            );
			                        }
			
			                        Array.from(
			                            { length: 装备栏每页装备数 },
			                            (_, i) =>
			                                玩家装备.get(
			                                    当前装备页 * 装备栏每页装备数 +
			                                        i +
			                                        1
			                                )
			                        )
			                            .filter((v) => v != null)
			                            .forEach((装备) => {
			                                if (
			                                    装备 instanceof 宠物 &&
			                                    装备.x === x &&
			                                    装备.y === y &&
			                                    !装备.自定义数据.get("休眠中")
			                                ) {
			                                    装备.受伤(this.毒云强度);
			                                    添加日志(
			                                        `${装备.名称} 吸入了剧毒云雾！`,
			                                        "错误"
			                                    );
			                                }
			                            });
			
			                        计划显示格子特效(
			                            [{ x: x, y: y }],
			                            "90EE90",
			                            150
			                        );
			                    }
			                }
			            }
			        }
			    }
			}
			class 骷髅仆从 extends 怪物 {
    constructor(配置 = {}) {
        super({
            图标: 图标映射.骷髅仆从,
            类型: "骷髅仆从",
            基础生命值: 15 + (配置.强化 ? 10 : 0),
            基础攻击力: 3 + (配置.强化 ? 2 : 0),
            移动率: 1.0,
            掉落概率: 0,
            基础攻击范围: 1,
            跟踪距离: 50,
            ...配置,
        });
        this.主人 = 玩家;
        this.状态 = 怪物状态.活跃;
        this.生命周期 = 30 + (配置.强化 ? 20 : 0);
    }

    选择目标() {
        if (this.仇恨 && this.仇恨.当前生命值 > 0) {
            const 距离 = Math.abs(this.x - this.仇恨.x) + Math.abs(this.y - this.仇恨.y);
            if (距离 < this.跟踪距离 && 检查视线(this.x, this.y, this.仇恨.x, this.仇恨.y, this.跟踪距离)) {
                return this.仇恨;
            }
        }
        return this.寻找最近怪物目标();
    }

    寻找最近怪物目标() {
        let 最近距离 = Infinity;
        let 最近目标 = {x:玩家.x,y:玩家.y};

        所有怪物.forEach(怪物 => {
            if (怪物.状态 === 怪物状态.活跃 && 怪物.当前生命值 > 0 && !(怪物 instanceof 骷髅仆从) && !(怪物 instanceof 远射陷阱) && !(怪物 instanceof 巡逻怪物)) {
                const 距离 = Math.abs(this.x - 怪物.x) + Math.abs(this.y - 怪物.y);
                if (距离 < 最近距离 && 检查视线(this.x, this.y, 怪物.x, 怪物.y, this.跟踪距离)) {
                    最近距离 = 距离;
                    最近目标 = 怪物;
                }
            }
        });
        this.仇恨 = 最近目标;
        return 最近目标;
    }

    尝试移动() {
        if (this.生命周期 > 0) {
            this.生命周期--;
        } else {
            this.受伤(999, '消散');
            return;
        }

        const 目标 = this.选择目标();
        if (!目标) {
            const 距离主人 = Math.abs(this.x - this.主人.x) + Math.abs(this.y - this.主人.y);
            if (距离主人 > 2) {
                this.目标路径 = this.计算路径(this.主人.x, this.主人.y);
                if (this.目标路径 && this.目标路径.length > 0) {
                    super.尝试移动();
                }
            }
            return;
        }

        const 距离目标 = Math.abs(this.x - 目标.x) + Math.abs(this.y - 目标.y);

        if (距离目标) {
            this.目标路径 = this.计算路径(目标.x, 目标.y);
            if (this.目标路径 && this.目标路径.length > 0) {
                super.尝试移动();
            }
        }
    }
    
    尝试攻击() {
        const 目标 = this.仇恨;
        if (目标 && !深度比较(目标,this.主人)) {
             const 距离目标 = Math.abs(this.x - 目标.x) + Math.abs(this.y - 目标.y);
             if (距离目标 <= this.攻击范围) {
                 目标.受伤(this.攻击力, this);
                 计划显示格子特效(获取直线路径(this.x,this.y,目标.x,目标.y));
                 return true;
             }
        }
        return false;
    }
    
    受伤(伤害, 来源 = null) {
        if (来源 !== 玩家 && !(来源 instanceof 骷髅仆从)) {
            this.当前生命值 -= 伤害;
        }
        if (来源 instanceof 怪物) {
			            let dx = this.x - 来源.x;
			            let dy = this.y - 来源.y;
			            let 方向DX = 0, 方向DY = 0;

			            if (Math.abs(dx) > Math.abs(dy)) {
			                方向DX = Math.sign(dx) || (dy === 0 ? (prng() < 0.5 ? 1 : -1) : 0);
			            } else if (Math.abs(dy) > Math.abs(dx)) {
			                方向DY = Math.sign(dy) || (dx === 0 ? (prng() < 0.5 ? 1 : -1) : 0);
			            } else if (dx !== 0) {
			                方向DX = Math.sign(dx);
			            } else if (dy !== 0) {
			                方向DY = Math.sign(dy);
			            }

			            const 新X = this.x + 方向DX;
			            const 新Y = this.y + 方向DY;

			            if (位置是否可用(新X, 新Y, true, false) && 检查移动可行性(this.x, this.y, 新X, 新Y)) {
			                const 旧X = this.x;
			                const 旧Y = this.y;
			                this.x = 新X;
			                this.y = 新Y;
			                怪物动画状态.set(this, {
			                    旧逻辑X: 旧X, 旧逻辑Y: 旧Y,
			                    目标逻辑X: 新X, 目标逻辑Y: 新Y,
			                    视觉X: 旧X, 视觉Y: 旧Y,
			                    动画开始时间: Date.now(), 正在动画: true,
			                });
			                //添加日志(`${this.名称} 被击退了！`, "警告");
			            }
			        }
        
        if (this.当前生命值 <= 0) {
            this.恢复背景类型();
            所有怪物 = 所有怪物.filter(m => m !== this);
            玩家仆从列表 = 玩家仆从列表.filter(p => p !== this);
            计划显示格子特效([{ x: this.x, y: this.y }], "FFFFFF");
        }
    }

    绘制血条(隐藏 = false) {
    if (命令行模式开启) {
        const 动画状态 = 怪物动画状态.get(this);
        let 绘制逻辑X = this.x;
        let 绘制逻辑Y = this.y;
        if (动画状态?.正在动画) {
            绘制逻辑X = 动画状态.视觉X !== undefined ? 动画状态.视觉X : this.x;
            绘制逻辑Y = 动画状态.视觉Y !== undefined ? 动画状态.视觉Y : this.y;
        }
        const 屏幕X = (绘制逻辑X - 当前相机X) * 单元格大小;
        const 屏幕Y = (绘制逻辑Y - 当前相机Y) * 单元格大小;
        const 活跃且区域可见 = this.状态 === 怪物状态.活跃 && (房间地图[this.y][this.x] === -1 || 已访问房间.has(房间地图[this.y][this.x]));
        if (活跃且区域可见) {
            ctx.font = `${单元格大小 * 0.3}px 'Courier New', monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            const 血量百分比 = Math.max(0, (this.当前生命值 / this.生命值));
            const 总格数 = 7;
            const 实心格数 = Math.round(血量百分比 * 总格数);
            const 空心格数 = 总格数 - 实心格数;
            const 血条文本 = `[${'#'.repeat(实心格数)}${'.'.repeat(空心格数)}]`;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(血条文本, 屏幕X + 单元格大小 / 2, 屏幕Y);
        }
        return;
    }
        const 动画状态 = 怪物动画状态.get(this);
			        let 绘制逻辑X = this.x;
			        let 绘制逻辑Y = this.y;
			        const 正在动画 = 动画状态?.正在动画;
			
			        if (正在动画) {
			            绘制逻辑X =
			                动画状态.视觉X !== undefined
			                    ? 动画状态.视觉X
			                    : this.x;
			            绘制逻辑Y =
			                动画状态.视觉Y !== undefined
			                    ? 动画状态.视觉Y
			                    : this.y;
			        }
			
			        const 屏幕X = (绘制逻辑X - 当前相机X) * 单元格大小;
			        const 屏幕Y = (绘制逻辑Y - 当前相机Y) * 单元格大小;
        const 宽度 = 单元格大小;

        const 血条高度 = 4;
        const 血条Y = 屏幕Y -8;
        const 血条背景色 = "#444";
        const 血条前景色 = "#90ee90";

        ctx.save();
        ctx.fillStyle = 血条背景色;
        ctx.fillRect(屏幕X, 血条Y, 宽度, 血条高度);
        const 血量百分比 = Math.max(0, (this.当前生命值 / this.生命值) * 100);
        ctx.fillStyle = 血条前景色;
        ctx.fillRect(屏幕X, 血条Y, 宽度 * (血量百分比 / 100), 血条高度);
        ctx.restore();
    }
}



    
			class 召唤师怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.召唤师怪物,
			            类型: "召唤师怪物",
			            基础生命值: 30 + (配置.强化 ? 15 : 0),
			            基础攻击力: 3 + (配置.强化 ? 1 : 0),
			            移动率: 0.8,
			            掉落物: new 死灵法杖({ 强化: 配置.强化 }),
			            掉落概率: 0.3,
			            基础攻击范围: 4,
			            跟踪距离: 15,
			            ...配置,
			        });
			        this.召唤冷却 = 配置.召唤冷却??(3 + (配置.强化 ? -1 : 0));
			        this.召唤冷却剩余 = 配置.召唤冷却剩余??(Math.floor(
			            prng() * this.召唤冷却
			        ));
			        this.最大召唤物数量 = 配置.最大召唤物数量??(2 + (配置.强化 ? 1 : 0));
			        this.当前召唤物列表 = [];
			        this.召唤物类 = 幽灵仆从;
			    }
			
			    尝试移动() {
			        const 我的状态 = 怪物状态表.get(this);
			        if (我的状态?.类型 === "冻结") return;
			
			        if (this.当前生命值 <= 0) return;
			
			        this.当前召唤物列表 = this.当前召唤物列表.filter(
			            (仆从) => 仆从 && 仆从.当前生命值 > 0
			        );
			
			        if (this.受伤冻结回合剩余 > 0) {
			            this.受伤冻结回合剩余--;
			            this.绘制血条();
			            return;
			        }
			
			        if (this.召唤冷却剩余 > 0) {
			            this.召唤冷却剩余--;
			        }
			
			        if (我的状态?.类型 === "魅惑") {
			            const 目标 = this.寻找最近怪物目标();
			            if (目标) {
			                const 逃离点 = this.选择逃离目标(目标.x, 目标.y, 5);
			                if (逃离点) {
			                    this.目标路径 = this.计算路径(
			                        逃离点.x,
			                        逃离点.y
			                    );
			                    if (this.目标路径) super.尝试移动();
			                }
			            }
			            this.绘制血条();
			            return;
			        }
			
			        if (
			            this.召唤冷却剩余 <= 0 &&
			            this.当前召唤物列表.length < this.最大召唤物数量
			        ) {
			            if (this.尝试召唤()) {
			                this.召唤冷却剩余 = this.召唤冷却;
			            }
			        }
			
			        const 玩家距离 =
			            Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (玩家距离 <= this.基础攻击范围+5) {
			            const 逃离点 = this.选择逃离目标(玩家.x, 玩家.y, 15);
			            if (逃离点) {
			                this.目标路径 = this.计算路径(逃离点.x, 逃离点.y);
			                if (this.目标路径) super.尝试移动();
			            
			            } else {
			            }
			        } else {
			            const 旧X = this.x;
			            const 旧Y = this.y;
			            if (prng() < this.移动率) {
			                const 方向 = [
			                    [0, -1],
			                    [0, 1],
			                    [-1, 0],
			                    [1, 0],
			                ];
			                const [dx, dy] =
			                    方向[Math.floor(prng() * 4)];
			                const 新X = this.x + dx;
			                const 新Y = this.y + dy;
			                if (
			                    检查移动可行性(this.x, this.y, 新X, 新Y) &&
			                    位置是否可用(新X, 新Y, false)
			                ) {
			                    this.恢复背景类型();
			                    this.保存新位置类型(新X, 新Y);
			                    this.x = 新X;
			                    this.y = 新Y;
			                    地牢[新Y][新X].类型 = 单元格类型.怪物;
			                    地牢[新Y][新X].关联怪物 = this;
			                    怪物动画状态.set(this, {
			                        旧逻辑X: 旧X,
			                        旧逻辑Y: 旧Y,
			                        目标逻辑X: this.x,
			                        目标逻辑Y: this.y,
			                        视觉X: 旧X,
			                        视觉Y: 旧Y,
			                        动画开始时间: Date.now(),
			                        正在动画: true,
			                    });
			                }
			            }
			        }
			        this.绘制血条();
			    }
			
			    选择逃离目标(目标X, 目标Y, 范围 = 10) {
			        const 可达点 = [];
			        const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
			        const 已访问 = new Set([`${this.x},${this.y}`]);
			        const 怪物所在房间ID = 房间地图[this.y][this.x];
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			            const 距离目标 =
			                Math.abs(当前.x - 目标X) + Math.abs(当前.y - 目标Y);
			            const 距离自身 = 当前.距离;
			
			            if (
			                距离自身 <= 范围 &&
			                距离目标 >
			                    Math.abs(this.x - 目标X) +
			                        Math.abs(this.y - 目标Y)
			            ) {
			                const 点所在房间ID = 房间地图[当前.y][当前.x];
			                if (
			                    点所在房间ID === 怪物所在房间ID ||
			                    点所在房间ID === -1 ||
			                    (已访问房间.has(点所在房间ID) &&
			                        房间列表[点所在房间ID]?.类型?.slice(
			                            0,
			                            2
			                        ) !== "隐藏")
			                ) {
			                    if (this.位置合法(当前.x, 当前.y)) {
			                        可达点.push({
			                            x: 当前.x,
			                            y: 当前.y,
			                            距离目标: 距离目标,
			                        });
			                    }
			                }
			            }
			
			            if (当前.距离 >= 范围) continue;
			
			            const 方向 = [
			                { dx: 1, dy: 0 },
			                { dx: -1, dy: 0 },
			                { dx: 0, dy: 1 },
			                { dx: 0, dy: -1 },
			            ];
			            for (const { dx, dy } of 方向) {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			                const 位置键 = `${新X},${新Y}`;
			
			                if (
			                    新X >= 0 &&
			                    新X < 地牢大小 &&
			                    新Y >= 0 &&
			                    新Y < 地牢大小 &&
			                    !已访问.has(位置键)
			                ) {
			                    const 当前单元格 = 地牢[当前.y]?.[当前.x];
			                    const 目标单元格 = 地牢[新Y]?.[新X];
			                    const 移动方向 = getMoveDirection(当前.x, 当前.y, 新X, 新Y);
			                    if (目标单元格.isOneWay && 移动方向 !== 目标单元格.oneWayAllowedDirection) {
			                        continue;
			                    }
			                    if (
			                        当前单元格 &&
			                        目标单元格 &&
			                        ![
			                            单元格类型.墙壁,
			                            单元格类型.上锁的门,
			                        ].includes(目标单元格.背景类型) &&
			                        检查移动可行性(当前.x, 当前.y, 新X, 新Y) &&
			                        this.位置合法(新X, 新Y)
			                    ) {
			                        已访问.add(位置键);
			                        队列.push({
			                            x: 新X,
			                            y: 新Y,
			                            距离: 当前.距离 + 1,
			                        });
			                    }
			                }
			            }
			        }
			
			        if (可达点.length > 0) {
			            可达点.sort((a, b) => b.距离目标 - a.距离目标);
			            return 可达点[0];
			        }
			        return null;
			    }
			
			    尝试召唤() {
			        const 方向 = [
			            [-1, 0],
			            [1, 0],
			            [0, -1],
			            [0, 1],
			            [-1, -1],
			            [1, -1],
			            [-1, 1],
			            [1, 1],
			        ];
			        let 召唤成功数 = 0;
			        const 需要召唤数 =
			            1 + (this.强化 ? Math.floor(prng() * 2) : 0);
			
			        for (let i = 0; i < 需要召唤数; i++) {
			            let 放置成功 = false;
			            方向.sort(() => prng() - 0.5);
			            for (const [dx, dy] of 方向) {
			                const 召唤X = this.x + dx;
			                const 召唤Y = this.y + dy;
			                if (
			                    召唤X >= 0 &&
			                    召唤X < 地牢大小 &&
			                    召唤Y >= 0 &&
			                    召唤Y < 地牢大小 &&
			                    位置是否可用(召唤X, 召唤Y, false) &&
			                    检查直线移动可行性(
			                        this.x,
			                        this.y,
			                        召唤X,
			                        召唤Y,
			                        true
			                    )
			                ) {
			                    const 新召唤物 = new this.召唤物类({
			                        x: 召唤X,
			                        y: 召唤Y,
			                        房间ID: this.房间ID,
			                        状态: 怪物状态.活跃,
			                        召唤者: this,
			                        强化: this.强化,
			                    });
			                    放置怪物到单元格(新召唤物, 召唤X, 召唤Y);
			                    新召唤物.处理地形效果();
			                    this.当前召唤物列表.push(新召唤物);
			                    召唤成功数++;
			                    放置成功 = true;
			                    break;
			                }
			            }
			            if (!放置成功 && i === 0) return false;
			            if (!放置成功 && i > 0) break;
			        }
			
			        if (召唤成功数 > 0) {
			            添加日志(
			                `${this.类型} 召唤了 ${召唤成功数} 个 幽灵奴仆！`,
			                "信息"
			            );
			            计划显示格子特效(
			                this.当前召唤物列表
			                    .slice(-召唤成功数)
			                    .map((s) => ({ x: s.x, y: s.y })),
			                "8A2BE2",
			                0
			            );
			            return true;
			        }
			        return false;
			    }
			
			    尝试攻击() {
			        if (
			            this.召唤冷却剩余 <= 0 ||
			            this.当前召唤物列表.length < this.最大召唤物数量
			        ) {
			            return false;
			        }
			
			        if (怪物状态表.get(this)?.类型 === "魅惑") {
			            return super.尝试攻击();
			        } else {
			            return super.尝试攻击();
			        }
			    }
			
			    受伤(伤害, 来源 = null) {
			        const 原始血量 = this.当前生命值;
			        super.受伤(伤害, 来源);
			        if (原始血量 > 0 && this.当前生命值 <= 0) {
			            this.当前召唤物列表.forEach((仆从) => {
			                if (
			                    仆从 &&
			                    仆从.当前生命值 > 0 &&
			                    prng() < 0.7
			                ) {
			                    仆从.受伤(仆从.生命值 * 2, "召唤者死亡");
			                    添加日志(
			                        `${仆从.类型} 随着 ${this.类型} 的死亡而消散了。`,
			                        "信息"
			                    );
			                }
			            });
			            this.当前召唤物列表 = [];
			        }
			    }
			}
			
			class 幽灵仆从 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.幽灵仆从,
			            类型: "幽灵仆从",
			            基础生命值: 10 + (配置.强化 ? 3 : 0),
			            基础攻击力: 2 + (配置.强化 ? 1 : 0),
			            移动率: 1.0,
			            掉落物: null,
			            掉落概率: 0,
			            基础攻击范围: 1,
			            跟踪距离: 10,
			            ...配置,
			        });
			        this.生命周期 = 8 + (配置.强化 ? 4 : 0);
			        this.召唤者 = 配置.召唤者;
			    }
			
			    尝试移动() {
			        if (this.当前生命值 <= 0) return;
			
			        this.生命周期--;
			        if (this.生命周期 <= 0) {
			            this.受伤(this.生命值 * 2, "生命周期结束");
			            添加日志(`${this.类型} 消散了。`, "信息");
			            return;
			        }
			
			        if (
			            (!this.召唤者 || this.召唤者.当前生命值 <= 0) &&
			            prng() < 0.1
			        ) {
			            this.受伤(this.生命值 * 2, "召唤者死亡");
			            return;
			        }
			
			        this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			        super.尝试移动();
			        this.绘制血条();
			    }
			
			    选择目标() {
			        return { x: 玩家.x, y: 玩家.y };
			    }
			}
			
			class 萨满怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.萨满怪物,
			            类型: "萨满怪物",
			            基础生命值: 35 + (配置.强化 ? 10 : 0),
			            基础攻击力: 2 + (配置.强化 ? 1 : 0),
			            移动率: 0.9,
			            掉落物: new 治疗药水({
			                数量: Math.ceil(prng() * 3),
			            }),
			            掉落概率: 0.5,
			            基础攻击范围: 1,
			            跟踪距离: 12,
			            ...配置,
			        });
			        this.治疗范围 = 配置.治疗范围??(3 + (配置.强化 ? 2 : 0));
			        this.治疗量 = 配置.治疗量??(8 + (配置.强化 ? 4 : 0));
			        this.治疗冷却 = 配置.治疗冷却??(1 - (配置.强化 ? 1 : 0));
			        this.治疗冷却剩余 = 配置.治疗冷却剩余??(Math.floor(
			            prng() * (this.治疗冷却 + 1)
			        ));
			        this.优先治疗阈值 = 配置.优先治疗阈值??0.7;
			    }
			
			    尝试移动() {
			        const 我的状态 = 怪物状态表.get(this);
			        if (
			            我的状态?.类型 === "冻结" ||
			            我的状态?.类型 === "魅惑"
			        ) {
			            super.尝试移动();
			            this.绘制血条();
			            return;
			        }
			        if (this.当前生命值 <= 0) return;
			        if (this.受伤冻结回合剩余 > 0) {
			            this.受伤冻结回合剩余--;
			            this.绘制血条();
			            return;
			        }
			
			        if (this.治疗冷却剩余 > 0) {
			            this.治疗冷却剩余--;
			        }
			
			        const 待治疗友军 = this.寻找待治疗友军();
			
			        if (待治疗友军 && this.治疗冷却剩余 <= 0) {
			            const 距离 =
			                Math.abs(this.x - 待治疗友军.x) +
			                Math.abs(this.y - 待治疗友军.y);
			            if (距离 <= this.治疗范围) {
			                this.执行治疗(待治疗友军);
			            }
			            this.目标路径 = this.计算目标路径(
			                待治疗友军.x,
			                待治疗友军.y
			            );
			            if (this.目标路径) {
			                super.尝试移动();
			            }
			
			            this.绘制血条();
			            return;
			        }
			
			        this.目标路径 = this.计算路径(玩家.x, 玩家.y);
			        super.尝试移动();
			        this.绘制血条();
			    }
			
			    尝试攻击() {
			        if (
			            怪物状态表.get(this)?.类型 === "魅惑" ||
			            怪物状态表.get(this)?.类型 === "冻结"
			        )
			            return false;
			        if (this.治疗冷却剩余 > 0) {
			            return;
			        }
			
			        const 待治疗友军 = this.寻找待治疗友军();
			        if (待治疗友军 && this.治疗冷却剩余 <= 0) {
			            const 距离 =
			                Math.abs(this.x - 待治疗友军.x) +
			                Math.abs(this.y - 待治疗友军.y);
			            if (距离 <= this.治疗范围) {
			                return false;
			            }
			        }
			
			        return super.尝试攻击();
			    }
			
			    寻找待治疗友军() {
			        let 最优先目标 = null;
			        let 最低血量百分比 = this.优先治疗阈值;
			        const isCharmed = 怪物状态表.get(this)?.类型 === "魅惑";
			
			        let potentialAllies = [];
			        if (isCharmed) {
			            potentialAllies = 所有怪物.filter(m => 怪物状态表.get(m)?.类型 === "魅惑" && m !== this);
			            potentialAllies.push(...当前出战宠物列表.filter(p => p.是否已放置 && !p.自定义数据.get("休眠中")));
			        } else {
			            potentialAllies = 所有怪物;
			        }
			
			        potentialAllies.forEach((友军) => {
			            if (
			                友军 === this ||
			                (友军 instanceof 怪物 && (友军.当前生命值 <= 0 || 友军.当前生命值 >= 友军.生命值)) ||
							(友军 instanceof 宠物 && (友军.自定义数据.get("当前生命值") <= 0 || 友军.自定义数据.get("当前生命值") >= 友军.自定义数据.get("最大生命值")))
			            )
			                return;
						
						if (!isCharmed && 怪物状态表.get(友军)?.类型 === "魅惑") return;
			
			            const 距离 =
			                Math.abs(this.x - 友军.x) +
			                Math.abs(this.y - 友军.y);
			
			            if (距离 <= this.治疗范围 + 3) {
			                const 血量百分比 = (友军 instanceof 怪物) ? 友军.当前生命值 / 友军.生命值 : 友军.自定义数据.get("当前生命值") / 友军.自定义数据.get("最大生命值");
			                if (血量百分比 < 最低血量百分比) {
			                    最低血量百分比 = 血量百分比;
			                    最优先目标 = 友军;
			                }
			            }
			        });
			        return 最优先目标;
			    }
			
			    执行治疗(目标) {
			        const 治疗量 = this.治疗量;
			        目标.当前生命值 = Math.min(
			            目标.生命值,
			            目标.当前生命值 + 治疗量
			        );
			        this.治疗冷却剩余 = this.治疗冷却;
			        添加日志(
			            `${this.类型} 治疗了 ${目标.类型}，恢复了 ${治疗量} 点生命！`,
			            "信息"
			        );
			        目标.绘制血条();
			        目标.接受萨满治疗 = true;
			    }
			}
			
			class 大史莱姆怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.大史莱姆,
			            类型: "大史莱姆",
			            基础生命值: 40 + (配置.强化 ? 20 : 0),
			            基础攻击力: 5 + (配置.强化 ? 2 : 0),
			            移动率: 0.6, // 移动较慢
			            掉落物: new 金币({
			                数量: Math.floor(prng() * 8) + 3,
			            }),
			            掉落概率: 0.8,
			            攻击冷却: 1,
			            ...配置,
			        });
			        this.分裂数量 =配置.分裂数量??( 2 + (配置.强化 ? 1 : 0));
			    }
			
			    尝试攻击() {
			        if (super.尝试攻击()) {
			            // 攻击成功后施加缓慢效果
			            if (怪物状态表.get(this)?.类型 === "魅惑") {
			                if (this.魅惑目标怪物) {
			                    new 状态效果(
			                        "缓慢",
			                        "#888888",
			                        "慢",
			                        5,
			                        null,
			                        null,
			                        this.魅惑目标怪物
			                    );
			                }
			            } else if (this.目标?.x==玩家.x && this.目标?.y==玩家.y){
			                new 状态效果(
			                    "缓慢",
			                    "#888888",
			                    图标映射.缓慢,
			                    5,
			                    5
			                ); // 假设缓慢持续5回合
			            }
			            return true;
			        }
			        return false;
			    }
			
			    受伤(伤害, 来源 = null) {
			        const 原始血量 = this.当前生命值;
			        super.受伤(伤害, 来源);
			        // 如果死亡，则分裂
			        if (原始血量 > 0 && this.当前生命值 <= 0) {
			            this.分裂();
			        }
			    }
			
			    分裂() {
			        let 成功分裂数 = 0;
			        const 方向 = [
			            { dx: -1, dy: 0 },
			            { dx: 1, dy: 0 },
			            { dx: 0, dy: -1 },
			            { dx: 0, dy: 1 },
			            { dx: -1, dy: -1 },
			            { dx: 1, dy: -1 },
			            { dx: -1, dy: 1 },
			            { dx: 1, dy: 1 },
			        ];
			
			        for (let i = 0; i < this.分裂数量; i++) {
			            let 放置成功 = false;
			            for (const { dx, dy } of 方向) {
			                const 新X = this.x + dx;
			                const 新Y = this.y + dy;
			                if (位置是否可用(新X, 新Y) && 快速检查相邻移动(this.x, this.y, 新X, 新Y)) {
			                    let 史莱姆;
			                    if (prng() < 0.15 && this.强化) {
			                        史莱姆 = new 大史莱姆怪物({
			                            x: 新X,
			                            y: 新Y,
			                            房间ID: this.房间ID,
			                            状态: 怪物状态.活跃, // 出生即活跃
			                            强化: this.强化, // 继承强化状态
			                        });
			                        if (this.永久增益.some(b => b.类型 === '自爆')) 史莱姆.永久增益.push(新怪物.携带药水);
			                    } else {
			                        史莱姆 = new 小史莱姆怪物({
			                            x: 新X,
			                            y: 新Y,
			                            房间ID: this.房间ID,
			                            状态: 怪物状态.活跃, // 出生即活跃
			                            强化: this.强化, // 继承强化状态
			                        });
			                        if (this.永久增益.some(b => b.类型 === '自爆')) 史莱姆.永久增益.push(新怪物.携带药水);
			                    }
			                    放置怪物到单元格(史莱姆, 新X, 新Y);
			                    成功分裂数++;
			                    放置成功 = true;
			                    // 移除已用方向，避免重复放置
			                    方向.splice(
			                        方向.findIndex(
			                            (d) => d.dx === dx && d.dy === dy
			                        ),
			                        1
			                    );
			                    break;
			                }
			            }
			            // 如果所有方向都试过还失败，就不再尝试分裂更多
			            if (!放置成功) break;
			        }
			        if (成功分裂数 > 0) {
			            添加日志(
			                `${this.类型} 分裂成了 ${成功分裂数} 个小史莱姆！`,
			                "警告"
			            );
			        }
			    }
			}
			
			class 小史莱姆怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.小史莱姆,
			            类型: "小史莱姆",
			            基础生命值: 15 + (配置.强化 ? 10 : 0),
			            基础攻击力: 3 + (配置.强化 ? 1 : 0),
			            移动率: 1, // 移动较快
			            掉落物: new 金币({
			                数量: Math.floor(prng() * 3) + 1,
			            }),
			            掉落概率: 0.5,
			            攻击冷却: 0, // 攻击更快
			            基础攻击范围: 1,
			            基础移动距离: 2, // 可以移动两格
			            ...配置,
			        });
			    }
			
			    尝试攻击() {
			        if (super.尝试攻击()) {
			            if (怪物状态表.get(this)?.类型 === "魅惑") {
			                if (this.魅惑目标怪物) {
			                    new 状态效果(
			                        "缓慢",
			                        "#888888",
			                        图标映射.缓慢,
			                        3,
			                        null,
			                        null,
			                        this.魅惑目标怪物
			                    );
			                }
			            } else {
			                new 状态效果(
			                    "缓慢",
			                    "#888888",
			                    图标映射.缓慢,
			                    3,
			                    3
			                ); // 缓慢持续3回合
			            }
			            return true;
			        }
			        return false;
			    }
			}
			
			class 瞬移怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.瞬移怪物,
			            类型: "瞬移怪物",
			            基础生命值: 25 + (配置.强化 ? 15 : 0),
			            基础攻击力: 2 + (配置.强化 ? 3 : 0),
			            移动率: 0.85,
			            掉落物: new 跃迁卷轴({
			                数量: 1,
			                强化: 配置.强化 ?? false,
			            }),
			            掉落概率: 0.4,
			            基础攻击范围: 2,
			            受伤冻结回合: 0, // 受伤不冻结，可能直接瞬移走
			            ...配置,
			        });
			        this.瞬移几率 = 配置.瞬移几率??(0.6 + (配置.强化 ? 0.2 : 0));
			        this.受击瞬移几率 = 配置.受击瞬移几率??(0.4 + (配置.强化 ? 0.2 : 0));
			    }
			
			    尝试移动() {
			        const 我的状态 = 怪物状态表.get(this);
			        if (我的状态?.类型 === "冻结") return;
			
			        if (this.当前生命值 <= 0) return;
			        if (房间地图[玩家.y][玩家.x] === 0) return; // 教程层不动
			
			        // 魅惑状态下的移动
			        if (我的状态?.类型 === "魅惑") {
			            const 目标 = this.寻找最近怪物目标();
			            if (目标 && prng() < this.瞬移几率) {
			                this.瞬移到(目标.x, 目标.y, 5); // 尝试瞬移到目标怪物附近
			            } else if (目标) {
			                // 不瞬移则正常寻路移动
			                this.目标路径 = this.计算路径(目标.x, 目标.y);
			                super.尝试移动(); // 调用基类移动
			            }
			            this.绘制血条();
			            return; // 处理完魅惑移动后返回
			        }
			
			        // 正常状态下的移动
			        const 玩家距离 =
			            Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (
			            玩家距离 <= this.跟踪距离 &&
			            prng() < this.瞬移几率
			        ) {
			            this.瞬移到(玩家.x, 玩家.y, 3); // 尝试瞬移到玩家附近
			        } else {
			            // 不瞬移则正常寻路移动
			            if (this.目标路径.length > 0 && this.追击玩家中) {
			                super.尝试移动(); // 调用基类移动
			            }
			        }
			        this.绘制血条();
			    }
			
			    尝试攻击() {
			        if (怪物状态表.get(this)?.类型 === "冻结") return false;
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余 -= 1;
			            return false;
			        }
			
			        if (怪物状态表.get(this)?.类型 === "魅惑") {
			            const { x: 目标X, y: 目标Y } = this.寻找最近怪物目标();
			            this.通向目标路径 = this.计算目标路径(目标X, 目标Y);
			            if (this.通向目标路径 === null) return false;
			            if (this.通向目标路径.length <= this.攻击范围) {
			                if (this.魅惑目标怪物) {
			                    this.魅惑目标怪物.受伤(this.攻击力, this);
			                    this.攻击冷却回合剩余 = this.攻击冷却;
			                    计划显示格子特效(this.通向目标路径);
			                    return true;
			                }
			            }
			        } else {
			            this.通向目标路径 = this.计算目标路径(玩家.x, 玩家.y);
			            if (this.通向目标路径 === null) return false;
			            if (this.通向目标路径.length <= this.攻击范围) {
			                伤害玩家(this.攻击力, this);
			                this.攻击冷却回合剩余 = this.攻击冷却;
			                计划显示格子特效(this.通向目标路径);
			                return true;
			            }
			        }
			        return false;
			    }
			
			    瞬移到(目标X, 目标Y, 范围) {
			        const 候选位置 = [];
			        const 搜索范围 = 范围 + 2; // 稍微扩大搜索范围以找到更多候选点
			
			        // 1. 查找目标点周围的可用格子
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                if (dx === 0 && dy === 0) continue;
			                const 新X = 目标X + dx;
			                const 新Y = 目标Y + dy;
			                if (
			                    新X >= 0 &&
			                    新X < 地牢大小 &&
			                    新Y >= 0 &&
			                    新Y < 地牢大小 &&
			                    位置是否可用(新X, 新Y, false)
			                ) {
			                    候选位置.push({ x: 新X, y: 新Y });
			                }
			            }
			        }
			
			        // 2. 筛选出 BFS 可达的格子
			        const 可达位置 = 候选位置.filter((pos) =>
			            检查直线移动可行性(this.x, this.y, pos.x, pos.y, true)
			        );
			
			        if (可达位置.length > 0) {
			            const 目标位置 =
			                可达位置[
			                    Math.floor(prng() * 可达位置.length)
			                ];
			            // 保存旧位置用于恢复单元格类型
			            const 旧X = this.x;
			            const 旧Y = this.y;
			
			            this.恢复背景类型(); // 恢复旧位置单元格
			            this.保存新位置类型(目标位置.x, 目标位置.y); // 保存新位置背景类型
			            this.x = 目标位置.x;
			            this.y = 目标位置.y;
			            地牢[this.y][this.x].类型 = 单元格类型.怪物;
			            地牢[this.y][this.x].关联怪物 = this;
			            this.处理地形效果();
			            怪物动画状态.set(this, {
			                旧逻辑X: 旧X,
			                旧逻辑Y: 旧Y,
			                目标逻辑X: this.x,
			                目标逻辑Y: this.y,
			                视觉X: 旧X,
			                视觉Y: 旧Y,
			                动画开始时间: Date.now(),
			                正在动画: true,
			            });
			            添加日志(`${this.类型} 瞬移了！`, "信息");
			        }
			    }
			    瞬移逃跑() {
			        const 范围 = 8; // 逃跑瞬移范围更大
			        const 候选位置 = [];
			        // 1. 查找自身周围的可用格子作为逃跑候选
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                if (dx === 0 && dy === 0) continue;
			                const 新X = this.x + dx;
			                const 新Y = this.y + dy;
			                if (
			                    新X >= 0 &&
			                    新X < 地牢大小 &&
			                    新Y >= 0 &&
			                    新Y < 地牢大小 &&
			                    位置是否可用(新X, 新Y, false)
			                ) {
			                    const 距离玩家 =
			                        Math.abs(新X - 玩家.x) +
			                        Math.abs(新Y - 玩家.y);
			                    const 距离自身 = Math.abs(dx) + Math.abs(dy);
			                    // 优先选择远离玩家的位置
			                    if (
			                        距离玩家 >
			                        Math.abs(this.x - 玩家.x) +
			                            Math.abs(this.y - 玩家.y)
			                    ) {
			                        候选位置.push({
			                            x: 新X,
			                            y: 新Y,
			                            距离玩家: 距离玩家,
			                            距离自身: 距离自身,
			                        });
			                    }
			                }
			            }
			        }
			
			        // 2. 筛选出 BFS 可达的逃跑位置
			        const 可达逃跑位置 = 候选位置.filter(
			            (pos) =>
			                检查直线移动可行性(
			                    this.x,
			                    this.y,
			                    pos.x,
			                    pos.y,
			                    true
			                ) // 允许较长路径
			        );
			
			        if (可达逃跑位置.length > 0) {
			            // 3. 从可达位置中选择最优（最远）
			            可达逃跑位置.sort((a, b) => b.距离玩家 - a.距离玩家); // 按距离玩家远近排序
			            const 目标位置 = 可达逃跑位置[0]; // 选择最远的
			
			            // 保存旧位置
			            const 旧X = this.x;
			            const 旧Y = this.y;
			
			            this.恢复背景类型(); // 恢复旧位置
			            this.保存新位置类型(目标位置.x, 目标位置.y); // 保存新位置
			            this.x = 目标位置.x;
			            this.y = 目标位置.y;
			            地牢[this.y][this.x].类型 = 单元格类型.怪物;
			            地牢[this.y][this.x].关联怪物 = this;
			            添加日志(`${this.类型} 瞬移逃跑了！`, "信息");
			            this.处理地形效果();
			            怪物动画状态.set(this, {
			                旧逻辑X: 旧X,
			                旧逻辑Y: 旧Y,
			                目标逻辑X: this.x,
			                目标逻辑Y: this.y,
			                视觉X: 旧X,
			                视觉Y: 旧Y,
			                动画开始时间: Date.now(),
			                正在动画: true,
			            });
			        }
			        // 如果没有可达的逃跑位置，则不瞬移
			    }
			
			    受伤(伤害, 来源 = null) {
			        const 原始血量 = this.当前生命值;
			        if (来源 instanceof 狙击金币枪) {
			             super.受伤(伤害, 来源);
			             return;
			        }
			
			        // 有几率瞬移逃跑
			        if (
			            原始血量 > 0 &&
			            this.当前生命值 > 0 &&
			            prng() < this.受击瞬移几率
			        ) {
			            this.瞬移逃跑();
			            return;
			        }
			        super.受伤(伤害, 来源);
			    }
			}
			
			class 伪装怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        const 伪装物品列表 = [
			            { 图标: 图标映射.药水, 名称: "药水" },
			            { 图标: 图标映射.卷轴, 名称: "卷轴" },
			            { 图标: 图标映射.金币, 名称: "金币" },
			        ];
			        let 伪装 =
			            伪装物品列表[
			                Math.floor(prng() * 伪装物品列表.length)
			            ];
			
			        if (配置.伪装成) {
			            伪装 = {
			                图标: 图标映射[配置.伪装成],
			                名称: 配置.伪装成,
			            };
			        }
			
			        super({
			            类型: "伪装怪物",
			            图标: 图标映射.伪装怪物,
			            基础生命值: 30 + (配置.强化 ? 10 : 0),
			            基础攻击力: 7 + (配置.强化 ? 3 : 0),
			            移动率: 0, // 初始不动
			            掉落物: new 隐身药水({}),
			            掉落概率: 0.9,
			            基础攻击范围: 1,
			            ...配置,
			        });
			        this.伪装状态 = true;
			        this.图标 = 配置.图标??伪装.图标;
			        this.触发距离 = 配置.触发距离??1;
			        this.偷袭伤害 = 配置.偷袭伤害??(12 + (配置.强化 ? 8 : 0));
			    }
			    尝试移动() {
			        if (this.当前生命值 <= 0) return;
			
			        if (this.伪装状态) {
			            const 玩家距离 =
			                Math.abs(this.x - 玩家.x) +
			                Math.abs(this.y - 玩家.y);
			            if (玩家距离 <= this.触发距离) {
			                this.解除伪装();
			            } else {
			                return;
			            }
			        }
			
			        if (!this.伪装状态) {
			            super.尝试移动();
			        }
			        this.绘制血条();
			    }
			
			    解除伪装() {
			        if (!this.伪装状态) return;
			        显示通知(`一个${this.类型}显现了！`, "警告");
			        添加日志(
			            `伪装的 ${this.图标} 原来是 ${this.类型}！`,
			            "警告"
			        );
			        this.伪装状态 = false;
			        this.图标 = 图标映射.伪装怪物;
			        this.移动率 = 0.7;
			        this.状态 = 怪物状态.活跃;
			
			        const 玩家距离 =
			            Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (玩家距离 <= 2) {
			        伤害玩家(this.偷袭伤害, this);
			        显示通知(`它对你发动了突然袭击！`, "错误");
			        }
			
			        this.绘制血条();
			        绘制();
			    }
			
			    绘制血条(隐藏血条 = false) {
			        if (!this.伪装状态) {
			            super.绘制血条(隐藏血条);
			        } else if (this.血条元素) {
			            this.血条元素.style.display = "none";
			        }
			    }
			
			    尝试攻击() {
			        if (!this.伪装状态) {
			            return super.尝试攻击();
			        }
			        return false;
			    }
			
			    受伤(伤害, 来源 = null) {
			        if (this.伪装状态) {
			            this.解除伪装();
			        }
			        super.受伤(伤害, 来源);
			    }
			}
			
			class 炸弹怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            基础移动距离: 配置.基础移动距离 ?? 2,
			            图标: 图标映射.炸弹怪物,
			            类型: "炸弹怪物",
			            掉落物: new 炸弹({
			                数量: Math.floor(prng() * 5) + 1,
			                强化: 配置.强化 || false,
			            }),
			            房间ID: 配置.房间ID || null,
			            强化: 配置.强化 || false,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.休眠,
			            生命值: 配置.基础生命值 || 45,
			            基础攻击力: 配置.基础攻击力 || 3,
			        });
			        this.携带炸弹 = 配置.携带炸弹??true;
			    }
			
			    尝试移动() {
			        if (!this.携带炸弹) {
			            super.尝试移动();
			            return;
			        }
			
			        this.目标路径 = this.计算路径(this.目标.x, this.目标.y);
			        const 玩家距离 = this.目标路径 ? this.目标路径.length - 1 : Infinity;
			
			        if (玩家距离 <= this.攻击范围) {
			            this.放置炸弹();
			            return;
			        }
			        
			
			        if (this.目标路径 === null) {
			            this.尝试摧毁障碍物()
			                return;
			            
			        }
			        const 下一步 =
			                this.目标路径[
			                    Math.min(
			                        this.移动距离 - 1,
			                        this.目标路径.length - 1
			                    )
			                ];
			            let 最终位置 = null;
			            if (下一步) {
			                const dx = 下一步.x - this.x;
			                const dy = 下一步.y - this.y;
			                最终位置 = this.规划移动路径(dx, dy);
			            }
			        if(!最终位置 || (最终位置.x === this.x && 最终位置.y === this.y)) {
			        this.尝试摧毁障碍物()
			                return;
			            
			        }
			
			        return super.尝试移动();
			    }
			
			    尝试摧毁障碍物() {
			        const 障碍物列表 = [];
			        const 搜索范围 = 8;
			        for (let dy = -搜索范围; dy <= 搜索范围; dy++) {
			            for (let dx = -搜索范围; dx <= 搜索范围; dx++) {
			                const x = this.x + dx;
			                const y = this.y + dy;
			                if(x<0 || x>=地牢大小 || y<0 || y>=地牢大小) continue;
			                const 单元格 = 地牢[y][x];
			                if (单元格 && 单元格.关联物品 instanceof 已放置的障碍物) {
			                    障碍物列表.push(单元格.关联物品);
			                }
			            }
			        }
			        if(障碍物列表.length === 0) return false;
			
			        let 最近障碍物 = null;
			        let 最短路径 = null;
			        let 最小距离 = Infinity;
			        障碍物列表.forEach(障碍物 => {
			            const 路径 = this.计算路径(障碍物.x, 障碍物.y);
			            if (路径 && 路径.length < 最小距离) {
			                最小距离 = 路径.length;
			                最近障碍物 = 障碍物;
			                最短路径 = 路径;
			            }
			        });
			
			        if (最近障碍物) {
			            if (最小距离 <= 2) {
			                this.放置炸弹(最近障碍物.x, 最近障碍物.y);
			                return true;
			            } else {
			                this.目标路径 = 最短路径;
			                super.尝试移动();
			                return true;
			            }
			        }
			        return false;
			    }
			
			    放置炸弹(目标X, 目标Y) {
			         if (当前天气效果.includes("严寒")) {
			            return;
			        }
			
			        const 扔出炸弹 = new 炸弹({ 能否拾起: false, 来源: '怪物', 颜色索引: 4 });
			        let 放置X = 目标X, 放置Y = 目标Y;
			
			        if (目标X === undefined || 目标Y === undefined) {
			            const 玩家放置结果 = 玩家放置物品(扔出炸弹);
			            if(玩家放置结果.x === null) return;
			            放置X = 玩家放置结果.x;
			            放置Y = 玩家放置结果.y;
			        } else {
			             const 方向 = [[0, -1], [0, 1], [-1, 0], [1, 0]];
			             let 最佳位置 = null;
			             for(const [dx, dy] of 方向) {
			                 const x = 目标X + dx;
			                 const y = 目标Y + dy;
			                 if(位置是否可用(x, y, false)){
			                    最佳位置 = {x, y};
			                    break;
			                 }
			             }
			             if(!最佳位置) return;
			             放置X = 最佳位置.x;
			             放置Y = 最佳位置.y;
			             放置物品到单元格(扔出炸弹,放置X,放置Y);
			        }
			
			        if (放置X !== null && 放置Y !== null) {
			            扔出炸弹.使用(false, 放置X, 放置Y);
			            setTimeout(()=>this.基础移动距离 = 1,1000);
			            if (当前层数 !== 10) {
			                this.携带炸弹 = false;
			                this.图标 = 图标映射.怪物;
			            }
			        }
			    }
			}
			class 旋风怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.旋风怪物,
			            类型: "旋风怪物",
			            基础生命值: 38 + (配置.强化 ? 18 : 0),
			            基础攻击力: 3 + (配置.强化 ? 1 : 0), // 直接攻击力不高
			            移动率: 0.75,
			            掉落物: new 追踪风弹({
			                数量: Math.floor(prng() * 10) + 5,
			                强化: 配置.强化,
			            }),
			            掉落概率: 0.6,
			            基础攻击范围: 1, // 主要靠旋风
			            跟踪距离: 15,
			            ...配置,
			        });
			        this.召唤冷却 = 配置.召唤冷却??(4 + (配置.强化 ? -1 : 0)); // 召唤间隔
			        this.召唤冷却剩余 = 配置.召唤冷却剩余??(Math.floor(
			            prng() * (this.召唤冷却 + 1)
			        ));
			        this.最大召唤物数量 = 配置.最大召唤物数量??(1 + (配置.强化 ? 1 : 0)); // 同时存在的旋风数量
			        this.当前召唤物列表 = [];
			        this.召唤物类 = 旋风; // 召唤旋风怪物
			    }
			
			    尝试移动() {
			        const 我的状态 = 怪物状态表.get(this);
			        if (我的状态?.类型 === "冻结") return;
			
			        if (this.当前生命值 <= 0) return;
			
			        // 清理已消失的召唤物
			        this.当前召唤物列表 = this.当前召唤物列表.filter(
			            (旋) => 旋 && 旋.当前生命值 > 0
			        );
			
			        if (this.受伤冻结回合剩余 > 0) {
			            this.受伤冻结回合剩余--;
			            this.绘制血条();
			            return;
			        }
			
			        // 冷却处理
			        if (this.召唤冷却剩余 > 0) {
			            this.召唤冷却剩余--;
			        }
			
			        // 尝试召唤
			        if (
			            this.召唤冷却剩余 <= 0 &&
			            this.当前召唤物列表.length < this.最大召唤物数量
			        ) {
			            if (this.尝试召唤()) {
			                this.召唤冷却剩余 = this.召唤冷却;
			                this.绘制血条();
			                return; // 召唤成功后本回合可能不再移动或攻击
			            }
			        }
			
			        super.尝试移动();
			        this.绘制血条();
			    }
			
			    尝试召唤() {
			        const 方向 = [
			            [-1, 0],
			            [1, 0],
			            [0, -1],
			            [0, 1],
			            [-1, -1],
			            [1, -1],
			            [-1, 1],
			            [1, 1],
			        ];
			        let 召唤成功数 = 0;
			        const 需要召唤数 = 1; // 一次只召唤一个
			
			        for (let i = 0; i < 需要召唤数; i++) {
			            let 放置成功 = false;
			            方向.sort(() => prng() - 0.5); // 随机方向
			            for (const [dx, dy] of 方向) {
			                const 召唤X = this.x + dx;
			                const 召唤Y = this.y + dy;
			                if (
			                    召唤X >= 0 &&
			                    召唤X < 地牢大小 &&
			                    召唤Y >= 0 &&
			                    召唤Y < 地牢大小 &&
			                    位置是否可用(召唤X, 召唤Y, false)
			                ) {
			                    const 新召唤物 = new this.召唤物类({
			                        x: 召唤X,
			                        y: 召唤Y,
			                        房间ID: this.房间ID,
			                        状态: 怪物状态.活跃,
			                        强化: this.强化,
			                    });
			                    放置怪物到单元格(新召唤物, 召唤X, 召唤Y);
			                    this.当前召唤物列表.push(新召唤物);
			                    召唤成功数++;
			                    放置成功 = true;
			                    break;
			                }
			            }
			            if (!放置成功) return false; // 无法放置则召唤失败
			        }
			
			        if (召唤成功数 > 0) {
			            添加日志(`${this.类型} 释放了一个旋风！`, "信息");
			            计划显示格子特效(
			                this.当前召唤物列表
			                    .slice(-召唤成功数)
			                    .map((s) => ({ x: s.x, y: s.y })),
			                "ADD8E6",
			                0
			            ); // 淡蓝色特效
			            return true;
			        }
			        return false;
			    }
			
			    // 可以保留基础攻击，或者让它完全依赖旋风
			    尝试攻击() {
			        super.尝试攻击();
			        return true; // 目前主要靠旋风
			    }
			
			    受伤(伤害, 来源 = null) {
			        const 原始血量 = this.当前生命值;
			        super.受伤(伤害, 来源);
			        // 死亡时驱散场上所有由它召唤的旋风（可选）
			        if (原始血量 > 0 && this.当前生命值 <= 0) {
			            this.当前召唤物列表.forEach((旋) => {
			                if (旋 && 旋.当前生命值 > 0) {
			                    旋.受伤(旋.生命值 * 2, "召唤者死亡"); // 强制移除
			                }
			            });
			            this.当前召唤物列表 = [];
			        }
			    }
			}
			class 旋风 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.旋风,
			            类型: "旋风",
			            基础生命值: 5 + (配置.强化 ? 5 : 0), // 很脆弱
			            基础攻击力: 0, // 不直接攻击
			            移动率: 1.0, // 移动较快
			            掉落概率: 0,
			            基础攻击范围: 0, // 接触触发
			            跟踪距离: 30, // 追踪范围大
			            受伤冻结回合: 0, // 不受冻结影响移动
			            基础移动距离: 2, // 移动快
			            ...配置,
			        });
			        this.生命周期 = 10 + (配置.强化 ? 5 : 0); // 存在时间
			    }
			
			    尝试移动() {
			        if (this.当前生命值 <= 0) return;
			
			        // 生命周期处理
			        this.生命周期--;
			        if (this.生命周期 <= 0) {
			            this.受伤(this.生命值 * 2, "生命周期结束"); // 时间到了消失
			            添加日志(`${this.类型} 消散了。`, "信息");
			            this.移除自身();
			            return;
			        }
			        let { x, y } = this.选择目标();
			        // 碰撞检测与效果触发
			        if (this.x === x && this.y === y) {
			            this.触发效果();
			        }
			        this.目标路径 = this.计算目标路径(x, y);
			        if (this.当前生命值 <= 0) return;
			        if (房间地图[玩家.y][玩家.x] === 0) return;
			        if (
			            this.目标路径.length === 0 ||
			            (prng() > this.移动率 && !切换动画) ||
			            this.跟踪距离 < this.目标路径.length
			        ) {
			            this.追击玩家中 = false;
			            return;
			        }
			
			        const 旧X = this.x;
			        const 旧Y = this.y;
			        const 下一步 =
			            this.目标路径[
			                Math.min(
			                    this.移动距离 - 1,
			                    this.目标路径.length - 1
			                )
			            ];
			        if (下一步) {
			            const dx = 下一步.x - this.x;
			            const dy = 下一步.y - this.y;
			
			            // 规划实际可移动位置
			            const 最终位置 = this.规划移动路径(dx, dy);
			            if (!最终位置) return;
			            this.恢复背景类型();
			            this.保存新位置类型(最终位置.x, 最终位置.y);
			            this.x = 最终位置.x;
			            this.y = 最终位置.y;
			            地牢[this.y][this.x].类型 = 单元格类型.怪物;
			            地牢[this.y][this.x].关联怪物 = this;
			            怪物动画状态.set(this, {
			                旧逻辑X: 旧X,
			                旧逻辑Y: 旧Y,
			                目标逻辑X: this.x,
			                目标逻辑Y: this.y,
			                视觉X: 旧X,
			                视觉Y: 旧Y,
			                动画开始时间: Date.now(),
			                正在动画: true,
			            });
			        }
			        if (this.x === x && this.y === y) {
			            this.触发效果();
			            return;
			        }
			        this.绘制血条(true); // 强制不显示血条
			    }
			
			    绘制血条(隐藏血条 = true) {
			        // 旋风不显示血条
			        if (this.血条元素) {
			            this.血条元素.style.display = "none";
			        }
			    }
			
			    尝试攻击() {
			        let { x, y } = this.选择目标();
			        if (this.x === x && this.y === y) {
			            this.触发效果();
			        }
			        return false;
			    }
			    获得效果(状态效果) {
			        状态效果.移除状态();
			        return false;
			    }
			    触发效果() {
			        添加日志(`${this.类型} 撞到了你，释放了气流！`, "警告");
			        this.受伤(this.生命值 * 2, "效果触发");
			        this.移除自身();
			        const 中心X = this.x;
			        const 中心Y = this.y;
			
			        // 在3x3区域生成旋风物品
			        for (let dx = -1; dx <= 1; dx++) {
			            for (let dy = -1; dy <= 1; dy++) {
			                // if (dx === 0 && dy === 0) continue; // 不在中心生成
			                const x = 中心X + dx;
			                const y = 中心Y + dy;
			
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小
			                ) {
			                    // 检查目标格子是否可放置（非墙、非上锁门）
			                    const 单元格 = 地牢[y][x];
			                    if (
			                        单元格 &&
			                        ![
			                            单元格类型.墙壁,
			                            单元格类型.上锁的门,
			                        ].includes(单元格.背景类型) &&
			                        !单元格.关联物品
			                    ) {
			                        const 旋风物品实例 = new 旋风物品({});
			                        // 使用放置物品到单元格，并将其添加到所有计时器列表
			                        if (放置物品到单元格(旋风物品实例, x, y)) {
			                            旋风物品实例.x = x;
			                            旋风物品实例.y = y;
			                            所有计时器.push(旋风物品实例); // 添加到计时器列表
			                            计划显示格子特效(
			                                [{ x: x, y: y }],
			                                "90EE90"
			                            ); // 显示生成特效
			                        }
			                    }
			                }
			            }
			        }
			        new 状态效果(
			            "眩晕",
			            效果颜色编号映射[效果名称编号映射.眩晕],
			            图标映射.眩晕,
			            2
			        );
			    }
			
			    移除自身() {
			        this.恢复背景类型();
			        if (this.血条元素) this.血条元素.remove();
			        所有怪物 = 所有怪物.filter((m) => m !== this);
			        绘制(); // 更新画面
			    }
			}
			class 盔甲怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.盔甲怪物,
			            类型: "盔甲怪物",
			            强化: 配置.强化 || false,
			            掉落物: new 钢制板甲({
			                数量: 1,
			            }),
			            掉落概率: 0.5,
			            房间ID: 配置.房间ID || null,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.休眠,
			            基础生命值: 配置.基础生命值 || 35,
			        });
			        if (this.掉落物) {
			            this.尝试添加随机词条到掉落物(this.掉落物);
			        }
			    }
			}
			class 敏捷怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            基础移动距离: 3,
			            跟踪距离: 40,
			            图标: 图标映射.敏捷怪物,
			            类型: "敏捷怪物",
			            强化: 配置.强化 || false,
			            掉落物: new 迅捷卷轴({
			                数量: 1,
			            }),
			            掉落概率: 0.3,
			            房间ID: 配置.房间ID || null,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.休眠,
			            基础生命值: 配置.基础生命值 || 28,
			            基础攻击力: 配置.基础攻击力 || 4,
			            移动率: 配置.移动率 || 0.85,
			        });
			    }
			}
			class 远攻怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.远攻怪物,
			            类型: "远攻怪物",
			            掉落物: new 橡木法杖({
			                数量: 1,
			            }),
			            掉落概率: 0.3,
			            房间ID: 配置.房间ID || null,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.休眠,
			            强化: 配置.强化 || false,
			            基础生命值: 配置.基础生命值 || 35,
			            基础攻击力: 配置.基础攻击力 || 3,
			            移动率: 配置.移动率 || 0.7,
			            基础攻击范围: 3,
			            跟踪距离: 25,
			        });
			        if (this.掉落物) {
			            this.尝试添加随机词条到掉落物(this.掉落物);
			        }
			    }
			}
			class 仙人掌怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        const 随机品质 =
			            1 + Math.floor(prng() * prng() * 4);
			        const 荆棘卷轴实例 = new 附魔卷轴({
			            品质: 随机品质, // 使用随机品质
			            已解锁: true, // 默认掉落已鉴定
			            强化: 配置.强化 || false, // 可选：继承强化状态
			        });
			
			        // 手动设置附魔效果为荆棘
			        const 效果名 = "荆棘附魔";
			        const 效果索引 = 荆棘卷轴实例.效果名.indexOf(效果名);
			
			        if (效果索引 !== -1) {
			            荆棘卷轴实例.附魔效果 = 荆棘卷轴实例.附魔池[效果索引]; // 设置效果函数
			            荆棘卷轴实例.效果描述 = `为防御装备附加${效果名} ${"I".repeat(
			                随机品质
			            )}级`; // 更新描述
			            荆棘卷轴实例.名称 = `${效果名}卷轴`; // 可以考虑更新名称
			            荆棘卷轴实例.颜色索引 = 随机品质 - 1; // 根据品质更新颜色
			        }
			        super({
			            图标: 图标映射.仙人掌怪物,
			            类型: "仙人掌怪物",
			            掉落物: 荆棘卷轴实例,
			            掉落概率: 0.3 + (配置.强化 ? 0.15 : 0),
			            房间ID: 配置.房间ID || null,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.休眠,
			            强化: 配置.强化 || false,
			            生命值: 配置.基础生命值 || 30,
			            基础攻击力: 配置.基础攻击力 || 3,
			            移动率: 配置.移动率 || 0.7,
			        });
			    }
			    受伤(伤害, 来源 = null) {
			        if (来源 === "玩家") {
			            伤害玩家(this.攻击力, this);
			        }
			        super.受伤(伤害, 来源);
			    }
			}
			class 冰冻怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.冰冻怪物,
			            类型: "冰冻怪物",
			            掉落物: new 冰盾({
			                数量: 1,
			            }),
			            掉落概率: 配置.掉落概率 || 0.3,
			            房间ID: 配置.房间ID || null,
			            x: 配置.x || null,
			            y: 配置.y || null,
			            状态: 配置.状态 || 怪物状态.休眠,
			            强化: 配置.强化 || false,
			            基础生命值: 配置.基础生命值 || 23,
			            基础攻击力: 配置.基础攻击力 || 3,
			            移动率: 配置.移动率 || 0.7,
			            基础攻击范围: 1,
			            跟踪距离: 25,
			            攻击冷却: 4,
			        });
			        if (this.掉落物) {
			            this.尝试添加随机词条到掉落物(this.掉落物);
			        }
			    }
			    位置合法(x, y) {
			        if (!super.位置合法(x,y)) return false;
			        if (
			            地牢[y][x].类型 === 单元格类型.物品 &&
			            地牢[y][x].关联物品 instanceof 火焰物品
			        ) {
			            return false;
			        }
			        return true;
			    }
			    尝试攻击() {
        const 攻击成功 = super.尝试攻击();
        if (攻击成功) {
            if (怪物状态表.get(this)?.类型 === "魅惑") {
                new 状态效果(
                    "冻结",
                    "#2196F3",
                    "冻",
                    3,
                    null,
                    null,
                    this.魅惑目标怪物
                );
            } else if (this.目标 instanceof 宠物) {
                new 状态效果("冻结", "#2196F3", "冰", 3, null, null, this.目标);
            } else if (
                this.目标?.x == 玩家.x && this.目标?.y==玩家.y &&
                !Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                    玩家装备.get(
                        当前装备页 * 装备栏每页装备数 + i + 1
                    )
                )
                    .filter((v) => v != null)
                    .some((item) => item.名称 === "冰盾")
            ) {
                new 状态效果(
                    "冻结",
                    "#2196F3",
                    图标映射.冰冻怪物,
                    3,
                    3
                ); 
            }
        }
    }
			    获得效果(状态效果) {
			        if (状态效果.类型 === "冻结") {
			            状态效果.移除状态();
			            return false;
			        }
			        if (状态效果.类型 === "火焰") {
			            this.恢复背景类型();
			            
			            所有怪物 = 所有怪物.filter((m) => m !== this);
			            const 新怪物 = new 怪物({
			                x: this.x,
			                y: this.y,
			                当前生命值: this.当前生命值,
			                基础生命值: this.生命值,
			            });
			            放置怪物到单元格(新怪物, this.x, this.y);
			            新怪物.绘制血条();
			        }
			        return true;
			    }
			}
			class 米诺陶 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.米诺陶,
			            类型: "米诺陶",
			            基础生命值: 100 + (配置.强化 ? 150 : 0),
			            基础攻击力: 6 + (配置.强化 ? 5 : 0),
			            移动率: 0.9,
			            掉落概率: 1.0,
			            基础攻击范围: 1,
			            跟踪距离: 1000,
			            基础移动距离: 1,
			            攻击冷却: 1,
			            残血逃跑: false,
			            ...配置,
			        });
			        this.技能冷却 = {
			            高速冲撞: 12,
			            喷火: 5,
			            喷射毒液: 10,
			            战争践踏: 8,
			            异墙凸起: 12,
			        };
			        this.技能冷却剩余 = {
			            高速冲撞: 0,
			            喷火: Math.floor(prng() * 3),
			            喷射毒液: Math.floor(prng() * 4),
			            战争践踏: Math.floor(prng() * 5),
			            异墙凸起: Math.floor(prng() * 8),
			        };
			    }
			    计算路径(目标X, 目标Y) {
			        const 路径 = [];
			        const dx = 目标X - this.x;
			        const dy = 目标Y - this.y;
			
			        if (dx === 0 && dy === 0) {
			            return 路径;
			        }
			
			        const 步数 = Math.max(Math.abs(dx), Math.abs(dy));
			        const x增量 = dx / 步数;
			        const y增量 = dy / 步数;
			
			        let 当前X = this.x;
			        let 当前Y = this.y;
			
			        for (let i = 0; i < 步数; i++) {
			            当前X += x增量;
			            当前Y += y增量;
			            const 下一个点X = Math.round(当前X);
			            const 下一个点Y = Math.round(当前Y);
			
			            if (路径.length > 0) {
			                const 上一个点 = 路径[路径.length - 1];
			                if (
			                    上一个点.x === 下一个点X &&
			                    上一个点.y === 下一个点Y
			                ) {
			                    continue;
			                }
			            }
			            路径.push({ x: 下一个点X, y: 下一个点Y });
			        }
			
			        return 路径;
			    }
			
			    计算目标路径(x, y) {
			        return this.计算路径(x, y);
			    }
			
			    更新技能冷却() {
			        for (const 技能 in this.技能冷却剩余) {
			            if (
			                this.技能冷却剩余[技能] > 0 &&
			                prng() < 0.5
			            ) {
			                this.技能冷却剩余[技能]--;
			            }
			        }
			    }
			
			    受伤(伤害, 来源 = null) {
			        if (来源 === "火焰" || 来源 === "中毒") {
			            return;
			        }
			
			        if (this.当前生命值 > 0) {
			            this.当前生命值 -= 伤害;
			            if (中文模式) this.触发受击动画();
			
			            if (this.当前生命值 <= 0) {
			                const deathX = this.x,
			                    deathY = this.y;
			                this.恢复背景类型();
			                if (this.血条元素) this.血条元素.remove();
			                所有怪物 = 所有怪物.filter((m) => m !== this);
			
			                const 附近位置 = [
			                    [0, 0],
			                    [0, 1],
			                    [0, -1],
			                    [1, 0],
			                    [-1, 0],
			                    [1, 1],
			                    [1, -1],
			                    [-1, 1],
			                    [-1, -1],
			                ];
			                const 可用位置列表 = [];
			
			                for (const [dx, dy] of 附近位置) {
			                    const 检查X = deathX + dx;
			                    const 检查Y = deathY + dy;
			                    if (位置是否可用(检查X, 检查Y, false)) {
			                        可用位置列表.push({ x: 检查X, y: 检查Y });
			                    }
			                }
			
			                if (游戏状态 === '地图编辑器' || 游戏状态 === '编辑器游玩') {
			                    if (可用位置列表.length > 0) {
			                        const 旗帜位置 = 可用位置列表.shift();
			                        放置物品到单元格(new 旗帜(), 旗帜位置.x, 旗帜位置.y);
			                    } else {
			                        放置物品到单元格(new 旗帜(), deathX, deathY);
			                    }
								} else if (游戏状态 !== '图鉴') {
									if (可用位置列表.length > 0) {
										const 牛角位置 = 可用位置列表.shift();
										const 冲撞牛角掉落 = new 冲撞牛角({});
										放置物品到单元格(冲撞牛角掉落, 牛角位置.x, 牛角位置.y);
									}
									if (可用位置列表.length > 0) {
										const 战斧位置 = 可用位置列表.shift();
										const 战斧掉落 = new 嗜血战斧({ 强化: true });
										放置物品到单元格(战斧掉落, 战斧位置.x, 战斧位置.y);
									}
					
									if (可用位置列表.length > 0) {
										const 出口位置 = 可用位置列表.shift();
										生成迷宫出口(出口位置.x, 出口位置.y);
									} else {
										生成迷宫出口(deathX, deathY);
									}
								}
			
			                显示通知("米诺陶发出一声哀嚎，倒下了...", "成功");
			                return;
			            }
			            this.绘制血条();
			        }
			    }
			
			    选择目标() {
			        if (this.当前生命值 < this.生命值 * 0.7) {
			            let 最近药水位置 = null;
			            let 最小距离 = Infinity;
			            for (let y = 0; y < 地牢大小; y++) {
			                for (let x = 0; x < 地牢大小; x++) {
			                    const 物品 = 地牢[y]?.[x]?.关联物品;
			                    if (物品 instanceof 治疗药水) {
			                        const 方向 = [
			                            [0, -1],
			                            [0, 1],
			                            [-1, 0],
			                            [1, 0],
			                        ];
			                        for (const [dx, dy] of 方向) {
			                            const 邻近X = x + dx;
			                            const 邻近Y = y + dy;
			                            if (
			                                邻近X >= 0 &&
			                                邻近X < 地牢大小 &&
			                                邻近Y >= 0 &&
			                                邻近Y < 地牢大小 &&
			                                位置是否可用(邻近X, 邻近Y, false)
			                            ) {
			                                const 距离 =
			                                    Math.abs(this.x - 邻近X) +
			                                    Math.abs(this.y - 邻近Y);
			                                if (距离 < 最小距离) {
			                                    最小距离 = 距离;
			                                    最近药水位置 = {
			                                        x: 邻近X,
			                                        y: 邻近Y,
			                                        药水本体X: x,
			                                        药水本体Y: y,
			                                    };
			                                }
			                            }
			                        }
			                    }
			                }
			            }
			            if (最近药水位置) {
			                this.目标 = 最近药水位置;
			                return 最近药水位置;
			            }
			        }
			        this.目标 = 玩家;
			        return { x: 玩家.x, y: 玩家.y };
			    }
			
			                    尝试移动() {
			        this.更新技能冷却();
			        const 目标 = this.选择目标();
			
			        if (目标.药水本体X !== undefined) {
			            this.目标路径 = this.计算路径(目标.x, 目标.y);
			            if (this.目标路径) {
			                super.尝试移动();
			                const 距离药水 =
			                    Math.abs(this.x - 目标.药水本体X) +
			                    Math.abs(this.y - 目标.药水本体Y);
			                if (距离药水 === 1) {
			                    const 药水单元格 =
			                        地牢[目标.药水本体Y]?.[目标.药水本体X];
			                    if (
			                        药水单元格 &&
			                        药水单元格.关联物品 instanceof 治疗药水
			                    ) {
			                        this.当前生命值 = Math.min(
			                            this.生命值,
			                            this.当前生命值 + 50
			                        );
			                        药水单元格.关联物品 = null;
			                        if (药水单元格.类型 === 单元格类型.物品)
			                            药水单元格.类型 = null;
			                        添加日志(
			                            `${this.类型} 喝下了治疗药水，恢复了生命！`,
			                            "信息"
			                        );
			                        this.绘制血条();
			                        const 迷宫尺寸 = 85;
			                        const 偏移X = Math.floor((地牢大小 - 迷宫尺寸) / 2);
			                        const 偏移Y = Math.floor((地牢大小 - 迷宫尺寸) / 2);
			                        let 放置成功 = false;
			                        for (let 尝试次数 = 0; 尝试次数 < 100 && !放置成功; 尝试次数++) {
			                            const 新药水X = 偏移X + Math.floor(prng() * 迷宫尺寸);
			                            const 新药水Y = 偏移Y + Math.floor(prng() * 迷宫尺寸);
			                            if (位置是否可用(新药水X, 新药水Y, false) && 地牢[新药水Y]?.[新药水X]?.背景类型 === 单元格类型.走廊) {
			                                 放置物品到单元格(new 治疗药水({ 强化: true }), 新药水X, 新药水Y);
			                                 放置成功 = true;
			                            }
			                        }
			                        绘制();
			                    }
			                }
			            }
			        } else {
			            this.目标路径 = this.计算路径(目标.x, 目标.y);
			            super.尝试移动();
			        }
			    }
			
			    尝试攻击() {
			        const 玩家距离 =
			            Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        const 技能列表 = [];
			
			        if (玩家距离 >= 8 && this.技能冷却剩余.高速冲撞 <= 0)
			            技能列表.push("高速冲撞");
			        if (玩家距离 <= 4 && this.技能冷却剩余.喷火 <= 0)
			            技能列表.push("喷火");
			        if (玩家距离 <= 5 && this.技能冷却剩余.喷射毒液 <= 0)
			            技能列表.push("喷射毒液");
			        if (玩家距离 <= 3 && this.技能冷却剩余.战争践踏 <= 0)
			            技能列表.push("战争践踏");
			        if (
			            玩家距离 > 2 &&
			            玩家距离 < 7 &&
			            this.技能冷却剩余.异墙凸起 <= 0
			        )
			            技能列表.push("异墙凸起");
			
			        if (技能列表.length > 0) {
			            const 选用技能 =
			                技能列表[
			                    Math.floor(prng() * 技能列表.length)
			                ];
			            switch (选用技能) {
			                case "高速冲撞":
			                    return this.高速冲撞();
			                case "喷火":
			                    return this.喷火();
			                case "喷射毒液":
			                    return this.喷射毒液();
			                case "战争践踏":
			                    return this.战争践踏();
			                case "异墙凸起":
			                    return this.异墙凸起();
			            }
			        } else if (玩家距离 <= this.攻击范围) {
			            return super.尝试攻击();
			        }
			
			        return false;
			    }
			
			    高速冲撞() {
			        if (
			            this.技能冷却剩余.高速冲撞 > 0 ||
			            this.选择目标().药水本体X !== undefined
			        )
			            return false;
			
			        const 伤害 = this.攻击力 * 1.5;
			        const 冲撞距离 = 10;
			        const 落点距离 = 4;
			        const dx = 玩家.x - this.x;
			        const dy = 玩家.y - this.y;
			
			        if (dx === 0 && dy === 0) return false;
			
			        let dirX, dirY;
			        if (Math.abs(dx) > Math.abs(dy)) {
			            dirX = Math.sign(dx);
			            dirY = 0;
			        } else {
			            dirX = 0;
			            dirY = Math.sign(dy);
			        }
			
			        const 冲撞路径 = [];
			        let 撞到玩家 = false;
			
			        for (let i = 1; i <= 冲撞距离; i++) {
			            const 路径X = this.x + i * dirX;
			            const 路径Y = this.y + i * dirY;
			            冲撞路径.push({ x: 路径X, y: 路径Y });
			            if (路径X === 玩家.x && 路径Y === 玩家.y) {
			                伤害玩家(伤害, this);
			                撞到玩家 = true;
			                break;
			            }
			            if (当前出战宠物列表.some(pet => pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === 路径X && pet.y === 路径Y)) {
    当前出战宠物列表.forEach(pet => {
        if (pet.x === 路径X && pet.y === 路径Y && pet.层数==当前层数 ) {
            pet.受伤(伤害);
        }
    });
}
			        }
			
			        if (撞到玩家) {
			            for (let i = 1; i <= 落点距离; i++) {
			                const 路径X = 玩家.x + i * dirX;
			                const 路径Y = 玩家.y + i * dirY;
			                if (
			                    路径X < 0 ||
			                    路径X >= 地牢大小 ||
			                    路径Y < 0 ||
			                    路径Y >= 地牢大小
			                )
			                    break;
			                冲撞路径.push({ x: 路径X, y: 路径Y });
			            }
			        }
			
			        let 最终落点 = { x: this.x, y: this.y };
			        for (const 节点 of 冲撞路径) {
			            const 当前单元格 = 地牢[节点.y]?.[节点.x];
			
			            if (this.位置合法(节点.x, 节点.y, true)) {
			                最终落点 = { x: 节点.x, y: 节点.y };
			            } else {
			                break;
			            }
			            当前单元格.背景类型 = 单元格类型.走廊;
			        }
			
			        if (冲撞路径.length === 0) return false;
			
			        const 旧X = this.x,
			            旧Y = this.y;
			        this.恢复背景类型();
			        this.x = 最终落点.x;
			        this.y = 最终落点.y;
			        this.保存新位置类型(this.x, this.y);
			        地牢[this.y][this.x].类型 = 单元格类型.怪物;
			        地牢[this.y][this.x].关联怪物 = this;
			        生成墙壁();
			        怪物动画状态.set(this, {
			            旧逻辑X: 旧X,
			            旧逻辑Y: 旧Y,
			            目标逻辑X: this.x,
			            目标逻辑Y: this.y,
			            视觉X: 旧X,
			            视觉Y: 旧Y,
			            动画开始时间: Date.now(),
			            正在动画: true,
			        });
			
			        计划显示格子特效(冲撞路径, "FF4500");
			        添加日志("米诺陶发动了高速冲撞！", "警告");
			        this.技能冷却剩余.高速冲撞 = this.技能冷却.高速冲撞;
			        return true;
			    }
			
			    喷火() {
			        if (this.技能冷却剩余.喷火 > 0) return false;
			        const 范围 = 4;
			        const 方向 = [
			            [-1, 0],
			            [1, 0],
			            [0, -1],
			            [0, 1],
			        ];
			        const 火焰区域 = [];
			        for (const [dx, dy] of 方向) {
			            let lastX = this.x,
			                lastY = this.y;
			            for (let i = 0; i <= 范围; i++) {
			                const x = this.x + i * dx,
			                    y = this.y + i * dy;
			                if (
			                    x < 0 ||
			                    x >= 地牢大小 ||
			                    y < 0 ||
			                    y >= 地牢大小
			                )
			                    break;
			
			                const 前一单元格 = 地牢[lastY]?.[lastX];
			                const 当前单元格 = 地牢[y]?.[x];
			                if (!前一单元格 || !当前单元格) break;
			                const 移动方向 = 获取移动方向(lastX, lastY, x, y);
			                if (
			                    前一单元格.墙壁[移动方向.当前墙] ||
			                    当前单元格.墙壁[移动方向.反方向墙]
			                )
			                    break;
			
			                火焰区域.push({ x, y });
			                lastX = x;
			                lastY = y;
			            }
			        }
			        火焰区域.forEach(({ x, y }) => {
			            计划显示格子特效([{ x, y }], "FFA500");
			            if (玩家.x === x && 玩家.y === y) 伤害玩家(this.攻击力, this);
						当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === x && pet.y === y && pet.层数==当前层数 ) {
        pet.受伤(this.攻击力);
    }
});
			        });
			        添加日志(`${this.类型} 喷出了火焰！`, "警告");
			        this.技能冷却剩余.喷火 = this.技能冷却.喷火;
			        return true;
			    }
			
			    喷射毒液() {
			        if (this.技能冷却剩余.喷射毒液 > 0) return false;
			        const 范围 = 3;
			        const 毒液数量 = 5;
			        const 可选位置 = [];
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                const x = this.x + dx,
			                    y = this.y + dy;
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小 &&
			                    位置是否可用(x, y, false)
			                ) {
			                    可选位置.push({ x, y });
			                }
			            }
			        }
			        for (
			            let i = 0;
			            i < Math.min(毒液数量, 可选位置.length);
			            i++
			        ) {
			            const 位置 =
			                可选位置[
			                    Math.floor(prng() * 可选位置.length)
			                ];
			            const 毒液 = new 毒液物品({ 强化: this.强化 });
			            放置物品到单元格(毒液, 位置.x, 位置.y);
			            可选位置.splice(可选位置.indexOf(位置), 1);
			        }
			        添加日志(`${this.类型} 喷射了毒液！`, "警告");
			        this.技能冷却剩余.喷射毒液 = this.技能冷却.喷射毒液;
			        return true;
			    }
			
			    战争践踏() {
			        if (this.技能冷却剩余.战争践踏 > 0) return false;
			        const 范围 = 3;
			        const 影响格子 = [];
			        const 击中列表 = new Set();
			
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                if (Math.abs(dx) + Math.abs(dy) > 范围) continue;
			                const x = this.x + dx;
			                const y = this.y + dy;
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小
			                ) {
			                    计划显示格子特效([{ x, y }], "A52A2A");
			
			                    if (玩家.x === x && 玩家.y === y) {
			                        击中列表.add(玩家);
			                    }
			                    当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === x && pet.y === y && pet.层数==当前层数 ) {
        击中列表.add(pet);
    }
});
			                    const 单元格 = 地牢[y]?.[x];
			                    if (
			                        单元格?.关联怪物 &&
			                        单元格.关联怪物 !== this
			                    ) {
			                        击中列表.add(单元格.关联怪物);
			                    }
			                }
			            }
			        }
			
			        击中列表.forEach((目标) => {
			            if (目标 === 玩家) {
			                伤害玩家(this.攻击力, this);
			                new 状态效果(
			                    "眩晕",
			                    效果颜色编号映射[效果名称编号映射.眩晕],
			                    图标映射.眩晕,
			                    3
			                );
			            } else if (目标 instanceof 怪物) {
			                new 状态效果(
			                    "眩晕",
			                    效果颜色编号映射[效果名称编号映射.眩晕],
			                    图标映射.眩晕,
			                    2,
			                    null,
			                    null,
			                    目标
			                );
			            }
			        });
			
			        添加日志(`${this.类型} 发动了战争践踏！`, "警告");
			        this.技能冷却剩余.战争践踏 = this.技能冷却.战争践踏;
			        return true;
			    }
			
			    异墙凸起() {
			        if (this.技能冷却剩余.异墙凸起 > 0) return false;
			
			        const 尝试次数 = 15;
			        for (let i = 0; i < 尝试次数; i++) {
			            const 角度 = prng() * Math.PI * 2;
			            const 距离 = 2.5 + prng() * 2;
			            const 墙壁半长 = 4 + prng() * 8;
			            const 墙壁中心X = 玩家.x + Math.cos(角度) * 距离;
			            const 墙壁中心Y = 玩家.y + Math.sin(角度) * 距离;
			            const 墙壁方向X = -Math.sin(角度);
			            const 墙壁方向Y = Math.cos(角度);
			            const 起点X = 墙壁中心X - 墙壁方向X * 墙壁半长;
			            const 起点Y = 墙壁中心Y - 墙壁方向Y * 墙壁半长;
			            const 终点X = 墙壁中心X + 墙壁方向X * 墙壁半长;
			            const 终点Y = 墙壁中心Y + 墙壁方向Y * 墙壁半长;
			
			            const 格子列表 = 获取直线格子(
			                起点X,
			                起点Y,
			                终点X,
			                终点Y
			            );
			
			            if (
			                格子列表.some(
			                    (p) => p.x === 玩家.x && p.y === 玩家.y
			                )
			            )
			                continue;
			
			            const 有效墙壁格子 = 格子列表.filter(({ x, y }) => {
			                if (
			                    x < 0 ||
			                    x >= 地牢大小 ||
			                    y < 0 ||
			                    y >= 地牢大小
			                )
			                    return false;
			                const 单元格 = 地牢[y]?.[x];
			                return (
			                    单元格 &&
			                    (单元格.背景类型 === 单元格类型.走廊 ||
			                        单元格.背景类型 === 单元格类型.房间) &&
			                    !单元格.关联物品 &&
			                    !单元格.关联怪物
			                );
			            });
			
			            if (有效墙壁格子.length >= 4) {
			                有效墙壁格子.forEach(({ x, y }) => {
			                    const 单元格 = 地牢[y][x];
			                    const 原背景类型 = 单元格.背景类型;
			                    const 计时器实例 = new 临时墙壁计时器({ 原背景类型: 原背景类型 });
			                    
			                    
			                    放置物品到单元格(计时器实例, x, y); 
			                    单元格.背景类型 = 单元格类型.墙壁;
			                    所有计时器.push(计时器实例);
			                });
			                生成墙壁();
			                计划显示格子特效(有效墙壁格子, "8B4513");
			                添加日志(`${this.类型} 发动了异墙凸起！`, "警告");
			                this.技能冷却剩余.异墙凸起 = this.技能冷却.异墙凸起;
			                return true;
			            }
			        }
			        return false;
			    }
			
			    规划移动路径() {
			        let 当前位置 = { x: this.x, y: this.y };
			        let 有效位置 = null;
			        for (
			            let i = 0;
			            i < Math.min(this.目标路径.length, this.移动距离);
			            i++
			        ) {
			            const 节点 = this.目标路径[i];
			            const nextX = 节点.x,
			                nextY = 节点.y;
			
			            const 目标单元格 = 地牢[nextY]?.[nextX];
			
			            if (目标单元格.背景类型 === 单元格类型.墙壁) {
			                目标单元格.背景类型 = 单元格类型.走廊;
			                生成墙壁();
			                有效位置 = { x: nextX, y: nextY };
			                break;
			            }
			
			            if (this.位置合法(nextX, nextY)) {
			                有效位置 = { x: nextX, y: nextY };
			            }
			
			            当前位置 = { x: nextX, y: nextY };
			        }
			        if (有效位置) this.目标路径 = [];
			        return 有效位置;
			    }
			
			    位置合法(x, y, 忽略怪物 = false) {
			        if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
			            return false;
			        const 单元格 = 地牢[y]?.[x];
			        if (!单元格) return false;
			        if (单元格.关联物品 && 单元格.关联物品.阻碍怪物)
			            return false;
			        if (
			            !忽略怪物 &&
			            单元格.关联怪物 &&
			            单元格.关联怪物 !== this
			        )
			            return false;
			        return true;
			    }
			}
			
			class 恐惧怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.恐惧怪物,
			            类型: "恐惧怪物",
			            基础生命值: 30 + (配置.强化 ? 15 : 0),
			            基础攻击力: 5 + (配置.强化 ? 2 : 0),
			            移动率: 0.6,
			            掉落物: new 恐惧魔杖({ 强化: 配置.强化 ?? false }),
			            掉落概率: 0.8,
			            基础攻击范围: 2,
			            跟踪距离: 10,
			            数据: {
			                恐惧持续时间: 3 + (配置?.强化 ? 2 : 0),
			                ...配置.数据,
			            },
			            ...配置,
			        });
			        this.击退距离 = 2 + (配置.强化 ? 1 : 0);
			    }
			
			    尝试攻击() {
			        const 我的状态 = 怪物状态表.get(this);
			        if (我的状态?.类型 === "冻结") return false;
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余 -= 1;
			            return false;
			        }
			
			        if (我的状态?.类型 === "魅惑") {
			            if (
			                this.魅惑目标怪物 &&
			                this.魅惑目标怪物 !== this &&
			                this.魅惑目标怪物.当前生命值 > 0
			            ) {
			                // this.通向目标路径 应该由 处理怪物回合 中的 计算目标路径 更新
			                if (
			                    this.通向目标路径 &&
			                    this.通向目标路径.length <= this.攻击范围
			                ) {
			                    this.魅惑目标怪物.受伤(this.攻击力, this);
			                    this.攻击冷却回合剩余 = this.攻击冷却;
			                    计划显示格子特效(
			                        this.通向目标路径,
			                        效果颜色编号映射[
			                            效果名称编号映射.恐惧
			                        ].slice(1)
			                    );
			
			                    if (this.魅惑目标怪物.当前生命值 > 0) {
			                        new 状态效果(
			                            "恐惧",
			                            效果颜色编号映射[效果名称编号映射.恐惧],
			                            图标映射.恐惧,
			                            this.自定义数据.get("恐惧持续时间") ||
			                                3,
			                            null,
			                            null,
			                            this.魅惑目标怪物,
			                            1
			                        );
			                        添加日志(
			                            `${this.类型} 使 ${this.魅惑目标怪物.类型} 陷入了恐惧！`,
			                            "信息"
			                        );
			                    }
			                    return true;
			                }
			            }
			            return false;
			        } else {
			            const 玩家距离 =
			                Math.abs(this.x - 玩家.x) +
			                Math.abs(this.y - 玩家.y);
			
			            if (
			                玩家距离 <= this.攻击范围 &&
			                检查视线(
			                    this.x,
			                    this.y,
			                    玩家.x,
			                    玩家.y,
			                    this.攻击范围
			                )
			            ) {
			                伤害玩家(this.攻击力, this);
			                this.攻击冷却回合剩余 = this.攻击冷却;
			
			                let dx = 玩家.x - this.x;
			                let dy = 玩家.y - this.y;
			                let 方向DX = 0,
			                    方向DY = 0;
			
			                if (Math.abs(dx) > Math.abs(dy))
			                    方向DX =
			                        Math.sign(dx) ||
			                        (dy === 0
			                            ? prng() < 0.5
			                                ? 1
			                                : -1
			                            : 0);
			                else if (Math.abs(dy) > Math.abs(dx))
			                    方向DY =
			                        Math.sign(dy) ||
			                        (dx === 0
			                            ? prng() < 0.5
			                                ? 1
			                                : -1
			                            : 0);
			                else if (dx !== 0 && dy !== 0) {
			                    if (prng() < 0.5) 方向DX = Math.sign(dx);
			                    else 方向DY = Math.sign(dy);
			                }
			                if (方向DX === 0 && 方向DY === 0) {
			                    if (prng() < 0.5)
			                        方向DX = prng() < 0.5 ? 1 : -1;
			                    else 方向DY = prng() < 0.5 ? 1 : -1;
			                }
			
			                if (方向DX !== 0 || 方向DY !== 0) {
			                    let 最终X = 玩家.x;
			                    let 最终Y = 玩家.y;
			                    for (let i = 1; i <= this.击退距离; i++) {
			                        const 尝试X = 玩家.x + 方向DX * i;
			                        const 尝试Y = 玩家.y + 方向DY * i;
			
			                        if (
			                            尝试X < 0 ||
			                            尝试X >= 地牢大小 ||
			                            尝试Y < 0 ||
			                            尝试Y >= 地牢大小
			                        )
			                            break;
			                        if (
			                            !检查移动可行性(
			                                最终X,
			                                最终Y,
			                                尝试X,
			                                尝试Y,
			                                true
			                            )
			                        )
			                            break;
			                        const 目标单元格 = 地牢[尝试Y]?.[尝试X];
			                        if (
			                            !目标单元格 ||
			                            [
			                                单元格类型.墙壁,
			                                单元格类型.上锁的门,
			                            ].includes(目标单元格.背景类型)
			                        )
			                            break;
			                        if (
			                            目标单元格.关联怪物 ||
			                            (目标单元格.关联物品 &&
			                                目标单元格.关联物品.阻碍怪物)
			                        )
			                            break;
			
			                        最终X = 尝试X;
			                        最终Y = 尝试Y;
			                    }
			
			                    if (最终X !== 玩家.x || 最终Y !== 玩家.y) {
			                        const 旧恐惧X = 玩家.x,
			                            旧恐惧Y = 玩家.y;
			                        玩家.x = 最终X;
			                        玩家.y = 最终Y;
			                        处理玩家着陆效果(
			                            旧恐惧X,
			                            旧恐惧Y,
			                            玩家.x,
			                            玩家.y
			                        );
			                        更新视口();
			                        添加日志(
			                            `你被 ${this.类型} 击退了！`,
			                            "警告"
			                        );
			                        this.攻击冷却回合剩余++;
			                        绘制();
			                    }
			                }
			                计划显示格子特效(
			                    [{ x: 玩家.x, y: 玩家.y }],
			                    效果颜色编号映射[效果名称编号映射.恐惧].slice(1)
			                );
			                return true;
			            }
			            return false;
			        }
			    }
			}
			
			class 物品 {
			    constructor(配置 = {}) {
			        this.类型 = 配置.类型 || "其他物品";
			        this.名称 = 配置.名称 || "未命名物品";
			        this.图标 = 配置.图标 || "◎"; //图标要使用图标映射
			        this.品质 = 配置.品质 || 1;
			        this.堆叠数量 = 配置.堆叠数量 || 1;
			        const 材料列表 = Object.values(材料);
			        this.材质 = 配置.材质 ?? 材料列表[Math.floor(prng() * 材料列表.length)];
			        this.最大堆叠数量 = 配置.最大堆叠数量 || 最大堆叠数;
			        this.颜色索引 = 配置.颜色索引 || 0;
			        if (配置.数据 instanceof Map) {
			            this.自定义数据 = new Map([...配置.数据]);
			        } else {
			            this.自定义数据 = new Map(Object.entries(配置.数据 || {}));
			        }
			        
			        const date = new Date();
			        this.唯一标识 =
			            配置.唯一标识 ||
			            Symbol(
			                Date.now().toString() + prng().toString()
			            );
			        this.已装备 = 配置.已装备 || false;
			        this.装备槽位 = 配置.已装备 || null;
			        this.x = 配置.x || null;
			        this.y = 配置.y || null;
			        this.显示元素 = null;
			        this.isActive = false; //屎山莫动
			        this.强化 = 配置.强化 || false;
			        this.能否拾起 =
			            配置.能否拾起 === undefined ? true : 配置.能否拾起;
			        this.是否正常物品 =
			            配置.是否正常物品 === undefined
			                ? true
			                : 配置.是否正常物品; // 用于配置是否是只能存在于地图上被玩家使用的物品
			        this.效果描述 = 配置.效果描述 || null;
			        this.是否隐藏 = 配置.是否隐藏 || false; //是否在背包中显示
			        this.是否为隐藏物品 = 配置.是否为隐藏物品 || false; //是否在地图上显示
			        this.阻碍怪物 =
			            配置.阻碍怪物 !== undefined ? 配置.阻碍怪物 : true;
			        this.是否被丢弃 = 配置.是否被丢弃 ?? false;
			    }
			    装备() {
			        if (this.已装备) return false;
			        const 空槽 =
			            Array.from(
			                { length: 装备栏每页装备数 },
			                (_, i) => i + 1
			            ).find(
			                (id) =>
			                    !玩家装备.has(
			                        id + 当前装备页 * 装备栏每页装备数
			                    )
			            ) +
			            当前装备页 * 装备栏每页装备数;
			
			        if (空槽) {
			            this.已装备 = true;
			            this.装备槽位 = 空槽;
			            玩家装备.set(this.装备槽位, this);
			            
			            return true;
			        }
			        return false;
			    }
			
			    取消装备() {
			        if (!this.已装备) return false;
			        玩家装备.delete(this.装备槽位);
			        this.已装备 = false;
			        this.装备槽位 = null;
			        
			        return true;
			    }
			    获取名称() {
			        return (
			            `${this.显示名称} [${this.品质} 级]` +
			            (this.强化 ? ` [强化]` : ``)
			        );
			    }
			
			    使用() {
			        this.堆叠数量 -= 1;
			        return true;
			    }
			    当被收集(进入者) {
			        return true;
			    }
			    当被丢弃(x, y) {
			        return true;
			    }
			    可交互目标(目标) {
			        return false;
			    }
			    刷新显示() {
			        this.显示元素.innerHTML = `
			< div class="物品图标" > ${this.图标}</div >
			<div class="物品名称">${this.获取名称()}</div>
			                                                            ${
			                                                                this
			                                                                    .堆叠数量 >
			                                                                1
			                                                                    ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
			                                                                    : ""
			                                                            }
			        `;
			    }
			
			    获取提示() {
			        const lines = [];
			        lines.push(`${this.获取名称()} `);
			        lines.push(`类型：${this.类型} `);
			        lines.push(`品质：${"★".repeat(this.品质)} `);
			        lines.push(`材质：${this.材质}`);
			
			        if (this.最大堆叠数量 > 1) {
			            lines.push(
			                `堆叠：${this.堆叠数量} / ${this.最大堆叠数量}`
			            );
			        }
			        if (this.效果描述) {
			            lines.push(`效果描述：${this.效果描述} `);
			        }
			
			        const 融合Buffs = this.自定义数据?.get("fusedBuffs");
			        if (融合Buffs && 融合Buffs.length > 0) {
			            lines.push("--- 强化效果 ---");
			            融合Buffs.forEach((buff) => {
			                let buffs = 格式化Buff提示(buff)
			                if(buffs) lines.push(buffs);
			            });
			        }
			
			        if (
			            this.自定义数据?.has("附魔") &&
			            this.自定义数据.get("附魔").length > 0
			        ) {
			            const 附魔描述 = 获取附魔描述(
			                this.自定义数据.get("附魔")
			            );
			            if (附魔描述) lines.push(附魔描述);
			        }
			
			        if (
			            this.自定义数据?.has("耐久") &&
			            this.自定义数据?.has("原耐久")
			        ) {
			            lines.push(
			                `耐久：${this.自定义数据.get(
			                    "耐久"
			                )} / ${this.自定义数据.get("原耐久")}`
			            );
			        }
			
			        if (
			            this.自定义数据?.has("冷却剩余") &&
			            this.自定义数据?.has("冷却回合")
			        ) {
			            if (this.自定义数据.get("冷却回合") > 0) {
			                lines.push(
			                    `冷却：${this.自定义数据.get(
			                        "冷却剩余"
			                    )} / ${this.最终冷却回合||this.自定义数据.get("冷却回合")}回合`
			                );
			            }
			        }
			        if (this.自定义数据?.get("不可破坏")) {
			            lines.push("[不可破坏]");
			        }
			
			        return lines
			            .filter((line) => line && line.trim() !== "")
			            .join("\n");
			    }
			    安全销毁() {
			        this.取消装备();
			        this.自定义数据.clear();
			        this.唯一标识 = null;
			        return true;
			    }
			    get 显示图标() {
			        return this.图标;
			    }
			    get 显示名称() {
			        return this.名称;
			    }
			    get 颜色表() {
			        return 颜色表;
			    }
			    生成显示元素(用途 = "背包") {
			        const 元素 = document.createElement("div");
			        元素.className = "物品条目";
			        元素.setAttribute("data-quality", this.品质);
			        元素.__物品实例 = this; 
			        let 物品图标=getIconHTML(this.显示图标);
			
			        let innerHTML = `
			            <div class="物品图标">${物品图标}</div>
			            <div class="物品名称">${用途 === '背包' ? this.获取名称() : this.显示名称}</div>
			            ${this.堆叠数量 > 1 ? `<div class="物品堆叠">x${this.堆叠数量}</div>` : ""}
			        `;
			        
			        if (用途 === "背包") {
			            元素.classList.add("hover");
			            innerHTML += `
			                <button class="上屏按钮">↑</button>
			                <button class="丢弃按钮">↓</button>
			                <button class="使用按钮">⚡</button>
			                <button class="装备按钮" style="background: ${this.已装备 ? '#f44336' : '#FF9800'};">${getIconHTML('装备按钮')}</button>
			            `;
			        }
			        
			        元素.innerHTML = innerHTML;
			        
			        const 图标元素 = 元素.querySelector(".物品图标");
			        图标元素.style.color = this.颜色表[this.颜色索引] || '#FFFFFF';
			        图标元素.style.textShadow = `0 0 8px ${this.颜色表[this.颜色索引] || '#FFFFFF'}`;

			        if (!游戏设置.文本模式 && 游戏设置.emoji风格 !== 'local' && 游戏设置.emojiCDN是否可用 && this.显示图标!==物品图标) {
			            const img = 图标元素.querySelector('img');
			            if (img) {
			                img.style.filter = `drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5)) drop-shadow(0 0 8px ${this.颜色表[this.颜色索引] || '#FFFFFF'})`;
			            }
			        }
			        图标元素.style.fontSize = "2.5em";

			        if (用途 === '装备') {
			             元素.style.transform = 'scale(0.65)';
			             元素.style.margin = '-5px 0';
			        }
			
			        return 元素;
			    }
			    可堆叠于(其他物品) {
			        if (
			            this.堆叠数量 >= this.最大堆叠数量 ||
			            this.堆叠数量 >= 最大堆叠数
			        )
			            return false;
			        const 基础相同 =
			            this.类型 === 其他物品.类型 &&
			            this.名称 === 其他物品.名称 &&
			            this.图标 === 其他物品.图标 &&
			            this.品质 === 其他物品.品质 &&
			            this.强化 === 其他物品.强化 &&
			            this.获取名称() === 其他物品.获取名称();
			
			        const 数据相同 = this.比较自定义数据(其他物品.自定义数据);
			
			        return 基础相同 && 数据相同;
			    }
			    比较自定义数据(其他数据) {
			        if (this.自定义数据.size !== 其他数据.size) return false;
			
			        for (const [键, 值] of this.自定义数据) {
			            if (!其他数据.has(键)) return false;
			
			            const 其他值 = 其他数据.get(键);
			            if (typeof 值 === "object" && 值 !== null) {
			                if (!深度比较(值, 其他值)) return false;
			            } else if (值 !== 其他值) {
			                return false;
			            }
			        }
			        return true;
			    }
			}
			
			            class 武器类 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "武器",
			            名称: 配置.名称 || "铁剑",
			            图标: 配置.图标 || "⚔️",
			            品质: 配置.品质 || 1,
			            颜色索引: 配置.品质 - 1 || 0,
			            堆叠数量: 配置.堆叠数量 || 1,
			            最大堆叠数量: 配置.最大堆叠数量 || 1,
			            效果描述: 配置.效果描述 || null,
			            强化: 配置.强化 || false,
			            ...配置,
			            数据: {
			                基础攻击力: 配置.基础攻击力 ?? 3,
			                冷却回合: 配置.冷却回合 || 1,
			                冷却剩余: 0,
			                攻击范围: 配置.攻击范围 ?? 1,
			                耐久: 配置.耐久 || 30,
			                原耐久: 配置.耐久 || 30,
			                不可破坏: 配置.不可破坏 || false,
			                攻击目标数: 配置.攻击目标数 ?? 1,
			                附魔: 配置.附魔 || [],
			                fusedBuffs: 配置.fusedBuffs || [],
			                ...配置.数据,
			            },
			        });
			    }
			    get 最终攻击范围() {
			        let 范围 = this.自定义数据.get("攻击范围") || 1;
			        const buffs = this.自定义数据.get("fusedBuffs") || [];
			        const 范围加成Buff = buffs.find(
			            (b) => b.type === 融合Buff类型.范围加成
			        );
			        if (
			            范围加成Buff &&
			            typeof 范围加成Buff.value === "number"
			        ) {
			            范围 += 范围加成Buff.value;
			        }
			        return Math.max(1, Math.round(范围));
			    }
			    get 最终冷却回合() {
			        let effectiveCooldown =
			            this.自定义数据.get("冷却回合") || 0;
			
			        if (this.强化) {
			            effectiveCooldown = Math.max(0, effectiveCooldown - 1);
			        }
			
			        const buffs = this.自定义数据.get("fusedBuffs") || [];
			
			        const sharpenedCooldownBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石冷却缩减);
			        if (sharpenedCooldownBuff) {
			            effectiveCooldown -= sharpenedCooldownBuff.value;
			        }
			
			        buffs.forEach((buff) => {
			            if (buff.type === 融合Buff类型.冷却缩减) {
			                effectiveCooldown -= buff.value;
			            } else if (buff.type === 融合Buff类型.冷却倍率) {
			                effectiveCooldown *=
			                    1 - Math.min(1, Math.max(0, buff.value));
			            }
			        });
			
			        return Math.max(1, Math.round(effectiveCooldown));
			    }
			
			    使用(目标怪物列表, 目标路径, 调用者) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			        if (!目标怪物列表) return 0;
			        const buffs = this.自定义数据.get("fusedBuffs") || [];
			        const sharpenedAttackBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石攻击加成);
			        const sharpenedCooldownBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石冷却缩减);
			        let sharpenedAttackBonus = 0;
			        if (sharpenedAttackBuff) {
			            sharpenedAttackBonus = sharpenedAttackBuff.value;
			        }
			
			        let 总伤害 = this.攻击力 + sharpenedAttackBonus;
			        let 总有效伤害 = 0;
			        let isCriticalHit = false;
			
			
			        const critChanceBuff = buffs.find(
			            (b) => b.type === 融合Buff类型.暴击几率
			        );
			        if (
			            critChanceBuff &&
			            prng() < critChanceBuff.value
			        ) {
			            isCriticalHit = true;
			            const critDamageBuff = buffs.find(
			                (b) => b.type === 融合Buff类型.暴击伤害倍率
			            );
			            const critMultiplier =
			                1.5 + (critDamageBuff ? critDamageBuff.value : 0);
			            总伤害 *= critMultiplier;
			            添加日志(`${this.获取名称()} 打出了暴击！`, "成功");
			        }
			
			        目标怪物列表.forEach((怪物) => {
			            if (怪物.当前生命值 > 0) {
			                const 原始血量 = 怪物.当前生命值;
			                怪物.受伤(Math.round(总伤害), 调用者);
			                const 实际伤害 = 原始血量 - 怪物.当前生命值;
			                if (实际伤害 > 0) 总有效伤害 += 实际伤害;
			
			                const luckyStrikeBuff = buffs.find(
			                    (b) => b.type === 融合Buff类型.幸运一击
			                );
			                if (
			                    luckyStrikeBuff &&
			                    prng() < luckyStrikeBuff.value &&
			                    怪物.当前生命值 > 0
			                ) {
			                    const luckyDamageMultiplier = 1.2;
			                    const bonusDamage = Math.round(
			                        总伤害 * (luckyDamageMultiplier - 1)
			                    );
			                    const originalMonsterHealthForLucky =
			                        怪物.当前生命值;
			                    怪物.受伤(bonusDamage, "幸运一击");
			                    const actualBonusDamage =
			                        originalMonsterHealthForLucky -
			                        怪物.当前生命值;
			                    if (actualBonusDamage > 0)
			                        总有效伤害 += actualBonusDamage;
			                    添加日志(
			                        `${this.获取名称()} 触发幸运一击！额外造成 ${bonusDamage} 伤害！`,
			                        "成功"
			                    );
			                }
			
			                const knockbackBuff = buffs.find(
			                    (b) => b.type === 融合Buff类型.击退几率
			                );
			                if (
			                    knockbackBuff &&
			                    prng() < knockbackBuff.value &&
			                    怪物.当前生命值 > 0
			                ) {
			                    let dx = 怪物.x - 玩家.x;
			                    let dy = 怪物.y - 玩家.y;
			                    let 方向DX = 0,
			                        方向DY = 0;
			                    if (Math.abs(dx) > Math.abs(dy))
			                        方向DX = Math.sign(dx);
			                    else if (Math.abs(dy) > Math.abs(dx))
			                        方向DY = Math.sign(dy);
			                    else if (dx !== 0) 方向DX = Math.sign(dx);
			                    else if (dy !== 0) 方向DY = Math.sign(dy);
			
			                    if (方向DX !== 0 || 方向DY !== 0) {
			                        const { x: 最终X, y: 最终Y } =
			                            怪物.计算最大甩飞位置(
			                                怪物.x,
			                                怪物.y,
			                                方向DX,
			                                方向DY,
			                                1
			                            );
			                        if (最终X !== 怪物.x || 最终Y !== 怪物.y) {
			                            怪物.恢复背景类型();
			                            怪物.x = 最终X;
			                            怪物.y = 最终Y;
			                            怪物.保存新位置类型(最终X, 最终Y);
			                            地牢[最终Y][最终X].类型 =
			                                单元格类型.怪物;
			                            地牢[最终Y][最终X].关联怪物 = 怪物;
			                            怪物.处理地形效果();
			                            怪物.绘制血条();
			                            添加日志(
			                                `${this.获取名称()} 将 ${
			                                    怪物.类型
			                                } 击退了！`,
			                                "信息"
			                            );
			                        }
			                    }
			                }
			                const fireChanceBuff = buffs.find(
			                    (b) => b.type === 融合Buff类型.火焰伤害
			                );
			                if (
			                    fireChanceBuff &&
			                    prng() < fireChanceBuff.value &&
			                    怪物.当前生命值 > 0
			                ) {
			                    new 状态效果(
			                        "火焰",
			                        效果颜色编号映射[效果名称编号映射.火焰],
			                        "火",
			                        3,
			                        null,
			                        null,
			                        怪物,
			                        2
			                    );
			                    添加日志(
			                        `${this.获取名称()} 点燃了 ${怪物.类型}！`,
			                        "成功"
			                    );
			                }
			                const poisonChanceBuff = buffs.find(
			                    (b) => b.type === 融合Buff类型.中毒几率
			                );
			                if (
			                    poisonChanceBuff &&
			                    prng() < poisonChanceBuff.value &&
			                    怪物.当前生命值 > 0
			                ) {
			                    new 状态效果(
			                        "中毒",
			                        效果颜色编号映射[效果名称编号映射.中毒],
			                        "☠️",
			                        3,
			                        null,
			                        null,
			                        怪物,
			                        1 + Math.floor(this.品质 / 2)
			                    );
			                    添加日志(
			                        `${this.获取名称()} 使 ${
			                            怪物.类型
			                        } 中毒了！`,
			                        "成功"
			                    );
			                }
			                const iceChanceBuff = buffs.find(
			                    (b) => b.type === 融合Buff类型.冰冻几率
			                );
			                if (
			                    iceChanceBuff &&
			                    prng() < iceChanceBuff.value &&
			                    怪物.当前生命值 > 0
			                ) {
			                    new 状态效果(
			                        "冻结",
			                        "#2196F3",
			                        "冻",
			                        2,
			                        null,
			                        null,
			                        怪物
			                    );
			                    添加日志(
			                        `${this.获取名称()} 冻结了 ${怪物.类型}！`,
			                        "成功"
			                    );
			                }
			            }
			        });
			
			        const lifeStealBuff = buffs.find(
			            (b) => b.type === 融合Buff类型.生命偷取
			        );
			        if (lifeStealBuff && 总有效伤害 > 0) {
			            const 吸血量 = Math.ceil(
			                总有效伤害 * lifeStealBuff.value
			            );
			            const 生命条 =
			                document.querySelector(".health-bar");
			            const 当前宽度 =
			                parseFloat(生命条.style.width) || 0;
			            const 新宽度 = Math.min(100, 当前宽度 + 吸血量);
			            if (新宽度 > 当前宽度) {
			                生命条.style.width = `${新宽度}%`;
			                添加日志(
			                    `${this.获取名称()} 吸取了 ${吸血量.toFixed(
			                        0
			                    )} 点生命！`,
			                    "成功"
			                );
			                触发HUD显示();
			            }
			        }
			
			        const energyStealBuff = buffs.find(
			            (b) => b.type === 融合Buff类型.攻击吸能
			        );
			        if (energyStealBuff && 总有效伤害 > 0) {
			            const 吸能量 = Math.ceil(
			                总有效伤害 * energyStealBuff.value * 0.5
			            );
			            const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            能量条.style.width = `${Math.min(
			                100,
			                当前能量 + 吸能量/自定义全局设置.初始能量值*100
			            )}%`;
			            添加日志(
			                `${this.获取名称()} 吸取了 ${吸能量.toFixed(
			                    0
			                )} 点能量！`,
			                "成功"
			            );
			            触发HUD显示();
			        }
			
			        if (sharpenedAttackBuff) {
			            sharpenedAttackBuff.usesLeft--;
			            if (sharpenedAttackBuff.usesLeft <= 0) {
			                const index = buffs.indexOf(sharpenedAttackBuff);
			                if (index > -1) buffs.splice(index, 1);
			            }
			        }
			        if (sharpenedCooldownBuff) {
			            sharpenedCooldownBuff.usesLeft--;
			             if (sharpenedCooldownBuff.usesLeft <= 0) {
			                const index = buffs.indexOf(sharpenedCooldownBuff);
			                if (index > -1) buffs.splice(index, 1);
			            }
			        }
			        this.自定义数据.set("fusedBuffs", buffs);
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			
			        this.自定义数据.set("冷却剩余", this.最终冷却回合);
			
			        if (总有效伤害 > 0) {
			            if (目标怪物列表.length > 1) {
			                显示通知(
			                    `${this.名称} 对 ${
			                        目标怪物列表.length
			                    } 个目标造成共 ${总有效伤害.toFixed(
			                        1
			                    )} 点伤害！`,
			                    "成功"
			                );
			            } else {
			                显示通知(
			                    `${this.名称} 造成 ${总有效伤害.toFixed(
			                        1
			                    )} 点伤害！`,
			                    "成功"
			                );
			            }
			        }
			        this.触发通用附魔(目标怪物列表);
			        let 物品已生锈 = false;
			
			        if (this.材质 === 材料.铁质 && !this.自定义数据.get("不可破坏")) {
			            if (prng() < 0.05) {
			                let 锈蚀度 = this.自定义数据.get('锈蚀度') || 0;
			                if (锈蚀度 < this.攻击力) {
			                    this.自定义数据.set('锈蚀度', Math.round(10*(锈蚀度 + Math.pow(this.攻击力-锈蚀度,1/3)/8))/10);
			                    物品已生锈 = true;
			                }
			            }
			        }
			
			    if (物品已生锈) {
			        更新背包显示();
			    }
			
			        if (目标路径) {
			            目标路径.forEach((攻击路径) => {
			                计划显示格子特效(攻击路径);
			            });
			        }
			        更新装备显示();
			        return 总有效伤害;
			    }
			
			    触发通用附魔(目标怪物列表) {
			        if (!当前天气效果.includes("严寒")) {
			            if (
			                this.自定义数据
			                    .get("附魔")
			                    ?.find((item) => item.种类 === "火焰附魔")?.等级
			            ) {
			                const 火焰等级 = this.自定义数据
			                    .get("附魔")
			                    .find((item) => item.种类 === "火焰附魔").等级;
			                目标怪物列表.forEach((怪物) => {
			                    if (怪物.当前生命值 > 0) {
			                        new 状态效果(
			                            "火焰",
			                            "#CC5500",
			                            "火",
			                            火焰等级,
			                            null,
			                            null,
			                            怪物
			                        );
			                    }
			                });
			            }
			        }
			
			        const 连锁附魔 = this.自定义数据
			            .get("附魔")
			            ?.find((item) => item.种类 === "连锁附魔");
			        if (连锁附魔) {
			            const 连锁距离 = 连锁附魔.等级;
			            目标怪物列表.forEach((初始目标) => {
			                if (初始目标.当前生命值 > 0) {
			                    this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
			                }
			            });
			        }
			    }
			    触发连锁(当前目标, 连锁距离, 已攻击过的怪物 = []) {
			        let 第一层 = false;
			        if (this.访问过 === undefined) {
			            this.访问过 = [];
			            第一层 = true;
			        }
			        if (this.访问过.includes(当前目标)) return;
			        this.访问过.push(当前目标);
			        if (连锁距离 <= 0) return;
			        const 可连锁目标 = this.寻找连锁目标(
			            当前目标,
			            连锁距离,
			            this.访问过
			        );
			        for (const 新目标 of 可连锁目标) {
			            计划显示格子特效(新目标.路径);
			            this.使用([新目标.怪物]);
			            添加日志(
			                `连锁附魔击中了 ${新目标.怪物.类型}！`,
			                "成功"
			            );
			        }
			        if (第一层) this.访问过 = undefined;
			    }
			    寻找连锁目标(中心怪物, 连锁距离, 已攻击过的怪物) {
			        const 开放列表 = [
			            { x: 中心怪物.x, y: 中心怪物.y, 距离: 0, 路径: [] },
			        ];
			        const 已访问 = new Set([`${中心怪物.x},${中心怪物.y} `]);
			        const 可连锁目标 = [];
			
			        for (const 怪物 of 已攻击过的怪物) {
			            已访问.add(`${怪物.x},${怪物.y} `);
			        }
			
			        const 方向 = [
			            { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
			            { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
			            { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
			            { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
			        ];
			
			        while (开放列表.length > 0) {
			            const 当前 = 开放列表.shift();
			
			            if (当前.距离 >= 连锁距离) continue;
			
			            for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    continue;
			
			                const 位置键 = `${新X},${新Y} `;
			                if (已访问.has(位置键)) continue;
			
			                const 当前单元格 = 地牢[当前.y][当前.x];
			                const 目标单元格 = 地牢[新Y][新X];
			
			                if (
			                    当前单元格.墙壁[当前墙] ||
			                    目标单元格.墙壁[目标墙] ||
			                    目标单元格.背景类型 === 单元格类型.墙壁 ||
			                    目标单元格.背景类型 === 单元格类型.上锁的门
			                )
			                    continue;
			
			                const 新路径 = [...当前.路径, { x: 新X, y: 新Y }];
			
			                if (
			                    目标单元格.类型 === 单元格类型.怪物 &&
			                    目标单元格.关联怪物?.状态 === 怪物状态.活跃
			                ) {
			                    可连锁目标.push({
			                        怪物: 目标单元格.关联怪物,
			                        路径: 新路径,
			                    });
			                    已访问.add(位置键);
			                }
			                已访问.add(位置键);
			                开放列表.push({
			                    x: 新X,
			                    y: 新Y,
			                    距离: 当前.距离 + 1,
			                    路径: 新路径,
			                });
			            }
			        }
			        return 可连锁目标;
			    }
			
			    获取提示() {
			        const lines = super.获取提示().split("\n");
			        const weaponStats = [];
			        weaponStats.push(`攻击力：${this.攻击力.toFixed(1)}`);
			
			        const 锈蚀度 = this.自定义数据.get('锈蚀度');
			        if (this.材质 === 材料.铁质 && 锈蚀度 > 0) {
			            weaponStats.push(`锈蚀：攻击力 -${锈蚀度}`);
			        }
			        weaponStats.push(`攻击范围：${this.最终攻击范围} 格`);
			
			        if (
			            this.自定义数据.has("攻击目标数") &&
			            this.自定义数据.get("攻击目标数") > 1
			        ) {
			            weaponStats.push(
			                `穿透数量：${this.自定义数据.get("攻击目标数")} 个`
			            );
			        }
			
			        let insertIndex = lines.findIndex((line) =>
			            line.startsWith("品质：")
			        );
			        if (insertIndex === -1) {
			            insertIndex = lines.findIndex((line) =>
			                line.startsWith("类型：")
			            );
			        }
			        if (insertIndex === -1) {
			            insertIndex = lines.findIndex((line) =>
			                line.startsWith(this.获取名称())
			            );
			        }
			
			        if (insertIndex !== -1) {
			            lines.splice(insertIndex + 1, 0, ...weaponStats);
			        } else {
			            lines.unshift(...weaponStats);
			        }
			        return lines.filter(Boolean).join("\n");
			    }
			
			    获取名称() {
			        return (
			            物品.prototype.获取名称.call(this) +
			            (this.自定义数据.get("攻击目标数") > 1
			                ? " [范围武器]"
			                : "")
			        );
			    }
			
			    get 攻击力() {
			        let 基础攻击 =
			            (this.自定义数据.get("基础攻击力") || 0) +
			            (this.强化 ? 2 : 0) +
			            (玩家属性.攻击加成 || 0);
			        let 锈蚀度 = this.自定义数据.get('锈蚀度') || 0;
			        if (this.材质 === 材料.铁质 && 锈蚀度 > 0) {
			            基础攻击 = Math.max(1, 基础攻击 - 锈蚀度);
			        }
			        const buffs = this.自定义数据.get("fusedBuffs") || [];
			
			        buffs.forEach((buff) => {
			            if (buff.type === 融合Buff类型.攻击加成) {
			                基础攻击 += buff.value;
			            } else if (buff.type === 融合Buff类型.攻击倍率) {
			                基础攻击 *= 1 + buff.value;
			            }
			        });
			
			        const synergyBuffWeapon = buffs.find(
			            (b) => b.type === 融合Buff类型.协同效应
			        );
			        if (synergyBuffWeapon) {
			            基础攻击 += synergyBuffWeapon.value;
			        }
			
			        基础攻击 +=
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "锋利附魔")?.等级 *
			                2 || 0;
			
			        return Math.max(1, 基础攻击);
			    }
			    get 耐久消耗() {
			        if (this.自定义数据.get("不可破坏")) return 0;
			        const 耐久附魔等级 =
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "耐久附魔")?.等级 ||
			            0;
			        let 消耗系数 = 1;
			        if (耐久附魔等级 > 0) {
			            消耗系数 = 1 / (耐久附魔等级 + 1);
			        }
			        if (this.强化) {
			            消耗系数 *= 0.5;
			        }
			         消耗系数 *= (1 - (玩家属性.耐久消耗减免 || 0));
			        return Math.max(0.1, 消耗系数);
			    }
			}
			class 钥匙 extends 物品 {
			    constructor(配置) {
			        let 钥匙唯一标识 = undefined;
			        if (配置.地牢层数 && 配置.对应门ID) {
			            钥匙唯一标识 = Symbol.for(
			                配置.地牢层数.toString() +
			                    "层" +
			                    配置.对应门ID.toString()
			            );
			        }
			        super({
			            ...配置,
			            类型: 配置.类型 || "钥匙",
			            名称: 配置.名称 || "钥匙",
			            图标: 配置.图标 || 图标映射.钥匙,
			            品质: 配置.品质 || 2,
			            颜色索引: 配置.颜色索引,
			            唯一标识: 钥匙唯一标识,
			            数据: {
			                对应门ID: 配置.对应门ID || 0,
			                地牢层数: 配置.地牢层数,
			            },
			            
			        });
			    }
			
			    获取名称() {
			        const 颜色名 = 颜色名表[this.颜色索引] || "未知";
			        return `${颜色名} 铜钥匙`;
			    }
			
			    可交互目标(门实例) {
			        if (门实例.类型 !== "上锁的门") return false;
			
			        const 钥匙绑定的门ID = this.自定义数据.get("对应门ID");
			        const 钥匙绑定的层数 = this.自定义数据.get("地牢层数");
			
			        if (钥匙绑定的层数 == -1 && 钥匙绑定的门ID == -1) {
			            return true; 
			        }
			
			        if (钥匙绑定的层数 == -1) {
			            return 钥匙绑定的门ID == 门实例.房间ID;
			        }
			        
			        if (钥匙绑定的层数 == 当前层数) {
			            return 钥匙绑定的门ID == 门实例.房间ID;
			        }
			        
			        return false;
			    }
			    获取提示() {
			        return [
			            `类型：${this.类型} `,
			            `品质：${"★".repeat(this.品质)} `,
			            `房间 ID：${this.自定义数据.get("对应门ID")==-1 ? '万能' : this.自定义数据.get("对应门ID")} `,
			            `层数：${this.自定义数据.get("地牢层数")==-1 ? '万能' : this.自定义数据.get("地牢层数")} `,
			        ].join("\n");
			    }
			    使用() {
			        显示通知("请使用互动键来使用钥匙", "错误");
			        return false;
			    }
			}
			class 金币 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "金币",
			            名称: "金币",
			            图标: 图标映射.金币,
			            品质: 1,
			            颜色索引: 2,
			            堆叠数量: 配置.数量 || 1,
			            是否隐藏: 配置.是否隐藏 || false,
			        });
			    }
			
			    获取名称() {
			        return `${this.名称} `;
			    }
			    使用() {
			        return false;
			    }
			}
			
			class 卷轴类 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "卷轴",
			            名称: 配置.名称 || "魔法卷轴",
			            效果描述: 配置.效果描述 || "未知效果",
			            图标: 配置.图标 || 图标映射.卷轴,
			            品质: 配置.品质 || 3,
			            颜色索引: 配置.品质 - 1 || 2,
			            堆叠数量: 配置.堆叠数量 || 1,
			            强化: 配置.强化 || false,
			            最大堆叠数量: 1,
			            ...配置,
			            数据: {
			                能量消耗: 配置.能量消耗 ?? 2,
			                已解锁: 配置.已解锁 || false,
			                ...配置.数据,
			            },
			            
			        });
			    }
			    安全销毁() {
			        if (当前激活卷轴列表.has(this))
			            当前激活卷轴列表.delete(this);
			        let ret = super.安全销毁();
			
			        return ret;
			    }
			    使用() {
			        // 具体效果由子类实现
			        return false;
			    }
			    获取名称() {
			        return this.自定义数据.get("已解锁")
			            ? `${this.显示名称} [${this.品质} 级]` +
			                  (this.强化 ? " [强化]" : "")
			            : "卷轴";
			    }
			    消耗能量() {
			        if (当前天气效果.includes("诡魅")) {
			            当前激活卷轴列表.delete(this);
			            if (this.卸下()){
			            显示通知("不论如何念咒，卷轴依然无法启用...","信息",true);
			            
			            }
			            return false;
			        }
			        return 扣除能量(this.最终能量消耗, true);
			    }
			    get 最终能量消耗() {
			        return Math.max(
			            this.自定义数据.get("能量消耗") - (this.强化 ? 2 : 0),
			            0
			        );
			    }
			    get 显示图标() {
			        return this.自定义数据.get("已解锁")
			            ? this.图标
			            : 图标映射.卷轴;
			    }
			    get 显示名称() {
			        return this.自定义数据.get("已解锁") ? this.名称 : "卷轴";
			    }
			    生成显示元素(用途 = "背包") {
			        let 元素 = super.生成显示元素(用途);
			        if (this.装备按钮) {
			        this.装备按钮.onclick = (e) => {
			            e.stopPropagation();
			            this.isActive = true;
			            元素.classList.add("active");
			            document.querySelectorAll(".物品条目").forEach((el) => {
			                if (el !== 元素 && el.__物品实例) {
			                    el.classList.remove("active");
			                    el.__物品实例.isActive = false;
			                }
			            });
			            if (this.已装备) {
			                this.取消装备();
			                显示通知("已卸下", "成功");
			            } else {
			                if (this.装备()) {
			                    显示通知("已装备", "成功");
			                } else {
			                    显示通知("装备槽已满！", "错误");
			                }
			            }
			            this.装备按钮.style.background = this.已装备
			                ? "#f44336"
			                : "#FF9800";
			            更新装备显示();
			            更新背包显示();
			
			            document.getElementById("浮动提示框").style.display =
			                "none";
			        };
			        }
			        return 元素;
			    }
			    取消装备() {
			        if (!this.已装备) return false;
			        if (当前激活卷轴列表.has(this)) {
			            当前激活卷轴列表.delete(this);
			            this.卸下();
			        }
			        let ret = super.取消装备();
			        return ret;
			    }
			    卸下() {
			        return true;
			    }
			    获取提示() {
			        if (this.自定义数据.get("已解锁")) {
			            return [
			                `${this.获取名称()} `,
			                `品质：${"★".repeat(this.品质)} `,
			                `材质：${this.材质}`,
			                `能量消耗：${this.最终能量消耗} `,
			                `效果描述：${this.效果描述} `,
			            ].join("\n");
			        } else {
			            return `古老的卷轴，似乎透露着什么秘密...\n材质：${this.材质}`;
			        }
			    }
			}
			class 防御装备类 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "防御装备",
			            名称: 配置.名称 || "护甲模板",
			            图标: 配置.图标 || "🛡️",
			            品质: 配置.品质 || 2,
			            颜色索引: 配置.品质 - 1 || 1,
			            最大堆叠数量: 1,
			            堆叠数量: 配置.堆叠数量 || 1,
			            效果描述: 配置.效果描述 || null,
			            强化: 配置.强化 || false,
			            数据: {
			                防御力: 配置.防御力 || 1,
			                耐久: 配置.耐久 || 100,
			                原耐久: 配置.耐久 || 100,
			                不可破坏: 配置.不可破坏 || false,
			                附魔: 配置.附魔 || [],
			                fusedBuffs: 配置.fusedBuffs || [],
			                ...配置.数据,
			            },
			        });
			    }
			    get 最终防御力() {
			        let 基础防御 =
			            (this.自定义数据.get("防御力") || 0) +
			            (this.强化 ? 2 : 0);
			        const buffs = this.自定义数据.get("fusedBuffs") || [];
			
			        buffs.forEach((buff) => {
			            if (buff.type === 融合Buff类型.防御加成) {
			                基础防御 += buff.value;
			            } else if (buff.type === 融合Buff类型.防御倍率) {
			                基础防御 *= 1 + buff.value;
			            }
			        });
			
			        const synergyBuffArmor = buffs.find(
			            (b) => b.type === 融合Buff类型.协同效应
			        );
			        if (synergyBuffArmor) {
			            基础防御 += synergyBuffArmor.value;
			        }
			
			        基础防御 +=
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "保护附魔")?.等级 ||
			            0;
			        return Math.max(0, 基础防御);
			    }
			    get 耐久消耗() {
			        if (this.自定义数据.get("不可破坏")) return 0;
			        const 耐久附魔等级 =
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "耐久附魔")?.等级 ||
			            0;
			        let 消耗系数 = 1;
			        if (耐久附魔等级 > 0) {
			            消耗系数 = 1 / (耐久附魔等级 + 1);
			        }
			        if (this.强化) {
			            消耗系数 *= 0.5;
			        }
			        return Math.max(0.1, 消耗系数);
			    }
			    get 反伤() {
			        const 荆棘附魔等级 =
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "荆棘附魔")?.等级 ||
			            0;
			        if (荆棘附魔等级 > 0) {
			            return 荆棘附魔等级 * 1.5;
			        }
			        return 0;
			    }
			
			    当被攻击(原始攻击力, 来源 = null) {
			        let 最终伤害 = 原始攻击力;
			        const buffs = this.自定义数据.get("fusedBuffs") || [];
			
			        const flatReductionBuff = buffs.find(
			            (b) => b.type === 融合Buff类型.固定伤害减免
			        );
			        if (flatReductionBuff) {
			            最终伤害 = Math.max(
			                0,
			                最终伤害 - flatReductionBuff.value
			            );
			        }
			
			        最终伤害 = Math.max(0, 最终伤害 - this.最终防御力);
			
			        if (
			            来源 === "炸弹" &&
			            this.自定义数据
			                .get("附魔")
			                .some(
			                    (item) =>
			                        item.种类 === "爆炸保护附魔" &&
			                        item.等级 > 0
			                )
			        ) {
			            最终伤害 = Math.max(
			                0,
			                最终伤害 -
			                    this.自定义数据
			                        .get("附魔")
			                        .find(
			                            (item) => item.种类 === "爆炸保护附魔"
			                        )?.等级 *
			                        5
			            );
			        }
			
			        if (
			            来源 instanceof 怪物 &&
			            this.自定义数据
			                .get("附魔")
			                .some(
			                    (item) =>
			                        item.种类 === "火焰附魔" && item.等级 > 0
			                )
			        ) {
			            const 火焰等级 = this.自定义数据
			                .get("附魔")
			                .find((item) => item.种类 === "火焰附魔").等级;
			            new 状态效果(
			                "火焰",
			                "#CC5500",
			                "火",
			                火焰等级,
			                null,
			                null,
			                来源
			            );
			        }
			
			        const dodgeBuff = buffs.find(
			            (b) => b.type === 融合Buff类型.闪避几率
			        );
			        if (dodgeBuff && prng() < dodgeBuff.value) {
			            添加日志(`${this.获取名称()} 触发闪避！`, "成功");
			            最终伤害 = 0;
			        }
			
			        const poisonChanceBuff = buffs.find(
			            (b) => b.type === 融合Buff类型.中毒几率
			        );
			        if (
			            poisonChanceBuff &&
			            来源 instanceof 怪物 &&
			            来源.当前生命值 > 0 &&
			            prng() < poisonChanceBuff.value
			        ) {
			            new 状态效果(
			                "中毒",
			                效果颜色编号映射[效果名称编号映射.中毒],
			                "☠️",
			                3,
			                null,
			                null,
			                来源,
			                1 + Math.floor(this.品质 / 2)
			            );
			            添加日志(
			                `${this.获取名称()} 使 ${来源.类型} 中毒了！`,
			                "成功"
			            );
			        }
			
			        if (最终伤害 <= 0 && 原始攻击力 > 0)
			            最终伤害 = Math.round(prng() * 100) / 100;
			
			        if (最终伤害 > 0) {
			            this.自定义数据.set(
			                "耐久",
			                (this.自定义数据.get("耐久") - this.耐久消耗).toFixed(2)
			            );
			            if (
			                this.反伤 > 0 &&
			                来源 instanceof 怪物 &&
			                !(来源 instanceof 仙人掌怪物)
			            ) {
			                来源.受伤(this.反伤, "荆棘");
			                添加日志(
			                    `${this.名称} 因荆棘造成了 ${this.反伤} 点伤害！`,
			                    "成功"
			                );
			            }
			
			            const energyOnHitBuff = buffs.find(
			                (b) => b.type === 融合Buff类型.受击回能
			            );
			            if (energyOnHitBuff) {
			                const 恢复能量 = Math.ceil(energyOnHitBuff.value);
			                const 能量条 = document.querySelector(".power-bar");
			                const 当前能量 =
			                    parseFloat(能量条.style.width) || 0;
			                能量条.style.width = `${Math.min(
			                    100,
			                    当前能量 + 恢复能量/自定义全局设置.初始能量值*100
			                )}%`;
			                添加日志(
			                    `${this.获取名称()} 受到攻击，恢复了 ${恢复能量} 点能量！`,
			                    "信息"
			                );
			                触发HUD显示();
			            }
			        }
			
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        更新装备显示();
			
			        return 最终伤害;
			    }
			
			    获取提示() {
			        const lines = super.获取提示().split("\n");
			        const armorStats = [
			            `防御力：${this.最终防御力.toFixed(1)}`,
			        ];
			
			        let insertIndex = lines.findIndex((line) =>
			            line.startsWith("品质：")
			        );
			        if (insertIndex === -1) {
			            insertIndex = lines.findIndex((line) =>
			                line.startsWith("类型：")
			            );
			        }
			        if (insertIndex === -1) {
			            insertIndex = lines.findIndex((line) =>
			                line.startsWith(this.获取名称())
			            );
			        }
			
			        if (insertIndex !== -1) {
			            lines.splice(insertIndex + 1, 0, ...armorStats);
			        } else {
			            lines.unshift(...armorStats);
			        }
			        return lines.filter(Boolean).join("\n");
			    }
			    使用() {
			        显示通知("装备不能被主动使用！", "错误");
			        return false;
			    }
			}
			class 扫帚 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "扫帚",
			            图标: 图标映射.扫帚,
			            品质: 2,
			            基础攻击力: 8,
			            冷却回合: 4,
			            攻击范围: 3,
			            耐久: 配置?.耐久 || 70,
			            强化: 配置?.强化 || false,
			            效果描述: "扫除面前扇形区域的敌人。",
			            攻击目标数: 99,
			            ...配置,
			        });
			    }

			    寻找最近的可攻击怪物(使用者) {
			        let 最近怪物 = null;
			        let 最小距离 = Infinity;

			        所有怪物.forEach(怪物 => {
			            if (怪物.状态 === 怪物状态.活跃 && 怪物.当前生命值 > 0) {
			                if (检查视线(使用者.x, 使用者.y, 怪物.x, 怪物.y, 999)) {
			                    const 距离 = Math.abs(使用者.x - 怪物.x) + Math.abs(使用者.y - 怪物.y);
			                    if (距离 < 最小距离) {
			                        最小距离 = 距离;
			                        最近怪物 = 怪物;
			                    }
			                }
			            }
			        });
			        return 最近怪物;
			    }

			    使用(目标怪物列表, 目标路径, 使用者 = 玩家) {
			        if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return 0;

			        const 目标怪物 = this.寻找最近的可攻击怪物(使用者);
			        if (!目标怪物) {
			            显示通知("没有可攻击的目标！", "警告");
			            return 0;
			        }

			        const dx = 目标怪物.x - 使用者.x;
			        const dy = 目标怪物.y - 使用者.y;

			        let 主轴;
			        let 方向 = {};
			        if (Math.abs(dx) >= Math.abs(dy)) {
			            主轴 = 'x';
			            方向.dx = dx === 0 ? 1 : Math.sign(dx);
			            方向.dy = 0;
			        } else {
			            主轴 = 'y';
			            方向.dx = 0;
			            方向.dy = dy === 0 ? 1 : Math.sign(dy);
			        }

			        const 攻击格子 = new Set();
			        let 总有效伤害 = 0;
			        const 击中怪物 = new Set();
			        const 攻击范围 = this.最终攻击范围;

			        for (let i = 1; i <= 攻击范围; i++) {
			            const 宽度 = (i * 2) - 1;
			            for (let j = -Math.floor(宽度 / 2); j <= Math.floor(宽度 / 2); j++) {
			                let 格子X, 格子Y;
			                if (主轴 === 'x') {
			                    格子X = 使用者.x + i * 方向.dx;
			                    格子Y = 使用者.y + j;
			                } else {
			                    格子X = 使用者.x + j;
			                    格子Y = 使用者.y + i * 方向.dy;
			                }
			
			                const 路径到目标 = 获取直线路径(使用者.x, 使用者.y, 格子X, 格子Y);
			                let 路径畅通 = true;
			                if (路径到目标.length > 1) {
			                    for(let k = 1; k < 路径到目标.length; k++) {
			                        if(!检查移动可行性(路径到目标[k-1].x, 路径到目标[k-1].y, 路径到目标[k].x, 路径到目标[k].y, true)){
			                            路径畅通 = false;
			                            break;
			                        }
			                    }
			                }

			                if (路径畅通 && 格子X >= 0 && 格子X < 地牢大小 && 格子Y >= 0 && 格子Y < 地牢大小) {
			                    攻击格子.add(`${格子X},${格子Y}`);
			                    const 单元格 = 地牢[格子Y]?.[格子X];
			                    if (单元格?.关联怪物 && 单元格.关联怪物.当前生命值 > 0 && !击中怪物.has(单元格.关联怪物)) {
			                        const 怪物 = 单元格.关联怪物;
			                        击中怪物.add(怪物);
			                        const 原始血量 = 怪物.当前生命值;
			                        怪物.受伤(this.攻击力, 使用者);
			                        const 实际伤害 = 原始血量 - 怪物.当前生命值;
			                        if (实际伤害 > 0) 总有效伤害 += 实际伤害;
			                    }
			                }
			            }
			        }
			        
			        const 格式化攻击格子 = Array.from(攻击格子).map(coord => {
			            const [x, y] = coord.split(',').map(Number);
			            return {x, y};
			        });
			        
			        计划显示格子特效(格式化攻击格子, "A9A9A9", 20);

			        this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			        }
			        this.自定义数据.set("冷却剩余", this.最终冷却回合);

			        if (击中怪物.size > 0) {
			            显示通知(`扫帚挥击了 ${击中怪物.size} 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");
			            this.触发通用附魔(Array.from(击中怪物));
			        } else {
			            显示通知(`${this.名称} 挥了个空！`, "信息");
			        }
			        更新装备显示();
			        return 总有效伤害;
			    }
			}
			class 吸血剑 extends 武器类 {
			    constructor(配置) {
			        super({
			            名称: "吸血剑",
			            图标: 图标映射.吸血剑,
			            品质: 2,
			            基础攻击力: 6,
			            冷却回合: 3,
			            攻击范围: 1,
			            耐久: 配置?.耐久 || 80,
			            强化: 配置?.强化 || false,
			            效果描述: `${(0.7 * 100).toFixed(0)}%概率吸取造成伤害${(
			                0.25 * 100
			            ).toFixed(0)}%的生命。`,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            fusedBuffs: 配置?.数据?.fusedBuffs || [],
			            数据: {
			                吸血概率: 0.7,
			                吸血比例: 0.25,
			                ...(配置?.数据 || {}),
			            },
			        });
			    }
			
			    使用(目标怪物列表, 目标路径) {
			        const 总有效伤害 = super.使用(目标怪物列表, 目标路径); // 调用父类，它会处理暴击、击退等
			        if (总有效伤害 > 0) {
			            let 吸血概率 = this.自定义数据.get("吸血概率");
			            let 吸血比例 = this.自定义数据.get("吸血比例");
			
			            // 检查是否有生命偷取buff，如果有，则优先使用buff的几率和比例
			            const lifeStealBuff = (
			                this.自定义数据.get("fusedBuffs") || []
			            ).find((b) => b.type === 融合Buff类型.生命偷取);
			            if (lifeStealBuff) {
			                吸血概率 = lifeStealBuff.value; // 直接使用buff的value作为几率
			                吸血比例 = lifeStealBuff.value; // 假设buff的value同时代表比例，或者需要单独定义比例
			            }
			
			            if (prng() < 吸血概率) {
			                const 吸血量 = Math.ceil(总有效伤害 * 吸血比例);
			                const 生命条 =
			                    document.querySelector(".health-bar");
			                const 当前宽度 =
			                    parseFloat(生命条.style.width) || 0;
			                const 新宽度 = Math.min(100, 当前宽度 + 吸血量);
			                if (新宽度 > 当前宽度) {
			                    生命条.style.width = `${新宽度}%`;
			                    添加日志(
			                        `${this.获取名称()} 吸取了 ${吸血量.toFixed(
			                            0
			                        )} 点生命！`,
			                        "成功"
			                    );
			                    触发HUD显示();
			                }
			            }
			            return true;
			        }
			        return false;
			    }
			}
			class 棋子 extends 物品 {
			    constructor(配置) {
			        super({
			            类型: "棋子",
			            名称: 配置.名称 || "棋子",
			            图标: 配置.图标,
			            品质: 1,
			            颜色索引: 2,
			            最大堆叠数量: 8,
			            效果描述: "使用可以在玩家位置落子，按互动键可以提子",
			            ...配置,
			        });
			        this.能否拾起 = true;
			    }
			
			    可攻击位置(x, y, 棋盘) {
			        return [];
			    }
			    使用(玩家使用 = true, x0 = 0, y0 = 0) {
			        if (this.堆叠数量 <= 0) return false; // 检查是否有棋子可用
			
			        let 放置成功 = false;
			        if (玩家使用) {
			            const 当前房间ID = 房间地图[玩家.y][玩家.x];
			            const 当前房间 = 房间列表[当前房间ID];
			            if (当前房间?.类型 === "隐藏解谜棋盘") {
			                // 检查房间类型
			                let ret = 玩家放置物品(this, false); // 放置棋子逻辑不变
			                if (ret.x !== null) {
			                    // 检查放置是否成功
			                    放置成功 = true;
			                    检查解谜是否成功(当前房间.棋子数量);
			                    显示通知("落子成功", "成功");
			                } else {
			                    显示通知("无法在此处落子", "错误");
			                    return false; // 放置失败，不消耗棋子
			                }
			            } else {
			                显示通知("只能在解谜棋盘上落子", "错误");
			                return false; // 不在棋盘上，不消耗
			            }
			        } else {
			            // 非玩家使用（例如编辑器放置）的逻辑 - 可能不需要修改消耗
			            放置成功 = true; // 假设非玩家使用总是“成功”放置，不涉及消耗
			        }
			
			        if (放置成功 && 玩家使用) {
			            // 只有玩家成功放置才消耗
			            this.堆叠数量 -= 1; // 消耗一个棋子
			            if (this.堆叠数量 <= 0) {
			                // 如果是最后一个棋子，从背包或装备中移除
			                if (this.已装备) {
			                    玩家装备.delete(this.装备槽位);
			                    this.已装备 = false;
			                    this.装备槽位 = null;
			                    更新装备显示();
			                }
			                玩家背包.delete(this.唯一标识);
			                更新背包显示(); // 更新UI显示数量或移除条目
			            } else {
			                // 如果还有棋子，仅更新UI显示数量
			                更新背包显示();
			                更新装备显示();
			            }
			            return true; // 返回放置结果（放置逻辑已处理）
			        } else if (!玩家使用 && 放置成功) {
			            // 非玩家使用，可能不需要消耗或UI更新，直接返回true
			            return true;
			        }
			
			        return false; // 放置失败或其他情况
			    }
			}
			
			class 国际象棋车 extends 棋子 {
			    constructor(配置 = {}) {
			        super({
			            名称: "国际象棋车",
			            图标: "♜",
			            ...配置,
			        });
			    }
			    可攻击位置(x, y, 棋盘) {
			        const 攻击位置 = [];
			        const 棋盘大小 = 棋盘.length;
			
			        for (let i = 0; i < 棋盘大小; i++) {
			            if (i !== x) 攻击位置.push({ x: i, y: y });
			        }
			
			        for (let j = 0; j < 棋盘大小; j++) {
			            if (j !== y) 攻击位置.push({ x: x, y: j });
			        }
			
			        return 攻击位置;
			    }
			}
			
			class 国际象棋马 extends 棋子 {
			    constructor(配置 = {}) {
			        super({
			            名称: "国际象棋马",
			            图标: "♞",
			            ...配置,
			        });
			    }
			
			    可攻击位置(x, y, 棋盘) {
			        const 攻击位置 = [];
			        const 棋盘大小 = 棋盘.length;
			        const dx = [-2, -2, -1, -1, 1, 1, 2, 2];
			        const dy = [-1, 1, -2, 2, -2, 2, -1, 1];
			        for (let i = 0; i < 8; i++) {
			            const 新x = x + dx[i];
			            const 新y = y + dy[i];
			            if (
			                新x >= 0 &&
			                新x < 棋盘大小 &&
			                新y >= 0 &&
			                新y < 棋盘大小
			            ) {
			                攻击位置.push({ x: 新x, y: 新y });
			            }
			        }
			        return 攻击位置;
			    }
			}
			
			class 国际象棋象 extends 棋子 {
			    constructor(配置 = {}) {
			        super({
			            名称: "国际象棋象",
			            图标: "♝",
			            ...配置,
			        });
			    }
			
			    可攻击位置(x, y, 棋盘) {
			        const 攻击位置 = [];
			        const 棋盘大小 = 棋盘.length;
			
			        const directions = [
			            [1, 1],
			            [1, -1],
			            [-1, 1],
			            [-1, -1],
			        ];
			        for (const [dx, dy] of directions) {
			            for (let i = 1; i < 棋盘大小; i++) {
			                const 新x = x + i * dx;
			                const 新y = y + i * dy;
			
			                if (
			                    新x >= 0 &&
			                    新x < 棋盘大小 &&
			                    新y >= 0 &&
			                    新y < 棋盘大小
			                ) {
			                    攻击位置.push({ x: 新x, y: 新y });
			                } else {
			                    break;
			                }
			            }
			        }
			
			        return 攻击位置;
			    }
			}
			
			class 中国象棋炮 extends 棋子 {
			    constructor(配置 = {}) {
			        super({
			            名称: "中国象棋炮",
			            图标: "♚",
			            ...配置,
			        });
			    }
			
			    可攻击位置(x, y, 棋盘) {
			        const 攻击位置 = [];
			        const 棋盘大小 = 棋盘.length;
			
			        const directions = [
			            [1, 0],
			            [-1, 0],
			            [0, 1],
			            [0, -1],
			        ];
			        for (const [dx, dy] of directions) {
			            let 隔子 = false;
			            for (let i = 1; i < 棋盘大小; i++) {
			                const 新x = x + i * dx;
			                const 新y = y + i * dy;
			
			                if (
			                    新x >= 0 &&
			                    新x < 棋盘大小 &&
			                    新y >= 0 &&
			                    新y < 棋盘大小
			                ) {
			                    if (棋盘[新y][新x] !== 0) {
			                        if (!隔子) {
			                            隔子 = true;
			                        } else {
			                            攻击位置.push({ x: 新x, y: 新y });
			                            break;
			                        }
			                    } else if (!隔子) {
			                        攻击位置.push({ x: 新x, y: 新y });
			                    }
			                } else {
			                    break;
			                }
			            }
			        }
			
			        return 攻击位置;
			    }
			}
			class 药水类 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "药水",
			            名称: 配置.名称 || "基础药水",
			            图标: 配置.图标 || 图标映射.药水,
			            品质: 配置.品质 || 3,
			            颜色索引: 效果名称编号映射[配置.效果类型] || 0,
			            堆叠数量: 配置.堆叠数量 || 1,
			            最大堆叠数量: 16,
			            效果描述: 配置.效果描述 || null,
			            强化: 配置.强化 || false,
			            数据: {
			                是否冻结: 配置.是否冻结 || false,
			                基础持续时间: 配置.持续时间 || 3,
			                效果强度: 配置.效果强度 || 1,
			                效果类型: 配置.效果类型 || null,
			                ...配置.数据,
			            },
			        });
			        this.激活中 = false;
			        this.状态效果 = null;
			    }
			    获取名称() {
			        let 基础名称 = super.获取名称();
			        if (this.自定义数据?.get("是否冻结")) {
			            基础名称 += " [冻]";
			        }
			        return 基础名称;
			    }
			
			    使用() {
			        if (this.自定义数据?.get("是否冻结")) {
			            显示通知("药水被冻住了，无法使用！", "警告");
			            return false;
			        }
			        if (this.激活中) {
			            显示通知(
			                `${this.自定义数据.get("效果类型")} 效果已存在`,
			                "错误"
			            );
			            return false;
			        }
			
			        // 应用效果
			        this.激活中 = true;
			        this.状态效果 = new 状态效果(
			            this.自定义数据.get("效果类型"),
			            this.获取药水颜色(),
			            this.图标,
			            this.持续时间,
			            this.持续时间,
			            this
			        );
			        this.应用效果();
			
			        // 关键修复：在这里直接调用父类的使用方法来消耗一个单位
			        super.使用();
			
			        绘制();
			        显示通知(`${this.名称} 效果生效！`, "成功");
			        return true;
			    }
			
			    获取药水颜色() {
			        return 效果颜色编号映射[this.颜色索引] || "#FFFFFF";
			    }
			
			    应用效果() {
			        // 子类在这实现自定义效果...
			        return;
			    }
			
			    // [已修正]
			    移除效果() {
			        this.激活中 = false;
			        // 关键修复：移除这里的 super.使用() 调用，因为消耗已经在“使用”时完成。
			        // 子类在这还原效果...
			        return;
			    }
			
			    获取提示() {
			        return [
			            super.获取提示(),
			            `效果类型: ${this.自定义数据.get("效果类型")} `,
			            `持续时间: ${this.持续时间} 回合`,
			            `强度: +${this.强度} `,
			        ].join("\n");
			    }
			    get 强度() {
			        return (
			            this.自定义数据.get("效果强度") + (this.强化 ? 2 : 0)
			        );
			    }
			    get 持续时间() {
			        return (
			            this.自定义数据.get("基础持续时间") +
			            (this.强化 ? 2 : 0)
			        );
			    }
			    get 颜色表() {
			        return 效果颜色编号映射;
			    }
			}
			
			class 治疗药水 extends 药水类 {
			    constructor(配置) {
			        super({
			            名称: "治疗药水",
			            效果类型: "治疗",
			            持续时间: 5,
			            效果强度: 2,
			            堆叠数量: 配置.数量 || 1,
			            强化: 配置.强化 || false,
			        });
			    }
			    应用效果() {
			        const 当前生命 =
			            parseFloat(
			                document.querySelector(".health-bar").style.width
			            ) || 0;
			        document.querySelector(
			            ".health-bar"
			        ).style.width = `${Math.min(
			            100,
			            当前生命 + 4 * this.强度 //实际强度由getter决定
			        )}% `;
			        return;
			    }
			    移除效果() {
			        super.移除效果();
			        return;
			    }
			}
			
			class 能量药水 extends 药水类 {
			    constructor(配置) {
			        super({
			            名称: "能量药水",
			            效果类型: "能量",
			            持续时间: 5,
			            效果强度: 2,
			            堆叠数量: 配置.数量 || 1,
			            强化: 配置.强化 || false,
			        });
			    }
			    应用效果() {
			        const 当前能量 =
			            parseFloat(
			                document.querySelector(".power-bar").style.width
			            ) || 0;
			        document.querySelector(
			            ".power-bar"
			        ).style.width = `${Math.min(
			            100,
			            当前能量 + 3 * this.强度/自定义全局设置.初始能量值*100
			        )}% `;
			        return;
			    }
			    移除效果() {
			        super.移除效果();
			        return;
			    }
			}
			class 狂暴药水 extends 药水类 {
			    constructor(配置) {
			        super({
			            名称: "狂暴药水",
			            效果类型: "狂暴",
			            持续时间: 10,
			            效果强度: 1,
			            堆叠数量: 配置.数量 || 1,
			            强化: 配置.强化 || false,
			        });
			    }
			    应用效果() {
			        玩家属性.攻击加成 = 2 + 5 * this.强度;
			        return;
			    }
			    移除效果() {
			        玩家属性.攻击加成 = 0;
			        super.移除效果();
			        return;
			    }
			}
			class 神龟药水 extends 药水类 {
			    constructor(配置) {
			        super({
			            名称: "神龟药水",
			            效果类型: "神龟",
			            持续时间: 20,
			            效果强度: 1,
			            效果描述: "给予你赛尔达飞艇级别的防御",
			            堆叠数量: 配置.数量 || 1,
			            强化: 配置.强化 || false,
			        });
			    }
			    应用效果() {
			        玩家属性.防御加成 = 2 + 5 * this.强度;
			        return;
			    }
			    移除效果() {
			        玩家属性.防御加成 = 0;
			        super.移除效果();
			        return;
			    }
			}
			class 隐身药水 extends 药水类 {
			    constructor(配置) {
			        super({
			            名称: "隐身药水",
			            效果类型: "隐身",
			            持续时间: 35,
			            效果强度: 1,
			            效果描述: "悄悄滴进村，打枪滴不要。怪物视距全部变为 1",
			            堆叠数量: 配置.数量 || 1,
			            强化: 配置.强化 || false,
			        });
			    }
			    应用效果() {
			        处理怪物回合();
			        return; // 在 处理怪物回合 中检测了 玩家状态 来实现
			    }
			    移除效果() {
			        super.移除效果();
			        return;
			    }
			}
			class 透视药水 extends 药水类 {
			    constructor(配置) {
			        super({
			            名称: "透视药水",
			            效果类型: "透视",
			            持续时间: 50,
			            效果强度: 1,
			            效果描述: "透过迷雾，看清房内的陷阱",
			            堆叠数量: 配置.数量 || 1,
			            强化: 配置.强化 || false,
			        });
			    }
			    应用效果() {
			        玩家属性.透视 = true;
			        绘制();
			        return;
			    }
			    移除效果() {
			        玩家属性.透视 = false;
			        super.移除效果();
			        return;
			    }
			}
			class 死灵法杖 extends 武器类 {
    constructor(配置 = {}) {
        super({
            名称: "死灵法杖",
            图标: 图标映射.死灵法杖,
            品质: 2,
            基础攻击力: 1,
            冷却回合: 8,
            攻击范围: 10,
            耐久: 50,
            效果描述: "召唤一个骷髅仆从为你作战，仆从会在一定回合后消散。",
            ...配置,
            数据: {
                最大仆从数: 5 + (配置.强化 ? 5 : 0),
                ...配置.数据
            }
        });
    }

    使用(目标怪物列表, 目标路径, 使用者 = 玩家) {
        if (this.自定义数据.get("冷却剩余") > 0) {
            显示通知("法杖还未准备好！", "错误");
            return false;
        }

        const 当前仆从数 = 玩家仆从列表.length;
        if (当前仆从数 >= this.自定义数据.get("最大仆从数")) {
            显示通知("你无法控制更多的仆从！", "警告");
            return false;
        }

        let 放置位置 = 寻找可放置位置(使用者.x, 使用者.y);
        if (!放置位置) {
            显示通知("周围没有空间召唤仆从！", "错误");
            return false;
        }
        
        let 新仆从 = new 骷髅仆从({ 强化: this.强化 });
        let 放置成功=false
        if (放置怪物到单元格(新仆从, 放置位置.x, 放置位置.y)) {
            玩家仆从列表.push(新仆从);
            显示通知("骷髅仆从响应了你的召唤！", "成功");
            计划显示格子特效([{ x: 放置位置.x, y: 放置位置.y }], "8A2BE2");
            this.自定义数据.set("冷却剩余", this.最终冷却回合);
            更新装备显示();
            放置成功 = true
            //return true;
        }
        if (放置成功){
        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
        if(prng()<0.5){
        放置位置 = 寻找可放置位置(使用者.x, 使用者.y);
        if (!放置位置) {
            显示通知("周围没有空间召唤仆从！", "错误");
            return false;
        }

        新仆从 = new 骷髅仆从({ 强化: this.强化 });
        if (放置怪物到单元格(新仆从, 放置位置.x, 放置位置.y)) {
            玩家仆从列表.push(新仆从);
            //显示通知("一个骷髅仆从响应了你的召唤！", "成功");
            计划显示格子特效([{ x: 放置位置.x, y: 放置位置.y }], "8A2BE2");
            //this.自定义数据.set("冷却剩余", this.最终冷却回合);
            //更新装备显示();
            return true;
        }
        } else {
        return true;
        }
        }
        return false;
    }
}
			class 冰霜法杖 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "冰霜法杖",
			            图标: 图标映射.冰霜法杖,
			            品质: 3,
			            基础攻击力: 6,
			            冷却回合: 7,
			            攻击范围: 3,
			            耐久: 配置?.耐久 || 45,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "释放一圈冰霜能量，对范围内的敌人造成伤害并有几率冻结。",
			            攻击目标数: 99,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                冻结几率: 0.75 + (配置?.强化 ? 0.15 : 0),
			                冻结回合: 2,
			                ...配置.数据,
			            },
			        });
			    }
			
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			
			        const 范围 = this.最终攻击范围;
			        const 击中怪物 = new Set();
			        let 总有效伤害 = 0;
			        const 影响格子分层 = Array.from(
			            { length: 范围 + 1 },
			            () => []
			        );
			
			        const 队列 = [{ x: 使用者.x, y: 使用者.y, 距离: 0 }];
			        const 已访问 = new Set();
			        影响格子分层[0].push();
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			            if (当前.距离 >= 范围) continue;
			
			            const 方向 = [
			                { dx: 1, dy: 0 },
			                { dx: -1, dy: 0 },
			                { dx: 0, dy: 1 },
			                { dx: 0, dy: -1 },
			            ];
			
			            for (const { dx, dy } of 方向) {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			                const 位置键 = `${新X},${新Y}`;
			
			                if (
			                    新X >= 0 &&
			                    新X < 地牢大小 &&
			                    新Y >= 0 &&
			                    新Y < 地牢大小 &&
			                    !已访问.has(位置键)
			                ) {
			                    if (
			                        检查视线(使用者.x, 使用者.y, 新X, 新Y, 范围 + 1)
			                    ) {
			                        已访问.add(位置键);
			                        const 新距离 = 当前.距离 + 1;
			                        影响格子分层[新距离].push({
			                            x: 新X,
			                            y: 新Y,
			                        });
			                        队列.push({ x: 新X, y: 新Y, 距离: 新距离 });
			
			                        const 单元格 = 地牢[新Y][新X];
			
			                        if (
			                            单元格?.关联物品 instanceof 祭坛类 &&
			                            单元格.关联物品.自定义数据.get(
			                                "激活条件"
			                            ) === "冰霜封印" &&
			                            !单元格.关联物品.自定义数据.get(
			                                "已激活"
			                            )
			                        ) {
			                            单元格.关联物品.激活();
			                        }
			
			                        if (
			                            单元格?.关联怪物 instanceof 怪物 &&
			                            单元格.关联怪物.当前生命值 > 0
			                        ) {
			                            const 怪物 = 单元格.关联怪物;
			                            if (!击中怪物.has(怪物)) {
			                                击中怪物.add(怪物);
			                                const 原始血量 = 怪物.当前生命值;
			                                怪物.受伤(this.攻击力, "玩家");
			                                const 实际伤害 =
			                                    原始血量 - 怪物.当前生命值;
			                                if (实际伤害 > 0)
			                                    总有效伤害 += 实际伤害;
			
			                                if (
			                                    怪物.当前生命值 > 0 &&
			                                    prng() <
			                                        this.自定义数据.get(
			                                            "冻结几率"
			                                        )
			                                ) {
			                                    new 状态效果(
			                                        "冻结",
			                                        "#2196F3",
			                                        "冻",
			                                        this.自定义数据.get(
			                                            "冻结回合"
			                                        ),
			                                        null,
			                                        null,
			                                        怪物
			                                    );
			                                    添加日志(
			                                        `${怪物.类型} 被冰霜法杖冻结了！`,
			                                        "警告"
			                                    );
			                                }
			                            }
			                        } else if (
			                            单元格.关联物品 instanceof 炸弹
			                        ) {
			                            if (!单元格.关联物品.能否拾起) {
			                                单元格.关联物品.自定义数据.set(
			                                    "倒计时",
			                                    单元格.关联物品.自定义数据.get(
			                                        "爆炸时间"
			                                    )
			                                );
			                                单元格.关联物品.能否拾起 = true;
			                                所有计时器 = 所有计时器.filter(
			                                    (item) =>
			                                        item.x !== 单元格.关联物品.x || item.y !== 单元格.关联物品.y
			                                );
			                                单元格.关联物品.x = null;
			                                单元格.关联物品.y = null;
			                                添加日志("炸弹已被熄灭！", "信息");
			                            }
			                        } else if (
			                            单元格.关联物品 instanceof 火焰物品
			                        ) {
			                            单元格.关联物品 = null;
			                            if (单元格.类型 === 单元格类型.物品)
			                                单元格.类型 = null;
			                            单元格.颜色索引 = 颜色表.length;
			                        }
			                    }
			                }
			            }
			        }
			
			        影响格子分层.forEach((层内格子, 层级) => {
			            if (层内格子.length > 0) {
			                setTimeout(() => {
			                    计划显示格子特效(层内格子, "ADD8E6", 0);
			                }, 层级 * 80);
			            }
			        });
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set(
			            "冷却剩余",
			            this.最终冷却回合
			        );
			
			        if (击中怪物.size > 0) {
			            显示通知(
			                `${this.名称} 释放了冰霜！击中 ${
			                    击中怪物.size
			                } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
			                "成功"
			            );
			            const 所有击中怪物 = Array.from(击中怪物);
			
			            if (总有效伤害 > 0) {
			                this.触发通用附魔(所有击中怪物);
			            }
			        } else {
			            显示通知(`${this.名称} 释放了冰霜！`, "信息");
			        }
			        绘制();
			        更新装备显示();
			        return 总有效伤害;
			    }
			
			    触发通用附魔(目标怪物列表) {
			        if (
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "火焰附魔")?.等级
			        ) {
			            const 火焰等级 = this.自定义数据
			                .get("附魔")
			                .find((item) => item.种类 === "火焰附魔").等级;
			            目标怪物列表.forEach((怪物) => {
			                if (怪物.当前生命值 > 0) {
			                    new 状态效果(
			                        "火焰",
			                        "#CC5500",
			                        "火",
			                        火焰等级,
			                        null,
			                        null,
			                        怪物
			                    );
			                }
			            });
			        }
			        const 连锁附魔 = this.自定义数据
			            .get("附魔")
			            ?.find((item) => item.种类 === "连锁附魔");
			        if (连锁附魔) {
			            const 连锁距离 = 连锁附魔.等级;
			            目标怪物列表.forEach((初始目标) => {
			                if (初始目标.当前生命值 > 0) {
			                    this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
			                }
			            });
			        }
			    }
			
			    获取提示() {
			        let lines = super.获取提示().split("\n");
			        const specificEffectLines = [
			            `冻结几率：${(
			                this.自定义数据.get("冻结几率") * 100
			            ).toFixed(0)}% (${this.自定义数据.get(
			                "冻结回合"
			            )}回合)`,
			        ];
			
			        const effectDescIndex = lines.findIndex((line) =>
			            line.startsWith("效果描述：")
			        );
			        let insertAtIndex =
			            effectDescIndex !== -1
			                ? effectDescIndex + 1
			                : lines.findIndex((line) =>
			                      line.startsWith("--- 强化效果 ---")
			                  );
			        if (insertAtIndex === -1) insertAtIndex = lines.length;
			
			        lines.splice(insertAtIndex, 0, ...specificEffectLines);
			        return lines.filter(Boolean).join("\n");
			    }
			}
			class 荆棘种子 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "种子",
			            名称: "荆棘种子",
			            图标: 图标映射.种子,
			            品质: 1,
			            颜色索引: 0, // 绿色系
			            堆叠数量: 配置.数量 || Math.ceil(prng() * 5),
			            最大堆叠数量: 16,
			            效果描述:
			                "在相邻空格子播种，生成持续数回合的荆棘丛，可以用互动键收回。",
			            强化: 配置.强化 || false, // 强化可能增加荆棘伤害或持续时间
			            数据: {
			                荆棘持续时间: 5 + (配置.强化 ? 3 : 0),
			                荆棘伤害: 3 + (配置.强化 ? 2 : 0),
			                减速概率: 0.6 + (配置.强化 ? 0.1 : 0),
			                减速回合: 7,
			                ...配置.数据,
			            },
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (this.堆叠数量 <= 0) return false;
			
			        const 方向数组 = [
			            { dx: 0, dy: 0 },
			            { dx: 0, dy: -1 },
			            { dx: 1, dy: 0 },
			            { dx: 0, dy: 1 },
			            { dx: -1, dy: 0 },
			        ];
			        let 放置成功 = false;
			        let 目标X = -1,
			            目标Y = -1;
			
			        // 查找玩家周围可放置的格子
			        for (const { dx, dy } of 方向数组) {
			            const 检查X = 玩家.x + dx;
			            const 检查Y = 玩家.y + dy;
			            if (
			                (检查X >= 0 &&
			                    检查X < 地牢大小 &&
			                    检查Y >= 0 &&
			                    检查Y < 地牢大小 &&
			                    位置是否可用(检查X, 检查Y, false)) ||
			                !检查直线移动可行性(
			                    玩家.x,
			                    玩家.y,
			                    检查X,
			                    检查Y,
			                    true
			                )
			            ) {
			                // 检查格子是否为空地
			                目标X = 检查X;
			                目标Y = 检查Y;
			                放置成功 = true;
			                break; // 找到第一个可用格子就放置
			            }
			        }
			
			        if (!放置成功) {
			            显示通知("周围没有合适的地方播种！", "错误");
			            return false;
			        }
			
			        // 创建荆棘丛实例
			        const 荆棘丛实例 = new 荆棘丛({
			            倒计时: this.自定义数据.get("荆棘持续时间"),
			            爆炸时间: this.自定义数据.get("荆棘持续时间"), // 复用
			            伤害: this.自定义数据.get("荆棘伤害"),
			            减速概率: this.自定义数据.get("减速概率"),
			            减速回合: this.自定义数据.get("减速回合"),
			            强化: this.强化, // 传递强化状态给荆棘丛
			        });
			
			        // 放置荆棘丛到地牢
			        if (放置物品到单元格(荆棘丛实例, 目标X, 目标Y)) {
			            荆棘丛实例.x = 目标X; // 确保实例有坐标
			            荆棘丛实例.y = 目标Y;
			            所有计时器.push(荆棘丛实例); // 加入计时器列表使其能自动消失
			            显示通知(
			                `在 (${目标X}, ${目标Y}) 种下了荆棘丛！`,
			                "成功"
			            );
			
			            // 消耗种子
			            this.堆叠数量 -= 1;
			
			            计划显示格子特效([{ x: 目标X, y: 目标Y }], "228B22"); // 深绿色特效
			            return true;
			        } else {
			            显示通知("无法放置荆棘丛！", "错误");
			            return false;
			        }
			    }
			
			    获取提示() {
			        return [
			            `${this.获取名称()} `,
			            `类型：${this.类型}`,
			            `品质：${"★".repeat(this.品质)}`,
			            `材质：${this.材质}`,
			            `堆叠：${this.堆叠数量} / ${this.最大堆叠数量}`,
			            `效果：${this.效果描述}`,
			            `荆棘持续：${this.自定义数据.get("荆棘持续时间")} 回合`,
			            `进入伤害：${this.自定义数据.get("荆棘伤害")} 点`,
			            `减速几率：${(
			                this.自定义数据.get("减速概率") * 100
			            ).toFixed(0)}% (${this.自定义数据.get(
			                "减速回合"
			            )}回合)`,
			        ].join("\n");
			    }
			}
			
			class 荆棘丛 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形", // 标记为地形，不可交互
			            名称: "荆棘丛",
			            图标: 图标映射.荆棘丛, // 仙人掌图标
			            品质: 1,
			            颜色索引: 0,
			            最大堆叠数量: 1,
			            能否拾起: false,
			            阻碍怪物: false, // 不阻挡移动
			            是否正常物品: false,
			            是否为隐藏物品: false, // 地图上可见
			            效果描述: "进入时会受到伤害并可能减速。",
			            数据: {
			                倒计时: 配置.倒计时 ?? 7,
			                爆炸时间: 配置.倒计时 ?? 7, // 复用计时器接口
			                伤害: 配置.伤害 ?? 3,
			                减速概率: 配置.减速概率 ?? 0.3,
			                减速回合: 配置.减速回合 ?? 2,
			                // 可以添加一个 '来源玩家' 标记，避免玩家自己被自己的荆棘伤害？
			            },
			            ...配置,
			        });
			        this.发挥效果 = false;
			    }
			    尝试互动() {
			        if (玩家.x !== this.x || 玩家.y !== this.y) {
			            return false;
			        }
			        if (尝试收集物品(new 荆棘种子({}), true)) {
			            this.移除自身();
			            显示通知("成功回收了荆棘种子！", "成功");
			            return true;
			        } else {
			            显示通知("背包已满，无法回收种子！", "错误");
			            return false;
			        }
			    }
			    使用() {
			        return false;
			    }
			    
			    当被收集(进入者) {
			        const 伤害量 = this.自定义数据.get("伤害");
			        if (进入者 === "玩家" && false) { //废除。
			            伤害玩家(伤害量, this.名称);
			            添加日志("你踩进了荆棘丛！", "错误");
			            // 概率触发减速
			            if (prng() < this.自定义数据.get("减速概率")) {
			                new 状态效果(
			                    "缓慢",
			                    效果颜色编号映射[效果名称编号映射.缓慢],
			                    图标映射.缓慢,
			                    this.自定义数据.get("减速回合"),
			                    null,
			                    null,
			                    null,
			                    1
			                );
			                this.发挥效果 = true;
			                添加日志("你被荆棘缠绕，移动变慢了！", "错误");
			            }
			        }
			        // 注意：怪物的效果在 怪物.处理地形效果 中处理
			
			        return false; // 不可被收集
			    }
			
			    更新倒计时() {
			        const 剩余回合 = this.自定义数据.get("倒计时");
			        if (剩余回合 <= 0 && this.发挥效果) {
			            this.移除自身();
			        } else {
			            this.自定义数据.set("倒计时", 剩余回合 - 1);
			        }
			    }
			
			    移除自身() {
			        if (
			            this.x !== null &&
			            this.y !== null &&
			            地牢[this.y]?.[this.x]?.关联物品 === this
			        ) {
			            地牢[this.y][this.x].关联物品 = null;
			            if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品)
			                地牢[this.y][this.x].类型 = null;
			            地牢[this.y][this.x].颜色索引 = 颜色表.length; // 重置颜色
			        }
			        所有计时器 = 所有计时器.filter((item) => item !== this);
			    }
			
			    获取提示() {
			        return [
			            `${this.获取名称()}`,
			            `类型：${this.类型}`,
			            `剩余时间：${this.自定义数据.get("倒计时")} 回合`,
			            `进入伤害：${this.自定义数据.get("伤害")} 点`,
			            `减速几率：${(
			                this.自定义数据.get("减速概率") * 100
			            ).toFixed(0)}% (${this.自定义数据.get(
			                "减速回合"
			            )}回合)`,
			            `${this.效果描述}`,
			        ].join("\n");
			    }
			}
			
			class 能量熔炉 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "工具",
			            名称: "能量熔炉",
			            图标: 图标映射.能量熔炉,
			            品质: 3,
			            颜色索引: 4,
			            最大堆叠数量: 1,
			            效果描述: "消耗能量，少量修复所有已装备物品的耐久。",
			            强化: 配置.强化 || false, // 强化降低消耗或增加修复量
			            数据: {
			                能量消耗: 90 - (配置.强化 ? 15 : 0),
			                修复比例: 0.1 + (配置.强化 ? 0.05 : 0), // 修复最大耐久的10%，强化+5%
			                固定修复量: 5 + (配置.强化 ? 3 : 0), // 或至少修复5点，强化+3
			            },
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (!扣除能量(this.自定义数据.get("能量消耗"))) {
			            // 调用基类卷轴的能量消耗方法
			            显示通知("能量不足！", "错误");
			            return false;
			        }
			
			        let 修复发生 = false;
			        玩家装备.forEach((装备) => {
			            if (
			                装备.自定义数据?.has("耐久") &&
			                装备.自定义数据?.has("原耐久")
			            ) {
			                const 当前耐久 = 装备.自定义数据.get("耐久");
			                const 最大耐久 = 装备.自定义数据.get("原耐久");
			                if (当前耐久 < 最大耐久) {
			                    const 按比例修复 = Math.ceil(
			                        最大耐久 * this.自定义数据.get("修复比例")
			                    );
			                    const 实际修复量 = Math.max(
			                        this.自定义数据.get("固定修复量"),
			                        按比例修复
			                    );
			                    const 新耐久 = Math.min(
			                        最大耐久,
			                        当前耐久 + 实际修复量
			                    );
			                    if (新耐久 > 当前耐久) {
			                        装备.自定义数据.set("耐久", 新耐久);
			                        修复发生 = true;
			                        添加日志(
			                            `${装备.获取名称()} 被修复了 ${
			                                新耐久 - 当前耐久
			                            } 点耐久。`,
			                            "成功"
			                        );
			                    }
			                }
			            }
			        });
			
			        if (修复发生) {
			            显示通知(`${this.获取名称()} 修复了装备！`, "成功");
			            更新装备显示(); // 更新UI
			        } else {
			            显示通知(
			                `${this.获取名称()} 发动了，但没有装备需要修复。`,
			                "信息"
			            );
			        }
			
			        更新装备显示(); // 更新冷却显示（如果装备栏显示冷却）
			        return true;
			    }
			
			    获取提示() {
			        let 基础提示 = super.获取提示();
			        基础提示 = 基础提示.replace(/堆叠：.*\n/, ""); // 移除堆叠信息
			        const 能量消耗 = this.自定义数据.get("能量消耗");
			        const 修复比例 = (
			            this.自定义数据.get("修复比例") * 100
			        ).toFixed(0);
			        const 固定修复 = this.自定义数据.get("固定修复量");
			
			        return [
			            基础提示,
			            `---`,
			            `能量消耗：${能量消耗}`,
			            `修复效果：恢复最大耐久${修复比例}% (至少${固定修复}点)`,
			        ].join("\n");
			    }
			}
			class 引雷针护符 extends 防御装备类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "引雷针护符",
			            图标: 图标映射.引雷针护符,
			            品质: 2,
			            颜色索引: 3,
			            防御力: 1,
			            耐久: 配置.耐久 || 35 + (配置.强化 ? 10 : 0),
			            原耐久: 配置.原耐久 || 35 + (配置.强化 ? 10 : 0),
			            强化: 配置.强化 || false,
			            不可破坏: false,
			            效果描述: "拦截落雷，可能获得充能或恢复能量。",
			            数据: {
			                充能概率: 0.6 + (配置.强化 ? 0.15 : 0),
			                充能持续时间: 3 + (配置.强化 ? 2 : 0),
			                充能攻击加成值: 2 + (配置.强化 ? 2 : 0),
			                能量恢复量: 15 + (配置.强化 ? 15 : 0),
			            },
			            ...配置,
			        });
			    }
			
			    当被攻击(原始攻击力, 来源 = null) {
			        if (来源 === "雷暴" && this.自定义数据.get("耐久") > 0) {
			            super.当被攻击(原始攻击力, 来源);
			            添加日志(`${this.名称} 吸收了落雷！`, "成功");
			            const 现有效果 = 玩家状态.find(
			                (s) => s.来源 === this && s.类型 === "充能"
			            );
			            if (
			                prng() < this.自定义数据.get("充能概率") &&
			                !现有效果
			            ) {
			                const 持续时间 =
			                    this.自定义数据.get("充能持续时间");
			                const 加成值 =
			                    this.自定义数据.get("充能攻击加成值");
			                const 新效果 = new 状态效果(
			                    "充能",
			                    效果颜色编号映射[效果名称编号映射.充能],
			                    "⚡",
			                    持续时间,
			                    null,
			                    this,
			                    null,
			                    加成值
			                );
			                玩家属性.攻击加成 += 加成值;
			                显示通知(
			                    "你感到了电流的涌动，攻击力提升！",
			                    "成功"
			                );
			            } else {
			                const 恢复量 = this.自定义数据.get("能量恢复量");
			                const 能量条 = document.querySelector(".power-bar");
			                const 当前能量 =
			                    parseFloat(能量条.style.width) || 0;
			                能量条.style.width = `${Math.min(
			                    100,
			                    当前能量 + 恢复量/自定义全局设置.初始能量值*100
			                )}%`;
			                显示通知(
			                    `护符转化雷电，恢复了 ${恢复量} 点能量！`,
			                    "成功"
			                );
			                触发HUD显示();
			            }
			            return 0;
			        }
			        return super.当被攻击(原始攻击力, 来源);
			    }
			    应用效果() {
			        return;
			    }
			    移除效果() {
			        const 加成值 = this.自定义数据.get("充能攻击加成值");
			        const 对应效果 = 玩家状态.find(
			            (s) => s.来源 === this && s.类型 === "充能"
			        );
			        if (对应效果 && 加成值 > 0) {
			            玩家属性.攻击加成 -= 加成值;
			        }
			    }
			
			    获取提示() {
			        let lines = super.获取提示().split("\n");
			        const effectDescIndex = lines.findIndex((line) =>
			            line.startsWith("效果描述：")
			        );
			        if (effectDescIndex !== -1) {
			            lines.splice(effectDescIndex, 1);
			        }
			
			        const 充能概率 = (
			            this.自定义数据.get("充能概率") * 100
			        ).toFixed(0);
			        const 攻击加成 = this.自定义数据.get("充能攻击加成值");
			        const 持续 = this.自定义数据.get("充能持续时间");
			        const 能量恢复 = this.自定义数据.get("能量恢复量");
			        const 当前效果 = 玩家状态.find(
			            (s) => s.来源 === this && s.类型 === "充能"
			        );
			        const 剩余 = 当前效果 ? 当前效果.剩余回合 : 0;
			
			        let 效果详情 = `效果：拦截落雷消耗 1 耐久。\n`;
			        效果详情 += ` ${充能概率}%几率获得[充能](${持续}回合, +${攻击加成}攻击力)。\n`;
			        效果详情 += ` 否则恢复 ${能量恢复} 能量。`;
			        if (剩余 > 0) {
			            效果详情 += `\n 充能剩余：${剩余}回合`;
			        }
			
			        let insertIndex = lines.findIndex((line) =>
			            line.startsWith("--- 强化效果 ---")
			        );
			        if (insertIndex === -1) {
			            insertIndex = lines.findIndex((line) =>
			                line.startsWith("耐久：")
			            );
			        }
			        if (insertIndex === -1) {
			            insertIndex = lines.length;
			        }
			        lines.splice(insertIndex, 0, 效果详情);
			
			        return lines.filter(Boolean).join("\n");
			    }
			}
			class 重力锤 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "重力锤",
			            图标: 图标映射.重力锤,
			            品质: 4,
			            基础攻击力: 12,
			            冷却回合: 11,
			            攻击范围: 3 + (配置.强化 ? 2 : 0),
			            耐久: 配置?.耐久 || 60,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "猛击地面，将范围内的敌人拉向自己，然后造成范围伤害。",
			            攻击目标数: 99,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                伤害范围: 1 + (配置.强化 ? 2 : 0),
			                ...配置.数据,
			            },
			        });
			    }
			
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			
			        const 拉取范围 = this.最终攻击范围;
			        const 伤害范围 = this.自定义数据.get("伤害范围");
			        const 被拉取怪物 = new Set();
			        const 拉取路径可视化 = [];
			
			        for (let dx = -拉取范围; dx <= 拉取范围; dx++) {
			            for (let dy = -拉取范围; dy <= 拉取范围; dy++) {
			                const x = 使用者.x + dx;
			                const y = 使用者.y + dy;
			
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小
			                ) {
			                    const 单元格 = 地牢[y][x];
			                    const 怪物 = 单元格?.关联怪物;
			                    if (
			                        怪物 &&
			                        怪物.当前生命值 > 0 &&
			                        怪物.状态 === 怪物状态.活跃
			                    ) {
			                        let 拉到X = 使用者.x;
			                        let 拉到Y = 使用者.y;
			                        let 最近距离 = Infinity;
			                        let 找到位置 = false;
			                        let 移动路径 = null;
			
			                        for (let pdx = -1; pdx <= 1; pdx++) {
			                            for (let pdy = -1; pdy <= 1; pdy++) {
			                                if (pdx === 0 && pdy === 0)
			                                    continue;
			                                const 目标X = 使用者.x + pdx;
			                                const 目标Y = 使用者.y + pdy;
			                                if (
			                                    目标X >= 0 &&
			                                    目标X < 地牢大小 &&
			                                    目标Y >= 0 &&
			                                    目标Y < 地牢大小 &&
			                                    位置是否可用(
			                                        目标X,
			                                        目标Y,
			                                        true
			                                    ) &&
			                                    检查视线(
			                                        怪物.x,
			                                        怪物.y,
			                                        目标X,
			                                        目标Y,
			                                        拉取范围 + 2
			                                    )
			                                ) {
			                                    const 距离 =
			                                        Math.abs(目标X - 怪物.x) +
			                                        Math.abs(目标Y - 怪物.y);
			                                    if (距离 < 最近距离) {
			                                        const 路径 =
			                                            广度优先搜索路径(
			                                                怪物.x,
			                                                怪物.y,
			                                                目标X,
			                                                目标Y,
			                                                拉取范围 + 2,
			                                                true
			                                            );
			                                        if (
			                                            路径 &&
			                                            路径.length > 1
			                                        ) {
			                                            最近距离 = 距离;
			                                            拉到X = 目标X;
			                                            拉到Y = 目标Y;
			                                            移动路径 = 路径;
			                                            找到位置 = true;
			                                        }
			                                    }
			                                }
			                            }
			                        }
			
			                        if (
			                            找到位置 &&
			                            !(怪物.x === 拉到X && 怪物.y === 拉到Y)
			                        ) {
			                            被拉取怪物.add(怪物);
			                            拉取路径可视化.push(移动路径.slice(1));
			
			                            怪物.恢复背景类型();
			                            怪物.x = 拉到X;
			                            怪物.y = 拉到Y;
			                            怪物.保存新位置类型(拉到X, 拉到Y);
			                            地牢[拉到Y][拉到X].类型 =
			                                单元格类型.怪物;
			                            地牢[拉到Y][拉到X].关联怪物 = 怪物;
			                        }
			                    }
			                }
			            }
			        }
			        if (拉取路径可视化.length <= 0) return 0;
			        拉取路径可视化.forEach((路径, index) => {
			            setTimeout(() => {
			                计划显示格子特效(路径.slice().reverse(), "9400D3");
			            }, index * 50);
			        });
			
			        let 总有效伤害 = 0;
			        const 击中怪物 = new Set();
			        const 伤害格子 = [];
			
			        setTimeout(() => {
			            for (let ddx = -伤害范围; ddx <= 伤害范围; ddx++) {
			                for (let ddy = -伤害范围; ddy <= 伤害范围; ddy++) {
			                    const dmgX = 使用者.x + ddx;
			                    const dmgY = 使用者.y + ddy;
			                    if (
			                        dmgX >= 0 &&
			                        dmgX < 地牢大小 &&
			                        dmgY >= 0 &&
			                        dmgY < 地牢大小
			                    ) {
			                        if (
			                            检查视线(
			                                使用者.x,
			                                使用者.y,
			                                dmgX,
			                                dmgY,
			                                伤害范围 + 1
			                            )
			                        ) {
			                            伤害格子.push({ x: dmgX, y: dmgY });
			                            const 单元格 = 地牢[dmgY][dmgX];
			                            if (
			                                单元格?.关联怪物 &&
			                                单元格.关联怪物.当前生命值 > 0
			                            ) {
			                                const 怪物 = 单元格.关联怪物;
			                                if (!击中怪物.has(怪物)) {
			                                    击中怪物.add(怪物);
			                                    const 原始血量 =
			                                        怪物.当前生命值;
			                                    怪物.受伤(this.攻击力, "玩家");
			                                    const 实际伤害 =
			                                        原始血量 - 怪物.当前生命值;
			                                    if (实际伤害 > 0)
			                                        总有效伤害 += 实际伤害;
			                                }
			                            }
			                        }
			                    }
			                }
			            }
			            setTimeout(() => {
			                计划显示格子特效(伤害格子, "FFA500", 0);
			            }, 拉取路径可视化[0].length * 50);
			
			            this.自定义数据.set(
			                "耐久",
			                (
			                    this.自定义数据.get("耐久") -
			                    this.耐久消耗 * (被拉取怪物.size > 0 ? 1.2 : 1)
			                ).toFixed(1)
			            );
			            if (this.自定义数据.get("耐久") <= 0) {
			                处理销毁物品(this.唯一标识, true);
			                显示通知(`${this.名称} 已损坏！`, "警告");
			            }
			            this.自定义数据.set(
			                "冷却剩余",
			               this.最终冷却回合
			            );
			
			            if (被拉取怪物.size > 0 || 击中怪物.size > 0) {
			                let 消息 = `${this.名称} 发动！`;
			                if (被拉取怪物.size > 0)
			                    消息 += ` 拉近了 ${被拉取怪物.size} 个目标。`;
			                if (击中怪物.size > 0)
			                    消息 += ` 震击了 ${
			                        击中怪物.size
			                    } 个目标，共造成 ${总有效伤害.toFixed(
			                        1
			                    )} 点伤害！`;
			                显示通知(消息, "成功");
			
			                const 所有影响怪物 = Array.from(
			                    new Set([...被拉取怪物, ...击中怪物])
			                );
			
			                if (总有效伤害 > 0) {
			                    this.触发通用附魔(所有影响怪物);
			                }
			            } else {
			                显示通知(
			                    `${this.名称} 发动了，但未影响任何目标。`,
			                    "信息"
			                );
			            }
			
			            更新装备显示();
			            绘制();
			        }, 拉取路径可视化.length * 50 + 100);
			
			        return 1;
			    }
			
			    触发通用附魔(目标怪物列表) {
			        if (
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "火焰附魔")?.等级
			        ) {
			            const 火焰等级 = this.自定义数据
			                .get("附魔")
			                .find((item) => item.种类 === "火焰附魔").等级;
			            目标怪物列表.forEach((怪物) => {
			                if (怪物.当前生命值 > 0) {
			                    new 状态效果(
			                        "火焰",
			                        "#CC5500",
			                        "火",
			                        火焰等级,
			                        null,
			                        null,
			                        怪物
			                    );
			                }
			            });
			        }
			        const 连锁附魔 = this.自定义数据
			            .get("附魔")
			            ?.find((item) => item.种类 === "连锁附魔");
			        if (连锁附魔) {
			            const 连锁距离 = 连锁附魔.等级;
			            目标怪物列表.forEach((初始目标) => {
			                if (初始目标.当前生命值 > 0) {
			                    this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
			                }
			            });
			        }
			    }
			
			    获取提示() {
			        let lines = super.获取提示().split("\n");
			        const specificEffectLines = [
			            `震击范围：周围 ${this.自定义数据.get("伤害范围")} 格`,
			        ];
			        const effectDescIndex = lines.findIndex((line) =>
			            line.startsWith("效果描述：")
			        );
			        let insertAtIndex =
			            effectDescIndex !== -1
			                ? effectDescIndex + 1
			                : lines.findIndex((line) =>
			                      line.startsWith("--- 强化效果 ---")
			                  );
			        if (insertAtIndex === -1) insertAtIndex = lines.length;
			
			        lines.splice(insertAtIndex, 0, ...specificEffectLines);
			        return lines.filter(Boolean).join("\n");
			    }
			}
			class 旋风物品 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "旋风气流",
			            图标: 图标映射.旋风物品,
			            品质: 1,
			            颜色索引: 1,
			            最大堆叠数量: 1,
			            能否拾起: false, // 不能主动拾取
			            阻碍怪物: false, // 怪物可以穿过
			            效果描述: "不稳定的气流，接触会头晕。",
			            数据: {
			                倒计时: 5, // 存在5回合
			                爆炸时间: 5, // 同上，用于计时器
			                眩晕回合: 2,
			            },
			            ...配置, // 允许覆盖默认配置
			        });
			    }
			
			    使用() {
			        return false;
			    }
			
			    触发爆炸() {
			        this.移除自身();
			    }
			
			    当被收集(进入者) {
			        if (进入者 !== "玩家") return;
			        new 状态效果(
			            "眩晕",
			            效果颜色编号映射[效果名称编号映射.眩晕],
			            图标映射.眩晕,
			            this.自定义数据.get("眩晕回合")
			        );
			        return false;
			    }
			
			    移除自身() {
			        // 从地牢格子中移除
			        if (
			            this.x !== null &&
			            this.y !== null &&
			            地牢[this.y]?.[this.x]?.关联物品 === this
			        ) {
			            地牢[this.y][this.x].关联物品 = null;
			            if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品)
			                地牢[this.y][this.x].类型 = null; // 恢复原始格子类型
			        }
			        所有计时器 = 所有计时器.filter((item) => item !== this);
			        绘制(); // 更新画面
			    }
			
			    更新倒计时() {
			        const 剩余回合 = this.自定义数据.get("倒计时");
			        if (剩余回合 <= 0) {
			            // 用 <= 0 更安全
			            this.触发爆炸(); // 时间到，移除物品
			        } else {
			            this.自定义数据.set("倒计时", 剩余回合 - 1);
			        }
			    }
			}
			class 磨刀石 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "工具",
			            名称: "磨刀石",
			            图标: 图标映射.磨刀石,
			            品质: 3,
			            颜色索引: 4, 
			            最大堆叠数量: 1,
			            效果描述: "用于融合，可强化武器。先放磨刀石，再放武器。",
			            数据: {
			                耐久: 5 + (配置.强化 ? 3 : 0),
			                原耐久: 5 + (配置.强化 ? 3 : 0),
			            },
			            ...配置,
			        });
			    }
			    使用() {
			        return false;
			    }
			
			    获取提示() {
			        return `${this.获取名称()}\n类型：${
			this.类型
			        }\n品质：${"★".repeat(
			this.品质
			        )}\n效果：${this.效果描述}\n剩余使用次数：${this.自定义数据.get("耐久")}`;
			    }
			}
			class 刷怪笼 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "刷怪笼",
			            图标: 图标映射.刷怪笼,
			            品质: 4,
			            能否拾起: false,
			            阻碍怪物: true,
			            效果描述: "周期性地生成怪物或物品。",
			            数据: {
			                生成物类名: 配置.数据?.生成物类名 || '怪物',
			                生成间隔: 配置.数据?.生成间隔 || 5,
			                剩余间隔: 配置.数据?.剩余间隔 || 5,
			                生成半径: 配置.数据?.生成半径 || 3,
			                生成数量: 配置.数据?.生成数量 || 1,
			                生成上限: 配置.数据?.生成上限 || 5,
			                是否激活: 配置.数据?.是否激活 !== undefined ? 配置.数据.是否激活 : true,
			                是否生成点燃的炸弹: 配置.数据?.是否生成点燃的炸弹 || false,
			                巡逻方向: 配置.数据?.巡逻方向 || 'E',
			                当前生成物列表: [],
			                ...配置.数据,
			            },
			            ...配置,
			        });
			    }
			
			    更新倒计时() {
			        if (!this.自定义数据.get('是否激活')) return;
			        let 剩余 = this.自定义数据.get('剩余间隔');
			        剩余--;
			        if (剩余 <= 0) {
			this.尝试生成();
			剩余 = this.自定义数据.get('生成间隔');
			        }
			        this.自定义数据.set('剩余间隔', 剩余);
			    }
			
			    尝试生成() {
			        const 已生成列表 = this.自定义数据.get('当前生成物列表') || [];
			        const 存活列表 = 已生成列表.filter(实例 => 
			            (实例 instanceof 怪物 && 所有怪物.includes(实例)) ||
			            (实例 instanceof 物品 && 所有计时器.includes(实例))
			        );
			        this.自定义数据.set('当前生成物列表', 存活列表);
			
			        if (存活列表.length >= this.自定义数据.get('生成上限')) {
			            return;
			        }
			
			        const 数量 = Math.min(this.自定义数据.get('生成上限')-存活列表.length,this.自定义数据.get('生成数量'));
			        for (let i = 0; i < 数量; i++) {
			            const 半径 = this.自定义数据.get('生成半径');
			            let 放置成功 = false;
			            for(let 尝试 = 0; 尝试 < 200; 尝试++){
			                const dx = Math.floor(prng() * (2 * 半径 + 1)) - 半径;
			                const dy = Math.floor(prng() * (2 * 半径 + 1)) - 半径;
			                
			                if (Math.abs(dx) + Math.abs(dy) > 半径) {
			                    continue;
			                }
			
			                const x = this.x + dx;
			                const y = this.y + dy;
			
			                if (位置是否可用(x, y, true)) {
			                    let 实例;
			                    if (this.自定义数据.get('是否生成点燃的炸弹')) {
			                        const 放置炸弹 = new 炸弹({ 能否拾起: false, 来源: '怪物', 颜色索引: 4 });
			                        放置物品到单元格(放置炸弹, x, y);
			                        放置炸弹.使用(false, x, y);
			                    } else {
			                        const 构造器 = window[this.自定义数据.get('生成物类名')];
			                        if (构造器) {
			                            let 怪物配置 = {状态: 怪物状态.活跃};
			                            if (构造器 === 巡逻怪物) {
			                                怪物配置.巡逻方向 = this.自定义数据.get('巡逻方向');
			                            }
			                            实例 = new 构造器(怪物配置);
			                            放置怪物到单元格(实例, x, y);
			                        }
			                    }
			                    if(实例){
			                        存活列表.push(实例);
			                    }
			                    放置成功 = true;
			                    break;
			                }
			            }
			        }
			        this.自定义数据.set('当前生成物列表', 存活列表);
			    }
			}
			
			class 卷轴滚动墙 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "卷轴滚动墙",
			            图标: 图标映射.卷轴滚动墙,
			            品质: 1,
			            颜色索引: 4,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: false,
			            
			            效果描述: "阻挡视线的魔法墙壁，可通过开关控制。",
			            数据: {
			                开关控制: true,
			                ...配置.数据,
			            },
			            ...配置,
			        });
			    }
			    get 阻碍视野() {
			        if (this.自定义数据.get('开关控制')) {
			            return 绿紫开关状态 !== '紫';
			        }
			        return true;
			    }
			    set 阻碍视野(值){}
			}
			class 传送带 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			类型: "地形",
			名称: "传送带",
			图标: '→',
			品质: 2,
			能否拾起: false,
			阻碍怪物: false,
			效果描述: "将物品或生物向指定方向传送。",
			...配置,
			数据: {
			    方向: 配置.数据?.方向 || 上次放置的传送带?.自定义数据.get('方向') || 'E',
			    开关控制: 配置.数据?.开关控制 || 上次放置的传送带?.自定义数据.get('开关控制') || false,
			    开关激发: 配置.数据?.开关激发 || 上次放置的传送带?.自定义数据.get('开关激发') || false,
			    力度: 配置.数据?.力度?? 上次放置的传送带?.自定义数据.get('力度') ?? 1,
			    ...配置.数据,
			},
			
			        });
			        
			    }
			    set 颜色索引(a) {}
			    get 颜色索引() {
			        return this.自定义数据.get('开关控制')?4:this.自定义数据.get('开关激发')?3:2
			    }
			
			    get 图标() {
			        const 方向图标 = { N: '↑', S: '↓', E: '→', W: '←' };
			        return 方向图标[this.自定义数据.get('方向')] || '→';
			    }
			    set 图标(a) {}
			}
			
			class 巡逻怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.巡逻怪物,
			            类型: "巡逻怪物",
			            基础生命值: 40,
			            基础攻击力: 20,
			            掉落概率: 0,
			            ...配置,
			        });
			        
			        this.随机游走 = 配置.随机游走 ?? false;
			        this.随机游走方向 = 配置.随机游走方向 || '';
			        this.巡逻方向 = 配置.巡逻方向 || 'E';
			
			        const canMove = (x, y, dx, dy) => {
			            const newX = x + dx;
			            const newY = y + dy;
			            if (newX < 0 || newX >= 地牢大小 || newY < 0 || newY >= 地牢大小) return false;
			            const targetCell = 地牢[newY]?.[newX];
			            if (!targetCell || [单元格类型.墙壁, 单元格类型.上锁的门].includes(targetCell.背景类型) || (targetCell.关联物品 && targetCell.关联物品.阻碍怪物) || targetCell.关联怪物) {
			                return false;
			            }
			            return 快速检查相邻移动(x, y, newX, newY);
			        };
			
			        if (this.随机游走) {
			            const { x, y } = this;
			            const canGoEast = canMove(x, y, 1, 0);
			            const canGoWest = canMove(x, y, -1, 0);
			            const canGoNorth = canMove(x, y, 0, -1);
			            const canGoSouth = canMove(x, y, 0, 1);
			
			            const horizontalFree = canGoEast && canGoWest;
			            const verticalFree = canGoNorth && canGoSouth;
			
			            if (horizontalFree && verticalFree) {
			                if (prng() < 0.5) {
			                   this.巡逻方向 = prng() < 0.5 ? 'E' : 'W';
			                } else {
			                   this.巡逻方向 = prng() < 0.5 ? 'N' : 'S';
			                }
			            } else if (horizontalFree) {
			                this.巡逻方向 = prng() < 0.5 ? 'E' : 'W';
			            } else if (verticalFree) {
			                this.巡逻方向 = prng() < 0.5 ? 'N' : 'S';
			            } else {
			                const possibleDirections = [];
			                if (canGoEast) possibleDirections.push('E');
			                if (canGoWest) possibleDirections.push('W');
			                if (canGoNorth) possibleDirections.push('N');
			                if (canGoSouth) possibleDirections.push('S');
			                if (possibleDirections.length > 0) {
			                    this.巡逻方向 = possibleDirections[Math.floor(prng() * possibleDirections.length)];
			                }
			            }
			            return;
			        } else if (this.随机游走方向 && this.随机游走方向.length > 0) {
			            const directions = this.随机游走方向.split('');
			            this.巡逻方向 = directions[Math.floor(prng() * directions.length)];
			        }
			    }
			    初始巡逻() {
			        const canMove = (x, y, dx, dy) => {
			            const newX = x + dx;
			            const newY = y + dy;
			            if (newX < 0 || newX >= 地牢大小 || newY < 0 || newY >= 地牢大小) return false;
			            const targetCell = 地牢[newY]?.[newX];
			            if (!targetCell || [单元格类型.墙壁, 单元格类型.上锁的门].includes(targetCell.背景类型) || (targetCell.关联物品 && targetCell.关联物品.阻碍怪物) || targetCell.关联怪物) {
			                return false;
			            }
			            return 快速检查相邻移动(x, y, newX, newY);
			        };
			
			        if (this.随机游走) {
			            const { x, y } = this;
			            const canGoEast = canMove(x, y, 1, 0);
			            const canGoWest = canMove(x, y, -1, 0);
			            const canGoNorth = canMove(x, y, 0, -1);
			            const canGoSouth = canMove(x, y, 0, 1);
			
			            const horizontalFree = canGoEast && canGoWest;
			            const verticalFree = canGoNorth && canGoSouth;
			
			            if (horizontalFree && verticalFree) {
			                if (prng() < 0.5) {
			                   this.巡逻方向 = prng() < 0.5 ? 'E' : 'W';
			                } else {
			                   this.巡逻方向 = prng() < 0.5 ? 'N' : 'S';
			                }
			            } else if (horizontalFree) {
			                this.巡逻方向 = prng() < 0.5 ? 'E' : 'W';
			            } else if (verticalFree) {
			                this.巡逻方向 = prng() < 0.5 ? 'N' : 'S';
			            } else {
			                const possibleDirections = [];
			                if (canGoEast) possibleDirections.push('E');
			                if (canGoWest) possibleDirections.push('W');
			                if (canGoNorth) possibleDirections.push('N');
			                if (canGoSouth) possibleDirections.push('S');
			                if (possibleDirections.length > 0) {
			                    this.巡逻方向 = possibleDirections[Math.floor(prng() * possibleDirections.length)];
			                }
			            }
			            return;
			        } else if (this.随机游走方向 && this.随机游走方向.length > 0) {
			            const directions = this.随机游走方向.split('');
			            this.巡逻方向 = directions[Math.floor(prng() * directions.length)];
			        }
			    }
			
			    尝试移动() {
			        const 旧X = this.x;
			        const 旧Y = this.y;
			        const 我的状态 = 怪物状态表.get(this);
			        if (我的状态) {
			            switch (我的状态.类型) {
			                case "冻结":
			                case "眩晕":
			                case "牵制":
			                    return;
			                case "恐惧":
			                    return;
			            }
			        }
			
			        if (this.受伤冻结回合剩余 > 0) {
			            this.受伤冻结回合剩余--;
			            return;
			        }
			
			        const 方向向量 = { N: {dx: 0, dy: -1}, S: {dx: 0, dy: 1}, E: {dx: 1, dy: 0}, W: {dx: -1, dy: 0} };
			        const 反向 = { N: 'S', S: 'N', E: 'W', W: 'E' };
			
			        const 检查路径是否通畅 = (当前X, 当前Y, 移动DX, 移动DY) => {
			            const 目标X = 当前X + 移动DX;
			            const 目标Y = 当前Y + 移动DY;
			            if (目标X < 0 || 目标X >= 地牢大小 || 目标Y < 0 || 目标Y >= 地牢大小) return false;
			            
			            const 目标单元格 = 地牢[目标Y]?.[目标X];
			            if (!目标单元格 || (目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物) || 目标单元格.关联怪物 ||!this.位置合法(目标X,目标Y)) return false;
			            
			            return 检查移动可行性(当前X, 当前Y, 目标X, 目标Y);
			        };
			
			        let {dx, dy} = 方向向量[this.巡逻方向];
			        let 移动成功 = false;
			
			        for (let i = 0; i < this.移动距离; i++) {
			            if (检查路径是否通畅(this.x, this.y, dx, dy)) {
			                this.恢复背景类型();
			                this.x += dx;
			                this.y += dy;
			                this.保存新位置类型(this.x, this.y);
			                地牢[this.y][this.x].类型 = 单元格类型.怪物;
			                地牢[this.y][this.x].关联怪物 = this;
			                const 开关 = 地牢[this.y][this.x].关联物品;
			                if (开关 && (开关 instanceof 红蓝开关 || 开关 instanceof 绿紫开关)) {
			                    开关.使用();
			                }
			                移动成功 = true;
			            } else {
			                this.巡逻方向 = 反向[this.巡逻方向];
			                let {dx: newDx, dy: newDy} = 方向向量[this.巡逻方向];
			                if (检查路径是否通畅(this.x, this.y, newDx, newDy)) {
			                    dx = newDx;
			                    dy = newDy;
			                    i--;
			                } else {
			                    break;
			                }
			            }
			        }
			
			        if (移动成功) {
			            怪物动画状态.set(this, {
			                旧逻辑X: 旧X, 旧逻辑Y: 旧Y,
			                目标逻辑X: this.x, 目标逻辑Y: this.y,
			                视觉X: 旧X, 视觉Y: 旧Y,
			                动画开始时间: Date.now(), 正在动画: true,
			            });
			        }
			    }
			    尝试攻击() {
			        let 目标 = this.目标;
			        if (!目标) return false;
			        if (怪物状态表.get(this)?.类型 === "冻结") return;
			        const 距离目标 = Math.abs(this.x - 目标.x) + Math.abs(this.y - 目标.y);
			        if (距离目标>this.攻击范围) return;
			        let 攻击方向=方向到向量(this.巡逻方向)
			        if ((Math.sign(目标.x-this.x)!==攻击方向.dx||Math.sign(目标.y-this.y)!==攻击方向.dy)&&(目标.x!==this.x||目标.y!==this.y)) return;
			        this.绘制血条();
			        if (目标.x === 玩家.x && 目标.y === 玩家.y) {
			            伤害玩家(this.攻击力, this);
			            计划显示格子特效([{x:玩家.x,y:玩家.y}])
			        } else if (目标 instanceof 怪物) { 
			             目标.受伤(this.攻击力, this);
			        } else {
			            return false;
			        }
			        
			        
			        return true;
			    }
			}
			
			class 同步怪物 extends 怪物 {
			    constructor(配置 = {}) {
			        super({
			图标: 图标映射.同步怪物,
			类型: "同步怪物",
			基础生命值: 40,
			基础攻击力: 6,
			掉落概率: 0,
			...配置,
			        });
			    }
			
			    尝试移动() {
			        if (this.受伤冻结回合剩余 > 0) {
			this.受伤冻结回合剩余--;
			return;
			        }
			
			        
			const 当前距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			if (当前距离 <= 1) return;
			
			const 移动选项 = [];
			const 方向 = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
			
			for(const {dx, dy} of 方向) {
			    const 新X = this.x + dx;
			    const 新Y = this.y + dy;
			    if(新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;
			    const 新距离 = Math.abs(新X - 玩家.x) + Math.abs(新Y - 玩家.y);
			    const 目标单元格 = 地牢[新Y]?.[新X];
			    if (新距离 < 当前距离 && 目标单元格 && ![单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.背景类型) && !(目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物) && !目标单元格.关联怪物 && 快速检查相邻移动(this.x, this.y, 新X, 新Y)) {
			        移动选项.push({dx, dy, 新距离});
			    }
			}
			
			if (移动选项.length === 0) return;
			
			移动选项.sort((a,b) => a.新距离 - b.新距离);
			const 最佳移动 = 移动选项[0];
			const 旧X = this.x;
			const 旧Y = this.y;
			this.恢复背景类型();
			this.x += 最佳移动.dx;
			this.y += 最佳移动.dy;
			this.保存新位置类型(this.x, this.y);
			地牢[this.y][this.x].类型 = 单元格类型.怪物;
			地牢[this.y][this.x].关联怪物 = this;
			怪物动画状态.set(this, { 旧逻辑X: 旧X, 旧逻辑Y: 旧Y, 目标逻辑X: this.x, 目标逻辑Y: this.y, 视觉X: 旧X, 视觉Y: 旧Y, 动画开始时间: Date.now(), 正在动画: true, });
			
			
			const 开关 = 地牢[this.y][this.x].关联物品;
			if (开关 && (开关 instanceof 红蓝开关 || 开关 instanceof 绿紫开关)) {
			    开关.使用();
			}
			        
			    }
			}
			
			class 急救绷带 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "消耗品",
			            名称: "急救绷带",
			            图标: 图标映射.急救绷带,
			            品质: 2,
			            颜色索引: 0, 
			            堆叠数量: 配置.数量 || 1,
			            最大堆叠数量: 16,
			            效果描述: "恢复大量生命值，并移除中毒和火焰效果。",
			            数据: {
			                恢复量: 40 + (配置.强化 ? 20 : 0),
			            },
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (this.堆叠数量 <= 0) return false;
			
			        const 生命条 = document.querySelector(".health-bar");
			        const 当前宽度 = parseFloat(生命条.style.width) || 0;
			        const 新宽度 = Math.min(100, 当前宽度 + this.自定义数据.get("恢复量"));
			        if (新宽度 > 当前宽度) {
			            生命条.style.width = `${新宽度}%`;
			        }
			        
			        const 待移除状态 = [];
			        玩家状态.forEach(状态 => {
			            if (状态.类型 === '中毒' || 状态.类型 === '火焰') {
			                待移除状态.push(状态);
			            }
			        });
			
			        待移除状态.forEach(状态 => {
			            状态.移除状态();
			        });
			
			        this.堆叠数量--;
			        if (this.堆叠数量 <= 0) {
			            处理销毁物品(this.唯一标识, true);
			        }
			
			        显示通知("你使用了急救绷带！感觉好多了。", "成功");
			        更新背包显示();
			        更新装备显示();
			        触发HUD显示();
			
			        return true;
			    }
			
			    获取提示() {
			        return `${this.获取名称()}\n类型：${this.类型}\n品质：${"★".repeat(
			this.品质
			        )}\n效果：${this.效果描述}\n恢复量：${this.自定义数据.get("恢复量")}点`;
			    }
			}
			
			 class 照明弹光源 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "照明弹光源",
			            图标: 图标映射.照明弹光源,
			            能否拾起: false,
			            是否正常物品: false,
			            是否为隐藏物品: true,
			            阻碍怪物: false,
			            数据: {
			                倒计时: 配置.耐久 || 15,
			                爆炸时间: 配置.耐久 || 15, 
			                光照范围: 6 + (配置.强化 ? 2 : 0),
			            },
			            ...配置,
			        });
			    }
			    更新倒计时() {
			        const 剩余回合 = this.自定义数据.get("倒计时");
			        if (剩余回合 <= 0) {
			            this.移除自身();
			        } else {
			            this.自定义数据.set("倒计时", 剩余回合 - 1);
			        }
			    }
			    移除自身() {
			        if (
			            this.x !== null &&
			            this.y !== null &&
			            地牢[this.y]?.[this.x]?.关联物品 === this
			        ) {
			            地牢[this.y][this.x].关联物品 = null;
			            地牢[this.y][this.x].类型 = null;
			        }
			        所有计时器 = 所有计时器.filter((item) => item !== this);
			        绘制();
			    }
			}
			
			class 照明弹 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "工具",
			            名称: "照明弹",
			            图标: 图标映射.照明弹,
			            品质: 2,
			            颜色索引: 2,
			            最大堆叠数量: 1,
			            效果描述: "使用后点亮大片区域，持续15回合。",
			            数据: {
			                耐久: 3 + (配置.强化 ? 2 : 0), 
			                原耐久: 3 + (配置.强化 ? 2 : 0),
			            },
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (this.自定义数据.get("耐久") <= 0) return false;
			
			        const lightSource = new 照明弹光源({强化: this.强化});
			        lightSource.x = 玩家.x;
			        lightSource.y = 玩家.y;
			        if (!放置物品到单元格(lightSource,玩家.x,玩家.y)) return false;
			        所有计时器.push(lightSource);
			
			        this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			        }
			        更新背包显示();
			        更新装备显示();
			        显示通知("照明弹升空，照亮了周围！", "成功");
			        绘制(); 
			        return true;
			    }
			}
			class 开关脉冲器 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "开关脉冲器",
			            图标: 图标映射.开关脉冲器,
			            品质: 4,
			            能否拾起: false,
			            阻碍怪物: false,
			            效果描述: "监测特定开关状态并周期性地触发脉冲。",
			            ...配置,
			            数据: {
			                监测状态: 配置.监测状态 || 上次放置的开关脉冲器?.自定义数据?.get('监测状态') || '红', 
			                脉冲范围: 配置.脉冲范围 || 上次放置的开关脉冲器?.自定义数据?.get('脉冲范围') || 3,
			                脉冲冷却: 配置.脉冲冷却 || 上次放置的开关脉冲器?.自定义数据?.get('脉冲冷却') || 2,
			                禁用特效: 配置.禁用特效 || 上次放置的开关脉冲器?.自定义数据?.get('禁用特效') || false,
			                脉冲冷却剩余: 0,
			                ...配置.数据,
			            },
			        });
			        this.正在触发 = false
			    }
			
			    更新倒计时() {
			        let 冷却 = this.自定义数据.get('脉冲冷却剩余');
			        if (冷却 > 0) {
			            this.自定义数据.set('脉冲冷却剩余', 冷却 - 1);
			            return;
			        }
			        
			        const 监测状态 = this.自定义数据.get('监测状态');
			        const 当前开关状态 = (监测状态 === '红' || 监测状态 === '蓝') ? 红蓝开关状态 : 绿紫开关状态;
			
			        if (当前开关状态 === 监测状态) {
			            this.触发脉冲();
			            this.自定义数据.set('脉冲冷却剩余', this.自定义数据.get('脉冲冷却'));
			        }
			    }
			
			    触发脉冲() {
			        if(!(地牢[this.y][this.x].关联物品 instanceof 开关脉冲器)) {
			
			            return;
			        }
			        const 监测状态 = this.自定义数据.get('监测状态');
			        const 当前开关状态 = (监测状态 === '红' || 监测状态 === '蓝') ? 红蓝开关状态 : 绿紫开关状态;
			
			        if (当前开关状态 !== 监测状态) {
			            return;
			        }
			        this.正在触发 = true
			        const 范围 = this.自定义数据.get('脉冲范围');
			        const 脉冲格子 = [];
			        const 影响的怪物 = new Set();
			        const 影响的物品 = new Set();
			
			        for (let dy = -范围; dy <= 范围; dy++) {
			            for (let dx = -范围; dx <= 范围; dx++) {
			                const 目标X = this.x + dx;
			                const 目标Y = this.y + dy;
			                if (目标X < 0 || 目标X >= 地牢大小 || 目标Y < 0 || 目标Y >= 地牢大小) continue;
			                
			                脉冲格子.push({x: 目标X, y: 目标Y});
			                if(!this.自定义数据.get("禁用特效")) 计划显示格子特效([{x: 目标X, y: 目标Y}], '00FFFF', 20);
			
			                const 单元格 = 地牢[目标Y]?.[目标X];
			                if (!单元格) continue;
			
			                if (单元格.关联怪物 && 单元格.关联怪物.当前生命值 > 0) {
			                    影响的怪物.add(单元格.关联怪物);
			                }
			                if (单元格.关联物品 && 单元格.关联物品 !== this && !(单元格.关联物品 instanceof 开关脉冲器 && 单元格.关联物品?.正在触发)) {
			                    影响的物品.add(单元格.关联物品);
			                }
			            }
			        }
			
			        
			        
			        const 玩家穿了潜行靴子 = Array.from(玩家装备.values()).some(item => item instanceof 潜行靴子);
			
			        影响的怪物.forEach(m => {
			            if (m.状态 !== 怪物状态.活跃 || m.当前生命值 <= 0) return;
			            if (地牢[m.y]?.[m.x]?.关联物品 instanceof 传送带) return;
			
			            const 原始移动距离 = m.基础移动距离;
			            const 我的状态 = 怪物状态表.get(m);
			            我的状态?.更新状态();
			
			            if (m instanceof 同步怪物 || m instanceof 巡逻怪物) {
			                m.尝试移动();
			                let 目标 = m.选择目标();
			                m.目标 = 目标;
			                m.尝试攻击();
			                return;
			            }
			            if (m.始终追踪玩家) {
			                m.追踪玩家();
			                
			            }
			
			            let 目标 = m.选择目标();
			            m.目标 = 目标;
			            let { x, y } = 目标;
			
			            let 可以追踪 = true;
			            if (玩家穿了潜行靴子 && 我的状态?.类型 !== "魅惑" && 目标 === 玩家) {
			                可以追踪 = 快速直线检查(m.x, m.y, 玩家.x, 玩家.y, m.跟踪距离);
			            }
			
			            const 曼哈顿距离 = Math.abs(m.x - x) + Math.abs(m.y - y);
			            if (可以追踪 && 曼哈顿距离 <= m.跟踪距离) {
			                m.目标路径 = m.计算路径(x, y);
			            } else {
			                m.目标路径 = null;
			            }
			
			            if (m.目标路径) {
			                const 行动次数 = m.本回合行动次数 || 1;
			                for (let i = 0; i < 行动次数; i++) {
			                    
			                        if (m.目标路径.length > 0 && !(m.目标路径.length > 1 && 玩家状态.some(s => s.类型 === "隐身") && 我的状态?.类型 !== "魅惑")) {
			                            if (我的状态?.类型 !== "魅惑") m.追击玩家中 = true;
			                            m.尝试移动();
			                        } else {
			                            m.追击玩家中 = false;
			                        }
			                    
			                    m.通向目标路径 = m.计算目标路径(m.目标.x, m.目标.y);
			                    if (m.通向目标路径 && !(m.通向目标路径.length > 1 && 玩家状态.some(s => s.类型 === "隐身") && 我的状态?.类型 !== "魅惑")) {
			                        m.尝试攻击();
			                    }
			                    if (m.当前生命值 <= 0) break;
			                }
			                if (m?.本回合行动次数 > 1) m.本回合行动次数 = 1;
			            }
			            
			            m.基础移动距离 = 原始移动距离;
			            if (m instanceof 大魔法师) m.更新技能冷却();
			        });
			
			        影响的物品.forEach(物品 => {
			            物品.更新倒计时?.();
			            if (物品 instanceof 红蓝开关 || 物品 instanceof 绿紫开关) {
			            if (!物品.自定义数据.get('隐藏')) 物品.使用()
			            }
			        });
			        this.正在触发 = false
			    }
			}
			class 红蓝开关 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "红蓝开关",
			            图标: 图标映射.红蓝开关,
			            品质: 3,
			            颜色索引: 4,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "激活后，切换所有红色和蓝色方块的状态。",
			            ...配置,
			             数据: {
			                耐久: 配置.数据?.耐久 === undefined ? -1 : 配置.数据.耐久,
			                隐藏: 配置.数据?.隐藏 === undefined ? false : 配置.数据.隐藏,
			                广播距离: 配置.数据?.广播距离 === undefined ? 5 : 配置.数据.广播距离,
			                ...配置.数据,
			            },
			        });
			    }
			    get 颜色索引() {
			        return 红蓝开关状态 === '红' ? 4 : 1
			    }
			    set 颜色索引(a) {}
			
			    尝试互动() {
			        if (玩家.x !== this.x || 玩家.y !== this.y) {
			            return false;
			        }
			        this.使用();
			        return true;
			    }
			
			    使用() {
			        const 耐久 = this.自定义数据.get('耐久');
			        if (耐久 === 0) return true; 
			
			        if (耐久 > 0) {
			            this.自定义数据.set('耐久', 耐久 - 1);
			            if (this.自定义数据.get('耐久') <= 0) {
			                显示通知(`${this.名称} 的能量耗尽了！`, "警告");
			            }
			        }
			
			        红蓝开关状态 = 红蓝开关状态 === '红' ? '蓝' : '红';
			        添加日志(`开关已切换为 ${红蓝开关状态 === '红' ? '红色' : '蓝色'} 状态！`, "信息");
			        const 激活的砖块类型 = 红蓝开关状态 === '红' ? '红砖块' : '蓝砖块';
			
			        const 脉冲器列表 = [];
			        const 传送带列表 = [];
			        for (let y = 0; y < 地牢大小; y++) {
			            for (let x = 0; x < 地牢大小; x++) {
			                const 物品 = 地牢[y]?.[x]?.关联物品;
			                const 单元格 = 地牢[y][x];
			                if (物品 instanceof 开关脉冲器) {
			                    const 距离 = Math.abs(x - this.x) + Math.abs(y - this.y);
			                    脉冲器列表.push({ 实例: 物品, 距离: 距离 });
			                }
			                if (物品 instanceof 传送带) {
			                    传送带列表.push(物品);
			                }
			                if (单元格?.关联物品?.名称 === 激活的砖块类型 && 单元格.关联怪物) {
			                    推开生物(x, y);
			                }
			            }
			        }
			
			        const 按距离分组的脉冲器 = new Map();
			        脉冲器列表.forEach(item => {
			            if (!按距离分组的脉冲器.has(item.距离)) {
			                按距离分组的脉冲器.set(item.距离, []);
			            }
			            按距离分组的脉冲器.get(item.距离).push(item.实例);
			        });
			
			        const 排序后的距离 = Array.from(按距离分组的脉冲器.keys()).sort((a, b) => a - b);
			
			        排序后的距离.forEach((距离, 索引) => {
			            if (距离 > this.自定义数据.get('广播距离')) return;
			            const 脉冲器组 = 按距离分组的脉冲器.get(距离);
			            脉冲器组.forEach(脉冲器 => {if(!脉冲器.正在触发) 脉冲器.触发脉冲()});
			            
			        });
			        
			        
			
			    for (const 带 of 传送带列表) {
			        const 单元格 = 地牢[带.y]?.[带.x];
			
			            let 移动方向 = 带.自定义数据.get('方向');
			            
			            if (带.自定义数据.get('开关控制')) {
			                
			                    const 反向 = { N: 'S', S: 'N', E: 'W', W: 'E' };
			                    带.自定义数据.set('方向',反向[移动方向]);
			                }
			    }
			        return true;
			    }
			     get 是否为隐藏物品() {
			        return this.自定义数据.get('隐藏');
			    }
			    set 是否为隐藏物品(值) {
			         this.自定义数据.set('隐藏', 值);
			    }
			}
			class 绿紫开关 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "绿紫开关",
			            图标: 图标映射.绿紫开关,
			            品质: 3,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "激活后，切换所有绿色和紫色方块的状态。",
			            ...配置,
			            数据: {
			                耐久: 配置.数据?.耐久 === undefined ? -1 : 配置.数据.耐久,
			                隐藏: 配置.数据?.隐藏 === undefined ? false : 配置.数据.隐藏,
			                广播距离: 配置.数据?.广播距离 === undefined ? 5 : 配置.数据.广播距离,
			                ...配置.数据,
			            },
			        });
			    }
			    get 颜色索引() {
			        return 绿紫开关状态 === '绿' ? 0 : 5
			    }
			    set 颜色索引(a) {}
			    
			    尝试互动() {
			        if (玩家.x !== this.x || 玩家.y !== this.y) {
			            return false;
			        }
			        this.使用();
			        return true;
			    }
			    使用() {
			        const 耐久 = this.自定义数据.get('耐久');
			        if (耐久 === 0) return true;
			
			        if (耐久 > 0) {
			            this.自定义数据.set('耐久', 耐久 - 1);
			             if (this.自定义数据.get('耐久') <= 0) {
			                显示通知(`${this.名称} 的能量耗尽了！`, "警告");
			            }
			        }
			        绿紫开关状态 = 绿紫开关状态 === '绿' ? '紫' : '绿';
			        添加日志(`开关已切换为 ${绿紫开关状态 === '绿' ? '绿色' : '紫色'} 状态！`, "信息");
			        
			
			        const 脉冲器列表 = [];
			        const 激活的砖块类型 = 绿紫开关状态 === '绿' ? '绿砖块' : '紫砖块';
			        for (let y = 0; y < 地牢大小; y++) {
			            for (let x = 0; x < 地牢大小; x++) {
			                const 物品 = 地牢[y]?.[x]?.关联物品;
			                const 单元格 = 地牢[y][x];
			                if (物品 instanceof 开关脉冲器) {
			                    const 距离 = Math.abs(x - this.x) + Math.abs(y - this.y);
			                    脉冲器列表.push({ 实例: 物品, 距离: 距离 });
			                } else if (物品 instanceof 绿紫开关 && 物品.图标 !== "切"){
			                    物品.图标=绿紫开关状态 === '绿' ? "🟢":"🟣"
			                } else if (单元格?.关联物品?.名称 === 激活的砖块类型 && 单元格.关联怪物) {
			                    推开生物(x, y);
			                } else if (物品 instanceof 卷轴滚动墙 && 物品.图标 !== "停"){
			                    物品.图标=绿紫开关状态 === '绿' ? "🚫":""
			                }
			            }
			        }
			
			        const 按距离分组的脉冲器 = new Map();
			        脉冲器列表.forEach(item => {
			            if (!按距离分组的脉冲器.has(item.距离)) {
			                按距离分组的脉冲器.set(item.距离, []);
			            }
			            按距离分组的脉冲器.get(item.距离).push(item.实例);
			        });
			
			        const 排序后的距离 = Array.from(按距离分组的脉冲器.keys()).sort((a, b) => a - b);
			
			        排序后的距离.forEach((距离, 索引) => {
			            if (距离 > this.自定义数据.get('广播距离')) return;
			            const 脉冲器组 = 按距离分组的脉冲器.get(距离);
			            脉冲器组.forEach(脉冲器 => {if(!脉冲器.正在触发) 脉冲器.触发脉冲()});
			            
			        });
			
			        更新视口()
			        return true;
			    }
			     get 是否为隐藏物品() {
			        return this.自定义数据.get('隐藏');
			    }
			    set 是否为隐藏物品(值) {
			         this.自定义数据.set('隐藏', 值);
			    }
			}
			
			class 红砖块 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "开关砖",
			            名称: "红砖块",
			            图标: 图标映射.红砖块,
			            品质: 1,
			            颜色索引: 4,
			            能否拾起: false,
			            是否正常物品: false,
			            ...配置,
			        });
			    }
			    
			    get 阻碍怪物() {
			        return 红蓝开关状态 === '红';
			    }
			    
			    get 是否为隐藏物品() {
			        return 红蓝开关状态 !== '红';
			    }
			    set 阻碍怪物(a) {}
			    set 是否为隐藏物品(a){}
			
			    当被收集(进入者) {
			        return false;
			    }
			}
			
			class 蓝砖块 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "开关砖",
			            名称: "蓝砖块",
			            图标: 图标映射.蓝砖块,
			            品质: 1,
			            颜色索引: 1,
			            能否拾起: false,
			            是否正常物品: false,
			            ...配置,
			        });
			    }
			
			    get 阻碍怪物() {
			        return 红蓝开关状态 === '蓝';
			    }
			    
			    get 是否为隐藏物品() {
			        return 红蓝开关状态 !== '蓝';
			    }
			    
			    set 阻碍怪物(a) {}
			    set 是否为隐藏物品(a){}
			
			    当被收集(进入者) {
			        return false;
			    }
			}
			class 绿砖块 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			类型: "开关砖",
			名称: "绿砖块",
			图标: 图标映射.绿砖块,
			品质: 1,
			颜色索引: 0,
			能否拾起: false,
			是否正常物品: false,
			...配置,
			        });
			    }
			
			    get 阻碍怪物() {
			        return 绿紫开关状态 === '绿';
			    }
			    
			    get 是否为隐藏物品() {
			        return 绿紫开关状态 !== '绿';
			    }
			    set 阻碍怪物(a) {}
			    set 是否为隐藏物品(a){}
			
			    当被收集(进入者) {
			        return false;
			    }
			}
			
			class 紫砖块 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			类型: "开关砖",
			名称: "紫砖块",
			图标: 图标映射.紫砖块,
			品质: 1,
			颜色索引: 3,
			能否拾起: false,
			是否正常物品: false,
			...配置,
			        });
			    }
			
			    get 阻碍怪物() {
			        return 绿紫开关状态 === '紫';
			    }
			    
			    get 是否为隐藏物品() {
			        return 绿紫开关状态 !== '紫';
			    }
			    set 阻碍怪物(a) {}
			    set 是否为隐藏物品(a){}
			
			    当被收集(进入者) {
			        return false;
			    }
			}
			class 挑战石碑 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "挑战石碑",
			            图标: 图标映射.挑战石碑,
			            品质: 4,
			            颜色索引: 3,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: true,
			            效果描述: "一座古老的石碑，散发着不祥的气息。互动以开始生存挑战。",
			            数据: {
			                已激活: false,
			                当前波数: 0,
			                自定义奖励: [],
			            },
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        if (生存挑战激活) {
			            显示通知("已有挑战正在进行！", "错误");
			            return false;
			        }
			
			        if (this.自定义数据.get("已激活")) {
			            显示通知("石碑上的能量已经平息。", "信息");
			            return false;
			        }
			
			        显示自定义确认对话框(
			            "你确定要激活石碑，开始无尽的生存挑战吗？挑战将在你倒下时结束。",
			            () => this.开始生存挑战()
			        );
			
			        return true;
			    }
			
			    开始生存挑战() {
			        if (生存挑战激活) return; 
			
			        const 当前房间ID = 房间地图[this.y]?.[this.x];
			        if (当前房间ID === -1 || 当前房间ID === undefined) {
			            显示通知("石碑未在有效房间内，无法开始挑战。", "错误");
			            return;
			        }
			        const 房间实例 = 房间列表.find(t=>t.id==当前房间ID);
			
			        生存挑战激活 = true;
			        生存挑战备份单元格 = [];
			        this.自定义数据.set("已激活", true);
			        this.自定义数据.set("当前波数", 0);
			        房间实例.isSurvivalChallenge = true; 
			        房间实例.survivalWave = 0; 
			
			        const 挑战半径 = 25;
			        const 中心X = this.x;
			        const 中心Y = this.y;
			
			        for (let y = 中心Y - 挑战半径; y <= 中心Y + 挑战半径; y++) {
			            for (let x = 中心X - 挑战半径; x <= 中心X + 挑战半径; x++) {
			                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
			                
			                const 距离 = Math.sqrt(Math.pow(x - 中心X, 2) + Math.pow(y - 中心Y, 2));
			
			                if (Math.abs(距离 - 挑战半径) < 1) { 
			                    const 原始单元格 = 地牢[y][x];
			                    生存挑战备份单元格.push({
			                        x: x,
			                        y: y,
			                        类型: 原始单元格.类型,
			                        背景类型: 原始单元格.背景类型,
			                        墙壁: { ...原始单元格.墙壁 },
			                        关联物品: 原始单元格.关联物品,
			                        关联怪物: 原始单元格.关联怪物,
			                        颜色索引: 原始单元格.颜色索引,
			                        标识: 原始单元格.标识,
			                    });
			
			                    原始单元格.类型 = 单元格类型.墙壁;
			                    原始单元格.背景类型 = 单元格类型.墙壁;
			                    原始单元格.关联物品 = null;
			                    原始单元格.关联怪物 = null;
			                }
			            }
			        }
			
			        生成墙壁();
			        绘制();
			        
			        显示通知("挑战结界已升起！", "警告", true);
			        this.刷新生存挑战下一波(房间实例);
			    }
			    
			    刷新生存挑战下一波(房间实例) {
			        if (!this.自定义数据.get("已激活")) return;
			
			        this.自定义数据.set("当前波数", this.自定义数据.get("当前波数") + 1);
			        房间实例.survivalWave = this.自定义数据.get("当前波数");
			
			        const 波数 = this.自定义数据.get("当前波数");
			        显示通知(`第 ${波数} 波开始！`, "警告");
			        
			        const 怪物数量 = Math.min(8, 1 + Math.floor(波数 / 2));
			        const 强化概率 = Math.min(0.8, 0.1 + 波数 * 0.05);

			        const 挑战怪物池 = [];
			        const 怪物层级 = 当前层数 === -1 ? 999 : 当前层数;
			        for (let i = 0; i <= 怪物层级; i++) {
			            if (怪物引入计划.has(i)) {
			                怪物引入计划.get(i).forEach(怪物定义 => {
			                    if (!挑战怪物池.some(m => m.类.name === 怪物定义.类.name)) {
			                        挑战怪物池.push(怪物定义);
			                    }
			                });
			            }
			        }
			        const 候选怪物 = 挑战怪物池.filter(m => m.类.name !== '蜈蚣怪物' && m.类.name !== '巨人怪物');
			
			        if(候选怪物.length === 0) return;
			
			        for(let i=0; i<怪物数量; i++) {
			            const 选中配置 = 候选怪物[Math.floor(prng() * 候选怪物.length)];
			            const 新怪物 = new 选中配置.类({强化: prng() < 强化概率, 状态: 怪物状态.活跃});
			            放置怪物到房间(新怪物, 房间实例);
			        }
			    }
			
			    发放奖励(波数) {
			        const 房间实例 = 房间列表.find(t=>t.id==房间地图[this.y][this.x]);
			        if (!房间实例) return;
			    
			        const 自定义奖励 = this.自定义数据.get('自定义奖励');
			        if (自定义奖励 && 自定义奖励.length > 0) {
			            自定义奖励.forEach(奖励配置 => {
			                const 奖励类 = window[奖励配置.类名];
			                if (奖励类) {
			                    const 新物品 = new 奖励类(奖励配置.配置 || {});
			                    放置物品到房间(新物品, 房间实例, 单元格类型.物品, false, true);
			                }
			            });
			            显示通知(`挑战结束！你坚持了 ${波数} 波，获得了预设的奖励！`, "成功");
			        } else {
			            const 奖励等级 = Math.floor(波数 / 5);
			            const 奖励数量 = 1 + 奖励等级;
			    
			            for (let i = 0; i < 奖励数量; i++) {
			                const 品质 = Math.min(5, 2 + 奖励等级);
			                const 可用物品 = Object.values(物品池).flat().filter(item => item.品质 >= 品质-1 && item.品质 <= 品质 && new item.类({}).是否正常物品);
			                if (可用物品.length > 0) {
			                        const 选中配置 = 可用物品[Math.floor(prng() * 可用物品.length)];
			                        const 新物品 = new 选中配置.类({强化: true, 已解锁: true});
			                        放置物品到房间(新物品, 房间实例, 单元格类型.物品, false, true);
			                }
			            }
			            显示通知(`挑战结束！你坚持了 ${波数} 波，获得了随机奖励！`, "成功");
			        }
			    }
			}
			class 剧毒匕首 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "剧毒匕首",
			            图标: 图标映射.剧毒匕首,
			            品质: 1,
			            基础攻击力: 3,
			            冷却回合: 2,
			            攻击范围: 1,
			            耐久: 配置?.耐久 || 90,
			            强化: 配置?.强化 || false,
			            效果描述: "攻击附加可叠加的中毒效果，持续造成伤害。",
			            攻击目标数: 1,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                中毒强度: 2 + (配置?.强化 ? 1 : 0),
			                中毒持续时间: 5,
			                ...配置.数据,
			            },
			        });
			    }
			
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0 ||
			            !(目标怪物列表?.length>0)
			        )
			            return 0;
			
			        const 目标怪物 = 目标怪物列表[0];
			        if (!目标怪物 || 目标怪物.当前生命值 <= 0) return 0;
			
			        let 总有效伤害 = 0;
			        const 原始血量 = 目标怪物.当前生命值;
			        目标怪物.受伤(this.攻击力, "玩家");
			        const 实际伤害 = 原始血量 - 目标怪物.当前生命值;
			        if (实际伤害 > 0) 总有效伤害 += 实际伤害;
			
			        if (目标怪物.当前生命值 > 0) {
			            new 状态效果(
			                "中毒",
			                效果颜色编号映射[效果名称编号映射.中毒],
			                "☠️",
			                this.自定义数据.get("中毒持续时间"),
			                null,
			                null,
			                目标怪物,
			                this.自定义数据.get("中毒强度")
			            );
			            添加日志(`${目标怪物.类型} 中毒了！`, "警告");
			        }
			
			        const 攻击路径 = 广度优先搜索路径(
			            使用者.x,
			            使用者.y,
			            目标怪物.x,
			            目标怪物.y,
			            this.最终攻击范围,
			            true
			        );
			        if (攻击路径 && 攻击路径.length > 1) {
			            计划显示格子特效(攻击路径.slice(1), "008000");
			        }
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set(
			            "冷却剩余",
			            this.最终冷却回合
			        );
			
			        let 消息 = `${this.名称} 造成 ${总有效伤害.toFixed(
			            1
			        )} 点伤害`;
			        if (
			            目标怪物.当前生命值 > 0 &&
			            怪物状态表.get(目标怪物)?.类型 === "中毒"
			        ) {
			            消息 += ` 并附加了中毒效果！`;
			        } else {
			            消息 += `！`;
			        }
			        显示通知(消息, "成功");
			
			        if (总有效伤害 > 0) {
			            this.触发通用附魔([目标怪物]);
			        }
			
			        更新装备显示();
			        return 总有效伤害;
			    }
			
			    触发通用附魔(目标怪物列表) {
			        if (
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "火焰附魔")?.等级
			        ) {
			            const 火焰等级 = this.自定义数据
			                .get("附魔")
			                .find((item) => item.种类 === "火焰附魔").等级;
			            目标怪物列表.forEach((怪物) => {
			                if (怪物.当前生命值 > 0) {
			                    new 状态效果(
			                        "火焰",
			                        "#CC5500",
			                        "火",
			                        火焰等级,
			                        null,
			                        null,
			                        怪物
			                    );
			                }
			            });
			        }
			        const 连锁附魔 = this.自定义数据
			            .get("附魔")
			            ?.find((item) => item.种类 === "连锁附魔");
			        if (连锁附魔) {
			            const 连锁距离 = 连锁附魔.等级;
			            目标怪物列表.forEach((初始目标) => {
			                if (初始目标.当前生命值 > 0) {
			                    this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
			                }
			            });
			        }
			    }
			
			    获取提示() {
			        let lines = super.获取提示().split("\n");
			        const specificEffectLines = [
			            `毒性：${this.自定义数据.get("中毒强度")}点/回合`,
			            `持续：${this.自定义数据.get("中毒持续时间")}回合`,
			        ];
			        const effectDescIndex = lines.findIndex((line) =>
			            line.startsWith("效果描述：")
			        );
			        let insertAtIndex =
			            effectDescIndex !== -1
			                ? effectDescIndex + 1
			                : lines.findIndex((line) =>
			                      line.startsWith("--- 强化效果 ---")
			                  );
			        if (insertAtIndex === -1) insertAtIndex = lines.length;
			
			        lines.splice(insertAtIndex, 0, ...specificEffectLines);
			        return lines.filter(Boolean).join("\n");
			    }
			}
			
			class 荆棘鞭 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "荆棘鞭",
			            图标: 图标映射.荆棘鞭,
			            品质: 1,
			            基础攻击力: 2,
			            冷却回合: 3,
			            攻击范围: 2,
			            耐久: 配置?.耐久 || 70,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "甩出长鞭，将近处的单个敌人直线甩飞并造成少量伤害。",
			            攻击目标数: 1,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                甩飞距离: 3 + (配置?.强化 ? 1 : 0),
			                ...配置.数据,
			            },
			        });
			    }
			
			    计算最大甩飞距离(起始X, 起始Y, 方向DX, 方向DY, 最大距离) {
			        let 可行终点 = { x: 起始X, y: 起始Y };
			        for (let i = 1; i <= 最大距离; i++) {
			            const 尝试X = 起始X + 方向DX * i;
			            const 尝试Y = 起始Y + 方向DY * i;
			
			            if (
			                尝试X < 0 ||
			                尝试X >= 地牢大小 ||
			                尝试Y < 0 ||
			                尝试Y >= 地牢大小
			            )
			                break;
			            if (!快速直线检查(起始X, 起始Y, 尝试X, 尝试Y, i)) break;
			            if (位置是否可用(尝试X, 尝试Y, true)) {
			                可行终点 = { x: 尝试X, y: 尝试Y };
			            }
			        }
			        return 可行终点;
			    }
			
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			
			        if (!目标怪物列表 || 目标怪物列表.length === 0) {
			            显示通知("附近没有可甩飞的目标！", "警告");
			            return 0;
			        }
			
			        const 目标怪物 = 目标怪物列表[0];
			        if (目标怪物.当前生命值 <= 0) return 0;
			
			        const 路径 = 获取直线路径(
			            使用者.x,
			            使用者.y,
			            目标怪物.x,
			            目标怪物.y
			        );
			        if (
			            路径.length === 0 ||
			            路径.length > this.最终攻击范围 + 1
			        ) {
			            显示通知("目标太远或路径被阻挡！", "警告");
			            return 0;
			        }
			
			        const dx = 目标怪物.x - 使用者.x;
			        const dy = 目标怪物.y - 使用者.y;
			        const 甩飞距离 = this.自定义数据.get("甩飞距离");
			        let 最终X = 目标怪物.x;
			        let 最终Y = 目标怪物.y;
			        let 选择方向DX = 0;
			        let 选择方向DY = 0;
			
			        if (dx === 0) {
			            选择方向DY = dy > 0 ? 1 : -1;
			        } else if (dy === 0) {
			            选择方向DX = dx > 0 ? 1 : -1;
			        } else {
			            const 水平方向DX = dx > 0 ? 1 : -1;
			            const 水平终点 = this.计算最大甩飞距离(
			                目标怪物.x,
			                目标怪物.y,
			                水平方向DX,
			                0,
			                甩飞距离
			            );
			            const 水平距离使用者 =
			                Math.abs(水平终点.x - 使用者.x) +
			                Math.abs(水平终点.y - 使用者.y);
			
			            const 垂直方向DY = dy > 0 ? 1 : -1;
			            const 垂直终点 = this.计算最大甩飞距离(
			                目标怪物.x,
			                目标怪物.y,
			                0,
			                垂直方向DY,
			                甩飞距离
			            );
			            const 垂直距离使用者 =
			                Math.abs(垂直终点.x - 使用者.x) +
			                Math.abs(垂直终点.y - 使用者.y);
			
			            if (水平距离使用者 >= 垂直距离使用者) {
			                选择方向DX = 水平方向DX;
			                选择方向DY = 0;
			            } else {
			                选择方向DX = 0;
			                选择方向DY = 垂直方向DY;
			            }
			        }
			
			        const 最终落点 = this.计算最大甩飞距离(
			            目标怪物.x,
			            目标怪物.y,
			            选择方向DX,
			            选择方向DY,
			            甩飞距离
			        );
			        最终X = 最终落点.x;
			        最终Y = 最终落点.y;
			
			        let 总有效伤害 = 0;
			        const 原始血量 = 目标怪物.当前生命值;
			        目标怪物.受伤(this.攻击力, "玩家");
			
			        const 实际伤害 = 原始血量 - 目标怪物.当前生命值;
			        if (实际伤害 > 0) 总有效伤害 += 实际伤害;
			        if (目标怪物.当前生命值 <= 0) return 总有效伤害;
			
			        if (最终X !== 目标怪物.x || 最终Y !== 目标怪物.y) {
			            目标怪物.恢复背景类型();
			            目标怪物.x = 最终X;
			            目标怪物.y = 最终Y;
			            目标怪物.保存新位置类型(最终X, 最终Y);
			            地牢[最终Y][最终X].类型 = 单元格类型.怪物;
			            地牢[最终Y][最终X].关联怪物 = 目标怪物;
			            目标怪物.处理地形效果();
			            目标怪物.绘制血条();
			            绘制();
			            显示通知(
			                `${this.名称} 将 ${
			                    目标怪物.类型
			                } 甩飞了，造成 ${总有效伤害.toFixed(1)} 点伤害！`,
			                "成功"
			            );
			        } else {
			            显示通知(
			                `${this.名称} 击中了 ${
			                    目标怪物.类型
			                } 但未能将其甩飞，造成 ${总有效伤害.toFixed(
			                    1
			                )} 点伤害！`,
			                "信息"
			            );
			        }
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set(
			            "冷却剩余",
			            this.最终冷却回合
			        );
			
			        if (总有效伤害 > 0) {
			            this.触发通用附魔([目标怪物]);
			        }
			
			        更新装备显示();
			        return 总有效伤害;
			    }
			
			    触发通用附魔(目标怪物列表) {
			        if (
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "火焰附魔")?.等级
			        ) {
			            const 火焰等级 = this.自定义数据
			                .get("附魔")
			                .find((item) => item.种类 === "火焰附魔").等级;
			            目标怪物列表.forEach((怪物) => {
			                if (怪物.当前生命值 > 0) {
			                    new 状态效果(
			                        "火焰",
			                        "#CC5500",
			                        "火",
			                        火焰等级,
			                        null,
			                        null,
			                        怪物
			                    );
			                }
			            });
			        }
			        const 连锁附魔 = this.自定义数据
			            .get("附魔")
			            ?.find((item) => item.种类 === "连锁附魔");
			        if (连锁附魔) {
			            const 连锁距离 = 连锁附魔.等级;
			            目标怪物列表.forEach((初始目标) => {
			                if (初始目标.当前生命值 > 0) {
			                    this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
			                }
			            });
			        }
			    }
			
			    获取提示() {
			        let lines = super.获取提示().split("\n");
			        const specificEffectLines = [
			            `甩飞距离：${this.自定义数据.get("甩飞距离")} 格`,
			        ];
			        const effectDescIndex = lines.findIndex((line) =>
			            line.startsWith("效果描述：")
			        );
			        let insertAtIndex =
			            effectDescIndex !== -1
			                ? effectDescIndex + 1
			                : lines.findIndex((line) =>
			                      line.startsWith("--- 强化效果 ---")
			                  );
			        if (insertAtIndex === -1) insertAtIndex = lines.length;
			        lines.splice(insertAtIndex, 0, ...specificEffectLines);
			        return lines.filter(Boolean).join("\n");
			    }
			}
			class 回旋镖 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "回旋镖",
			            图标: 图标映射.回旋镖,
			            品质: 2,
			            基础攻击力: 4,
			            冷却回合: 2,
			            攻击范围: 5 + (配置?.强化 ? 2 : 0),
			            耐久: 配置?.耐久 || 60,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "沿直线投掷固定距离后返回，对路径上的敌人造成两次伤害。会被墙壁阻挡。",
			            攻击目标数: 5,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                ...配置.数据,
			            },
			        });
			    }
			    获取固定距离轴向路径(startX, startY, targetX, targetY) {
			        const path = [];
			        const fixedDistance = this.最终攻击范围;
			        const dxTotal = targetX - startX;
			        const dyTotal = targetY - startY;
			
			        let currentX = startX;
			        let currentY = startY;
			        let dirX = 0;
			        let dirY = 0;
			
			        if (Math.abs(dxTotal) >= Math.abs(dyTotal)) {
			            dirX =
			                Math.sign(dxTotal) ||
			                (prng() < 0.5 ? 1 : -1);
			            dirY = 0;
			        } else {
			            dirX = 0;
			            dirY =
			                Math.sign(dyTotal) ||
			                (prng() < 0.5 ? 1 : -1);
			        }
			
			        if (dirX === 0 && dirY === 0) return [];
			
			        for (let i = 0; i < fixedDistance; i++) {
			            const nextX = currentX + dirX;
			            const nextY = currentY + dirY;
			
			            if (
			                nextX < 0 ||
			                nextX >= 地牢大小 ||
			                nextY < 0 ||
			                nextY >= 地牢大小
			            ) {
			                break;
			            }
			            if (!检查移动可行性(currentX, currentY, nextX, nextY)) {
			                break;
			            }
			            if (地牢[nextY][nextX].背景类型 === 单元格类型.墙壁) {
			                break;
			            }
			            path.push({ x: nextX, y: nextY });
			            currentX = nextX;
			            currentY = nextY;
			        }
			        return path;
			    }
			
			    寻找直线方向目标(使用者) {
			        const 方向列表 = [
			            { dx: 0, dy: -1, 名称: "上" },
			            { dx: 0, dy: 1, 名称: "下" },
			            { dx: -1, dy: 0, 名称: "左" },
			            { dx: 1, dy: 0, 名称: "右" },
			        ];
			        let 最近目标坐标 = null;
			        let 最小距离 = Infinity;
			        const 搜索距离 = 20;
			
			        for (const 方向 of 方向列表) {
			            let 当前X = 使用者.x;
			            let 当前Y = 使用者.y;
			
			            for (let i = 1; i <= 搜索距离; i++) {
			                const 检查X = 使用者.x + 方向.dx * i;
			                const 检查Y = 使用者.y + 方向.dy * i;
			
			                if (
			                    检查X < 0 ||
			                    检查X >= 地牢大小 ||
			                    检查Y < 0 ||
			                    检查Y >= 地牢大小
			                )
			                    break;
			                if (!检查移动可行性(当前X, 当前Y, 检查X, 检查Y))
			                    break;
			                if (地牢[检查Y][检查X].背景类型 === 单元格类型.墙壁)
			                    break;
			
			                const 单元格 = 地牢[检查Y][检查X];
			                if (
			                    单元格?.关联怪物 &&
			                    单元格.关联怪物.状态 === 怪物状态.活跃
			                ) {
			                    const 距离 = i;
			                    if (距离 < 最小距离) {
			                        最小距离 = 距离;
			                        最近目标坐标 = { x: 检查X, y: 检查Y };
			                    }
			                }
			                当前X = 检查X;
			                当前Y = 检查Y;
			            }
			        }
			        return 最近目标坐标;
			    }
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			
			        const 目标坐标 = this.寻找直线方向目标(使用者);
			        let targetDirX, targetDirY;
			        if (目标坐标) {
			            targetDirX = 目标坐标.x;
			            targetDirY = 目标坐标.y;
			        } else {
			            targetDirX = 使用者.x;
			            targetDirY = 使用者.y-1;
			        }
			        const 实际飞出路径 = this.获取固定距离轴向路径(
			            使用者.x,
			            使用者.y,
			            targetDirX,
			            targetDirY
			        );
			
			        if (实际飞出路径.length === 0) {
			            显示通知("回旋镖无法掷出（前方有障碍）！", "警告");
			            this.自定义数据.set(
			                "耐久",
			                this.自定义数据.get("耐久") - this.耐久消耗 * 0.5
			            );
			            if (this.自定义数据.get("耐久") <= 0)
			                处理销毁物品(this.唯一标识, true);
			            this.自定义数据.set(
			                "冷却剩余",
			                this.最终冷却回合
			            );
			            更新装备显示();
			            return 0;
			        }
			
			        let 总有效伤害 = 0;
			        const 击中怪物_去程 = new Set();
			        const 击中怪物_回程 = new Set();
			
			        for (const 节点 of 实际飞出路径) {
			            const 单元格 = 地牢[节点.y]?.[节点.x];
			            if (
			                单元格?.关联怪物 &&
			                单元格.关联怪物.当前生命值 > 0 &&
			                !击中怪物_去程.has(单元格.关联怪物)
			            ) {
			                const 怪物实例 = 单元格.关联怪物;
			                const 原始血量 = 怪物实例.当前生命值;
			                怪物实例.受伤(this.攻击力, "玩家");
			                const 实际伤害 = 原始血量 - 怪物实例.当前生命值;
			                if (实际伤害 > 0) 总有效伤害 += 实际伤害;
			                击中怪物_去程.add(怪物实例);
			                if (
			                    击中怪物_去程.size >=
			                    this.自定义数据.get("攻击目标数")
			                )
			                    break;
			            }
			        }
			
			        const 实际返回路径 = [];
			        let 回程当前X =
			            实际飞出路径.length > 0
			                ? 实际飞出路径[实际飞出路径.length - 1].x
			                : 使用者.x;
			        let 回程当前Y =
			            实际飞出路径.length > 0
			                ? 实际飞出路径[实际飞出路径.length - 1].y
			                : 使用者.y;
			
			        for (let i = 实际飞出路径.length - 1; i >= 0; i--) {
			            const 目标节点 = 实际飞出路径[i];
			            const 回程步X = 目标节点.x;
			            const 回程步Y = 目标节点.y;
			
			            if (
			                !检查移动可行性(
			                    回程当前X,
			                    回程当前Y,
			                    回程步X,
			                    回程步Y
			                )
			            ) {
			                break;
			            }
			            if (地牢[回程步Y][回程步X].背景类型 === 单元格类型.墙壁) {
			                break;
			            }
			
			            实际返回路径.push({ x: 回程步X, y: 回程步Y });
			
			            const 单元格 = 地牢[回程步Y]?.[回程步X];
			            if (
			                单元格?.关联怪物 &&
			                单元格.关联怪物.当前生命值 > 0 &&
			                !击中怪物_回程.has(单元格.关联怪物)
			            ) {
			                const 怪物实例 = 单元格.关联怪物;
			                const 伤害系数 = 击中怪物_去程.has(怪物实例)
			                    ? 0.8
			                    : 1;
			                const 原始血量 = 怪物实例.当前生命值;
			                怪物实例.受伤(this.攻击力 * 伤害系数, "玩家");
			                const 实际伤害 = 原始血量 - 怪物实例.当前生命值;
			                if (实际伤害 > 0) 总有效伤害 += 实际伤害;
			                击中怪物_回程.add(怪物实例);
			                if (
			                    击中怪物_回程.size >=
			                    this.自定义数据.get("攻击目标数")
			                )
			                    break;
			            }
			            回程当前X = 回程步X;
			            回程当前Y = 回程步Y;
			        }
			
			        计划显示格子特效(实际飞出路径, "00FF00");
			        if (实际返回路径.length > 0) {
			            setTimeout(() => {
			                计划显示格子特效(实际返回路径.slice(), "FFFF00");
			            }, 450);
			        }
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set(
			            "冷却剩余",
			            this.最终冷却回合
			        );
			
			        const 总击中数 = new Set([
			            ...击中怪物_去程,
			            ...击中怪物_回程,
			        ]).size;
			        if (总击中数 > 0) {
			            显示通知(
			                `${
			                    this.名称
			                } 击中了 ${总击中数} 个目标，共造成 ${总有效伤害.toFixed(
			                    1
			                )} 点伤害！`,
			                "成功"
			            );
			
			            if (总有效伤害 > 0) {
			                const 所有击中怪物 = Array.from(击中怪物_去程);
			
			                this.触发通用附魔(所有击中怪物);
			            }
			        } 
			
			        更新装备显示();
			        return 总有效伤害;
			    }
			
			    触发通用附魔(目标怪物列表) {
			        if (
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "火焰附魔")?.等级
			        ) {
			            const 火焰等级 = this.自定义数据
			                .get("附魔")
			                .find((item) => item.种类 === "火焰附魔").等级;
			            目标怪物列表.forEach((怪物) => {
			                if (怪物.当前生命值 > 0) {
			                    new 状态效果(
			                        "火焰",
			                        "#CC5500",
			                        "火",
			                        火焰等级,
			                        null,
			                        null,
			                        怪物
			                    );
			                }
			            });
			        }
			        const 连锁附魔 = this.自定义数据
			            .get("附魔")
			            ?.find((item) => item.种类 === "连锁附魔");
			        if (连锁附魔) {
			            const 连锁距离 = 连锁附魔.等级;
			            目标怪物列表.forEach((初始目标) => {
			                if (初始目标.当前生命值 > 0) {
			                    this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
			                }
			            });
			        }
			    }
			
			    获取提示() {
			        return super.获取提示();
			    }
			}
			
			class 闪电链法杖 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "闪电链法杖",
			            图标: 图标映射.闪电链法杖,
			            品质: 3,
			            基础攻击力: 7,
			            冷却回合: 3,
			            攻击范围: 3,
			            耐久: 配置?.耐久 || 35,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "释放一道闪电链，攻击一个目标后弹射到附近其他敌人，每次弹射伤害递减。",
			            攻击目标数: 1,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                最大弹射次数: 3 + (配置?.强化 ? 1 : 0),
			                弹射范围: 3,
			                伤害衰减系数: 0.7,
			                ...配置.数据,
			            },
			        });
			    }
			
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			        if (!目标怪物列表?.length) return 0;
			        const 初始目标 = 目标怪物列表[0];
			        if (!初始目标 || 初始目标.当前生命值 <= 0) return 0;
			
			        let 总有效伤害 = 0;
			        const 已攻击怪物 = new Set([初始目标]);
			        let 当前目标 = 初始目标;
			        let 当前伤害 = this.攻击力;
			        const 弹射路径可视化 = [];
			
			        const 初始攻击路径 = 获取直线路径(
			            使用者.x,
			            使用者.y,
			            初始目标.x,
			            初始目标.y
			        );
			        初始攻击路径.shift();
			        计划显示格子特效(初始攻击路径, "00FFFF");
			
			        const 初始原始血量 = 初始目标.当前生命值;
			        初始目标.受伤(当前伤害, "玩家");
			        const 初始实际伤害 = 初始原始血量 - 初始目标.当前生命值;
			        if (初始实际伤害 > 0) 总有效伤害 += 初始实际伤害;
			
			        let 剩余弹射次数 = this.自定义数据.get("最大弹射次数");
			        while (剩余弹射次数 > 0 && 当前目标.当前生命值 > 0) {
			            const 下一个目标信息 = this.寻找下一个弹射目标(
			                当前目标,
			                已攻击怪物
			            );
			            if (!下一个目标信息) break;
			
			            const { 目标: 下一个目标, 路径: 弹射路径 } =
			                下一个目标信息;
			
			            当前伤害 *= this.自定义数据.get("伤害衰减系数");
			            if (当前伤害 < 1) break;
			
			            弹射路径可视化.push(弹射路径);
			
			            const 原始血量 = 下一个目标.当前生命值;
			            下一个目标.受伤(Math.round(当前伤害), "玩家");
			            const 实际伤害 = 原始血量 - 下一个目标.当前生命值;
			            if (实际伤害 > 0) 总有效伤害 += 实际伤害;
			
			            已攻击怪物.add(下一个目标);
			            当前目标 = 下一个目标;
			            剩余弹射次数--;
			        }
			
			        弹射路径可视化.forEach((路径段, index) => {
			            setTimeout(() => {
			                计划显示格子特效(路径段, "FFFF00");
			            }, 100 + index * 100);
			        });
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") -
			                this.耐久消耗 * (已攻击怪物.size > 1 ? 1.5 : 1)
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set(
			            "冷却剩余",
			            this.最终冷却回合
			        );
			
			        if (已攻击怪物.size > 0) {
			            显示通知(
			                `${this.名称} 攻击了 ${
			                    已攻击怪物.size
			                } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
			                "成功"
			            );
			            if (总有效伤害 > 0) {
			                const 所有击中怪物 = Array.from(已攻击怪物);
			                this.触发通用附魔(所有击中怪物);
			            }
			        }
			        更新装备显示();
			        return 总有效伤害;
			    }
			
			    寻找下一个弹射目标(当前怪物, 已攻击集合) {
			        const 范围 = this.自定义数据.get("弹射范围");
			        let 最近目标 = null;
			        let 最短路径 = null;
			        let 最小距离 = Infinity;
			
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                if (dx === 0 && dy === 0) continue;
			                const x = 当前怪物.x + dx;
			                const y = 当前怪物.y + dy;
			
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小
			                ) {
			                    const 单元格 = 地牢[y][x];
			                    const 潜在目标 = 单元格?.关联怪物;
			                    if (
			                        潜在目标 &&
			                        潜在目标.当前生命值 > 0 &&
			                        !已攻击集合.has(潜在目标) &&
			                        潜在目标.状态 === 怪物状态.活跃
			                    ) {
			                        const 路径 = 广度优先搜索路径(
			                            当前怪物.x,
			                            当前怪物.y,
			                            x,
			                            y,
			                            范围,
			                            true
			                        );
			                        if (
			                            路径 &&
			                            路径.length > 1 &&
			                            路径.length <= 范围 + 1
			                        ) {
			                            const 距离 = 路径.length - 1;
			                            if (距离 < 最小距离) {
			                                最小距离 = 距离;
			                                最近目标 = 潜在目标;
			                                最短路径 = 路径.slice(1);
			                            }
			                        }
			                    }
			                }
			            }
			        }
			        return 最近目标 ? { 目标: 最近目标, 路径: 最短路径 } : null;
			    }
			
			    获取提示() {
			        let lines = super.获取提示().split("\n");
			        const specificEffectLines = [
			            `最大弹射：${this.自定义数据.get("最大弹射次数")} 次`,
			            `弹射范围：${this.自定义数据.get("弹射范围")} 格`,
			            `伤害衰减：x${this.自定义数据
			                .get("伤害衰减系数")
			                .toFixed(2)} /次`,
			        ];
			        const effectDescIndex = lines.findIndex((line) =>
			            line.startsWith("效果描述：")
			        );
			        let insertAtIndex =
			            effectDescIndex !== -1
			                ? effectDescIndex + 1
			                : lines.findIndex((line) =>
			                      line.startsWith("--- 强化效果 ---")
			                  );
			        if (insertAtIndex === -1) insertAtIndex = lines.length;
			
			        lines.splice(insertAtIndex, 0, ...specificEffectLines);
			        return lines.filter(Boolean).join("\n");
			    }
			}
			
			class 大地猛击锤 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "大地猛击锤",
			            图标: 图标映射.大地猛击锤,
			            品质: 3,
			            基础攻击力: 10,
			            冷却回合: 5,
			            攻击范围: 2 + (配置?.强化 ? 2 : 0),
			            耐久: 配置?.耐久 || 80,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "猛击地面，对自身周围小范围内的所有敌人造成伤害并有几率眩晕。",
			            攻击目标数: 99,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                眩晕几率: 0.3,
			                眩晕回合: 2,
			                ...配置.数据,
			            },
			        });
			    }
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			
			        const 范围 = this.最终攻击范围 - 1;
			        const 影响格子 = [];
			        const 击中怪物 = new Set();
			        let 总有效伤害 = 0;
			
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                const x = 使用者.x + dx;
			                const y = 使用者.y + dy;
			
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小
			                ) {
			                    if (检查视线(使用者.x, 使用者.y, x, y, 范围 + 1)) {
			                        影响格子.push({ x, y });
			                        const 单元格 = 地牢[y][x];
			                        if (
			                            单元格?.关联怪物 &&
			                            单元格.关联怪物.当前生命值 > 0
			                        ) {
			                            const 怪物 = 单元格.关联怪物;
			                            击中怪物.add(怪物);
			                            const 原始血量 = 怪物.当前生命值;
			                            怪物.受伤(this.攻击力, "玩家");
			                            const 实际伤害 =
			                                原始血量 - 怪物.当前生命值;
			                            if (实际伤害 > 0)
			                                总有效伤害 += 实际伤害;
			
			                            if (
			                                怪物.当前生命值 > 0 &&
			                                prng() < this.眩晕几率
			                            ) {
			                                new 状态效果(
			                                    "冻结",
			                                    "#FFA500",
			                                    "晕",
			                                    this.自定义数据.get("眩晕回合"),
			                                    null,
			                                    null,
			                                    怪物
			                                );
			                                添加日志(
			                                    `${怪物.类型} 被大地猛击锤眩晕了！`,
			                                    "警告"
			                                );
			                            }
			                        }
			                    }
			                }
			            }
			        }
			
			        if (影响格子.length > 0) {
			            影响格子.forEach((格, index) => {
			                const dist =
			                    Math.abs(格.x - 使用者.x) +
			                    Math.abs(格.y - 使用者.y);
			                setTimeout(
			                    () => 计划显示格子特效([格], "A0522D"),
			                    dist * 50
			                );
			            });
			        }
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") -
			                this.耐久消耗 * (击中怪物.size > 2 ? 1.5 : 1)
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set(
			            "冷却剩余",
			            this.最终冷却回合
			        );
			
			        if (击中怪物.size > 0) {
			            显示通知(
			                `${this.名称} 震击了 ${
			                    击中怪物.size
			                } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
			                "成功"
			            );
			            const 所有击中怪物 = Array.from(击中怪物);
			
			            if (总有效伤害 > 0) {
			                this.触发通用附魔(所有击中怪物);
			            }
			        } else {
			            显示通知(`${this.名称} 发动了震击！`, "信息");
			        }
			
			        更新装备显示();
			        return 总有效伤害;
			    }
			    get 眩晕几率() {
			        return (
			            this.自定义数据.get("眩晕几率") + (this.强化 ? 0.15 : 0)
			        );
			    }
			    获取提示() {
			        let lines = super.获取提示().split("\n");
			        const specificEffectLines = [
			            `眩晕几率：${(this.眩晕几率 * 100).toFixed(0)}%`,
			        ];
			        const effectDescIndex = lines.findIndex((line) =>
			            line.startsWith("效果描述：")
			        );
			        let insertAtIndex =
			            effectDescIndex !== -1
			                ? effectDescIndex + 1
			                : lines.findIndex((line) =>
			                      line.startsWith("--- 强化效果 ---")
			                  );
			        if (insertAtIndex === -1) insertAtIndex = lines.length;
			
			        lines.splice(insertAtIndex, 0, ...specificEffectLines);
			        return lines.filter(Boolean).join("\n");
			    }
			}
			
			class 穿云箭 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "穿云箭",
			            图标: 图标映射.穿云箭,
			            品质: 2,
			            基础攻击力: 5,
			            冷却回合: 3,
			            攻击范围: 8 + (配置?.强化 ? 2 : 0),
			            耐久: 配置?.耐久 || 50,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "射出一支能够穿透多个敌人的箭矢，飞行固定距离。",
			            攻击目标数: 3 + (配置?.强化 ? 1 : 0),
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                ...配置.数据,
			            },
			        });
			    }
			
			    寻找直线方向目标(使用者) {
			        const 方向列表 = [
			            { dx: 0, dy: -1, 名称: "上" },
			            { dx: 0, dy: 1, 名称: "下" },
			            { dx: -1, dy: 0, 名称: "左" },
			            { dx: 1, dy: 0, 名称: "右" },
			        ];
			        let 最近目标坐标 = null;
			        let 最小距离 = Infinity;
			        const 搜索距离 = 20;
			
			        for (const 方向 of 方向列表) {
			            let 当前X = 使用者.x;
			            let 当前Y = 使用者.y;
			
			            for (let i = 1; i <= 搜索距离; i++) {
			                const 检查X = 使用者.x + 方向.dx * i;
			                const 检查Y = 使用者.y + 方向.dy * i;
			
			                if (
			                    检查X < 0 ||
			                    检查X >= 地牢大小 ||
			                    检查Y < 0 ||
			                    检查Y >= 地牢大小
			                )
			                    break;
			                if (!检查移动可行性(当前X, 当前Y, 检查X, 检查Y))
			                    break;
			                if (地牢[检查Y][检查X].背景类型 === 单元格类型.墙壁)
			                    break;
			
			                const 单元格 = 地牢[检查Y][检查X];
			                if (
			                    单元格?.关联怪物 &&
			                    单元格.关联怪物.状态 === 怪物状态.活跃
			                ) {
			                    const 距离 = i;
			                    if (距离 < 最小距离) {
			                        最小距离 = 距离;
			                        最近目标坐标 = { x: 检查X, y: 检查Y };
			                    }
			                }
			                当前X = 检查X;
			                当前Y = 检查Y;
			            }
			        }
			        return 最近目标坐标;
			    }
			
			    获取固定距离直线路径(startX, startY, targetX, targetY) {
			        const path = [];
			        const fixedDistance = this.最终攻击范围;
			        const dxTotal = targetX - startX;
			        const dyTotal = targetY - startY;
			
			        let currentX = startX;
			        let currentY = startY;
			        let dirX = 0;
			        let dirY = 0;
			
			        if (
			            Math.abs(dxTotal) >= Math.abs(dyTotal) &&
			            dxTotal !== 0
			        ) {
			            dirX = Math.sign(dxTotal);
			            dirY = 0;
			        } else if (
			            Math.abs(dyTotal) > Math.abs(dxTotal) &&
			            dyTotal !== 0
			        ) {
			            dirX = 0;
			            dirY = Math.sign(dyTotal);
			        } else {
			            const lastMove = 移动历史[移动历史.length - 1];
			            if (lastMove === "右") {
			                dirX = 1;
			                dirY = 0;
			            } else if (lastMove === "左") {
			                dirX = -1;
			                dirY = 0;
			            } else if (lastMove === "下") {
			                dirX = 0;
			                dirY = 1;
			            } else if (lastMove === "上") {
			                dirX = 0;
			                dirY = -1;
			            } else {
			                if (prng() < 0.5) {
			                    dirX = prng() < 0.5 ? 1 : -1;
			                    dirY = 0;
			                } else {
			                    dirX = 0;
			                    dirY = prng() < 0.5 ? 1 : -1;
			                }
			            }
			        }
			        if (dirX === 0 && dirY === 0) return [];
			
			        for (let i = 0; i < fixedDistance; i++) {
			            const nextX = currentX + dirX;
			            const nextY = currentY + dirY;
			
			            if (
			                nextX < 0 ||
			                nextX >= 地牢大小 ||
			                nextY < 0 ||
			                nextY >= 地牢大小
			            )
			                break;
			            if (!检查移动可行性(currentX, currentY, nextX, nextY))
			                break;
			            if (地牢[nextY][nextX].背景类型 === 单元格类型.墙壁)
			                break;
			
			            path.push({ x: nextX, y: nextY });
			            currentX = nextX;
			            currentY = nextY;
			        }
			        return path;
			    }
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			
			        let targetX, targetY;
			        const 方向目标坐标 = this.寻找直线方向目标(使用者);
			
			        if (方向目标坐标) {
			            targetX = 方向目标坐标.x;
			            targetY = 方向目标坐标.y;
			        } else {
			            显示通知("攻击范围内无可攻击怪物", "错误");
			            return 0;
			        }
			
			        const 实际飞行路径 = this.获取固定距离直线路径(
			            使用者.x,
			            使用者.y,
			            targetX,
			            targetY
			        );
			
			        if (实际飞行路径.length === 0) {
			            显示通知("箭矢无法射出（前方有障碍）！", "警告");
			            this.自定义数据.set(
			                "耐久",
			                this.自定义数据.get("耐久") - this.耐久消耗 * 0.5
			            );
			            if (this.自定义数据.get("耐久") <= 0)
			                处理销毁物品(this.唯一标识, true);
			            this.自定义数据.set(
			                "冷却剩余",
			                this.最终冷却回合
			            );
			            更新装备显示();
			            return 0;
			        }
			
			        let 总有效伤害 = 0;
			        const 击中怪物 = new Set();
			        let 穿透计数 = 0;
			
			        for (const 节点 of 实际飞行路径) {
			            if (穿透计数 >= this.自定义数据.get("攻击目标数"))
			                break;
			
			            const 单元格 = 地牢[节点.y]?.[节点.x];
			            if (
			                单元格?.关联怪物 &&
			                单元格.关联怪物.当前生命值 > 0 &&
			                !击中怪物.has(单元格.关联怪物)
			            ) {
			                const 怪物 = 单元格.关联怪物;
			                击中怪物.add(怪物);
			                穿透计数++;
			
			                const 原始血量 = 怪物.当前生命值;
			                怪物.受伤(this.攻击力, "玩家");
			                const 实际伤害 = 原始血量 - 怪物.当前生命值;
			                if (实际伤害 > 0) 总有效伤害 += 实际伤害;
			            }
			        }
			
			        计划显示格子特效(实际飞行路径, "C0C0C0");
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set(
			            "冷却剩余",
			            this.最终冷却回合
			        );
			
			        if (击中怪物.size > 0) {
			            显示通知(
			                `${this.名称} 穿透了 ${
			                    击中怪物.size
			                } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
			                "成功"
			            );
			            const 所有击中怪物 = Array.from(击中怪物);
			
			            if (总有效伤害 > 0) {
			                this.触发通用附魔(所有击中怪物);
			            }
			        } else if (实际飞行路径.length > 0) {
			            显示通知(`${this.名称} 未击中任何目标。`, "信息");
			        }
			
			        更新装备显示();
			        return 总有效伤害;
			    }
			
			    触发通用附魔(目标怪物列表) {
			        if (
			            this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "火焰附魔")?.等级
			        ) {
			            const 火焰等级 = this.自定义数据
			                .get("附魔")
			                .find((item) => item.种类 === "火焰附魔").等级;
			            目标怪物列表.forEach((怪物) => {
			                if (怪物.当前生命值 > 0) {
			                    new 状态效果(
			                        "火焰",
			                        "#CC5500",
			                        "火",
			                        火焰等级,
			                        null,
			                        null,
			                        怪物
			                    );
			                }
			            });
			        }
			        const 连锁附魔 = this.自定义数据
			            .get("附魔")
			            ?.find((item) => item.种类 === "连锁附魔");
			        if (连锁附魔) {
			            const 连锁距离 = 连锁附魔.等级;
			            目标怪物列表.forEach((初始目标) => {
			                if (初始目标.当前生命值 > 0) {
			                    this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
			                }
			            });
			        }
			    }
			
			    获取提示() {
			        return super.获取提示();
			    }
			}
			class 守卫者盔甲 extends 防御装备类 {
    constructor(配置) {
        super({
            名称: "守卫者盔甲",
            图标: 图标映射.守卫者盔甲,
            品质: 4,
            防御力: 0,
            效果描述: `提供 ${配置?.强化 ? '10%' : '5%'} 的伤害减免，可叠加，最高85%。`,
            耐久: 配置?.耐久 || 200,
            强化: 配置?.强化 || false,
            ...配置,
        });
    }
}
			class 钢制长剑 extends 武器类 {
			    constructor(配置) {
			        super({
			            名称: "钢制长剑",
			            图标: 图标映射.钢制长剑,
			            基础攻击力: 6,
			            冷却回合: 2,
			            攻击范围: 2,
			            效果描述: "一把标准的钢剑。",
			            耐久: 配置.耐久 || 50,
			            强化: 配置.强化 || false,
			            不可破坏: 配置.不可破坏 || false,
			        });
			    }
			    获取提示() {
			        return super.获取提示();
			    }
			}
			
			class 橡木法杖 extends 武器类 {
			    constructor(配置) {
			        super({
			            名称: "橡木法杖",
			            图标: 图标映射.橡木法杖,
			            品质: 3,
			            基础攻击力: 8,
			            攻击范围: 5,
			            冷却回合: 3,
			            攻击目标数: 5,
			            效果描述: "发射魔法弹攻击多个目标。",
			            耐久: 配置.耐久 || 40,
			            强化: 配置.强化 || false,
			            不可破坏: 配置.不可破坏 || false,
			        });
			    }
			    获取提示() {
			        return super.获取提示();
			    }
			}
			
			class 沉浸式传送门 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "沉浸式传送门",
			            图标: 图标映射.沉浸式传送门,
			            品质: 5,
			            能否拾起: true,
			            是否为隐藏物品: true,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "连接两个时空节点的传送门。",
			            ...配置,
			            数据: {
			                传送门ID: 配置?.传送门ID ?? 所有传送门.slice(-1)[0]?.自定义数据?.get('传送门ID')??0,
			                ...配置.数据,
			            },
			        });
			    }
			
			    get 颜色索引() {
			        
			        return (this.自定义数据.get('传送门ID')) % 颜色表.length;
			    }
			    set 颜色索引(值) {
			    }
			    
			    当被收集(进入者) {
			        if (进入者 !== "玩家" || 玩家正在传送) return false;
			        return false;
			    }
			}
			class 冲撞牛角 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "冲撞牛角",
			            图标: 图标映射.冲撞牛角,
			            品质: 5,
			            基础攻击力: 15,
			            冷却回合: 12,
			            攻击范围: 10,
			            耐久: 配置?.耐久 || 50,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "消耗能量，朝怪物最多的方向冲锋，对路径上的敌人造成伤害。",
			            攻击目标数: 99,
			            不可破坏: 配置?.不可破坏 || false,
			            数据: {
			                能量消耗: 40,
			                ...配置.数据,
			            },
			        });
			    }
			
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return false;
			        if (!扣除能量(this.自定义数据.get("能量消耗"))) {
			            显示通知("能量不足！", "错误");
			            return false;
			        }
			
			        const 方向列表 = [
			            { dx: 0, dy: -1, 名称: "上" },
			            { dx: 0, dy: 1, 名称: "下" },
			            { dx: -1, dy: 0, 名称: "左" },
			            { dx: 1, dy: 0, 名称: "右" },
			        ];
			        let 最佳方向 = null;
			        let 最大怪物数 = -1;
			
			        方向列表.forEach((方向) => {
			            let 怪物计数 = 0;
			            for (let i = 1; i <= this.最终攻击范围; i++) {
			                const 检查X = 使用者.x + 方向.dx * i;
			                const 检查Y = 使用者.y + 方向.dy * i;
			                if (
			                    !检查直线移动可行性(
			                        使用者.x,
			                        使用者.y,
			                        检查X,
			                        检查Y,
			                        true
			                    )
			                )
			                    break;
			                if (地牢[检查Y]?.[检查X]?.关联怪物) {
			                    怪物计数++;
			                }
			            }
			            if (怪物计数 > 最大怪物数) {
			                最大怪物数 = 怪物计数;
			                最佳方向 = 方向;
			            }
			        });
			
			        if (最大怪物数 <= 0) {
			            显示通知("没有可冲锋的目标方向！", "信息");
			            const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            能量条.style.width = `${Math.min(
			                100,
			                当前能量 + this.自定义数据.get("能量消耗")/自定义全局设置.初始能量值*100
			            )}%`;
			            return false;
			        }
			
			        const 冲锋路径 = [];
			        let 最终X = 使用者.x;
			        let 最终Y = 使用者.y;
			        let 总有效伤害 = 0;
			
			        for (let i = 1; i <= this.最终攻击范围; i++) {
			            const 新X = 使用者.x + 最佳方向.dx * i;
			            const 新Y = 使用者.y + 最佳方向.dy * i;
			            if (!检查直线移动可行性(最终X, 最终Y, 新X, 新Y)) break;
			
			            冲锋路径.push({ x: 新X, y: 新Y });
			            最终X = 新X;
			            最终Y = 新Y;
			
			            const 单元格 = 地牢[新Y]?.[新X];
			            if (单元格?.关联怪物) {
			                const 原始血量 = 单元格.关联怪物.当前生命值;
			                单元格.关联怪物.受伤(this.攻击力, "玩家");
			                let 实际伤害 =
			                    原始血量 - 单元格.关联怪物?.当前生命值;
			                if (!单元格.关联怪物?.当前生命值) 实际伤害 = 原始血量;
			                if (实际伤害 > 0) 总有效伤害 += 实际伤害;
			            }
			        }
			
			        if (冲锋路径.length > 0) {
			            计划显示格子特效(冲锋路径, "FFA500");
			            const 旧玩家X = 使用者.x;
			            const 旧玩家Y = 使用者.y;
			            使用者.x = 最终X;
			            使用者.y = 最终Y;
			            if(!(使用者 instanceof 宠物)) 处理玩家着陆效果(旧玩家X, 旧玩家Y, 使用者.x, 使用者.y);
			            更新视口();
			            显示通知(
			                `发动冲锋！对路径上的敌人造成了 ${总有效伤害.toFixed(
			                    1
			                )} 点伤害！`,
			                "成功"
			            );
			        }
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			        }
			        this.自定义数据.set("冷却剩余", this.最终冷却回合);
			        更新装备显示();
			        return true;
			    }
			}
			class 护卫种子 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "种子",
			            名称: "护卫种子",
			            图标: 图标映射.种子,
			            品质: 2,
			            颜色索引: 1,
			            堆叠数量: 配置.数量 || 1,
			            最大堆叠数量: 16,
			            效果描述:
			                "种下一株永久存在的护卫植物，它会自动攻击周围的敌人，可以用互动键收回。",
			            数据: {
			                耐久: 配置.耐久,
			            },
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (this.堆叠数量 <= 0) return false;
			        const 放置位置 = 寻找可放置位置(玩家.x, 玩家.y);
			        if (!放置位置) {
			            显示通知("周围没有合适的地方播种！", "错误");
			            return false;
			        }
			        const 护卫植物实例 = new 护卫植物({
			            强化: this.强化,
			            耐久: this.自定义数据.get("耐久"),
			        });
			        if (
			            放置物品到单元格(护卫植物实例, 放置位置.x, 放置位置.y)
			        ) {
			            
			            this.堆叠数量--;
			            显示通知("种下了护卫植物！", "成功");
			            return true;
			        }
			        return false;
			    }
			    获取提示() {
			        let 提示 = super.获取提示();
			        const 耐久 = this.自定义数据.get("耐久");
			        if (耐久 !== undefined && 耐久 !== null) {
			            const 临时植物 = new 护卫植物({ 强化: this.强化 });
			            const 原耐久 = 临时植物.自定义数据.get("原耐久");
			            提示 += `\n剩余攻击次数: ${耐久}/${原耐久}`;
			        }
			        return 提示;
			    }
			}
			
			class 护卫植物 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "植物",
			            名称: "护卫植物",
			            图标: 图标映射.护卫植物,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "攻击周围的敌人。",
			            数据: {
			                倒计时: -1,
			                爆炸时间: -1,
			                攻击力: 5 + (配置.强化 ? 3 : 0),
			                耐久: 配置.耐久 || (30 + (配置.强化 ? 20 : 0)),
			                原耐久: 配置.耐久 || (30 + (配置.强化 ? 20 : 0)),
			                冷却: 2,
			                冷却剩余: 0,
			            },
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        if (玩家.x !== this.x || 玩家.y !== this.y) {
			            return false;
			        }
			        if (
			            尝试收集物品(
			                new 护卫种子({ 耐久: this.自定义数据.get("耐久") }),
			                true
			            )
			        ) {
			            this.移除自身();
			            显示通知("成功回收了护卫种子！", "成功");
			            return true;
			        } else {
			            显示通知("背包已满，无法回收种子！", "错误");
			            return false;
			        }
			    }
			
			    移除自身() {
			        if (
			            this.x !== null &&
			            this.y !== null &&
			            地牢[this.y]?.[this.x]?.关联物品 === this
			        ) {
			            地牢[this.y][this.x].关联物品 = null;
			            地牢[this.y][this.x].类型 = null;
			        }
			        所有计时器 = 所有计时器.filter((item) => item !== this);
			        绘制();
			    }
			
			    更新倒计时() {
			        let 冷却剩余 = this.自定义数据.get("冷却剩余");
			        if (冷却剩余 > 0) {
			            this.自定义数据.set("冷却剩余", 冷却剩余 - 1);
			            return;
			        }
			        let 耐久 = this.自定义数据.get("耐久");
			        if (耐久 <= 0) {
			            this.移除自身();
			            显示通知(`${this.名称} 枯萎了。`, "信息");
			            return;
			        }
			
			        const 攻击范围 = 1;
			        for (let dy = -攻击范围; dy <= 攻击范围; dy++) {
			            for (let dx = -攻击范围; dx <= 攻击范围; dx++) {
			                const 目标X = this.x + dx;
			                const 目标Y = this.y + dy;
			                if (
			                    目标X >= 0 &&
			                    目标X < 地牢大小 &&
			                    目标Y >= 0 &&
			                    目标Y < 地牢大小
			                ) {
			                    const 单元格 = 地牢[目标Y]?.[目标X];
			                    if (
			                        单元格?.关联怪物 &&
			                        单元格.关联怪物.当前生命值 > 0
			                    ) {
			                        单元格.关联怪物.受伤(
			                            this.自定义数据.get("攻击力"),
			                            this
			                        );
			                        this.自定义数据.set("耐久", 耐久 - 1);
			                        this.自定义数据.set(
			                            "冷却剩余",
			                            this.自定义数据.get("冷却")
			                        );
			                        计划显示格子特效(
			                            [{ x: 目标X, y: 目标Y }],
			                            "00FF00"
			                        );
			                        return;
			                    }
			                }
			            }
			        }
			    }
			}
			
			class 远射种子 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "种子",
			            名称: "远射种子",
			            图标: 图标映射.种子,
			            品质: 3,
			            颜色索引: 2,
			            堆叠数量: 配置.数量 || 1,
			            最大堆叠数量: 16,
			            效果描述:
			                "种下一株永久存在的远射植物，它会远程攻击并击退敌人，可以用互动键收回。",
			            数据: {
			                耐久: 配置.耐久,
			            },
			            
			        });
			    }
			
			    使用() {
			        if (this.堆叠数量 <= 0) return false;
			        const 放置位置 = 寻找可放置位置(玩家.x, 玩家.y);
			        if (!放置位置) {
			            显示通知("周围没有合适的地方播种！", "错误");
			            return false;
			        }
			        const 远射植物实例 = new 远射植物({
			            强化: this.强化,
			            耐久: this.自定义数据.get("耐久"),
			        });
			        if (
			            放置物品到单元格(远射植物实例, 放置位置.x, 放置位置.y)
			        ) {
			            
			            this.堆叠数量--;
			            显示通知("种下了远射植物！", "成功");
			            return true;
			        }
			        return false;
			    }
			    获取提示() {
			        let 提示 = super.获取提示();
			        const 耐久 = this.自定义数据.get("耐久");
			        if (耐久 !== undefined && 耐久 !== null) {
			             const 临时植物 = new 远射植物({ 强化: this.强化 });
			             const 原耐久 = 临时植物.自定义数据.get("原耐久");
			             提示 += `\n剩余攻击次数: ${耐久}/${原耐久}`;
			        }
			        return 提示;
			    }
			}
			
			class 远射植物 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "植物",
			            名称: "远射植物",
			            图标: 图标映射.远射植物,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "远程攻击敌人。",
			            
			            数据: {
			                倒计时: -1,
			                爆炸时间: -1,
			                攻击力: 4 + (配置.强化 ? 2 : 0),
			                攻击范围: 6,
			                冷却: 3,
			                冷却剩余: 0,
			                耐久: 配置.耐久 || (25 + (配置.强化 ? 15 : 0)),
			            原耐久: 配置.耐久 || (25 + (配置.强化 ? 15 : 0)),
			                
			                
			            },
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        if (玩家.x !== this.x || 玩家.y !== this.y) {
			            return false;
			        }
			        if (
			            尝试收集物品(
			                new 远射种子({ 耐久: this.自定义数据.get("耐久") }),
			                true
			            )
			        ) {
			            this.移除自身();
			            显示通知("成功回收了远射种子！", "成功");
			            return true;
			        } else {
			            显示通知("背包已满，无法回收种子！", "错误");
			            return false;
			        }
			    }
			
			    移除自身() {
			        if (
			            this.x !== null &&
			            this.y !== null &&
			            地牢[this.y]?.[this.x]?.关联物品 === this
			        ) {
			            地牢[this.y][this.x].关联物品 = null;
			            地牢[this.y][this.x].类型 = null;
			        }
			        所有计时器 = 所有计时器.filter((item) => item !== this);
			        绘制();
			    }
			
			    更新倒计时() {
			        let 冷却剩余 = this.自定义数据.get("冷却剩余");
			        if (冷却剩余 > 0) {
			            this.自定义数据.set("冷却剩余", 冷却剩余 - 1);
			            return;
			        }
			        let 耐久 = this.自定义数据.get("耐久");
			        if (耐久 <= 0) {
			            this.移除自身();
			            显示通知(`${this.名称} 枯萎了。`, "信息");
			            return;
			        }
			
			        let 最近怪物 = null;
			        let 最小距离 = Infinity;
			
			        所有怪物.forEach((怪物) => {
			            if (怪物.状态 === 怪物状态.活跃) {
			                const 距离 =
			                    Math.abs(this.x - 怪物.x) +
			                    Math.abs(this.y - 怪物.y);
			                if (
			                    距离 < 最小距离 &&
			                    距离 <= this.自定义数据.get("攻击范围")
			                ) {
			                    if (
			                        检查视线(
			                            this.x,
			                            this.y,
			                            怪物.x,
			                            怪物.y,
			                            this.自定义数据.get("攻击范围")
			                        )
			                    ) {
			                        最小距离 = 距离;
			                        最近怪物 = 怪物;
			                    }
			                }
			            }
			        });
			
			        if (最近怪物) {
			            最近怪物.受伤(this.自定义数据.get("攻击力"), this);
			            const 路径 = 获取直线路径(
			                this.x,
			                this.y,
			                最近怪物.x,
			                最近怪物.y
			            );
			            计划显示格子特效(路径, "FFA500");
			
			            const dx = 最近怪物.x - this.x;
			            const dy = 最近怪物.y - this.y;
			            let 方向DX = dx === 0 ? 0 : Math.sign(dx);
			            let 方向DY = dy === 0 ? 0 : Math.sign(dy);
			            if (Math.abs(dx) > Math.abs(dy)) {
			                方向DY = 0;
			            } else {
			                方向DX = 0;
			            }
			
			            const { x: 最终X, y: 最终Y } =
			                最近怪物.计算最大甩飞位置(
			                    最近怪物.x,
			                    最近怪物.y,
			                    方向DX,
			                    方向DY,
			                    1
			                );
			            if (最终X !== 最近怪物.x || 最终Y !== 最近怪物.y) {
			                const oldX = 最近怪物.x,
			                    oldY = 最近怪物.y;
			                最近怪物.恢复背景类型();
			                最近怪物.x = 最终X;
			                最近怪物.y = 最终Y;
			                最近怪物.保存新位置类型(最终X, 最终Y);
			                地牢[最终Y][最终X].类型 = 单元格类型.怪物;
			                地牢[最终Y][最终X].关联怪物 = 最近怪物;
			                最近怪物.处理地形效果();
			                最近怪物.绘制血条();
			                怪物动画状态.set(最近怪物, {
			                    旧逻辑X: oldX,
			                    旧逻辑Y: oldY,
			                    目标逻辑X: 最终X,
			                    目标逻辑Y: 最终Y,
			                    视觉X: oldX,
			                    视觉Y: oldY,
			                    动画开始时间: Date.now(),
			                    正在动画: true,
			                });
			            }
			
			            this.自定义数据.set("耐久", 耐久 - 1);
			            this.自定义数据.set(
			                "冷却剩余",
			                this.自定义数据.get("冷却")
			            );
			        }
			    }
			}
			
			class 追踪风弹 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "追踪风弹",
			            图标: 图标映射.追踪风弹,
			            品质: 3,
			            颜色索引: 1,
			            堆叠数量: 配置.数量 || 1,
			            最大堆叠数量: 16,
			            冷却回合: 1,
			            攻击力: 0,
			            攻击范围:25,
			            效果描述: "消耗品。发射一枚自动追踪敌人的气弹，命中后在3x3范围内造成眩晕。",
			            ...配置,
			        });
			    }
			
			    使用(目标怪物列表, 目标路径, 使用者 = 玩家) {
			        if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return false;
			
			        const 发射位置 = 寻找可放置位置(使用者.x, 使用者.y);
			        if (!发射位置?.x) return;
			
			        this.堆叠数量--;
			        if (this.堆叠数量 <= 0) {
			            处理销毁物品(this.唯一标识, true);
			        }
			        this.自定义数据.set("冷却剩余",this.最终冷却回合);
			        更新装备显示();
			        更新背包显示();
			        
			        const 弹头实例 = new 追踪风弹弹头({强化:this.强化});
			        放置怪物到单元格(弹头实例, 发射位置.x, 发射位置.y);
			        
			
			        return true;
			    }
			}
			class 泉水 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "生命之泉",
			            图标: 图标映射.泉水,
			            品质: 4,
			            颜色索引: 1,
			            能否拾起: false,
			            阻碍怪物: false,
			            是否正常物品: false,
			            效果描述: "互动一次即可完全恢复生命和能量。",
			            数据: {
			                已使用: false,
			                ...配置.数据,
			            },
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (this.自定义数据.get("已使用")) {
			            显示通知("泉水已经干涸了。", "信息");
			            return false;
			        }
			        const 生命条 = document.querySelector(".health-bar");
			        const 能量条 = document.querySelector(".power-bar");
			        生命条.style.width = "100%";
			        能量条.style.width = "100%";
			        this.自定义数据.set("已使用", true);
			        const 新的永久Buffs = { 已获得效果: new Set() };
			                 永久Buffs = 新的永久Buffs;
			                 应用永久Buffs(); 
			
			        this.效果描述 = "泉水已经干涸了。";
			        显示通知("你感到一股清流涌遍全身，焕然一新！", "成功");
			        绘制();
			        return true;
			    }
			
			    尝试互动() {
			        return this.使用();
			    }
			}
			
			class 书架 extends 物品 {
			    constructor(配置 = {}) {
			        const hasContent =
			            配置.有内容 !== undefined
			                ? 配置.有内容
			                : prng() < 0.2;
			        super({
			            类型: "地形",
			            名称: hasContent ? "古老的书架" : "空书架",
			            图标: 图标映射.书架,
			            品质: 3,
			            颜色索引: 2,
			            能否拾起: false,
			            阻碍怪物: false,
			            是否正常物品: false,
			            效果描述: hasContent
			                ? "互动一次可以随机获得一个已解锁的卷轴或融合配方。"
			                : "这个书架上空空如也，积满了灰尘。",
			            数据: {
			                已使用: !hasContent,
			                ...配置.数据,
			            },
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (this.自定义数据.get("已使用")) {
			            显示通知("书架上已经没有可读的书了。", "信息");
			            return false;
			        }
			
			        if (prng() < 0.7) {
			            const 可用卷轴 = 物品池["卷轴"].filter((item) => {
			                const 实例 = new item.类({});
			                return 实例.是否正常物品;
			            });
			            if (可用卷轴.length > 0) {
			                const 选中卷轴配置 =
			                    可用卷轴[
			                        Math.floor(prng() * 可用卷轴.length)
			                    ];
			                const 新卷轴 = new 选中卷轴配置.类({
			                    已解锁: true,
			                });
			                if (尝试收集物品(新卷轴, true)) {
			                    显示通知(
			                        `你从书中习得了《${新卷轴.名称}》！`,
			                        "成功"
			                    );
			                } else {
			                    显示通知(
			                        `你发现了一本《${新卷轴.名称}》，但背包满了！`,
			                        "错误"
			                    );
			                    return false;
			                }
			            }
			        } else {
			            const 可用配方 = [...程序生成配方列表];
			            if (可用配方.length > 0) {
			                const 选中配方 =
			                    可用配方[
			                        Math.floor(prng() * 可用配方.length)
			                    ];
			                if (
			                    !已发现的程序生成配方.some(
			                        (r) => r.说明 === 选中配方.说明
			                    )
			                ) {
			                    已发现的程序生成配方.push(选中配方);
			                    显示通知(
			                        `你发现了一张配方：${选中配方.说明}！`,
			                        "成功"
			                    );
			                } else {
			                    显示通知(
			                        "你又读了一遍熟悉的配方，温故而知新。",
			                        "信息"
			                    );
			                }
			            } else {
			                显示通知(
			                    "书架上落满了灰尘，什么也没找到。",
			                    "信息"
			                );
			            }
			        }
			
			        this.自定义数据.set("已使用", true);
			        this.名称 = "空书架";
			        this.效果描述 = "这个书架上空空如也，积满了灰尘。";
			
			        return true;
			    }
			
			    尝试互动() {
			        return this.使用();
			    }
			}
			class 神偷手 extends 武器类 {
			 constructor(配置 = {}) {
			     super({
			         名称: "神偷手",
			         图标: 图标映射.神偷手,
			         品质: 3,
			         颜色索引: 2, 
			         基础攻击力: 0, 
			         冷却回合: 15 - (配置.强化 ? 5 : 0),
			         攻击范围: 3, 
			         耐久: 15 + (配置.强化 ? 10 : 0),
			         原耐久: 15 + (配置.强化 ? 10 : 0),
			         效果描述: "对近处的敌人施展妙手空空之术。",
			         攻击目标数: 1, 
			         数据: {
			             能量消耗: 60 - (配置.强化 ? 20 : 0),
			             怪物偷窃成功率: 0.7 + (配置.强化 ? 0.2 : 0), 
			             商人偷窃成功率: 0.4 + (配置.强化 ? 0.15 : 0),
			         },
			         ...配置,
			     });
			 }
			
			 
			 使用(目标怪物列表, 目标路径, 使用者 = 玩家) {
			     if (this.自定义数据.get("冷却剩余") > 0) {
			         显示通知("手臂还在发麻，等会再偷！", "警告");
			         return true;//返回true以防止重复通知，下面同理
			     }
			     if (!扣除能量(this.自定义数据.get("能量消耗"))) {
			         显示通知("能量不足，无法施展妙手！", "错误");
			         return true;
			     }
			
			     const 目标 = this.寻找最近的目标(使用者);
			
			     if (!目标) {
			         显示通知("附近没有可以下手的东西...", "信息");
			         
			         const 能量条 = document.querySelector(".power-bar");
			         const 当前能量 = parseFloat(能量条.style.width) || 0;
			         能量条.style.width = `${Math.min(100, 当前能量 + this.自定义数据.get("能量消耗")/自定义全局设置.初始能量值*100)}%`;
			         return true;
			     }
			
			     
			     this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
			     if (this.自定义数据.get("耐久") <= 0) {
			         处理销毁物品(this.唯一标识, true);
			         显示通知(`${this.名称} 已损坏！`, "警告");
			     }
			     this.自定义数据.set("冷却剩余", this.最终冷却回合);
			     更新装备显示();
			
			     
			     if (目标 instanceof 神秘商人) {
			         this.处理商人偷窃(目标);
			     } else if (目标 instanceof 怪物) {
			         this.处理怪物偷窃(目标);
			     }
			
			     return true; 
			 }
			
			 寻找最近的目标(使用者) {
			     let 最近目标 = null;
			     let 最小距离 = Infinity;
			     const 范围 = this.最终攻击范围;
			
			     for (let dy = -范围; dy <= 范围; dy++) {
			         for (let dx = -范围; dx <= 范围; dx++) {
			             const x = 使用者.x + dx;
			             const y = 使用者.y + dy;
			             if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
			             
			             const 距离 = Math.abs(dx) + Math.abs(dy);
			             if (距离 < 最小距离) {
			                 const 单元格 = 地牢[y]?.[x];
			                 if (单元格) {
			                     const 潜在目标 = 单元格.关联怪物 || 单元格.关联物品;
			                     if (潜在目标 && (潜在目标 instanceof 怪物 || 潜在目标 instanceof 神秘商人)) {
			                          if(快速直线检查(使用者.x, 使用者.y, x, y, 范围)){
			                             最小距离 = 距离;
			                             最近目标 = 潜在目标;
			                         }
			                     }
			                 }
			             }
			         }
			     }
			     return 最近目标;
			 }
			
			 处理怪物偷窃(目标怪物) {
				if (目标怪物 && !(目标怪物 instanceof 大魔法师)
				 && !(目标怪物 instanceof 米诺陶) 
				 && !(目标怪物 instanceof 墓碑) && !(目标怪物 instanceof 王座守护者)
				 && !(目标怪物 instanceof 皇家守卫)
				 && !(目标怪物 instanceof 复活怪物)
				 && !(目标怪物 instanceof 巨人怪物)
				 && !(目标怪物 instanceof 追踪风弹弹头)
				 && !(目标怪物 instanceof 蜈蚣部位)
				 && !(目标怪物 instanceof 蜈蚣怪物)) {
			     if (!(目标怪物.掉落物) || 目标怪物.掉落物.length === 0) {
			         显示通知(`${目标怪物.类型} 身上空空如也！`, "信息");
			         return;
			     }
			
			     if (prng() < this.自定义数据.get("怪物偷窃成功率")) {
			         
			         const 被偷物品 = 克隆物品(目标怪物.掉落物); 
			         if (尝试收集物品(被偷物品, true)) {
			             显示通知(`成功偷取了 ${被偷物品.获取名称()}！`, "成功");
			
			             
			             const 旧生命值 = 目标怪物.当前生命值;
			             const 旧位置X = 目标怪物.x;
			             const 旧位置Y = 目标怪物.y;
			             const 旧房间ID = 目标怪物.房间ID;
			
			             
			             目标怪物.恢复背景类型(); 
			             所有怪物 = 所有怪物.filter(m => m !== 目标怪物);
			             怪物状态表.delete(目标怪物);
			             
			             
			             const 新普通怪物 = new 怪物({
			                 x: 旧位置X,
			                 y: 旧位置Y,
			                 房间ID: 旧房间ID,
			                 当前生命值: 旧生命值, 
			                 状态: 怪物状态.活跃,
			                 掉落物: new 金币({ 数量: 1 }), 
			             });
			             放置怪物到单元格(新普通怪物, 旧位置X, 旧位置Y);
			             添加日志(`${目标怪物.类型} 的宝物被夺走，变得普通了！`, '警告');
			             
			         } else {
			             显示通知("偷到了东西，但背包满了！", "错误");
			         }
			     } else {
			         
			         显示通知("失手了！被怪物发现了！", "警告");
			         目标怪物.仇恨 = 玩家;
			     }
				} else {
					显示通知("目标似乎无法被选中...", "信息");
				}
			 }
			
			 处理商人偷窃(商人) {
			     const 库存 = 商人.自定义数据.get("库存");
			     if (!库存 || 库存.length === 0) {
			         显示通知("这个商人已经没货了！", "信息");
			         return;
			     }
			
			     if (prng() < this.自定义数据.get("商人偷窃成功率")) {
			         
			         const 随机索引 = Math.floor(prng() * 库存.length);
			         const 被偷物品原型 = 库存.splice(随机索引, 1)[0]; 
			         const 被偷物品 = 克隆物品(被偷物品原型);
			
			         if (尝试收集物品(被偷物品, true)) {
			             显示通知(`成功从商人那里偷到了 ${被偷物品.获取名称()}！`, "成功");
			             
			             if(库存.length === 0) {
			                  this.商人消失(商人, "心满意足地");
			             }
			         } else {
			             显示通知("偷到了东西，但背包满了！", "错误");
			             库存.push(被偷物品原型); 
			         }
			     } else {
			         
			         显示通知("失手了！商人愤怒地召唤了神罚！", "错误");
			         this.商人闪电惩罚();
			         this.商人消失(商人, "愤怒地");
			     }
			 }
			 
			 商人闪电惩罚() {
			     
			     const 闪电伤害 = 50;
			     const 火焰强度 = 5;
			     const 火焰持续 = 5;
			     const 惩罚范围 = [{x: 玩家.x, y: 玩家.y}]; 
			
			     计划显示格子特效(惩罚范围, "FFFF00", 50);
			
			     伤害玩家(闪电伤害, "神秘商人");
			     
			     new 状态效果(
			         "火焰",
			         效果颜色编号映射[效果名称编号映射.火焰],
			         图标映射.火焰,
			         火焰持续, null, null, null, 火焰强度
			     );
			     添加日志("你被闪电点燃了！", "错误");
			
			     if (位置是否可用(玩家.x, 玩家.y, false)) {
			         放置物品到单元格(new 火焰物品({强化: true}), 玩家.x, 玩家.y);
			     }
			 }
			
			 商人消失(商人, 方式) {
			     if (商人.x !== null && 商人.y !== null && 地牢[商人.y]?.[商人.x]?.关联物品 === 商人) {
			         地牢[商人.y][商人.x].关联物品 = null;
			         if (地牢[商人.y][商人.x].类型 === 单元格类型.物品) {
			             地牢[商人.y][商人.x].类型 = null;
			         }
			         添加日志(`神秘商人${方式}消失了。`, '信息');
			         绘制();
			     }
			 }
			 
			 get 攻击力() {
			     return 0;
			 }
			}
			class 迅捷卷轴 extends 卷轴类 {
			    constructor(配置) {
			        super({
			            名称: "迅捷卷轴",
			            品质: 3,
			            效果描述: "激活后增加移动步数，效果可叠加，消耗能量",
			            能量消耗: 配置.能量消耗 ?? 4,
			            强化: 配置.强化 || false,
			            已解锁: 配置.已解锁 || false,
			        });
			        this.速度加成值 = 2;
			    }
			
			    计算总迅捷加成() {
			        let 激活的迅捷卷轴数量 = 0;
			        if (
			            typeof 当前激活卷轴列表 !== "undefined" &&
			            当前激活卷轴列表 instanceof Set
			        ) {
			            当前激活卷轴列表.forEach((卷轴) => {
			                if (卷轴 instanceof 迅捷卷轴) {
			                    激活的迅捷卷轴数量++;
			                }
			            });
			        } else {
			            console.warn(
			                "迅捷卷轴：无法访问或类型错误的 当前激活卷轴列表，无法计算加成。"
			            );
			            return 0;
			        }
			        return 激活的迅捷卷轴数量 * this.速度加成值;
			    }
			
			    使用() {
			        const 总加成 = this.计算总迅捷加成();
			        玩家属性.移动步数 = 初始玩家属性.移动步数 + 总加成;
			        return true;
			    }
			
			    卸下() {
			        const 总加成 = this.计算总迅捷加成();
			        const 计算后的步数 = 初始玩家属性.移动步数 + 总加成;
			        玩家属性.移动步数 = Math.max(
			            初始玩家属性.移动步数,
			            计算后的步数
			        );
			        return true;
			    }
			}
			class 神秘卷轴 extends 卷轴类 {
			    constructor(配置) {
			        super({
			            名称: "神秘卷轴",
			            品质: 3,
			            效果描述: "浪费能量的空白卷轴",
			            能量消耗: 15,
			            强化: 配置.强化 || false,
			            已解锁: 配置.已解锁 || false,
			        });
			    }
			    //使用时不卸下即视为每回合消耗能量，消耗能量在卷轴基类处理
			    使用() {
			        return true;
			    }
			    卸下() {
			        return true;
			    }
			}
			class 贪婪卷轴 extends 卷轴类 {
			    constructor(配置) {
			        super({
			            名称: "贪婪卷轴",
			            品质: 3,
			            效果描述: "赌狗！将怪物掉落率/装备耐久提高一倍吧！",
			            能量消耗: 5,
			            强化: 配置.强化 || false,
			            已解锁: 配置.已解锁 || false,
			        });
			    }
			
			    计算总倍率加成() {
			        let 激活的贪婪卷轴数量 = 0;
			        if (
			            typeof 当前激活卷轴列表 !== "undefined" &&
			            当前激活卷轴列表 instanceof Set
			        ) {
			            当前激活卷轴列表.forEach((卷轴) => {
			                if (卷轴 instanceof 贪婪卷轴) {
			                    激活的贪婪卷轴数量++;
			                }
			            });
			        } else {
			            console.warn(
			                "贪婪卷轴：无法访问或类型错误的 当前激活卷轴列表，无法计算加成。"
			            );
			            return 0;
			        }
			        return 激活的贪婪卷轴数量;
			    }
			
			    使用() {
			        const 总加成 = this.计算总倍率加成();
			        玩家属性.掉落倍率 = 初始玩家属性.掉落倍率 + 总加成;
			        return true;
			    }
			
			    卸下() {
			        const 总加成 = this.计算总倍率加成();
			        const 计算后的倍率 = 初始玩家属性.掉落倍率 + 总加成;
			        玩家属性.掉落倍率 = Math.max(
			            初始玩家属性.掉落倍率,
			            计算后的倍率
			        );
			        return true;
			    }
			}
			class 清净卷轴 extends 卷轴类 {
			    constructor(配置) {
			        super({
			            名称: "清净卷轴",
			            品质: 3,
			            效果描述: "消耗大量能量，激活后去除自身所有效果",
			            能量消耗: 10,
			            强化: 配置.强化 || false,
			            已解锁: 配置.已解锁 || false,
			        });
			    }
			
			    使用() {
			        if (!this.消耗能量()) return false;
			        玩家状态.forEach((item) => {
			            item.移除状态();
			        });
			        当前激活卷轴列表.delete(this);
			
			        显示通知("卷轴成功发挥作用", "成功");
			        绘制();
			        return true;
			    }
			}
			class 金币手枪 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "金币手枪",
			            图标: 图标映射.金币手枪,
			            品质: 3,
			            颜色索引: 2,
			            效果描述:
			                "发射直线子弹，中弹怪物会麻木，每发消耗2金币。",
			            基础攻击力: 1,
			            冷却回合: 1,
			            攻击范围: 40,
			            耐久: 配置.耐久 || 75,
			            强化: 配置.强化 || false,
			            不可破坏: 配置.不可破坏 || false,
			            数据: {
			                金币消耗: 2,
			            },
			        });
			    }
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (使用者 instanceof 宠物) return false;
			        const 金币列表 = [...玩家背包.values()].filter(
			            (i) => i instanceof 金币
			        );
			        const 总金币 = 金币列表.reduce(
			            (sum, i) => sum + i.堆叠数量,
			            0
			        );
			        if (总金币 < this.自定义数据.get("金币消耗")) {
			            显示通知("金币不足！", "错误");
			            return false;
			        }
			        const 攻击结果 = this.寻找直线目标();
			        if (!攻击结果) {
			            return false;
			        }
			
			        if (!扣除金币(this.自定义数据.get("金币消耗")))
			            return false;
			
			        super.使用([攻击结果.怪物]);
			        更新背包显示();
			        攻击结果.怪物.受伤冻结回合剩余 = 2;
			        计划显示格子特效(攻击结果.路径);
			        return true;
			    }
			    寻找直线目标() {
			        const 方向列表 = [
			            {
			                dx: 0,
			                dy: -1,
			                名称: "上",
			            },
			            {
			                dx: 0,
			                dy: 1,
			                名称: "下",
			            },
			            {
			                dx: -1,
			                dy: 0,
			                名称: "左",
			            },
			            {
			                dx: 1,
			                dy: 0,
			                名称: "右",
			            },
			        ];
			        let 最近目标 = null;
			        let 最小距离 = Infinity;
			        if (地牢[玩家.y][玩家.x].类型 === 单元格类型.怪物) {
			            return {
			                怪物: 地牢[玩家.y][玩家.x].关联怪物,
			                路径: [{ x: 玩家.x, y: 玩家.y }],
			            };
			        }
			        方向列表.forEach((方向) => {
			            let 当前X = 玩家.x + 方向.dx;
			            let 当前Y = 玩家.y + 方向.dy;
			            let 路径 = [];
			            for (let i = 0; i < 9999; i++) {
			                if (
			                    !检查移动可行性(
			                        当前X - 方向.dx,
			                        当前Y - 方向.dy,
			                        当前X,
			                        当前Y
			                    )
			                )
			                    break;
			                const 单元格 = 地牢[当前Y]?.[当前X];
			                if (
			                    单元格?.关联怪物 &&
			                    单元格.类型 === 单元格类型.怪物 &&
			                    单元格.关联怪物?.状态 === 怪物状态.活跃
			                ) {
			                    const 距离 =
			                        Math.abs(当前X - 玩家.x) +
			                        Math.abs(当前Y - 玩家.y);
			                    if (距离 < 最小距离) {
			                        最近目标 = {
			                            怪物: 单元格.关联怪物,
			                            路径: 获取直线路径(
			                                玩家.x,
			                                玩家.y,
			                                当前X,
			                                当前Y
			                            ),
			                        };
			                        最小距离 = 距离;
			                    }
			                    break;
			                }
			                路径.push({
			                    x: 当前X,
			                    y: 当前Y,
			                });
			                当前X += 方向.dx;
			                当前Y += 方向.dy;
			            }
			        });
			        return 最近目标;
			    }
			    获取提示() {
			        return super.获取提示();
			    }
			}
			
			class 附魔卷轴 extends 卷轴类 {
			    constructor(配置) {
			        super({
			            名称: "附魔卷轴",
			            品质: 配置.品质 || 1,
			            效果描述: "为装备附加附魔",
			            能量消耗: 30,
			            已解锁: 配置.已解锁 || false,
			            强化: 配置.强化 || false,
			        });
			        this.可用次数 = 配置.可用次数 || 1;
			        this.附魔池 = [
			            this.火焰附魔,
			            this.保护附魔,
			            this.耐久附魔,
			            this.锋利附魔,
			            this.爆炸保护附魔,
			            this.连锁附魔,
			            this.荆棘附魔,
			        ];
			        this.效果名 = [
			            "火焰附魔",
			            "保护附魔",
			            "耐久附魔",
			            "锋利附魔",
			            "爆炸保护附魔",
			            "连锁附魔",
			            "荆棘附魔",
			        ];
			        const 效果索引 = Math.floor(
			            prng() * this.附魔池.length
			        );
			        this.附魔效果 = this.附魔池[效果索引];
			        this.当前附魔效果名 = this.效果名[效果索引];
			        if (!配置.品质) {
			            this.品质 = Math.floor(prng() * 6) || 1;
			            this.颜色索引 = this.品质 - 1;
			        }
			        this.效果描述 =
			            "为装备附加" +
			            this.当前附魔效果名 +
			            "(附魔等级由品质决定)";
			    }
			
			    使用() {
			        this.显示附魔界面();
			        return true;
			    }
			
			    显示附魔界面() {
			        玩家属性.允许移动 += 1;
			        const 弹窗 = this.创建附魔弹窗();
			        更新装备显示();
			        this.添加装备到弹窗(弹窗);
			        this.添加确认按钮(弹窗);
			        
			    }
			
			    添加确认按钮(弹窗) {
			        const 确认按钮 = document.createElement("button");
			        确认按钮.className = "附魔确认按钮";
			        确认按钮.innerHTML = "开始附魔";
			        确认按钮.addEventListener("click", () => {
			            const 选中装备 = 弹窗.querySelector(".可附魔.active");
			            if (选中装备) {
			                this.执行附魔(选中装备.__物品实例, 弹窗, 选中装备);
			            } else {
			                显示通知("请选择要附魔物品", "错误");
			            }
			        });
			        弹窗.querySelector(".附魔装备容器").after(确认按钮);
			    }
			
			    创建附魔弹窗() {
			        const 弹窗 = document.createElement("div");
			        弹窗.className = "附魔弹窗";
			        弹窗.innerHTML = `
			<div class="附魔头" >
			    <span class="附魔标题">选择要附魔的装备</span>
			    <button class="关闭按钮" click>×</button>
			</div >
			<div class="附魔装备容器"></div>
			<div class="附魔特效"></div>
			        `;
			        弹窗.querySelector(".关闭按钮").addEventListener(
			            "click",
			            () => {
			                弹窗.classList.add("关闭中");
			                setTimeout(() => {
			                    玩家属性.允许移动 -= 1;
			                    弹窗.remove();
			                    当前激活卷轴列表.delete(this);
			                    更新装备显示();
			                }, 300);
			            }
			        );
			        document.body.appendChild(弹窗);
			        return 弹窗;
			    }
			
			    添加装备到弹窗(弹窗) {
			        const 容器 = 弹窗.querySelector(".附魔装备容器");
			        Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			        )
			            .filter((v) => v != null)
			            .forEach((装备) => {
			                const 克隆元素 = 装备
			                    .生成显示元素("装备")
			                    .cloneNode(true);
			                克隆元素.style.margin = "-5px 0";
			                克隆元素.classList.remove("active");
			                克隆元素.classList.remove("hover");
			                克隆元素.removeAttribute("data-quality");
			                克隆元素.__物品实例 = 装备;
			                克隆元素.classList.add("可附魔");
			                克隆元素.addEventListener("click", (e) => {
			                    克隆元素.classList.add("active");
			                    容器.querySelectorAll(".物品条目").forEach(
			                        (el) => {
			                            if (el !== 克隆元素) {
			                                el.classList.remove("active");
			                            }
			                        }
			                    );
			                });
			                ["丢弃按钮", "使用按钮", "装备按钮"].forEach(
			                    (className) => {
			                        克隆元素.querySelector(
			                            `.${className} `
			                        )?.remove();
			                    }
			                );
			                容器.appendChild(克隆元素);
			            });
			    }
			
			    执行附魔(装备, 弹窗, 元素) {
			        const 成功 = this.附魔效果.call(this, 装备);
			
			        if (成功) {
			            元素.classList.add("附魔成功");
			            setTimeout(
			                () => 元素.classList.remove("附魔成功"),
			                1500
			            );
			
			            this.播放附魔特效(装备, 弹窗, 元素);
			            this.可用次数--;
			            if (this.可用次数 <= 0) {
			                处理销毁物品(this.唯一标识, true);
			            }
			            显示通知("附魔成功！装备绽放出神秘光芒", "成功");
			            弹窗.classList.add("关闭中");
			            当前激活卷轴列表.delete(this);
			            更新装备显示();
			
			            setTimeout(() => {
			                弹窗.remove();
			                玩家属性.允许移动 -= 1;
			            }, 2000);
			            return true;
			        } else {
			            显示通知("无法应用附魔！", "错误");
			            return false;
			        }
			    }
			
			    火焰附魔(装备) {
			        return this.添加附魔(装备, "火焰附魔", [
			            "武器",
			            "防御装备",
			        ]);
			    }
			    耐久附魔(装备) {
			        return this.添加附魔(装备, "耐久附魔", [
			            "武器",
			            "防御装备",
			        ]);
			    }
			    保护附魔(装备) {
			        return this.添加附魔(装备, "保护附魔", ["防御装备"]);
			    }
			    锋利附魔(装备) {
			        return this.添加附魔(装备, "锋利附魔", ["武器"]);
			    }
			    连锁附魔(装备) {
			        return this.添加附魔(装备, "连锁附魔", ["武器"]);
			    }
			    爆炸保护附魔(装备) {
			        return this.添加附魔(装备, "爆炸保护附魔", ["防御装备"]);
			    }
			    荆棘附魔(装备) {
			        return this.添加附魔(装备, "荆棘附魔", ["防御装备"]);
			    }
			    添加附魔(装备, 附魔种类, 允许装备列表) {
			        if (装备.自定义数据.get("附魔")) {
			            if (
			                !装备.自定义数据
			                    .get("附魔")
			                    .some(
			                        (附魔) =>
			                            附魔.种类 === 附魔种类 &&
			                            附魔.等级 >= this.品质
			                    ) &&
			                允许装备列表.includes(装备.类型)
			            ) {
			                if (!this.消耗能量()) {
			                    显示通知("能量不足！", "错误");
			                    return false;
			                }
			                let 成功附魔 = false;
			                装备.自定义数据
			                    .get("附魔")
			                    .forEach((item, index, arr) => {
			                        if (
			                            item.种类 === 附魔种类 &&
			                            item.等级 < this.品质
			                        ) {
			                            arr[index] = {
			                                种类: 附魔种类,
			                                等级: this.品质,
			                            };
			                            成功附魔 = true;
			                        }
			                    });
			                if (!成功附魔) {
			                    装备.自定义数据
			                        .get("附魔")
			                        .push({ 种类: 附魔种类, 等级: this.品质 });
			                }
			                return true;
			            }
			        }
			        return false;
			    }
			    播放附魔特效(装备, 弹窗, 装备元素) {
			        const 装备位置 = 装备元素.getBoundingClientRect();
			        const 中心X = 装备位置.left + 装备位置.width / 2;
			        const 中心Y = 装备位置.top + 装备位置.height / 2;
			
			        const 特效容器 = document.createElement("div");
			        特效容器.style = `
			        position: fixed;
			        left: ${中心X}px;
			        top: ${中心Y}px;
			        pointer-events: none;
			        z-index: 10001;
			        `;
			
			        document.body.appendChild(特效容器);
			
			        const 粒子数 = 12;
			
			        const 基础色相 = 260;
			
			        for (let i = 0; i < 粒子数; i++) {
			            const 粒子 = document.createElement("div");
			            粒子.className = "魔幻粒子";
			
			            const 角度 = prng() * Math.PI * 2;
			            const 距离 = 120 + prng() * 80;
			            const 目标X = Math.cos(角度) * 距离;
			            const 目标Y = Math.sin(角度) * 距离;
			            const 大小 = 12 + prng() * 16;
			            const 旋转 = prng() * 720;
			            const 色相偏移 = (prng() - 0.5) * 40;
			            const 亮度曲线 = 60 + prng() * 30;
			
			            粒子.style = `
			        --target-x: ${目标X}px;
			        --target-y: ${目标Y}px;
			        --size: ${大小}px;
			        --hue: ${基础色相 + 色相偏移};
			        transform: translateZ(0);
			        --lightness: ${亮度曲线}%;
			        --rotate: ${旋转}deg;
			        --delay: ${prng() * 0.4}s;
			        `;
			
			            特效容器.appendChild(粒子);
			        }
			
			        setTimeout(() => 特效容器.remove(), 2000);
			    }
			}
			class 易位卷轴 extends 卷轴类 {
			    constructor(配置) {
			        super({
			            名称: "易位卷轴",
			            品质: 4,
			            效果描述: "启用后，在画面中点选一个单位，与它互换位置。",
			            能量消耗: 55,
			            ...配置
			        });
			    }
			
			    使用() {
			        if (!this.消耗能量()) return false;
			        if (生存挑战激活) {
			        显示通知("强大的结界阻止了传送！", "错误");
			        //关闭传送菜单();
			        return false;
			    }
			        显示通知("请在地图上点击要交换位置的目标。", "信息", true);
			        物品点击监听器 = (clientX, clientY) => {
			            const rect = canvas.getBoundingClientRect();
			            const x = clientX - rect.left;
			            const y = clientY - rect.top;
			            const gridX = Math.floor(视口偏移X + x / 单元格大小);
			            const gridY = Math.floor(视口偏移Y + y / 单元格大小);
			
			            if (!检查视线(玩家.x, 玩家.y, gridX, gridY)) {
			                显示通知("目标不在视线范围内！", "错误");
			            }
			
			            const 目标单元格 = 地牢[gridY]?.[gridX];
			            const 目标实体 = 目标单元格?.关联怪物 || 目标单元格?.关联物品 || 当前出战宠物列表.some(p => p.x === gridX && p.y === gridY);
			
			            if (目标实体 && 目标实体 !== 玩家 && 目标实体.类型!=='楼梯') {
			                const 玩家旧X = 玩家.x;
			                const 玩家旧Y = 玩家.y;
			                const 目标旧X = 目标实体.x;
			                const 目标旧Y = 目标实体.y;
			                let isPlayerSpotValid = false;
			                if (目标实体 instanceof 怪物) {
			                    isPlayerSpotValid = 目标实体.位置合法(玩家旧X, 玩家旧Y);
			                    if (目标实体 instanceof 巨人怪物 || 目标实体 instanceof 巨人部位 || 目标实体 instanceof 蜈蚣怪物 || 目标实体 instanceof 蜈蚣部位) {
			                        const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            if (能量条)
			                能量条.style.width = `${Math.min(
			                    100,
			                    当前能量 + this.自定义数据.get("能量消耗")/自定义全局设置.初始能量值*100
			                )}%`;
			            触发HUD显示();
			                    显示通知("无法交换：目标无法移动到你的位置！", "错误");
			                return true;
			                    }
			                } else {
			                    isPlayerSpotValid = 位置是否可用(玩家旧X, 玩家旧Y, false);
			                }
			
			                if (isPlayerSpotValid) {
			                    if (目标实体 instanceof 怪物) {
			                        目标实体.恢复背景类型();
			                    } else if (目标实体 instanceof 物品) {
			                        if(地牢[目标旧Y][目标旧X].关联物品 === 目标实体) {
			                            地牢[目标旧Y][目标旧X].关联物品 = null;
			                            地牢[目标旧Y][目标旧X].类型 = null;
			                        }
			                    }
			
			                    玩家.x = 目标旧X;
			                    玩家.y = 目标旧Y;
			                    处理玩家着陆效果(玩家旧X,玩家旧Y,玩家.x,玩家.y)
			                    目标实体.x = 玩家旧X;
			                    目标实体.y = 玩家旧Y;
			                    
			                    if (目标实体 instanceof 怪物) {
			                        目标实体.保存新位置类型(玩家旧X, 玩家旧Y);
			                        地牢[玩家旧Y][玩家旧X].类型 = 单元格类型.怪物;
			                        地牢[玩家旧Y][玩家旧X].关联怪物 = 目标实体;
			                    } else if (目标实体 instanceof 物品) {
			                         地牢[玩家旧Y][玩家旧X].类型 = 单元格类型.物品;
			                         地牢[玩家旧Y][玩家旧X].关联物品 = 目标实体;
			                    }
			
			                    显示通知(`与 ${目标实体.名称 || 目标实体.类型} 交换了位置！`, "成功");
			                    
			                    更新背包显示();
			                    更新装备显示();
			                    更新视口();
			                    
			                } else {
			                    const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            if (能量条)
			                能量条.style.width = `${Math.min(
			                    100,
			                    当前能量 + this.自定义数据.get("能量消耗")/自定义全局设置.初始能量值*100
			                )}%`;
			            触发HUD显示();
			                    显示通知("无法交换：目标无法移动到你的位置！", "错误");
			                }
			            } else {
			                const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            if (能量条)
			                能量条.style.width = `${Math.min(
			                    100,
			                    当前能量 + this.自定义数据.get("能量消耗")/自定义全局设置.初始能量值*100
			                )}%`;
			            触发HUD显示();
			                显示通知("无效的目标！", "错误");
			            }
			            物品点击监听器 = null;
			            当前激活卷轴列表.delete(this);
			            更新装备显示();
			        };
			        return true;
			    }
			}
			class 跃迁卷轴 extends 卷轴类 {
			    constructor(配置) {
			        super({
			            名称: "跃迁卷轴",
			            品质: 3,
			            效果描述: "随机传送到未访问房间，并解锁目标房间所有门",
			            强化: 配置.强化 || false,
			            能量消耗: 70,
			            已解锁: 配置.已解锁 || false,
			        });
			    }
			
			    使用() {
			        if (!this.消耗能量()) return false;
			
			        const 当前玩家房间ID = 房间地图[玩家.y][玩家.x];
			        if (当前玩家房间ID !== -1) {
			            const 当前玩家所在房间 = 房间列表.find(t=>t.id==当前玩家房间ID);
			            if (
			                当前玩家所在房间 &&
			                当前玩家所在房间.类型 === "挑战房间" &&
			                当前玩家所在房间.挑战状态 &&
			                当前玩家所在房间.挑战状态.进行中
			            ) {
			                处理挑战失败(当前玩家所在房间);
			            }
			        }
			        if (生存挑战激活) {
			            显示通知("强大的结界阻止了空间传送！", "错误");
			            return false;
			        }
			        if (当前层数 % 5 === 0 && 当前层数>0) {
			            显示通知('当前地牢无法使用跃迁卷轴','错误');
			            return false;
			        }
			        const 有效房间 = 房间列表.filter(
			            (r) =>
			                r.id !== 房间地图[玩家.y][玩家.x] &&
			                !已访问房间.has(r.id)
			        );
			
			        let 目标房间;
			        if (有效房间.length > 0) {
			            目标房间 =
			                有效房间[
			                    Math.floor(prng() * 有效房间.length)
			                ];
			        } else {
			            const 所有可选房间 = 房间列表.filter(
			                (r) => r.id !== 房间地图[玩家.y][玩家.x]
			            );
			            if (所有可选房间.length > 0) {
			                目标房间 =
			                    所有可选房间[
			                        Math.floor(
			                            prng() * 所有可选房间.length
			                        )
			                    ];
			                显示通知(
			                    "没有可传送的未访问房间，随机传送。",
			                    "警告"
			                );
			            } else {
			                显示通知("没有可传送的房间。", "错误");
			                return false;
			            }
			        }
			
			        门实例列表.forEach((门) => {
			            if (门.房间ID === 目标房间.id) {
			                地牢[门.所在位置.y][门.所在位置.x].背景类型 =
			                    单元格类型.门;
			            }
			        });
			
			        玩家.x = 目标房间.x + Math.floor(目标房间.w / 2);
			        玩家.y = 目标房间.y + Math.floor(目标房间.h / 2);
			        已访问房间.add(目标房间.id);
			        更新视口();
			        绘制();
			        处理怪物回合();
			        显示通知(
			            `一阵风刮来，被传送到了 ${目标房间.id} 号房间`,
			            "成功"
			        );
			        当前激活卷轴列表.delete(this);
			
			        return true;
			    }
			}
			
			class 真言卷轴 extends 卷轴类 {
    constructor(配置) {
        super({
            名称: "真言卷轴",
            图标: 图标映射.真言卷轴,
            品质: 4,
            强化: 配置.强化 || false,
            效果描述: "揭示装备中所有卷轴的奥秘，每个卷轴消耗30能量。有使用次数限制。", // 效果描述已更新
            能量消耗: 30,
            已解锁: 配置.已解锁 || false,
            最大堆叠数量: 1, // 增加此项，确保不可堆叠
            数据: {
                // 核心改动：增加耐久度
                耐久: 配置.耐久 || 3 + (配置.强化 ? 2 : 0), // 普通3次，强化后5次
                原耐久: 3 + (配置.强化 ? 2 : 0),
            },
        });
    }

    使用() {
        // 1. 使用前检查耐久度
        if (this.自定义数据.get("耐久") <= 0) {
            显示通知(`${this.获取名称()} 的魔力已经耗尽！`, "错误");
            return false;
        }

        const 能量条 = document.querySelector(".power-bar");
        let 当前能量 = Math.max(
            Math.min(parseFloat(能量条.style.width), 100),
            0
        );

        let 解密数量 = 0;
        const 每次解密消耗 = 30;

        // 查找所有装备中未解锁的卷轴
        const 待解密卷轴 = [];
        Array.from({ length: 装备栏每页装备数 }, (_, i) =>
            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
        )
            .filter((v) => v != null)
            .forEach((item) => {
                if (
                    item instanceof 卷轴类 &&
                    !item.自定义数据.get("已解锁")
                ) {
                    待解密卷轴.push(item);
                }
            });

        // 如果没有可解密的卷轴，则不消耗耐久
        if (待解密卷轴.length === 0) {
            显示通知("没有可解密的卷轴。", "信息");
            return false;
        }

        // 尝试解密
        待解密卷轴.forEach((item) => {
            if (当前能量 >= 每次解密消耗) {
                当前能量 -= 每次解密消耗;
                item.自定义数据.set("已解锁", true);
                解密数量++;
            }
        });

        // 只有成功解密了至少一个卷轴，才消耗耐久和能量
        if (解密数量 > 0) {
            扣除能量(
                Math.max(
                    Math.min(parseFloat(document.querySelector(".power-bar").style.width), 100),
                    0
                ) - 当前能量
            );

            // 2. 使用后消耗耐久
            const newDurability = this.自定义数据.get("耐久") - 1;
            this.自定义数据.set("耐久", newDurability);

            显示通知(`解密了 ${解密数量} 个神秘卷轴！`, "成功");

            // 3. 如果耐久耗尽，则销毁物品
            if (newDurability <= 0) {
                显示通知(`${this.获取名称()} 的魔力耗尽，化为了灰烬。`, "警告");
                处理销毁物品(this.唯一标识, true);
            }
        } else {
            显示通知(`能量不足，无法解密卷轴。`, "错误");
            return false; // 能量不足，不消耗耐久
        }
        当前激活卷轴列表.delete(this);
        更新装备显示();
        更新背包显示();

        return true;
    }

    获取提示() {
        if (this.自定义数据.get("已解锁")) {
            // 4. 更新提示信息以显示耐久度
            const lines = super.获取提示().split('\n');
            const effectIndex = lines.findIndex(line => line.startsWith('效果描述：'));
            
            // 在效果描述前插入耐久度信息
            if (effectIndex !== -1) {
                lines.splice(effectIndex, 0, `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`);
            } else {
                lines.push(`耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`);
            }
            return lines.join('\n');
        } else {
            return "布满古老符文的卷轴，散发着神秘能量...";
        }
    }
}
			class 恐惧魔杖 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "恐惧魔杖",
			            图标: 图标映射.恐惧魔杖,
			            品质: 3,
			            基础攻击力: 1,
			            冷却回合: 5,
			            攻击范围: 4,
			            耐久: 配置?.耐久 || 40,
			            强化: 配置?.强化 || false,
			            效果描述: "使周围的非首领怪物陷入恐惧，远离施法者。",
			            攻击目标数: 99,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                恐惧持续时间: 3 + (配置?.强化 ? 2 : 0),
			                ...配置.数据,
			            },
			        });
			    }
			
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			
			        let 影响怪物数量 = 0;
			        const 范围 = this.最终攻击范围;
			        const 恐惧持续 = this.自定义数据.get("恐惧持续时间");
			        const 影响格子特效 = [];
			
			        for (let dx = -范围; dx <= 范围; dx++) {
			            for (let dy = -范围; dy <= 范围; dy++) {
			                const x = 使用者.x + dx;
			                const y = 使用者.y + dy;
			
			                if (
			                    x >= 0 &&
			                    x < 地牢大小 &&
			                    y >= 0 &&
			                    y < 地牢大小
			                ) {
			                    const 单元格 = 地牢[y][x];
			                    if (
			                        单元格?.关联怪物 &&
			                        单元格.关联怪物.当前生命值 > 0 &&
			                        !(单元格.关联怪物 instanceof 大魔法师) &&
			                        单元格.关联怪物.状态 === 怪物状态.活跃
			                    ) {
			                        if (检查视线(使用者.x, 使用者.y, x, y, 范围)) {
			                            const 怪物 = 单元格.关联怪物;
			                            new 状态效果(
			                                "恐惧",
			                                效果颜色编号映射[
			                                    效果名称编号映射.恐惧
			                                ],
			                                图标映射.恐惧,
			                                恐惧持续,
			                                null,
			                                null,
			                                怪物,
			                                1
			                            );
			                            影响怪物数量++;
			                            影响格子特效.push({ x, y });
			                        }
			                    }
			                }
			            }
			        }
			
			        if (影响格子特效.length > 0) {
			            计划显示格子特效(
			                影响格子特效,
			                效果颜色编号映射[效果名称编号映射.恐惧].slice(1),
			                50
			            );
			        }
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set("冷却剩余", this.最终冷却回合);
			
			        if (影响怪物数量 > 0) {
			            显示通知(
			                `${this.名称} 使 ${影响怪物数量} 个怪物陷入恐惧！`,
			                "成功"
			            );
			        } else {
			            显示通知(`${this.名称} 未影响任何目标。`, "信息");
			        }
			        更新装备显示();
			        return 影响怪物数量 > 0 ? 1 : 0;
			    }
			
			    获取提示() {
			        let lines = super.获取提示().split("\n");
			        const specificEffectLines = [
			            `恐惧范围：周围 ${this.最终攻击范围} 格`,
			            `恐惧持续：${this.自定义数据.get("恐惧持续时间")} 回合`,
			        ];
			        const effectDescIndex = lines.findIndex((line) =>
			            line.startsWith("效果描述：")
			        );
			        let insertAtIndex =
			            effectDescIndex !== -1
			                ? effectDescIndex + 1
			                : lines.findIndex((line) =>
			                      line.startsWith("--- 强化效果 ---")
			                  );
			        if (insertAtIndex === -1) insertAtIndex = lines.length;
			
			        lines.splice(insertAtIndex, 0, ...specificEffectLines);
			        return lines.filter(Boolean).join("\n");
			    }
			}
			let 调试输入数据 = null;
			let 调试无限生命 = false;
			let 调试无限能量 = false;
			            class 调试工具 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "工具",
			            名称: "调试工具",
			            图标: 图标映射.调试工具,
			            品质: 5,
			            颜色索引: 4,
			            最大堆叠数量: 1,
			            效果描述: "打开调试命令输入界面。",
			            数据: {},
			            ...配置,
			        });
			    }
			
			    使用() {
			        this.打开调试输入界面();
			        return true;
			    }
			
			    打开调试输入界面() {
			        if (界面可见性.背包) 切换背包显示();
			        玩家属性.允许移动++;
			
			        const 现有遮罩 = document.getElementById("调试输入遮罩");
			        if (现有遮罩) 现有遮罩.remove();
			
			        const 遮罩 = document.createElement("div");
			        遮罩.id = "调试输入遮罩";
			        遮罩.style.cssText = `
			            position: fixed; top: 0; left: 0; width: 100vw; height: 92vh;
			            background: rgba(0,0,0,0.75); z-index: 20000; display: flex;
			            align-items: center; justify-content: center; backdrop-filter: blur(5px);
			        `;
			
			        const 弹窗 = document.createElement("div");
			        弹窗.id = "调试输入弹窗";
			        弹窗.style.cssText = `
			            background: #2a2a2a; color: #e0e0e0; padding: 25px; border-radius: 12px;
			            box-shadow: 0 5px 25px rgba(0,0,0,0.6); display: flex; flex-direction: column;
			            gap: 15px; width: 90%; max-width: 600px; border: 1px solid #4caf50; max-height: 90vh; overflow-y: scroll;
			        `;
			
			        const 顶栏 = document.createElement("div");
			        顶栏.style.cssText = "display: flex; justify-content: space-between; align-items: center; padding-bottom: 15px; border-bottom: 1px solid #444;";
			
			        const 标题 = document.createElement("h3");
			        标题.textContent = "调试工具";
			        标题.style.cssText = "color: #4caf50; text-align: center; margin: 0; flex-grow: 1;";
			
			        const 关闭按钮 = document.createElement("button");
			        关闭按钮.textContent = "×";
			        关闭按钮.className = "关闭按钮";
			        关闭按钮.style.fontSize = "1.5em";
			        关闭按钮.style.color = "#aaa";
			        关闭按钮.style.padding = "0 8px";
			
			        顶栏.appendChild(标题);
			        顶栏.appendChild(关闭按钮);
			
			        const 功能按钮容器 = document.createElement("div");
			        功能按钮容器.style.cssText = "display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; padding-bottom: 10px; border-bottom: 1px dashed #444;";
			
			        const 无限生命按钮 = document.createElement("button");
			        无限生命按钮.id = "debug-godmode-btn";
			        无限生命按钮.className = "菜单按钮";
			        无限生命按钮.textContent = 调试无限生命 ? "无限生命: 开" : "无限生命: 关";
			        if (调试无限生命) 无限生命按钮.style.borderColor = "#FFD700";
			
			        const 无限能量按钮 = document.createElement("button");
			        无限能量按钮.id = "debug-infenergy-btn";
			        无限能量按钮.className = "菜单按钮";
			        无限能量按钮.textContent = 调试无限能量 ? "无限能量: 开" : "无限能量: 关";
			        if (调试无限能量) 无限能量按钮.style.borderColor = "#2196F3";
			
			        [无限生命按钮, 无限能量按钮].forEach(btn => {
			            btn.style.padding = "8px 15px";
			            btn.style.fontSize = "0.9em";
			            btn.style.minWidth = "auto";
			            btn.style.margin = "0";
			        });
			
			        功能按钮容器.appendChild(无限生命按钮);
			        功能按钮容器.appendChild(无限能量按钮);
			
			        const GUI容器 = document.createElement("div");
			        GUI容器.style.cssText = "display: flex; flex-direction: column; gap: 15px;";
			
			        const 创建选择器区域 = (标签文本, selectId, propEditorId, ...buttons) => {
			            const 区域 = document.createElement("div");
			            区域.style.cssText = "display: flex; flex-direction: column; gap: 10px;";
			
			            const 顶行 = document.createElement("div");
			            顶行.style.cssText = "display: flex; align-items: center; gap: 10px;";
			
			            const 标签 = document.createElement("label");
			            标签.textContent = 标签文本;
			            标签.style.flexShrink = "0";
			
			            const 选择框 = document.createElement("select");
			            选择框.id = selectId;
			            选择框.style.cssText = `
			                flex-grow: 1; background: #1e1e1e; color: #e0e0e0;
			                border: 1px solid #444; border-radius: 5px; padding: 8px;
			            `;
			
			            顶行.appendChild(标签);
			            顶行.appendChild(选择框);
			            区域.appendChild(顶行);
			
			            const 属性编辑器容器 = document.createElement("div");
			            属性编辑器容器.id = propEditorId;
			            属性编辑器容器.style.cssText = `
			                display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;
			                background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-top: -5px;
			            `;
			            区域.appendChild(属性编辑器容器);
			
			            const 按钮行 = document.createElement("div");
			            按钮行.style.cssText = "display: flex; gap: 10px; flex-wrap: wrap; justify-content: flex-start;";
			
			            buttons.forEach(btnConfig => {
			                const 按钮 = document.createElement("button");
			                按钮.id = btnConfig.id;
			                按钮.textContent = btnConfig.text;
			                按钮.className = "菜单按钮";
			                按钮.style.cssText = "padding: 8px 15px; font-size: 0.9em; min-width: auto; margin: 0;";
			                按钮行.appendChild(按钮);
			            });
			            区域.appendChild(按钮行);
			            return 区域;
			        };
			
			        const 物品选择区 = 创建选择器区域("物品:", "debug-item-select", "debug-item-prop-editor",
			            {id: "debug-give-item-btn", text: "给予"},
			            {id: "debug-spawn-item-btn", text: "在脚下生成"}
			        );
			        const 怪物选择区 = 创建选择器区域("怪物:", "debug-monster-select", "debug-monster-prop-editor",
			            {id: "debug-spawn-monster-btn", text: "在脚下生成"}
			        );
			
			        GUI容器.appendChild(物品选择区);
			        GUI容器.appendChild(怪物选择区);
			
			        const 分隔符 = document.createElement("div");
			        分隔符.textContent = "手动输入命令";
			        分隔符.style.cssText = "text-align: center; color: #888; margin: -5px 0;";
			
			        const 命令容器 = document.createElement("div");
			        命令容器.style.cssText = "display: flex; align-items: stretch; gap: 10px;";
			
			        const 命令输入框 = document.createElement("textarea");
			        命令输入框.id = "调试命令输入框";
			        命令输入框.placeholder = '放置物品:{"类名":"钢制长剑"}';
			        命令输入框.style.cssText = `
			            flex-grow: 1; min-height: 60px; background: #1e1e1e; color: #e0e0e0;
			            border: 1px solid #444; border-radius: 5px; padding: 10px; font-family: monospace;
			            resize: vertical;
			        `;
			
			        const 执行命令按钮 = document.createElement("button");
			        执行命令按钮.textContent = "执行";
			        执行命令按钮.className = "菜单按钮";
			        执行命令按钮.style.flexShrink = "0";
			
			        命令容器.appendChild(命令输入框);
			        命令容器.appendChild(执行命令按钮);
			
			        弹窗.appendChild(顶栏);
			        弹窗.appendChild(功能按钮容器);
			        弹窗.appendChild(GUI容器);
			        弹窗.appendChild(分隔符);
			        弹窗.appendChild(命令容器);
			
			        遮罩.appendChild(弹窗);
			        document.body.appendChild(遮罩);
			
			        const { items: allItems, monsters: allMonsters } = 获取所有可用的定义();
			
			        const 填充选择框 = (selectId, definitions, isMonster = false) => {
			            const 选择框 = document.getElementById(selectId);
			            const 选项 = [];
			            definitions.forEach(cfg => {
			                try {
			                    const 实例 = new cfg.类({});
			                    const text = isMonster ? 实例.类型 : 实例.名称;
			                    if (实例 && text) {
			                        选项.push({ text: text, value: cfg.类.name });
			                    }
			                } catch (e) {}
			            });
			
			            [...new Map(选项.map(item => [item.value, item])).values()]
			                .sort((a,b) => a.text.localeCompare(b.text, 'zh-Hans-CN'))
			                .forEach(opt => {
			                    const optionElement = document.createElement("option");
			                    optionElement.value = opt.value;
			                    optionElement.textContent = opt.text;
			                    选择框.appendChild(optionElement);
			                });
			        };
			
			        填充选择框("debug-item-select", allItems, false);
			        填充选择框("debug-monster-select", allMonsters, true);
			
			        const 创建字段 = (key, value, type = 'text') => {
			            const fieldWrapper = document.createElement('div');
			            fieldWrapper.style.cssText = `display: flex; align-items: center; gap: 5px; justify-content: space-between;`;
			
			            const label = document.createElement('label');
			            label.textContent = key;
			            label.style.cssText = 'font-size: 0.8em; color: #aaa; flex-shrink: 0;';
			
			            let input;
			            if (type === 'checkbox') {
			                input = document.createElement('input');
			                input.type = 'checkbox';
			                input.checked = !!value;
			                input.style.cssText = 'margin: 0; transform: scale(0.9);';
			            } else {
			                input = document.createElement('input');
			                input.type = type;
			                input.value = value;
			                input.style.cssText = 'background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 5px; width: 60%;';
			            }
			            input.id = `debug-prop-${key}`;
			
			            fieldWrapper.appendChild(label);
			            fieldWrapper.appendChild(input);
			            return fieldWrapper;
			        };
			
			        const 生成属性编辑器 = (itemClass, editorContainerId) => {
			            const editorContainer = document.getElementById(editorContainerId);
			            editorContainer.innerHTML = '';
			            if (!itemClass) return;
			
			            const tempInstance = new itemClass({});
			            editorContainer.appendChild(创建字段('强化', tempInstance.强化, 'checkbox'));
			
			            if (tempInstance instanceof 物品 && !(tempInstance instanceof 怪物)) {
			                editorContainer.appendChild(创建字段('品质', tempInstance.品质, 'number'));
			            }
			            if (tempInstance instanceof 武器类 || tempInstance instanceof 防御装备类) {
			                editorContainer.appendChild(创建字段('耐久', tempInstance.自定义数据.get('耐久'), 'number'));
			                editorContainer.appendChild(创建字段('不可破坏', tempInstance.自定义数据.get('不可破坏'), 'checkbox'));
			            }
			            if (tempInstance instanceof 武器类) {
			               editorContainer.appendChild(创建字段('基础攻击力', tempInstance.自定义数据.get('基础攻击力'), 'number'));
			               editorContainer.appendChild(创建字段('冷却回合', tempInstance.自定义数据.get('冷却回合'), 'number'));
			            }
			             if (tempInstance instanceof 防御装备类) {
			               editorContainer.appendChild(创建字段('防御力', tempInstance.自定义数据.get('防御力'), 'number'));
			            }
			            if (tempInstance instanceof 药水类) {
			                editorContainer.appendChild(创建字段('效果强度', tempInstance.自定义数据.get('效果强度'), 'number'));
			                editorContainer.appendChild(创建字段('基础持续时间', tempInstance.自定义数据.get('基础持续时间'), 'number'));
			            }
			             if (tempInstance instanceof 卷轴类) {
			               editorContainer.appendChild(创建字段('已解锁', tempInstance.自定义数据.get('已解锁'), 'checkbox'));
			            }
			            if (tempInstance instanceof 怪物) {
			                editorContainer.appendChild(创建字段('基础生命值', tempInstance.基础生命值, 'number'));
			                editorContainer.appendChild(创建字段('基础攻击力', tempInstance.基础攻击力, 'number'));
			            }
			        };
			
			        const itemSelect = document.getElementById('debug-item-select');
			        itemSelect.onchange = () => {
			            const className = itemSelect.value;
			            const ItemClass = window[className];
			            生成属性编辑器(ItemClass, 'debug-item-prop-editor');
			        };
			        生成属性编辑器(window[itemSelect.value], 'debug-item-prop-editor');
			
			        const monsterSelect = document.getElementById('debug-monster-select');
			        monsterSelect.onchange = () => {
			            const className = monsterSelect.value;
			            const MonsterClass = window[className];
			            生成属性编辑器(MonsterClass, 'debug-monster-prop-editor');
			        };
			        生成属性编辑器(window[monsterSelect.value], 'debug-monster-prop-editor');
			
			        const 获取编辑器配置 = (editorId) => {
			            const config = {};
			            const dataConfig = {};
			            const propInputs = document.querySelectorAll(`#${editorId} input`);
			            propInputs.forEach(input => {
			                const key = input.id.replace('debug-prop-', '');
			                const value = input.type === 'checkbox' ? input.checked : (isNaN(parseFloat(input.value)) ? input.value : parseFloat(input.value));
			
			                const dataKeys = ['耐久', '基础攻击力', '防御力', '冷却回合', '效果强度', '基础持续时间', '不可破坏', '已解锁', '基础生命值'];
			                if (dataKeys.includes(key)) {
			                    dataConfig[key] = value;
			                } else {
			                    config[key] = value;
			                }
			            });
			            if (Object.keys(dataConfig).length > 0) {
			                config.数据 = dataConfig;
			            }
			            return config;
			        };
			
			        const 关闭调试界面 = () => {
			            遮罩.remove();
			            玩家属性.允许移动--;
			            玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
			        };
			
			        无限生命按钮.onclick = () => {
			            调试无限生命 = !调试无限生命;
			            无限生命按钮.textContent = 调试无限生命 ? "无限生命: 开" : "无限生命: 关";
			            无限生命按钮.style.borderColor = 调试无限生命 ? "#FFD700" : "";
			            if(调试无限生命) document.querySelector(".health-bar").style.width = "100%";
			        };
			
			        无限能量按钮.onclick = () => {
			            调试无限能量 = !调试无限能量;
			            无限能量按钮.textContent = 调试无限能量 ? "无限能量: 开" : "无限能量: 关";
			            无限能量按钮.style.borderColor = 调试无限能量 ? "#2196F3" : "";
			             if(调试无限能量) document.querySelector(".power-bar").style.width = "100%";
			        };
			
			        document.getElementById("debug-give-item-btn").onclick = () => {
			            const 类名 = document.getElementById("debug-item-select").value;
			            const 属性 = 获取编辑器配置('debug-item-prop-editor');
			            const 命令 = `给予物品:{"类名":"${类名}", "属性": ${JSON.stringify(属性)}}`;
			            命令输入框.value = 命令;
			            this.解析并执行命令(命令);
			        };
			
			        document.getElementById("debug-spawn-item-btn").onclick = () => {
			            const 类名 = document.getElementById("debug-item-select").value;
			            const 属性 = 获取编辑器配置('debug-item-prop-editor');
			            const 命令 = `放置物品:{"类名":"${类名}", "属性": ${JSON.stringify(属性)}}`;
			            命令输入框.value = 命令;
			            this.解析并执行命令(命令);
			        };
			
			        document.getElementById("debug-spawn-monster-btn").onclick = () => {
			            const 类名 = document.getElementById("debug-monster-select").value;
			            const 属性 = 获取编辑器配置('debug-monster-prop-editor');
			            const 命令 = `放置怪物:{"类名":"${类名}", "属性": ${JSON.stringify(属性)}}`;
			            命令输入框.value = 命令;
			            this.解析并执行命令(命令);
			        };
			
			        执行命令按钮.onclick = () => {
			            const 命令文本 = 命令输入框.value.trim();
			            if (命令文本) {
			                this.解析并执行命令(命令文本);
			            }
			        };
			
			        关闭按钮.onclick = 关闭调试界面;
			
			        命令输入框.focus();
			    }
			
			    解析并执行命令(命令文本) {
			        const [命令类型, ...参数部分] = 命令文本.split(":");
			        const 参数字符串 = 参数部分.join(":").trim();
			
			        try {
			            const 配置JSON = JSON.parse(参数字符串);
			            const 类名 = 配置JSON.类名;
			            const 属性 = 配置JSON.属性 || {};
			            const 类构造器 = window[类名];
			            let 新实例 = null
			
			            if (类构造器 && typeof 类构造器 === 'function') {
			                
			            新实例 = new 类构造器({});
			
			            if (!新实例.自定义数据) {
			                新实例.自定义数据 = new Map();
			            }
			
			            for (const [键, 值] of Object.entries(属性)) {
			                if (键 === '数据' && typeof 值 === 'object' && 值 !== null) {
			                    for (const [数据键, 数据值] of Object.entries(值)) {
			                        新实例.自定义数据.set(数据键, 数据值);
			                        if(数据键 === '基础生命值' && 新实例 instanceof 怪物) 新实例.当前生命值 = 数据值;
			                    }
			                } else {
			                    新实例[键] = 值;
			                    if(键 === '基础生命值' && 新实例 instanceof 怪物) 新实例.当前生命值 = 值;
			                }
			            }
			            }
			
			            switch (命令类型.trim().toLowerCase()) {
			                case "给予物品":
			                    if (尝试收集物品(新实例, true)) {
			                        显示通知(`已给予 ${新实例.获取名称()}`, "成功");
			                    }
			                    break;
			                case "放置物品":
			                    if (放置物品到单元格(新实例, 玩家.x, 玩家.y)) {
			                        显示通知(`成功放置 ${新实例.获取名称()}`, "成功");
			                    } else {
			                        显示通知(`无法在当前位置放置 ${类名}`, "错误");
			                    }
			                    break;
			                case "放置怪物":
			                    新实例.状态 = 怪物状态.活跃;
			                    if (放置怪物到单元格(新实例, 玩家.x, 玩家.y)) {
			                        显示通知(`成功放置 ${新实例.类型}`, "成功");
			                    } else {
			                        显示通知(`无法在当前位置放置 ${类名}`, "错误");
			                    }
			                    break;
			                case "切换楼层":
			                    const 目标层数 = parseInt(参数字符串);
			                    if (!isNaN(目标层数)) {
			                        切换楼层(目标层数);
			                        显示通知(`已切换到楼层 ${目标层数}`, "成功");
			                    } else {
			                        显示通知("无效的楼层号", "错误");
			                    }
			                    break;
			                default:
			                    显示通知("未知的调试命令", "错误");
			            }
			        } catch (错误) {
			            console.error("调试命令解析或执行错误:", 错误);
			            显示通知(`命令错误: ${错误.message}`, "错误");
			        }
			    }
			
			    获取提示() {
			        return `${this.获取名称()}\n类型：${
			            this.类型
			        }\n品质：${"★".repeat(this.品质)}\n效果：${this.效果描述}`;
			    }
			}
			class 磁铁 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "磁铁",
			            图标: 图标映射.磁铁,
			            品质: 3,
			            颜色索引: 2,
			            效果描述: "吸取周围3x3范围内的可拾取物品。",
			            基础攻击力: 0,
			            冷却回合: 4,
			            攻击范围: 0,
			            攻击目标数: 0,
			            耐久: 配置?.耐久 || 40,
			            原耐久: 配置?.耐久 || 40,
			            强化: 配置?.强化 || false,
			            数据: {
			                能量消耗: 25 - (配置.强化 ? 10 : 0),
			                吸取范围: 3,
			            },
			            ...配置,
			        });
			        if (this.强化) {
			            this.自定义数据.set('吸取范围', 5);
			            this.效果描述 = "吸取周围5x5范围内的可拾取物品。";
			        }
			    }
			
			    使用(目标怪物列表, 目标路径, 使用者 = 玩家) {
			        if (this.自定义数据.get("冷却剩余") > 0) {
			            显示通知("磁力还未充能完毕！", "警告");
			            return false;
			        }
			        if (this.自定义数据.get("耐久") <= 0) {
			            显示通知("磁铁的魔力已经耗尽。", "错误");
			            return false;
			        }
			        if (!扣除能量(this.自定义数据.get("能量消耗"))) {
			            显示通知("能量不足，无法激活磁铁！", "错误");
			            return false;
			        }
			
			        const 范围 = this.自定义数据.get('吸取范围');
			        const 半径 = Math.ceil(范围 / 2);
			        let 成功吸取数量 = 0;
			        const 待吸取物品列表 = [];
			
			        for (let dy = -半径; dy <= 半径; dy++) {
			            for (let dx = -半径; dx <= 半径; dx++) {
			                if (dx === 0 && dy === 0) continue;
			
			                const x = 使用者.x + dx;
			                const y = 使用者.y + dy;
			
			                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
			
			                const 单元格 = 地牢[y]?.[x];
			                const 物品实例 = 单元格?.关联物品;
			                const 距离 = Math.abs(dx) + Math.abs(dy);
			
			                if (物品实例 && 物品实例.能否拾起 && 检查视线(使用者.x, 使用者.y, x, y, 范围 + 1)) {
			                    待吸取物品列表.push({ 物品: 物品实例, 单元格: 单元格, 距离: 距离 });
			                }
			            }
			        }
			
			        待吸取物品列表.sort((a, b) => a.距离 - b.距离);
			
			        if (待吸取物品列表.length === 0) {
			            显示通知("周围没有可吸取的物品。", "信息");
			            const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            能量条.style.width = `${Math.min(100, 当前能量 + this.自定义数据.get("能量消耗")/自定义全局设置.初始能量值*100)}%`;
			            return false;
			        }
			
			        this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
			        if (this.自定义数据.get("耐久") <= 0) {
			            setTimeout(() => 处理销毁物品(this.唯一标识, true), 待吸取物品列表.length * 100 + 300);
			        }
			        this.自定义数据.set("冷却剩余", this.最终冷却回合);
			        更新装备显示();
			
			        const 动画延迟 = typeof gsap !== 'undefined' ? 100 : 0;
			        const 吸取间隔 = 45;
			        玩家属性.允许移动++;
			        const 吸取下一个物品 = (索引) => {
			            if (索引 >= 待吸取物品列表.length) {
			                if (成功吸取数量 > 0) {
			                    显示通知(`磁铁吸取了 ${成功吸取数量} 个物品！`, "成功");
			                }
			                if (this.自定义数据.get("耐久") <= 0) {
			                    显示通知(`${this.名称} 已损坏！`, "警告");
			                }
			                玩家属性.允许移动--
			                return;
			            }
			
			            const 当前物品数量 = [...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0);
			            if (当前物品数量 >= 最大背包容量 && ![...玩家背包.values()].some(i => i.可堆叠于(待吸取物品列表[索引].物品))) {
			                if (成功吸取数量==0) {
			                    const 能量条 = document.querySelector(".power-bar");
			                    const 当前能量 = parseFloat(能量条.style.width) || 0;
			                    能量条.style.width = `${Math.min(100, 当前能量 + this.自定义数据.get("能量消耗")/自定义全局设置.初始能量值*100)}%`;
			                }
			                玩家属性.允许移动--
			                显示通知("背包已满，停止吸取！", "警告");
			                return;
			            }
			
			            const { 物品, 单元格 } = 待吸取物品列表[索引];
			            
			            
			
			            setTimeout(() => {
			            const 临时父元素 = document.createElement('div');
			                
			                if (尝试收集物品(物品, true)) {
			                    单元格.关联物品 = null;
			                    if (单元格.类型 === 单元格类型.物品) {
			                        单元格.类型 = null;
			                    }
			                    成功吸取数量++;
			                    
			            const 图标元素 = document.createElement('div');
			            图标元素.className = '物品图标';
			            图标元素.innerHTML = getIconHTML(物品.显示图标);
			            const color = 物品.颜色表[物品.颜色索引] || '#FFFFFF';
			            图标元素.style.color = color;
			            图标元素.style.textShadow = `0 0 8px ${color}`;
			            图标元素.style.fontSize = `${单元格大小 * 0.8}px`;
			            图标元素.style.position = 'fixed';
			            图标元素.style.display = 'flex';
			            图标元素.style.alignItems = 'center';
			            图标元素.style.justifyContent = 'center';
			            图标元素.style.width = `${单元格大小}px`;
			            图标元素.style.height = `${单元格大小}px`;
			            const 起始位置 = canvas.getBoundingClientRect();
			            图标元素.style.left = `${(物品.x - 当前相机X) * 单元格大小 + 起始位置.left}px`;
			            图标元素.style.top = `${(物品.y - 当前相机Y) * 单元格大小 + 起始位置.top}px`;
			            临时父元素.appendChild(图标元素);
			            document.getElementById('effectsContainer').appendChild(临时父元素);
			
			            创建并播放物品移动动画(临时父元素, () => document.getElementById('背包按钮'));
			                    更新背包显示();
			                    绘制();
			                } else {
			                     显示通知("背包已满，停止吸取！", "警告");
			                     玩家属性.允许移动--
			                     return;
			                }
			                
			                setTimeout(() => {吸取下一个物品(索引 + 1);临时父元素.remove();}, 吸取间隔);
			
			            }, 动画延迟);
			        };
			
			        吸取下一个物品(0);
			
			        return true;
			    }
			
			    获取提示() {
			        const 范围 = this.自定义数据.get('吸取范围');
			        const 能量消耗 = this.自定义数据.get('能量消耗');
			        return `${this.获取名称()}\n类型：${
			            this.类型
			        }\n品质：${"★".repeat(this.品质)}\n效果：${this.效果描述}\n吸取范围: ${范围}x${范围}\n能量消耗: ${能量消耗}`;
			    }
			}
			class 陷阱基类 extends 物品 {
			    constructor(配置 = {}) {
			        // 先准备好数据
			        const 基础数据 = {
			            已触发: false,
			            冷却回合: 3 + Math.floor(prng() * 2),
			            冷却剩余: 0,
			            ...配置.数据,
			        };
			
			        super({
			            类型: "陷阱",
			            能否拾起: true,
			            是否正常物品: false,
			            阻碍怪物: false,
			            // 核心修改：在父类构造时就根据数据决定图标
			            是否为隐藏物品: true,
			            颜色索引:4,
			            图标: 配置.激活后图标 || "V",
			            ...配置,
			            数据: 基础数据,
			        });
			        
			        // 将激活后的图标也存入自定义数据，以便后续使用
			        this.自定义数据.set('激活后图标', 配置.激活后图标 || "V");
			
			        if(!所有计时器.some(t => t.唯一标识 === this.唯一标识)) {
			        
			        if (游戏状态 === '地图编辑器') {
			            if (配置?.玩家放置) this.玩家放置=配置?.玩家放置
			            return;
			                
			            }
			            所有计时器.push(this);
			        }
			    }
			
			    当被收集(进入者) {
			        if (进入者 !== "玩家" || this.自定义数据.get("冷却剩余") > 0 || this.自定义数据.get("已发现")) return false;
			        if (玩家.x!==this.x||玩家.y!==this.y) return false;
			
			        
			        const 首次触发 = !this.自定义数据.get("已触发");
			        if (首次触发) {
			            this.自定义数据.set("已触发", true);
			            this.是否为隐藏物品 = false;
			            this.图标 = this.自定义数据.get('激活后图标'); // 从数据中读取激活后的图标
			            显示通知("你触发了一个陷阱！", "警告");
			        }
			        
			        this.触发效果(进入者);
			        
			        this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));
			        计划显示格子特效([{ x: this.x, y: this.y }], "FF0000");
			        绘制();
			
			        return false; 
			    }
			    
			    更新倒计时() {
			        let 冷却 = this.自定义数据.get("冷却剩余");
			        if (冷却 > 0) {
			            this.自定义数据.set("冷却剩余", 冷却 - 1);
			        }
			    }
			    
			    触发效果(触发者) {
			    }
			
			    使用() { return false; }
			}
			
			class 隐形落石陷阱 extends 陷阱基类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "落石陷阱",
			            激活后图标: 图标映射.落石,
			            原图标: 图标映射.落石,
			            品质: 2,
			            效果描述: "从上方落下巨石造成伤害。",
			            数据: {
			                伤害: 15 + (配置.强化 ? 10 : 0),
			            },
			            ...配置,
			        });
			    }
			    触发效果(触发者) {
			        伤害玩家(this.自定义数据.get("伤害"), this.名称);
			    }
			}
			
			class 隐形地刺陷阱 extends 陷阱基类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "地刺陷阱",
			            激活后图标: 图标映射.地刺,
			            原图标: 图标映射.地刺,
			            品质: 2,
			            效果描述: "锋利的地刺从地面穿出，造成伤害并使你减速。",
			             数据: {
			                伤害: 10 + (配置.强化 ? 5 : 0),
			                减速回合: 3 + (配置.强化 ? 2 : 0),
			            },
			            ...配置,
			        });
			    }
			    触发效果(触发者) {
			        伤害玩家(this.自定义数据.get("伤害"), this.名称);
			        new 状态效果("缓慢", 效果颜色编号映射[效果名称编号映射.缓慢], "慢", this.自定义数据.get("减速回合"));
			    }
			}
			
			class 隐形毒气陷阱 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "陷阱",
			            名称: "隐形毒气陷阱",
			            图标: 图标映射.隐形毒气陷阱,
			            品质: 2,
			            能否拾起: true,
			            是否正常物品: false,
			            阻碍怪物: false,
			            是否为隐藏物品: true, 
			            效果描述: "一个隐藏的毒气陷阱。",
			            数据: {
			                激活后图标: 图标映射.毒气,
			                关联陷阱ID: 配置.关联陷阱ID || 0,
			                中毒强度: 配置.中毒强度||(2 + (配置.强化 ? 1 : 0)),
			                中毒持续: 5,
			                强化: 配置.强化 || false,
			            },
			            
			        });
			        this.图标=图标映射.隐形毒气陷阱;
			    }
			
			    当被收集(进入者) {
			        if (进入者 !== "玩家") return false;
			        if (this.自定义数据.get('已触发') || 玩家.x!==this.x||玩家.y!==this.y) return false;
			        this.自定义数据.set('已触发', true);
			        
			        const 强度 = this.自定义数据.get('中毒强度');
			        const 持续 = this.自定义数据.get('中毒持续');
			        new 状态效果("中毒", 效果颜色编号映射[效果名称编号映射.中毒], "☠️", 持续, null, null, null, 强度);
			        添加日志("你踩中了隐藏的毒气陷阱！", "错误");
			        
			        const 陷阱ID = this.自定义数据.get('关联陷阱ID');
			        if (陷阱ID!==undefined) {
			            揭示并激活陷阱群(陷阱ID, this.自定义数据.get('中毒持续'), this.自定义数据.get('中毒强度'));
			        }
			
			        return false;
			    }
			
			    使用() { return false; }
			}
			
			class 隐形失明陷阱 extends 陷阱基类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "失明陷阱",
			            激活后图标: 图标映射.失明,
			            原图标: 图标映射.失明,
			            品质: 3,
			            效果描述: "触发后会暂时剥夺你的视野。",
			             数据: {
			                失明持续: 15 + (配置.强化 ? 10 : 0),
			            },
			            ...配置,
			        });
			    }
			    触发效果(触发者) {
			        new 状态效果("失明", "#333333", "👁️‍🗨️", this.自定义数据.get("失明持续"));
			    }
			}
			
			class 召唤怪物陷阱 extends 陷阱基类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "召唤陷阱",
			            激活后图标: 图标映射.召唤陷阱,
			            原图标: 图标映射.召唤陷阱,
			            品质: 3,
			            效果描述: "一个不稳定的魔法阵，会召唤出地牢生物。",
			            数据: {
			               召唤数量: 配置.召唤数量 || (3 + (配置.强化 ? 3 : 0)),
			               怪物层级: 配置.怪物层级 || 当前层数===-1 ? 3 : 当前层数,
			            },
			            ...配置,
			        });
			    }
			    触发效果(触发者) {
			        let 已召唤数量 = 0;
			         for (let i = 0; i < this.自定义数据.get('召唤数量'); i++) {
			            
			            if (房间地图[this.y][this.x] && 房间地图[this.y][this.x] !== -1) {
			                const 候选怪物 = 怪物池["普通房间"].filter(m => this.自定义数据.get('怪物层级') >= m.最小层 && m.类.name !== "大魔法师");
			                if(候选怪物.length > 0) {
			                   const 选中配置 = 候选怪物[Math.floor(prng() * 候选怪物.length)];
			                   const 新怪物 = new 选中配置.类({强化: prng() < 0.2 + 当前层数 * 0.03, 状态: 怪物状态.活跃});
			                   if(放置怪物到房间(新怪物, 房间列表.find(t=>t.id==房间地图[this.y][this.x]))) {
			                       已召唤数量++;
			                   }
			                }
			            } else {
			                const 候选怪物 = 怪物池["普通房间"].filter(m => this.自定义数据.get('怪物层级') >= m.最小层 && m.类.name !== "巨人怪物" && m.类.name !== "蜈蚣怪物");
			                if(候选怪物.length > 0) {
			                   const 选中配置 = 候选怪物[Math.floor(prng() * 候选怪物.length)];
			                   let 放置位置=寻找可放置位置(玩家.x,玩家.y);
			                   const 新怪物 = new 选中配置.类({强化: prng() < 0.2 + 当前层数 * 0.03, 状态: 怪物状态.活跃,x:放置位置.x,y:放置位置.y});
			                   if(放置怪物到单元格(新怪物,放置位置.x,放置位置.y)) {
			                       已召唤数量++;
			                   }
			                }
			            }
			        }
			         if (已召唤数量 > 0) {
			            显示通知(`陷阱召唤了 ${已召唤数量} 只怪物！`, "警告");
			        }
			    }
			}
			
			class 烈焰触发陷阱 extends 陷阱基类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "烈焰陷阱",
			            激活后图标: 图标映射.烈焰陷阱,
			            原图标: 图标映射.烈焰陷阱,
			            品质: 4,
			            效果描述: "一个高温的符文，触发后会引燃整个房间。",
			             数据: {
			                引燃比例: 0.4 + (配置.强化 ? 0.2 : 0),
			            },
			            ...配置,
			        });
			    }
			    触发效果(触发者) {
			        const 房间ID = 房间地图[this.y]?.[this.x];
			        
			        let 房间 = 房间列表.find(t=>t.id==房间ID);
			        if (!房间) {
			            房间 = { id: -1, x: 玩家.x - 4, y: 玩家.y - 4, w: 8, h: 8, 类型:'房间'};
			        }
			        const 地板格子 = [];
			        for(let y = 房间.y; y < 房间.y + 房间.h; y++){
			            for(let x = 房间.x; x < 房间.x + 房间.w; x++){
			                if(位置是否可用(x, y, false)) {
			                    地板格子.push({x, y});
			                }
			            }
			        }
			        
			        const 燃烧数量 = Math.floor(地板格子.length * this.自定义数据.get('引燃比例'));
			        地板格子.sort(() => prng() - 0.5);
			        
			        for(let i=0; i < Math.min(燃烧数量, 地板格子.length); i++){
			            const {x, y} = 地板格子[i];
			            const 火焰 = new 火焰物品({强化: this.自定义数据.get('强化'),倒计时:9999});
			            放置物品到单元格(火焰, x, y);
			        }
			        显示通知("周围燃起了熊熊大火！", "错误");
			    }
			}
			
			class 隐形虫洞陷阱 extends 陷阱基类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "虫洞陷阱",
			            激活后图标: 图标映射.虫洞,
			            原图标: 图标映射.虫洞,
			            品质: 4,
			            效果描述: "不稳定的空间裂隙，会将你传送到一个固定的未知时空。",
			            ...配置,
			        });
			    }
			    
			    触发效果(触发者) {
			        // 检查陷阱是否已经决定了传送目标
			        if (生存挑战激活) {
			            return false;
			        }
			        if (!this.自定义数据.has('目标层数')) {
			            // 第一次触发：决定目标楼层并保存
			            let 可选层数 = 当前层数%5===4?[]:[当前层数 + 1]; 
			            for (let i = 0; i < 当前层数; i++) {
			                if (所有地牢层.has(i)) {
			                    可选层数.push(i);
			                }
			            }
			            const 目标层 = 可选层数[Math.floor(prng() * 可选层数.length)];
			            this.自定义数据.set('目标层数', 目标层);
			            // 此时不决定坐标，坐标将在楼层切换后决定
			        }
			
			        const 目标层数 = this.自定义数据.get('目标层数');
			        let 目标坐标 = this.自定义数据.get('目标坐标'); // 可能是 null 或已保存的坐标
			
			        if (目标层数 === undefined) {
			            显示通知("虫洞的目标不稳定，传送失败！", "错误");
			            this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));
			            return;
			        }
			
			        显示通知(`你被吸入了不稳定的虫洞！即将前往第 ${目标层数} 层...`, "警告", true);
			        
			        const 传送回调 = () => {
			            let 最终目标坐标 = this.自定义数据.get('目标坐标');
			            if (!最终目标坐标) {
			                // 如果坐标未定（说明是第一次传送到新层）
			                最终目标坐标 = this.寻找随机合法坐标(目标层数);
			                this.自定义数据.set('目标坐标', 最终目标坐标);
			            }
			            // 手动修改玩家坐标
			            玩家.x = 最终目标坐标.x;
			            玩家.y = 最终目标坐标.y;
			
			            // 更新视觉和逻辑
			            更新视口();
			            绘制();
			            处理玩家着陆效果(玩家.x, 玩家.y, 玩家.x, 玩家.y);
			        };
			        
			        setTimeout(() => {
			            切换楼层(目标层数, false, null, false, 传送回调);
			        }, 500);
			    }
			
			    寻找随机合法坐标(目标层数) {
			        
			        const 可用房间 = 房间列表.filter(r => r.类型 === '房间');
			        
			        if (可用房间.length > 0) {
			            for (let 尝试 = 0; 尝试 < 50; 尝试++) {
			                const 随机房间 = 可用房间[Math.floor(prng() * 可用房间.length)];
			                if(!随机房间 || 上锁房间列表.some(r => r.id === 随机房间?.id)) continue;
			                const x = 随机房间.x + Math.floor(prng() * 随机房间.w);
			                const y = 随机房间.y + Math.floor(prng() * 随机房间.h);
			                if (地牢[y]?.[x] && [单元格类型.房间, 单元格类型.走廊].includes(地牢[y][x].背景类型)) {
			                    return { x, y };
			                }
			            }
			        }
			
			        for (let 尝试 = 0; 尝试 < 200; 尝试++) {
			            const x = Math.floor(prng() * 地牢大小);
			            const y = Math.floor(prng() * 地牢大小);
			            if (地牢[y]?.[x] && [单元格类型.房间, 单元格类型.走廊].includes(地牢[y][x].背景类型)) {
			                return {x, y};
			            }
			        }
			        
			        return { x: 玩家初始位置.x, y: 玩家初始位置.y };
			    }
			
			    获取提示() {
			        let baseTip = super.获取提示();
			        if (this.自定义数据.get("已触发")) {
			             if (this.自定义数据.has('目标层数')) {
			                const targetFloor = this.自定义数据.get('目标层数');
			                baseTip += `\n它似乎连接着第 ${targetFloor} 层。`;
			            } else {
			                baseTip += `\n一个未知的空间连接。`;
			            }
			        }
			        return baseTip;
			    }
			}
			
			class 远射陷阱 extends 怪物 {
			     constructor(配置 = {}) {
			        if (prng()<0.15) 配置.强化 = true;
			        super({
			            图标: 图标映射.远射陷阱,
			            类型: "远射陷阱",
			            基础生命值: 80 + (配置.强化 ? 40 : 0),
			            基础攻击力: 3 + (配置.强化 ? 3 : 0),
			            移动率: 0, 
			            掉落概率: 0,
			            基础攻击范围: 8,
			            跟踪距离: 12,
			            攻击冷却: 3 + (配置.强化 ? 1 : 0),
			            ...配置,
			        });
			        this.状态 = 怪物状态.活跃; 
			    }
			    
			    尝试移动() { return; }
			
			                
			    尝试攻击() {
			        if (this.攻击冷却回合剩余 > 0) {
			            this.攻击冷却回合剩余--;
			            return false;
			        }
			        if (!已访问房间.has(房间地图[this.y][this.x]) && 房间地图[this.y][this.x]!==-1) {
			            return false;
			        }
			        if(快速直线检查(this.x, this.y, 玩家.x, 玩家.y, this.攻击范围)) {
			            const 路径 = 获取直线路径(this.x, this.y, 玩家.x, 玩家.y);
			            if(路径 && 路径.length > 1) {
			                计划显示格子特效(路径.slice(1), "FF8C00");
			                伤害玩家(this.攻击力, this.类型);
			                this.攻击冷却回合剩余 = this.攻击冷却;
			
			
			                const 击退距离 = 1 + (this.强化 ? 1 : 0);
			                const dx = 玩家.x - this.x;
			                const dy = 玩家.y - this.y;
			                let 方向DX = 0, 方向DY = 0;
			
			                if(Math.abs(dx) > Math.abs(dy)){
			                    方向DX = Math.sign(dx);
			                } else {
			                    方向DY = Math.sign(dy);
			                }
			
			                if (方向DX !== 0 || 方向DY !== 0) {
			                    let 最终X = 玩家.x;
			                    let 最终Y = 玩家.y;
			
			                    for(let i=1; i <= 击退距离; i++) {
			                        const 尝试X = 玩家.x + 方向DX * i;
			                        const 尝试Y = 玩家.y + 方向DY * i;
			                        if(检查移动可行性(最终X, 最终Y, 尝试X, 尝试Y, true)) {
			                            最终X = 尝试X;
			                            最终Y = 尝试Y;
			                        } else {
			                            break;
			                        }
			                    }
			
			                    if(最终X !== 玩家.x || 最终Y !== 玩家.y) {
			                        const 旧玩家X = 玩家.x;
			                        const 旧玩家Y = 玩家.y;
			                        玩家.x = 最终X;
			                        玩家.y = 最终Y;
			                        处理玩家着陆效果(旧玩家X, 旧玩家Y, 玩家.x, 玩家.y);
			
			                        添加日志(`你被 ${this.类型} 击退了！`, "警告");
			                        绘制();
			                    }
			                }
			
			
			                return true;
			            }
			        }
			        return false;
			    }
			}
			class 狙击金币枪 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "狙击金币枪",
			            图标: 图标映射.狙击金币枪,
			            品质: 3,
			            基础攻击力: 10,
			            冷却回合: 2,
			            攻击范围: 99,
			            耐久: 配置?.耐久 || 25,
			            强化: 配置?.强化 || false,
			            效果描述: "消耗3金币，朝点击位置的怪物发射一枚可破坏墙体的子弹。对瞬移怪物必定命中。",
			            攻击目标数: 1,
			            数据: {
			                金币消耗: 3,
			                ...配置.数据,
			            },
			        });
			    }
			
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (使用者 instanceof 宠物) return;
			        if (this.自定义数据.get("冷却剩余") > 0) {
			            显示通知("枪械正在冷却！", "错误");
			            return true;
			        }
			        if (物品点击监听器) {
			            物品点击监听器 = null;
			            显示通知("取消了狙击模式。", "信息");
			            return true;
			        }
			
			        const 总金币 = [...玩家背包.values()].filter(i => i instanceof 金币).reduce((sum, i) => sum + i.堆叠数量, 0);
			        if (总金币 < this.自定义数据.get("金币消耗")) {
			            显示通知("金币不足！", "错误");
			            return true;
			        }
			
			        显示通知("狙击模式开启：请点击一个目标怪物。", "信息", true);
			        物品点击监听器 = (clientX, clientY) => {
			            const rect = canvas.getBoundingClientRect();
			            const x = clientX - rect.left;
			            const y = clientY - rect.top;
			            const gridX = Math.floor(视口偏移X + x / 单元格大小);
			            const gridY = Math.floor(视口偏移Y + y / 单元格大小);
			
			            const 目标单元格 = 地牢[gridY]?.[gridX];
			            const 目标怪物 = 目标单元格?.关联怪物;
			
			            if (目标怪物 && 目标怪物.状态 === 怪物状态.活跃) {
			                if (扣除金币(this.自定义数据.get("金币消耗"))) {
			                    let 路径 = 获取直线格子(玩家.x, 玩家.y, 目标怪物.x, 目标怪物.y);
			
			                    let 墙壁已穿透 = 0;
			                    for(const 节点 of 路径) {
			                        const 单元格 = 地牢[节点.y]?.[节点.x];
			                        if (单元格) {
			                            if (单元格.背景类型 === 单元格类型.墙壁) {
			                                
			                                墙壁已穿透++;
			                                if (墙壁已穿透>1) {
			                                    显示通知("墙壁太厚，子弹被阻挡！", "错误");
			                                    路径 = 获取直线格子(玩家.x, 玩家.y, 节点.x, 节点.y);
			                                    计划显示格子特效(路径.slice(1), "FFD700");
			                                    return false;
			                                }
			                            } else if (单元格.关联怪物) {
			                                单元格.关联怪物?.受伤(this.攻击力, this);
			                            }
			                        }
			                    }
			                    
			                    计划显示格子特效(路径.slice(1), "FFD700");
			                    
			
			                    目标怪物.受伤(this.攻击力, this);
			                    显示通知(`击中 ${目标怪物.类型}！`, "成功");
			
			                    this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
			                    if (this.自定义数据.get("耐久") <= 0) {
			                        处理销毁物品(this.唯一标识, true);
			                    }
			                    this.自定义数据.set("冷却剩余", this.最终冷却回合);
			                    更新装备显示();
			                } else {
			                    显示通知("金币不足，射击取消！", "错误");
			                }
			            } else {
			                显示通知("未击中有效目标。", "警告");
			            }
			            物品点击监听器 = null;
			        };
			        return true;
			    }
			}
			class 便携障碍物 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "工具",
			            名称: "便携障碍物",
			            图标: 图标映射.障碍物,
			            品质: 1,
			            颜色索引: 4,
			            堆叠数量: 配置.数量 || Math.ceil(7*prng()),
			            效果描述: "点击使用后，在地图上点击一次以放置。只能在障碍物本格回收。",
			            ...配置,
			        });
			    }
			
			    使用() {
			         if (玩家正在放置障碍物) {
			            玩家正在放置障碍物 = false;
			            显示通知("已取消放置障碍物。", "信息");
			            return false;
			        }
			        玩家正在放置障碍物 = true;
			        显示通知("请在地图上选择一个位置放置障碍物。", "信息", true);
			        return true;
			    }
			}
			
			class 已放置的障碍物 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "障碍物",
			            图标: 图标映射.障碍物,
			            品质: 1,
			            颜色索引: 4,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: true,
			            效果描述: "一个坚固的障碍物。",
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        if (玩家.x !== this.x || 玩家.y !== this.y) return false;
			
			        if (尝试收集物品(new 便携障碍物({数量: 1}), true)) {
			            if (地牢[this.y]?.[this.x]?.关联物品 === this) {
			                地牢[this.y][this.x].关联物品 = null;
			                if (地牢[this.y][this.x].类型 === 单元格类型.物品) {
			                   地牢[this.y][this.x].类型 = null;
			                }
			            }
			            显示通知("成功回收了障碍物！", "成功");
			            绘制();
			            return true;
			        } else {
			            显示通知("背包已满，无法回收！", "错误");
			            return false;
			        }
			    }
			}
			class 洗身砚 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "洗身砚",
			            图标: 图标映射.洗身砚,
			            品质: 4,
			            颜色索引: 1,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: true,
			            效果描述: "一座古朴的石砚，似乎能洗净尘世间的因果。",
			            数据: {
			                已使用: false,
			            },
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        if (this.自定义数据.get("已使用")) {
			            显示通知("石砚中的清水已经浑浊，失去了力量。", "信息");
			            return false;
			        }
			
			        显示自定义确认对话框(
			            "你确定要用这方石砚洗涤自身吗？<br>这会移除神龛和药水带来的负面效果",
			            () => this.使用()
			        );
			
			        return true;
			    }
			
			使用() {
			 if (this.自定义数据.get("已使用")) return false;
			
			 this.自定义数据.set("已使用", true);
			
			 
			 let 移除了诅咒 = false;
			 const 新的永久Buffs = { 已获得效果: new Set() };
			 if (永久Buffs && 永久Buffs.已获得效果) {
			     永久Buffs.已获得效果.forEach(effectId => {
			         const 效果定义 = 神龛效果列表.find(e => e.id === effectId);
			         if (效果定义 && 效果定义.类型 !== '诅咒') {
			             新的永久Buffs.已获得效果.add(effectId);
			             
			         } else if (效果定义 && 效果定义.类型 === '诅咒') {
			             移除了诅咒 = true; 
			         }
			     });
			 }
			 永久Buffs = 新的永久Buffs;
			 永久Buffs.已获得效果.forEach(effectId => {
			         const 效果定义 = 神龛效果列表.find(e => e.id === effectId);
			         if (效果定义) {
			             效果定义.apply()
			         }
			     });
			 应用永久Buffs(); 
			 
			 [...玩家状态].forEach(状态 => {
			     const 负面状态类型 = ["中毒", "缓慢", "腐蚀", "眩晕", "火焰", "恐惧", "牵制"];
			     if (负面状态类型.includes(状态.类型)) {
			         状态.移除状态();
			     }
			 });
			
			 this.效果描述 = "石砚中的清水已经浑浊，失去了力量。";
			 this.颜色索引 = 颜色表.length; 
			
			 if (移除了诅咒) {
			     显示通知("一阵清明流过全身，你感到了身上的诅咒之力已然消散。", "成功");
			 } else {
			     显示通知("清水洗涤了你的尘埃。", "信息");
			 }
			 
			 绘制();
			 return true;
			}
			
			    获取提示() {
			        return `${this.获取名称()}\n品质：${"★".repeat(this.品质)}\n${this.效果描述}`;
			    }
			}
			class 时空罗盘 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			类型: "工具",
			名称: "时空罗盘",
			图标: 图标映射.沙漏,
			品质: 5,
			颜色索引: 4,
			最大堆叠数量: 1,
			效果描述: "激活后，扭曲时间，令所有怪物跳过其行动回合。每次使用都会消耗其耐久。",
			强化: 配置.强化 || false,
			数据: {
			    耐久: 配置.耐久 || (15+ (配置.强化?15:0)),
			    原耐久: 配置.原耐久 || (15+ (配置.强化?15:0)),
			    能量消耗: 50,
			    跳过回合数: 3 + (配置.强化?3:0),
			    ...配置.数据,
			},
			...配置,
			        });
			    }
			
			    使用() {
			        if (this.自定义数据.get("耐久") <= 0) {
			显示通知("罗盘的能量已经耗尽！", "错误");
			return false;
			        }
			
			        if (!扣除能量(this.自定义数据.get("能量消耗"))) {
			显示通知("能量不足！", "错误");
			return false;
			        }
			
			        
			        跳过怪物回合剩余次数 += this.自定义数据.get("跳过回合数");
			        显示通知(`怪物凝固了！ (持续 ${this.自定义数据.get("跳过回合数")} 回合)`, "成功");
			
			        
			        this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
			        if (this.自定义数据.get("耐久") <= 0) {
			处理销毁物品(this.唯一标识, true);
			        }
			
			        更新装备显示();
			        return true;
			    }
			
			    获取提示() {
			        const lines = super.获取提示().split('\n');
			        // 移除多余的堆叠信息
			        const stackIndex = lines.findIndex(line => line.startsWith('堆叠：'));
			        if (stackIndex !== -1) {
			lines.splice(stackIndex, 1);
			        }
			        
			        const stats = [
			`能量消耗：${this.自定义数据.get("能量消耗")}`,
			`跳过回合：${this.自定义数据.get("跳过回合数")}`,
			`剩余次数：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
			        ];
			        
			        // 插入到品质行之后
			        const qualityIndex = lines.findIndex(line => line.startsWith('品质：'));
			        if (qualityIndex !== -1) {
			lines.splice(qualityIndex + 1, 0, ...stats);
			        } else {
			lines.unshift(...stats);
			        }
			        
			        return lines.join('\n');
			    }
			}
			
			class 毒气 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "毒气",
			            图标: 图标映射.毒气,
			            品质: 1,
			            颜色索引: 效果名称编号映射.中毒,
			            能否拾起: true,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "一片弥漫的毒气，接触的生物会中毒。",
			            数据: {
			                倒计时: 配置.倒计时 || (8 + (配置.强化 ? 4 : 0)),
			                来源: 配置.来源 || '玩家',
			                爆炸时间: 配置.爆炸时间 || (8 + (配置.强化 ? 4 : 0)),
			                中毒强度: 配置.中毒强度 || 2 + (配置.强化 ? 1 : 0),
			                中毒持续: 配置.中毒持续 || 5,
			            },
			            ...配置,
			        });
			    }
			
			    当被收集(进入者) {
			        if (this.自定义数据.get('来源') === '玩家' && 进入者 instanceof 怪物 && !(进入者 instanceof 幽灵怪物)) {
			            new 状态效果("中毒", this.获取毒气颜色(), "☠️", this.自定义数据.get("中毒持续"), null, null, 进入者, this.自定义数据.get("中毒强度"));
			            添加日志(`${进入者.类型} 进入了毒气！`, "警告");
			        } else if (this.自定义数据.get('来源') === '陷阱' && 进入者 === '玩家') {
			        const 强度 = this.自定义数据.get('中毒强度');
			        const 持续 = this.自定义数据.get('中毒持续');
			        new 状态效果("中毒", 效果颜色编号映射[效果名称编号映射.中毒], "☠️", 持续, null, null, null, 强度);
			        }
			        return false; 
			    }
			
			    更新倒计时() {
			        const 剩余回合 = this.自定义数据.get("倒计时") - 1;
			        this.自定义数据.set("倒计时", 剩余回合);
			        if (剩余回合 <= 0) {
			            this.移除自身();
			        }
			    }
			
			    移除自身() {
			        if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
			            地牢[this.y][this.x].关联物品 = null;
			            if (地牢[this.y][this.x].类型 === 单元格类型.物品) {
			                地牢[this.y][this.x].类型 = null;
			            }
			        }
			        所有计时器 = 所有计时器.filter(item => item !== this);
			        绘制();
			    }
			    
			    获取毒气颜色() {
			        return 效果颜色编号映射[this.颜色索引] || "#008000";
			    }
			
			    get 颜色表() {
			        return 效果颜色编号映射;
			    }
			}
			
			class 毒气瓶 extends 物品 {
			     constructor(配置 = {}) {
			        super({
			            类型: "消耗品",
			            名称: "毒气瓶",
			            图标: 图标映射.毒气瓶,
			            品质: 2,
			            颜色索引: 效果名称编号映射.中毒,
			            堆叠数量: 配置.数量 || 1,
			            最大堆叠数量: 8,
			            效果描述: "在玩家周围3x3区域释放一片毒气云。",
			            强化: 配置.强化 || false,
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (this.堆叠数量 <= 0) return false;
			
			        let 放置成功计数 = 0;
			        for (let dy = -1; dy <= 1; dy++) {
			            for (let dx = -1; dx <= 1; dx++) {
			                const 目标X = 玩家.x + dx;
			                const 目标Y = 玩家.y + dy;
			
			                if (位置是否可用(目标X, 目标Y, false)) {
			                    const 毒气实例 = new 毒气({ 强化: this.强化 });
			                    if (放置物品到单元格(毒气实例, 目标X, 目标Y)) {
			                         所有计时器.push(毒气实例);
			                         放置成功计数++;
			                    }
			                }
			            }
			        }
			
			        if (放置成功计数 > 0) {
			            this.堆叠数量--;
			            if (this.堆叠数量 <= 0) {
			                处理销毁物品(this.唯一标识, true);
			            }
			            显示通知(`释放了毒气云！`, "成功");
			            更新背包显示();
			            更新装备显示();
			            绘制();
			            return true;
			        } else {
			            显示通知("周围没有空间释放毒气！", "错误");
			            return false;
			        }
			    }
			    get 颜色表() {
			        return 效果颜色编号映射;
			    }
			}
			
			class 万能钥匙 extends 钥匙 {
			    constructor(配置 = {}) {
			        super({
			            ...配置,
			            名称: "万能钥匙",
			            图标: 图标映射.万能钥匙,
			            品质: 3,
			            颜色索引: 2,
			            效果描述: "这把钥匙似乎能打开任何锁。",
			            地牢层数: -1,
			            对应门ID: -1,
			        });
			    }
			    
			    可交互目标(门实例) {
			        if (门实例.类型 === "上锁的门") {
			            return true;
			        }
			        return false;
			    }
			    
			    获取名称() {
			        return `万能钥匙`;
			    }
			}
			
			class 陨石法杖 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "陨石法杖",
			            图标: 图标映射.陨石法杖,
			            品质: 4,
			            基础攻击力: 15 + (配置.强化 ? 10 : 0),
			            冷却回合: 14 - (配置.强化 ? 2 : 0),
			            攻击范围: 4,
			            耐久: 配置?.耐久 || 40,
			            强化: 配置?.强化 || false,
			            效果描述: "召唤数颗小型陨石轰击附近的敌人。",
			            数据: {
			                陨石数量: 3 + (配置.强化 ? 2 : 0),
			                爆炸范围: 2,
			            },
			            ...配置,
			        });
			    }
			
			    
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return false;
			
			        const 范围 = this.最终攻击范围;
			        const 陨石数量 = this.自定义数据.get("陨石数量");
			        const 爆炸范围 = this.自定义数据.get("爆炸范围");
			        
			        const 候选怪物列表 = [];
			        const 怪物位置集合 = new Set();
			        
			        for (let y = 使用者.y - 范围; y <= 使用者.y + 范围; y++) {
			            for (let x = 使用者.x - 范围; x <= 使用者.x + 范围; x++) {
			                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
			                const 距离 = Math.abs(x-使用者.x) + Math.abs(y-使用者.y);
			                if (距离 > 范围) continue;
			                
			                const 单元格 = 地牢[y]?.[x];
			                if (单元格 && 单元格.关联怪物 && 单元格.关联怪物.状态 === 怪物状态.活跃) {
			                    if (检查视线(使用者.x, 使用者.y, x, y, 范围)) {
			                         if (!怪物位置集合.has(`${x},${y}`)) {
			                            候选怪物列表.push(单元格.关联怪物);
			                            怪物位置集合.add(`${x},${y}`);
			                         }
			                    }
			                }
			            }
			        }
			
			        if (候选怪物列表.length === 0) {
			            显示通知("附近没有目标可供轰炸！", "错误");
			            return false;
			        }
			
			        const 目标点列表 = [];
			        if (候选怪物列表.length <= 陨石数量) {
			            // 如果怪物数量不多，直接以每个怪物为目标
			            候选怪物列表.forEach(m => 目标点列表.push({ x: m.x, y: m.y, 权重: 5 }));
			        } else {
			            // 怪物太多，需要聚类选择最优轰炸点
			            const 潜在轰炸点 = new Map();
			            候选怪物列表.forEach(怪物 => {
			                 for (let dy = -爆炸范围; dy <= 爆炸范围; dy++) {
			                    for (let dx = -爆炸范围; dx <= 爆炸范围; dx++) {
			                        const 落点X = 怪物.x + dx;
			                        const 落点Y = 怪物.y + dy;
			                        if (落点X < 0 || 落点X >= 地牢大小 || 落点Y < 0 || 落点Y >= 地牢大小) continue;
			                        
			                        const 单元格 = 地牢[落点Y]?.[落点X];
			                        if(单元格 && [单元格类型.房间, 单元格类型.走廊].includes(单元格.背景类型) && !单元格.关联物品?.阻碍怪物) {
			                            const key = `${落点X},${落点Y}`;
			                            if(!潜在轰炸点.has(key)){
			                                潜在轰炸点.set(key, {x: 落点X, y: 落点Y, 权重: 0});
			                            }
			                        }
			                    }
			                }
			            });
			
			            潜在轰炸点.forEach(落点 => {
			               let 覆盖怪物数 = 0;
			               候选怪物列表.forEach(怪物 => {
			                   if (Math.abs(怪物.x - 落点.x) <= 爆炸范围 && Math.abs(怪物.y - 落点.y) <= 爆炸范围) {
			                       覆盖怪物数++;
			                   }
			               });
			               落点.权重 = 覆盖怪物数;
			            });
			            
			            const 排序后的落点 = Array.from(潜在轰炸点.values()).sort((a, b) => b.权重 - a.权重);
			            for(let i = 0; i < Math.min(陨石数量, 排序后的落点.length); i++){
			                目标点列表.push(排序后的落点[i]);
			            }
			        }
			
			        if (目标点列表.length === 0) {
			             显示通知("没有合适的位置召唤陨石！", "错误");
			             return false;
			        }
			
			        目标点列表.forEach((目标点, index) => {
			           setTimeout(() => {
			               const 临时炸弹 = new 炸弹({ 强化: true }); 
			                临时炸弹.x = 目标点.x;
			                临时炸弹.y = 目标点.y;
			                临时炸弹.能否拾起 = false;
			                临时炸弹.自定义数据.set("爆炸范围", 爆炸范围);
			                临时炸弹.自定义数据.set("伤害", 17);
			                
			                临时炸弹.触发爆炸();
			           }, index * 120); // 陨石依次落下
			        });
			        
			        this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			        }
			        this.自定义数据.set("冷却剩余", this.最终冷却回合);
			        更新装备显示();
			        显示通知("陨石从天而降！", "成功");
			        return true;
			    }
			}
			class 配方卷轴 extends 物品 {
			    constructor(配置 = {}) {
			        const recipe = 配置.recipeData || {
			            输入: ["未知物品A", "未知物品B"],
			            输出类: "未知物品C",
			            输出类名称: "未知物品C",
			            说明: "一个神秘的配方",
			        };
			        super({
			            类型: "其他",
			            名称: `配方: ${recipe.输出类名称 || recipe.输出类}`,
			            图标: 图标映射.卷轴,
			            品质: 2,
			            颜色索引: 1,
			            效果描述: `学习一个物品融合配方！`,
			            是否正常物品: true,
			            能否拾起: true,
			            数据: {
			                recipe: recipe,
			                层数: 配置.层数,
			                已解锁: true, // Recipe scrolls are always "readable"
			            },
			            ...配置,
			        });
			    }
			
			    使用() {
			        const recipe = this.自定义数据.get("recipe");
			        if (recipe) {
			            const recipeString = recipe.说明;
			            if (
			                !已发现的程序生成配方.some(
			                    (r) => r.说明 === recipeString
			                )
			            ) {
			                已发现的程序生成配方.push(recipe);
			                // Also add to the main 融合配方列表 so it can be used immediately
			                if (
			                    !融合配方列表.some(
			                        (r) => r.说明 === recipeString
			                    )
			                ) {
			                    融合配方列表.push(recipe);
			                }
			                显示通知(`学会了新配方: ${recipe.说明}`, "成功");
			
			                处理销毁物品(this, true);
			                return true;
			            } else {
			                显示通知("你已经知道这个配方了。", "信息");
			
			                return true;
			            }
			        }
			        return false;
			    }
			
			    获取提示() {
			        const recipe = this.自定义数据.get("recipe");
			        let desc = super.获取提示();
			        if (recipe && recipe.说明) {
			            desc += `\n配方内容: ${recipe.说明}`;
			        }
			        return desc;
			    }
			}
			class 湮灭卷轴 extends 卷轴类 {
			    constructor(配置) {
			        super({
			            名称: "湮灭卷轴",
			            品质: 3,
			            效果描述: "销毁所有已装备物品",
			            能量消耗: 0,
			            强化: 配置.强化 || false,
			            已解锁: 配置.已解锁 || false,
			        });
			    }
			
			    使用() {
			        if (!this.消耗能量()) return false;
			        let 销毁列表 = Array.from(
			            { length: 装备栏每页装备数 },
			            (_, i) =>
			                玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			        ).filter((v) => v != null);
			
			        销毁列表.forEach((item) => {
			            const 槽位元素 = document.getElementById(
			                `装备槽${
			                    ((item.装备槽位 - 1) % 装备栏每页装备数) + 1
			                }`
			            ); // 修正槽位ID获取
			            if (槽位元素) {
			                // 确保槽位元素存在
			                const 烟花容器 = document.createElement("div");
			                烟花容器.style.position = "fixed";
			                const rect = 槽位元素.getBoundingClientRect();
			                烟花容器.style.left = `${
			                    rect.left + rect.width / 2
			                }px`;
			                烟花容器.style.top = `${
			                    rect.top + rect.height / 2
			                }px`;
			                烟花容器.style.zIndex = 99999;
			                document.body.appendChild(烟花容器);
			
			                for (let i = 0; i < 12; i++) {
			                    const 粒子 = document.createElement("div");
			                    粒子.className = "烟花粒子";
			                    粒子.innerHTML = [
			                        "✨",
			                        "❄️",
			                        "⚡",
			                        "⭐",
			                        "💥",
			                        "🔥",
			                    ][i % 6];
			                    粒子.style.color = "#fff";
			                    粒子.style.setProperty(
			                        "--tx",
			                        Math.cos((i * 30 * Math.PI) / 180)
			                    );
			                    粒子.style.setProperty(
			                        "--ty",
			                        Math.sin((i * 30 * Math.PI) / 180)
			                    );
			                    烟花容器.appendChild(粒子);
			                }
			                setTimeout(() => 烟花容器.remove(), 800);
			            }
			            item.取消装备();
			            处理销毁物品(item.唯一标识, true);
			        });
			        处理销毁物品(this.唯一标识, true);
			        更新背包显示();
			        更新装备显示();
			        显示通知(`湮灭了${销毁列表.length} 件装备`, "错误");
			        return true;
			    }
			}
			
			class 秘银锁甲 extends 防御装备类 {
			    constructor(配置) {
			        super({
			            名称: "秘银锁甲",
			            图标: 图标映射.秘银锁甲,
			            品质: 3,
			            防御力: 3,
			            效果描述: "轻盈而坚固的锁甲。",
			            耐久: 配置.耐久 || 150,
			            强化: 配置.强化 || false,
			            不可破坏: 配置.不可破坏 || false,
			        });
			    }
			    获取提示() {
			        return super.获取提示();
			    }
			}
			
			class 钢制板甲 extends 防御装备类 {
			    constructor(配置) {
			        super({
			            名称: "钢制板甲",
			            图标: 图标映射.钢制板甲,
			            品质: 2,
			            强化: 配置.强化 || false,
			            防御力: 1,
			            效果描述: "沉重的钢制板甲，提供基础防护。",
			            耐久: 配置.耐久 || 200,
			            不可破坏: 配置.不可破坏 || false,
			        });
			    }
			    获取提示() {
			        return super.获取提示();
			    }
			}
			
			class 锅盖 extends 防御装备类 {
			    constructor(配置) {
			        super({
			            名称: "锅盖",
			            图标: 图标映射.锅盖,
			            品质: 2,
			            强化: 配置.强化 || false,
			            防御力: 2,
			            效果描述: "笨重的锅盖，似乎可以用于防御。",
			            耐久: 配置.耐久 || 150,
			            不可破坏: 配置.不可破坏 || false,
			        });
			    }
			    获取提示() {
			        return super.获取提示();
			    }
			}
			
			class 冰盾 extends 防御装备类 {
			    constructor(配置) {
			        super({
			            名称: "冰盾",
			            图标: 图标映射.冰盾,
			            效果描述: `受击时有 ${(0.8 * 100).toFixed(
			                0
			            )}% 概率冻结攻击者 ${3} 回合。`,
			            品质: 3,
			            强化: 配置.强化 || false,
			            防御力: 2,
			            耐久: 配置.耐久 || 100,
			            不可破坏: 配置.不可破坏 || false,
			            数据: {
			                冻结概率: 0.8,
			                冻结回合: 3,
			            },
			        });
			    }
			
			    当被攻击(原始攻击力, 来源 = null) {
			        const 最终伤害 = super.当被攻击(原始攻击力, 来源);
			        if (
			            prng() < this.自定义数据.get("冻结概率") &&
			            来源 instanceof 怪物
			        ) {
			            const 攻击者 = 来源;
			            if (攻击者) {
			                const 冻结状态 = new 状态效果(
			                    "冻结",
			                    "#2196F3",
			                    "冻",
			                    this.自定义数据.get("冻结回合"),
			                    null,
			                    null,
			                    攻击者
			                );
			            }
			        }
			        return 最终伤害;
			    }
			    获取提示() {
			        return super.获取提示();
			    }
			}
			class 存档点 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "存档点",
			            图标: 图标映射.存档点,
			            品质: 5,
			            颜色索引: 1, 
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: true,
			            效果描述: "互动后，你的重生点将被设置在此处。",
			            数据: {
			                目标X: 配置.数据?.目标X ?? null,
			                目标Y: 配置.数据?.目标Y ?? null,
			            },
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        const 目标X = this.自定义数据.get('目标X');
			        const 目标Y = this.自定义数据.get('目标Y');
			
			        if (目标X == null || 目标Y == null || isNaN(目标X) || isNaN(目标Y)) {
			            玩家初始位置.x = this.x;
			            玩家初始位置.y = this.y;
			        } else {
			            玩家初始位置.x = parseInt(目标X);
			            玩家初始位置.y = parseInt(目标Y);
			        }
			        
			        显示通知(`重生点已设置在 (${玩家初始位置.x}, ${玩家初始位置.y})！`, '成功');
			        计划显示格子特效([{x: 玩家初始位置.x, y: 玩家初始位置.y}], '4CAF50');
			        return true;
			    }
			
			    获取提示() {
			        const 目标X = this.自定义数据.get('目标X');
			        const 目标Y = this.自定义数据.get('目标Y');
			        let 提示 = super.获取提示();
			        if (目标X !== null && 目标Y !== null) {
			            提示 += `\n重生坐标: (${目标X}, ${目标Y})`;
			        } else {
			            提示 += `\n重生坐标: (当前位置)`;
			        }
			        return 提示;
			    }
			}
			class 重铸台 extends 物品 {
			 constructor(配置 = {}) {
			     const 最大耐久 = 5;
			     const 当前耐久 = 配置.耐久 ?? 最大耐久;
			     super({
			         类型: "工具",
			         名称: "重铸台",
			         图标: 图标映射.重铸台,
			         品质: 4,
			         颜色索引: 3,
			         最大堆叠数量: 1,
			         效果描述: `消耗金币，可将一件装备/武器的耐久完全修复。\n剩余使用次数：${当前耐久}/${最大耐久}`,
			         数据: {
			             耐久: 当前耐久,
			             最大耐久: 最大耐久,
			             ...配置.数据,
			         },
			     });
			 }
			
			 
			 计算修复消耗(物品) {
			     if (!物品 || !物品.自定义数据.has('原耐久')) return 0;
			     const 最大耐久 = 物品.自定义数据.get('原耐久');
			     const 当前耐久 = 物品.自定义数据.get('耐久');
			     const 已损失耐久百分比 = (最大耐久 - 当前耐久) / 最大耐久;
			
			     if (已损失耐久百分比 <= 0) return 0;
			
			     let 基础消耗 = 15; // 修复的基础费用
			     基础消耗 += 物品.品质 * 10; // 品质越高越贵
			     基础消耗 += 最大耐久 * 0.5; // 耐久上限越高越贵
			     if (物品.强化) {
			         基础消耗 *= 1.5; // 强化物品修复更贵
			     }
			     
			     // 最终消耗与损失的耐久度成正比
			     const 最终消耗 = Math.ceil(基础消耗 * 已损失耐久百分比);
			     return Math.max(1, 最终消耗); // 最低消耗1金币
			 }
			
			 使用() {
			     if (this.自定义数据.get("耐久") <= 0) {
			         显示通知("修复台的能量已经耗尽！", "错误");
			         return false;
			     }
			     显示修复界面(this);
			     return true;
			 }
			}
			
			class 火把 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "工具",
			            名称: "火把",
			            图标: 图标映射.火焰,
			            品质: 1,
			            颜色索引: 2,
			            堆叠数量: 配置.数量 || 1,
			            最大堆叠数量: 1,
			            效果描述: `装备后视野+${
			                2 + (配置.强化 ? 1 : 0)
			            }，丢地上光照${
			                3 + (配置.强化 ? 1 : 0)
			            }格。每回合消耗耐久。`,
			            强化: 配置.强化 || false,
			            数据: {
			                耐久: 配置.耐久 || 400 + (配置.强化 ? 400 : 0),
			                原耐久: 400 + (配置.强化 ? 400 : 0),
			                光照范围: 3 + (配置.强化 ? 1 : 0),
			                视野加成: 2 + (配置.强化 ? 1 : 0),
			                倒计时: 配置.耐久 || 400 + (配置.强化 ? 400 : 0),
			                爆炸时间: 配置.耐久 || 400 + (配置.强化 ? 400 : 0),
			                不可破坏: false,
			                ...配置.数据,
			            },
			        });
			        this.是否被丢弃 = 配置.是否被丢弃 ?? false;
			    }
			    生成显示元素(用途 = "背包") {
			        const 元素 = super.生成显示元素(用途);
			
			        if (
			            this.自定义数据.has("耐久") &&
			            this.自定义数据.has("原耐久") &&
			            用途 === "装备"
			        ) {
			            let 耐久标签 = 元素.querySelector(".耐久标签");
			            if (!耐久标签) {
			                耐久标签 = document.createElement("div");
			                耐久标签.className = "耐久标签";
			                元素.appendChild(耐久标签);
			            }
			
			            耐久标签.textContent = `耐久:${this.自定义数据.get(
			                "耐久"
			            )}`;
			        }
			        return 元素;
			    }
			
			    装备() {
			        const 装备成功 = super.装备();
			        if (装备成功) {
			            if (
			                !所有计时器.some(
			                    (t) => t.唯一标识 === this.唯一标识
			                )
			            ) {
			                所有计时器.push(this);
			            }
			            解冻药水();
			        }
			        return 装备成功;
			    }
			
			    取消装备() {
			        const 卸下成功 = super.取消装备();
			        if (卸下成功) {
			            所有计时器 = 所有计时器.filter(
			                (t) => t.唯一标识 !== this.唯一标识
			            );
			        }
			        return 卸下成功;
			    }
			
			    更新倒计时() {
			        let 当前耐久 = this.自定义数据.get("倒计时");
			        当前耐久--;
			        if (!this.是否被丢弃){
			            this.x=玩家.x
			            this.y=玩家.y
			        }
			        if (当前天气效果.includes("严寒")) {
			            当前耐久--;
			        }
			        this.自定义数据.set("倒计时", 当前耐久);
			        this.自定义数据.set("耐久", 当前耐久);
			
			        if (当前耐久 <= 0) {
			            this.触发爆炸();
			        }
			
			        if (this.已装备) {
			            更新装备显示();
			        }
			    }
			
			    触发爆炸() {
			        显示通知(`${this.名称} 燃尽熄灭了。`, "信息");
			
			        if (
			            this.x !== null &&
			            this.y !== null &&
			            地牢[this.y]?.[this.x]?.关联物品 === this
			        ) {
			            地牢[this.y][this.x].关联物品 = null;
			            地牢[this.y][this.x].类型 =
			                null;
			        }
			        所有计时器 = 所有计时器.filter(
			            (t) => t.唯一标识 !== this.唯一标识
			        );
			
			        if (玩家背包.has(this.唯一标识)) {
			            处理销毁物品(this.唯一标识, true);
			        }
			        绘制();
			    }
			
			    使用() {
			        if (!this.已装备) {
			            if (this.装备()) {
			                显示通知(`装备了 ${this.名称}`, "成功");
			                更新背包显示();
			                更新装备显示();
			                return true;
			            } else {
			                显示通知("装备槽已满！", "错误");
			                return false;
			            }
			        } else {
			            显示通知("火把已装备", "信息");
			            return false;
			        }
			    }
			
			    获取提示() {
			        return super.获取提示();
			    }
			
			    当被丢弃(x, y) {
			        this.x = x;
			        this.y = y;
			        if (
			            this.自定义数据.get("耐久") > 0 &&
			            !所有计时器.some((t) => t.唯一标识 === this.唯一标识)
			        ) {
			            所有计时器.push(this);
			        }
			        return true;
			    }
			    当被收集(进入者) {
			        if (进入者 !== "玩家") return;
			        所有计时器 = 所有计时器.filter(
			            (t) => t.唯一标识 !== this.唯一标识
			        );
			        return true;
			    }
			}
			
			            class 喷火枪 extends 武器类 {
			    constructor(配置) {
			        super({
			            名称: "喷火枪",
			            图标: 图标映射.喷火枪,
			            品质: 2,
			            基础攻击力: 4,
			            冷却回合: 4,
			            攻击范围: 2,
			            耐久: 配置?.耐久 || 100,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "向四个方向喷射火焰，对距离3格的直线敌人造成范围伤害，并能点燃荆棘丛。",
			            攻击目标数: 1,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                火焰范围: 2,
			            },
			        });
			    }
			
			    使用(目标怪物,路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			        if (当前天气效果.includes("严寒")) {
			            if (目标怪物)
			                显示通知("温度过低，武器打不着火了！", "警告");
			            return 0;
			        }
			        const 总攻击力 = this.攻击力;
			        let 总有效伤害 = 0;
			        const 击中怪物列表 = new Set();
			        const 火焰影响区域 = [];
			
			        const 火焰范围 = this.自定义数据.get("火焰范围");
			        const 目标X = 使用者.x;
			        const 目标Y = 使用者.y;
			
			        if (
			            目标X < 0 ||
			            目标X >= 地牢大小 ||
			            目标Y < 0 ||
			            目标Y >= 地牢大小
			        )
			            return;
			
			        const 当前方向火焰区 = [];
			        for (let 偏移 = -火焰范围; 偏移 <= 火焰范围; 偏移++) {
			            const 格子Y = 目标Y + 偏移;
			            if (格子Y >= 0 && 格子Y < 地牢大小) {
			                if (
			                    快速直线检查(
			                        使用者.x,
			                        使用者.y,
			                        目标X,
			                        格子Y,
			                        Math.abs(偏移)
			                    )
			                ) {
			                    当前方向火焰区.push({ x: 目标X, y: 格子Y });
			                }
			            }
			        }
			        for (let 偏移 = -火焰范围; 偏移 <= 火焰范围; 偏移++) {
			            const 格子X = 目标X + 偏移;
			            if (格子X >= 0 && 格子X < 地牢大小) {
			                if (
			                    快速直线检查(
			                        使用者.x,
			                        使用者.y,
			                        格子X,
			                        目标Y,
			                        Math.abs(偏移)
			                    )
			                ) {
			                    当前方向火焰区.push({ x: 格子X, y: 目标Y });
			                }
			            }
			        }
			
			        当前方向火焰区.forEach(({ x, y }) => {
			            火焰影响区域.push({ x, y });
			            const 单元格 = 地牢[y][x];
			            if (单元格?.关联物品 instanceof 荆棘丛) {
			                const 荆棘丛实例 = 单元格.关联物品;
			                所有计时器 = 所有计时器.filter(t => t.唯一标识 !== 荆棘丛实例.唯一标识);
			                const 火焰 = new 火焰物品({ 强化: this.强化 });
			                单元格.关联物品 = 火焰;
			                火焰.x = x;
			                火焰.y = y;
			                所有计时器.push(火焰);
			                添加日志(`荆棘丛在 (${x}, ${y}) 被点燃了！`, "警告");
			            } else if (
			                单元格 &&
			                单元格.关联物品 instanceof 祭坛类 &&
			                单元格.关联物品.自定义数据.get("激活条件") ===
			                    "火焰净化" &&
			                !单元格.关联物品.自定义数据.get("已激活")
			            ) {
			                单元格.关联物品.激活();
			            } else if (
			                单元格 &&
			                单元格.关联怪物 &&
			                单元格.关联怪物.当前生命值 > 0 &&
			                !击中怪物列表.has(单元格.关联怪物)
			            ) {
			                const 怪物 = 单元格.关联怪物;
			                const 原始血量 = 怪物.当前生命值;
			                怪物.受伤(总攻击力, "玩家");
			                const 实际伤害 = 原始血量 - 怪物.当前生命值;
			                if (实际伤害 > 0) {
			                    总有效伤害 += 实际伤害;
			                    击中怪物列表.add(怪物);
			                }
			            }
			        });
			
			        火焰影响区域.forEach((格子) =>
			            计划显示格子特效([格子], "FFA500")
			        );
			
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set(
			            "冷却剩余",
			            Math.max(
			               this.最终冷却回合 -
			                    (this.强化 ? 1 : 0),
			                0
			            )
			        );
			
			        if (总有效伤害 > 0) {
			            显示通知(
			                `${this.名称} 对 ${
			                    击中怪物列表.size
			                } 个目标造成共 ${总有效伤害.toFixed(1)} 点伤害！`,
			                "成功"
			            );
			        } else if (火焰影响区域.length > 0) {
			            显示通知(`${this.名称} 喷射了火焰！`, "信息");
			        } else {
			            显示通知(`${this.名称} 未能喷射火焰！`, "警告");
			            return 0;
			        }
			
			        if (总有效伤害 > 0) {
			            const 受击怪物数组 = Array.from(击中怪物列表);
			            const 火焰等级 =
			                (this.自定义数据
			                    .get("附魔")
			                    ?.find((item) => item.种类 === "火焰附魔")
			                    ?.等级 || 0) + 2;
			            受击怪物数组.forEach((怪物) => {
			                if (怪物.当前生命值 > 0) {
			                    new 状态效果(
			                        "火焰",
			                        "#CC5500",
			                        "火",
			                        火焰等级,
			                        null,
			                        null,
			                        怪物
			                    );
			                }
			            });
			
			            const 连锁附魔 = this.自定义数据
			                .get("附魔")
			                ?.find((item) => item.种类 === "连锁附魔");
			            if (连锁附魔) {
			                const 连锁距离 = 连锁附魔.等级;
			                受击怪物数组.forEach((初始目标) => {
			                    if (初始目标.当前生命值 > 0) {
			                        this.触发连锁(
			                            初始目标,
			                            连锁距离,
			                            受击怪物数组
			                        );
			                    }
			                });
			            }
			        }
			        return 总有效伤害;
			    }
			
			    获取提示() {
			        return super.获取提示();
			    }
			}
			class 斜方刀 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "斜方刀",
			            图标: 图标映射.斜方刀,
			            品质: 2,
			            基础攻击力: 5,
			            冷却回合: 3,
			            攻击范围: 4,
			            耐久: 配置?.耐久 || 60,
			            强化: 配置?.强化 || false,
			            效果描述:
			                "向四个斜向挥出刀光，对路径上2格内的敌人造成伤害。",
			            攻击目标数: 8,
			            不可破坏: 配置?.不可破坏 || false,
			            附魔: 配置?.数据?.附魔 || [],
			            数据: {
			                ...配置.数据,
			            },
			        });
			    }
			
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (
			            this.堆叠数量 <= 0 ||
			            this.自定义数据.get("冷却剩余") > 0
			        )
			            return 0;
			
			        const 总攻击力 = this.攻击力;
			        let 总有效伤害 = 0;
			        const 击中怪物列表 = new Set();
			        const 影响格子 = [];
			
			        // 定义四个斜向的方向向量
			        const 斜向列表 = [
			            { dx: -1, dy: -1 }, // 左上
			            { dx: 1, dy: -1 }, // 右上
			            { dx: -1, dy: 1 }, // 左下
			            { dx: 1, dy: 1 }, // 右下
			        ];
			
			        // 遍历每个斜向
			        斜向列表.forEach((方向) => {
			            // 每个方向延伸2格
			            for (let 距离 = 0; 距离 <= 2; 距离++) {
			                const 目标X = 使用者.x + 方向.dx * 距离;
			                const 目标Y = 使用者.y + 方向.dy * 距离;
			
			                const 上一步X = 使用者.x + 方向.dx * (距离 - 1);
			                const 上一步Y = 使用者.y + 方向.dy * (距离 - 1);
			
			                // 检查路径是否被阻挡
			                if (
			                    !检查移动可行性(上一步X, 上一步Y, 目标X, 目标Y)
			                ) {
			                    break; // 如果路径被墙壁阻挡，则停止在这个方向上继续延伸
			                }
			
			                if (
			                    目标X >= 0 &&
			                    目标X < 地牢大小 &&
			                    目标Y >= 0 &&
			                    目标Y < 地牢大小
			                ) {
			                    影响格子.push({ x: 目标X, y: 目标Y });
			                    const 单元格 = 地牢[目标Y]?.[目标X];
			
			                    if (
			                        单元格?.关联怪物 &&
			                        单元格.关联怪物.当前生命值 > 0 &&
			                        !击中怪物列表.has(单元格.关联怪物)
			                    ) {
			                        const 怪物 = 单元格.关联怪物;
			                        const 原始血量 = 怪物.当前生命值;
			                        怪物.受伤(总攻击力, "玩家");
			                        const 实际伤害 = 原始血量 - 怪物.当前生命值;
			
			                        if (实际伤害 > 0) {
			                            总有效伤害 += 实际伤害;
			                            击中怪物列表.add(怪物);
			                        }
			                    }
			                } else {
			                    break; // 超出边界，停止延伸
			                }
			            }
			        });
			
			        // 显示攻击特效
			        计划显示格子特效(影响格子, "C0C0C0"); // 银色刀光
			
			        // 处理武器消耗和冷却
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        this.自定义数据.set("冷却剩余", this.最终冷却回合);
			
			        if (击中怪物列表.size > 0) {
			            显示通知(
			                `${this.名称} 击中了 ${
			                    击中怪物列表.size
			                } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
			                "成功"
			            );
			            const 所有击中怪物 = Array.from(击中怪物列表);
			            this.触发通用附魔(所有击中怪物);
			        } else {
			            显示通知(`${this.名称} 挥了个空！`, "信息");
			        }
			
			        更新装备显示();
			        return 总有效伤害;
			    }
			}
			class 神龛 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "神龛",
			            图标: 图标映射.神龛,
			            品质: 5,
			            颜色索引: 4,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: true,
			            效果描述: "一座散发着因果气息的古老神龛，许下你的愿望吧...",
			            数据: {
			                已许愿: false,
			            },
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        if (this.自定义数据.get("已许愿")) {
			            显示通知("神龛的回应已经结束，它陷入了沉寂。", "信息");
			            return false;
			        }
			        显示自定义确认对话框(
			            "你感觉到神龛正在呼唤你。你是否愿意献上你的一部分命运，来换取一个永久的祝福...或诅咒？",
			            () => this.执行许愿(神龛效果列表)
			        );
			
			        return true;
			    }
			
			    执行许愿(效果池) {
			        const 随机效果 = 效果池[Math.floor(prng() * 效果池.length)];
			        
			        随机效果.apply(); 
			        
			        
			        永久Buffs.已获得效果.add(随机效果.id);
			        应用永久Buffs();
			        this.自定义数据.set("已许愿", true);
			        
			        this.效果描述 = "神龛的力量已经与你的命运交织在了一起。";
			
			        const 提示类型 = 随机效果.类型 === '祝福' ? '成功' : '错误';
			        显示通知(`你的命运改变了！获得了${随机效果.类型}：【${随机效果.名称}】`, 提示类型, false, 4000);
			        添加日志(`【神龛】${随机效果.描述}`, 提示类型);
			        
			        绘制();
			    }
			
			    获取提示() {
			         if (this.自定义数据.get("已许愿")) {
			            return `${this.名称}\n${this.效果描述}`;
			        }
			        return `${this.名称}\n品质：${"★".repeat(this.品质)}\n${this.效果描述}`;
			    }
			}
			
			
			class 神秘商人 extends 物品 {
			    constructor(配置) {
			        super({
			            类型: "NPC",
			            名称: "神秘商人",
			            图标: 图标映射.神秘商人,
			            品质: 4,
			            颜色索引: 3,
			            能否拾起: false,
			            效果描述: "毫无卵用的奸商",
			            数据: {
			                库存: 配置.库存 || [],
			                商品层数: 配置.商品层数??当前层数??0,
			                刷新次数: 3, // 可交易次数
			            },
			        });
			        this.能否拾起 = false;
			        if (!配置.库存物品) {
			            this.生成库存(Math.max(this.自定义数据.get('商品层数'), 0));
			        }
			    }
			    使用() {
			        打开交易窗口(this);
			        return true;
			    }
			    生成库存(层数) {
			        this.自定义数据.set("库存", []);
			        const 品质权重 = [
			            { 品质: 1, 权重: 50 - 层数 * 5 },
			            { 品质: 2, 权重: 30 + 层数 * 3 },
			            { 品质: 3, 权重: 15 + 层数 * 2 },
			            { 品质: 4, 权重: 5 + 层数 * 1 },
			        ].filter((w) => w.权重 > 0);
			        let 已选中 = false;
			        let 尝试次数 = 0;
			        for (let i = 0; i < 3; i++) {
			            while (!已选中 && 尝试次数 < 100) {
			                let 选中品质 = 加权随机选择(品质权重);
			                if (选中品质) {
			                    const 候选物品 = Object.values(物品池)
			                        .flat()
			                        .filter((item) => {
			                            const 临时实例 = new item.类({
			                                库存物品: true,
			                            });
			                            return (
			                                item.品质 == 选中品质.品质 &&
			                                层数 >= item.最小层 &&
			                                临时实例.类型 !== "工具"
			                            );
			                        });
			
			                    if (候选物品.length > 0) {
			                        const 模板 =
			                            候选物品[
			                                Math.floor(
			                                    prng() * 候选物品.length
			                                )
			                            ];
			                        const 物品实例 = new 模板.类({
			                            数量: 1,
			                            强化:
			                                prng() <
			                                Math.min(0.85, 层数 * 0.15),
			                            已解锁: true,
			                            品质: 2 + Math.floor(prng() * 4),
			                        });
			                        if (
			                            !this.自定义数据
			                                .get("库存")
			                                .some(
			                                    (item) =>
			                                        item.名称 === 物品实例.名称
			                                ) &&
			                            物品实例.是否正常物品
			                        ) {
			                            this.自定义数据
			                                .get("库存")
			                                .push(物品实例);
			                            已选中 = true;
			                        }
			                    }
			                }
			                尝试次数++;
			            }
			            已选中 = false;
			            尝试次数 = 0;
			        }
			    }
			
			    获取价格(物品) {
			        const 基础价格 = 物品.品质 * 20 + (物品.强化 ? 20 : 0) + Math.floor(prng() * 15) - this.自定义数据.get('商品层数') * 2;
			        const 最终价格 = Math.floor(基础价格 * (玩家属性.商店价格倍率 || 1));
			        return Math.max(30, 最终价格);
			    }
			}
			class 探险家 extends 物品 {
			    constructor(配置) {
			        super({
			            类型: "NPC",
			            名称: "探险家",
			            图标: 图标映射.探险家,
			            品质: 3,
			            颜色索引: 3,
			            能否拾起: false,
			            是否正常物品: false, // 不直接出现在掉落池
			            效果描述:
			                "一位经验丰富的探险家，愿意用金币换取你的发现。",
			            数据: {
			                收购需求: [], // { 名称: "钢制长剑", 品质下限: 1, 强化需求: false, 数量: 1 }
			                需求层数: 配置.需求层数??当前层数??0,
			                交易次数: 5 + Math.floor(prng() * 6), // 随机交易次数
			            },
			        });
			        if (!配置.库存物品) {
			            this.生成收购需求(this.自定义数据.get('需求层数'));
			        }
			    }
			
			    生成收购需求(层数) {
			        this.自定义数据.set("收购需求", []);
			        const 需求数量 = 9 + Math.floor(prng() * 4);
			
			        const 可选物品池 = Object.values(物品池)
			            .flat()
			            // 排除非卖品
			            .filter((itemTmpl) => {
			                if (itemTmpl.类.name !== "探险家") {
			                    const tempInstance = new itemTmpl.类({
			                        库存物品: true,
			                    });
			                    return (
			                        tempInstance.是否正常物品 &&
			                        tempInstance.类型 !== "钥匙" &&
			                        tempInstance.类型 !== "金币" &&
			                        tempInstance.类型 !== "NPC" &&
			                        tempInstance.类型 !== "祭坛" &&
			                        tempInstance.类型 !== "工具" &&
			                        tempInstance.类型 !== "折跃门"
			                    );
			                }
			            });
			
			        if (可选物品池.length === 0) return;
			
			        const 已选名称 = new Set();
			
			        for (let i = 0; i < 需求数量; i++) {
			            let 尝试次数 = 0;
			            while (尝试次数 < 50) {
			                const 随机物品模板 =
			                    可选物品池[
			                        Math.floor(
			                            prng() * 可选物品池.length
			                        )
			                    ];
			                const 临时实例 = new 随机物品模板.类({});
			
			                if (已选名称.has(临时实例.名称)) {
			                    尝试次数++;
			                    continue;
			                }
			
			                const 强化需求 =
			                    随机物品模板.品质 >= 3 &&
			                    prng() < 0.3 + this.自定义数据.get('商品层数') * 0.05;
			
			                this.自定义数据.get("收购需求").push({
			                    名称: 临时实例.名称,
			                    强化需求: 强化需求,
			                    图标: 临时实例.图标,
			                    颜色索引: 临时实例.颜色索引,
			                    类名: 随机物品模板.类.name,
			                });
			                已选名称.add(临时实例.名称);
			                break;
			            }
			        }
			    }
			
			    计算收购价格(物品实例, 需求) {
			        let 基础价格 =
			            (物品实例.品质 * 20 + (需求.强化需求 ? 15 : 0)) * 0.8; // 比商人售价低一些
			
			        if (物品实例.强化 && (!需求.强化需求 || 需求.强化需求)) {
			            基础价格 += 10;
			        } else if (!物品实例.强化 && 需求.强化需求) {
			            return 0;
			        }
			
			        if (
			            物品实例.自定义数据?.has("耐久") &&
			            物品实例.自定义数据?.has("原耐久")
			        ) {
			            const 耐久比例 =
			                物品实例.自定义数据.get("耐久") /
			                物品实例.自定义数据.get("原耐久");
			            基础价格 *= 0.5 + 耐久比例 * 0.5;
			        }
			
			        if (物品实例.自定义数据?.has("附魔")) {
			            const 附魔数量 = (物品实例.自定义数据.get("附魔") || [])
			                .length;
			            const 附魔等级总和 = (
			                物品实例.自定义数据.get("附魔") || []
			            ).reduce((sum, e) => sum + e.等级, 0);
			            基础价格 += 附魔数量 * 2 + 附魔等级总和 * 1.5;
			        }
			
			        if (
			            物品实例 instanceof 卷轴类 &&
			            物品实例.自定义数据?.get("已解锁")
			        ) {
			            基础价格 *= 1.3;
			        }
			
			        if (
			            物品实例 instanceof 宠物 &&
			            物品实例.自定义数据?.has("等级")
			        ) {
			            基础价格 += 物品实例.自定义数据.get("等级") * 3;
			        }
			
			        return Math.max(
			            1,
			            Math.floor(基础价格 * (0.9 + prng() * 0.2))
			        ); // 90%-110% 浮动，最低1金币
			    }
			
			    使用() {
			        if (this.自定义数据.get("交易次数") <= 0) {
			            显示通知(
			                "我已经收够今天想要的东西了，下次再见！",
			                "信息"
			            );
			            return false;
			        }
			        打开收购窗口(this);
			        return true;
			    }
			}
			class 蛛网 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "陷阱",
			            名称: "蛛网",
			            图标: 图标映射.蛛网,
			            品质: 1,
			            颜色索引: 5,
			            能否拾起: true,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "黏糊糊的蛛网，能缠住敌人。",
			            数据: {
			                倒计时: 15 + (配置.强化 ? 10 : 0),
			                爆炸时间: 15 + (配置.强化 ? 10 : 0),
			                牵制回合: 3 + (配置.强化 ? 1 : 0),
			            },
			            ...配置,
			        });
			        if (!所有计时器.some(t => t.唯一标识 === this.唯一标识)) {
			            所有计时器.push(this);
			        }
			    }
			    当被收集(进入者) {
			        const 目标 = 进入者 === "玩家" ? null : 进入者;
			        if (进入者 === "玩家") {
			             new 状态效果("牵制", "#FFFFFF", 图标映射.蛛网, this.自定义数据.get("牵制回合"));
			        }
			        this.移除自身();
			        return false;
			    }
			    更新倒计时() {
			        const 剩余回合 = this.自定义数据.get("倒计时") - 1;
			        this.自定义数据.set("倒计时", 剩余回合);
			        if (剩余回合 <= 0) {
			            this.移除自身();
			        }
			    }
			    移除自身() {
			        if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
			            地牢[this.y][this.x].关联物品 = null;
			            if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品) {
			                地牢[this.y][this.x].类型 = null;
			            }
			        }
			        所有计时器 = 所有计时器.filter(item => item !== this);
			    }
			}
			class 渔网陷阱 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "陷阱",
			            名称: "渔网陷阱",
			            图标: 图标映射.渔网陷阱,
			            品质: 2,
			            颜色索引: 3,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "黏糊糊的渔网，能缠住敌人。",
			            数据: {
			                倒计时: 999,
			                爆炸时间: 999,
			                牵制回合: 5,
			            },
			            ...配置,
			        });
			    }
			    当被收集(进入者) {
			        if (进入者 instanceof 怪物 && !(进入者 instanceof 幽灵怪物)) {
			            new 状态效果("牵制", "#FFFFFF", "网", this.自定义数据.get("牵制回合"), null, null, 进入者);
			            添加日志(`${进入者.类型} 被渔网缠住了！`, "信息");
			            this.移除自身();
			        }
			        return false;
			    }
			    更新倒计时() {
			    }
			    移除自身() {
			        if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
			            地牢[this.y][this.x].关联物品 = null;
			            if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品) {
			                地牢[this.y][this.x].类型 = null;
			            }
			        }
			        所有计时器 = 所有计时器.filter(item => item !== this);
			    }
			}
			
			class 渔网 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "工具",
			            名称: "渔网",
			            图标: 图标映射.渔网,
			            品质: 2,
			            颜色索引: 3,
			            堆叠数量: 配置.数量 || 1,
			            最大堆叠数量: 16,
			            效果描述: "在脚下2x2的区域放置一张大网。",
			            ...配置,
			        });
			    }
			    使用() {
			        if (this.堆叠数量 <= 0) return false;
			        const 格子偏移 = [
			            { dx: 0, dy: 0 },
			            { dx: 1, dy: 0 },
			            { dx: 0, dy: 1 },
			            { dx: 1, dy: 1 },
			        ];
			        let 放置成功计数 = 0;
			        for (const 偏移 of 格子偏移) {
			            const 目标X = 玩家.x + 偏移.dx;
			            const 目标Y = 玩家.y + 偏移.dy;
			            if (位置是否可用(目标X, 目标Y, false)) {
			                const 网格陷阱实例 = new 渔网陷阱({});
			                if (放置物品到单元格(网格陷阱实例, 目标X, 目标Y)) {
			                    放置成功计数++;
			                }
			            }
			        }
			        if (放置成功计数 > 0) {
			            this.堆叠数量--;
			            if (this.堆叠数量 <= 0) {
			                处理销毁物品(this.唯一标识, true);
			            }
			            显示通知(`成功放置了 ${放置成功计数} 格渔网！`, "成功");
			            更新背包显示();
			            更新装备显示();
			            绘制();
			            return true;
			        } else {
			            显示通知("无法在此处放置渔网。", "错误");
			            return false;
			        }
			    }
			}
			
			class 充能魔杖 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "充能魔杖",
			            图标: 图标映射.充能魔杖,
			            品质: 4,
			            基础攻击力: 0,
			            冷却回合: 10,
			            攻击范围: 1,
			            耐久: 配置?.耐久 || 30,
			            强化: 配置?.强化 || false,
			            效果描述: "消耗大量能量释放强大的魔法。",
			            数据: {
			                能量消耗: 80 - (配置.强化 ? 20 : 0),
			            },
			            ...配置,
			        });
			    }
			    使用(目标怪物列表,目标路径,使用者=玩家) {
			        if (使用者 instanceof 宠物) return;
			        if (this.自定义数据.get("冷却剩余") > 0) {
			            显示通知("魔杖还在充能！", "警告");
			            return false;
			        }
			        if (!扣除能量(this.自定义数据.get("能量消耗"))) {
			            显示通知("能量不足！", "错误");
			            return false;
			        }
			        if (当前层数 % 5 === 0 && 当前层数>0) {
			            显示通知('当前地牢无法使用充能魔杖','错误');
			            return false;
			        }
			        const 效果池 = ["不伤玩家爆炸", "召唤植物", "大同", "分散"];
			        const 选中效果 = 效果池[Math.floor(prng() * 效果池.length)];
			        switch (选中效果) {
			            case "不伤玩家爆炸":
			                this.执行爆炸();
			                break;
			            case "召唤植物":
			                this.召唤植物();
			                break;
			            case "大同":
			                this.大同();
			                break;
			            case "分散":
			                this.分散();
			                break;
			        }
			        this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			        }
			        this.自定义数据.set("冷却剩余", this.最终冷却回合);
			        更新装备显示();
			        return true;
			    }
			    执行爆炸() {
			        const 爆炸范围 = 4;
			        const 爆炸坐标 = [];
			        for (let dy = -爆炸范围; dy <= 爆炸范围; dy++) {
			            for (let dx = -爆炸范围; dx <= 爆炸范围; dx++) {
			                if (Math.sqrt(dx*dx + dy*dy) <= 爆炸范围) {
			                    爆炸坐标.push({x: 玩家.x + dx, y: 玩家.y + dy});
			                }
			            }
			        }
			        计划显示格子特效(爆炸坐标, "8A2BE2", 20);
			        爆炸坐标.forEach(({x, y}) => {
			            if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
			                const 单元格 = 地牢[y]?.[x];
			                if (单元格?.关联怪物) {
			                    单元格.关联怪物.受伤(25, this.名称);
			                    let 怪物 = 单元格.关联怪物;
			                    if (!怪物) return;
			                    if (怪物.当前生命值 > 0) {
			                        const dx = x - 玩家.x;
			                        const dy = y - 玩家.y;
			                        let dirX = 0;
			                        let dirY = 0;
			
			                        if (Math.abs(dx) > Math.abs(dy)) {
			                            dirX = Math.sign(dx);
			                        } else if (Math.abs(dy) > Math.abs(dx)) {
			                            dirY = Math.sign(dy);
			                        } else if (dx !== 0) {
			                            dirX = Math.sign(dx);
			                        } else if (dy !== 0) {
			                            dirY = Math.sign(dy);
			                        }
			
			                        if (dirX !== 0 || dirY !== 0) {
			                            const { x: 最终X, y: 最终Y } = 怪物.计算最大甩飞位置(x, y, dirX, dirY, 1);
			                            if(最终X !== x || 最终Y !== y) {
			                                const oldX = 怪物.x;
			                                const oldY = 怪物.y;
			                                怪物.恢复背景类型();
			                                怪物.x = 最终X;
			                                怪物.y = 最终Y;
			                                怪物.保存新位置类型(最终X, 最终Y);
			                                地牢[最终Y][最终X].类型 = 单元格类型.怪物;
			                                地牢[最终Y][最终X].关联怪物 = 怪物;
			                                怪物.处理地形效果();
			                                怪物动画状态.set(怪物, {
			                                    旧逻辑X: oldX,
			                                    旧逻辑Y: oldY,
			                                    目标逻辑X: 最终X,
			                                    目标逻辑Y: 最终Y,
			                                    视觉X: oldX,
			                                    视觉Y: oldY,
			                                    动画开始时间: Date.now(),
			                                    正在动画: true,
			                                });
			                            }
			                        }
			                    }
			                }
			            }
			        });
			        显示通知("魔杖释放了一股强大的能量波！", "成功");
			    }
			    召唤植物() {
			        const 召唤数量 = 5 + (this.强化 ? 2 : 0);
			        let 已召唤 = 0;
			        const 方向 = [[0,-2],[2,0],[0,2],[-2,0],[-1,-1],[1,-1],[1,1],[-1,1]];
			        方向.sort(() => prng() - 0.5);
			        for(const [dx, dy] of 方向) {
			            if (已召唤 >= 召唤数量) break;
			            const 目标X = 玩家.x + dx;
			            const 目标Y = 玩家.y + dy;
			            if (位置是否可用(目标X, 目标Y, false)) {
			                const 新植物 = new 魔力远射植物({强化: this.强化});
			                if(放置物品到单元格(新植物, 目标X, 目标Y)) {
			                    所有计时器.push(新植物);
			                    已召唤++;
			                }
			            }
			        }
			        显示通知(`魔杖召唤了 ${已召唤} 株魔力植物！`, "成功");
			    }
			    大同() {
			        const 范围 = 5;
			        let 影响数量 = 0;
			        for(let dy = -范围; dy <= 范围; dy++) {
			            for(let dx = -范围; dx <= 范围; dx++) {
			                const x = 玩家.x + dx;
			                const y = 玩家.y + dy;
			                if(x<0 || x>=地牢大小 || y<0 || y>=地牢大小) continue;
			                const 单元格 = 地牢[y]?.[x];
			                if(单元格?.关联怪物 && 单元格.关联怪物.类型 !== '怪物') {
			                    const 旧怪物 = 单元格.关联怪物;
			                    const 新怪物 = new 怪物({
			                        x: x, y: y, 房间ID: 旧怪物.房间ID, 状态: 怪物状态.活跃,
			                        当前生命值: Math.min(旧怪物.当前生命值, 23),
			                        基础生命值: 23,
			                    });
			                    旧怪物.恢复背景类型();
			                    所有怪物 = 所有怪物.filter(m => m !== 旧怪物);
			                    怪物状态表.delete(旧怪物);
			                    放置怪物到单元格(新怪物, x, y);
			                    影响数量++;
			                }
			            }
			        }
			        if (影响数量 > 0) {
			            计划显示格子特效([{x: 玩家.x, y: 玩家.y}], "FFFFFF");
			            显示通知(`大同之光净化了 ${影响数量} 只怪物！`, "成功");
			        } else {
			             显示通知("什么都没发生...", "信息");
			        }
			    }
			    分散() {
			         const 范围 = 8;
			         const 待分散怪物 = [];
			         for(let dy = -范围; dy <= 范围; dy++) {
			            for(let dx = -范围; dx <= 范围; dx++) {
			                const x = 玩家.x + dx;
			                const y = 玩家.y + dy;
			                if(x<0 || x>=地牢大小 || y<0 || y>=地牢大小) continue;
			                const 单元格 = 地牢[y]?.[x];
			                if(单元格?.关联怪物) {
			                    待分散怪物.push(单元格.关联怪物);
			                }
			            }
			         }
			         if(待分散怪物.length === 0) {
			            显示通知("附近没有怪物可以分散。", "信息");
			            return;
			         }
			
			         待分散怪物.forEach(怪物 => {
			            let 新X, 新Y, 尝试次数 = 0;
			            do {
			                新X = Math.floor(prng() * 地牢大小);
			                新Y = Math.floor(prng() * 地牢大小);
			                尝试次数++;
			            } while ((!位置是否可用(新X, 新Y, false) || (Math.abs(新X - 玩家.x) + Math.abs(新Y - 玩家.y) < 15)) && 尝试次数 < 200);
			
			            if (尝试次数 < 200) {
			                怪物.恢复背景类型();
			                怪物.x = 新X;
			                怪物.y = 新Y;
			                怪物.保存新位置类型(新X, 新Y);
			                地牢[新Y][新X].类型 = 单元格类型.怪物;
			                地牢[新Y][新X].关联怪物 = 怪物;
			            }
			         });
			         显示通知(`强大的能量将 ${待分散怪物.length} 只怪物传送到了未知的地方！`, "成功");
			         绘制();
			    }
			}
			
			class 魔力远射植物 extends 远射植物 {
			    constructor(配置 = {}) {
			        super({
			            名称: "魔力远射植物",
			            能否拾起: false,
			            
			            ...配置,
			        });
			        this.自定义数据.set('倒计时',25 + (配置.强化 ? 10 : 0))
			        this.自定义数据.set('攻击力',7 + (配置.强化 ? 7 : 0))
			    }
			    尝试互动() {
			        return false;
			    }
			    更新倒计时() {
			        if(this.自定义数据.get("耐久") <= 0) {
			            this.移除自身();
			            
			            return;
			        }
			        super.更新倒计时();
			        let 倒计时 = this.自定义数据.get("倒计时");
			        if(倒计时 > 0) {
			            this.自定义数据.set("倒计时", 倒计时 - 1);
			        } else {
			            this.移除自身();
			            
			        }
			    }
			}
			
			class 时间卷轴 extends 卷轴类 {
			    constructor(配置) {
			        super({
			            名称: "时间卷轴",
			            图标: 图标映射.时间卷轴,
			            品质: 4,
			            效果描述: "激活后，装备冷却和宠物恢复速度加快。持续消耗能量。",
			            能量消耗: 4,
			            强化: 配置.强化 || false,
			            已解锁: 配置.已解锁 || false,
			        });
			    }
			    使用() {
			        return true;
			    }
			    卸下() {
			        return true;
			    }
			}
			
			class 潜行靴子 extends 防御装备类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "潜行靴子",
			            图标: 图标映射.潜行靴子,
			            品质: 3,
			            防御力: 1,
			            效果描述: "装备后，只有在敌人视线内才会被追踪。",
			            耐久: 配置.耐久 || 120,
			            强化: 配置.强化 || false,
			        });
			    }
			}
			
			class 钩索 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            类型: "工具",
			            名称: "钩索",
			            图标: 图标映射.钩索,
			            品质: 3,
			            基础攻击力: 0,
			            最大堆叠数量: 1,
			            效果描述: "向你上次移动的方向发射钩索，将你拉向墙壁。",
			            强化: 配置?.强化 || false,
			            攻击范围: 0,
			            攻击目标数: 0,
			            数据: {
			                冷却回合: 5 - (配置.强化 ? 2 : 0),
			                攻击范围: 30 + (配置.强化 ? 20 : 0),
			                耐久: 50 + (配置.强化 ? 25 : 0),
			                原耐久: 50 + (配置.强化 ? 25 : 0),
			                冷却剩余: 0,
			            },
			            ...配置,
			        });
			    }
			    使用() {
			        if (玩家正在钩索) {
			            显示通知("正在使用钩索！", "警告");
			            return false;
			        }
			        if (this.自定义数据.get("冷却剩余") > 0) {
			            显示通知("钩索还未准备好！", "错误");
			            return false;
			        }
			        const 上次方向 = 移动历史[移动历史.length - 1];
			        if (!上次方向) {
			            显示通知("没有移动方向！", "错误");
			            return false;
			        }
			        let dx = 0, dy = 0;
			        if (上次方向 === "上") dy = -1;
			        else if (上次方向 === "下") dy = 1;
			        else if (上次方向 === "左") dx = -1;
			        else if (上次方向 === "右") dx = 1;
			        let 钩中点 = null;
			        for (let i = 1; i <= this.最终攻击范围; i++) {
			            const 检查X = 玩家.x + dx * i;
			            const 检查Y = 玩家.y + dy * i;
			            if (检查X < 0 || 检查X >= 地牢大小 || 检查Y < 0 || 检查Y >= 地牢大小) break;
			            const 单元格 = 地牢[检查Y]?.[检查X];
			            if (!单元格) break;
			            const 前一单元格 = 地牢[玩家.y + dy * (i-1)]?.[玩家.x + dx * (i-1)];
			            if(前一单元格 && !检查移动可行性(玩家.x, 玩家.y, 检查X, 检查Y, true)) {
			               钩中点 = { x: 玩家.x + dx * (i-1), y: 玩家.y + dy * (i-1) };
			               break;
			            }
			            const 目标房间ID = 房间地图[检查Y]?.[检查X];
			            const 目标房间已访问 = 目标房间ID === -1 || 已访问房间.has(目标房间ID);
			            if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) || (前一单元格.背景类型 === 单元格类型.门 && !目标房间已访问)) {
			                钩中点 = { x: 玩家.x + dx * (i-1), y: 玩家.y + dy * (i-1) };
			                break;
			            }
			        }
			        if (钩中点) {
			            
			            const 路径 = 广度优先搜索路径(玩家.x, 玩家.y, 钩中点.x, 钩中点.y, this.最终攻击范围, true);
			            if (路径.length > 1) {
			                this.自定义数据.set("冷却剩余", this.最终冷却回合);
			            this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
			            if(this.自定义数据.get("耐久") <= 0) 处理销毁物品(this.唯一标识, true);
			            更新装备显示();
			                this.开始高速移动(路径.slice(1));
			                return true;
			            }
			        }
			        显示通知("钩索没有勾住任何东西！", "错误");
			        return false;
			    }
			    开始高速移动(路径) {
			        玩家正在钩索 = true;
			        计划显示格子特效(路径, "778899", 5);
			        const 移动逻辑 = () => {
			            if (!玩家正在钩索 || 路径.length === 0) {
			                玩家正在钩索 = false;
			                clearTimeout(钩索移动定时器);
			                return;
			            }
			            const 步数 = Math.min(5, 路径.length);
			            const 目标节点 = 路径[步数 - 1];
			            if (检查移动可行性(玩家.x, 玩家.y, 目标节点.x, 目标节点.y)) {
			                const 旧X = 玩家.x;
			                const 旧Y = 玩家.y;
			                玩家.x = 目标节点.x;
			                玩家.y = 目标节点.y;
			                路径.splice(0, 步数);
			                const 触发中断 = 处理玩家着陆效果(旧X, 旧Y, 玩家.x, 玩家.y);
			                更新视口();
			                绘制();
			                if(触发中断) {
			                     玩家正在钩索 = false;
			                     clearTimeout(钩索移动定时器);
			                     return;
			                }
			            } else {
			                玩家正在钩索 = false;
			                clearTimeout(钩索移动定时器);
			                return;
			            }
			            钩索移动定时器 = setTimeout(移动逻辑, 80);
			        };
			        移动逻辑();
			    }
			    get 最终攻击范围() {
			        return this.自定义数据.get("攻击范围");
			    }
			}
			
			class 嗜血战斧 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "嗜血战斧",
			            图标: 图标映射.嗜血战斧,
			            品质: 4,
			            基础攻击力: 12 + (配置.强化 ? 8 : 0),
			            冷却回合: 4,
			            攻击范围: 2,
			            耐久: 配置?.耐久 || 80,
			            强化: 配置?.强化 || false,
			            效果描述: "一把沉重而锋利的战斧，可以劈开坚固的护甲。",
			            ...配置,
			        });
			    }
			}
			class 祭坛类 extends 物品 {
			    constructor(配置) {
			        super({
			            类型: "祭坛",
			            图标: 图标映射.祭坛,
			            是否正常物品: false,
			            品质: 4,
			            颜色索引: 3,
			            能否拾起: false,
			            数据: {
			                已激活: 配置?.数据?.已激活 || false,
			                激活条件: 配置?.数据?.激活条件 || null,
			                ...配置.数据,
			            },
			            ...配置,
			        });
			
			        if (!this.自定义数据.get("激活条件")) {
			            const 条件列表 = [
			                { 类型: "献祭生命", 权重: 25 },
			                { 类型: "火焰净化", 权重: 15 },
			                {
			                    类型: "力量考验",
			                    权重: 20,
			                    需求伤害: 50 + Math.floor(prng() * 21),
			                },
			                { 类型: "爆炸冲击", 权重: 15 },
			                { 类型: "物品献祭", 权重: 15 },
			                {
			                    类型: "能量灌注",
			                    权重: 10,
			                    能量消耗: 80 + Math.floor(prng() * 21),
			                },
			                { 类型: "冰霜封印", 权重: 10 },
			            ];
			            const 选中的条件 = 加权随机选择(条件列表);
			            this.自定义数据.set("激活条件", 选中的条件.类型);
			            if (选中的条件.需求伤害) {
			                this.自定义数据.set(
			                    "需求伤害",
			                    选中的条件.需求伤害
			                );
			                this.自定义数据.set("当前承受伤害", 0);
			            }
			            if (选中的条件.能量消耗) {
			                this.自定义数据.set(
			                    "能量消耗",
			                    选中的条件.能量消耗
			                );
			            }
			        }
			    }
			
			    尝试互动() {
			        if (this.自定义数据.get("已激活")) {
			            显示通知("这个祭坛的力量已经耗尽。", "信息");
			
			            return false;
			        }
			
			        const 条件 = this.自定义数据.get("激活条件");
			        let 提示信息 = `一个古老的祭坛，上面刻着奇怪的符号：`;
			
			        switch (条件) {
			            case "献祭生命":
			                提示信息 += `\n“以汝之血，换汝新生。”<br>提示：需要献祭大量生命`;
			                if (confirm(提示信息.replace(/<br>/g, "\n"))) {
			                    this.激活();
			                }
			                break;
			            case "火焰净化":
			                提示信息 += `\n“烈焰红火，洗褪尘埃。”<br>提示：需要用火焰灼烧`;
			                显示通知(提示信息, "信息", true, 3000);
			                break;
			            case "冰霜封印":
			                提示信息 += `\n“寒冰凝结，封印之力。”<br>提示：需要用冰霜武器冲击`;
			                显示通知(提示信息, "信息", true, 3000);
			                break;
			            case "力量考验":
			                const 需求伤害 = this.自定义数据.get("需求伤害");
			                const 当前伤害 =
			                    this.自定义数据.get("当前承受伤害") || 0;
			                提示信息 += `\n“力量击破障碍，火力带来胜利。”<br>提示：需要对祭坛造成足够伤害 (${当前伤害}/${需求伤害})。`;
			                显示通知(提示信息, "信息", true, 3000);
			                break;
			            case "爆炸冲击":
			                提示信息 += `\n“破碎带来重组，毁灭孕育机遇。”<br>提示：需要用剧烈的爆炸冲击`;
			                显示通知(提示信息, "信息", true, 3000);
			                break;
			            case "物品献祭":
			                提示信息 += `\n“等价交换，世间真理。”<br>提示：需要扣除背包中的物品`;
			                if (confirm(提示信息.replace(/<br>/g, "\n"))) {
			                    this.激活();
			                }
			                break;
			            case "能量灌注":
			                const 能量消耗 = this.自定义数据.get("能量消耗");
			                提示信息 += `\n“以意志之能量，闯浩瀚之云天。”<br>提示：需要灌注 ${能量消耗} 点能量`;
			                if (confirm(提示信息.replace(/<br>/g, "\n"))) {
			                    this.激活();
			                }
			                break;
			            default:
			                显示通知(提示信息, "信息", true, 3000);
			        }
			        return false;
			    }
			
			    当被攻击(伤害, 来源) {
			        if (this.自定义数据.get("已激活")) return;
			        const 条件 = this.自定义数据.get("激活条件");
			
			        if (条件 === "力量考验") {
			            let 当前伤害 = this.自定义数据.get("当前承受伤害") || 0;
			            当前伤害 += 伤害;
			            this.自定义数据.set("当前承受伤害", 当前伤害);
			
			            计划显示格子特效(
			                [{ x: this.x, y: this.y }],
			                "FFD700",
			                50
			            );
			
			            const 需求伤害 = this.自定义数据.get("需求伤害");
			            if (当前伤害 >= 需求伤害) {
			                this.激活();
			            } else {
			                显示通知(
			                    `祭坛吸收了你的力量... (${Math.floor(
			                        当前伤害
			                    )}/${需求伤害})`,
			                    "信息"
			                );
			            }
			        }
			    }
			
			    激活() {
			        if (this.自定义数据.get("已激活")) return false;
			
			        const 条件 = this.自定义数据.get("激活条件");
			        switch (条件) {
			            case "献祭生命":
			                const 当前生命 =
			                    parseFloat(
			                        document.querySelector(".health-bar").style
			                            .width
			                    ) || 0;
			                if (当前生命 > 75) {
			                    伤害玩家(75, this.名称);
			                } else {
			                    显示通知("血量不足，无法献祭！", "错误");
			                    return false;
			                }
			                break;
			            case "物品献祭":
			                const 可献祭物品 = [...玩家背包.values()].filter(
			                    (item) =>
			                        item.是否正常物品 &&
			                        !item.是否隐藏 &&
			                        item.类型 !== "钥匙" &&
			                        item.类型 !== "金币"
			                );
			                if (可献祭物品.length === 0) {
			                    显示通知("背包中没有可献祭的物品！", "错误");
			                    return false;
			                }
			                const 随机物品 =
			                    可献祭物品[
			                        Math.floor(
			                            prng() * 可献祭物品.length
			                        )
			                    ];
			                显示通知(
			                    `你献祭了 ${随机物品.获取名称()}...`,
			                    "信息"
			                );
			                处理销毁物品(随机物品.唯一标识, true);
			                break;
			            case "能量灌注":
			                if (!扣除能量(this.自定义数据.get("能量消耗"))) {
			                    显示通知("能量不足，无法激活祭坛！", "错误");
			                    return false;
			                }
			                break;
			        }
			
			        this.自定义数据.set("已激活", true);
			        this.图标 = "◎";
			        this.颜色索引 = 颜色表.length;
			        this.效果描述 = "祭坛的力量已经耗尽。";
			        计划显示格子特效([{ x: this.x, y: this.y }], "00FF00", 0);
			        显示通知(`${this.名称}被激活了！`, "成功");
			
			        this.给予奖励();
			
			        return true;
			    }
			
			    给予奖励() {}
			
			    获取提示() {
			        if (this.自定义数据.get("已激活")) {
			            return `${this.名称}\n力量已经耗尽。`;
			        }
			        const 条件 = this.自定义数据.get("激活条件");
			        let 提示 = `${this.名称}\n一个散发着微光的古老祭坛。\n激活条件：`;
			        switch (条件) {
			            case "献祭生命":
			                提示 += "献祭生命";
			                break;
			            case "火焰净化":
			                提示 += "火焰净化";
			                break;
			            case "冰霜封印":
			                提示 += "冰霜封印";
			                break;
			            case "力量考验":
			                提示 += `力量考验 (${
			                    this.自定义数据.get("当前承受伤害") || 0
			                }/${this.自定义数据.get("需求伤害")})`;
			                break;
			            case "爆炸冲击":
			                提示 += "爆炸冲击";
			                break;
			            case "物品献祭":
			                提示 += "物品献祭";
			                break;
			            case "能量灌注":
			                提示 += `能量灌注 (${this.自定义数据.get(
			                    "能量消耗"
			                )})`;
			                break;
			            default:
			                提示 += "未知";
			        }
			        return 提示;
			    }
			}
			class 物品祭坛 extends 祭坛类 {
			    constructor(配置) {
			        super({
			            名称: "物品祭坛",
			            效果描述: "激活后获得一件强大的物品！",
			            数据: {
			                库存: 配置?.数据?.库存 || [],
			                ...配置.数据,
			            },
			        });
			
			        if (
			            !this.自定义数据.get("已激活") &&
			            this.自定义数据.get("库存").length === 0
			        ) {
			            let 已选中 = false;
			            let 尝试次数 = 0;
			            if (!配置.库存物品) {
			                while (!已选中 && 尝试次数 < 100) {
			                    已选中 = this.生成库存();
			                    尝试次数++;
			                }
			            }
			        }
			    }
			
			    给予奖励() {
			        const 库存 = this.自定义数据.get("库存");
			        if (库存.length > 0) {
			            const 奖励物品 = 库存.shift();
			            if (尝试收集物品(奖励物品, false)) {
			                显示通知("你从祭坛获得了奖励！", "成功");
			            } else {
			                this.自定义数据.get("库存").unshift(奖励物品);
			                显示通知("背包已满，奖励无法领取！", "错误");
			            }
			        } else {
			            显示通知("祭坛中空空如也...", "信息");
			        }
			    }
			
			    生成库存() {
			        this.自定义数据.set("库存", []);
			        const 候选物品 = Object.values(物品池)
			            .flat()
			            .filter((itemCfg) => {
			                const 临时实例 = new itemCfg.类({ 库存物品: true });
			                return 临时实例.类型 !== "工具";
			            });
			        if (候选物品.length === 0) return false;
			        const 物品实例 = new 候选物品[
			            Math.floor(prng() * 候选物品.length)
			        ].类({ 强化: true, 已解锁: true });
			        if (
			            物品实例.是否正常物品 &&
			            !(物品实例 instanceof 神秘商人) &&
			            物品实例.类型 !== "工具"
			        ) {
			            this.自定义数据.get("库存").push(物品实例);
			            return true;
			        }
			        return false;
			    }
			}
			
			class 耐久祭坛 extends 祭坛类 {
			    constructor(配置) {
			        super({
			            名称: "耐久祭坛",
			            效果描述: "激活后修复所有已装备物品的耐久。",
			            ...配置,
			        });
			    }
			
			    给予奖励() {
			        let 修复发生 = false;
			        Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			        )
			            .filter((v) => v != null)
			            .forEach((装备) => {
			                if (装备.自定义数据.get("原耐久")) {
			                    装备.自定义数据.set(
			                        "耐久",
			                        装备.自定义数据.get("原耐久")
			                    );
			                    修复发生 = true;
			                }
			            });
			
			        if (修复发生) {
			            显示通知("所有装备的耐久都已完全恢复！", "成功");
			            更新装备显示();
			        } else {
			            显示通知("你没有需要修复的装备。", "信息");
			        }
			    }
			}
			
			class 背包扩容祭坛 extends 祭坛类 {
			    constructor(配置) {
			        super({
			            名称: "背包扩容祭坛",
			            效果描述: "激活后永久扩展你的背包容量！",
			            数据: {
			                扩容量: 2,
			                最大扩展至: 24,
			                ...配置.数据,
			            },
			        });
			    }
			
			    给予奖励() {
			        if (最大背包容量 >= this.自定义数据.get("最大扩展至")) {
			            显示通知("你的背包已经足够大了，无法再扩展。", "信息");
			            return;
			        }
			        最大背包容量 = Math.min(
			            this.自定义数据.get("最大扩展至"),
			            最大背包容量 + this.自定义数据.get("扩容量")
			        );
			        document.getElementById("最大容量").textContent =
			            最大背包容量;
			        更新背包显示();
			        显示通知(`背包容量已扩展至 ${最大背包容量}！`, "成功");
			    }
			}
			class 灵能盾牌 extends 防御装备类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "灵能盾牌",
			            图标: 图标映射.灵能盾牌,
			            品质: 3,
			            颜色索引: 4,
			            防御力: 1 + (配置.强化 ? 1 : 0),
			            耐久: 配置.耐久 || 80 + (配置.强化 ? 40 : 0),
			            原耐久: 配置.原耐久 || 80 + (配置.强化 ? 40 : 0),
			            强化: 配置.强化 || false,
			            效果描述: "受击时概率恢复能量或闪避攻击。",
			            不可破坏: 配置.不可破坏 || false,
			            附魔: 配置.附魔 || [],
			            数据: {
			                能量恢复概率: 0.25 + (配置.强化 ? 0.1 : 0),
			                能量恢复量: 10 + (配置.强化 ? 5 : 0),
			                闪避触发概率: 0.15 + (配置.强化 ? 0.1 : 0),
			            },
			            ...配置,
			        });
			    }
			
			    当被攻击(原始攻击力, 来源 = null) {
			        let 剩余伤害 = super.当被攻击(原始攻击力, 来源);
			        if (prng() < this.自定义数据.get("能量恢复概率")) {
			            const 恢复量 = this.自定义数据.get("能量恢复量");
			            const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            能量条.style.width = `${Math.min(
			                100,
			                当前能量 + 恢复量/自定义全局设置.初始能量值*100
			            )}%`;
			            触发HUD显示();
			        }
			
			        if (prng() < this.自定义数据.get("闪避触发概率")) {
			            显示通知("灵能盾牌闪避！", "成功");
			            添加日志(
			                `成功闪避了来自 ${
			                    来源 instanceof 怪物
			                        ? 来源.类型
			                        : 来源 || "未知来源"
			                } 的攻击！`,
			                "成功"
			            );
			            触发HUD显示();
			            return 0;
			        }
			        return 剩余伤害;
			    }
			
			    获取提示() {
			        let lines = super.获取提示().split("\n");
			        const effectDescIndex = lines.findIndex((line) =>
			            line.startsWith("效果描述：")
			        );
			        if (effectDescIndex !== -1) {
			            lines.splice(effectDescIndex, 1); // Remove the generic description
			        }
			
			        const 能量概率 = (
			            this.自定义数据.get("能量恢复概率") * 100
			        ).toFixed(0);
			        const 能量恢复 = this.自定义数据.get("能量恢复量");
			        const 闪避概率 = (
			            this.自定义数据.get("闪避触发概率") * 100
			        ).toFixed(0);
			
			        const specificEffectLines = [
			            `--- 特殊效果 ---`,
			            `能量恢复：${能量概率}%几率恢复 ${能量恢复} 点`,
			            `灵体闪避：${闪避概率}%几率完全闪避攻击`,
			        ];
			
			        let insertIndex = lines.findIndex((line) =>
			            line.startsWith("--- 强化效果 ---")
			        );
			        if (insertIndex === -1) {
			            insertIndex = lines.findIndex((line) =>
			                line.startsWith("耐久：")
			            );
			        }
			        if (insertIndex === -1) {
			            insertIndex = lines.length;
			        }
			        lines.splice(insertIndex, 0, ...specificEffectLines);
			
			        return lines.filter(Boolean).join("\n");
			    }
			}
			class 毒液物品 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "毒液",
			            图标: 图标映射.毒液,
			            品质: 1,
			            颜色索引: 效果名称编号映射.中毒,
			            最大堆叠数量: 1,
			            能否拾起: true,
			            阻碍怪物: false,
			            是否正常物品: false,
			            是否为隐藏物品: false,
			            效果描述: "一滩剧毒的液体，接触会中毒。",
			            数据: {
			                倒计时: 配置.倒计时 || 5 + (配置.强化 ? 3 : 0),
			                爆炸时间: 5 + (配置.强化 ? 3 : 0),
			                中毒强度: 1 + (配置.强化 ? 2 : 0),
			                中毒持续: 4,
			                ...配置.数据,
			            },
			            ...配置,
			        });
			        if (!所有计时器.some((t) => t.唯一标识 === this.唯一标识)) {
			        
			        if (游戏状态 === '地图编辑器') {
			        if(配置?.玩家放置) this.玩家放置=配置?.玩家放置
			            return;
			                
			            }
			            所有计时器.push(this);
			        }
			    }
			
			    使用() {
			        return false;
			    }
			
			    当被收集(进入者) {
			        if (进入者 !== "玩家") return false;
			        if (this.x!==玩家.x||this.y!==玩家.y) return false;
			        new 状态效果(
			            "中毒",
			            this.获取毒液颜色(),
			            "☠️",
			            this.自定义数据.get("中毒持续"),
			            null,
			            null,
			            null,
			            this.自定义数据.get("中毒强度")
			        );
			        添加日志("你踩到了毒液，中毒了！", "错误");
			        this.移除自身();
			        return false;
			    }
			
			    更新倒计时() {
			        const 剩余回合 = this.自定义数据.get("倒计时");
			        if (剩余回合 <= 0) {
			            this.移除自身();
			        } else {
			            this.自定义数据.set("倒计时", 剩余回合 - 1);
			        }
			    }
			
			    移除自身() {
			        if (
			            this.x !== null &&
			            this.y !== null &&
			            地牢[this.y]?.[this.x]?.关联物品 === this
			        ) {
			            地牢[this.y][this.x].关联物品 = null;
			            if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品)
			                地牢[this.y][this.x].类型 = null;
			        }
			        所有计时器 = 所有计时器.filter((item) => item !== this);
			        绘制();
			    }
			
			    获取提示() {
			        return `【毒液】\n剩余: ${this.自定义数据.get(
			            "倒计时"
			        )}回合\n接触会中毒(${this.自定义数据.get(
			            "中毒强度"
			        )}伤害/回合)`;
			    }
			
			    获取毒液颜色() {
			        return 效果颜色编号映射[this.颜色索引] || "#008000";
			    }
			
			    get 颜色表() {
			        return 效果颜色编号映射;
			    }
			}
			class 饰品 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "饰品",
			            最大堆叠数量: 1,
			            图标: 图标映射.饰品,
			            ...配置,
			        });
			    }
			    使用() {
			        return false;
			    }
			}
			
			class 陷阱先锋饰品 extends 饰品 {
			    constructor(配置 = {}) {
			        super({
			            名称: "陷阱先锋",
			            图标: 图标映射.陷阱先锋,
			            品质: 3,
			            颜色索引: 1,
			            效果描述: "装备后，宠物可以主动揭晓周围2格范围内的陷阱。",
			            ...配置,
			        });
			    }
			}
			
			class 飞毛腿饰品 extends 饰品 {
			    constructor(配置 = {}) {
			        super({
			            名称: "飞毛腿",
			            图标: 图标映射.飞毛腿,
			            品质: 2,
			            颜色索引: 2,
			            效果描述: "装备后，宠物移动步数+1。",
			            ...配置,
			        });
			    }
			}
			
			class 瞬间移动饰品 extends 饰品 {
			     constructor(配置 = {}) {
			        super({
			            名称: "瞬间移动",
			            图标: 图标映射.瞬间移动,
			            品质: 5,
			            颜色索引: 4,
			            效果描述: "当宠物距离你过远、无法正常寻路或切换楼层时，它会瞬间移动到你的身边。",
			            ...配置,
			        });
			    }
			}
			
			class 博士之卷饰品 extends 饰品 {
			     constructor(配置 = {}) {
			        super({
			            名称: "博士之卷",
			            图标: 图标映射.博士之卷,
			            品质: 3,
			            颜色索引: 2,
			            效果描述: "装备后，宠物击败怪物获得的经验翻倍。",
			            ...配置,
			        });
			    }
			}
			
			class 恢复之心饰品 extends 饰品 {
			     constructor(配置 = {}) {
			        super({
			            名称: "恢复之心",
			            图标: 图标映射.恢复之心,
			            品质: 2,
			            颜色索引: 0,
			            效果描述: "装备后，宠物在休眠状态下的生命恢复速度加快。",
			            ...配置,
			        });
			    }
			}
			
			class 以牙还牙饰品 extends 饰品 {
			     constructor(配置 = {}) {
			        super({
			            名称: "以牙还牙",
			            图标: 图标映射.以牙还牙,
			            品质: 4,
			            颜色索引: 4,
			            效果描述: "当宠物被非首领怪物击倒进入休眠时，会对该怪物造成一次强力反击伤害。",
			            ...配置,
			        });
			    }
			}
			class 嗅探之鼻饰品 extends 饰品 {
			    constructor(配置 = {}) {
			        super({
			            名称: "嗅探之鼻",
			            图标: 图标映射.嗅探之鼻,
			            品质: 3,
			            颜色索引: 2,
			            效果描述: "装备后，宠物在生命值低下时会主动寻找并“吃掉”你丢弃的物品和金币来恢复生命。",
			            ...配置,
			        });
			    }
			}
			class 宠物 extends 物品 {
			    constructor(配置 = {}) {
			        const 饰品栏数量 = 配置.饰品栏数量 || 2;
			        const 装备槽 = { 武器: null, 防具: null };
			        for (let i = 1; i <= 饰品栏数量; i++) {
			            装备槽[`饰品${i}`] = null;
			        }
			
			        super({
			            类型: "宠物",
			            名称: 配置.名称 || "宠物",
			            图标: 配置.图标 || 图标映射.宠物,
			            品质: 配置.品质 || 3,
			            颜色索引: 配置.颜色索引 || 2,
			            最大堆叠数量: 1,
			            堆叠数量: 配置.堆叠数量 || 1,
			            效果描述: 配置.效果描述 || "一只忠诚的伙伴。",
			            强化: 配置.强化 || false,
			            数据: {
			                等级: 配置.等级 || 1,
			                当前生命值:
			                    配置.当前生命值 || 配置.最大生命值 || 100,
			                最大生命值: 配置.最大生命值 || 100,
			                基础攻击力: 配置.基础攻击力 || 5,
			                基础防御力: 配置.基础防御力 || 2,
			                经验值: 配置.经验值 || 0,
			                升级所需经验: 配置.升级所需经验 || 20,
			                升级所需金币: 配置.升级所需金币 || 30,
			                技能: 配置.技能 || [],
			                饰品栏数量: 饰品栏数量,
			                装备: 装备槽,
			                休眠中: false,
			                每移动恢复量: 配置.每移动恢复量 || 1,
			                光源范围:1,
			                ...配置.数据,
			            },
			        });
			         if (this.强化) {
			            this.自定义数据.set(
			                "升级所需金币",
			                Math.round(
			                    this.自定义数据.get("升级所需金币") * 0.5
			                )
			            );
			            this.自定义数据.set(
			                "升级所需经验",
			                Math.round(
			                    this.自定义数据.get("升级所需经验") * 0.5
			                )
			            );
			        }
			        this.x = 配置.x ?? null;
			        this.y = 配置.y ?? null;
			        this.层数=配置?.层数?? 当前层数
			        this.是否已放置 = 配置.是否已放置 ?? false;
			        this.伤害来源缓存 = null;
			        this.回到玩家 = false;
			    }
			
			    get 移动距离() {
			        let 基础距离 = 1;
			        const 装备 = this.自定义数据.get("装备") || {};
			        const 飞毛腿列表 = Object.values(装备).filter(item => item instanceof 飞毛腿饰品);
			        基础距离 += 飞毛腿列表.length;
			        return 基础距离;
			    }
			    
			    使用() {
			        this.打开宠物管理窗口();
			        return true;
			    }
			    
			    放出或召回() {
			         if (this.是否已放置) {
			            if (尝试收集物品(this, true)) {
			                const index = 当前出战宠物列表.indexOf(this);
							if (index > -1) {
								当前出战宠物列表.splice(index, 1);
							}
			                this.是否已放置 = false;
			                this.x = null;
			                this.y = null;
			                显示通知(`已召回 ${this.名称}`, "成功");
			            } else {
			                显示通知("背包已满，无法召回宠物！", "错误");
			            }
			        } else {
			            const 放置位置 = 寻找可放置位置(玩家.x, 玩家.y);
			            if (!放置位置) {
			                显示通知("周围没有空间放置宠物！", "错误");
			                return;
			            }
			            if (this.已装备) {
			                玩家装备.delete(this.装备槽位);
			                this.已装备 = false;
			                this.装备槽位 = null;
			            }
			                玩家背包.delete(this.唯一标识);
			            this.是否已放置 = true;
			            this.x = 放置位置.x;
			            this.y = 放置位置.y;
			             this.层数=当前层数
			            当前出战宠物列表.push(this);
			            if (window.宠物管理窗口) {
			                let 窗口=window.宠物管理窗口
			                窗口.style.transform =
			                "translate(-50%, -50%) scale(0.9)";
			            窗口.style.opacity = 0;
			            setTimeout(() => {
			                玩家属性.允许移动 -= 1;
			                玩家属性.允许移动 = Math.max(0,玩家属性.允许移动)
			                窗口.remove();
			            }, 300);
			            window.宠物管理窗口 = null;
			            }
			            显示通知(`${this.名称} 已放出！`, "成功");
			        }
			        更新背包显示();
			        更新装备显示();
			    }
			    
			    尝试互动() {
			        if (!this.是否已放置) return false;
			        const 距离 = Math.abs(玩家.x - this.x) + Math.abs(玩家.y - this.y);
			        if (距离 <= 1) {
			            return this.使用();
			        }
			        return false;
			    }
			
			    寻找可拾取物品() {
			        if ([...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0) >= 最大背包容量-1) {
			            return null;
			        }
			        let 最近物品 = null;
			        let 最小距离 = Infinity;
			        const 搜索范围 = 15;
			        for (let dy = -搜索范围; dy <= 搜索范围; dy++) {
			            for (let dx = -搜索范围; dx <= 搜索范围; dx++) {
			                const x = this.x + dx;
			                const y = this.y + dy;
			                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
			                const 物品 = 地牢[y]?.[x]?.关联物品;
			                if (
			                    物品 &&
			                    !物品.是否被丢弃 &&
			                    (物品 instanceof 武器类 ||
			                     物品 instanceof 防御装备类 ||
			                     物品 instanceof 药水类 ||
			                     (物品 instanceof 卷轴类 && 物品.自定义数据.get("已解锁")))
			                ) {
			                    const 距离宠物 = Math.abs(this.x - x) + Math.abs(this.y - y);
			                    const 距离玩家 = Math.abs(玩家.x - this.x) + Math.abs(玩家.y - this.y);
			                    if (距离宠物 < 距离玩家) {
			                        if (距离宠物 < 最小距离) {
			                            最小距离 = 距离宠物;
			                            最近物品 = 物品;
			                        }
			                    }
			                }
			            }
			        }
			        return 最近物品;
			    }
			    寻找可食用的物品() {
			        let 最近物品 = null;
			        let 最小距离 = Infinity;
			        const 搜索范围 = 20;
			        for (let dy = -搜索范围; dy <= 搜索范围; dy++) {
			            for (let dx = -搜索范围; dx <= 搜索范围; dx++) {
			                const x = this.x + dx;
			                const y = this.y + dy;
			                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
			                const 物品 = 地牢[y]?.[x]?.关联物品;
			                if (物品 instanceof 金币 || (物品 && 物品.是否被丢弃)) {
			                    const 距离 = Math.abs(this.x - x) + Math.abs(this.y - y);
			                    if (距离 < 最小距离) {
			                        最小距离 = 距离;
			                        最近物品 = 物品;
			                    }
			                }
			            }
			        }
			        return 最近物品;
			    }
			    
			    执行回合AI() {
			        if (this.自定义数据.get("休眠中") || !this.是否已放置 || this.层数!==当前层数) return;
			        const 宠物状态 = 宠物状态表.get(this);
        if (宠物状态 && (宠物状态.类型 === '冻结' || 宠物状态.类型 === '牵制' || 宠物状态.类型 === '眩晕')) {
            return;
        }
			        const 嗅探之鼻 = Object.values(this.自定义数据.get("装备") || {}).find(item => item instanceof 嗅探之鼻饰品);
			        const isLowHealth = (this.自定义数据.get("当前生命值") / this.自定义数据.get("最大生命值")) < 0.4;
			
			        if (嗅探之鼻 && isLowHealth) {
			            const food = this.寻找可食用的物品();
			            if (food) {
			                const distance = Math.abs(this.x - food.x) + Math.abs(this.y - food.y);
			                if (distance <= 1) {
			                    const healAmount = (food.品质 || 1) * 10 + (food instanceof 金币 ? food.堆叠数量 : 0);
			                    this.自定义数据.set("当前生命值", Math.min(this.自定义数据.get("最大生命值"), this.自定义数据.get("当前生命值") + healAmount));
			                    
			                    const foodCell = 地牢[food.y][food.x];
			                    if (foodCell && foodCell.关联物品 === food) {
			                        foodCell.关联物品 = null;
			                        foodCell.类型 = null;
			                    }
			                    
			                    显示通知(`${this.名称} 吃掉了 ${food.获取名称()}，恢复了生命！`, "成功");
			                    
			                    
			
			                    if (this.自定义数据.get("当前生命值") < this.自定义数据.get("最大生命值")) {
			                        return; 
			                    }
			                } else {
			                    this.移动到(food);
			                    return;
			                }
			            }
			        }
			
			        const 武器 = this.自定义数据.get("装备")?.武器;
			        
			        const 陷阱先锋列表 = Object.values(this.自定义数据.get("装备") || {}).filter(item => item instanceof 陷阱先锋饰品);
			        if (陷阱先锋列表.length > 0) {
			            const 探测半径 = 2 + (陷阱先锋列表.length - 1);
			            let 发现陷阱 = false;
			            for (let dy = -探测半径; dy <= 探测半径; dy++) {
			                for (let dx = -探测半径; dx <= 探测半径; dx++) {
			                    const 目标X = this.x + dx;
			                    const 目标Y = this.y + dy;
			                    const 单元格 = 地牢[目标Y]?.[目标X];
			                    if (单元格 && 单元格.关联物品 && (单元格.关联物品 instanceof 陷阱基类 || 单元格.关联物品 instanceof 隐形毒气陷阱) && 单元格.关联物品.是否为隐藏物品) {
			                        let 陷阱 = 单元格.关联物品
			                        陷阱.是否为隐藏物品 = false;
			                陷阱.自定义数据.set("已触发", true);
			                陷阱.自定义数据.set("已发现", true);
			                陷阱.图标 = 陷阱.自定义数据.get('激活后图标');
			                        计划显示格子特效([{x: 目标X, y: 目标Y}], "00FFFF");
			                        发现陷阱 = true;
			                    }
			                }
			            }
			            if(发现陷阱) 显示通知(`${this?.名称} 发现了隐藏的陷阱！`, "信息");
			        }
			        const 距离玩家 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
			        if (距离玩家 > 15) this.回到玩家 = true
			
			        const 目标物品 = this.寻找可拾取物品();
			        if (目标物品 &&!this.回到玩家) {
			            const 距离物品 = Math.abs(this.x - 目标物品.x) + Math.abs(this.y - 目标物品.y);
			            
			            
			            if (距离物品 <= 1) {
			                const 拾取物品实例 = 地牢[目标物品.y][目标物品.x].关联物品;
			                if (尝试收集物品(拾取物品实例, true)) {
			                    地牢[目标物品.y][目标物品.x].关联物品 = null;
			                    if (地牢[目标物品.y][目标物品.x].类型 === 单元格类型.物品) {
			                        地牢[目标物品.y][目标物品.x].类型 = null;
			                    }
			                    显示通知(`${this.名称} 为你捡起了 ${拾取物品实例.获取名称()}！`, "成功");
			                    
			                }
			            } else {
			                
			                this.移动到(目标物品);
			            }
			            return;
			        }
			        
			        const 目标敌人 = this.寻找最近怪物目标();
			        
			        if (目标敌人 &&!this.回到玩家) {
			            const 武器攻击范围 = 武器?.最终攻击范围 || 1;
			            const 距离 = Math.abs(this.x - 目标敌人.x) + Math.abs(this.y - 目标敌人.y);
			
			            if (距离 <= 武器攻击范围) {
			                this.攻击([目标敌人]);
			            } else {
			                this.移动到(目标敌人);
			            }
			            return;
			        }
			        
			        
			        if (距离玩家 > 3) {
			             this.移动到(玩家);
			        } else {
			            this.回到玩家 = false
			        }
			    }
			
			    攻击(目标怪物列表) {
			        if (this.自定义数据.get("休眠中") || !this.是否已放置) return;
			        const 武器 = this.自定义数据.get("装备")?.武器;
			        
			        if (武器 && 武器.堆叠数量 > 0 && (武器.自定义数据.get("冷却剩余") ?? 0) === 0) {
			            const { 怪物, 路径 } = 获取周围怪物(武器.自定义数据.get("攻击目标数"), 武器.最终攻击范围, {x:this.x,y:this.y});
			            if(怪物 !== null) {
			                const 目标怪物们 = 怪物.filter(m => 目标怪物列表.includes(m));
			                if (目标怪物们.length > 0) {
			                    武器.使用(目标怪物们, 路径,this);
			                }
			            }
			        } else { 
			            let 总伤害 = this.自定义数据.get("基础攻击力");
			            目标怪物列表.forEach(怪物 => {
			                if (怪物.当前生命值 > 0) {
			                    怪物.受伤(总伤害, this);
			                    
			                    计划显示格子特效(获取直线路径(this.x,this.y,怪物.x,怪物.y));
			                }
			            });
			            添加日志(`${this.名称} 攻击了 ${目标怪物列表.map(m=>m.类型).join(', ')}, 造成 ${总伤害} 点伤害`, "信息");
			        }
			        this.触发技能("攻击", 目标怪物列表);
			    }
			
			    寻找最近怪物目标() {
			        let 最近距离 = Infinity;
			        let 最近目标 = null;
			
			        所有怪物.forEach(怪物 => {
			            if (怪物.状态 === 怪物状态.活跃 && 怪物.当前生命值 > 0 && !(怪物 instanceof 远射陷阱) && !(怪物 instanceof 巡逻怪物)) {
			                const 距离 = Math.abs(this.x - 怪物.x) + Math.abs(this.y - 怪物.y);
			                if (距离 < 最近距离) {
			                    if (检查视线(this.x, this.y, 怪物.x, 怪物.y, 15)) {
			                        最近距离 = 距离;
			                        最近目标 = 怪物;
			                    }
			                }
			            }
			        });
			        return 最近目标;
			    }
			
			    移动到(目标实体) {
			        let 路径 = 广度优先搜索路径(this.x, this.y, 目标实体.x, 目标实体.y, 999, true);
			        const 瞬间移动 = Object.values(this.自定义数据.get("装备") || {}).find(item => item instanceof 瞬间移动饰品);
			        
			        if (!路径 || 路径.length <= 1 || 路径.length > 15) {
			             if (瞬间移动 && (玩家.x==目标实体.x&&玩家.y==目标实体.y)) {
			                this.瞬移到玩家身旁();
			                return;
			             } else {
			             路径 = 广度优先搜索路径(this.x, this.y, 目标实体.x, 目标实体.y, 999, true,true,true);
			             if (!路径) {
			             let bestMove = null;
			            let minDistance = Math.abs(this.x - 目标实体.x) + Math.abs(this.y - 目标实体.y); // 从当前距离开始比较
			            const directions = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];

			            for (const { dx, dy } of directions) {
			                const newX = this.x + dx;
			                const newY = this.y + dy;
			
			                // 检查相邻格子是否是有效的移动目的地
			                if (位置是否可用(newX, newY, false, true) && 快速检查相邻移动(this.x, this.y, newX, newY)) {
			                    const distance = Math.abs(newX - 目标实体.x) + Math.abs(newY - 目标实体.y);
			                    if (distance < minDistance) {
			                        minDistance = distance;
			                        bestMove = { x: newX, y: newY };
			                    }
			                }
			            }
			            
			
			            if (bestMove) {
			                // 移动到找到的最佳相邻格子
			                const 旧x = this.x;
			                const 旧y = this.y;
			                this.x = bestMove.x;
			                this.y = bestMove.y;
			                处理宠物着陆效果(this, 旧x, 旧y, this.x, this.y);
			
			                // 触发移动动画
			                怪物动画状态.set(this, {
			                    旧逻辑X: 旧x,
			                    旧逻辑Y: 旧y,
			                    目标逻辑X: this.x,
			                    目标逻辑Y: this.y,
			                    视觉X: 旧x,
			                    视觉Y: 旧y,
			                    动画开始时间: Date.now(),
			                    正在动画: true,
			                });
			            } 
			             }
			             }
			             
			        }
			
			        const 步数 = Math.min(this.移动距离, 路径.length - 1);
			        const 下一步 = 路径[步数];
			
			        if (下一步) {
			            const 目标单元格 = 地牢[下一步.y]?.[下一步.x];
			            if (目标单元格 && !目标单元格.关联怪物 && !(下一步.x === 玩家.x && 下一步.y === 玩家.y) && 位置是否可用(下一步.x,下一步.y,false,true) && (已访问房间.has(房间地图[下一步.y][下一步.x])||房间地图[下一步.y][下一步.x]==-1)) {
			                const 旧x = this.x;
			                const 旧y = this.y;
			                
			                this.x = 下一步.x;
			                this.y = 下一步.y;
			
			                怪物动画状态.set(this, {
			                    旧逻辑X: 旧x,
			                    旧逻辑Y: 旧y,
			                    目标逻辑X: this.x,
			                    目标逻辑Y: this.y,
			                    视觉X: 旧x,
			                    视觉Y: 旧y,
			                    动画开始时间: Date.now(),
			                    正在动画: true,
			                });
			            }
			        } else if(瞬间移动) {
			             this.瞬移到玩家身旁();
			        }
			    }
			
			    瞬移到玩家身旁() {
			        const 瞬移位置 = 寻找可放置位置(玩家.x, 玩家.y);
			        if (瞬移位置) {
			            const oldX = this.x;
			            const oldY = this.y;
			            this.x = 瞬移位置.x;
			            this.y = 瞬移位置.y;
			             this.层数=当前层数
			            //计划显示格子特效([{x: oldX, y: oldY}, {x: this.x, y: this.y}], "8A2BE2");
			            //显示通知(`${this.名称} 瞬间移动到了你的身边！`, "信息");
			            绘制();
			        }
			    }
			
			    当玩家攻击(目标怪物列表) {
			        if (this.自定义数据.get("休眠中")) return;
			        this.触发技能("攻击", 目标怪物列表);
			    }
			    
			    当玩家被攻击(原始攻击力, 来源) {
			        if (this.自定义数据.get("休眠中")) return 原始攻击力;
			        this.伤害来源缓存 = 来源;
			
			        let 最终攻击力 = 原始攻击力;
			
			        const 防具 = this.自定义数据.get("装备")?.防具;
			        if (防具) {
			            最终攻击力 = 防具.当被攻击(最终攻击力, 来源);
			        }
			
			        最终攻击力 = Math.max(
			            0,
			            最终攻击力 - this.自定义数据.get("基础防御力")
			        );
			        if (最终攻击力 <= 0)
			            最终攻击力 = Math.round(prng() * 100) / 100;
			        const 承担比例 = 0.3;
			        const 宠物承担伤害 = Math.ceil(最终攻击力 * 承担比例);
			        this.受伤(宠物承担伤害, 来源);
			
			        this.触发技能("被攻击", 来源);
			        return 最终攻击力 * (1 - 承担比例);
			    }

			    受伤(伤害值, 来源 = null) {
			        let 当前生命值 = this.自定义数据.get("当前生命值");
			        if (this.是否已放置 && 地牢[this.y]?.[this.x]?.关联物品 instanceof 烟雾) {
			            添加日志(`${this.名称} 被烟雾保护了！`, "成功");
			            return;
			        }
			        当前生命值 = Math.max(0, 当前生命值 - 伤害值);
			        this.自定义数据.set("当前生命值", 当前生命值);
			        this.更新宠物管理窗口();

			        if (来源 instanceof 怪物 && this.是否已放置) {
			            let dx = this.x - 来源.x;
			            let dy = this.y - 来源.y;
			            let 方向DX = 0, 方向DY = 0;

			            if (Math.abs(dx) > Math.abs(dy)) {
			                方向DX = Math.sign(dx) || (dy === 0 ? (prng() < 0.5 ? 1 : -1) : 0);
			            } else if (Math.abs(dy) > Math.abs(dx)) {
			                方向DY = Math.sign(dy) || (dx === 0 ? (prng() < 0.5 ? 1 : -1) : 0);
			            } else if (dx !== 0) {
			                方向DX = Math.sign(dx);
			            } else if (dy !== 0) {
			                方向DY = Math.sign(dy);
			            }

			            const 新X = this.x + 方向DX;
			            const 新Y = this.y + 方向DY;

			            if (位置是否可用(新X, 新Y, false, false) && 检查移动可行性(this.x, this.y, 新X, 新Y)) {
			                const 旧X = this.x;
			                const 旧Y = this.y;
			                this.x = 新X;
			                this.y = 新Y;
			                怪物动画状态.set(this, {
			                    旧逻辑X: 旧X, 旧逻辑Y: 旧Y,
			                    目标逻辑X: 新X, 目标逻辑Y: 新Y,
			                    视觉X: 旧X, 视觉Y: 旧Y,
			                    动画开始时间: Date.now(), 正在动画: true,
			                });
			                添加日志(`${this.名称} 被击退了！`, "警告");
			            }
			        }

			        if (当前生命值 <= 0) {
			            const 以牙还牙列表 = Object.values(this.自定义数据.get("装备") || {}).filter(item => item instanceof 以牙还牙饰品);
			            const 伤害来源 = 来源 || this.伤害来源缓存;
			            
			            if (以牙还牙列表.length > 0 && 伤害来源 instanceof 怪物 && !(伤害来源 instanceof 大魔法师) && !(伤害来源 instanceof 米诺陶) && !(伤害来源 instanceof 王座守护者)) {
			                const 报复伤害 = this.自定义数据.get("最大生命值") * 0.8 * 以牙还牙列表.length;
			                伤害来源.受伤(报复伤害, this);
			                显示通知(`${this.名称} 发动了以牙还牙，对 ${伤害来源.类型} 造成了 ${报复伤害.toFixed(0)} 点伤害！`, "警告");
			            }
			            this.进入休眠();
			        }
			        this.伤害来源缓存 = null;
			        this.触发技能("被攻击", 来源);
			    }
			
			    进入休眠() {
			        this.自定义数据.set("休眠中", true);
			        添加日志(`${this.名称} 生命值过低，进入休眠！`, "警告");
			    }
			
			    恢复生命值() {
			        if (!this.自定义数据.get("休眠中")) return;
			
			        let 当前生命值 = this.自定义数据.get("当前生命值");
			        const 最大生命值 = this.自定义数据.get("最大生命值");
			        const 时间加速 = 当前激活卷轴列表.has(Array.from(当前激活卷轴列表).find(item => item instanceof 时间卷轴));
			        const 基础恢复量 = this.自定义数据.get("每移动恢复量");
			        const 恢复之心列表 = Object.values(this.自定义数据.get("装备") || {}).filter(item => item instanceof 恢复之心饰品);
			        const 恢复倍率 = 1 + 恢复之心列表.length;
			        const 恢复量 = (时间加速 ? 基础恢复量 * 2 : 基础恢复量) * 恢复倍率;
			        当前生命值 = Math.min(最大生命值, 当前生命值 + 恢复量);
			        this.自定义数据.set("当前生命值", 当前生命值);
			        this.更新宠物管理窗口();
			        if (
			            当前生命值 >= 最大生命值 &&
			            this.自定义数据.get("休眠中")
			        ) {
			            this.自定义数据.set("休眠中", false);
			            显示通知(`${this.名称}已恢复，退出休眠！`, "成功");
			        }
			    }
			    升级() {
			        const 当前等级 = this.自定义数据.get("等级");
			        const 升级所需金币 = this.自定义数据.get("升级所需金币");
			        if (
			            this.自定义数据.get("升级所需经验") <=
			            this.自定义数据.get("经验值")
			        ) {
			            if (扣除金币(升级所需金币)) {
			                this.自定义数据.set("等级", 当前等级 + 1);
			                this.自定义数据.set(
			                    "最大生命值",
			                    this.自定义数据.get("最大生命值") + 20
			                );
			                this.自定义数据.set(
			                    "当前生命值",
			                    this.自定义数据.get("最大生命值")
			                ); 
			                this.自定义数据.set(
			                    "基础攻击力",
			                    this.自定义数据.get("基础攻击力") + 2
			                );
			                this.自定义数据.set(
			                    "基础防御力",
			                    this.自定义数据.get("基础防御力") + 1
			                );
			                this.自定义数据.set(
			                    "升级所需经验",
			                    Math.floor(
			                        this.自定义数据.get("升级所需经验") * 1.5
			                    )
			                );
			                this.自定义数据.set(
			                    "升级所需金币",
			                    Math.floor(
			                        this.自定义数据.get("升级所需金币") * 1.2
			                    )
			                );
			                显示通知(`${this.名称}升级成功！`, "成功");
			                this.更新宠物管理窗口();
			                return true;
			            } else {
			                显示通知("金币不足，无法升级！", "错误");
			                return false;
			            }
			        } else {
			            显示通知("经验不足，无法升级！", "错误");
			            return false;
			        }
			    }
			    获得经验(经验值) {
			        let 最终经验 = 经验值;
			        const 博士之卷列表 = Object.values(this.自定义数据.get("装备") || {}).filter(item => item instanceof 博士之卷饰品);
			        博士之卷列表.forEach(() => {
			            最终经验 *= 2;
			        });
			        let 当前经验 = this.自定义数据.get("经验值") + 最终经验;
			        this.自定义数据.set("经验值", 当前经验);
			    }
			    装备物品(物品, 槽位) {
			        const isAccessorySlot = 槽位.startsWith("饰品");
			        const maxAccessorySlots = this.自定义数据.get("饰品栏数量") || 0;
			        if (isAccessorySlot) {
			            const slotNum = parseInt(槽位.slice(2), 10);
			            if(isNaN(slotNum) || slotNum <= 0 || slotNum > maxAccessorySlots) {
			               显示通知("无效的宠物饰品槽位", "错误");
			               return;
			            }
			        }
			        if (!["武器", "防具"].includes(槽位) && !isAccessorySlot) {
			            显示通知("无效的宠物装备槽位", "错误");
			            return;
			        }
			        if (
			            (槽位 === "武器" && !(物品 instanceof 武器类)) ||
			            (槽位 === "防具" && !(物品 instanceof 防御装备类)) ||
			            (isAccessorySlot && 物品.类型 !== "饰品")
			        ) {
			            显示通知("该物品不能装备到此槽位", "错误");
			            return;
			        }
			        if (this.自定义数据.get("装备")[槽位]) {
			            this.卸下装备(槽位);
			        }
			        物品.是否隐藏 = true;
			        卸下装备槽物品(物品.装备槽位); 
			        this.自定义数据.get("装备")[槽位] = 物品;
			        显示通知(`${this.名称}装备了${物品.获取名称()}`, "成功");
			        this.更新宠物管理窗口();
			    }
			    卸下装备(槽位) {
			        const 装备 = this.自定义数据.get("装备");
			        if (
			            装备 &&
			            装备[槽位] &&
			            [...玩家背包.values()].reduce(
			                (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
			                0
			            ) < 最大背包容量
			        ) {
			            const 卸下物品 = 装备[槽位];
			            装备[槽位] = null;
			            卸下物品.是否隐藏 = false;
			            显示通知(
			                `${this.名称}卸下了${卸下物品.获取名称()}`,
			                "成功"
			            );
			            this.自定义数据.set("装备", 装备);
			            this.更新宠物管理窗口();
			            更新背包显示();
			        } else {
			            显示通知("背包已满！", "错误");
			        }
			    }
			    触发技能(时机, 额外参数) {
			        const 技能列表 = this.自定义数据.get("技能");
			        if (!技能列表) return;
			        技能列表.forEach((技能) => {
			            if (技能.时机 === 时机 && prng() > 0.5) {
			                this.技能效果[技能.索引](this, 额外参数);
			            }
			        });
			    }
			    打开宠物管理窗口() {
			        if (界面可见性.背包) 切换背包显示();
			        玩家属性.允许移动 += 1;
			        if (window.宠物管理窗口) {
			            显示通知("一次只能打开一个宠物管理窗口", "错误");
			            玩家属性.允许移动 -= 1;
			            return;
			        }
			        const 窗口 = document.createElement("div");
			        窗口.className = "宠物管理窗口";
			        window.宠物管理窗口 = 窗口;
			        const 基本信息面板 = this.创建基本信息面板();
			        const 装备面板 = this.创建装备面板();
			        const 饰品面板 = this.创建饰品面板();
			        const 技能面板 = this.创建技能面板();
			        const 交互按钮容器 = document.createElement("div");
			        交互按钮容器.style.display = 'flex';
			        交互按钮容器.style.gap = '10px';
			        const 放出召回按钮 = document.createElement("button");
			        放出召回按钮.className = "通用按钮";
			        放出召回按钮.textContent = this.是否已放置 ? "召回宠物" : "放出宠物";
			        放出召回按钮.onclick = () => {
			            this.放出或召回();
			            放出召回按钮.textContent = this.是否已放置 ? "召回宠物" : "放出宠物";
			        };
			        const 升级按钮 = document.createElement("button");
			        升级按钮.className = "通用按钮";
			        升级按钮.textContent = `升级宠物（${this.自定义数据.get("升级所需金币")} 金币）`;
			        升级按钮.addEventListener("click", () => {
			            this.升级();
			            this.更新基本信息面板(基本信息面板); 
			            升级按钮.textContent = `升级宠物（${this.自定义数据.get("升级所需金币")} 金币）`;
			        });
			        交互按钮容器.appendChild(放出召回按钮);
			        交互按钮容器.appendChild(升级按钮);
			        const 关闭按钮 = document.createElement("button");
			        关闭按钮.className = "关闭按钮";
			        关闭按钮.textContent = "×";
			        关闭按钮.onclick = () => {
			            窗口.style.transform =
			                "translate(-50%, -50%) scale(0.9)";
			            窗口.style.opacity = 0;
			            setTimeout(() => {
			                玩家属性.允许移动 -= 1;
			                窗口.remove();
			            }, 300);
			            window.宠物管理窗口 = null;
			        };
			        窗口.appendChild(关闭按钮);
			        窗口.appendChild(基本信息面板);
			        窗口.appendChild(装备面板);
			        窗口.appendChild(饰品面板);
			        窗口.appendChild(技能面板);
			        窗口.appendChild(交互按钮容器);
			        document.body.appendChild(窗口);
			    }
			    更新宠物管理窗口() {
			        if (!window.宠物管理窗口) return;
			        const 基本信息面板 =
			            window.宠物管理窗口.querySelector(".宠物基本信息面板");
			        if (基本信息面板) this.更新基本信息面板(基本信息面板);
			        const 装备面板容器 = window.宠物管理窗口.querySelector(".宠物装备面板");
			        if (装备面板容器) {
			            const 新装备面板 = this.创建装备面板();
			            装备面板容器.replaceWith(新装备面板);
			        }
			        const 饰品面板容器 = window.宠物管理窗口.querySelector(".宠物饰品面板");
			        if(饰品面板容器) {
			            const 新饰品面板 = this.创建饰品面板();
			            饰品面板容器.replaceWith(新饰品面板);
			        }
			        const 升级按钮 = window.宠物管理窗口.querySelectorAll('.通用按钮')[6];
			        if (升级按钮) {
			             升级按钮.textContent = `升级宠物（${this.自定义数据.get("升级所需金币")} 金币）`;
			        }
			    }
			    创建基本信息面板() {
			        const 面板 = document.createElement("div");
			        面板.className = "宠物基本信息面板";
			        this.更新基本信息面板(面板);
			        return 面板;
			    }
			    更新基本信息面板(面板) {
			        const data = this.自定义数据;
			        面板.innerHTML = `
			<h3>${this.名称} (等级 ${data.get("等级")})</h3>
			<div class="宠物状态栏">
			     <span>生命:</span>
			     <div class="条容器">
			        <div class="宠物血量条" style="width: ${Math.max(0, (data.get("当前生命值") / data.get("最大生命值")) * 100)}%;"></div>
			        <span class="宠物血量文本">${data.get("当前生命值")} / ${data.get("最大生命值")}</span>
			    </div>
			     <span>经验:</span>
			    <div class="宠物经验条容器">
			        <div class="宠物经验条" style="width: ${Math.min(100, (data.get("经验值") / data.get("升级所需经验")) * 100)}%;"></div>
			        <span class="宠物经验文本">${data.get("经验值")} / ${data.get("升级所需经验")}</span>
			    </div>
			</div>
			<div class="宠物属性">
			    <span>攻击力: ${data.get("基础攻击力")}</span>
			    <span>防御力: ${data.get("基础防御力")}</span>
			</div>
			<p style="text-align: center; margin-top: 10px;">状态: ${data.get("休眠中") ? "休眠中" : "活跃"}</p>
			        `;
			    }
			    创建装备面板() {
			        const 面板 = document.createElement("div");
			        面板.className = "宠物装备面板";
			        面板.innerHTML = "<h4>装备</h4>";
			        const 武器槽 = this.创建装备槽("武器");
			        const 防具槽 = this.创建装备槽("防具");
			        面板.appendChild(武器槽);
			        面板.appendChild(防具槽);
			        return 面板;
			    }
			    创建饰品面板() {
			        const 面板 = document.createElement("div");
			        面板.className = "宠物饰品面板";
			        面板.innerHTML = "<h4>饰品</h4>";
			
			        const 饰品槽容器 = document.createElement("div");
			        饰品槽容器.className = "宠物装备格子容器"; 
			        
			        const 饰品栏数量 = this.自定义数据.get("饰品栏数量") || 0;
			        饰品槽容器.style.gridTemplateColumns = `repeat(${饰品栏数量}, 1fr)`; 
			
			        for (let i = 1; i <= 饰品栏数量; i++) {
			            const 饰品槽 = this.创建装备槽(`饰品${i}`);
			            饰品槽容器.appendChild(饰品槽);
			        }
			
			        面板.appendChild(饰品槽容器);
			        return 面板;
			    }
			    创建装备槽(槽位类型) {
			        const 槽 = document.createElement("div");
			        槽.className = "宠物装备槽";
			        槽.dataset.槽位 = 槽位类型;
			        const 槽位名 = document.createElement("span");
			        槽位名.className = "宠物装备槽位名";
			        槽位名.textContent = 槽位类型;
			        槽.appendChild(槽位名);
			        const 已装备物品 = this.自定义数据.get("装备")[槽位类型];
			        if (已装备物品 && (已装备物品?.自定义数据?.get('耐久')>0 ||!(已装备物品 instanceof 武器类 || 已装备物品 instanceof 防御装备类))) {
			            const 物品元素 = this.创建装备物品元素(已装备物品, 槽位类型);
			            槽.appendChild(物品元素);
			        } else {
			            const 选择按钮 = document.createElement("button");
			            选择按钮.className = "通用按钮";
			            选择按钮.textContent = `装备${槽位类型}`;
			            选择按钮.addEventListener("click", () => {
			                if(槽位类型.startsWith('饰品')) {
			                    this.显示饰品选择(槽位类型);
			                } else {
			                    this.显示装备选择(槽位类型);
			                }
			            });
			            槽.appendChild(选择按钮);
			        }
			        return 槽;
			    }
			    创建装备物品元素(物品, 槽位类型) {
			        const 元素 = document.createElement("div");
			        元素.className = "宠物已装备物品";
			        const 图标 = document.createElement("span");
			        图标.className = "宠物装备图标";
			        图标.textContent = 物品.图标;
			        图标.style.color = 物品.颜色表[物品.颜色索引];
			        const 名称 = document.createElement("span");
			        名称.className = "宠物装备名称";
			        名称.textContent = 物品.获取名称();
			        const 卸下按钮 = document.createElement("button");
			        卸下按钮.className = "通用按钮";
			        卸下按钮.textContent = "卸下";
			        卸下按钮.addEventListener("click", () => {
			            this.卸下装备(槽位类型); 
			            this.更新宠物管理窗口();
			        });
			        元素.appendChild(图标);
			        元素.appendChild(名称);
			        元素.appendChild(卸下按钮);
			        return 元素;
			    }
			    显示饰品选择(槽位类型) {
			        this.显示装备选择(槽位类型, '饰品');
			    }
			    显示装备选择(槽位类型, 物品类型过滤 = null) {
			        const 遮罩 = document.createElement("div");
			        遮罩.className = "宠物装备选择遮罩";
			        const 弹窗 = document.createElement("div");
			        弹窗.className = "宠物装备选择弹窗";
			        const 标题 = document.createElement("h4");
			        标题.textContent = `选择${槽位类型}`;
			        弹窗.appendChild(标题);
			        const 物品列表 = document.createElement("div");
			        物品列表.className = "宠物装备选择列表";
			        const 可用装备 = [...玩家背包.values()].filter(
			            (物品) => {
			                 if(物品类型过滤 === '饰品'){
			                    return 物品.类型 === '饰品' && !物品.是否隐藏;
			                }
			                return (槽位类型 === "武器" && 物品 instanceof 武器类) ||
			                (槽位类型 === "防具" && 物品 instanceof 防御装备类)
			            }
			        );
			        if (可用装备.length === 0) {
			            const 提示 = document.createElement("div");
			            提示.className = "无装备提示";
			            提示.textContent = `无可用${物品类型过滤 || 槽位类型}装备`;
			            物品列表.appendChild(提示);
			        } else {
			            可用装备.forEach((物品) => {
			                const 物品元素 = this.创建可选装备元素(
			                    物品,
			                    槽位类型
			                );
			                物品列表.appendChild(物品元素);
			            });
			        }
			        弹窗.appendChild(物品列表);
			        const 关闭按钮 = document.createElement("button");
			        关闭按钮.className = "关闭按钮";
			        关闭按钮.textContent = "×";
			        关闭按钮.onclick = () => {
			            弹窗.style.transform =
			                "translate(-50%, -50%) scale(0.9)";
			            弹窗.style.opacity = 0;
			            setTimeout(() => {
			                遮罩.remove();
			            }, 300);
			        };
			        弹窗.appendChild(关闭按钮);
			        遮罩.appendChild(弹窗);
			        document.querySelector(".宠物管理窗口").appendChild(遮罩);
			    }
			    创建可选装备元素(物品, 槽位类型) {
			        const 元素 = document.createElement("div");
			        元素.className = "宠物可选装备";
			        const 图标 = document.createElement("span");
			        图标.className = "宠物可选装备图标";
			        图标.textContent = 物品.图标;
			        图标.style.color = 物品.颜色表[物品.颜色索引];
			        const 名称 = document.createElement("span");
			        名称.className = "宠物可选装备名称";
			        名称.textContent = 物品.获取名称();
			        const 选择按钮 = document.createElement("button");
			        选择按钮.className = "宠物装备选择确认按钮";
			        选择按钮.textContent = "选择";
			        选择按钮.addEventListener("click", () => {
			            this.装备物品(物品, 槽位类型);
			            let 弹窗 = document.querySelector(".宠物装备选择弹窗");
			            弹窗.style.transform =
			                "translate(-50%, -50%) scale(0.9)";
			            弹窗.style.opacity = 0;
			            setTimeout(() => {
			                document
			                    .querySelector(".宠物装备选择遮罩")
			                    .remove();
			            }, 300);
			            更新装备显示();
			            更新背包显示();
			        });
			        元素.appendChild(图标);
			        元素.appendChild(名称);
			        元素.appendChild(选择按钮);
			        return 元素;
			    }
			    创建技能面板() {
			        const 面板 = document.createElement("div");
			        面板.className = "宠物技能面板";
			        面板.innerHTML = "<h4>技能</h4>";
			        const 技能列表 = this.自定义数据.get("技能");
			        if (技能列表 && 技能列表.length > 0) {
			            技能列表.forEach((技能) => {
			                const 技能元素 = document.createElement("div");
			                技能元素.className = "宠物技能";
			                技能元素.innerHTML = `
			        <p><strong>${技能.名称}</strong> (等级 ${技能.等级})</p>
			        <p>${技能.描述}</p>
			    `;
			                面板.appendChild(技能元素);
			            });
			        } else {
			            面板.innerHTML += "<p>暂无技能</p>";
			        }
			        return 面板;
			    }
			    获取提示() {
			        const data = this.自定义数据;
			        const 装备 = data.get("装备");
			        const 武器 = 装备?.武器 ? 装备.武器.获取名称() : "无";
			        const 防具 = 装备?.防具 ? 装备.防具.获取名称() : "无";
			
			        const 饰品文本列表 = [];
			        for(let i=1; i <= (data.get('饰品栏数量') || 0); i++) {
			            const 饰品 = 装备?.[`饰品${i}`];
			            if(饰品) 饰品文本列表.push(饰品.获取名称());
			        }
			        const 饰品文本 = 饰品文本列表.length > 0 ? 饰品文本列表.join(', ') : "无";
			
			        return [
			            `${this.获取名称()} (等级 ${data.get("等级")})`,
			            `类型：${this.类型}`,
			            `品质：${"★".repeat(this.品质)}`,
			            `生命值: ${data.get("当前生命值")} / ${data.get(
			                "最大生命值"
			            )}`,
			            `武器: ${武器}`,
			            `防具: ${防具}`,
			            `饰品: ${饰品文本}`,
			            `${this.效果描述}`,
			        ].join("\n");
			    }
			}
			class 熊猫 extends 宠物 {
			    constructor(配置 = {}) {
			        super({
			            名称: "熊猫",
			            图标: 图标映射.熊猫,
			            品质: 3,
			            颜色索引: 2,
			            饰品栏数量: 2,
			            效果描述:
			                "来自神秘竹林的守护者，擅长竹叶飞刀和强力防御。",
			            基础攻击力: 1,
			            基础防御力: 2,
			            最大生命值: 40,
			            强化: 配置.强化 || false,
			            技能: [
			                {
			                    名称: "竹叶飞刀",
			                    等级: 1,
			                    描述: "投掷锋利的竹叶，对单个敌人造成伤害。伤害随技能等级提升。",
			                    时机: "攻击",
			                    索引: 0,
			                },
			                {
			                    名称: "金钟罩",
			                    等级: 1,
			                    描述: "受到攻击时有几率触发金钟罩，使攻击来源攻击力下降。抵挡比例随技能等级提升。",
			                    时机: "被攻击",
			                    索引: 1,
			                },
			            ],
			            ...配置,
			        });
			        this.技能效果 = [
			            function (宠物, 目标怪物列表) {
			                if (!目标怪物列表 || 目标怪物列表.length === 0)
			                    return;
			                const 技能等级 =
			                    宠物.自定义数据.get("技能")[0].等级; // 获取第一个技能的等级
			                const 基础伤害 = 1;
			                const 伤害 = 基础伤害 + 技能等级 * 3;
			
			                // 随机选择一个目标
			                const 目标 =
			                    目标怪物列表[
			                        Math.floor(
			                            prng() * 目标怪物列表.length
			                        )
			                    ];
			                目标.受伤(伤害, 宠物);
			                添加日志(
			                    `${宠物.名称}使用了竹叶飞刀！造成了 ${伤害} 点伤害`,
			                    "成功"
			                );
			            },
			            function (宠物, 来源) {
			                const 技能等级 =
			                    宠物.自定义数据.get("技能")[1].等级; // 获取第二个技能的等级
			                const 基础格挡率 = 0.15;
			                const 格挡率 = Math.min(
			                    0.85,
			                    基础格挡率 + (技能等级 - 1) * 0.05
			                );
			
			                if (
			                    prng() < 格挡率 &&
			                    来源 instanceof 怪物
			                ) {
			                    // 触发格挡
			                    const 基础减伤 = 0.8;
			                    const 减伤比例 = Math.min(
			                        0,
			                        基础减伤 - 技能等级 * 0.05
			                    );
			                    来源.基础攻击力 = Math.floor(
			                        来源.基础攻击力 * 减伤比例
			                    ); //修改攻击者的基础攻击力
			                    添加日志(`${宠物.名称}触发了金钟罩！`, "成功");
			                }
			            },
			        ];
			    }
			
			    升级() {
			        const 升级成功 = super.升级();
			        if (升级成功) {
			            const 技能列表 = this.自定义数据.get("技能");
			            if (技能列表) {
			                // 随机升级一个技能
			                const 随机技能索引 = Math.floor(
			                    prng() * 技能列表.length
			                );
			                技能列表[随机技能索引].等级 += 1;
			                显示通知(
			                    `${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`,
			                    "成功"
			                );
			                window.宠物管理窗口.querySelector(
			                    ".宠物技能面板"
			                ).innerHTML = "";
			                window.宠物管理窗口
			                    .querySelector(".宠物技能面板")
			                    .appendChild(this.创建技能面板());
			            }
			        }
			        return 升级成功;
			    }
			
			    当玩家被攻击(原始攻击力, 来源) {
			        if (this.自定义数据.get("休眠中")) return 原始攻击力;
			
			        let 最终攻击力 = 原始攻击力;
			
			        // 宠物装备的防具效果
			        const 防具 = this.自定义数据.get("装备")?.防具;
			        if (防具) {
			            最终攻击力 = 防具.当被攻击(最终攻击力, 来源);
			        }
			
			        最终攻击力 = Math.max(
			            0,
			            最终攻击力 - this.自定义数据.get("基础防御力")
			        );
			        if (最终攻击力 <= 0)
			            最终攻击力 = Math.round(prng() * 100) / 100;
			        const 承担比例 = 0.3;
			        const 宠物承担伤害 = Math.floor(最终攻击力 * 承担比例);
			        this.受伤(宠物承担伤害);
			        最终攻击力 -= 宠物承担伤害;
			
			        this.触发技能("被攻击", 来源);
			        return 最终攻击力;
			    }
			}
class 火蜥蜴 extends 宠物 {
    constructor(配置 = {}) {
        super({
            名称: "火蜥蜴",
            图标: 图标映射.火蜥蜴,
            品质: 4,
            颜色索引: 4,
            饰品栏数量: 2,
            效果描述: "喷射旋转的火焰并能震开敌人。",
            基础攻击力: 6,
            基础防御力: 3,
            最大生命值: 40,
            技能: [
                {
                    名称: "旋转火棍",
                    等级: 1,
                    描述: "向最近的敌人发射一道旋转的火焰路径，点燃路径上的所有敌人。",
                    时机: "攻击",
                    索引: 0,
                },
                {
                    名称: "烈焰震击",
                    等级: 1,
                    描述: "释放火焰冲击波，将所有可见的敌人击退一格。",
                    时机: "被攻击",
                    索引: 1,
                },
            ],
            ...配置,
        });

        this.技能效果 = [
            (宠物, 目标怪物列表) => {
                const 技能 = 宠物.自定义数据.get("技能")[0];
                const 目标 = 宠物.寻找最近怪物目标();
                if (!目标) return;

                const 初始路径 = 获取直线路径(宠物.x, 宠物.y, 目标.x, 目标.y);
                if (!初始路径 || 初始路径.length < 2) return;

                const 火棍长度 = 3 + 技能.等级;
                const 旋转帧数 = 8;
                const 每帧延迟 = 50;
                const 旋转总角度 = 360;
                const 已击中怪物 = new Set();
                
                const 初始向量X = 初始路径[1].x - 宠物.x;
                const 初始向量Y = 初始路径[1].y - 宠物.y;
                const 初始角度 = Math.atan2(初始向量Y, 初始向量X);

                for (let i = 0; i < 旋转帧数; i++) {
                    setTimeout(() => {
                        const 当前旋转角度 = 初始角度 + (i / (旋转帧数 - 1)) * (旋转总角度 * Math.PI / 180);
                        const 当前帧格子 = new Set();

                        for (let j = 1; j <= 火棍长度; j++) {
                            const x = Math.round(宠物.x + Math.cos(当前旋转角度) * j);
                            const y = Math.round(宠物.y + Math.sin(当前旋转角度) * j);

                            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) break;
                            当前帧格子.add(`${x},${y}`);
                        }

                        const 格子列表 = Array.from(当前帧格子).map(s => {
                            const [x, y] = s.split(',').map(Number);
                            return { x, y };
                        });

                        计划显示格子特效(格子列表, "FFA500", 5);

                        格子列表.forEach(格 => {
                            const 单元格 = 地牢[格.y]?.[格.x];
                            const 怪物 = 单元格?.关联怪物;
                            if (怪物 && !已击中怪物.has(怪物)) {
                                new 状态效果("火焰", 效果颜色编号映射[效果名称编号映射.火焰], "火", 3 + 技能.等级, null, null, 怪物, 3);
                                已击中怪物.add(怪物);
                            }
                        });
                    }, i * 每帧延迟);
                }
            },
            (宠物, 来源) => {
                const 技能 = 宠物.自定义数据.get("技能")[1];
                if (prng() > 0.3 + 技能.等级 * 0.1) return;
                
                添加日志(`${宠物.名称} 发动了烈焰震击！`, "成功");
                计划显示格子特效([{x: 宠物.x, y: 宠物.y}], "FF4500", 0);

                所有怪物.forEach(怪物 => {
                    if (怪物.状态 !== 怪物状态.活跃 || !检查视线(宠物.x, 宠物.y, 怪物.x, 怪物.y, 15)) return;

                    const dx = 怪物.x - 宠物.x;
                    const dy = 怪物.y - 宠物.y;
                    let 击退DX = 0, 击退DY = 0;

                    if (Math.abs(dx) > Math.abs(dy)) 击退DX = Math.sign(dx);
                    else 击退DY = Math.sign(dy);

                    if (击退DX === 0 && 击退DY === 0) {
                        const 随机方向 = [[1,0], [-1,0], [0,1], [0,-1]][Math.floor(prng() * 4)];
                        击退DX = 随机方向[0];
                        击退DY = 随机方向[1];
                    }
                    
                    const { x: 最终X, y: 最终Y } = 怪物.计算最大甩飞位置(怪物.x, 怪物.y, 击退DX, 击退DY, 1 + 技能.等级);
                    if (最终X !== 怪物.x || 最终Y !== 怪物.y) {
                        const oldX = 怪物.x, oldY = 怪物.y;
                        怪物.恢复背景类型();
                        怪物.x = 最终X;
                        怪物.y = 最终Y;
                        怪物.保存新位置类型(最终X, 最终Y);
                        地牢[最终Y][最终X].类型 = 单元格类型.怪物;
                        地牢[最终Y][最终X].关联怪物 = 怪物;
                        怪物.处理地形效果();
                        怪物动画状态.set(怪物, {
                            旧逻辑X: oldX, 旧逻辑Y: oldY, 目标逻辑X: 最终X, 目标逻辑Y: 最终Y,
                            视觉X: oldX, 视觉Y: oldY, 动画开始时间: Date.now(), 正在动画: true,
                        });
                    }
                });
            },
        ];
    }
    			    升级() {
			        if (super.升级()) {
			            const 技能列表 = this.自定义数据.get("技能");
			            const 随机技能索引 = Math.floor(
			                prng() * 技能列表.length
			            );
			            技能列表[随机技能索引].等级 += 1;
			            显示通知(
			                `${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`,
			                "成功"
			            );
			        }
			    }
}   
class 定位器地图 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            名称: "定位器地图",
			            图标: 图标映射.定位器地图,
			            品质: 1,
			            颜色索引: 0,
			            效果描述: "装备后，可为你寻找下楼楼梯的位置。",
			            ...配置,
			        });
			    }
			        使用() {
			        return false;
			        }
			}
class 烟雾弹 extends 物品 {
    constructor(配置 = {}) {
        super({
            类型: "消耗品",
            名称: "烟雾弹",
            图标: 图标映射.烟雾弹,
            品质: 3,
            颜色索引: 2,
            堆叠数量: 配置.数量 || 1,
            最大堆叠数量: 16,
            效果描述: "制造一片烟雾，藏身其中可以免疫伤害且不会被怪物发现。",
            强化: 配置.强化 || false,
            ...配置,
            数据: {
                扩散范围: 配置.扩散范围??25,
                持续时间: 配置.持续时间??(10 + (配置.强化 ? 5 : 0)),
            },
            
        });
    }

    使用() {
        if (this.堆叠数量 <= 0) return false;
        
        
        const 范围 = this.自定义数据.get("扩散范围");
        const 持续 = this.自定义数据.get("持续时间");

        const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0 }];
        const 已访问 = new Set([`${玩家.x},${玩家.y}`]);
        let 放置计数 = 0;

        const 放置烟雾 = (x, y) => {
            if (位置是否可用(x, y, false)) {
                const 烟雾实例 = new 烟雾({
                    倒计时: 持续,
                    爆炸时间: 持续,
                });
                放置物品到单元格(烟雾实例, x, y);
                return true;
            }
            return false;
        };

        if (放置烟雾(玩家.x, 玩家.y)) 放置计数++;
        
        while (队列.length > 0 && 放置计数 < 范围) {
            const { x, y, 距离 } = 队列.shift();
            
            const 方向 = [[0, -1], [0, 1], [-1, 0], [1, 0]];
            方向.sort(() => prng() - 0.5);

            for (const [dx, dy] of 方向) {
                const 新X = x + dx;
                const 新Y = y + dy;
                const 键 = `${新X},${新Y}`;
                if (新X >= 0 && 新X < 地牢大小 && 新Y >= 0 && 新Y < 地牢大小 && !已访问.has(键)) {
                    已访问.add(键);
                    if (放置烟雾(新X, 新Y)) {
                        放置计数++;
                        队列.push({ x: 新X, y: 新Y, 距离: 距离 + 1 });
                        if (放置计数 >= 范围) break;
                    }
                }
            }
             if (放置计数 >= 范围) break;
        }

        显示通知("烟雾弥漫开来！", "成功");
        this.堆叠数量--;
        if (this.堆叠数量 <= 0) {
            处理销毁物品(this.唯一标识, true);
        }
        return true;
    }
}

class 烟雾 extends 物品 {
    constructor(配置 = {}) {
        super({
            类型: "地形",
            名称: "烟雾",
            图标: 图标映射.烟雾,
            品质: 1,
            颜色索引: 5,
            能否拾起: false,
            是否正常物品: false,
            阻碍怪物: false,
            效果描述: "浓厚的烟雾，可以隐藏身形。",
            ...配置,
            数据: {
                倒计时: 配置.倒计时 || 10,
                爆炸时间: 配置.倒计时 || 10,
            },
            
        });
        if (!所有计时器.some(t => t.唯一标识 === this.唯一标识)) {
            所有计时器.push(this);
        }
    }

    更新倒计时() {
        const 剩余回合 = this.自定义数据.get("倒计时") - 1;
        this.自定义数据.set("倒计时", 剩余回合);
        if (剩余回合 <= 0) {
            this.移除自身();
        }
    }

    移除自身() {
        if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
            地牢[this.y][this.x].关联物品 = null;
            if (地牢[this.y][this.x].类型 === 单元格类型.物品) {
                地牢[this.y][this.x].类型 = null;
            }
        }
        所有计时器 = 所有计时器.filter(item => item !== this);
    }
}
			class 水母 extends 宠物 {
			    constructor(配置 = {}) {
			        super({
			            名称: "水母",
			            图标: 图标映射.水母,
			            品质: 4,
			            颜色索引: 3,
			            饰品栏数量: 3,
			            效果描述:
			                "来自虚空的神秘生物，可以扭曲空间，并拥有强大的精神控制力。",
			            基础攻击力: 2,
			            基础防御力: 2,
			            最大生命值: 30,
			            强化: 配置.强化 || false,
			            技能: [
			                {
			                    名称: "空间扭曲",
			                    等级: 1,
			                    描述: "被攻击时有几率扭曲空间，使攻击者传送回其原始位置。",
			                    时机: "被攻击",
			                    索引: 0,
			                },
			                {
			                    名称: "精神控制",
			                    等级: 1,
			                    描述: "攻击时有几率魅惑一个敌人，使其在短时间内为你作战。",
			                    时机: "攻击",
			                    索引: 1,
			                },
			            ],
			            ...配置,
			        });
			        this.技能效果 = [
			            function (宠物, 来源) {
			                if (!(来源 instanceof 怪物)) return;
			                const 技能等级 =
			                    宠物.自定义数据.get("技能")[0].等级;
			                const 触发几率 = Math.min(
			                    0.85,
			                    0.1 + (技能等级 - 1) * 0.05
			                ); // 初始10%几率, 每级增加5%
			
			                if (prng() < 触发几率) {
			                    // 记录原始位置
			                    if (!来源.原始位置) {
			                        来源.原始位置 = { x: 来源?.x, y: 来源?.y };
			                        return;
			                    }
			                    if (
			                        来源.原始位置 &&
			                        来源.原始位置.x >= 0 &&
			                        来源.原始位置.x < 地牢大小 &&
			                        来源.原始位置.y >= 0 &&
			                        来源.原始位置.y < 地牢大小
			                    ) {
			                        来源.恢复背景类型();
			                        来源.x = 来源.原始位置.x;
			                        来源.y = 来源.原始位置.y;
			                        地牢[来源.y][来源.x].类型 = 单元格类型.怪物;
			                        地牢[来源.y][来源.x].关联怪物 = 来源;
			                        显示通知(
			                            `${宠物.名称}发动了空间扭曲！`,
			                            "成功"
			                        );
			                        绘制();
			                    }
			                }
			            },
			            function (宠物, 目标怪物列表) {
			                if (!目标怪物列表 || 目标怪物列表.length === 0)
			                    return;
			                const 技能等级 =
			                    宠物.自定义数据.get("技能")[1].等级;
			                let 触发几率 = Math.min(
			                    0.85,
			                    0.1 + (技能等级 - 1) * 0.05
			                );
			                //触发几率 = 1;
			                if (prng() < 触发几率) {
			                    const 目标 =
			                        目标怪物列表[
			                            Math.floor(
			                                prng() * 目标怪物列表.length
			                            )
			                        ];
			
			                    if (
			                        怪物状态表.get(目标)?.类型 !== "魅惑" &&
			                        !(目标 instanceof 炸弹怪物) &&
			                        !(目标 instanceof 大魔法师)
			                    ) {
			                        const 持续回合 = 2 + 技能等级; // 基础2回合，每级+1回合
			                        const 控制状态 = new 状态效果(
			                            "魅惑",
			                            "#8e44ad",
			                            "魅",
			                            持续回合,
			                            null,
			                            null,
			                            目标
			                        );
			
			                        添加日志(
			                            `${宠物.名称}控制了${目标.类型}!`,
			                            "成功"
			                        );
			                    }
			                }
			            },
			        ];
			    }
			    升级() {
			        const 升级成功 = super.升级();
			        if (升级成功) {
			            const 技能列表 = this.自定义数据.get("技能");
			            if (技能列表) {
			                // 随机升级
			                const 随机技能索引 = Math.floor(
			                    prng() * 技能列表.length
			                );
			                技能列表[随机技能索引].等级 += 1;
			                显示通知(
			                    `${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`,
			                    "成功"
			                );
			                window.宠物管理窗口.querySelector(
			                    ".宠物技能面板"
			                ).innerHTML = "";
			                window.宠物管理窗口
			                    .querySelector(".宠物技能面板")
			                    .appendChild(this.创建技能面板());
			            }
			        }
			        return 升级成功;
			    }
			}
			class 魔法水晶 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: `${配置.水晶ID}水晶`,
			            图标: 图标映射.水晶,
			            品质: 5,
			            颜色索引: 配置.颜色索引 || 0,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: true,
			            效果描述:
			                "一个蕴含着强大魔法能量的水晶，似乎是某种封印的核心。",
			            数据: {
			                水晶ID: 配置.水晶ID || "未知",
			                已摧毁: false,
			                管辖房间: 配置.管辖房间 || [],
			            },
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        if (this.自定义数据.get("已摧毁")) return false;
			
			        const 管辖房间名称列表 = this.自定义数据.get("管辖房间");
			        if (管辖房间名称列表 && 管辖房间名称列表.length > 0) {
			            for (const 房间名称 of 管辖房间名称列表) {
			                const 房间 = 房间列表.find(
			                    (r) => r.名称 === 房间名称
			                );
			                if (房间) {
			                    for (const 怪物 of 所有怪物) {
			                        if (
			                            怪物.房间ID === 房间.id &&
			                            怪物.当前生命值 > 0
			                        ) {
			                            显示通知(
			                                `水晶受到保护，必须先清除 ${房间名称} 内的所有怪物！`,
			                                "警告"
			                            );
			                            return false;
			                        }
			                    }
			                }
			            }
			        }
			
			        this.自定义数据.set("已摧毁", true);
			        显示通知(
			            `${this.名称}被摧毁了，发出了一声清脆的碎裂声！`,
			            "成功"
			        );
			
			        if (
			            this.x !== null &&
			            this.y !== null &&
			            地牢[this.y]?.[this.x]?.关联物品 === this
			        ) {
			            地牢[this.y][this.x].关联物品 = null;
			            if (地牢[this.y][this.x].类型 === 单元格类型.物品) {
			                地牢[this.y][this.x].类型 = null;
			            }
			        }
			        绘制();
			        检查所有水晶状态();
			        return true;
			    }
			
			    get 颜色表() {
			        return 颜色表;
			    }
			}
			class 旗帜 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "胜利旗帜",
			            图标: 图标映射.旗帜,
			            品质: 5,
			            颜色索引: 2,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "触碰它，宣告你的胜利！",
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        if (自定义全局设置.胜利条件.清除所有怪物) {
			            const 待清除怪物列表 = 所有怪物.filter(monster => {
			                // 排除远射陷阱
			                if (monster instanceof 远射陷阱) {
			                    return false;
			                }
			                // 排除血量异常或已经死亡的怪物
			                if (monster.当前生命值 <= 0) {
			                    return false;
			                }
			                // 如果未来有其他非战斗“怪物”单位，可在此处继续添加排除逻辑
			                
			                // 默认情况下，所有其他怪物都需要被清除
			                return true;
			            });
			
			            if (待清除怪物列表.length === 0) {
			                检查胜利条件();
			            } else {
			                显示通知(`还有 ${待清除怪物列表.length} 只怪物没有被清除！`, '警告');
			            }
			        } else {
			            检查胜利条件();
			        }
			        return true;
			    }
			}
			
			class 符文圈 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: `${配置.效果类型}符文圈`,
			            图标: 图标映射.符文圈,
			            品质: 5,
			            颜色索引: 效果名称编号映射[配置.效果类型] || 0,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: false,
			
			            效果描述: "周期性激活的魔法符文。",
			            数据: {
			                周期: 配置.周期 || 10,
			                剩余周期:
			                    配置.剩余周期 ??
			                    Math.floor(prng() * (配置.周期 || 10)),
			                持续时间: 配置.持续时间 || 3,
			                效果类型: 配置.效果类型 || "狂暴",
			                强度: 配置.强度 || 2,
			                ...配置.数据,
			            },
			            ...配置,
			        });
			        所有计时器.push(this);
			    }
			
			    更新倒计时() {
			        let 剩余 = this.自定义数据.get("剩余周期") - 1;
			        if (剩余 <= 0) {
			            const 效果列表 = ["狂暴", "神龟", "缓慢", "中毒"];
			            const 当前效果 = this.自定义数据.get("效果类型");
			            const 当前索引 = 效果列表.indexOf(当前效果);
			            const 下一个索引 = (当前索引 + 1) % 效果列表.length;
			            const 新效果类型 = 效果列表[下一个索引];
			
			            this.自定义数据.set("效果类型", 新效果类型);
			            this.名称 = `${新效果类型}符文圈`;
			            this.颜色索引 = 效果名称编号映射[新效果类型] || 0;
			            this.自定义数据.set(
			                "剩余周期",
			                this.自定义数据.get("周期")
			            );
			        } else {
			            this.自定义数据.set("剩余周期", 剩余);
			        }
			
			        this.应用效果();
			    }
			
			    应用效果() {
			        const 效果类型 = this.自定义数据.get("效果类型");
			        const 颜色 = 效果颜色编号映射[this.颜色索引];
			        const 图标 = this.图标;
			        const 持续时间 = this.自定义数据.get("持续时间");
			        const 强度 = this.自定义数据.get("强度");
			
			        if (玩家.x === this.x && 玩家.y === this.y) {
			            new 状态效果(
			                效果类型,
			                颜色,
			                图标,
			                持续时间,
			                null,
			                null,
			                null,
			                强度
			            );
			        }
			        所有怪物.forEach((怪物) => {
			            if (怪物.x === this.x && 怪物.y === this.y) {
			                new 状态效果(
			                    效果类型,
			                    颜色,
			                    图标,
			                    持续时间,
			                    null,
			                    null,
			                    怪物,
			                    强度
			                );
			            }
			        });
			    }
			
			    get 颜色表() {
			        return 效果颜色编号映射;
			    }
			}
			let 游戏开始时间 = null;
			class 奖杯物品 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "胜利奖杯",
			            图标: 图标映射.奖杯,
			            品质: 5,
			            颜色索引: 4, 
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: true,
			            效果描述: "一座闪耀的奖杯，纪念着你来之不易的胜利。",
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        显示结算界面();
			        return true;
			    }
			}
			
			let 游戏事件日志 = [];
			function 获取结局评级(统计数据) {
			    let 分数 = 75;
			    let 评语池 = {
			        正面: [],
			        中立: [],
			        负面: []
			    };
			
			    if (统计数据.游戏时长秒 < 12000) { 
			        分数 += 20;
			        评语池.正面.push("风驰电掣");
			    } else if (统计数据.游戏时长秒 > 36000) {
			        分数 -= 10;
			        评语池.负面.push("一次漫长的苦旅");
			    } else {
			        评语池.中立.push("步履不停");
			    }
			    
			    if (统计数据.承受伤害 === 0) {
			        分数 += 30;
			        评语池.正面.push("毫发无伤的幻神");
			    } else if (统计数据.承受伤害 < 600) {
			        分数 += 10;
			        评语池.正面.push("身法灵动");
			    } else if (统计数据.承受伤害 > 2000) {
			        分数 -= 10;
			        评语池.负面.push("伤痕累累");
			    }
			
			    if (统计数据.击杀怪物 > 500) {
			        分数 += 15;
			        评语池.正面.push("地牢灾星");
			    } else if (统计数据.击杀怪物 < 300) {
			        分数 -= 5;
			    } else {
			        评语池.中立.push("清道夫");
			    }
			
			    if (统计数据.获得金币 > 200) {
			        分数 += 10;
			        评语池.正面.push("富甲一方");
			    }
			
			    if (玩家死亡次数 === 0) {
			        分数 += 25;
			        评语池.正面.push("不灭灵魂");
			    } else {
			        分数 -= 玩家死亡次数;
			        评语池.负面.push(`浴火重生x${玩家死亡次数}`);
			    }
			
			    let 最终评语 = "";
			    if (评语池.正面.length >= 2) {
			        最终评语 = `“${评语池.正面[0]}，${评语池.正面[1]}”`;
			    } else if (评语池.正面.length === 1) {
			        最终评语 = 评语池.中立.length > 0 ? `“${评语池.正面[0]}，亦是${评语池.中立[0]}”` : `“${评语池.正面[0]}”`;
			    } else if(评语池.负面.length > 0) {
			        最终评语 = `“${评语池.负面.join('，')}”`;
			    } else {
			        最终评语 = "“一次平凡但完整的冒险”";
			    }
			
			    if (分数 >= 135) return { 评级: 'S+', 标题: '地牢传奇', 颜色类: '评级-S-plus', 结束语: '你的事迹，已成为地牢中永恒的神话。\n'+最终评语 };
			    if (分数 >= 120) return { 评级: 'S', 标题: '地牢征服者', 颜色类: '评级-S', 结束语: '黑暗在你面前退却，你已是此地无可争议的主宰。\n' +最终评语};
			    if (分数 >= 100) return { 评级: 'A', 标题: '英勇探险家', 颜色类: '评级-A', 结束语: '凭借勇气与智慧，你战胜了所有险阻。\n'+最终评语 };
			    if (分数 >= 85) return { 评级: 'B', 标题: '熟练的冒险者', 颜色类: '评级-B', 结束语: '历经磨难，地牢的秘密已向你敞开。' +最终评语};
			    if (分数 >= 70) return { 评级: 'C', 标题: '幸存者', 颜色类: '评级-C', 结束语: '你在深渊的边缘走了一遭，并活了下来。\n'+最终评语 };
			    return { 评级: 'D', 标题: '惨胜', 颜色类: '评级-D', 结束语: '你赢了，但代价是什么呢？\n' +最终评语};
			}
			
			function 生成结算粒子(容器) {
			    if (!容器) return;
			    容器.innerHTML = '';
			    const 粒子数量 = 20;
			    for (let i = 0; i < 粒子数量; i++) {
			        const 粒子 = document.createElement('div');
			        粒子.className = '结算粒子';
			        粒子.style.left = `${prng() * 100}%`;
			        粒子.style.animationDelay = `${prng() * 15}s`;
			        粒子.style.animationDuration = `${5 + prng() * 10}s`;
			        容器.appendChild(粒子);
			    }
			}
			
			            function 显示结算界面() {
			    if (游戏状态 === '图鉴' || document.getElementById('结算界面遮罩').style.display === 'flex') return;
			
			    游戏状态 = "胜利";
			    导出存档();
			
			    const 遮罩 = document.getElementById('结算界面遮罩');
			    const 标题元素 = 遮罩.querySelector('.结算标题');
			    const 评级元素 = document.getElementById('结局评级');
			    const 评语元素 = document.getElementById('结束评语');
			    const 统计容器 = 遮罩.querySelector('.结算统计容器');
			    const 凭证码元素 = document.getElementById('通关凭证码');
			    
			    const 返回按钮 = document.getElementById('结算返回主菜单按钮');
			    const 粒子容器 = document.getElementById('结算粒子容器');
			
			    const 游戏时长秒 = Math.floor((Date.now() - 游戏开始时间) / 1000);
			    const 分钟 = Math.floor(游戏时长秒 / 60);
			    const 秒 = 游戏时长秒 % 60;
			    const 游戏时长文本 = `${分钟}分 ${秒}秒`;
			
			    const 总金币 = [...玩家背包.values()].filter(i => i instanceof 金币).reduce((sum, i) => sum + i.堆叠数量, 0);
			
			    const 统计数据 = {
			        '游戏时长': { 数值: 游戏时长文本, 图标: 图标映射.时间 },
			        '击杀怪物': { 数值: `${已击杀怪物数}`, 图标: 图标映射.死亡图标 },
			        '探索回合': { 数值: `${玩家总移动回合数}`, 图标: 图标映射.脚印 },
			        '获得金币': { 数值: `${总金币}`, 图标: 图标映射.金币 },
			        '承受伤害': { 数值: `${玩家总受到伤害.toFixed(1)}`, 图标:图标映射.修补心 },
			        '最高层数': { 数值: `${当前层数}`, 图标: 图标映射.旗帜 }
			    };
			
			    统计容器.innerHTML = '';
			    for (const [标签, 数据] of Object.entries(统计数据)) {
			        const 条目 = document.createElement('div');
			        条目.className = '统计条目';
			        条目.innerHTML = `
			            <div class="统计图标">${数据.图标}</div>
			            <div class="统计数值">${数据.数值}</div>
			            <div class="统计标签">${标签}</div>
			        `;
			        统计容器.appendChild(条目);
			    }
			
			    const 评级数据 = 获取结局评级({游戏时长秒: 游戏时长秒, 击杀怪物: 已击杀怪物数, 获得金币: 总金币, 回合数: 玩家总移动回合数, 承受伤害: 玩家总受到伤害});
			    标题元素.textContent = 评级数据.标题;
			    评级元素.textContent = 评级数据.评级;
			    评级元素.className = `结局评级 ${评级数据.颜色类}`;
			    评语元素.textContent = 评级数据.结束语;
			
			    const 胜利凭证 = 生成死亡凭证(当前层数);
			    凭证码元素.textContent = 胜利凭证;
			
			    返回按钮.onclick = () => {
			        遮罩.classList.remove('显示');
			        重置所有游戏状态();
			        显示主菜单();
			    };
			
			    生成结算粒子(粒子容器);
			    遮罩.style.display = 'flex';
			    requestAnimationFrame(() => {
			        遮罩.classList.add('显示');
			    });
			}
			class 魔法师法杖 extends 武器类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "魔法师法杖",
			            图标: 图标映射.魔法师法杖,
			            品质: 5,
			            基础攻击力: 10,
			            冷却回合: 6,
			            攻击范围: 5,
			            耐久: 120,
			            效果描述: "释放大魔法师的经典法术，攻击模式随机。",
			            不可破坏: false,
			            ...配置,
			        });
			    }
			    使用(目标怪物,路径,使用者=玩家) {
			        if (this.自定义数据.get("冷却剩余") > 0) return false;
			        this.普通攻击(使用者);
			        this.自定义数据.set("冷却剩余", this.最终冷却回合);
			        this.自定义数据.set(
			            "耐久",
			            this.自定义数据.get("耐久") - this.耐久消耗
			        );
			        if (this.自定义数据.get("耐久") <= 0) {
			            处理销毁物品(this.唯一标识, true);
			            显示通知(`${this.名称} 已损坏！`, "警告");
			        }
			        更新装备显示();
			        return true;
			    }
			
			    普通攻击(使用者) {
			        const 攻击模式 = Math.floor(prng() * 4);
			        let 方向列表 = [];
			
			        switch (攻击模式) {
			            case 0:
			                方向列表 = [
			                    { dx: 0, dy: -1 },
			                    { dx: 0, dy: 1 },
			                    { dx: -1, dy: 0 },
			                    { dx: 1, dy: 0 },
			                ];
			                break;
			            case 1:
			                方向列表 = [
			                    { dx: -1, dy: -1 },
			                    { dx: 1, dy: -1 },
			                    { dx: -1, dy: 1 },
			                    { dx: 1, dy: 1 },
			                ];
			                break;
			            case 2:
			            case 3:
			                const 基本方向 = [
			                    { dx: 0, dy: -1 },
			                    { dx: 1, dy: 0 },
			                    { dx: 0, dy: 1 },
			                    { dx: -1, dy: 0 },
			                ];
			                const 顺时针方向变化 = [
			                    { dx: 1, dy: 0 },
			                    { dx: 0, dy: 1 },
			                    { dx: -1, dy: 0 },
			                    { dx: 0, dy: -1 },
			                ];
			                const 逆时针方向变化 = [
			                    { dx: 0, dy: -1 },
			                    { dx: -1, dy: 0 },
			                    { dx: 0, dy: 1 },
			                    { dx: 1, dy: 0 },
			                ];
			
			                基本方向.forEach((起始方向) => {
			                    let 当前方向 = 起始方向;
			                    let 当前X = 使用者.x;
			                    let 当前Y = 使用者.y;
			                    let 路径 = [];
			                    let 层数 = 0;
			                    while (
			                        Math.abs(当前X - 使用者.x) +
			                            Math.abs(当前Y - 使用者.y) <=
			                        this.最终攻击范围
			                    ) {
			                        层数++;
			                        let 步数 = 层数 * 2 - 1;
			                        if (层数 > 1) {
			                            const 方向变化 =
			                                攻击模式 === 2
			                                    ? 顺时针方向变化
			                                    : 逆时针方向变化;
			                            let 方向索引 = 方向变化.findIndex(
			                                (d) =>
			                                    d.dx === 当前方向.dx &&
			                                    d.dy === 当前方向.dy
			                            );
			                            方向索引 = (方向索引 + 1) % 4;
			                            当前方向 = 方向变化[方向索引];
			                            当前X += 当前方向.dx;
			                            当前Y += 当前方向.dy;
			                            if (
			                                !检查移动可行性(
			                                    当前X - 当前方向.dx,
			                                    当前Y - 当前方向.dy,
			                                    当前X,
			                                    当前Y
			                                )
			                            )
			                                break;
			                            const 单元格 = 地牢[当前Y]?.[当前X];
			                            if (
			                                单元格?.关联怪物 &&
			                                单元格.类型 === 单元格类型.怪物 &&
			                                单元格.关联怪物?.状态 ===
			                                    怪物状态.活跃
			                            ) {
			                                单元格.关联怪物.受伤(
			                                    this.攻击力,
			                                    this
			                                );
			                            }
			                            路径.push({ x: 当前X, y: 当前Y });
			                            步数--;
			                        }
			                        for (let i = 0; i < 步数; i++) {
			                            当前X += 当前方向.dx;
			                            当前Y += 当前方向.dy;
			                            if (
			                                !检查移动可行性(
			                                    当前X - 当前方向.dx,
			                                    当前Y - 当前方向.dy,
			                                    当前X,
			                                    当前Y
			                                )
			                            )
			                                break;
			                            const 单元格 = 地牢[当前Y]?.[当前X];
			                            if (
			                                单元格?.关联怪物 &&
			                                单元格.类型 === 单元格类型.怪物 &&
			                                单元格.关联怪物?.状态 ===
			                                    怪物状态.活跃
			                            ) {
			                                单元格.关联怪物.受伤(
			                                    this.攻击力,
			                                    this
			                                );
			                            }
			                            路径.push({ x: 当前X, y: 当前Y });
			                        }
			                        if (
			                            Math.abs(当前X - 使用者.x) +
			                                Math.abs(当前Y - 使用者.y) >
			                            this.最终攻击范围
			                        )
			                            break;
			                    }
			                    计划显示格子特效(路径);
			                });
			                return;
			        }
			
			        方向列表.forEach((方向) => {
			            let 当前X = 使用者.x + 方向.dx;
			            let 当前Y = 使用者.y + 方向.dy;
			            let 路径 = [];
			            while (
			                Math.abs(当前X - 使用者.x) +
			                    Math.abs(当前Y - 使用者.y) <=
			                this.最终攻击范围
			            ) {
			                if (
			                    !检查移动可行性(
			                        当前X - 方向.dx,
			                        当前Y - 方向.dy,
			                        当前X,
			                        当前Y
			                    )
			                )
			                    break;
			                const 单元格 = 地牢[当前Y]?.[当前X];
			                if (
			                    单元格?.关联怪物 &&
			                    单元格.类型 === 单元格类型.怪物 &&
			                    单元格.关联怪物?.状态 === 怪物状态.活跃
			                ) {
			                    单元格.关联怪物.受伤(this.攻击力, this);
			                    break;
			                }
			                路径.push({ x: 当前X, y: 当前Y });
			                当前X += 方向.dx;
			                当前Y += 方向.dy;
			            }
			            计划显示格子特效(路径);
			        });
			    }
			}
			
			class 大师附魔卷轴 extends 卷轴类 {
			    constructor(配置 = {}) {
			        super({
			            名称: "大师附魔卷轴",
			            品质: 5,
			            效果描述:
			                "从三个随机的高级附魔中选择一个，为装备附加。",
			            能量消耗: 50,
			            数据: {
			               附魔选项: [],
			            },
			            ...配置,
			        });
			        if (!this.自定义数据.get('附魔选项') || this.自定义数据.get('附魔选项').length === 0) {
			            const 附魔池 = new 附魔卷轴({}).附魔池;
			            const 效果名池 = new 附魔卷轴({}).效果名;
			            const 随机效果 = [];
			            const 已选索引 = new Set();
			            while (随机效果.length < 3 && 已选索引.size < 附魔池.length) {
			                const 索引 = Math.floor(prng() * 附魔池.length);
			                if (!已选索引.has(索引)) {
			                    已选索引.add(索引);
			                    随机效果.push({
			                        效果函数名: 附魔池[索引].name,
			                        效果名: 效果名池[索引],
			                    });
			                }
			            }
			            this.自定义数据.set('附魔选项', 随机效果);
			        }
			    }
			
			    使用() {
			        const 效果列表 = this.自定义数据.get('附魔选项').map(opt => ({
			            效果函数: opt.效果函数名,
			            效果名: opt.效果名
			        }));
			
			        if (效果列表.length < 3) {
			            显示通知("附魔池不足，无法生成选项！", "错误");
			            return false;
			        }
			        if (!this.消耗能量()) return false;
			
			        this.显示选择界面(效果列表);
			        当前激活卷轴列表.delete(this);
			        return true;
			    }
			
			    显示选择界面(效果列表) {
			        玩家属性.允许移动++;
			        const 遮罩 = document.createElement("div");
			        遮罩.className = "重铸遮罩";
			        const 弹窗 = document.createElement("div");
			        弹窗.className = "重铸弹窗";
			        弹窗.innerHTML = `<div class="重铸弹窗-header"><h3>选择一个附魔</h3><button class="关闭按钮" id="三选一关闭按钮">×</button></div><div id="附魔选项容器" class="重铸弹窗-items"></div>`;
			        const 容器 = 弹窗.querySelector("#附魔选项容器");
			
			        const 关闭选择界面 = () => {
			            遮罩.remove();
			            玩家属性.允许移动--;
			            const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            if (能量条)
			                能量条.style.width = `${Math.min(
			                    100,
			                    当前能量 + this.自定义数据.get("能量消耗")/自定义全局设置.初始能量值*100
			                )}%`;
			            触发HUD显示();
			        };
			
			        弹窗.querySelector("#三选一关闭按钮").onclick =
			            关闭选择界面;
			
			        效果列表.forEach((效果) => {
			            const 按钮 = document.createElement("button");
			            按钮.className = "菜单按钮";
			            按钮.textContent = 效果.效果名;
			            按钮.onclick = () => {
			                遮罩.remove();
			                玩家属性.允许移动 -= 1;
			                const 临时附魔卷轴 = new 附魔卷轴({
			                    品质: 4,
			                    已解锁: true,
			                });
			                临时附魔卷轴.附魔效果 = 临时附魔卷轴[效果.效果函数];
			                临时附魔卷轴.当前附魔效果名 = 效果.效果名;
			                临时附魔卷轴.自定义数据.set('能量消耗',0);
			
			                const 原创建附魔弹窗 = 临时附魔卷轴.创建附魔弹窗;
			                临时附魔卷轴.创建附魔弹窗 = () => {
			                    const 附魔弹窗实例 =
			                        原创建附魔弹窗.call(临时附魔卷轴);
			                    const 原关闭按钮 =
			                        附魔弹窗实例.querySelector(".关闭按钮");
			                    if (原关闭按钮) {
			                        原关闭按钮.onclick = () => {
			                            附魔弹窗实例.classList.add("关闭中");
			                            setTimeout(() => {
			                                附魔弹窗实例.remove();
			                                当前激活卷轴列表.delete(
			                                    临时附魔卷轴
			                                );
			                                const 能量条 =
			                                    document.querySelector(
			                                        ".power-bar"
			                                    );
			                                const 当前能量 =
			                                    parseFloat(
			                                        能量条.style.width
			                                    ) || 0;
			                                if (能量条)
			                                    能量条.style.width = `${Math.min(
			                                        100,
			                                        当前能量 +
			                                            this.自定义数据.get(
			                                                "能量消耗"
			                                            )/自定义全局设置.初始能量值*100
			                                    )}%`;
			                                触发HUD显示();
			                            }, 300);
			                        };
			                    }
			                    return 附魔弹窗实例;
			                };
			
			                const 原执行附魔 = 临时附魔卷轴.执行附魔;
			                临时附魔卷轴.执行附魔 = (装备, 弹窗, 元素) => {
			                    const 附魔成功 = 原执行附魔.call(
			                        临时附魔卷轴,
			                        装备,
			                        弹窗,
			                        元素
			                    );
			                    if (附魔成功) {
			                        处理销毁物品(this.唯一标识, true);
			                    } else {
			                        显示通知('无法应用附魔','错误')
			                    }
			                };
			
			                临时附魔卷轴.使用();
			            };
			            容器.appendChild(按钮);
			        });
			        遮罩.appendChild(弹窗);
			        document.body.appendChild(遮罩);
			    }
			}
			class 小书魔 extends 宠物 {
			    constructor(配置 = {}) {
			        super({
			            名称: "小书魔",
			            图标: 图标映射.小书魔,
			            品质: 4,
			            饰品栏数量: 4,
			            效果描述: "它似乎对魔法卷轴有着天生的亲和力。",
			            基础攻击力: 3,
			            基础防御力: 1,
			            最大生命值: 25,
			            技能: [
			                {
			                    名称: "奥术飞弹",
			                    等级: 1,
			                    描述: "攻击时有几率发射奥术飞弹，造成额外伤害。",
			                    时机: "攻击",
			                    索引: 0,
			                },
			                {
			                    名称: "法力汲取",
			                    等级: 1,
			                    描述: "受击时有几率从攻击者身上汲取法力，为主人恢复能量。",
			                    时机: "被攻击",
			                    索引: 1,
			                },
			            ],
			            ...配置,
			        });
			
			        this.技能效果 = [
			            (宠物, 目标怪物列表) => {
			                const 技能 = 宠物.自定义数据.get("技能")[0];
			                if (prng() < 0.3) {
			                    const 伤害 = 2 + 技能.等级;
			                    const 目标 = 目标怪物列表[0];
			                    if (目标 && 目标.当前生命值 > 0) {
			                        目标.受伤(伤害, 宠物);
			                        添加日志(
			                            `${宠物.名称}发射了奥术飞弹！`,
			                            "成功"
			                        );
			                    }
			                }
			            },
			            (宠物, 来源) => {
			                const 技能 = 宠物.自定义数据.get("技能")[1];
			                if (prng() < 0.4 && 来源 instanceof 怪物) {
			                    const 恢复量 = 5 + 技能.等级 * 2;
			                    const 能量条 =
			                        document.querySelector(".power-bar");
			                    const 当前能量 =
			                        parseFloat(能量条.style.width) || 0;
			                    能量条.style.width = `${Math.min(
			                        100,
			                        当前能量 + 恢复量/自定义全局设置.初始能量值*100
			                    )}%`;
			                    添加日志(`${宠物.名称}汲取了能量！`, "成功");
			                }
			            },
			        ];
			    }
			
			    升级() {
			        if (super.升级()) {
			            const 技能列表 = this.自定义数据.get("技能");
			            const 随机技能索引 = Math.floor(
			                prng() * 技能列表.length
			            );
			            技能列表[随机技能索引].等级 += 1;
			            显示通知(
			                `${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`,
			                "成功"
			            );
			        }
			    }
			}
			class 罐子 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "工具",
			            名称: "神秘的罐子",
			            图标: 图标映射.罐子,
			            品质: 2,
			            颜色索引: 3,
			            最大堆叠数量: 1,
			            能否拾起: true,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述:
			                "一个看起来很脆弱的罐子，里面似乎装着什么东西。",
			            数据: {
			                内容物类型: null,
			                内容物类名: null,
			                内容物配置: {},
			                随机层数: 999,
			                已破碎: false,
			                
			            },
			            
			        });
			        if (
			            !this.自定义数据.get("已破碎") &&
			            !this.自定义数据.get("内容物类名") &&
			            this.自定义数据.get("内容物类型") !== '随机'
			        ) {
			            this.决定罐子内容(当前层数 ?? 0);
			        }
			    }
			
			    决定罐子内容(层数) {
			        const 实际层数 = (层数 === null || 层数 === undefined) ? (this.自定义数据.get('随机层数') ?? 999) : 层数;
			        if (prng() < 0.65) {
			            this.自定义数据.set("内容物类型", "怪物");
			            const 怪物池选择 = 怪物池.普通房间.filter(
			                (m) =>
			                    m.最小层 <= 实际层数 && m.类.name !== "大魔法师"
			            );
			            if (怪物池选择.length > 0) {
			                const 怪物配置 = 加权随机选择(
			                    怪物池选择.map((cfg) => ({ 值: cfg, 权重: 1 }))
			                );
			                this.自定义数据.set("内容物类名", 怪物配置.类.name);
			                this.自定义数据.set("内容物配置", {
			                    强化: prng() < 0.2 + 实际层数 * 0.02,
			                });
			            } else {
			                this.转为物品内容("金币", {
			                    数量: Math.floor(prng() * 10) + 5,
			                });
			            }
			        } else {
			            this.自定义数据.set("内容物类型", "物品");
			            const 物品池选择 = Object.values(物品池)
			                .flat()
			                .filter(
			                    (i) =>
			                        i.最小层 <= 实际层数 &&
			                        i.类.name !== "罐子" &&
			                        i.类.name !== "神秘商人" &&
			                        i.类.name !== "探险家" &&
			                        i.类.name !== "物品祭坛" &&
			                        i.类.name !== "耐久祭坛" &&
			                        i.类.name !== "背包扩容祭坛" &&
			                        i.类.name !== "重铸台" &&
			                        i.类.name !== "折跃门" &&
			                        i.类.name !== "寻宝戒指" &&
			                        i.类.name !== "配方卷轴" &&
			                        i.类.name !== "钥匙" &&
			                        i.类.name !== "调试工具"
			                );
			            if (物品池选择.length > 0) {
			                const 物品配置 =
			                    物品池选择[
			                        Math.floor(
			                            prng() * 物品池选择.length
			                        )
			                    ];
			                this.自定义数据.set("内容物类名", 物品配置.类.name);
			                this.自定义数据.set("内容物配置", {
			                    强化: prng() < 0.1 + 实际层数 * 0.02,
			                });
			            } else {
			                this.转为物品内容("金币", {
			                    数量: Math.floor(prng() * 10) + 5,
			                });
			            }
			        }
			    }
			
			    转为物品内容(类名, 配置) {
			        this.自定义数据.set("内容物类型", "物品");
			        this.自定义数据.set("内容物类名", 类名);
			        this.自定义数据.set("内容物配置", 配置);
			    }
			
			    当被收集(进入者) {
			        
			        if (this.自定义数据.get("已破碎")) return false;
			        this.破碎并释放内容();
			        return false;
			    }
			
			    破碎并释放内容(触发怪物 = null) {
			        if (this.自定义数据.get("已破碎")) return;
			        this.自定义数据.set("已破碎", true);
			
			        const 原罐子X = this.x;
			        const 原罐子Y = this.y;
			
			        if (
			            原罐子X !== null &&
			            原罐子Y !== null &&
			            地牢[原罐子Y]?.[原罐子X]?.关联物品 === this
			        ) {
			            地牢[原罐子Y][原罐子X].关联物品 = null;
			            if(地牢[原罐子Y][原罐子X].类型===单元格类型.物品) 地牢[原罐子Y][原罐子X].类型 = null;
			            地牢[原罐子Y][原罐子X].颜色索引 = 颜色表.length;
			        }
			        if (玩家背包.has(this.唯一标识)) {
			            玩家背包.delete(this.唯一标识);
			            更新背包显示();
			        }
			
			        显示通知("罐子破碎了！", "警告");
			        计划显示格子特效([{ x: 原罐子X, y: 原罐子Y }], "A52A2A");
			
			        let 内容物类型 = this.自定义数据.get("内容物类型");
			        let 内容物类名 = this.自定义数据.get("内容物类名");
			        
			        if (内容物类型 === '随机' || !内容物类型) {
			            this.决定罐子内容(this.自定义数据.get('随机层数'));
			            内容物类型 = this.自定义数据.get("内容物类型");
			            内容物类名 = this.自定义数据.get("内容物类名");
			        }
			
			        const 内容物配置 = this.自定义数据.get("内容物配置") || {};
			
			        if (!内容物类名) {
			            添加日志("罐子是空的...", "信息");
			            绘制();
			            return;
			        }
			
			        const 构造器 = window[内容物类名];
			        if (!构造器) {
			            添加日志(
			                `罐子里的东西不见了 (未知类型: ${内容物类名})`,
			                "错误"
			            );
			            绘制();
			            return;
			        }
			
			        let 释放物实例;
			        try {
			            释放物实例 = new 构造器({
			                ...内容物配置,
			                x: null,
			                y: null,
			            });
			        } catch (e) {
			            添加日志(
			                `无法创建罐子内容物 ${内容物类名}: ${e.message}`,
			                "错误"
			            );
			            绘制();
			            return;
			        }
			
			        let 放置X = 原罐子X;
			        let 放置Y = 原罐子Y;
			        let 放置成功 = false;
			
			        const 怪物正在此格 =
			            触发怪物 &&
			            触发怪物.x === 放置X &&
			            触发怪物.y === 放置Y;
			
			        if (!怪物正在此格 && 位置是否可用(放置X, 放置Y, false)) {
			            if (内容物类型 === "怪物") {
			                放置成功 = 放置怪物到单元格(
			                    释放物实例,
			                    放置X,
			                    放置Y
			                );
			            } else {
			                放置成功 = 放置物品到单元格(
			                    释放物实例,
			                    放置X,
			                    放置Y
			                );
			            }
			        }
			
			        if (!放置成功) {
			            const 方向 = [
			                [0, -1],
			                [0, 1],
			                [-1, 0],
			                [1, 0],
			                [-1, -1],
			                [1, -1],
			                [-1, 1],
			                [1, 1],
			            ];
			            方向.sort(() => prng() - 0.5);
			            for (const [dx, dy] of 方向) {
			                const 新X = 原罐子X + dx;
			                const 新Y = 原罐子Y + dy;
			
			                if (
			                    新X >= 0 &&
			                    新X < 地牢大小 &&
			                    新Y >= 0 &&
			                    新Y < 地牢大小 &&
			                    位置是否可用(新X, 新Y, false)
			                ) {
			                    if (内容物类型 === "怪物") {
			                        放置成功 = 放置怪物到单元格(
			                            释放物实例,
			                            新X,
			                            新Y
			                        );
			                    } else {
			                        放置成功 = 放置物品到单元格(
			                            释放物实例,
			                            新X,
			                            新Y
			                        );
			                    }
			                    if (放置成功) {
			                        放置X = 新X;
			                        放置Y = 新Y;
			                        break;
			                    }
			                }
			            }
			        }
			
			        if (放置成功) {
			            添加日志(
			                `从罐子中出现了: ${
			                    释放物实例.获取名称
			                        ? 释放物实例.获取名称()
			                        : 释放物实例.类型 || 内容物类名
			                }!`,
			                "成功"
			            );
			            if (内容物类型 === "怪物") {
			                释放物实例.状态 = 怪物状态.活跃;
			                释放物实例.绘制血条();
			            }
			        } else {
			            添加日志("罐子里的东西无处安放，消失了...", "信息");
			        }
			        绘制();
			    }
			
			    获取提示() {
			        if (this.自定义数据.get("已破碎")) {
			            return "破碎的罐子";
			        }
			        let 提示 = `${this.名称}\n品质：${"★".repeat(this.品质)}\n${
			            this.效果描述
			        }`;
			        return 提示;
			    }
			}
			class 空罐子 extends 罐子 {
			    constructor(配置 = {}) {
			        super({
			            名称: "空罐子",
			            数据: {
			                已破碎: false,
			                内容物类型: null,
			                内容物类名: null,
			            },
			            ...配置,
			        });
			    }
			    决定罐子内容() {}
			}
			class 吸能种子 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "消耗品",
			            名称: "吸能种子",
			            图标: 图标映射.种子,
			            品质: 2,
			            颜色索引: 1,
			            堆叠数量: 配置.数量 || 1,
			            最大堆叠数量: 16,
			            效果描述:
			                "消耗至多50点能量，将其转化为能量草存入背包。",
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (this.堆叠数量 <= 0) return false;
			
			        const 能量条 = document.querySelector(".power-bar");
			        const 当前能量百分比 = parseFloat(能量条.style.width) || 0;
			        const 当前能量值 = 当前能量百分比;
			
			        if (当前能量值 <= 0) {
			            显示通知("没有能量可以吸取！", "错误");
			            return false;
			        }
			
			        const 能量草实例 = new 能量草({});
			        if (
			            [...玩家背包.values()].reduce(
			                (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
			                0
			            ) >= 最大背包容量 &&
			            ![...玩家背包.values()].find((i) =>
			                i.可堆叠于(能量草实例)
			            )
			        ) {
			            显示通知("背包已满，无法生成能量草！", "错误");
			            return false;
			        }
			
			        const 吸收量 = Math.min(50, 当前能量值);
			        if (!扣除能量(吸收量)) {
			            显示通知("未知错误，无法吸取能量。", "错误");
			            return false;
			        }
			
			        if (尝试收集物品(能量草实例, true)) {
			            this.堆叠数量--;
			            显示通知(
			                `成功吸取 ${吸收量.toFixed(
			                    0
			                )} 点能量，获得了能量草！`,
			                "成功"
			            );
			            return true;
			        } else {
			            能量条.style.width = `${当前能量百分比}%`;
			            显示通知("背包空间不足，无法获得能量草！", "错误");
			            return false;
			        }
			    }
			}
			class 能量草 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "消耗品",
			            名称: "能量草",
			            图标: 图标映射.能量草,
			            品质: 2,
			            颜色索引: 1,
			            堆叠数量: 配置.数量 || 1,
			            最大堆叠数量: 16,
			            效果描述: "使用后恢复50点能量。",
			            ...配置,
			        });
			    }
			
			    使用() {
			        if (this.堆叠数量 <= 0) return false;
			
			        const 能量条 = document.querySelector(".power-bar");
			        const 当前能量 = parseFloat(能量条.style.width) || 0;
			        能量条.style.width = `${Math.min(100, 当前能量 + 50/自定义全局设置.初始能量值*100)}%`;
			
			        this.堆叠数量--;
			        if (this.堆叠数量 <= 0) {
			            处理销毁物品(this.唯一标识, true);
			        }
			
			        显示通知("你感到了能量的充盈！", "成功");
			        更新背包显示();
			        更新装备显示();
			        return true;
			    }
			}
			class 火焰物品 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形", // 特殊类型，非普通物品
			            名称: "火焰",
			            图标: 图标映射.火焰,
			            品质: 1, // 品质意义不大
			            颜色索引: 效果名称编号映射.火焰, // 使用火焰效果的颜色索引
			            最大堆叠数量: 1,
			            能否拾起: true, // 必须为true 才能触发 当被收集 函数
			            阻碍怪物: false, // 关键：不阻碍怪物
			            是否正常物品: false, // 不参与常规掉落/交易
			            是否为隐藏物品: false, // 在地图上可见
			            效果描述: "灼热的火焰，触碰会被点燃。",
			            数据: {
			                倒计时: 配置.倒计时 ?? 10, // 默认存在10回合
			                爆炸时间: 配置.倒计时 ?? 10, // 复用计时器接口
			                火焰强度: 配置.火焰强度 ?? 3, // 每回合伤害
			                火焰持续: 配置.火焰持续 ?? 3, // 施加给玩家的燃烧效果持续回合数
			                光照范围: 配置.光照范围 ?? 2, // 照亮范围
			                ...配置.数据, // 允许覆盖
			            },
			            ...配置, // 允许覆盖父类属性
			        });
			        // 火焰物品创建时自动加入计时器
			        if (!所有计时器.some((t) => t.唯一标识 === this.唯一标识)) {
			            
			            if (游戏状态 === '地图编辑器') {
			            if(配置?.玩家放置) this.玩家放置=配置?.玩家放置
			            return;
			                
			            }
			            所有计时器.push(this);
			        }
			        if (当前天气效果?.includes("严寒") && !配置.倒计时) {
			            this.自定义数据.set("爆炸时间", 5);
			            this.自定义数据.set("倒计时", 5);
			        }
			    }
			
			    // 火焰不能被主动使用
			    使用() {
			        return false;
			    }
			
			    // 玩家接触火焰时触发 (不能被收集，但会触发效果)
			    当被收集(进入者) {
			        if (进入者 !== "玩家") return;
			        const 效果 = new 状态效果(
			            "火焰", // 效果类型
			            this.获取火焰颜色(), // 颜色
			            图标映射.火焰, // 图标
			            this.自定义数据.get("火焰持续"), // 效果持续回合数
			            null, // 剩余回合（从持续时间开始）
			            null, // 来源（火焰本身，或null）
			            null, // 关联怪物 (null代表玩家)
			            this.自定义数据.get("火焰强度") // 效果强度（每回合伤害）
			        );
			        添加日志("你接触了火焰，被点燃了！", "错误");
			        return false; // 返回 false 表示无法被收集（移除）
			    }
			
			    // 更新倒计时 (每回合调用)
			    更新倒计时() {
			        const 剩余回合 = this.自定义数据.get("倒计时");
			        if (剩余回合 <= 0) {
			            this.熄灭(); // 时间到，火焰熄灭
			        } else {
			            this.自定义数据.set("倒计时", 剩余回合 - 1);
			        }
			    }
			
			    // 火焰熄灭 (代替原来的触发爆炸)
			    熄灭() {
			        // 从地牢格子中移除
			        if (
			            this.x !== null &&
			            this.y !== null &&
			            地牢[this.y]?.[this.x]?.关联物品 === this
			        ) {
			            地牢[this.y][this.x].关联物品 = null;
			
			            if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品)
			                地牢[this.y][this.x].类型 = null;
			        }
			        // 从计时器列表中移除
			        所有计时器 = 所有计时器.filter((item) => item !== this);
			        绘制(); // 更新画面，移除火焰图标
			    }
			
			    获取提示() {
			        return [
			            `${this.获取名称()}`,
			            `类型：${this.类型}`,
			            `剩余时间：${this.自定义数据.get("倒计时")} 回合`,
			            `${this.效果描述}`,
			        ].join("\n");
			    }
			
			    获取火焰颜色() {
			        return 效果颜色编号映射[this.颜色索引] || "#CC5500";
			    }
			
			    get 颜色表() {
			        return 效果颜色编号映射;
			    }
			}
			class 寻宝戒指 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "戒指",
			            名称: "寻宝戒指",
			            图标: 图标映射.寻宝戒指,
			            品质: 3,
			            颜色索引: 2,
			            最大堆叠数量: 1,
			            效果描述: "装备后，会为你指出隐藏大门的位置",
			            数据: {
			                生效层数: 配置.生效层数 || 当前层数, // 指定生效的层数
			                已生成折跃门: false,
			                ...配置.数据,
			            },
			        });
			    }
			    生成显示元素(用途 = "背包") {
			        const 元素 = super.生成显示元素(用途);
			        if (用途 === "装备") {
			            const 标签 = document.createElement("div");
			            标签.className = "耐久标签";
			            标签.textContent = `当前层:${当前层数}`;
			            元素.appendChild(标签);
			        }
			        return 元素;
			    }
			    使用() {
			        显示通知("装备不能被使用！", "错误");
			        return false;
			    }
			    装备() {
			        if (!super.装备()) return false;
			        // 触发检查和生成折跃门逻辑
			        if (
			            this.自定义数据.get("生效层数") === 当前层数 &&
			            !this.自定义数据.get("已生成折跃门")
			        ) {
			            this.尝试生成折跃门();
			        }
			
			        更新装备显示();
			        return true;
			    }
			
			    取消装备() {
			        if (!this.已装备) return false;
			        // 移除折跃门指示器（如果存在）
			        const 指示器 = document.querySelector(".折跃门指示器");
			        if (指示器) {
			            指示器.remove();
			        }
			        玩家装备.delete(this.装备槽位);
			        this.已装备 = false;
			        this.装备槽位 = null;
			        更新装备显示();
			        return true;
			    }
			
			    尝试生成折跃门() {
			        const 可用房间 = 房间列表.filter(
			            (房间) => 房间.类型?.slice(0, 2) === "房间"
			        );
			        if (可用房间.length === 0) return; // 没有可用房间
			        const 随机房间 =
			            可用房间[Math.floor(prng() * 房间列表.length)];
			        const 放置折跃门 = new 折跃门({
			            目标房间: 房间列表.find(
			                (item) => item.类型?.slice(0, 2) === "隐藏"
			            ),
			        }); // 假设目标房间是起始房间
			        if (
			            放置物品到房间(
			                放置折跃门,
			                随机房间,
			                单元格类型.物品,
			                false,
			                true
			            )
			        ) {
			            this.自定义数据.set("已生成折跃门", true);
			            this.自定义数据.set("折跃门位置", {
			                x: 放置折跃门.x,
			                y: 放置折跃门.y,
			            });
			            更新物体指示器();
			        }
			    }
			
			    获取提示() {
			        return [
			            `${this.获取名称()}`,
			            `类型：${this.类型}`,
			            `生效层数：${this.自定义数据.get("生效层数")}`,
			            `效果描述：${this.效果描述}`,
			        ].join("\n");
			    }
			}
			class 传送门 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "传送门",
			            图标: 图标映射.传送门,
			            品质: 5,
			            颜色索引: 1, 
			            能否拾起: true,
			            是否正常物品: false,
			            阻碍怪物: false,
			            效果描述: "一个神秘的传送门，触碰它会被传送到未知的地方。",
			            数据: {
			                是否随机: true,
			                目标X: null,
			                目标Y: null,
			                ...配置.数据,
			            },
			            ...配置,
			        });
			    }
			
			    当被收集(进入者) {
			        if (进入者 !== "玩家") return false;
			        
			        const 是否随机 = this.自定义数据.get('是否随机');
			        let 目标X = this.自定义数据.get('目标X');
			        let 目标Y = this.自定义数据.get('目标Y');
			        
			
			        if (是否随机) {
			            const 可用位置 = [];
			            for (let y = 0; y < 地牢大小; y++) {
			                for (let x = 0; x < 地牢大小; x++) {
			                    if (位置是否可用(x, y, false)) {
			                        可用位置.push({ x, y });
			                    }
			                }
			            }
			            if (可用位置.length > 0) {
			                const 随机位置 = 可用位置[Math.floor(prng() * 可用位置.length)];
			                目标X = 随机位置.x;
			                目标Y = 随机位置.y;
			            } else {
			                显示通知("没有可用的传送目标位置！", "错误");
			                return false;
			            }
			        } else if (目标X === null || 目标Y === null) {
			            显示通知("传送门目标未设置！", "错误");
			            return false;
			        }
			
			        if (位置是否可用(目标X, 目标Y, false)) {
			            显示通知(`你穿过了传送门...`, "成功");
			            const 当前玩家房间ID = 房间地图[玩家.y][玩家.x];
			        if (当前玩家房间ID !== -1) {
			            const 当前玩家所在房间 = 房间列表.find(t=>t.id==当前玩家房间ID);
			            if (
			                当前玩家所在房间 &&
			                当前玩家所在房间.类型 === "挑战房间" &&
			                当前玩家所在房间.挑战状态 &&
			                当前玩家所在房间.挑战状态.进行中
			            ) {
			                处理挑战失败(当前玩家所在房间);
			            }
			        }
			        if (生存挑战激活) {
			            显示通知("强大的结界阻止了空间传送！", "错误");
			            return false;
			        }
			        setTimeout(() => {
			        const 旧X = 玩家.x;
			            const 旧Y = 玩家.y;
			            玩家.x = parseInt(目标X);
			            玩家.y = parseInt(目标Y);
			            处理玩家着陆效果(旧X, 旧Y, 玩家.x, 玩家.y);
			            更新视口();
			            
			    }, 400);
			            
			            
			        } else {
			            显示通知("传送目标位置被阻挡！", "错误");
			        }
			
			        return false; 
			    }
			
			    获取提示() {
			        const 是否随机 = this.自定义数据.get('是否随机');
			        let dest = 是否随机 ? "随机位置" : `(${this.自定义数据.get('目标X') ?? '未设置'}, ${this.自定义数据.get('目标Y') ?? '未设置'})`;
			        return `${this.名称}\n品质：${"★".repeat(this.品质)}\n传送目标: ${dest}\n${this.效果描述}`;
			    }
			
			    使用() {
			        return false;
			    }
			}
			class 折跃门 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            图标: 图标映射.折跃门,
			            类型: "地形",
			            名称: "折跃门",
			            品质: 1,
			            颜色索引: 2,
			            能否拾起: false,
			            是否正常物品: false,
			            是否为隐藏物品:
			                配置.是否为隐藏物品 !== undefined
			                    ? 配置.是否为隐藏物品
			                    : true, // 默认为隐藏
			            数据: {
			                目标房间: 配置.目标房间 || null, // 目标房间的配置
			            },
			        });
			    }
			
			    使用() {
			        const 目标房间 = this.自定义数据.get("目标房间");
			        if (!confirm("你发现了一个折跃门，是否传送？")) return false;
			        const 当前玩家房间ID = 房间地图[玩家.y][玩家.x];
			        if (当前玩家房间ID !== -1) {
			            const 当前玩家所在房间 = 房间列表.find(t=>t.id==当前玩家房间ID);
			            if (
			                当前玩家所在房间 &&
			                当前玩家所在房间.类型 === "挑战房间" &&
			                当前玩家所在房间.挑战状态 &&
			                当前玩家所在房间.挑战状态.进行中
			            ) {
			                处理挑战失败(当前玩家所在房间);
			            }
			        }
			        if (生存挑战激活) {
			            显示通知("强大的结界阻止了空间传送！", "错误");
			            return false;
			        }
			        if (目标房间) {
			            let 目标X, 目标Y;
			            let 尝试次数 = 0;
			            do {
			                目标X =
			                    目标房间.x +
			                    Math.floor(prng() * 目标房间.w);
			                目标Y =
			                    目标房间.y +
			                    Math.floor(prng() * 目标房间.h);
			                尝试次数++;
			            } while (
			                地牢[目标Y]?.[目标X]?.背景类型 ===
			                    单元格类型.墙壁 &&
			                尝试次数 < 50
			            );
			
			            if (
			                地牢[目标Y]?.[目标X]?.背景类型 === 单元格类型.墙壁
			            ) {
			                目标X = 目标房间.x + Math.floor(目标房间.w / 2);
			                目标Y = 目标房间.y + Math.floor(目标房间.h / 2);
			            }
			
			            玩家.x = 目标X;
			            玩家.y = 目标Y;
			            const 目标房间ID = 房间地图[玩家.y][玩家.x];
			            if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
			                moveQueue = [];
			                isAutoMoving = false;
			                已访问房间.add(目标房间ID);
			            }
			
			            更新视口();
			            绘制();
			            显示通知("你被传送到了一个神秘的房间！", "成功");
			            return true;
			        }
			        return false;
			    }
			}
			//下面这个物品！！！闪亮登场！
			class 炸弹 extends 物品 {
			    constructor(配置) {
			        super({
			            类型: "炸弹",
			            名称: "炸弹",
			            图标: 图标映射.炸弹,
			            品质: 3,
			            强化: 配置.强化 || false,
			            颜色索引:
			                配置.颜色索引 === undefined ? 2 : 配置.颜色索引,
			            堆叠数量: 配置.数量 || 1,
			            能否拾起:
			                配置.能否拾起 === undefined ? true : 配置.能否拾起,
			            数据: {
			                效果描述: "无法对炸弹怪物造成伤害",
			                倒计时: 配置.倒计时 || 2,
			                爆炸时间: 配置.爆炸时间 || 2,
			                爆炸范围: 配置.爆炸范围 || 3,
			                伤害: 配置.伤害 || 30,
			                来源: 配置.来源 || '玩家',
			            },
			        });
			    }
			    获取提示() {
			        return [
			            super.获取提示(),
			            `效果描述：${this.自定义数据.get("效果描述")}`,
			        ].join("\n");
			    }
			    使用(玩家使用 = true, x0 = 0, y0 = 0) {
			        if (当前天气效果.includes("严寒")) {
			            if (!玩家使用) {
			                this.能否拾起 = true;
			            }
			            显示通知("温度过低，炸弹打不着火了！", "警告");
			            return 0;
			        }
			        super.使用();
			        if (玩家使用) {
			            this.自定义数据.set(
			                "倒计时",
			                this.自定义数据.get("爆炸时间")
			            );
			            const { x, y, 新物品 } = 玩家放置物品(this, false);
			            if (x === null || y === null || 新物品 === null)
			                return false;
			            新物品.x = x;
			            新物品.y = y;
			            所有计时器.push(新物品);
			            return true;
			        }
			        this.x = x0;
			        this.y = y0;
			        所有计时器.push(this);
			        return true;
			    }
			    更新倒计时() {
			        const 剩余回合 = this.自定义数据.get("倒计时");
			
			        if (剩余回合 <= 0) {
			            this.触发爆炸();
			            所有计时器 = 所有计时器.filter((item) => item !== this);
			        }
			        this.自定义数据.set("倒计时", 剩余回合 - 1);
			    }
			
			    触发爆炸() {
			        if (this.能否拾起) return;
			        const 爆炸范围 = this.计算爆炸范围();
			        this.显示爆炸效果(爆炸范围);
			        this.处理爆炸效果(爆炸范围);
			    }
			
			    计算爆炸范围() {
			        const 可到达格子 = [];
			        const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
			        const 已访问 = new Set([`${this.x},${this.y}`]);
			
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			            可到达格子.push(当前);
			
			            if (当前.距离 >= this.自定义数据.get("爆炸范围"))
			                continue;
			
			            const 方向 = [
			                { dx: 1, dy: 0 },
			                { dx: -1, dy: 0 },
			                { dx: 0, dy: 1 },
			                { dx: 0, dy: -1 },
			            ];
			
			            方向.forEach(({ dx, dy }) => {
			                const 新X = 当前.x + dx;
			                const 新Y = 当前.y + dy;
			                const 位置键 = `${新X},${新Y}`;
			
			                if (
			                    新X >= 0 &&
			                    新X < 地牢大小 &&
			                    新Y >= 0 &&
			                    新Y < 地牢大小 &&
			                    !已访问.has(位置键)
			                ) {
			                    if (
			                        this.检查路径可行性(
			                            当前.x,
			                            当前.y,
			                            新X,
			                            新Y
			                        )
			                    ) {
			                        已访问.add(位置键);
			                        队列.push({
			                            x: 新X,
			                            y: 新Y,
			                            距离: 当前.距离 + 1,
			                        });
			                    }
			                }
			            });
			        }
			        return 可到达格子;
			    }
			
			    检查路径可行性(fromX, fromY, toX, toY) {
			        const 移动方向 = 获取移动方向(fromX, fromY, toX, toY);
			
			        const 当前单元格 = 地牢[fromY][fromX];
			        const 目标单元格 = 地牢[toY][toX];
			
			        if (
			            当前单元格.墙壁[移动方向.当前墙] ||
			            目标单元格.墙壁[移动方向.反方向墙]
			        ) {
			            return false;
			        }
			
			        return [
			            单元格类型.房间,
			            单元格类型.走廊,
			            单元格类型.门,
			            单元格类型.上锁的门,
			        ].includes(目标单元格.背景类型);
			    }
			
			    显示爆炸效果(爆炸范围) {
			        爆炸范围.sort((a, b) => a.距离 - b.距离);
			    待显示爆炸范围.push({
			        爆炸范围: 爆炸范围,
			        范围: this.自定义数据.get("爆炸范围"),
			    });
			    }
			
			    处理爆炸效果(爆炸范围) {
			        const 是否强化炸弹 = this.强化;
			
			        爆炸范围.forEach(({ x, y }) => {
			            const 当前单元格 = 地牢[y]?.[x];
			            if (!当前单元格) return;
			            if (当前单元格.关联物品 instanceof 符文圈) return;
			            if (当前单元格.关联物品 instanceof 挑战石碑) return;
			            if (当前单元格.关联物品 instanceof 魔法水晶) return;
			            if (当前单元格.关联物品 instanceof 传送门) return;
			            if (当前单元格.关联物品 instanceof 折跃门) return;
			            if (当前单元格.关联物品 instanceof 临时墙壁计时器) return;
			            if (当前单元格.关联物品 instanceof 告示牌) return;
			            if (当前单元格.关联物品 instanceof 存档点) return;
			            if (当前单元格.关联物品 instanceof 传送带) return;
			            if (当前单元格.关联物品 instanceof 开关脉冲器) return;
			            if (当前单元格.关联物品 instanceof 奖杯物品) return;
			            if (当前单元格.关联物品?.类型 === '开关砖') return;
			            
			            if (当前单元格.关联物品 instanceof 红蓝开关) {
			                当前单元格.关联物品.使用()
			                return;
			            }
			            if (当前单元格.关联物品 instanceof 绿紫开关) {
			                当前单元格.关联物品.使用()
			                return;
			            }
			
			            if (
			                当前单元格.关联物品 instanceof 祭坛类 &&
			                当前单元格.关联物品.自定义数据.get("激活条件") ===
			                    "爆炸冲击" &&
			                !当前单元格.关联物品.自定义数据.get("已激活")
			            ) {
			                当前单元格.关联物品.激活();
			            }
			
			            if (!是否强化炸弹 && 玩家.x === x && 玩家.y === y) {
			                伤害玩家(this.自定义数据?.get("伤害"), this.名称);
			                const 火焰强度玩家 = 5;
			                const 火焰持续玩家 = 4;
			                new 状态效果(
			                    "火焰",
			                    效果颜色编号映射[效果名称编号映射.火焰],
			                    图标映射.火焰,
			                    火焰持续玩家,
			                    null,
			                    null,
			                    null,
			                    火焰强度玩家
			                );
			                Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).forEach(装备 => {
			                    if (装备.材质 === 材料.玻璃 && 装备.自定义数据?.has("耐久") && !装备.自定义数据.get("不可破坏")) {
			                        const 原耐久 = 装备.自定义数据.get("耐久");
			                        const 新耐久 = Math.floor(原耐久 / 2);
			                        装备.自定义数据.set("耐久", 新耐久);
			                         显示通知(`${装备.获取名称()} 因爆炸而破损！`, "警告");
			                         if (新耐久 === 0) {
			                            处理销毁物品(装备.唯一标识, true);
			                         }
			                    }
			                });
			                更新装备显示();
			            }
			            if (!是否强化炸弹) {
    当前出战宠物列表.forEach(pet => {
        if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === x && pet.y === y && pet.层数==当前层数 ) {
            pet.受伤(this.自定义数据?.get("伤害"));
            添加日志(`${pet.名称} 被爆炸波及了！`, "警告");
        }
    });
}
			
			            if (当前单元格.关联怪物) {
			                if (
			                    当前单元格.关联怪物.类型 !== "炸弹怪物" &&
			                    当前单元格.关联怪物.类型 !== "大魔法师" &&
			                    当前单元格.关联怪物.类型 !== "米诺陶" &&
			                    !(当前单元格.关联怪物.类型 === "王座守护者" && 当前单元格.关联怪物.当前阶段 === 3)
			                ) {
			                    当前单元格.关联怪物.受伤(this.自定义数据?.get("伤害"), "炸弹");
			                    if (当前单元格.关联怪物) {
			                    const 火焰强度怪物 = 5;
			                    const 火焰持续怪物 = 4;
			                    new 状态效果(
			                        "火焰",
			                        效果颜色编号映射[效果名称编号映射.火焰],
			                        "火",
			                        火焰持续怪物,
			                        null,
			                        null,
			                        当前单元格.关联怪物,
			                        火焰强度怪物
			                    );
			                    添加日志(
			                        `${当前单元格.关联怪物?.类型} 被爆炸点燃了！`,
			                        "警告"
			                    );
			                    }
			                }
			            }
			
			            if (当前单元格.关联物品) {
			                if (
			                    当前单元格.关联物品 instanceof 罐子 &&
			                    !当前单元格.关联物品.自定义数据.get("已破碎")
			                ) {
			                    当前单元格.关联物品.破碎并释放内容();
			                } else if (
			                    !是否强化炸弹 &&
			                    !(当前单元格.关联物品 instanceof 罐子) &&
			                    !(当前单元格.关联物品 instanceof 祭坛类) &&
			                    !(当前单元格.关联物品.类型 === "楼梯")
			
			                ) {
			                    const 被毁物品 = 当前单元格.关联物品;
			                    const 计时器索引 = 所有计时器.findIndex(
			                        (t) => t.唯一标识 === 被毁物品.唯一标识
			                    );
			                    if (计时器索引 !== -1) {
			                        所有计时器.splice(计时器索引, 1);
			                    }
			                    if (当前单元格.关联物品 instanceof 炸弹 && 当前单元格.关联物品.唯一标识.toString()!==this.唯一标识.toString()) 当前单元格.关联物品.触发爆炸()
			                    添加日志(`${被毁物品.名称} 被炸毁了！`, "警告");
			                    当前单元格.关联物品 = null;
			                    当前单元格.类型 = null;
			                } else if (x === this.x && y === this.y) {
			                    const 被毁物品 = 当前单元格.关联物品;
			                    const 计时器索引 = 所有计时器.findIndex(
			                        (t) => t.唯一标识 === 被毁物品.唯一标识
			                    );
			                    if (计时器索引 !== -1) {
			                        所有计时器.splice(计时器索引, 1);
			                    }
			                    添加日志(`${被毁物品.名称} 被炸毁了！`, "警告");
			                    当前单元格.关联物品 = null;
			                    当前单元格.类型 = null;
			                }
			            }
			
			            if (当前单元格.背景类型 === 单元格类型.上锁的门) {
			                当前单元格.背景类型 = 单元格类型.门;
			            }
			        });
			
			
			
			        const 爆炸半径 = this.自定义数据.get("爆炸范围") ?? 3;
			        const 火焰数量 =
			            Math.floor(prng() * (爆炸半径 * 2)) + 1;
			        const 可放火焰格子 = 爆炸范围.filter(
			            ({ x, y, 距离 }) =>
			                距离 > 0 &&
			                地牢[y]?.[x] &&
			                !地牢[y][x].关联物品 &&
			                !地牢[y][x].关联怪物 &&
			                [
			                    单元格类型.房间,
			                    单元格类型.走廊,
			                    单元格类型.门,
			                ].includes(地牢[y][x].背景类型)
			        );
			
			        可放火焰格子.sort(() => prng() - 0.5);
			        const 实际放置火焰数 = Math.min(
			            火焰数量,
			            可放火焰格子.length
			        );
			
			        for (let i = 0; i < 实际放置火焰数; i++) {
			            const { x, y } = 可放火焰格子[i];
			            const 火焰 = new 火焰物品({ 强化: 是否强化炸弹 });
			            放置物品到单元格(火焰, x, y);
			        }
			        if (实际放置火焰数 > 0) {
			            添加日志(
			                `爆炸产生了 ${实际放置火焰数} 处火焰！`,
			                "信息"
			            );
			        }
			        绘制();
			    }
			}
			class 告示牌 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "告示牌",
			            图标: 图标映射.告示牌,
			            品质: 2,
			            颜色索引: 2,
			            能否拾起: false,
			            是否正常物品: false,
			            阻碍怪物: true,
			            效果描述: "一块可以写字的牌子。",
			            数据: {
			                内容: "这里写着一些文字...",
			                ...配置.数据,
			            },
			            ...配置,
			        });
			    }
			
			    尝试互动() {
			        const 内容 = this.自定义数据.get("内容");
			        const 提示窗口 = document.getElementById("教程提示窗口");
			        const 提示内容元素 = document.getElementById("教程提示内容");
			        const 关闭按钮 = 提示窗口.querySelector(".关闭按钮");
			
			        提示内容元素.innerHTML = 内容.replace(/\n/g, '<br>'); //此处可以XSS注入，那咋了？反正没人玩，连存档和apikey我都明文存了还怂这个？
			        
			        关闭按钮.textContent = "关闭";
			        关闭按钮.onclick = 关闭教程提示;
			        提示窗口.style.display = "block";
			    
			        
			        玩家属性.允许移动++;
			        
			        return true;
			    }
			}
			
			class 临时墙壁计时器 extends 物品 {
			    constructor(配置 = {}) {
			        super({
			            类型: "地形",
			            名称: "不稳定的墙体",
			            图标: "🧱",
			            能否拾起: false,
			            是否正常物品: false,
			            是否为隐藏物品: true,
			            阻碍怪物: true,
			            数据: {
			                倒计时: 25,
			                爆炸时间: 25,
			                原背景类型: 配置.原背景类型 ?? 单元格类型.走廊,
			                
			            },
			            
			        });
			    }
			
			    更新倒计时() {
			        const 剩余回合 = this.自定义数据.get("倒计时") - 1;
			        this.自定义数据.set("倒计时", 剩余回合);
			        if (剩余回合 <= 0) {
			            this.恢复墙壁();
			        }
			    }
			
			    恢复墙壁() {
			        const 单元格 = 地牢[this.y]?.[this.x];
			        if (单元格) {
			            单元格.背景类型 = this.自定义数据.get("原背景类型");
			            单元格.关联物品 = null;
			            单元格.类型 = null;
			            生成墙壁();
			            
			        }
			        所有计时器 = 所有计时器.filter(t => t.唯一标识 !== this.唯一标识);
			    }
			}
			
			// 基类：界面元素
			class 界面元素基类 {
			    constructor() {
			        this.元素标识 = `元素_${Date.now()}_${prng()
			            .toString(36)
			            .substr(2, 9)}`;
			        this.容器元素 = document.createElement("div");
			        this.容器元素.className = "hud-item";
			        this.容器元素.dataset.元素标识 = this.元素标识;
			        document.querySelector(".hud").appendChild(this.容器元素);
			    }
			
			    销毁() {
			        this.容器元素.remove();
			        this.容器元素 = null;
			    }
			
			    更新(参数) {
			        throw new Error("必须实现更新方法");
			    }
			}
			
			// 文本行元素
			class 文本元素 extends 界面元素基类 {
			    constructor(配置) {
			        super();
			        this.图标元素 = null;
			        this.文本元素 = null;
			        this.初始化(配置);
			    }
			
			    初始化({ 图标, 内容 }) {
			        const 行容器 = document.createElement("div");
			        行容器.className = "界面文本行";
			
			        if (图标) {
			            this.图标元素 = document.createElement("span");
			            this.图标元素.className = "hud-icon";
			            this.图标元素.innerHTML = getIconHTML(图标);
			            行容器.appendChild(this.图标元素);
			        }
			
			        this.文本元素 = document.createElement("span");
			        this.文本元素.className = "hud-label";
			        this.文本元素.textContent = 内容;
			        行容器.appendChild(this.文本元素);
			
			        this.容器元素.appendChild(行容器);
			        触发HUD显示();
			    }
			
			    更新({ 内容, 图标 }) {
			        if (this.文本元素.textContent == 内容) return;
			        if (内容) this.文本元素.textContent = 内容;
			        if (图标) this.图标元素.innerHTML = getIconHTML(图标);
			        触发HUD显示();
			    }
			}
			
			// 进度条元素
			class 进度条元素 extends 界面元素基类 {
			    constructor(配置) {
			        super();
			        this.进度条元素 = null;
			        this.标签元素 = null;
			        this.初始化(配置);
			    }
			
			    初始化({ 图标, 颜色, 初始值, 标签 }) {
			        this.容器元素.innerHTML = `
			                                                            <span class="hud-icon">${
			                                                                getIconHTML(图标) ||
			                                                                "⚡"
			                                                            }</span>
			                                                            <div class="hud-bar-container">
			                                                                <div class="hud-bar" style="width: ${
			                                                                    初始值 ||
			                                                                    100
			                                                                }%">
			                                                                    <div class="进度条标签">${
			                                                                        标签 ||
			                                                                        ""
			                                                                    }</div>
			                                                                </div>
			                                                            </div>
			                                                        `;
			
			        this.进度条元素 = this.容器元素.querySelector(".hud-bar");
			        this.标签元素 =
			            this.进度条元素.querySelector(".进度条标签");
			
			        if (颜色) {
			            this.进度条元素.style.background = 颜色;
			        }
			        触发HUD显示();
			    }
			
			    更新({ 数值, 标签, 颜色 }) {
			        if (
			            this.标签元素.textContent == 标签 &&
			            this.进度条元素.style.width == `${数值}%`
			        )
			            return;
			        if (数值 !== undefined) {
			            this.进度条元素.style.width = `${数值}%`;
			
			            // 自动添加低数值警告
			            if (数值 <= 20) {
			                this.进度条元素.classList.add("低数值警告");
			            } else {
			                this.进度条元素.classList.remove("低数值警告");
			            }
			        }
			
			        // 动态调整标签位置
			        if (标签) {
			            this.标签元素.textContent = 标签;
			        }
			
			        if (颜色) {
			            this.进度条元素.style.background = 颜色;
			        }
			        触发HUD显示();
			    }
			}
			
			// 使用示例：
			//const 药水条 = new 进度条元素({
			//图标: '🧪',
			//颜色: 'linear-gradient(to right, #00ff88, #00ccff)',
			//初始值: 80,
			//标签: '强化药水 80%'
			//});
			
			//const 任务提示 = new 文本元素({
			//    图标: '📜',
			//    内容: '主线任务：寻找古代遗物'
			//});
			
			// 更新元素示例
			//药水条.更新({ 数值: 15, 标签: '药水剩余 15%' });
			//任务提示.更新({ 内容: '紧急任务：击败守护者' });
			
			const 怪物追踪提示 = new 文本元素({
			    内容: `追踪怪物：0`,
			});
			const 击杀提示 = new 文本元素({
			    内容: `已击杀怪物：${已击杀怪物数}`,
			});
			
			// 单元格类
			class 单元格 {
			    constructor(x, y) {
			        this.x = x;
			        this.y = y;
			        this.类型 = 单元格类型.墙壁;
			        this.墙壁 = { 上: false, 右: false, 下: false, 左: false };
			        this.钥匙ID = null;
			        this.颜色索引 = 颜色表.length;
			        this.关联物品 = null;
			        this.关联怪物 = null;
			        this.背景类型 = 单元格类型.墙壁;
			        this.isOneWay = false;
			        this.oneWayAllowedDirection = null;
			        this.doorOrientation = null;
			        this.是否强制墙壁 = false;
			        this.阻碍视野 = false;
			    }
			
			绘制() {
			        const 屏幕X = (this.x - 当前相机X) * 单元格大小;
			        const 屏幕Y = (this.y - 当前相机Y) * 单元格大小;
			        const 房间ID = 房间地图[this.y][this.x];
			        
			        const 房间实例 = 房间列表.find(t=>t.id==房间ID);
			        const 游戏时未探索 = 游戏状态 !== '地图编辑器'  && 房间ID !== -1 && !已访问房间.has(房间ID) && !玩家属性.透视;
			        const 编辑器时未探索 = 游戏状态 === '编辑器游玩' && 房间实例 && !已访问房间.has(房间ID);
			        
			        if (地牢生成方式 === 'cave' && !已揭示洞穴格子.has(`${this.x},${this.y}`) && 游戏状态 !== '地图编辑器' && !玩家属性.透视) {
        ctx.fillStyle = "#000000";
        ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
        return;
    }
			
			        if (
			            当前天气效果.includes("深夜") ||
			            房间列表.find(t=>t.id==房间ID)?.类型 === "黑暗房间" ||
			            玩家状态.some(s => s.类型 === '失明')
			        ) {
			            if (!是否在光源范围内(this.x, this.y) && 游戏状态 !== "地图编辑器") {
			                ctx.fillStyle = "#000000";
			                ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
			                return;
			            }
			        }
			        if (命令行模式开启) {
		if (游戏时未探索 || 编辑器时未探索) {
			ctx.fillStyle = "#000";
			ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
			return;
		}
		ctx.fillStyle = '#FFFFFF';
		ctx.font = `${单元格大小}px 'Courier New', monospace`;
		ctx.textAlign = 'center';
		ctx.textBaseline = 'middle';
		if (this.背景类型 === 单元格类型.墙壁) {
			const 墙壁字符 = 获取墙壁字符(this);
			ctx.fillText(墙壁字符, 屏幕X + 单元格大小 / 2, 屏幕Y + 单元格大小 / 2 + 2);
		} else {
			if (this.背景类型 === 单元格类型.门) {
				ctx.fillText('+', 屏幕X + 单元格大小 / 2, 屏幕Y + 单元格大小 / 2);
			} else if (this.背景类型 === 单元格类型.上锁的门) {
				ctx.fillStyle = 颜色表[this.颜色索引] || '#FFFFFF';
				ctx.fillText('#', 屏幕X + 单元格大小 / 2, 屏幕Y + 单元格大小 / 2);
			} else if (this.背景类型 === 单元格类型.走廊) {
				ctx.fillStyle = '#555';
				ctx.fillText('·', 屏幕X + 单元格大小 / 2, 屏幕Y + 单元格大小 / 2);
			} else {
				ctx.fillStyle = '#333';
				ctx.fillText('.', 屏幕X + 单元格大小 / 2, 屏幕Y + 单元格大小 / 2);
			}
			ctx.strokeStyle = '#FFFFFF';
			ctx.lineWidth = 1;
			ctx.beginPath();
			if (this.墙壁.上) { ctx.moveTo(屏幕X, 屏幕Y); ctx.lineTo(屏幕X + 单元格大小, 屏幕Y); }
			if (this.墙壁.右) { ctx.moveTo(屏幕X + 单元格大小, 屏幕Y); ctx.lineTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小); }
			if (this.墙壁.下) { ctx.moveTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小); ctx.lineTo(屏幕X, 屏幕Y + 单元格大小); }
			if (this.墙壁.左) { ctx.moveTo(屏幕X, 屏幕Y + 单元格大小); ctx.lineTo(屏幕X, 屏幕Y); }
			ctx.stroke();
		}
		if (this.关联物品) {
			this.绘制物品(屏幕X, 屏幕Y);
		}
		return;
	}
			        if (
			            (游戏时未探索) &&
			            !(游戏状态 === "图鉴")
			        ) {
			            ctx.fillStyle = "rgba(0, 0, 0)";
			            ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
			        } else {
                        let 背景颜色;
			            switch (this.背景类型) {
			                case 单元格类型.房间: 背景颜色 = "#3a506b"; break;
			                case 单元格类型.走廊: 背景颜色 = "#2b2d42"; break;
			                case 单元格类型.门: 背景颜色 = "#8b4513"; break;
			                case 单元格类型.上锁的门: 背景颜色 = 颜色表[this.颜色索引]; break;
			                case 单元格类型.楼梯下楼:
			                case 单元格类型.楼梯上楼:
			                    ctx.fillStyle = "#3a506b";
			                    ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
			                    this.绘制物品(屏幕X, 屏幕Y);
			                    return;
			                default: 背景颜色 = "#1a1a1a";
			            }
                        ctx.fillStyle = 背景颜色;
                        ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);

                        ctx.strokeStyle = this.背景类型 === 单元格类型.上锁的门 ? "#ffd700" : "#e0e0e0";
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        if (this.墙壁.上) {
                            if (this.背景类型 === 单元格类型.门 || this.背景类型 === 单元格类型.上锁的门) {
                                ctx.moveTo(屏幕X + 单元格大小 / 3, 屏幕Y);
                                ctx.lineTo(屏幕X + (单元格大小 * 2) / 3, 屏幕Y);
                            } else {
                                ctx.moveTo(屏幕X, 屏幕Y);
                                ctx.lineTo(屏幕X + 单元格大小, 屏幕Y);
                            }
                        }
                        if (this.墙壁.右) { ctx.moveTo(屏幕X + 单元格大小, 屏幕Y); ctx.lineTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小); }
                        if (this.墙壁.下) { ctx.moveTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小); ctx.lineTo(屏幕X, 屏幕Y + 单元格大小); }
                        if (this.墙壁.左) { ctx.moveTo(屏幕X, 屏幕Y + 单元格大小); ctx.lineTo(屏幕X, 屏幕Y); }
                        ctx.stroke();

			            if (this.isOneWay && this.oneWayAllowedDirection && [单元格类型.门, 单元格类型.上锁的门].includes(this.背景类型)) {
                            ctx.save();
			                ctx.font = `${单元格大小 * 0.7}px Arial`;
			                ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
			                ctx.textAlign = "center";
			                ctx.textBaseline = "middle";
			                let arrow = "";
			
			                if (this.oneWayAllowedDirection === "N") arrow = "↑";
			                else if (this.oneWayAllowedDirection === "S") arrow = "↓";
			                else if (this.oneWayAllowedDirection === "E") arrow = "→";
			                else if (this.oneWayAllowedDirection === "W") arrow = "←";
			
			                const arrowX = 屏幕X + 单元格大小 / 2;
			                const arrowY = 屏幕Y + 单元格大小 / 2;
			
			                ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
			                ctx.shadowBlur = 3;
			                ctx.shadowOffsetX = 1;
			                ctx.shadowOffsetY = 1;
			                ctx.fillText(arrow, arrowX, arrowY);
                            ctx.restore();
			            }
			            if (this.关联物品) {
			                this.绘制物品(屏幕X, 屏幕Y);
			            }
			        }
			    }
			绘制物品(屏幕X, 屏幕Y) {
			        if (!this.关联物品) return;
                    if (this.关联物品.是否为隐藏物品 && !(玩家属性.透视 || 游戏状态 === '地图编辑器')) {
                        return;
                    }
                    

                    const isRevealedTrap = (this.关联物品 instanceof 陷阱基类 || this.关联物品 instanceof 隐形毒气陷阱) && this.关联物品.是否为隐藏物品 && (玩家属性.透视 || 游戏状态 === '地图编辑器');

                    ctx.save();

                    if (isRevealedTrap) {
                        ctx.globalAlpha = 0.55
                        
                    }

                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    const key = (isRevealedTrap ? this.关联物品.自定义数据.get('激活后图标') : this.关联物品.显示图标) || (this.关联物品.类型 === '楼梯' ? (this.类型 === 单元格类型.楼梯下楼 ? 图标映射.下楼楼梯 : 图标映射.上楼楼梯) : this.关联物品.名称);
                    const iconSize = 单元格大小 * 0.8;
                    const iconColor = this.获取物品颜色();
                    const iconScreenX = 屏幕X + 单元格大小 / 2;
                    const iconScreenY = 屏幕Y + 单元格大小 / 2;
                    
                    if (this.颜色索引 < 颜色表.length || (this.关联物品 instanceof 火把 && this.关联物品.自定义数据.get("耐久") > 0)) {
                        if (this.关联物品 instanceof 火把) {
                            const 闪烁强度 = Math.abs(Math.sin(Date.now() / 200));
                            ctx.shadowColor = `rgba(255, 165, 0, ${0.5 + 闪烁强度 * 0.4})`;
                            ctx.shadowBlur = 8 + 闪烁强度 * 5;
                        } else {
                            ctx.shadowColor = iconColor;
                            ctx.shadowBlur = 15;
                        }
                    }
                    ctx.fillStyle = iconColor;
                    if (命令行模式开启) {
        ctx.fillStyle = this.获取物品颜色();
        ctx.font = `bold ${单元格大小 * 0.9}px 'Courier New', monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const 字符 = key || '§';
        if (this.类型 === 单元格类型.楼梯上楼){
        //debugger
        }
        ctx.fillText(字符, 屏幕X + 单元格大小 / 2, 屏幕Y + 单元格大小 / 2);
        ctx.restore();
        return;
    }
                    drawIcon(ctx, key, iconScreenX, iconScreenY, iconSize, iconColor);

                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;

                    const smallTextSize = 单元格大小 * 0.4;
                    ctx.font = `${smallTextSize}px Arial`;
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "#000000";
                    ctx.fillStyle = "#FFFFFF";
                    

                    if (this.关联物品.堆叠数量 > 1) {
                        ctx.textAlign = "right";
                        ctx.textBaseline = "bottom";
                        const text = this.关联物品.堆叠数量;
                        const textX = 屏幕X + 单元格大小 - 4;
                        const textY = 屏幕Y + 单元格大小 - 4;
                        ctx.strokeText(text, textX, textY);
                        ctx.fillText(text, textX, textY);
                    }

                    if ((this.关联物品 instanceof 红蓝开关 || this.关联物品 instanceof 绿紫开关) && this.关联物品.自定义数据.get('耐久') > 0) {
                        ctx.textAlign = "right";
                        ctx.textBaseline = "bottom";
                        const text = this.关联物品.自定义数据.get('耐久');
                        const textX = 屏幕X + 单元格大小 - 2;
                        const textY = 屏幕Y + 单元格大小 - 2;
                        ctx.strokeText(text, textX, textY);
                        ctx.fillText(text, textX, textY);
                    }

                    if (this.关联物品.是否被丢弃) {
                        ctx.fillStyle = "#AAAAAA";
                        ctx.textAlign = "right";
                        ctx.textBaseline = "top";
                        ctx.fillText("丢", 屏幕X + 单元格大小 - 3, 屏幕Y + 3);
                    }
                    if (this.关联物品 instanceof 隐形毒气陷阱 && isRevealedTrap) {
                    ctx.textAlign = "right";
                        ctx.textBaseline = "top";
                        ctx.lineWidth = 2;
                    ctx.strokeStyle = "#000000";
                    ctx.fillStyle = "#FFFFFF";
                    ctx.strokeText(this.关联物品.自定义数据.get('关联陷阱ID')?.toString().slice(-3), 屏幕X + 单元格大小 - 3, 屏幕Y + 3);
                        ctx.fillText(this.关联物品.自定义数据.get('关联陷阱ID')?.toString().slice(-3), 屏幕X + 单元格大小 - 3, 屏幕Y + 3);
                        }
                    ctx.restore();

                    if ((this.关联物品 instanceof 火把 || this.关联物品 instanceof 护卫植物 || this.关联物品 instanceof 远射植物) && this.关联物品.自定义数据.has("耐久")) {
                        const 耐久百分比 = this.关联物品.自定义数据.get("耐久") / this.关联物品.自定义数据.get("原耐久");
                        ctx.fillStyle = "rgba(0,0,0,0.6)";
                        ctx.fillRect(屏幕X + 单元格大小 * 0.1, 屏幕Y + 单元格大小 * 0.85, 单元格大小 * 0.8, 单元格大小 * 0.1);
                        ctx.fillStyle = 耐久百分比 > 0.5 ? "#4CAF50" : 耐久百分比 > 0.2 ? "#FFC107" : "#F44336";
                        ctx.fillRect(屏幕X + 单元格大小 * 0.1, 屏幕Y + 单元格大小 * 0.85, 单元格大小 * 0.8 * 耐久百分比, 单元格大小 * 0.1);
                    }
			    }
			
			
			    获取物品颜色() {
			        // 根据物品类型返回颜色
			        if (
			            this.类型 === 单元格类型.楼梯下楼 ||
			            this.类型 === 单元格类型.楼梯上楼
			        )
			            return "#fff";
			        return this.关联物品
			            ? this.关联物品.颜色表[this.关联物品.颜色索引] ||
			                  "#FFFFFF"
			            : "#FFFFFF";
			    }
			}
			
			function drawPath(path) {
			    if (path.length < 2) return;
			
			    ctx.save();
			    ctx.beginPath();
			
			    // 设置线条样式
			    ctx.strokeStyle = "rgba(255, 50, 50, 0.5)";
			    ctx.lineWidth = 2 * window.devicePixelRatio; // 适应高清屏
			    ctx.setLineDash([5, 15]);
			    ctx.lineJoin = "round";
			    ctx.lineCap = "round";
			
			    const startX = (玩家.x - 当前相机X + 0.5) * 单元格大小;
			    const startY = (玩家.y - 当前相机Y + 0.5) * 单元格大小;
			    ctx.moveTo(startX, startY);
			
			    // 连接后续点
			    for (let i = 1; i < path.length; i++) {
			        const { x, y } = path[i];
			        const pointX = (x - 当前相机X + 0.5) * 单元格大小;
			        const pointY = (y - 当前相机Y + 0.5) * 单元格大小;
			        ctx.lineTo(pointX, pointY);
			    }
			
			    ctx.stroke();
			    ctx.restore();
			}
			物品池 = 创建物品池();
			怪物池 = 创建怪物池();
			
			// 屏幕方向检测
			let resizeTimer;
			function handleResize() {
			    clearTimeout(resizeTimer);
			    resizeTimer = setTimeout(() => {
			        初始化canvas();
			        更新物体指示器();
			        绘制();
			    }, 200);
			}
			
			window.addEventListener("resize", handleResize);
			handleResize();
			
			function 开始移动() {
			    控制键处理移动(true);
			}
			
			function 控制键处理移动(PC = false) {
			    clearTimeout(移动定时器);
			    clearTimeout(单击移动定时器); // 清除之前的 单击移动定时器
			
			    const 立即移动 = () => {
			        const dx = 移动状态.left
			            ? -玩家属性.移动步数
			            : 移动状态.right
			            ? 玩家属性.移动步数
			            : 0;
			        const dy = 移动状态.up
			            ? -玩家属性.移动步数
			            : 移动状态.down
			            ? 玩家属性.移动步数
			            : 0;
			
			        if (dx !== 0 || dy !== 0) {
			            移动玩家(dx, dy);
			        }
			    };
			
			    const 持续移动 = () => {
			        if (
			            !移动状态.left &&
			            !移动状态.right &&
			            !移动状态.up &&
			            !移动状态.down
			        )
			            return;
			
			        const now = Date.now();
			        if (now - 最后移动时间 >= 移动间隔) {
			            长按移动 = true;
			            立即移动();
			            最后移动时间 = now;
			        }
			        移动定时器 = requestAnimationFrame(持续移动);
			    };
			
			    立即移动();
			    if (PC) {
			        长按移动 = true;
			        最后移动时间 = Date.now();
			        移动定时器 = setTimeout(() => {
			            cancelAnimationFrame(移动定时器);
			            移动定时器 = requestAnimationFrame(持续移动);
			        }, 0);
			    } else {
			        最后移动时间 = Date.now();
			
			        // 如果是长按，则在 首次移动延迟 后开始持续移动
			        移动定时器 = setTimeout(() => {
			            cancelAnimationFrame(移动定时器);
			            移动定时器 = requestAnimationFrame(持续移动);
			        }, 首次移动延迟);
			    }
			}
			function 停止移动() {
			    clearTimeout(移动定时器);
			    clearTimeout(单击移动定时器);
			    clearTimeout(开始移动定时器);
			    移动状态 = {
			        up: false,
			        down: false,
			        left: false,
			        right: false,
			    };
			    长按移动 = false;
			}
			function 显示HUD() {
			    if (hud模式 === "常隐") return;
			    if (hud模式 === "默认") {
			        if (显示HUD计时器) clearTimeout(显示HUD计时器);
			        document.querySelector(".hud").classList.add("可见");
			        显示HUD计时器 = setTimeout(() => {
			            隐藏HUD();
			        }, 700);
			    } else {
			        document.querySelector(".hud").classList.add("可见");
			    }
			}
			
			function 隐藏HUD() {
			    if (hud模式 !== "默认") return;
			    document.querySelector(".hud").classList.remove("可见");
			}
			
			function 切换HUD模式() {
			    const 模式顺序 = ["默认", "常显", "常隐"];
			    const 当前索引 = 模式顺序.indexOf(hud模式);
			    hud模式 = 模式顺序[(当前索引 + 1) % 3];
			
			    // 更新按钮图标
			    const 按钮图标映射 = {
			        默认: 图标映射.HUD智能,
			        常显: 图标映射.HUD常显,
			        常隐: 图标映射.HUD常隐,
			    };
			    document.getElementById("hudToggle").textContent =
			        按钮图标映射[hud模式];
			
			    // 立即应用新模式
			    if (hud模式 === "常显") {
			        document.querySelector(".hud").classList.add("可见");
			    } else if (hud模式 === "常隐") {
			        document.querySelector(".hud").classList.remove("可见");
			    } else {
			        隐藏HUD(); // 恢复默认模式隐藏
			    }
			}
			function 触发HUD显示() {
			    if (hud模式 === "默认") {
			        if (显示HUD计时器) clearTimeout(显示HUD计时器);
			        document.querySelector(".hud").classList.add("可见");
			        显示HUD计时器 = setTimeout(() => {
			            隐藏HUD();
			        }, 700);
			    }
			}
			
			// 防止长按触发文字选择
			document.addEventListener("contextmenu", (e) => e.preventDefault());
			
			const 添加控制事件 = (元素, 方向) => {
			    const 事件类型 = {
			        start:
			            "ontouchstart" in window ? "touchstart" : "mousedown",
			        end: "ontouchend" in window ? "touchend" : "mouseup",
			    };
			
			    元素.addEventListener(事件类型.start, (e) => {
			        e.preventDefault();
			        移动状态[方向] = true;
			        控制键处理移动();
			    });
			
			    元素.addEventListener(事件类型.end, () => {
			        移动状态[方向] = false;
			        停止移动();
			    });
			};
			
			添加控制事件(upBtn, "up");
			添加控制事件(leftBtn, "left");
			添加控制事件(rightBtn, "right");
			添加控制事件(downBtn, "down");
			function 深度比较(a, b) {
			    if (a === b) return true;
			    if (
			        typeof a !== "object" ||
			        typeof b !== "object" ||
			        a === null ||
			        b === null
			    )
			        return false;
			
			    const aKeys = Object.keys(a);
			    const bKeys = Object.keys(b);
			    if (aKeys.length !== bKeys.length) return false;
			
			    for (const key of aKeys) {
			        if (!b.hasOwnProperty(key)) return false;
			        if (!深度比较(a[key], b[key])) return false;
			    }
			    return true;
			}
			
			// 更新HUD显示
			function 更新界面状态() {
			    document.getElementById("roomCount").textContent =
			        已访问房间.size;
			}
			
			function 初始化canvas() {
			    画布宽度 = Math.min(
			        window.innerWidth - 20,
			        window.innerHeight - 100
			    ); // 动态宽度
			    画布高度 = 画布宽度; // 动态高度
			
			    // 保持单元格比例
			    const 单元格宽 = 画布宽度 / 相机显示边长;
			    const 单元格高 = 画布高度 / 相机显示边长;
			
			    单元格大小 = Math.min(单元格宽, 单元格高);
			    ctx.imageSmoothingEnabled = false;
			    ctx.webkitImageSmoothingEnabled = false;
			    const dpr = window.devicePixelRatio;
			    const width = 单元格大小 * 相机显示边长,
			        height = 单元格大小 * 相机显示边长;
			    
			    canvas.width = Math.round(width * dpr);
			    canvas.height = Math.round(height * dpr);
			    canvas.style.width = width + "px";
			    canvas.style.height = height + "px";
			    
			    ctx.scale(dpr, dpr);
			    
			    const 小地图 = document.getElementById("小地图");
			    小地图.width = 地牢大小 * 小地图缩放;
			    小地图.height = 地牢大小 * 小地图缩放;
			    小地图Ctx = 小地图.getContext("2d");
			}
			function 回溯路径(终点X, 终点Y, 距离图) {
			    const 路径 = [];
			    let 当前X = 终点X;
			    let 当前Y = 终点Y;
			    const 终点距离 = 距离图[当前Y][当前X];
			
			    if (终点距离 === Infinity) return []; 
			
			    路径.push({ x: 当前X, y: 当前Y });
			
			    while (距离图[当前Y][当前X] > 0) {
			        const 方向 = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
			        let 找到上一步 = false;
			        for (const {dx, dy} of 方向) {
			            const 上一步X = 当前X + dx;
			            const 上一步Y = 当前Y + dy;
			            if (上一步X >= 0 && 上一步X < 地牢大小 && 上一步Y >= 0 && 上一步Y < 地牢大小) {
			                if (距离图[上一步Y][上一步X] === 距离图[当前Y][当前X] - 1) {
			                    当前X = 上一步X;
			                    当前Y = 上一步Y;
			                    路径.push({ x: 当前X, y: 当前Y });
			                    找到上一步 = true;
			                    break;
			                }
			            }
			        }
			        if (!找到上一步) break; 
			    }
			    return 路径.reverse(); 
			}
			
			function 生成红蓝开关谜题(距离图) {
			    let 最远距离 = -1;
			    let 最远房间 = null;
			    const 可用房间 = 房间列表.filter(房间 => 房间 && 房间.id !== 0 && 房间.类型 === "房间");
			
			    可用房间.forEach(房间 => {
			        const 中心X = 房间.x + Math.floor(房间.w / 2);
			        const 中心Y = 房间.y + Math.floor(房间.h / 2);
			        const 距离 = 距离图[中心Y]?.[中心X];
			        if (距离 !== undefined && 距离 !== Infinity && 距离 > 最远距离) {
			            最远距离 = 距离;
			            最远房间 = 房间;
			        }
			    });
			
			    if (!最远房间) return;
			
			    
			    
			    const 终点中心X = 最远房间.x + Math.floor(最远房间.w / 2);
			    const 终点中心Y = 最远房间.y + Math.floor(最远房间.h / 2);
			    const 关键路径 = 回溯路径(终点中心X, 终点中心Y, 距离图);
			
			    if (关键路径.length < 20) return; 
			
			    
			    
			    const 路径起点索引 = Math.floor(关键路径.length * 0.3);
			    const 路径终点索引 = Math.floor(关键路径.length * 0.7);
			    const 候选障碍物位置 = [];
			
			    for (let i = 路径起点索引; i < 路径终点索引; i++) {
			        const 位置 = 关键路径[i];
			        if (地牢[位置.y][位置.x].背景类型 === 单元格类型.走廊) {
			            候选障碍物位置.push({位置: 位置, 索引: i});
			        }
			    }
			    
			    候选障碍物位置.sort(() => prng() - 0.5);
			    
			    let 最终障碍物位置 = null;
			    let 最终开关房间 = null;
			
			    for(const 候选 of 候选障碍物位置) {
			        const 障碍物距离 = 距离图[候选.位置.y][候选.位置.x];
			        const 关键路径房间ID = new Set(关键路径.map(p => 房间地图[p.y][p.x]));
			
			        const 开关候选房间 = 房间列表.filter(房间 => {
			            if (!房间 || 房间.类型 !== "房间" || 关键路径房间ID.has(房间.id)) return false;
			            
                    const 房间中心距离 = 距离图[房间.y + Math.floor(房间.h / 2)][房间.x + Math.floor(房间.w / 2)];
			        return 房间中心距离 < 障碍物距离; // 找到了！
			        });
			
			        if (开关候选房间.length > 0) {
			            最终障碍物位置 = 候选;
			            最终开关房间 = 开关候选房间[Math.floor(prng() * 开关候选房间.length)];
			            break;
			        }
			    }
			
			    if (!最终障碍物位置 || !最终开关房间) return; 
			
			    
			    
			    const 开关实例 = new 红蓝开关({});
			    const targetRoom = 最终开关房间;
        for (let y = targetRoom.y; y < targetRoom.y + targetRoom.h; y++) {
            for (let x = targetRoom.x; x < targetRoom.x + targetRoom.w; x++) {
                const cell = 地牢[y]?.[x];
                if (cell && cell.关联物品 instanceof 红蓝开关) {
                    最终开关房间=null;
                }
            }
        }
                if(最终开关房间) 放置物品到房间(开关实例, 最终开关房间);
			    添加日志(`已在房间 ${最终开关房间?.id} 生成红蓝开关`);
			    let isVertical = true; 
			    const prevNode = 关键路径[最终障碍物位置.索引 - 1];
			    const nextNode = 关键路径[最终障碍物位置.索引 + 1];
			    if (prevNode && nextNode && prevNode.y === nextNode.y) {
			        isVertical = false; 
			    }
			    
			    const 障碍物中心 = 最终障碍物位置.位置;
			    const 待填充格子 = [障碍物中心]; 
			    const 砖块类型 = prng() > 0.5 ? 蓝砖块 : 红砖块;
			
			    
			    if (isVertical) {
			        
			        for (let dx = -1; dx <= 1; dx += 2) { 
			            for (let i = 1; i < 100; i++) { 
			                const scanX = 障碍物中心.x + i * dx;
			                const scanY = 障碍物中心.y;
			                const cell = 地牢[scanY]?.[scanX];
			                if (cell && cell.背景类型 === 单元格类型.走廊) {
			                    待填充格子.push({ x: scanX, y: scanY });
			                } else {
			                    break; 
			                }
			            }
			        }
			    } else {
			        
			        for (let dy = -1; dy <= 1; dy += 2) { 
			            for (let i = 1; i < 100; i++) {
			                const scanX = 障碍物中心.x;
			                const scanY = 障碍物中心.y + i * dy;
			                const cell = 地牢[scanY]?.[scanX];
			                if (cell && cell.背景类型 === 单元格类型.走廊) {
			                    待填充格子.push({ x: scanX, y: scanY });
			                } else {
			                    break;
			                }
			            }
			        }
			    }
			
			    
			    let 放置的砖块数 = 0;
			    待填充格子.forEach(格子坐标 => {
			        if (放置物品到单元格(new 砖块类型({}), 格子坐标.x, 格子坐标.y)) {
			            放置的砖块数++;
			        }
			    });
			
			    if (放置的砖块数 > 0) {
			        添加日志(`已在关键路径上生成了由 ${放置的砖块数} 块砖块构成的障碍墙`);
			    }
			    
			}
			function 生成地牢() {
			    if (地牢生成方式 === 'cave') return 生成洞穴地牢()
			    if (地牢生成方式 === 'maze') return 生成迷宫地牢()
			    地牢大小 = 100 + 当前层数*2
			    地牢 = Array(地牢大小)
			        .fill()
			        .map((_, y) =>
			            Array(地牢大小)
			                .fill()
			                .map((_, x) => new 单元格(x, y))
			        );
			    房间地图 = Array(地牢大小)
			    .fill()
			    .map(() => Array(地牢大小).fill(-1));
			    let 已连接房间对 = new Set();
			
			    let 房间宽度 =
			        房间尺寸范围[0] +
			        2 *
			            Math.floor(
			                (prng() *
			                    (房间尺寸范围[1] - 房间尺寸范围[0])) /
			                    2
			            );
			    let 房间高度 =
			        房间尺寸范围[0] +
			        2 *
			            Math.floor(
			                (prng() *
			                    (房间尺寸范围[1] - 房间尺寸范围[0])) /
			                    2
			            );
			    let 房间起始X = Math.floor(地牢大小 / 2 - 房间宽度 / 2);
			    let 房间起始Y = Math.floor(地牢大小 / 2 - 房间高度 / 2);
			    房间列表.push({
			        x: 房间起始X,
			        y: 房间起始Y,
			        w: 房间宽度,
			        h: 房间高度,
			        id: 0,
			        名称: `房间_0`,
			        门: [],
			    });
			    放置房间(房间列表[0]);
			    let 回溯 = false;
			    for (let i = 1; i < 最大房间数+当前层数; i++) {
			        let 放置成功 = false;
			        let 尝试次数 = 0;
			
			        while (!放置成功 && 尝试次数 < 300) {
			            尝试次数++;
			            let 上一个房间 = 房间列表[i - 1];
			            if (回溯)
			                上一个房间 =
			                    房间列表[
			                        i -
			                            Math.floor(
			                                (Math.max(0, 尝试次数 - 10) / 40) *
			                                    (房间列表.length - 2)
			                            ) -
			                            1
			                    ];
			            房间宽度 =
			                房间尺寸范围[0] +
			                2 *
			                    Math.floor(
			                        (prng() *
			                            (房间尺寸范围[1] - 房间尺寸范围[0])) /
			                            2
			                    );
			            房间高度 =
			                房间尺寸范围[0] +
			                2 *
			                    Math.floor(
			                        (prng() *
			                            (房间尺寸范围[1] - 房间尺寸范围[0])) /
			                            2
			                    );
			
			            const 方向 = Math.floor(prng() * 4);
			
			            const 扩展距离 =
			                Math.floor(
			                    prng() * Math.max(0, 尝试次数 - 10)
			                ) +
			                房间尺寸范围[1] +
			                2;
			
			            switch (方向) {
			                case 0:
			                    房间起始X =
			                        上一个房间.x +
			                        Math.floor((上一个房间.w - 房间宽度) / 2);
			                    房间起始Y = 上一个房间.y - 房间高度 - 扩展距离;
			                    break;
			                case 1:
			                    房间起始X =
			                        上一个房间.x + 上一个房间.w + 扩展距离;
			                    房间起始Y =
			                        上一个房间.y +
			                        Math.floor((上一个房间.h - 房间高度) / 2);
			                    break;
			                case 2:
			                    房间起始X =
			                        上一个房间.x +
			                        Math.floor((上一个房间.w - 房间宽度) / 2);
			                    房间起始Y =
			                        上一个房间.y + 上一个房间.h + 扩展距离;
			                    break;
			                case 3:
			                    房间起始X = 上一个房间.x - 房间宽度 - 扩展距离;
			                    房间起始Y =
			                        上一个房间.y +
			                        Math.floor((上一个房间.h - 房间高度) / 2);
			                    break;
			            }
			
			            房间起始X = Math.max(
			                5,
			                Math.min(房间起始X, 地牢大小 - 房间宽度 - 5)
			            );
			            房间起始Y = Math.max(
			                5,
			                Math.min(房间起始Y, 地牢大小 - 房间高度 - 5)
			            );
			
			            if (
			                区域是否空闲(
			                    房间起始X,
			                    房间起始Y,
			                    房间宽度,
			                    房间高度
			                )
			            ) {
			                let 房间类型 = "房间";
			                if (房间列表.length > 2 && prng() < 0.12) {
			                    房间类型 = "挑战房间";
			                } else if (
			                    房间列表.length > 2 &&
			                    prng() < 0.15
			                ) {
			                    房间类型 = "单向房间";
			                } else if (
			                    房间列表.length > 2 &&
			                    prng() < 0.1
			                ) {
			                    房间类型 = "黑暗房间";
			                }
			
			                const 新房间 = {
			                    x: 房间起始X,
			                    y: 房间起始Y,
			                    w: 房间宽度,
			                    h: 房间高度,
			                    id: i,
			                    名称: `房间_${i}`,
			                    门: [],
			                    类型: 房间类型,
			                    已连接: true, //兼容 尝试进入特殊房间 函数
			                };
			                if (房间类型 === "挑战房间") {
			                    新房间.挑战状态 = {
			                        进行中: false,
			                        已完成: false,
			                        当前波次: 0,
			                        总波次: 4 + Math.round(prng()*Math.floor(当前层数 / 2)) + (玩家属性.挑战波数增加 || 0),
			                        波次最大回合数: 30 + 当前层数 * 3,
			                        波次当前回合数: 0,
			                        波次内怪物: [],
			                        原始门数据: [],
			                        挑战怪物层级: 当前层数,
			                        
			                    };
			                }
			                房间列表.push(新房间);
			                放置房间(新房间);
			                const 房间对ID = [房间列表[i - 1].id, 新房间.id]
			                    .sort()
			                    .join("-");
			                if (!已连接房间对.has(房间对ID)) {
			                    let 路径 = 连接房间(房间列表[i - 1], 新房间);
			                    if (路径) {
			                        生成走廊(路径);
			                        已连接房间对.add(房间对ID);
			                    }
			                }
			                
			
			                放置成功 = true;
			            }
			        }
			        回溯 = false;
			        if (!放置成功) {
			            console.log(`第${i}个房间多次尝试后仍然放置失败`);
			            回溯 = true;
			        }
			    }
			    添加额外走廊(房间列表, 5+当前层数, 已连接房间对);
			    let has特殊房间生成 = false;
			    if (prng() < 0.5) {
			        生成特殊房间();
			        has特殊房间生成 = true;
			    }
			    
			    生成墙壁();
			
			    const 第一个房间 = 房间列表[0];
			    房间列表[1].类型='房间'
			    玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
			    玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			
			    if (房间列表.length > 4) {
			        处理上锁的门();
			        生成钥匙();
			    }
			    if (has特殊房间生成) 生成寻宝戒指();
			    生成金币();
			    生成物品();
			    if (当前层数>=7 && 当前层数%5!==0) {
			    for (let i=0;i<=当前层数-5;i++) 生成红蓝开关谜题(计算距离图(玩家初始位置.x, 玩家初始位置.y));
			    
			    }
			    生成怪物();
			    
			    if (当前层数 === 0) {
			        const 初始武器 = new 钢制长剑({ 不可破坏: true }); 
			        放置物品到房间(初始武器, 房间列表[0]);
			    }
			    更新视口();
			    已访问房间.add(第一个房间.id); 
			    房间列表.forEach((房间) => 更新房间墙壁(房间));
			    const 距离图 = 计算距离图(玩家初始位置.x, 玩家初始位置.y)
			
			
			    let 最远距离 = -1;
			    let 最远房间 = null;
			    const 可用房间 = 房间列表.filter(
			        (房间) => 房间.id !== 0 && 房间.类型 == "房间"
			    );
			
			    可用房间.forEach((房间) => {
			        const 中心X = 房间.x + Math.floor(房间.w / 2);
			        const 中心Y = 房间.y + Math.floor(房间.h / 2);
			        const 距离 = 距离图[中心Y]?.[中心X]; 
			        生成陷阱(房间);
			
			        if (
			            距离 !== undefined &&
			            距离 !== Infinity &&
			            距离 > 最远距离
			        ) {
			            最远距离 = 距离;
			            最远房间 = 房间;
			        }
			    });
			    
			
			    if (!最远房间) {
			        最远房间 =
			            可用房间[
			                Math.floor(prng() * 可用房间.length)
			            ];
			        console.warn(
			            "未能通过距离找到最远房间放置楼梯，已随机选择。"
			        );
			    }
			    放置楼梯(最远房间, 楼梯图标.下楼, 单元格类型.楼梯下楼);
			    if (当前层数 > 0) {
			        放置楼梯(第一个房间, 楼梯图标.上楼, 单元格类型.楼梯上楼);
			    }
			    所有怪物.forEach(monster => {
			if (monster instanceof 巡逻怪物) {
			    monster.初始巡逻();
			}
			        });
			    更新界面状态();
			    return;
			}
			function 生成迷宫地牢() {
			    地牢大小 = 100 + 当前层数 * 2;
			    地牢 = Array(地牢大小)
			        .fill()
			        .map((_, y) =>
			            Array(地牢大小)
			                .fill()
			                .map((_, x) => new 单元格(x, y))
			        );
			    房间地图 = Array(地牢大小)
			        .fill()
			        .map(() => Array(地牢大小).fill(-1));
			    房间列表 = [];
			    上锁房间列表 = [];
			    所有怪物 = [];
			    所有计时器 = [];
			    已访问房间 = new Set();
			    门实例列表 = new Map();
			    let 当前区域 = 0;

			    当前区域 = 放置房间群(当前区域);
			    当前区域 = 填充迷宫(当前区域);
			    连接所有区域();
			    //移除所有死胡同();
			    最终化地牢();
			}
function 确保所有房间均已连接() {
			    const 方向 = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];

			    for (const 房间 of 房间列表) {
			        if (!房间) continue;

			        let 已连接到走廊 = false;
			        if (房间.门) {
			            for (const 门坐标 of 房间.门) {
			                for (const { dx, dy } of 方向) {
			                    const 邻居X = 门坐标.x + dx;
			                    const 邻居Y = 门坐标.y + dy;
			                    if (地牢[邻居Y]?.[邻居X]?.背景类型 === 单元格类型.走廊) {
			                        已连接到走廊 = true;
			                        break;
			                    }
			                }
			                if (已连接到走廊) break;
			            }
			        }

			        if (已连接到走廊) continue;

			        console.warn(`房间 ${房间.id} (${房间.名称}) 未连接到走廊，正在强制连接...`);

			        const 队列 = [];
			        const 已访问 = new Set();
			        const cameFrom = new Map();


			        for (let ry = 房间.y; ry < 房间.y + 房间.h; ry++) {
			            for (let rx = 房间.x; rx < 房间.x + 房间.w; rx++) {
			                const 房间单元格 = 地牢[ry]?.[rx];
			                if (房间单元格 && 房间单元格.背景类型 === 单元格类型.房间) {
			                    // 检查四个正交方向的邻居
			                    for (const { dx, dy } of 方向) {
			                        const wallX = rx + dx;
			                        const wallY = ry + dy;
			                        const wallKey = `${wallX},${wallY}`;

			                        if (wallX >= 0 && wallX < 地牢大小 && wallY >= 0 && wallY < 地牢大小 &&
			                            地牢[wallY][wallX].背景类型 === 单元格类型.墙壁 &&
			                            !已访问.has(wallKey)) {
			                            
			                            队列.push({ x: wallX, y: wallY });
			                            已访问.add(wallKey);
			                            cameFrom.set(wallKey, {x: rx, y: ry}); // 路径回溯时，墙的前一个点是房间内的地块
			                        }
			                    }
			                }
			            }
			        }

			        if (队列.length === 0) {
			            console.error(`房间 ${房间.id} 无法找到任何可作为起点的相邻墙壁。`);
			            continue;
			        }

			        let 终点 = null;
			        while (队列.length > 0) {
			            const 当前 = 队列.shift();
			            
			            for (const { dx, dy } of 方向) {
			                const 邻居X = 当前.x + dx;
			                const 邻居Y = 当前.y + dy;
			                const 邻居键 = `${邻居X},${邻居Y}`;

			                if (邻居X >= 0 && 邻居X < 地牢大小 && 邻居Y >= 0 && 邻居Y < 地牢大小 && !已访问.has(邻居键)) {
			                     if (地牢[邻居Y][邻居X].背景类型 === 单元格类型.走廊) {
			                        cameFrom.set(邻居键, 当前);
			                        终点 = {x: 邻居X, y: 邻居Y};
			                        队列.length = 0; // 找到即停止
			                        break;
			                     }
			                    if (地牢[邻居Y][邻居X].背景类型 === 单元格类型.墙壁) {
			                        已访问.add(邻居键);
			                        cameFrom.set(邻居键, 当前);
			                        队列.push({ x: 邻居X, y: 邻居Y });
			                    }
			                }
			            }
			        }

			        if (终点) {
			            const 路径 = [];
			            let current = 终点;
			            while (current) {
			                路径.unshift(current);
			                const currentKey = `${current.x},${current.y}`;
			                current = cameFrom.get(currentKey);
			            }
			            
			            // 路径的第一个点现在是房间内的地块，第二个点是紧邻的墙（即门的位置）
			            if (路径.length > 1) { 
			                const 门坐标 = 路径[1]; 
			                const 门单元格 = 地牢[门坐标.y][门坐标.x];

			                const 新门 = new 门({ 关联房间ID: 房间.id, 位置: { x: 门坐标.x, y: 门坐标.y } });
			                门单元格.背景类型 = 单元格类型.门;
			                门单元格.标识 = 新门.唯一标识;
			                门实例列表.set(新门.唯一标识, 新门);
			                if (!房间.门) 房间.门 = [];
			                房间.门.push({ x: 门坐标.x, y: 门坐标.y });
			                
			                // 将路径上剩余的墙壁打通为走廊
			                for (let i = 2; i < 路径.length; i++) {
			                    const pos = 路径[i];
			                    const cell = 地牢[pos.y][pos.x];
			                    if(cell.背景类型 === 单元格类型.墙壁) {
			                       cell.背景类型 = 单元格类型.走廊;
			                    }
			                }
			                console.log(`已为房间 ${房间.id} 在 (${门坐标.x}, ${门坐标.y}) 创建连接通道。`);
			            }
			        } else {
			            console.error(`无法为房间 ${房间.id} 找到通往走廊的路径！`);
			        }
			    }
			}
			function 放置房间群(起始区域) {
			    let 当前区域 = 起始区域;
			    for (let i = 0; i < (200 + 当前层数 * 15); i++) {
			        const 宽度 = (Math.floor(prng() * 4) + 2) * 2 + 1;
			        const 高度 = (Math.floor(prng() * 4) + 2) * 2 + 1;
			        const x = Math.floor(prng() * ((地牢大小 - 宽度) / 2)) * 2 + 1;
			        const y = Math.floor(prng() * ((地牢大小 - 高度) / 2)) * 2 + 1;

			        if (区域是否空闲(x, y, 宽度, 高度, 2)) {
			            
			            let 房间类型 = "房间";
			            if (房间列表.length > 2 && prng() < 0.12) {
			                房间类型 = "挑战房间";
			            } else if (房间列表.length > 2 && prng() < 0.1) {
			                房间类型 = "单向房间";
			            } else if (房间列表.length > 2 && prng() < 0.15) {
			                房间类型 = "黑暗房间";
			            }

			            const 新房间 = {
			                x,
			                y,
			                w: 宽度,
			                h: 高度,
			                id: 当前区域,
			                名称: `房间_${当前区域}`,
			                门: [],
			                类型: 房间类型,
			                已连接: true,
			            };

			            if (房间类型 === "挑战房间") {
			                新房间.挑战状态 = {
			                    进行中: false,
			                    已完成: false,
			                    当前波次: 0,
			                    总波次: 4 + Math.round(prng() * Math.floor(当前层数 / 2)) + (玩家属性.挑战波数增加 || 0),
			                    波次最大回合数: 30 + 当前层数 * 3,
			                    波次当前回合数: 0,
			                    波次内怪物: [],
			                    原始门数据: [],
			                    挑战怪物层级: 当前层数,
			                };
			            }
			            房间列表.push(新房间);
			            房间列表.sort((a,b)=>a.id-b.id)
			            for (let ry = y; ry < y + 高度; ry++) {
			                for (let rx = x; rx < x + 宽度; rx++) {
			                    地牢[ry][rx].背景类型 = 单元格类型.房间;
			                    房间地图[ry][rx] = 当前区域;
			                }
			            }
			            if (房间类型 === "房间" && 房间列表.length > 3 && prng() < 0.17) {
			                const 房间主题列表 = [
			                    { 类型: "隐藏解谜棋盘", 概率: 0.15 },
			                    { 类型: "隐藏罐子房间", 概率: 0.25 },
			                    { 类型: "隐藏植物房间", 概率: 0.2 },
			                    { 类型: "隐藏书库房间", 概率: 0.25 },
			                    { 类型: "隐藏药水房间", 概率: 0.15 },
			                ];
			                const 选定主题 = 加权随机选择(
			                    房间主题列表.map((t) => ({ 值: t.类型, 权重: t.概率 }))
			                );
			                新房间.类型 = 选定主题;
			                
			                switch (选定主题) {
			                    case "隐藏解谜棋盘":
			                        生成解谜棋盘(新房间);
			                        break;
			                    case "隐藏罐子房间":
			                        生成罐子房间内容(新房间);
			                        break;
			                    case "隐藏植物房间":
			                        生成植物房间内容(新房间);
			                        break;
			                    case "隐藏书库房间":
			                        生成书库房间内容(新房间);
			                        break;
			                    case "隐藏药水房间":
			                        生成药水房内容(新房间);
			                        break;
			                }
			            }

			            
			            当前区域++;
			        }
			    }
			    return 当前区域;
			}

			function 填充迷宫(起始区域) {
			    let 当前区域 = 起始区域;
			    for (let y = 1; y < 地牢大小 - 1; y += 4) {
			        for (let x = 1; x < 地牢大小 - 1; x += 4) {
			            if (地牢[y][x].背景类型 === 单元格类型.墙壁) {
			                当前区域++;
			                生长树算法(x, y, 当前区域);
			            }
			        }
			    }
			    return 当前区域;
			}

			function 生长树算法(起始X, 起始Y, 区域ID) {
			    const 单元格列表 = [];
			    const 雕刻 = (x, y) => {
			        if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return;
			        地牢[y][x].背景类型 = 单元格类型.走廊;
			        房间地图[y][x] = 区域ID;
			    };

			    const 雕刻区块 = (x, y) => {
			        雕刻(x, y);
			        雕刻(x + 1, y);
			        雕刻(x, y + 1);
			        雕刻(x + 1, y + 1);
			    };

			    雕刻区块(起始X, 起始Y);
			    单元格列表.push({ x: 起始X, y: 起始Y });

			    while (单元格列表.length > 0) {
			        const 当前单元格 = 单元格列表[单元格列表.length - 1];
			        const 可用方向 = [];
			        const 方向数组 = [{ x: 0, y: -4 }, { x: 0, y: 4 }, { x: -4, y: 0 }, { x: 4, y: 0 }];
			        方向数组.sort(() => prng() - 0.5);

			        for (const 方向 of 方向数组) {
			            const 新X = 当前单元格.x + 方向.x;
			            const 新Y = 当前单元格.y + 方向.y;
			            if (新X > 0 && 新X < 地牢大小 - 1 && 新Y > 0 && 新Y < 地牢大小 - 1 && 地牢[新Y][新X].背景类型 === 单元格类型.墙壁) {
			                可用方向.push(方向);
			            }
			        }

			        if (可用方向.length > 0) {
			            const 选定方向 = 可用方向[0];
			            const 连接点X = 当前单元格.x + 选定方向.x / 2;
			            const 连接点Y = 当前单元格.y + 选定方向.y / 2;
			            const 邻居X = 当前单元格.x + 选定方向.x;
			            const 邻居Y = 当前单元格.y + 选定方向.y;

			            雕刻区块(连接点X, 连接点Y);
			            雕刻区块(邻居X, 邻居Y);

			            单元格列表.push({ x: 邻居X, y: 邻居Y });
			        } else {
			            单元格列表.pop();
			        }
			    }
			}

			function 连接所有区域() {
			    const 连接点列表 = [];
			    for (let y = 1; y < 地牢大小 - 1; y++) {
			        for (let x = 1; x < 地牢大小 - 1; x++) {
			            if (地牢[y][x].背景类型 !== 单元格类型.墙壁) continue;

			            const 相邻区域 = new Set();
			            const 方向数组 = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
			            for (const 方向 of 方向数组) {
			                const 邻居单元格 = 地牢[y + 方向.y][x + 方向.x];
			                if (房间地图[y + 方向.y][x + 方向.x] >= 0) {
			                    相邻区域.add(房间地图[y + 方向.y][x + 方向.x]);
			                }
			            }

			            if (相邻区域.size > 1) {
			                连接点列表.push({ x, y, regions: 相邻区域 });
			            }
			        }
			    }
			    连接点列表.sort(() => prng() - 0.5);

			    const 合并区域 = new Map();
			    for (let i = 0; i <= 房间列表.length + 填充迷宫.length; i++) {
			        合并区域.set(i, i);
			    }

			    const 查找根 = (区域) => {
			        if (!合并区域.has(区域) || 合并区域.get(区域) === 区域) return 区域;
			        const 根 = 查找根(合并区域.get(区域));
			        合并区域.set(区域, 根);
			        return 根;
			    };

			    for (const 连接点 of 连接点列表) {
			        const 区域数组 = Array.from(连接点.regions).map(查找根);
			        const 唯一根 = new Set(区域数组);

			        if (唯一根.size > 1) {
			            const 根代表 = 唯一根.values().next().value;
			            唯一根.forEach(根 => 合并区域.set(根, 根代表));
			            _放置门(连接点.x, 连接点.y);
			        }
			    }
			    const 额外连接概率 = 0.08
                for (const 连接点 of 连接点列表) {
                    if (prng() < 额外连接概率) {
                        _放置门(连接点.x, 连接点.y);
                    }
                }
			

			}

			function _放置门(x, y) {
			    if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return;
			    const 单元格 = 地牢[y]?.[x];
			    if (!单元格 || 单元格.背景类型 !== 单元格类型.墙壁) return;
			
			    let adjX = -1, adjY = -1;
			    let mainDoorOrientation = 'NS'; 
			
			    const leftRegion = 房间地图[y]?.[x - 1];
			    const rightRegion = 房间地图[y]?.[x + 1];
			    const upRegion = 房间地图[y - 1]?.[x];
			    const downRegion = 房间地图[y + 1]?.[x];
			
			    if (leftRegion !== -1 && rightRegion !== -1 && leftRegion !== rightRegion) {
			        mainDoorOrientation = 'EW'; // 墙是垂直的，门是水平开
			        adjX = x;
			        adjY = y + 1;
			    } else if (upRegion !== -1 && downRegion !== -1 && upRegion !== downRegion) {
			        mainDoorOrientation = 'NS'; // 墙是水平的，门是垂直开
			        adjX = x + 1;
			        adjY = y;
			    } else {
			        console.warn(`无法确定门 (${x},${y}) 的朝向，将默认创建垂直门。`);
			        mainDoorOrientation = 'NS';
			        adjX = x + 1;
			        adjY = y;
			    }
			
			    const adjCell = 地牢[adjY]?.[adjX];
			    if (!adjCell || adjCell.背景类型 !== 单元格类型.墙壁) {
			        console.error(`无法为迷宫门 (${x},${y}) 找到配对单元格 at (${adjX}, ${adjY})。`);
			        return; 
			    }
			
			    let 关联房间 = null;
			    const 方向数组 = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
			    for (const 方向 of 方向数组) {
			        const 邻居X = x + 方向.dx;
			        const 邻居Y = y + 方向.dy;
			        if (地牢[邻居Y]?.[邻居X]?.背景类型 === 单元格类型.房间) {
			            关联房间 = 房间列表.find(r => r.id === 房间地图[邻居Y][邻居X]);
			            break;
			        }
			    }
			
			    const 新门 = new 门({ 关联房间ID: 关联房间?.id ?? -1, 位置: { x, y } });
			    门实例列表.set(新门.唯一标识, 新门);
			    if (关联房间 && !关联房间.门.some(d => d.x === x && d.y === y)) {
			        关联房间.门.push({ x, y });
			        关联房间.门.push({ x: adjX, y: adjY });
			    }
			
			    const cellsToUpdate = [
			        { cell: 单元格, partnerX: adjX, partnerY: adjY },
			        { cell: adjCell, partnerX: x, partnerY: y }
			    ];
			
			    cellsToUpdate.forEach(({ cell, partnerX, partnerY }) => {
			        cell.背景类型 = 单元格类型.门;
			        cell.标识 = 新门.唯一标识;
			        cell.关联物品 = null;
			        cell.墙壁 = { 上: false, 右: false, 下: false, 左: false };
			        cell.配对单元格位置 = { x: partnerX, y: partnerY };
			        cell.isOneWay = false;
			        cell.oneWayAllowedDirection = null;
			        cell.doorOrientation = mainDoorOrientation;
			
			        const cx = cell.x;
			        const cy = cell.y;
			        if (地牢[cy]?.[cx + 1]) 地牢[cy][cx + 1].墙壁.左 = false;
			        if (地牢[cy]?.[cx - 1]) 地牢[cy][cx - 1].墙壁.右 = false;
			        if (地牢[cy + 1]?.[cx]) 地牢[cy + 1][cx].墙壁.上 = false;
			        if (地牢[cy - 1]?.[cx]) 地牢[cy - 1][cx].墙壁.下 = false;
			    });
			}

			function 最终化地牢() {
			    for (let y = 1; y < 地牢大小 - 1; y++) {
			        for (let x = 1; x < 地牢大小 - 1; x++) {
			            if (房间地图[y][x]==房间列表.length+1) 房间地图[y][x]=-1
			                }
			            }
			    生成墙壁();
			    房间列表.forEach(更新房间墙壁);
			    确保所有房间均已连接();
                生成墙壁();

			    const 第一个房间 = 房间列表.find(r => r.id === 0) || 房间列表[0];
			    if (第一个房间) {
			        玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
			        玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
			        玩家.x = 玩家初始位置.x;
			        玩家.y = 玩家初始位置.y;
			        已访问房间.add(第一个房间.id);
			    }

			    const 距离图 = 计算距离图(玩家初始位置.x, 玩家初始位置.y);
			    let 最远距离 = -1;
			    let 最远房间 = null;

			    const 可用房间 = 房间列表.filter(房间 => 房间 && (第一个房间 ? 房间.id !== 第一个房间.id : true));

			    可用房间.forEach((房间) => {
			        const 中心X = 房间.x + Math.floor(房间.w / 2);
			        const 中心Y = 房间.y + Math.floor(房间.h / 2);
			        const 距离 = 距离图[中心Y]?.[中心X];
			        生成陷阱(房间);

			        if (!isNaN(距离) && 距离 !== Infinity && 距离 > 最远距离) {
			            最远距离 = 距离;
			            最远房间 = 房间;
			        }
			    });
			    

			    if (!最远房间 && 可用房间.length > 0) {
			        最远房间 = 可用房间[可用房间.length - 1];
			    }

			    if (最远房间) {
			        放置楼梯(最远房间, 楼梯图标.下楼, 单元格类型.楼梯下楼);
			    }
			    if (当前层数 > 0 && 第一个房间) {
			        放置楼梯(第一个房间, 楼梯图标.上楼, 单元格类型.楼梯上楼);
			    }

			    if (当前层数 === 0 && 第一个房间) {
			        const 初始武器 = new 钢制长剑({ 不可破坏: true });
			        放置物品到房间(初始武器, 第一个房间);
			    }

			    if (房间列表.length > 4) {
			        处理上锁的门();
			        生成钥匙();
			    }
			    for (let i=0;i<=当前层数-5;i++) 生成红蓝开关谜题(计算距离图(玩家初始位置.x, 玩家初始位置.y));
			    生成金币();
			    生成物品();
			    生成怪物();
			    

			    所有怪物.forEach(monster => {
			        if (monster instanceof 巡逻怪物) {
			            monster.初始巡逻();
			        }
			    });
			    更新界面状态();
			    更新视口();
			    绘制小地图();
			}
			function 生成陷阱(房间) {
			     if (房间.id === 0 || 房间.类型 !== '房间') return;
			     const 陷阱池 = [
			        { 类: 隐形落石陷阱, 权重: 20 },
			        { 类: 隐形地刺陷阱, 权重: 20 },
			        { 类: 远射陷阱, 权重: 8 },
			        { 类: 隐形失明陷阱, 权重: 12 },
			        { 类: 召唤怪物陷阱, 权重: 10 },
			        { 类: 烈焰触发陷阱, 权重: 5 },
			        { 类: 隐形虫洞陷阱, 权重: 10 },
			     ];
			     
			     const 是否上锁 = 上锁房间列表.some(r => r.id === 房间.id);
			
			     if (prng() < 0.15) {
			         生成毒气陷阱群(房间);
			     }
			
			     const 可用格子 = [];
			     for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			         for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			             const 单元格 = 地牢[y]?.[x];
			             if (单元格 && (单元格.背景类型 === 单元格类型.房间 || 单元格.背景类型 === 单元格类型.走廊) && !单元格.关联物品 && !单元格.关联怪物) {
			                 可用格子.push({ x, y });
			             }
			         }
			     }
			     可用格子.sort(() => prng() - 0.5);
			
			     const 陷阱数量 = prng() < 0.5 ? Math.ceil(prng()*5) : 0;
			
			     for (let i=0; i < 陷阱数量; i++) {
			         if (可用格子.length === 0) break;
			         const { x, y } = 可用格子.pop();
			
			         const 选定陷阱配置 = 加权随机选择(陷阱池.map(t => ({值: t, 权重: t.权重})));
			         if (选定陷阱配置) {
			             const 强化状态 = 是否上锁 || (prng() < 0.1 + 当前层数 * 0.025);
			             const 陷阱实例 = new 选定陷阱配置.类({强化: 强化状态});
			             
			             if (选定陷阱配置.类 === 远射陷阱) {
			                 放置怪物到单元格(陷阱实例, x, y);
			             } else {
			                 放置物品到单元格(陷阱实例, x, y);
			             }
			         }
			     }
			}
			function 计算距离图(起始X, 起始Y) {
			    const 距离图 = Array(地牢大小)
			        .fill(null)
			        .map(() => Array(地牢大小).fill(Infinity));
			    const 队列 = [[起始X, 起始Y, 0]]; // x, y, 距离
			    距离图[起始Y][起始X] = 0;
			    const 已访问 = new Set([`${起始X},${起始Y}`]);
			    const 方向 = [
			        { dx: 0, dy: -1, 当前墙: "上", 反方向墙: "下" },
			        { dx: 0, dy: 1, 当前墙: "下", 反方向墙: "上" },
			        { dx: -1, dy: 0, 当前墙: "左", 反方向墙: "右" },
			        { dx: 1, dy: 0, 当前墙: "右", 反方向墙: "左" },
			    ];
			
			    while (队列.length > 0) {
			        const [x, y, 距离] = 队列.shift();
			
			        for (const dir of 方向) {
			            const 新X = x + dir.dx;
			            const 新Y = y + dir.dy;
			
			            if (
			                新X < 0 ||
			                新X >= 地牢大小 ||
			                新Y < 0 ||
			                新Y >= 地牢大小
			            )
			                continue;
			
			            const 位置键 = `${新X},${新Y}`;
			            if (已访问.has(位置键)) continue;
			
			            const 当前单元格 = 地牢[y]?.[x];
			            const 下一单元格 = 地牢[新Y]?.[新X];
			
			            // 检查移动是否有效（非墙、非锁门、路径通畅）
			            if (
			                当前单元格 &&
			                下一单元格 &&
			                ![单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                    下一单元格.背景类型
			                ) &&
			                !当前单元格.墙壁[dir.当前墙] &&
			                !下一单元格.墙壁[dir.反方向墙] &&
			                !(下一单元格.关联物品?.类型 === '开关砖')
			            ) {
			                距离图[新Y][新X] = 距离 + 1;
			                已访问.add(位置键);
			                队列.push([新X, 新Y, 距离 + 1]);
			            }
			        }
			    }
			    return 距离图;
			}
			function 寻找可放置位置(中心X, 中心Y) {
			    const 方向 = [
			        
			        [0, -1],
			        [1, 0],
			        [0, 1],
			        [-1, 0],
			        [0, 0],
			    ];
			    for (const [dx, dy] of 方向) {
			        const 检查X = 中心X + dx;
			        const 检查Y = 中心Y + dy;
			        if (
			            检查X >= 0 &&
			            检查X < 地牢大小 &&
			            检查Y >= 0 &&
			            检查Y < 地牢大小 &&
			            位置是否可用(检查X, 检查Y, false) &&
			            (已访问房间.has(房间地图[检查Y][检查X])||房间地图[检查Y][检查X]==-1)
			        ) {
			            return { x: 检查X, y: 检查Y };
			        }
			    }
			    return null;
			}
			function 生成罐子房间内容(房间) {
			    for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			        for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			            if ((x + y) % 2 === 0) {
			                if (prng() < 0.3) {
			                    放置物品到单元格(new 空罐子({}), x, y);
			                } else {
			                    放置物品到单元格(new 罐子({}), x, y);
			                }
			            }
			        }
			    }
			}
			
			function 生成植物房间内容(房间) {
			    放置物品到房间(new 泉水({}), 房间);
			
			    const 种子池 = [
			        { 类: 荆棘种子, 权重: 35 },
			        { 类: 护卫种子, 权重: 30 },
			        { 类: 远射种子, 权重: 25 },
			        { 类: 吸能种子, 权重: 10 },
			    ];
			
			    for (let i = 0; i < 6; i++) {
			        const 选定种子配置 = 加权随机选择(
			            种子池.map((s) => ({ 值: s, 权重: s.权重 }))
			        );
			        if (选定种子配置) {
			            const 数量 = 2 + Math.floor(prng() * 2);
			            const 种子实例 = new 选定种子配置.类({ 数量: 数量 });
			            放置物品到房间(种子实例, 房间);
			        }
			    }
			}
			
			function 生成药水房内容(房间) {
			    //放置物品到房间(new 泉水({}), 房间);
			
			    const 药水池 = 物品池["药水"];
			    const 药水数量 = 3 + Math.floor(prng() * 3);
			
			    for (let i = 0; i < 药水数量; i++) {
			        const 选定药水配置 =
			            药水池[Math.floor(prng() * 药水池.length)];
			        if (选定药水配置) {
			            const 药水实例 = new 选定药水配置.类({
			                强化: prng() < 0.3,
			            });
			            放置物品到房间(药水实例, 房间);
			        }
			    }
			
			    const 怪物数量 = 3 + Math.floor(prng() * 3);
			    for (let i = 0; i < 怪物数量; i++) {
			        放置怪物到房间(new 伪装怪物({ 伪装成: "药水" }), 房间);
			    }
			}
			function 生成书库房间内容(房间) {
			    const 书架数量 = Math.floor(
			        房间.w * 房间.h * (0.15 + prng() * 0.2)
			    );
			    for (let i = 0; i < 书架数量; i++) {
			        放置物品到房间(
			            new 书架({ 有内容: prng() < 0.2 }),
			            房间
			        );
			    }
			    const 怪物数量 = Math.floor(
			        房间.w * 房间.h * (0.1 + prng() * 0.2)
			    );
			    for (let i = 0; i < 怪物数量; i++) {
			        放置怪物到房间(new 伪装怪物({ 伪装成: "书架" }), 房间);
			    }
			}
			function 生成特殊房间() {
			    let 房间宽度, 房间高度, 房间起始X, 房间起始Y;
			    let 放置成功 = false;
			    let 尝试次数 = 0;
			
			    const 房间主题列表 = [
			        { 类型: "隐藏解谜棋盘", 概率: 0.15 },
			        { 类型: "隐藏罐子房间", 概率: 0.25 },
			        { 类型: "隐藏植物房间", 概率: 0.2 },
			        { 类型: "隐藏书库房间", 概率: 0.25 },
			        { 类型: "隐藏药水房间", 概率: 0.15 },
			    ];
			
			    const 选定主题 = 加权随机选择(
			        房间主题列表.map((t) => ({ 值: t.类型, 权重: t.概率 }))
			    );
			
			    while (!放置成功 && 尝试次数 < 100) {
			        尝试次数++;
			        房间宽度 = Math.floor(prng() * 3) + 7;
			        房间高度 = 房间宽度;
			        房间起始X =
			            Math.floor(prng() * (地牢大小 - 房间宽度 - 2)) +
			            1;
			        房间起始Y =
			            Math.floor(prng() * (地牢大小 - 房间高度 - 2)) +
			            1;
			
			        if (
			            区域是否空闲(房间起始X, 房间起始Y, 房间宽度, 房间高度)
			        ) {
			            const 新房间 = {
			                x: 房间起始X,
			                y: 房间起始Y,
			                w: 房间宽度,
			                h: 房间高度,
			                id: 房间列表.length,
			                门: [],
			                已连接: false,
			                类型: 选定主题,
			            };
			            房间列表.push(新房间);
			            房间列表.sort((a,b)=>a.id-b.id)
			            放置房间(新房间);
			
			            switch (选定主题) {
			                case "隐藏解谜棋盘":
			                    生成解谜棋盘(新房间);
			                    break;
			                case "隐藏罐子房间":
			                    生成罐子房间内容(新房间);
			                    break;
			                case "隐藏植物房间":
			                    生成植物房间内容(新房间);
			                    break;
			                case "隐藏书库房间":
			                    生成书库房间内容(新房间);
			                    break;
			                case "隐藏药水房间":
			                    生成药水房内容(新房间);
			                    break;
			            }
			            放置成功 = true;
			        }
			    }
			}
			function 生成寻宝戒指() {
			    // 排除已经作为特殊房间的房间
			    const 可用房间 = 房间列表.filter((房间) => 房间.类型 == "房间");
			    if (可用房间.length === 0) return; // 没有可用房间则不生成
			
			    const 目标房间 =
			        可用房间[Math.floor(prng() * 可用房间.length)];
			    const 新戒指 = new 寻宝戒指({ 生效层数: 当前层数 });
			    放置物品到房间(新戒指, 目标房间);
			}
			
			function 连接特殊房间(特殊房间) {
			    let 最近房间 = null;
			    let 最小距离 = Infinity;
			
			    for (const 房间 of 房间列表) {
			        if (房间 === 特殊房间 || 房间.已连接) continue; // 排除特殊房间本身和已连接的房间
			
			        const 距离 =
			            Math.abs(特殊房间.x - 房间.x) +
			            Math.abs(特殊房间.y - 房间.y);
			        if (距离 < 最小距离) {
			            最小距离 = 距离;
			            最近房间 = 房间;
			        }
			    }
			    if (最近房间) {
			        let 路径 = 连接房间(特殊房间, 最近房间);
			
			        if (路径) {
			            生成走廊(路径);
			            特殊房间.已连接 = true; // 标记为已连接
			        } else {
			            添加日志(
			                `无法将特殊房间连接到地牢！房间 ID: ${特殊房间.id}`,
			                `错误`
			            );
			        }
			    } else {
			        添加日志(
			            `没有找到可连接的房间！房间 ID: ${特殊房间.id}`,
			            `错误`
			        );
			    }
			}
			function 生成墙壁() {
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const 当前单元格 = 地牢[y][x];
			            if (当前单元格.是否强制墙壁) {
			                continue; 
			            }
			                if (
			                    [
			                        单元格类型.墙壁,
			                        单元格类型.走廊,
			                        单元格类型.房间,
			                    ].includes(当前单元格.背景类型)
			                ) {
			                    地牢[y][x].墙壁 = {
			                        上:
			                            y > 0 &&
			                            地牢[y - 1][x].背景类型 !==
			                                地牢[y][x].背景类型 &&
			                            [
			                                单元格类型.墙壁,
			                                单元格类型.走廊,
			                                单元格类型.房间,
			                            ].includes(地牢[y - 1][x].背景类型),
			                        下:
			                            y < 地牢大小 - 1 &&
			                            地牢[y + 1][x].背景类型 !==
			                                地牢[y][x].背景类型 &&
			                            [
			                                单元格类型.墙壁,
			                                单元格类型.走廊,
			                                单元格类型.房间,
			                            ].includes(地牢[y + 1][x].背景类型),
			                        左:
			                            x > 0 &&
			                            地牢[y][x - 1].背景类型 !==
			                                地牢[y][x].背景类型 &&
			                            [
			                                单元格类型.墙壁,
			                                单元格类型.走廊,
			                                单元格类型.房间,
			                            ].includes(地牢[y][x - 1].背景类型),
			                        右:
			                            x < 地牢大小 - 1 &&
			                            地牢[y][x + 1].背景类型 !==
			                                地牢[y][x].背景类型 &&
			                            [
			                                单元格类型.墙壁,
			                                单元格类型.走廊,
			                                单元格类型.房间,
			                            ].includes(地牢[y][x + 1].背景类型),
			                    };
			                } else {
			                    地牢[y][x].墙壁 = {
			                        上:
			                            y > 0 &&
			                            地牢[y - 1][x].背景类型 ===
			                                单元格类型.墙壁,
			                        下:
			                            y < 地牢大小 - 1 &&
			                            地牢[y + 1][x].背景类型 ===
			                                单元格类型.墙壁,
			                        左:
			                            x > 0 &&
			                            地牢[y][x - 1].背景类型 ===
			                                单元格类型.墙壁,
			                        右:
			                            x < 地牢大小 - 1 &&
			                            地牢[y][x + 1].背景类型 ===
			                                单元格类型.墙壁,
			                    };
			                }
			
			            
			        }
			    }
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const 当前单元格 = 地牢[y]?.[x];
			            if (!当前单元格) continue;
			
			            const 配对位置 = 当前单元格.配对单元格位置;
			            if (
			                配对位置 &&
			                [
			                    单元格类型.走廊,
			                    单元格类型.门,
			                    单元格类型.上锁的门,
			                ].includes(当前单元格.背景类型)
			            ) {
			                const 配对单元格 = 地牢[配对位置.y]?.[配对位置.x];
			                if (
			                    配对单元格 &&
			                    配对单元格.背景类型 === 当前单元格.背景类型
			                ) {
			                    if (配对位置.x > x) {
			                        
			                        当前单元格.墙壁.右 = false;
			                        配对单元格.墙壁.左 = false;
			                    } else if (配对位置.x < x) {
			                        
			                        当前单元格.墙壁.左 = false;
			                        配对单元格.墙壁.右 = false;
			                    } else if (配对位置.y > y) {
			                        
			                        当前单元格.墙壁.下 = false;
			                        配对单元格.墙壁.上 = false;
			                    } else if (配对位置.y < y) {
			                        
			                        当前单元格.墙壁.上 = false;
			                        配对单元格.墙壁.下 = false;
			                    }
			                }
			            }
			        }
			    }
			}
			function 添加额外走廊(房间列表, 数量, 已连接房间对) {
			    let 添加次数 = 0;
			    let 尝试次数 = 0;
			
			    while (添加次数 < 数量 && 尝试次数 < 100) {
			        尝试次数++;
			
			        const 房间A =
			            房间列表[Math.floor(prng() * 房间列表.length)];
			        const 房间B =
			            房间列表[Math.floor(prng() * 房间列表.length)];
			        if (房间A === 房间B) continue;
			
			        const 房间对ID = [房间A.id, 房间B.id].sort().join("-");
			        if (已连接房间对.has(房间对ID)) {
			            continue;
			        }
			
			        const 路径 = 连接房间(房间A, 房间B);
			
			        if (路径) {
			            已连接房间对.add(房间对ID);
			            生成走廊(路径);
			            添加次数++;
			        }
			    }
			}
			            function 恢复挑战区域() {
			    if (生存挑战备份单元格.length === 0) return;
			
			    生存挑战备份单元格.forEach(备份 => {
			        const { x, y, 类型, 背景类型, 墙壁, 关联物品, 关联怪物, 颜色索引, 标识 } = 备份;
			        const 单元格 = 地牢[y]?.[x];
			        if (单元格) {
			            单元格.类型 = 类型;
			            单元格.背景类型 = 背景类型;
			            单元格.墙壁 = 墙壁;
			            单元格.关联物品 = 关联物品;
			            单元格.关联怪物 = 关联怪物;
			            单元格.颜色索引 = 颜色索引;
			            单元格.标识 = 标识;
			        }
			    });
			
			    生存挑战备份单元格 = []; 
			    生成墙壁(); 
			    绘制();
			    显示通知("随着你的倒下，挑战结界消失了...", "信息");
			}
			            function 生成奖励(房间) {
			    const 奖励数量 = 3;
			    const 奖励物品 = [];
			    
			    const 奖励层级 = (游戏状态 === '地图编辑器' || 游戏状态 === '编辑器游玩' || 是否是自定义关卡) 
			                    ? (自定义全局设置.奖励物品层级 || 0) 
			                    : Math.max(当前层数, 0); 
			    const 下一层数 = 奖励层级 + 1;
			
			    const 品质权重基础 = [
			        { 品质: 1, 权重: 20 },
			        { 品质: 2, 权重: 35 },
			        { 品质: 3, 权重: 25 },
			        { 品质: 4, 权重: 15 },
			        { 品质: 5, 权重: 5 },
			    ];
			
			    let 已选中 = false;
			    let 尝试次数 = 0;
			    const 已生成物品名称 = new Set(); 
			
			    for (let i = 0; i < 奖励数量; i++) {
			        已选中 = false;
			        尝试次数 = 0;
			        while (!已选中 && 尝试次数 < 100) {
			            const 候选物品池 = Object.values(物品池)
			                .flat()
			                .filter((itemCfg) => {
			                    const 临时实例 = new itemCfg.类({});
			                    return (
			                        itemCfg.最小层 <= 下一层数 &&
			                        临时实例.类型 !== "工具" &&
			                        itemCfg.类.name !== "神秘商人" &&
			                        itemCfg.类.name !== "探险家" &&
			                        itemCfg.类.name !== "物品祭坛" &&
			                        itemCfg.类.name !== "耐久祭坛" &&
			                        itemCfg.类.name !== "背包扩容祭坛" &&
			                        itemCfg.类.name !== "重铸台" &&
			                        itemCfg.类.name !== "折跃门" &&
			                        itemCfg.类.name !== "寻宝戒指" &&
			                        itemCfg.类.name !== "配方卷轴" &&
			                        itemCfg.类.name !== "钥匙" &&
			                        itemCfg.类.name !== "金币"
			                    );
			                });
			
			            if (候选物品池.length === 0) {
			                尝试次数 = 100; 
			                continue;
			            }
			
			            let 选中物品模板 = null;
			            let 品质尝试次数 = 0;
			            while (!选中物品模板 && 品质尝试次数 < 50) {
			                const 目标品质配置 = 加权随机选择(
			                    品质权重基础.map((p) => ({
			                        值: p.品质,
			                        权重: p.权重,
			                    }))
			                );
			                const 品质过滤后物品 = 候选物品池.filter(
			                    (item) => item.品质 === 目标品质配置
			                );
			
			                if (品质过滤后物品.length > 0) {
			                    选中物品模板 =
			                        品质过滤后物品[
			                            Math.floor(
			                                prng() *
			                                    品质过滤后物品.length
			                            )
			                        ];
			                }
			                品质尝试次数++;
			            }
			
			            if (!选中物品模板) {
			                选中物品模板 =
			                    候选物品池[
			                        Math.floor(
			                            prng() * 候选物品池.length
			                        )
			                    ];
			            }
			
			            if (选中物品模板) {
			                const 物品实例 = new 选中物品模板.类({
			                    数量: 1, 
			                    强化:
			                        prng() <
			                        0.2 + Math.min(奖励层级, 10) * 0.05, 
			                    已解锁: true, 
			                });
			
			                if (
			                    !已生成物品名称.has(物品实例.名称) &&
			                    物品实例.是否正常物品
			                ) {
			                    奖励物品.push(物品实例);
			                    已生成物品名称.add(物品实例.名称);
			                    已选中 = true;
			                }
			            }
			            尝试次数++;
			        }
			    }
			
			    奖励物品.forEach((物品) => {
			        放置物品到房间(物品, 房间, 单元格类型.物品, false, true);
			    });
			}
			
			let 上次死亡地点 = null;
			function 玩家死亡() {
			    if (死亡界面已显示 || 游戏状态 === "图鉴") return;
			    if (游戏状态 === "地图编辑器" ) {
			    显示通知("不支持在地图编辑器自杀", "错误");
			        return;
			    }
			    if (游戏状态 === "地图编辑器" || 游戏状态 === "死亡界面" || 游戏状态==="胜利"||游戏状态==="图鉴选择") return;
			
			    if (生存挑战激活) {
			        恢复挑战区域();
			        生存挑战激活 = false;
			        
			        let 石碑 = null;
			        let 石碑所在房间 = null;
			        
			        for(const row of 地牢) {
			            for(const cell of row) {
			                if (cell.关联物品 instanceof 挑战石碑 && cell.关联物品.自定义数据.get("已激活")) {
			                    石碑 = cell.关联物品;
			                    const 石碑房间ID = 房间地图[cell.y]?.[cell.x];
			                    if (石碑房间ID !== undefined && 石碑房间ID !== -1) {
			                        石碑所在房间 = 房间列表[石碑房间ID];
			                    }
			                    break;
			                }
			            }
			            if(石碑) break;
			        }
			
			        if (石碑 && 石碑所在房间) {
			            石碑.发放奖励(石碑所在房间.survivalWave); // 在石碑房间生成奖励
			            石碑.自定义数据.set("已激活", false);
			        }
			        
			        // 将所有房间的挑战状态重置
			        房间列表.forEach(房间 => {
			            if (房间 && 房间.isSurvivalChallenge) {
			                房间.isSurvivalChallenge = false;
			            }
			        });
			    }
			    if (!是否为教程层 && 当前层数 !== null) {
			        上次死亡地点 = { 层数: 当前层数, x: 玩家.x, y: 玩家.y };
			    }
			    
			    玩家死亡次数++;
			    更新胜利条件显示();
			    if (游戏状态 === '编辑器游玩' || 是否是自定义关卡) {
			        const 玩家房间ID = 房间地图[玩家.y]?.[玩家.x];
			    const 玩家所在房间 = 房间列表[玩家房间ID];
			    if (玩家所在房间 && 玩家所在房间.类型 === "挑战房间" && 玩家所在房间.挑战状态?.进行中) {
			            处理挑战失败(玩家所在房间);
			        }
			        死亡界面已显示 = true;
			        const 死亡遮罩 = document.createElement("div");
			        死亡遮罩.id = "死亡遮罩";
			        死亡遮罩.innerHTML = `
			        <div class="死亡内容容器">
			            <div class="骷髅容器">
			                <div class="动态骷髅">${图标映射.死亡图标}</div>
			            </div>
			            <div class="重生选项">
			                <button class="重生按钮" id="保留重生">
			                    <span class="按钮图标">⚡</span>
			                    在本层重生
			                </button>
			            </div>
			        </div>
			        `;
			        游戏状态 = "死亡界面";
			        死亡遮罩.querySelector("#保留重生").addEventListener("click", function () {
			            处理重生(true);
			            // 修复bug：确保重生后游戏状态正确，而不是回到主菜单
			            游戏状态 = 是否是自定义关卡 ? "游戏中" : "编辑器游玩"; 
			            
			            document.body.classList.add('编辑器游玩模式', '游戏进行中');
			            document.body.classList.remove('地图编辑器模式');
			            
			            this.style.transform = "scale(0.95)";
			            setTimeout(() => {
			                this.style.transform = "";
			                所有怪物.forEach((m) => {
			                    m.绘制血条(true);
			                });
			            }, 500);
			        });
			        document.body.appendChild(死亡遮罩);
			        return; 
			    }
			
			    
			
			
			    死亡界面已显示 = true;
			    const 设置菜单 = document.getElementById("设置菜单");
			    if (设置菜单 && 设置菜单.classList.contains("显示")) {
			        关闭设置菜单();
			    }
			    房间列表.forEach((房间实例) => {
			        if (
			            房间实例.类型 === "挑战房间" &&
			            房间实例.挑战状态 &&
			            房间实例.挑战状态.进行中
			        ) {
			            显示通知(
			                `由于你的死亡，房间 ${房间实例.id} 的挑战失败了！`,
			                "错误",
			                true,
			                3000
			            );
			            房间实例.挑战状态.进行中 = false;
			            房间实例.挑战状态.已完成 = true;
			
			            房间实例.挑战状态.原始门数据.forEach((门数据) => {
			                const 门单元格 = 地牢[门数据.y]?.[门数据.x];
			                if (门单元格) {
			                    门单元格.背景类型 = 门数据.原类型;
			                    门单元格.标识 = 门数据.原标识;
			                    门单元格.颜色索引 = 门数据.原颜色索引;
			                    门单元格.钥匙ID = 门数据.原钥匙ID;
			                    if (
			                        门数据.原类型 === 单元格类型.上锁的门 &&
			                        门数据.原标识
			                    ) {
			                        const 门实例 = 门实例列表.get(
			                            门数据.原标识
			                        );
			                        if (门实例) {
			                            门实例.类型 = "上锁的门";
			                            门实例.是否上锁 = true;
			                        }
			                    } else if (
			                        门数据.原类型 === 单元格类型.门 &&
			                        门数据.原标识
			                    ) {
			                        const 门实例 = 门实例列表.get(
			                            门数据.原标识
			                        );
			                        if (门实例) {
			                            门实例.类型 = "门";
			                            门实例.是否上锁 = false;
			                        }
			                    }
			                }
			            });
			            生成墙壁();
			        }
			    });
			    const 死亡遮罩 = document.createElement("div");
			    死亡遮罩.id = "死亡遮罩";
			    死亡遮罩.innerHTML = `
			    <div class="死亡内容容器">
			        <div class="骷髅容器">
			            <div class="动态骷髅">${图标映射.死亡图标}</div>
			        </div>
			        <div class="重生选项">
			            <button class="重生按钮" id="保留重生">
			                <span class="按钮图标">⚡</span>
			                从本层重生（保留物品）
			            </button>
			            <button class="重生按钮" id="重新开始">
			                <span class="按钮图标">🔄</span>
			                全新开始（第0层）
			            </button>
			        </div>
			    </div>
			`;
			    if (!是否为教程层 && 当前层数 !== null) {
			        let 死亡凭证 = 生成死亡凭证(当前层数);
			        添加日志(
			            `您已死亡，但您曾经到达 ${当前层数} 层，您的凭证是：` +
			                死亡凭证,
			            "信息"
			        );
			        CopyTextToClipboard(死亡凭证);
			    }
			    游戏状态 = "死亡界面";
			
			    const 粒子容器 = document.createElement("div");
			    粒子容器.className = "死亡粒子";
			    死亡遮罩.appendChild(粒子容器);
			    生成死亡粒子(粒子容器);
			
			    const 显示确认对话框 = () => {
			        const 确认遮罩 = document.createElement("div");
			        确认遮罩.className = "确认对话框遮罩";
			        确认遮罩.innerHTML = `
			        <div class="确认对话框">
			            <h3>警告</h3>
			            <p>你确定要放弃所有进度，从头开始吗？<br>这将清除你所有的物品和探索记录！</p>
			            <div class="确认按钮容器">
			                <button class="确认按钮 确认按钮-确认">确认放弃</button>
			                <button class="确认按钮 确认按钮-取消">再想想</button>
			            </div>
			        </div>
			    `;
			        document.body.appendChild(确认遮罩);
			
			        确认遮罩.querySelector(".确认按钮-确认").onclick = () => {
			            确认遮罩.remove();
			            处理重生(false);
			            游戏状态 = "游戏中";
			        };
			
			        确认遮罩.querySelector(".确认按钮-取消").onclick = () => {
			            确认遮罩.remove();
			        };
			    };
			
			    死亡遮罩.querySelector("#保留重生").addEventListener(
			        "click",
			        function () {
			            处理重生(true);
			            游戏状态 = "游戏中";
			            this.style.transform = "scale(0.95)";
			            setTimeout(() => {
			                this.style.transform = "";
			                所有怪物.forEach((m) => {
			                    m.绘制血条(true);
			                });
			            }, 500);
			        }
			    );
			
			    死亡遮罩.querySelector("#重新开始").addEventListener(
			        "click",
			        function () {
			            显示确认对话框();
			        }
			    );
			
			    document.body.appendChild(死亡遮罩);
			}
			
			function 生成物品(生成房间 = null) {
			    const 当前层数权重 = Math.min(Math.floor(当前层数 / 2), 1); // 每2层提升品质
			    let 可用房间 = 房间列表.filter((房间) => 房间.类型 == "房间");
			    if (生成房间) 可用房间 = 生成房间;
			    可用房间.forEach((房间) => {
			        const 是否上锁 = 上锁房间列表.some((r) => r.id === 房间.id);
			        const 房间类型 = 是否上锁 ? "上锁房间" : "普通房间";
			        const 基础概率 = 是否上锁
			            ? 物品生成配置.基础概率.上锁房间
			            : 物品生成配置.基础概率.普通房间;
			
			        // 计算实际生成概率
			        let 实际概率 = 基础概率;
			        if (是否上锁) 实际概率 += 0.1 + 当前层数 * 0.05;
			        实际概率 = Math.min(实际概率, 0.85);
			
			        if (prng() > 实际概率) return;
			        let 物品数量 = 1;
			        if (是否上锁) {
			            while (prng() < 0.8+0.1*实际概率 && 物品数量<=5) {
			                物品数量++;
			            }
			            物品数量 = Math.min(物品数量, 5);
			        }
			        for (let i = 0; i < 物品数量; i++) {
			            // 计算品质分布
			            const 品质分布 = Object.entries(
			                物品生成配置.品质权重
			            ).reduce((acc, [品质, 权重]) => {
			                const 总权重 = 权重[0] + 权重[1] * 当前层数权重;
			                if (总权重 > 0)
			                    acc.push({
			                        品质: parseInt(品质),
			                        权重: 总权重,
			                    });
			                return acc;
			            }, []);
			
			            // 选择物品类型
			            const 类型分布 = 物品生成配置.类型分布[房间类型];
			            const 选中类型 = 加权随机选择(类型分布);
			
			            // 过滤可用物品
			            const 可用物品 = 物品池[选中类型["类型"]].filter(
			                (item) =>
			                    当前层数 >= item.最小层 &&
			                    品质分布.some((q) => q.品质 >= item.品质)
			            );
			
			            if (可用物品.length === 0) return;
			
			            // 加权选择品质
			            const 目标品质 = 加权随机选择(
			                品质分布.map((q) => ({
			                    值: q.品质,
			                    权重: q.权重,
			                }))
			            );
			
			            // 筛选符合品质的物品
			            const 候选物品 = 可用物品.filter(
			                (item) => item.品质 >= 目标品质
			            );
			            if (候选物品.length === 0) return;
			
			            // 创建物品实例
			            const 选中物品配置 =
			                候选物品[
			                    Math.round(
			                        prng() * (候选物品.length - 1)
			                    )
			                ];
			            const 新物品 = new 选中物品配置.类({});
			
			            if (是否上锁) {
			                新物品.强化 = true;
			            }
			
			            // 尝试放置物品
			            if (!放置物品到房间(新物品, 房间)) {
			                console.log("物品放置失败，位置被占用");
			            }
			        }
			    });
			}
			let 怪物引入计划 = new Map();

			function 生成怪物引入计划() {
			    怪物引入计划.clear();
			    const 怪物池 = 创建怪物池();
			    const 所有普通怪物 = [
			        ...new Map(怪物池.普通房间.map(m => [m.类.name, m])).values()
			    ];
			    if (游戏状态 === '地图编辑器' || 游戏状态 === '编辑器游玩' || 是否是自定义关卡) {
			        怪物引入计划.set(0, 所有普通怪物);
			        return;
			    }

			    const 固定引入 = {
			        0: ['怪物', '盔甲怪物'],
			        1: ['仙人掌怪物', '冰冻怪物', '蜘蛛怪物'],
			        2: ['敏捷怪物', '仙人掌怪物', '吸血鬼'],
			        3: ['炸弹怪物', '萨满怪物', '恐惧怪物'],
			        4: ['剧毒云雾怪物', '反弹怪物', '吸能怪物']
			    };

			    const 已分配怪物 = new Set();
			    for (let i = 0; i <= 4; i++) {
			        怪物引入计划.set(i, []);
			        if (固定引入[i]) {
			            固定引入[i].forEach(怪名 => {
			                const 怪物定义 = 所有普通怪物.find(m => m.类.name === 怪名);
			                if (怪物定义) {
			                    怪物引入计划.get(i).push(怪物定义);
			                    已分配怪物.add(怪名);
			                }
			            });
			        }
			    }

			    const 待分配怪物 = 所有普通怪物.filter(m => !已分配怪物.has(m.类.name));
			    
			    for (let i = 待分配怪物.length - 1; i > 0; i--) {
			        const j = Math.floor(prng() * (i + 1));
			        [待分配怪物[i], 待分配怪物[j]] = [待分配怪物[j], 待分配怪物[i]];
			    }

			    const 可分配层数 = [];
			    for (let i = 5; i < 15; i++) {
			        if (i % 5 !== 0) {
			            可分配层数.push(i);
			        }
			    }

			    if (待分配怪物.length === 0 || 可分配层数.length === 0) {
			        return;
			    }

			    let 当前层数索引 = 0;
			    待分配怪物.forEach(怪物 => {
			        const 分配层数 = 可分配层数[当前层数索引];
			        if (!怪物引入计划.has(分配层数)) {
			            怪物引入计划.set(分配层数, []);
			        }
			        怪物引入计划.get(分配层数).push(怪物);
			        当前层数索引 = (当前层数索引 + 1) % 可分配层数.length;
			    });
			}
			function 生成怪物() {
			    const 当前层数权重 = Math.floor(当前层数 / 3);
			    const 可用房间 = 房间列表.filter(
			        (房间) => 房间.类型 == "房间" || 房间.类型 == "黑暗房间"
			    );
			    
			    const 当前怪物池 = { 普通房间: [], 上锁房间: [] };
			    for (let i = 0; i <= 当前层数; i++) {
			        if (怪物引入计划.has(i)) {
			            怪物引入计划.get(i).forEach(怪物定义 => {
			                if (!当前怪物池.普通房间.some(m => m.类.name === 怪物定义.类.name)) {
			                    当前怪物池.普通房间.push(怪物定义);
			                    当前怪物池.上锁房间.push(怪物定义);
			                }
			            });
			        }
			    }

			    可用房间.forEach((房间) => {
			        if (房间.id === 0) return;
			        const 是否上锁 = 上锁房间列表.some((r) => r.id === 房间.id);
			        const 房间类型 = 是否上锁 ? "上锁房间" : "普通房间";
			
			        const 候选怪物 = 当前怪物池[房间类型].filter(
			            (m) => !(m.类.prototype instanceof 巡逻怪物)
			        );
			
			        if (候选怪物.length === 0) return;
			
			        const 最大生成数 = 是否上锁 ? 最大怪物数 + 2 : 最大怪物数;
			        let 生成数量 = Math.round(
			                prng() *
			                prng() *
			                最大生成数 +
			                当前层数权重
			        );
			
			        if (房间.类型 === "黑暗房间")
			            生成数量 = Math.max(2, 生成数量);
			
			        for (let i = 0; i < 生成数量; i++) {
			            const 总权重 = 候选怪物.reduce(
			                (sum, m) => sum + m.权重,
			                0
			            );
			            let 随机值 = prng() * 总权重;
			            let 选中配置 = null;
			
			            for (const m of 候选怪物) {
			                if (随机值 <= m.权重) {
			                    选中配置 = m;
			                    break;
			                }
			                随机值 -= m.权重;
			            }
			
			            let 放置成功 = false;
			            for (let 尝试次数 = 0; 尝试次数 < 10; 尝试次数++) {
			                const x =
			                    房间.x + Math.floor(prng() * 房间.w);
			                const y =
			                    房间.y + Math.floor(prng() * 房间.h);
			
			                if (
			                    地牢[y][x].背景类型 === 单元格类型.房间 &&
			                    !地牢[y][x].关联怪物 &&
			                    !地牢[y][x].关联物品
			                ) {
			                    const 新怪物 = new 选中配置.类({
			                        x: x,
			                        y: y,
			                        房间ID: 房间.id,
			                        强化: 是否上锁,
			                        基础攻击力: 3 + 当前层数权重,
			                    });
			                    if (当前层数>7 && prng() < 0.15+(当前层数-7)*0.1) {
			                        const 药水池 = [
			                            { 类型: '一次性治疗', 值: 50 },
			                            { 类型: '永久隐身'},
			                            { 类型: '永久速度', 值: 1, 图标: 图标映射.飞毛腿 },
			                            { 类型: '永久抗火', 图标: 图标映射.永久抗火 },
			                            { 类型: '永久力量', 值: 5, 图标: 图标映射.永久力量 },
			                            { 类型: '永久强化', 值: 10 },
			                            { 类型: '永久抗毒', 图标: 图标映射.永久抗毒 },
			                            { 类型: '永久解冻', 图标: 图标映射.永久解冻 },
			                            { 类型: '自爆', 图标: 图标映射.炸弹 }
			                        ];
			                        新怪物.携带药水 = 药水池[Math.floor(prng() * 药水池.length)];
			                        if (新怪物.携带药水.类型 === '自爆') 新怪物.永久增益.push(新怪物.携带药水);
			                    }
			                    新怪物.基础生命值 += 当前层数权重 * 3;
			                    新怪物.当前生命值 += 当前层数权重 * 3;
			                    放置怪物到单元格(新怪物, x, y);
			                    生成成功 = true;
			                    break;
			                }
			            }
			        }
			    });
			
			    
			    const 走廊格子 = [];
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            if (地牢[y]?.[x]?.背景类型 === 单元格类型.走廊) {
			                走廊格子.push({x, y});
			            }
			        }
			    }
			
			    let 巡逻怪物数量 = Math.floor(走廊格子.length / 50);
			    if (地牢生成方式==='maze') 巡逻怪物数量 = Math.floor(走廊格子.length / 125);
			    if (走廊格子.length > 0 && 巡逻怪物数量 > 0) {
			         for (let i = 0; i < 巡逻怪物数量; i++) {
			            let 放置成功 = false;
			            for (let 尝试次数 = 0; 尝试次数 < 20; 尝试次数++) {
			                const 随机索引 = Math.floor(prng() * 走廊格子.length);
			                const {x, y} = 走廊格子[随机索引];
			
			                if (!地牢[y][x].关联怪物 && !地牢[y][x].关联物品) {
			                    const 强化 = prng() < 0.1 + 当前层数 * 0.02;
			                    const 新巡逻怪 = new 巡逻怪物({
			                        x, y,
			                        房间ID: -1,
			                        强化,
			                        随机游走: true,
			                    });
			                    放置怪物到单元格(新巡逻怪, x, y);
			                    放置成功 = true;
			                    走廊格子.splice(随机索引, 1);
			                    break;
			                }
			            }
			        }
			    }
			}
			
			function 加权随机选择(选项列表) {
			    const 乱序列表 = [...选项列表].sort(() => prng() - 0.5);
			
			    // 计算累计权重
			    let 累计权重 = 0;
			    const 累计列表 = 乱序列表.map((opt) => {
			        累计权重 += opt.权重;
			        return { ...opt, 累计权重 };
			    });
			
			    const 随机值 =prng() * 累计权重;
			
			    // 进行一个二分
			    let left = 0;
			    let right = 累计列表.length - 1;
			
			    while (left <= right) {
			        const mid = Math.floor((left + right) / 2);
			        if (随机值 <= 累计列表[mid].累计权重) {
			            if (mid === 0 || 随机值 > 累计列表[mid - 1].累计权重) {
			                return 累计列表[mid].值 || 累计列表[mid];
			            }
			            right = mid - 1;
			        } else {
			            left = mid + 1;
			        }
			    }
			
			    return 累计列表[0]?.值 || 累计列表[0];
			}
			
			function 生成死亡粒子(容器) {
			    const 粒子数量 = 30;
			    const 颜色 = ["#ff0000", "#ff4444", "#ff8888"];
			
			    for (let i = 0; i < 粒子数量; i++) {
			        const 粒子 = document.createElement("div");
			        粒子.className = "死亡粒子";
			        粒子.style.cssText = `
			                                                            position: absolute;
			                                                            width: ${
			                                                                prng() *
			                                                                    4 +
			                                                                2
			                                                            }px;
			                                                            height: ${
			                                                                prng() *
			                                                                    4 +
			                                                                2
			                                                            }px;
			                                                            background: ${
			                                                                颜色[
			                                                                    Math.floor(
			                                                                        prng() *
			                                                                            颜色.length
			                                                                    )
			                                                                ]
			                                                            };
			                                                            border-radius: 50%;
			                                                            left: ${
			                                                                prng() *
			                                                                100
			                                                            }%;
			                                                            top: ${
			                                                                prng() *
			                                                                100
			                                                            }%;
			                                                            animation: 粒子飘落 ${
			                                                                prng() *
			                                                                    3 +
			                                                                2
			                                                            }s linear infinite;
			                                                            opacity: ${
			                                                                prng() *
			                                                                    0.6 +
			                                                                0.4
			                                                            };
			                                                        `;
			        粒子.style.setProperty("--random", prng());
			        容器.appendChild(粒子);
			    }
			}
			function 处理重生(保留物品) {
			    if (当前天气效果.includes("诡魅")) {
			        处理诡魅房间刷新(
			            玩家.x,
			            玩家.y,
			            玩家初始位置.x,
			            玩家初始位置.y
			        );
			    }
			    const 生命条 = document.querySelector(".health-bar");
			    生命条.style.width = "100%";
			    document.querySelector(".power-bar").style.width = `100%`;
			
			    玩家状态.forEach((m) => {
			        m.移除状态();
			    });
			    if (当前激活卷轴列表.size > 0) {
			        当前激活卷轴列表.forEach((卷轴) => {
			            当前激活卷轴列表.delete(卷轴);
			            卷轴.卸下();
			        });
			    }
			    玩家属性.允许移动 = 0;
			    应用永久Buffs();
			    玩家状态 = [];
			
			    if (保留物品) {
			        if (当前层数 === 5) {
			            const 迷宫尺寸 = 85;
			            const 偏移X = Math.floor((地牢大小 - 迷宫尺寸) / 2);
			            const 偏移Y = Math.floor((地牢大小 - 迷宫尺寸) / 2);
			            let rx, ry;
			            do {
			                rx = 偏移X + Math.floor(prng() * 迷宫尺寸);
			                ry = 偏移Y + Math.floor(prng() * 迷宫尺寸);
			            } while (地牢[ry]?.[rx]?.背景类型 !== 单元格类型.走廊);
			            玩家.x = rx;
			            玩家.y = ry;
			        } else if (当前层数 === 15) {
			        const 房间ID = 房间地图[玩家.y][玩家.x];
			        const 当前所在房间 = 房间列表.find(r => r.id === 房间ID);
			
			        let 重生X = 玩家初始位置.x;
			        let 重生Y = 玩家初始位置.y;
			        let 找到位置 = false;
			
			        if (当前所在房间) {
			            for (let i = 0; i < 50; ) {
			                const 随机X = 当前所在房间.x + Math.floor(prng() * 当前所在房间.w);
			                const 随机Y = 当前所在房间.y + Math.floor(prng() * 当前所在房间.h);
			                if (位置是否可用(随机X, 随机Y, false)) {
			                    if (当前所在房间.名称 === "最终秘室") {
			                        const 大首领 = 所有怪物.find(m => m instanceof 王座守护者);
			                        if (大首领 && 广度优先搜索路径(随机X, 随机Y, 大首领.x, 大首领.y, 999)) {
			                            重生X = 随机X;
			                            重生Y = 随机Y;
			                            找到位置 = true;
			                            break;
			                        }
			                    } else {
			                        重生X = 随机X;
			                        重生Y = 随机Y;
			                        找到位置 = true;
			                        break;
			                    }
			                    i++
			                }
			            }
			        }
			
			        if (!找到位置 && 当前所在房间) {
			             重生X = 当前所在房间.x + Math.floor(当前所在房间.w / 2);
			             重生Y = 当前所在房间.y + Math.floor(当前所在房间.h / 2);
			        }
			        
			        玩家.x = 重生X;
			        玩家.y = 重生Y;
			
			    } else if (地牢生成方式 === 'cave') {
            const 可重生位置 = Array.from(已揭示洞穴格子);
            if (可重生位置.length > 0) {
                let 随机X, 随机Y;
let 尝试次数 = 0;
const 最大尝试次数 = 可重生位置.length * 2;

while (尝试次数 < 最大尝试次数) {
    const 位置字符串 = 可重生位置[Math.floor(prng() * 可重生位置.length)];
    const [x, y] = 位置字符串.split(',').map(Number);
    
    if (位置是否可用(x, y)) {
        [随机X, 随机Y] = [x, y];
        break;
    }
    
    尝试次数++;
}

if (尝试次数 >= 最大尝试次数) {
    console.log("无法找到可用的重生位置");
    玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;
} else {
玩家.x = 随机X;
                玩家.y = 随机Y;
}
更新洞穴视野();
                
            } else {
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;
            }
			        } else if(地牢生成方式==='maze') {
			            const visitedRoomIds = Array.from(已访问房间);
			            const availableRespawnRooms = 房间列表.filter(room => room && visitedRoomIds.includes(room.id));

			            if (availableRespawnRooms.length > 0) {
			                // 随机选择一个已访问的房间
			                const randomRoom = availableRespawnRooms[Math.floor(prng() * availableRespawnRooms.length)];
			                
			                // 将玩家放置在房间的中心位置，确保是一个有效的地块
			                玩家.x = randomRoom.x + Math.floor(randomRoom.w / 2);
			                玩家.y = randomRoom.y + Math.floor(randomRoom.h / 2);
			                } else {
			                    玩家.x = 玩家初始位置.x;
			                    玩家.y = 玩家初始位置.y;
			                }
			        } else {
			            玩家.x = 玩家初始位置.x;
			            玩家.y = 玩家初始位置.y;
			        }
			
			        玩家背包.forEach((item) => {
			            if (
			                item.类型 === "武器" &&
			                item.自定义数据.get("冷却剩余") > 0
			            ) {
			                item.自定义数据.set("冷却剩余", 0);
			            }
			        });
			
			        更新装备显示();
			    } else {
			        上次死亡地点 = null;
			        玩家背包.clear();
			        玩家装备.clear();
			        所有地牢层.clear();
			        已访问房间.clear();
			        玩家.x = 玩家初始位置.x;
			        玩家.y = 玩家初始位置.y;
			        地牢 = [];
			        房间列表 = [];
			        所有计时器 = [];
			        if (当前层数 !== null) {
			            切换楼层(0, true,null,false,()=>{更新视口();
			    绘制小地图();
			    更新光源地图();});
			        } else {
			            进入教程层();
			        }
			        更新背包显示();
			        更新装备显示();
			
			        更新界面状态();
			        更新物体指示器();
			        const 死亡遮罩 = document.getElementById("死亡遮罩");
			    if (死亡遮罩) 死亡遮罩.remove();
			    死亡界面已显示 = false;
			    return;
			    }
			
			    const 死亡遮罩 = document.getElementById("死亡遮罩");
			    if (死亡遮罩) 死亡遮罩.remove();
			    死亡界面已显示 = false;
			    更新视口();
			    绘制小地图();
			    更新光源地图();
			}
			function 切换楼层(
			    新层数,
			    完全重生 = false,
			    目标坐标 = null,
			    通过楼梯切换 = false,
			    onCompleteCallback = null
			) {
			    const 遮罩 = document.getElementById("transitionMask");
			    const 标题 = document.getElementById("floorTitle");
			
			    遮罩.style.opacity = 1;
			    if (新层数 === 5 && 当前层数 !== 5) {
			        标题.textContent = `米诺陶的迷宫`;
			    } else if (新层数 === 10 && 当前层数 !== 10) {
			        标题.textContent = `法师图书馆`;
			    } else if (新层数 === 15 && 当前层数 !== 15) {
			        标题.textContent = `最终战场`;
			    } else {
			        标题.textContent = `地牢 ${
			            新层数 < 0 ? 当前层数 - 1 : 新层数
			        }`;
			    }
			    if (新层数 > 当前层数 && !所有地牢层.has(新层数)) {
			            const 定位器地图实例 = [...玩家装备.values()].find(item => item instanceof 定位器地图) || [...玩家背包.values()].find(item => item instanceof 定位器地图);
			            if (定位器地图实例) {
			                if (定位器地图实例.堆叠数量 > 1) {
			                    定位器地图实例.堆叠数量--;
			                    添加日志("消耗了一张定位器地图。", "信息");
			                } else {
			                    处理销毁物品(定位器地图实例.唯一标识, true);
			                    添加日志("消耗了最后一张定位器地图！", "警告");
			                }
			                更新背包显示();
			                更新装备显示();
			            }
			        }
			    setTimeout(() => {
			        标题.style.opacity = 1;
			        标题.style.transform = "scale(1)";
			    }, 200);
			
			    setTimeout(() => {
			        const 旧楼层数据 = 所有地牢层.get(当前层数);
			        const 当前数据 = {
			            地牢数组: 地牢,
			            房间列表: 房间列表,
			            门实例列表: 门实例列表,
			            玩家位置: { x: 玩家.x, y: 玩家.y },
			            上锁房间列表: 上锁房间列表,
			            已访问房间: 已访问房间,
			            地牢生成方式: 地牢生成方式,
			            已揭示洞穴格子: deepClone(已揭示洞穴格子),
			            房间地图: 房间地图,
			            所有怪物: 所有怪物,
			            玩家初始位置: { x: 玩家初始位置.x, y: 玩家初始位置.y },
			            所有计时器: 所有计时器,
			            当前天气效果: [...当前天气效果],
			        };
			
			        所有怪物.forEach((m) => {
			            m.绘制血条(true);
			        });
			
			        if (当前层数 !== null && !完全重生) {
			            const 待保存楼层数据 = 所有地牢层.get(当前层数) || {};
			            待保存楼层数据.地牢数组 = 地牢;
			            待保存楼层数据.房间列表 = 房间列表;
			            待保存楼层数据.门实例列表 = 门实例列表;
			            if (通过楼梯切换) {
			                待保存楼层数据.玩家位置 = { x: 玩家.x, y: 玩家.y };
			            } else {
			                if (!待保存楼层数据.玩家位置) {
			                    待保存楼层数据.玩家位置 = { x: 玩家初始位置.x, y: 玩家初始位置.y };
			                }
			            }
			            待保存楼层数据.上锁房间列表 = 上锁房间列表;
			            待保存楼层数据.已访问房间 = 已访问房间;
			            待保存楼层数据.地牢生成方式 = 地牢生成方式;
			            待保存楼层数据.已揭示洞穴格子 = deepClone(已揭示洞穴格子);
			            待保存楼层数据.房间地图 = 房间地图;
			            待保存楼层数据.所有怪物 = 所有怪物;
			            待保存楼层数据.玩家初始位置 = { x: 玩家初始位置.x, y: 玩家初始位置.y };
			            待保存楼层数据.所有计时器 = 所有计时器;
			            待保存楼层数据.当前天气效果 = [...当前天气效果];
			            所有地牢层.set(当前层数, 待保存楼层数据);
			        } else {
			            传送点列表 = [];
			        }
			
			        当前层数 = 新层数;
			        已揭示洞穴格子 = new Set();
			
			        if (所有地牢层.has(新层数)) {
			            const 新地牢数据 = 所有地牢层.get(新层数);
			            地牢 = 新地牢数据.地牢数组;
			            地牢大小 = 地牢.length;
			            房间列表 = 新地牢数据.房间列表;
			            门实例列表 = 新地牢数据.门实例列表;
			            上锁房间列表 = 新地牢数据.上锁房间列表;
			            已访问房间 = 新地牢数据.已访问房间;
			            已揭示洞穴格子 = deepClone(新地牢数据.已揭示洞穴格子);
			            地牢生成方式 = 新地牢数据.地牢生成方式;
			            房间地图 = 新地牢数据.房间地图;
			            所有怪物 = 新地牢数据.所有怪物;
			            所有计时器 = 新地牢数据.所有计时器;
			            玩家初始位置 = 新地牢数据.玩家初始位置;
			            当前天气效果 = 新地牢数据.当前天气效果 || [];
			            if (目标坐标 && 位置是否可用(目标坐标.x, 目标坐标.y, false)) {
			                玩家.x = 目标坐标.x;
			                玩家.y = 目标坐标.y;
			            } else {
			                玩家.x = 新地牢数据.玩家位置.x;
			                玩家.y = 新地牢数据.玩家位置.y;
			            }
			        } else if (当前层数 === 5) {
			            初始化随机数生成器(当前游戏种子);
			            生成迷宫关卡();
			        } else if (当前层数 === 10) {
			            初始化随机数生成器(当前游戏种子);
			            生成法师图书馆();
			        } else if (当前层数 === 15) {
			            初始化随机数生成器(当前游戏种子);
			            生成最终首领楼层();
			        } else if (当前层数 > 15){
			            初始化随机数生成器(当前游戏种子);
			            生成沉没的迷宫();
			            显示通知('喜悦...或是不甘？','信息');
			            彩蛋1触发 = true;
			        } else {
			            初始化随机数生成器(当前游戏种子);
			            for (let i=0;i<当前层数;i++) prng()
			            if(当前层数===0) {
			                当前出战宠物列表 = [];
			                
			            }
			            const 能量条 = document.querySelector(".power-bar");
			        if (能量条 && 玩家属性.初始能量加成 > 0) {
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            能量条.style.width = `${Math.min(100, 当前能量 + 玩家属性.初始能量加成/自定义全局设置.初始能量值*100)}%`;
			        }
			            房间列表 = [];
			            上锁房间列表 = [];
			            所有怪物 = [];
			            所有计时器 = [];
			            已访问房间 = new Set();
			            房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
			            门实例列表 = new Map();
			            
			            if (当前层数 !== null && 当前层数 % 3 === 0 && 当前层数 !== 0) {
			                生成天气效果();
			            } else {
			                当前天气效果 = [];
			            }
			            生成地牢();
			            //更新洞穴视野();
			            生成并放置随机配方卷轴(当前层数);
			            玩家.x = 玩家初始位置.x;
			            玩家.y = 玩家初始位置.y;
			        }
						当前出战宠物列表.forEach(pet => {
    if (!pet || !pet.是否已放置) return;
	const 瞬间移动 = Object.values(pet.自定义数据.get("装备") || {}).find(item => item instanceof 瞬间移动饰品);
			            if (瞬间移动) {
			                pet.瞬移到玩家身旁();
			            }
});
			
			        更新视口();
			        绘制小地图();
			        更新界面状态();
			        更新物体指示器();
			        更新洞穴视野();
			        所有怪物.forEach((m) => { m.绘制血条(true); });
			        移动玩家(0, 0);
			        if (typeof onCompleteCallback === 'function') {
			            onCompleteCallback(); 
			        }
			        
			
			        标题.style.opacity = 0;
			        标题.style.transform = "scale(0.5)";
			        遮罩.style.opacity = 0;
			    }, 1200);
			
			}


			function 保存传送点() {
			    if (传送点列表.length >= 最大传送点数量) {
			        显示通知(
			            `最多只能保存 ${最大传送点数量} 个传送点！`,
			            "错误"
			        );
			        return;
			    }
			    if (当前层数 === null) {
			        显示通知(`不能在当前楼层设置传送点！`, "错误");
			        return;
			    }
			    if (
			        当前天气效果.includes("诡魅") ||
			        当前天气效果.includes("深夜")
			    ) {
			        显示通知(`奇怪的气氛阻止了传送点的保存...`, "错误");
			        return;
			    }
			    const 当前位置标识 = `${当前层数}-${玩家.x}-${玩家.y}`;
			    // 检查是否已在完全相同的位置保存过
			    if (
			        传送点列表.some(
			            (点) => `${点.层数}-${点.x}-${点.y}` === 当前位置标识
			        )
			    ) {
			        显示通知("当前位置已存在传送点！", "警告");
			        return;
			    }
			
			    // 允许玩家输入名称，或者使用默认名称
			    let 传送点名称 = prompt(
			        `为传送点命名（可选，当前：第 ${当前层数} 层 (${玩家.x}, ${玩家.y})）：`,
			        `第 ${当前层数} 层 (${玩家.x}, ${玩家.y})`
			    );
			    if (传送点名称 === null) return; // 用户取消
			    if (传送点名称.trim() === "") {
			        传送点名称 = `第 ${当前层数} 层 (${玩家.x}, ${玩家.y})`; // 默认名称
			    }
			
			    const 新传送点 = {
			        id:
			            Date.now().toString() +
			            prng().toString(36).substring(2, 7), // 简单唯一ID
			        名称: 传送点名称,
			        层数: 当前层数,
			        x: 玩家.x,
			        y: 玩家.y,
			    };
			
			    传送点列表.push(新传送点);
			    显示通知(`传送点 "${新传送点.名称}" 已保存！`, "成功");
			}
			function 打开传送菜单() {
			    if (自定义全局设置.禁用传送菜单) {
			        显示通知("此关卡禁用了传送菜单。", "警告");
			        return;
			    }
			    if (当前天气效果.includes("诡魅")) {
			        显示通知("诡异的气息干扰了空间传送！", "错误");
			        return;
			    }
			    if (当前层数 % 5 === 0 && 当前层数 > 0) {
			            显示通知('当前地牢无法使用传送菜单','错误');
			            return false;
			        }
			    if (生存挑战激活) {
			            显示通知("强大的结界阻止了空间传送！", "错误");
			            return false;
			    }
			    if (游戏状态 === "地图编辑器") {
			        显示通知("不支持在地图编辑器传送", "错误");
			        return;
			    }
			    if (游戏状态 === "地图编辑器" || 游戏状态 === "死亡界面" || 游戏状态==="胜利"||游戏状态==="图鉴选择"||游戏状态==="图鉴") return;
			    const 遮罩 = document.getElementById("传送点遮罩");
			    const 菜单 = document.getElementById("传送点菜单");
			    const 列表容器 = document.getElementById("传送点列表容器");
			
			    列表容器.innerHTML = "";
			    const 标题栏 = 菜单.querySelector(".重铸弹窗-header");
			    // 检查按钮是否已存在，防止重复添加
			    let 保存按钮 = 标题栏.querySelector("#保存当前传送点按钮"); // 先查找
			    if (!保存按钮) {
			        // 不存在则创建
			        保存按钮 = document.createElement("button");
			        保存按钮.textContent = "保存"; // 使用图标
			        保存按钮.className = "菜单操作按钮 传送菜单按钮-保存"; // 使用新基础类和特定类
			        保存按钮.id = "保存当前传送点按钮";
			        保存按钮.onclick = (事件) => {
			            事件.stopPropagation();
			            保存传送点(); // 调用现有的保存函数
			            列表容器.innerHTML = ""; // 清空旧列表
			            刷新传送菜单();
			        };
			        const 关闭按钮实例 = 标题栏.querySelector(".关闭按钮");
			        if (关闭按钮实例) {
			            标题栏.insertBefore(保存按钮, 关闭按钮实例);
			        } else {
			            标题栏.appendChild(保存按钮);
			        }
			    }
			    刷新传送菜单();
			
			    遮罩.style.display = "block";
			    菜单.style.opacity = 0;
			    菜单.style.transform = "translate(-50%, -50%) scale(0.9)";
			    requestAnimationFrame(() => {
			        菜单.style.transition =
			            "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
			        菜单.style.opacity = 1;
			        菜单.style.transform = "translate(-50%, -50%) scale(1)";
			    });
			    玩家属性.允许移动 += 1;
			}
			function 刷新传送菜单() {
			    const 遮罩 = document.getElementById("传送点遮罩");
			    const 菜单 = document.getElementById("传送点菜单");
			    const 列表容器 = document.getElementById("传送点列表容器");
			    列表容器.innerHTML = "";
			    if (传送点列表.length === 0) {
			        列表容器.innerHTML =
			            "<p style='text-align: center; color: #888;'>没有已保存的传送点。</p>";
			    } else {
			        传送点列表.forEach((点) => {
			            const 条目元素 = document.createElement("div");
			            条目元素.className = "重铸物品"; // 复用样式
			            条目元素.style.display = "flex";
			            条目元素.style.justifyContent = "space-between";
			            条目元素.style.alignItems = "center";
			            条目元素.style.padding = "10px 15px";
			
			            const 名称元素 = document.createElement("span");
			            名称元素.textContent = `${点.名称}`;
			            名称元素.style.flexGrow = "1";
			            名称元素.style.marginRight = "10px";
			
			            const 操作容器 = document.createElement("div");
			            操作容器.style.display = "flex";
			            操作容器.style.gap = "8px"; // 稍微增大按钮间距
			
			            const 传送按钮 = document.createElement("button");
			            传送按钮.innerHTML = "传送"; // 使用图标
			            传送按钮.className = "菜单操作按钮 传送菜单按钮-传送";
			            传送按钮.onclick = (事件) => {
			                事件.stopPropagation();
			                执行传送(点.id);
			            };
			
			            const 删除按钮 = document.createElement("button");
			            删除按钮.innerHTML = "删除"; // 使用图标
			            删除按钮.className = "菜单操作按钮 传送菜单按钮-删除";
			            删除按钮.onclick = (事件) => {
			                事件.stopPropagation();
			                删除传送点(点.id);
			                列表容器.innerHTML = "";
			                刷新传送菜单();
			            };
			
			            操作容器.appendChild(传送按钮);
			            操作容器.appendChild(删除按钮);
			
			            条目元素.appendChild(名称元素);
			            条目元素.appendChild(操作容器);
			            列表容器.appendChild(条目元素);
			        });
			    }
			}
			
			function 关闭传送菜单() {
			    const 遮罩 = document.getElementById("传送点遮罩");
			    const 菜单 = document.getElementById("传送点菜单");
			    菜单.style.transition =
			        "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
			    菜单.style.opacity = 0;
			    菜单.style.transform = "translate(-50%, -50%) scale(0.9)";
			    setTimeout(() => {
			        遮罩.style.display = "none";
			        玩家属性.允许移动 -= 1;
			    }, 300); // 等待动画完成
			}
			
			function 执行传送(目标点标识) {
			    if (当前天气效果.includes("诡魅")) {
			        显示通知("诡异的气息干扰了空间传送！", "错误");
			        关闭传送菜单();
			        return;
			    }
			    if (生存挑战激活) {
			        显示通知("强大的结界阻止了传送！", "错误");
			        关闭传送菜单();
			        return;
			    }
			    const 目标点 = 传送点列表.find((点) => 点.id === 目标点标识);
			    if (!目标点) {
			        显示通知("传送目标点无效！", "错误");
			        return;
			    }
			
			    const 当前玩家房间ID = 房间地图[玩家.y][玩家.x];
			    if (当前玩家房间ID !== -1) {
			        const 当前玩家所在房间 = 房间列表[当前玩家房间ID];
			        if (
			            当前玩家所在房间 &&
			            当前玩家所在房间.类型 === "挑战房间" &&
			            当前玩家所在房间.挑战状态 &&
			            当前玩家所在房间.挑战状态.进行中
			        ) {
			            处理挑战失败(当前玩家所在房间);
			        }
			    }
			
			    关闭传送菜单();
			
			    setTimeout(() => {
			        if (目标点.层数 === 当前层数) {
			            const 目标单元格 = 地牢[目标点.y]?.[目标点.x];
			            if (
			                目标单元格 &&
			                ![单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                    目标单元格.背景类型
			                )
			            ) {
			                玩家.x = 目标点.x;
			                玩家.y = 目标点.y;
			                添加日志(`已传送到 ${目标点.名称}`, "信息");
			                更新视口();
			                绘制();
			                处理怪物回合();
			                更新物体指示器();
			            } else {
			                显示通知(
			                    "目标位置无法传送！可能已被阻挡。",
			                    "错误"
			                );
			            }
			        } else {
			            切换楼层(目标点.层数, false, {
			                x: 目标点.x,
			                y: 目标点.y,
			            });
			            添加日志(`已传送到 ${目标点.名称}`, "信息");
			        }
			    }, 350);
			}
			function 删除传送点(目标点标识) {
			    const 索引 = 传送点列表.findIndex((点) => 点.id === 目标点标识);
			    if (索引 !== -1) {
			        const 删除的名称 = 传送点列表[索引].名称;
			        传送点列表.splice(索引, 1);
			        显示通知(`传送点 "${删除的名称}" 已删除。`, "成功");
			    }
			}
			function 放置楼梯(房间, 图标, 类型) {
			    const 楼梯 = {
			        类型: "楼梯",
			        图标: 图标,
			        显示图标: 图标,
			        颜色索引: 颜色表.length,
			        使用: () => {
			              let 目标层数 =
			                类型 === 单元格类型.楼梯下楼
			                    ? 当前层数 + 1
			                    : 当前层数 - 1;
			            if (当前层数===null) 目标层数 = 0;
			            切换楼层(目标层数, false, null, true);
			        },
			        唯一标识: Symbol(`楼梯_${类型}`),
			        获取名称: () =>
			            类型 === 单元格类型.楼梯下楼 ? "下楼楼梯" : "上楼楼梯",
			        自定义数据: new Map(),
			        品质: 1,
			        能否拾起: false,
			        是否正常物品: false,
			        是否隐藏: false,
			        是否为隐藏物品: false,
			        效果描述: null,
			        已装备: false,
			        装备槽位: null,
			        堆叠数量: 1,
			        最大堆叠数量: 1,
			        颜色表: 颜色表,
			    };
			    放置物品到房间(楼梯, 房间, 类型);
			}
			
			function 生成金币() {
			    const 普通房间生成概率 = 0.3;
			    const 上锁房间生成概率 = 0.7;
			    const 可用房间 = 房间列表.filter((房间) => 房间.类型 == "房间");
			    可用房间.forEach((房间) => {
			        let 生成概率 = 普通房间生成概率;
			        let 最大数量 = 9 + 当前层数;
			
			        // 上锁房间生成更多金币
			        if (上锁房间列表.some((r) => r.id === 房间.id)) {
			            生成概率 = 上锁房间生成概率;
			            最大数量 = 22 + 当前层数;
			        }
			
			        if (prng() < 生成概率) {
			            const 数量 = Math.min(
			                Math.floor(prng() * 最大数量) + 1,
			                最大堆叠数
			            );
			            const 金币实例 = new 金币({ 数量 });
			            放置物品到房间(金币实例, 房间);
			        }
			    });
			}
			function 区域是否空闲(x, y, w, h) {
			    for (let i = y; i < y + h; i++) {
			        for (let j = x; j < x + w; j++) {
			            if (
			                i >= 地牢大小 ||
			                j >= 地牢大小 ||
			                地牢[i][j].背景类型 !== 单元格类型.墙壁
			            ) {
			                return false;
			            }
			        }
			    }
			
			    // 计算缓冲区范围
			    const 缓冲距离 = 2;
			    const xStart = Math.max(0, x - 缓冲距离);
			    const xEnd = Math.min(地牢大小 - 1, x + w - 1 + 缓冲距离);
			    const yStart = Math.max(0, y - 缓冲距离);
			    const yEnd = Math.min(地牢大小 - 1, y + h - 1 + 缓冲距离);
			
			    for (let yi = yStart; yi <= yEnd; yi++) {
			        for (let xi = xStart; xi <= xEnd; xi++) {
			            // 计算到房间边缘的最小曼哈顿距离
			            let dx = 0,
			                dy = 0;
			            if (xi < x) dx = x - xi;
			            else if (xi >= x + w) dx = xi - (x + w - 1);
			
			            if (yi < y) dy = y - yi;
			            else if (yi >= y + h) dy = yi - (y + h - 1);
			
			            const 总距离 = dx + dy;
			
			            // 如果曼哈顿距离≤2且单元格非墙壁，则区域被占用
			            if (
			                总距离 <= 缓冲距离 &&
			                地牢[yi][xi].背景类型 !== 单元格类型.墙壁
			            ) {
			                return false;
			            }
			        }
			    }
			
			    return true;
			}
			
			function 放置房间(房间) {
			    for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			        for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			            const 单元格 = 地牢[y][x];
			            单元格.背景类型 = 单元格类型.房间;
			            房间地图[y][x] = 房间.id;
			            单元格.墙壁 = {
			                上: y === 房间.y,
			                下: y === 房间.y + 房间.h - 1,
			                左: x === 房间.x,
			                右: x === 房间.x + 房间.w - 1,
			            };
			        }
			    }
			    房间.已解锁 = false;
			    return true;
			}
			
			function 更新房间墙壁(房间) {
			    房间.门.forEach((门) => {
			        const { x, y } = 门;
			        if (y + 1 < 地牢大小) 地牢[y + 1][x].墙壁.上 = false;
			        if (y - 1 >= 0) 地牢[y - 1][x].墙壁.下 = false;
			        if (x + 1 < 地牢大小) 地牢[y][x + 1].墙壁.左 = false;
			        if (x - 1 >= 0) 地牢[y][x - 1].墙壁.右 = false;
			    });
			}
			
			function 处理上锁的门() {
			    const 上锁起始索引 = Math.floor(房间列表.length * 0.5);
			    const 候选房间 = 房间列表.filter(
			        (房间) =>
			            房间.门.length > 0 &&
			            房间.id >= 上锁起始索引 &&
			            房间.类型 == "房间" // 排除特殊房间
			    );
			    const 上锁数量 = Math.min(
			        候选房间.length,
			        Math.floor(prng() * 候选房间.length * 0.5) + 1
			    ); // 上锁一部分
			
			    for (let i = 0; i < 上锁数量; i++) {
			        if (候选房间.length === 0) break;
			
			        const 目标房间 = 候选房间.splice(
			            Math.floor(prng() * 候选房间.length),
			            1
			        )[0];
			
			        if (目标房间.id !== 0) {
			            // 不锁起始房间
			            const 颜色索引 = i % 颜色表.length;
			            // 遍历房间记录的主门位置
			            目标房间.门.forEach((主门位置) => {
			                const 主门单元格 = 地牢[主门位置.y]?.[主门位置.x];
			                if (主门单元格 && 主门单元格.标识) {
			                    const 门标识 = 主门单元格.标识;
			                    // 查找所有拥有相同门标识的单元格（包括主门和配对门）
			                    for (let y = 0; y < 地牢大小; y++) {
			                        for (let x = 0; x < 地牢大小; x++) {
			                            const 单元格 = 地牢[y]?.[x];
			                            if (
			                                单元格 &&
			                                单元格.标识 === 门标识 &&
			                                单元格.背景类型 === 单元格类型.门
			                            ) {
			                                单元格.背景类型 =
			                                    单元格类型.上锁的门;
			                                单元格.钥匙ID = 目标房间.id;
			                                单元格.颜色索引 = 颜色索引;
			                                // 更新门实例状态（虽然可能没直接用到，但保持一致）
			                                const 门实例 =
			                                    门实例列表.get(门标识);
			                                if (门实例) {
			                                    门实例.类型 = "上锁的门";
			                                    门实例.是否上锁 = true; // 添加一个明确的锁状态
			                                }
			                            }
			                        }
			                    }
			                }
			            });
			            // 记录上锁房间信息
			            上锁房间列表.push({ ...目标房间, 颜色索引 });
			        }
			    }
			    // 标记房间状态
			    上锁房间列表.forEach((房间) => {
			        const 原始房间 = 房间列表.find((r) => r.id === 房间.id);
			        if (原始房间) 原始房间.已解锁 = false; // 标记未解锁
			    });
			}
			
			function 生成钥匙() {
			    // 计算房间 ID 的 50% 分位点
			    const 钥匙放置截止索引 = Math.floor(房间列表.length * 0.5);
			
			    上锁房间列表.forEach((上锁房间) => {
			        const 新钥匙 = new 钥匙({
			            对应门ID: 上锁房间.id,
			            颜色索引: 上锁房间.颜色索引,
			            地牢层数: 当前层数,
			        });
			
			        // 只在房间 ID 小于 80% 分位点的房间中生成钥匙
			        const 可用房间 = 房间列表.filter(
			            (r) =>
			                !上锁房间列表.some((锁房) => 锁房.id === r.id) &&
			                r.id < 钥匙放置截止索引 &&
			                r.类型 === "房间"
			        );
			
			        const 目标房间 =
			            可用房间.length > 0
			                ? 可用房间[
			                      Math.floor(prng() * 可用房间.length)
			                  ]
			                : null; // 确保有可用房间
			
			        if (目标房间 && 放置物品到房间(新钥匙, 目标房间)) {
			            // 放置成功
			        }
			    });
			}
			
			function 寻找房间入口(房间, 避开方向 = {}) {
			    const { x, y, w, h } = 房间;
			    const 候选入口 = [];
			
			    if (!避开方向.上 && y > 0) {
			        for (let i = x + 1; i < x + w - 1; i++) {
			            if (地牢[y - 1][i].背景类型 === 单元格类型.墙壁) {
			                候选入口.push({ x: i, y: y - 1 });
			            }
			        }
			    }
			    if (!避开方向.下 && y + h < 地牢大小 - 1) {
			        for (let i = x + 1; i < x + w - 1; i++) {
			            if (地牢[y + h][i].背景类型 === 单元格类型.墙壁) {
			                候选入口.push({ x: i, y: y + h });
			            }
			        }
			    }
			    if (!避开方向.左 && x > 0) {
			        for (let i = y + 1; i < y + h - 1; i++) {
			            if (地牢[i][x - 1].背景类型 === 单元格类型.墙壁) {
			                候选入口.push({ x: x - 1, y: i });
			            }
			        }
			    }
			    if (!避开方向.右 && x + w < 地牢大小 - 1) {
			        for (let i = y + 1; i < y + h - 1; i++) {
			            if (地牢[i][x + w].背景类型 === 单元格类型.墙壁) {
			                候选入口.push({ x: x + w, y: i });
			            }
			        }
			    }
			    return 候选入口; // 直接返回数组
			}
			
			function 连接房间(房间A, 房间B, 尝试 = 0) {
			    if (!房间A || !房间B) return;
			    if (尝试 >= 6) {
			        房间A =
			            房间列表[
			                Math.floor(prng() * (房间列表.length - 2))
			            ];
			    }
			    if (尝试 >= 12) return;
			    const 相对位置 = {
			        左: 房间A.x < 房间B.x,
			        右: 房间A.x > 房间B.x,
			        上: 房间A.y < 房间B.y,
			        下: 房间A.y > 房间B.y,
			    };
			
			    const 避开方向 = {
			        起始: {
			            左: 相对位置.左,
			            右: 相对位置.右,
			            上: 相对位置.上,
			            下: 相对位置.下,
			        },
			        结束: {
			            左: 相对位置.右,
			            右: 相对位置.左,
			            上: 相对位置.下,
			            下: 相对位置.上,
			        },
			    };
			
			    const 起始候选 = 寻找房间入口(房间A, 避开方向.起始);
			    const 结束候选 = 寻找房间入口(房间B, 避开方向.结束);
			
			    if (!起始候选 || !结束候选) return;
			
			    let 起始 = null;
			    let 结束 = null;
			    let 最小距离 = Infinity;
			
			    for (const 房间起始 of 起始候选) {
			        for (const 房间结束 of 结束候选) {
			            const 距离 =
			                Math.abs(房间起始.x - 房间结束.x) +
			                Math.abs(房间起始.y - 房间结束.y);
			            if (距离 < 最小距离) {
			                最小距离 = 距离;
			                起始 = 房间起始;
			                结束 = 房间结束;
			            }
			        }
			    }
			
			    if (!起始 || !结束) {
			        return;
			    }
			
			    let 当前 = { x: 起始.x, y: 起始.y };
			    let 路径 = [当前];
			    let 门 = [];
			    let 在房间内 = false;
			    let 进入的房间 = null;
			
			    门.push({ x: 起始.x, y: 起始.y, 进入的房间: 房间A });
			
			    const x轴优先 =
			        Math.abs(结束.x - 起始.x) > Math.abs(结束.y - 起始.y);
			
			    let 上一个节点 = 当前;
			    while (当前.x !== 结束.x || 当前.y !== 结束.y) {
			        const dx = 结束.x - 当前.x;
			        const dy = 结束.y - 当前.y;
			
			        if (x轴优先 && dx !== 0) {
			            当前.x += dx > 0 ? 1 : -1;
			        } else if (dy !== 0) {
			            当前.y += dy > 0 ? 1 : -1;
			        } else if (!x轴优先 && dx !== 0) {
			            当前.x += dx > 0 ? 1 : -1;
			        }
			
			        let 附近的门数量 = [
			            { x: 当前.x, y: 当前.y - 1 },
			            { x: 当前.x, y: 当前.y + 1 },
			            { x: 当前.x - 1, y: 当前.y },
			            { x: 当前.x + 1, y: 当前.y },
			        ].reduce((数量, pos) => {
			            if (
			                pos.x >= 0 &&
			                pos.x < 地牢大小 &&
			                pos.y >= 0 &&
			                pos.y < 地牢大小
			            ) {
			                return (
			                    数量 +
			                    (地牢[pos.y][pos.x].背景类型 === 单元格类型.门)
			                );
			            }
			            return 数量;
			        }, 0);
			
			        const 碰撞房间 = 房间列表.find(
			            (房间) =>
			                当前.x >= 房间.x &&
			                当前.x <= 房间.x + 房间.w - 1 &&
			                当前.y >= 房间.y &&
			                当前.y <= 房间.y + 房间.h - 1 &&
			                房间 !== 房间A
			        );
			        if (碰撞房间 && !在房间内) {
			            在房间内 = true;
			            进入的房间 = 碰撞房间;
			            门.push({
			                x: 上一个节点.x,
			                y: 上一个节点.y,
			                进入的房间: 进入的房间,
			            });
			            附近的门数量 -= 1;
			        } else if (!碰撞房间 && 在房间内) {
			            if (当前.x !== 结束.x && 当前.y !== 结束.y) {
			                门.push({
			                    x: 当前.x,
			                    y: 当前.y,
			                    进入的房间: 进入的房间,
			                });
			                路径.push({ x: 当前.x, y: 当前.y });
			                在房间内 = false;
			            }
			            附近的门数量 -= 1;
			        }
			        if (
			            地牢[当前.y][当前.x].背景类型 === 单元格类型.门 ||
			            附近的门数量 > 1
			        ) {
			            let 路径 = [];
			            let 门 = [];
			            return 连接房间(房间A, 房间B, 尝试 + 1);
			        }
			        if (
			            路径.length === 0 &&
			            地牢[当前.y][当前.x].背景类型 === 单元格类型.走廊
			        ) {
			            let 路径 = [];
			            let 门 = [];
			            return 连接房间(房间A, 房间B, 尝试 + 1);
			        }
			        if (!在房间内) {
			            路径.push({ x: 当前.x, y: 当前.y });
			        }
			        上一个节点 = { x: 当前.x, y: 当前.y };
			    }
			
			    if (!在房间内) {
			        门.push({ x: 结束.x, y: 结束.y, 进入的房间: 房间B });
			        路径.push(结束);
			    }
			    门.forEach((door) => {
			        放置门(door.x, door.y, door.进入的房间);
			    });
			    return 路径;
			}
			
			function 生成走廊(路径) {
			    for (let i = 0; i < 路径.length; i++) {
			        const { x, y } = 路径[i];
			
			        // 确定偏移方向（尝试保持一致性，例如优先向右/向下偏移）
			        let adjX = x,
			            adjY = y;
			        if (i < 路径.length - 1) {
			            // 根据下一个点确定方向
			            const nextX = 路径[i + 1].x;
			            const nextY = 路径[i + 1].y;
			            if (nextX === x) {
			                // 垂直移动
			                adjX = x + 1; // 尝试向右偏移
			            } else {
			                // 水平移动
			                adjY = y + 1; // 尝试向下偏移
			            }
			        } else if (i > 0) {
			            // 根据上一个点确定方向（路径末端）
			            const prevX = 路径[i - 1].x;
			            const prevY = 路径[i - 1].y;
			            if (prevX === x) {
			                // 垂直移动
			                adjX = x + 1;
			            } else {
			                // 水平移动
			                adjY = y + 1;
			            }
			        }
			
			        // 放置主路径单元格
			        if (
			            地牢[y]?.[x] &&
			            地牢[y][x].背景类型 === 单元格类型.墙壁
			        ) {
			            地牢[y][x].背景类型 = 单元格类型.走廊;
			            地牢[y][x].墙壁 = {
			                上: false,
			                右: false,
			                下: false,
			                左: false,
			            }; // 清除墙壁
			            地牢[y][x].配对单元格位置 = { x: adjX, y: adjY }; // 记录伙伴位置
			        }
			
			        // 放置相邻单元格
			        if (
			            adjX >= 0 &&
			            adjX < 地牢大小 &&
			            adjY >= 0 &&
			            adjY < 地牢大小 &&
			            地牢[adjY]?.[adjX]
			        ) {
			            if (地牢[adjY][adjX].背景类型 === 单元格类型.墙壁) {
			                地牢[adjY][adjX].背景类型 = 单元格类型.走廊;
			                地牢[adjY][adjX].墙壁 = {
			                    上: false,
			                    右: false,
			                    下: false,
			                    左: false,
			                }; // 清除墙壁
			                地牢[adjY][adjX].配对单元格位置 = { x: x, y: y }; // 记录伙伴位置
			            }
			        }
			    }
			    // 单独处理墙壁清除，确保相邻的走廊单元格之间没有墙
			    路径.forEach(({ x, y }) => {
			        if (
			            !地牢[y]?.[x] ||
			            地牢[y][x].背景类型 !== 单元格类型.走廊
			        )
			            return;
			
			        const adjPos = 地牢[y][x].配对单元格位置;
			        if (
			            adjPos &&
			            地牢[adjPos.y]?.[adjPos.x]?.背景类型 === 单元格类型.走廊
			        ) {
			            // 根据相对位置清除墙壁
			            if (adjPos.x > x) {
			                // 相邻在右侧
			                地牢[y][x].墙壁.右 = false;
			                地牢[adjPos.y][adjPos.x].墙壁.左 = false;
			            } else if (adjPos.x < x) {
			                // 相邻在左侧
			                地牢[y][x].墙壁.左 = false;
			                地牢[adjPos.y][adjPos.x].墙壁.右 = false;
			            } else if (adjPos.y > y) {
			                // 相邻在下方
			                地牢[y][x].墙壁.下 = false;
			                地牢[adjPos.y][adjPos.x].墙壁.上 = false;
			            } else if (adjPos.y < y) {
			                // 相邻在上方
			                地牢[y][x].墙壁.上 = false;
			                地牢[adjPos.y][adjPos.x].墙壁.下 = false;
			            }
			        }
			        // 清除与路径中上一个点的墙壁
			        const prevIndex =
			            路径.findIndex((p) => p.x === x && p.y === y) - 1;
			        if (prevIndex >= 0) {
			            const prev = 路径[prevIndex];
			            if (
			                地牢[prev.y]?.[prev.x]?.背景类型 === 单元格类型.走廊
			            ) {
			                if (prev.x === x) {
			                    // 垂直连接
			                    if (prev.y < y) {
			                        地牢[y][x].墙壁.上 = false;
			                        地牢[prev.y][prev.x].墙壁.下 = false;
			                    } else {
			                        地牢[y][x].墙壁.下 = false;
			                        地牢[prev.y][prev.x].墙壁.上 = false;
			                    }
			                } else {
			                    // 水平连接
			                    if (prev.x < x) {
			                        地牢[y][x].墙壁.左 = false;
			                        地牢[prev.y][prev.x].墙壁.右 = false;
			                    } else {
			                        地牢[y][x].墙壁.右 = false;
			                        地牢[prev.y][prev.x].墙壁.左 = false;
			                    }
			                }
			                // 同时清除配对单元格与上一个配对单元格的墙
			                const prevAdjPos =
			                    地牢[prev.y]?.[prev.x]?.配对单元格位置;
			                const currentAdjPos = 地牢[y]?.[x]?.配对单元格位置;
			                if (
			                    prevAdjPos &&
			                    currentAdjPos &&
			                    地牢[prevAdjPos.y]?.[prevAdjPos.x]?.背景类型 ===
			                        单元格类型.走廊 &&
			                    地牢[currentAdjPos.y]?.[currentAdjPos.x]
			                        ?.背景类型 === 单元格类型.走廊
			                ) {
			                    if (prevAdjPos.x === currentAdjPos.x) {
			                        // 垂直连接
			                        if (prevAdjPos.y < currentAdjPos.y) {
			                            地牢[currentAdjPos.y][
			                                currentAdjPos.x
			                            ].墙壁.上 = false;
			                            地牢[prevAdjPos.y][
			                                prevAdjPos.x
			                            ].墙壁.下 = false;
			                        } else {
			                            地牢[currentAdjPos.y][
			                                currentAdjPos.x
			                            ].墙壁.下 = false;
			                            地牢[prevAdjPos.y][
			                                prevAdjPos.x
			                            ].墙壁.上 = false;
			                        }
			                    } else {
			                        // 水平连接
			                        if (prevAdjPos.x < currentAdjPos.x) {
			                            地牢[currentAdjPos.y][
			                                currentAdjPos.x
			                            ].墙壁.左 = false;
			                            地牢[prevAdjPos.y][
			                                prevAdjPos.x
			                            ].墙壁.右 = false;
			                        } else {
			                            地牢[currentAdjPos.y][
			                                currentAdjPos.x
			                            ].墙壁.右 = false;
			                            地牢[prevAdjPos.y][
			                                prevAdjPos.x
			                            ].墙壁.左 = false;
			                        }
			                    }
			                }
			            }
			        }
			    });
			}
			
			function 是否在任意房间内(x, y) {
			    return 房间列表.some(
			        (房间) =>
			            x >= 房间.x &&
			            x < 房间.x + 房间.w &&
			            y >= 房间.y &&
			            y < 房间.h
			    ); //可改为直接判断单元格类型
			}
			
			function 放置门(x, y, 目标房间) {
			    if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return;
			
			    // --- 确定门的方向和相邻位置 ---
			    let adjX = -1,
			        adjY = -1;
			    let isVerticalDoor = false; // 门是垂直放置（左右打开）还是水平放置（上下打开）
			
			    // 检查左右是否是房间或走廊
			    const leftCell = 地牢[y]?.[x - 1];
			    const rightCell = 地牢[y]?.[x + 1];
			    if (
			        (leftCell && leftCell.背景类型 !== 单元格类型.墙壁) ||
			        (rightCell && rightCell.背景类型 !== 单元格类型.墙壁)
			    ) {
			        const upCell = 地牢[y - 1]?.[x];
			        const downCell = 地牢[y + 1]?.[x];
			        if (
			            (upCell && upCell.背景类型 !== 单元格类型.墙壁) ||
			            (downCell && downCell.背景类型 !== 单元格类型.墙壁)
			        ) {
			            adjX = -1;
			            adjY = -1;
			        } else {
			            isVerticalDoor = true;
			            adjY = y + 1; // 尝试在下方放置配对门
			            adjX = x;
			        }
			    } else {
			        // 检查上下是否是房间或走廊
			        const upCell = 地牢[y - 1]?.[x];
			        const downCell = 地牢[y + 1]?.[x];
			        if (
			            (upCell && upCell.背景类型 !== 单元格类型.墙壁) ||
			            (downCell && downCell.背景类型 !== 单元格类型.墙壁)
			        ) {
			            isVerticalDoor = false; // 水平放置
			            adjX = x + 1; // 尝试在右方放置配对门
			            adjY = y;
			        } else {
			            adjX = -1;
			            adjY = -1;
			        }
			    }
			
			    // --- 创建逻辑门实例 ---
			    const 新门 = new 门({
			        关联房间ID: 目标房间.id,
			        位置: { x, y }, // 主单元格位置
			    });
			    let mainDoorOrientation = null;
			    if (isVerticalDoor) {
			        mainDoorOrientation = "EW";
			    } else {
			        mainDoorOrientation = "NS";
			    }
			
			    // --- 放置第一个门单元格 ---
			    if (地牢[y]?.[x]) {
			        地牢[y][x].标识 = 新门.唯一标识;
			        地牢[y][x].关联物品 = null;
			        地牢[y][x].背景类型 = 单元格类型.门;
			        地牢[y][x].墙壁 = {
			            上: false,
			            右: false,
			            下: false,
			            左: false,
			        }; // 清除所有墙
			        // 清除周围单元格对着门方向的墙壁
			        if (地牢[y]?.[x + 1]) 地牢[y][x + 1].墙壁.左 = false;
			        if (地牢[y]?.[x - 1]) 地牢[y][x - 1].墙壁.右 = false;
			        if (地牢[y + 1]?.[x]) 地牢[y + 1][x].墙壁.上 = false;
			        if (地牢[y - 1]?.[x]) 地牢[y - 1][x].墙壁.下 = false;
			        地牢[y][x].配对单元格位置 = { x: adjX, y: adjY };
			        地牢[y][x].isOneWay = false; // Initialize
			        地牢[y][x].oneWayAllowedDirection = null; // Initialize
			        地牢[y][x].doorOrientation = mainDoorOrientation;
			        地牢[y][x].主 = true;
			    } else {
			        console.error(`尝试在无效位置 (${x}, ${y}) 放置门`);
			        return;
			    }
			
			    // --- 放置第二个（配对）门单元格 ---
			    let 配对门放置成功 = false;
			    if (
			        adjX >= 0 &&
			        adjX < 地牢大小 &&
			        adjY >= 0 &&
			        adjY < 地牢大小 &&
			        地牢[adjY]?.[adjX]
			    ) {
			        const 配对门 = new 门({
			            关联房间ID: 目标房间.id,
			            位置: { x: adjX, y: adjY },
			        });
			        // 检查配对位置是否为墙壁，避免覆盖房间或走廊
			        if (地牢[adjY][adjX].背景类型 === 单元格类型.墙壁) {
			            地牢[adjY][adjX].标识 = 配对门.唯一标识;
			            地牢[adjY][adjX].关联物品 = null;
			            地牢[adjY][adjX].背景类型 = 单元格类型.门;
			            地牢[adjY][adjX].墙壁 = {
			                上: false,
			                右: false,
			                下: false,
			                左: false,
			            }; // 清除所有墙
			            地牢[adjY][adjX].配对单元格位置 = { x: x, y: y }; // 指回主单元格
			            地牢[adjY][adjX].isOneWay = false; // Initialize
			            地牢[adjY][adjX].oneWayAllowedDirection = null; // Initialize
			            地牢[adjY][adjX].doorOrientation = mainDoorOrientation;
			            配对门放置成功 = true;
			
			            // 清除周围单元格对着配对门方向的墙壁
			            if (地牢[adjY]?.[adjX + 1])
			                地牢[adjY][adjX + 1].墙壁.左 = false;
			            if (地牢[adjY]?.[adjX - 1])
			                地牢[adjY][adjX - 1].墙壁.右 = false;
			            if (地牢[adjY + 1]?.[adjX])
			                地牢[adjY + 1][adjX].墙壁.上 = false;
			            if (地牢[adjY - 1]?.[adjX])
			                地牢[adjY - 1][adjX].墙壁.下 = false;
			        } else {
			            // 如果配对位置不是墙，主门仍然放置，但没有配对门
			            地牢[y][x].配对单元格位置 = null; // 主门没有配对
			            console.warn(
			                `门的配对位置 (${adjX}, ${adjY}) 不是墙壁，只放置了单个门在 (${x}, ${y})`
			            );
			        }
			    } else {
			        // 如果配对位置无效，主门仍然放置，但没有配对门
			        地牢[y][x].配对单元格位置 = null;
			        console.warn(
			            `门的配对位置 (${adjX}, ${adjY}) 超出边界，只放置了单个门在 (${x}, ${y})`
			        );
			    }
			
			    // --- 清除两个门单元格之间的墙壁 ---
			    if (配对门放置成功) {
			        if (isVerticalDoor) {
			            // 垂直放置的门，清除上下墙
			            地牢[y][x].墙壁.下 = false;
			            地牢[adjY][adjX].墙壁.上 = false;
			        } else {
			            // 水平放置的门，清除左右墙
			            地牢[y][x].墙壁.右 = false;
			            地牢[adjY][adjX].墙壁.左 = false;
			        }
			    }
			
			    if (
			        目标房间 &&
			        !目标房间.门.some((d) => d.x === x && d.y === y)
			    ) {
			        目标房间.门.push({ x, y });
			        if (配对门放置成功) 目标房间.门.push({ x: adjX, y: adjY });
			    }
			}
			function randomlySetOneWayDirection(doorCell) {
			    if (!doorCell || !doorCell.doorOrientation) {
			        console.error(
			            "Cannot set one-way direction: doorCell or its orientation is invalid.",
			            doorCell
			        );
			        return null; // Or a default
			    }
			    if (doorCell.doorOrientation === "NS") {
			        return prng() < 0.5 ? "N" : "S"; // Allow passage North or South
			    } else if (doorCell.doorOrientation === "EW") {
			        return prng() < 0.5 ? "E" : "W"; // Allow passage East or West
			    }
			    return null; // Should not happen
			}
			
			function getMoveDirection(fromX, fromY, toX, toY) {
			    if (toX > fromX) return "E";
			    if (toX < fromX) return "W";
			    if (toY > fromY) return "S";
			    if (toY < fromY) return "N";
			    return null;
			}
			function 放置物品到房间(
			    物品实例,
			    目标房间,
			    放置物体 = 单元格类型.物品,
			    禁用光晕 = false,
			    特效 = false,
			    无视怪物 = false
			) {
			    // 寻找有效放置位置
			    let 放置成功 = false;
			    for (let 尝试次数 = 0; 尝试次数 < 20; 尝试次数++) {
			        // 计算房间有效区域
			        const 最小x = 目标房间.x;
			        const 最大x = 目标房间.x + 目标房间.w - 1;
			        const 最小y = 目标房间.y;
			        const 最大y = 目标房间.y + 目标房间.h - 1;
			
			        
			        const x =
			            最小x + Math.floor(prng() * (最大x - 最小x + 1));
			        const y =
			            最小y + Math.floor(prng() * (最大y - 最小y + 1));
			
			        // 验证位置有效性
			        if (位置是否可用(x, y,false,无视怪物)&& !地牢[y][x].关联物品) {
			            地牢[y][x].类型 = 放置物体;
			            地牢[y][x].关联物品 = 物品实例;
			            if (物品实例.颜色索引 === null || 禁用光晕) {
			                物品实例.颜色索引 = 物品实例.颜色表.length;
			            }
			            物品实例.x = x;
			            物品实例.y = y;
			            地牢[y][x].颜色索引 = 物品实例.颜色索引;
			            
			            放置成功 = true;
			            if (特效)
			                计划显示格子特效(
			                    [{ x: x, y: y }],
			                    物品实例.颜色表[物品实例.颜色索引].slice(1)
			                );
			            break;
			        }
			    }
			    return 放置成功;
			}
			function 放置物品到单元格(
			    物品实例,
			    x,
			    y,
			    放置物体 = 单元格类型.物品,
			    禁用光晕 = false,
			    无视怪物 = false
			) {
			    // 验证位置有效性
			    if (位置是否可用(x, y, false,无视怪物) && !地牢[y][x].关联物品) {
			        地牢[y][x].类型 = 放置物体;
			        地牢[y][x].关联物品 = 物品实例;
			        if (物品实例.颜色索引 === null || 禁用光晕) {
			            物品实例.颜色索引 = 物品实例.颜色表.length;
			        }
			        物品实例.x = x;
			        物品实例.y = y;
			        if (物品实例 instanceof 远射植物 || 物品实例 instanceof 护卫植物 || 物品实例 instanceof 刷怪笼 || 物品实例 instanceof 开关脉冲器) {
			if (!所有计时器.some(t => t.唯一标识 === 物品实例.唯一标识)) {
			     所有计时器.push(物品实例);
			}
			        }
			        if (物品实例 instanceof 沉浸式传送门 && !所有传送门.includes(物品实例)) {
			    所有传送门.push(物品实例);
			}
			        地牢[y][x].颜色索引 = 物品实例.颜色索引;
			        return true;
			    }
			    return false;
			}
			
			function 位置是否可用(x, y, 考虑玩家 = true,无视怪物 = false) {
			    // 边界检查
			    if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小 || 地牢?.length == 0)
			        return false;
			    if (考虑玩家 && 玩家.x === x && 玩家.y === y) return false;
				if (当前出战宠物列表.some(p => p.x === x && p.y === y)) return false;
			    const 单元格 = 地牢[y][x];
			
			    // 必须是房间地板且没有其他物品
			    return (
			        [单元格类型.房间, 单元格类型.走廊, 单元格类型.门].includes(
			            单元格.背景类型
			        ) &&
			        (!单元格.关联物品 || !单元格.关联物品?.阻碍怪物 ) &&
			        (!单元格.关联怪物 || 无视怪物)
			    );
			}
			let 互动按钮长按定时器 = null;
			let 互动按钮触摸移动 = false;
			let 互动按钮长按已触发 = false;
			const 互动按钮 = document.getElementById("互动按钮");
			if (互动按钮) {
				互动按钮.addEventListener('touchstart', (e) => {
					e.preventDefault();
					互动按钮触摸移动 = false;
					互动按钮长按已触发 = false;
					clearTimeout(互动按钮长按定时器);
					互动按钮长按定时器 = setTimeout(() => {
					    const inGameStates = ["游戏中", "编辑器游玩", "图鉴"];
						if (!互动按钮触摸移动 && inGameStates.includes(游戏状态)) {
							互动按钮长按已触发 = true;
							开始休息();
						}
					}, 500);
				}, { passive: false });


				互动按钮.addEventListener('touchend', (e) => {
					e.preventDefault();
					clearTimeout(互动按钮长按定时器);
					if (互动按钮长按已触发) {
						停止休息();
					} else if (!互动按钮触摸移动) {
						
						互动按钮.click();
					}
				}, { passive: false });

				互动按钮.addEventListener('touchcancel', (e) => {
					clearTimeout(互动按钮长按定时器);
					if (玩家正在休息) {
						停止休息();
					}
				}, { passive: false });
			}
			//修改时记得同步修改使用背包物品
			            function 尝试互动() {
			    if (游戏状态 === '地图编辑器') {
			        const 互动按钮元素 = document.getElementById('互动按钮');
			        if (编辑器状态.模式 === '传送') {
			            编辑器状态.模式 = '编辑';
			            显示通知("已切换到编辑模式", '信息');
			            互动按钮元素.style.background = '';
			        } else {
			            旧编辑器状态 = 编辑器状态.模式;
			            编辑器状态.模式 = '传送';
			            document.getElementById('笔刷工具容器').style.display = 'none';
			            document.getElementById('扳手工具菜单').style.display = 'none';
			            显示通知("传送模式已开启：点击地图进行传送", '信息');
			            互动按钮元素.style.background = '#2196F3';
			        }
			        编辑器状态.当前选中 = null;
			        document.querySelectorAll('#背包物品栏 .物品条目').forEach(el => el.classList.remove('active'));
			        return;
			    }
			
			    //if (互动冷却) return;
			    //互动冷却 = true;
			    //setTimeout(() => (互动冷却 = false), 500);
			    
			    const 发现的隐藏陷阱 = [];
			    const 侦测范围 = 1; 
			
			    for (let dy = -侦测范围; dy <= 侦测范围; dy++) {
			        for (let dx = -侦测范围; dx <= 侦测范围; dx++) {
			            const 目标X = 玩家.x + dx;
			            const 目标Y = 玩家.y + dy;
			
			            if (目标X < 0 || 目标X >= 地牢大小 || 目标Y < 0 || 目标Y >= 地牢大小) continue;
			
			            const 单元格 = 地牢[目标Y][目标X];
			            if (单元格 && 单元格.关联物品 && (单元格.关联物品 instanceof 陷阱基类 || 单元格.关联物品 instanceof 隐形毒气陷阱) && 单元格.关联物品.是否为隐藏物品) {
			                发现的隐藏陷阱.push(单元格.关联物品);
			            }
			        }
			    }
			
			    if (发现的隐藏陷阱.length > 0) {
			        const 能量消耗 = 5;
			        if (扣除能量(能量消耗)) {
			            发现的隐藏陷阱.forEach(陷阱 => {
			                陷阱.是否为隐藏物品 = false;
			                陷阱.自定义数据.set("已触发", true);
			                陷阱.自定义数据.set("已发现", true);
			                陷阱.图标 = 陷阱.自定义数据.get('激活后图标');
			            });
			            显示通知(`你仔细探查后，发现了 ${发现的隐藏陷阱.length} 个陷阱！`, "成功");
			            
			        } else {
			            显示通知(`能量不足，无法侦测陷阱！(需要 ${能量消耗} 能量)`, "错误");
			        }
			    }
			
			    let 互动 = false;
			    const 玩家所在单元格 = 地牢[玩家.y][玩家.x];
			    if (玩家所在单元格.关联物品) {
			        if (玩家所在单元格.关联物品?.类型 === "棋子") {
			            玩家所在单元格.关联物品.能否拾起 = true;
			            if (尝试收集物品(玩家所在单元格.关联物品)) {
			                玩家所在单元格.类型 = null;
			                玩家所在单元格.关联物品 = null;
			                
			                绘制();
			                互动 = true;
			            }
			        } else if (尝试收集物品(玩家所在单元格.关联物品)) {
			            玩家所在单元格.类型 = null;
			            玩家所在单元格.关联物品 = null;
			            更新光源地图();
			            绘制();
			            互动 = true;
			        } else if (
			            玩家所在单元格.关联物品?.类型 === "NPC" &&
			            !NPC互动中
			        ) {
			            玩家所在单元格.关联物品.使用();
			            NPC互动中 = true;
			            互动 = true;
			        }
			        if (玩家所在单元格.关联物品?.尝试互动?.()) {
			            互动 = true;
			        }
			    }
				当前出战宠物列表.forEach(pet => {
    if (!pet || !pet.是否已放置) return;
	if (pet?.x===玩家.x&&pet?.y===玩家.y && pet.层数==当前层数 ) {
		pet.尝试互动();
			        互动=true;
			    }
});
			    
			
			    if (互动) return;
			
			    const 方向 = [
			        { dx: 0, dy: -1 },
			        { dx: 1, dy: 0 },
			        { dx: 0, dy: 1 },
			        { dx: -1, dy: 0 },
			    ];
			
			    for (const { dx, dy } of 方向) {
			        const 目标X = 玩家.x + dx;
			        const 目标Y = 玩家.y + dy;
			
			        if (
			            目标X < 0 ||
			            目标X >= 地牢大小 ||
			            目标Y < 0 ||
			            目标Y >= 地牢大小
			        )
			            continue;
			
			        const 单元格 = 地牢[目标Y][目标X];
			
			        if (
			            单元格.关联物品 instanceof 祭坛类 &&
			            单元格.关联物品.自定义数据.get("激活条件") ===
			                "力量考验"
			        ) {
			            const 武器 = Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			                玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			            )
			                .filter((v) => v != null)
			                .find(
			                    (i) =>
			                        i?.类型 === "武器" &&
			                        i?.堆叠数量 > 0 &&
			                        i?.自定义数据.get("冷却剩余") == 0
			                );
			            if (武器) {
			                单元格.关联物品.当被攻击(武器.攻击力, 玩家);
			                武器.自定义数据.set(
			                    "耐久",
			                    武器.自定义数据.get("耐久") - 武器.耐久消耗
			                );
			                if (武器.自定义数据.get("耐久") <= 0) {
			                    处理销毁物品(武器.唯一标识, true);
			                }
			                武器.自定义数据.set("冷却剩余", 武器.最终冷却回合);
			                更新装备显示();
			                互动 = true;
			                break;
			            }
			        }
			        
			        if (单元格.背景类型 === 单元格类型.上锁的门) {
			            const 对应门 = 门实例列表.get(单元格.标识);
			            const 对应钥匙 = [...玩家背包.values()].find((item) =>
			                item.可交互目标(对应门)
			            );
			            if (对应钥匙) {
			                房间列表.find(
			                    (房间) => 房间.id === 对应门.房间ID
			                )?.门?.forEach((item) => {
			                    let 房间门 = 门实例列表.get(
			                        地牢[item.y][item.x].标识
			                    );
			                    互动 = 房间门.尝试解锁(玩家背包);
			                    if (互动)
			                        地牢[房间门.所在位置.y][
			                            房间门.所在位置.x
			                        ].背景类型 = 单元格类型.门;
			                });
			                绘制();
			            }
			            if (互动) {
			                处理销毁物品(对应钥匙.唯一标识, true);
			                显示通知("解锁成功！", "成功");
			                break; 
			            }
			        } else if (快速直线检查(玩家.x, 玩家.y, 目标X, 目标Y, 1)) {
			            if (单元格.关联物品) {
			                if (单元格.关联物品?.类型 === "棋子") {
			                    单元格.关联物品.能否拾起 = true;
			                    单元格.关联物品.isActive = false;
			                    if (尝试收集物品(单元格.关联物品)) {
			                        单元格.类型 = null;
			                        单元格.关联物品 = null;
			                        绘制();
			                        互动 = true;
			                    }
			                } else if (尝试收集物品(单元格.关联物品)) {
			                    单元格.类型 = null;
			                    单元格.关联物品 = null;
			                    更新光源地图();
			                    绘制();
			                    互动 = true;
			                } else if (
			                    单元格.关联物品?.类型 === "NPC" &&
			                    !NPC互动中
			                ) {
			                    单元格.关联物品.使用();
			                    NPC互动中 = true;
			                    互动 = true;
			                    break;
			                } else if (单元格.关联物品?.尝试互动?.()) {
			            互动 = true;
			            break;
			        }
			            }
			        }
			    }
			    if (互动) {
			        更新装备显示();
			        return;
			    }
			    const 武器 = Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			        玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			    )
			        .filter((v) => v != null)
			        .filter(
			            (i) =>
			                i?.类型 === "武器" &&
			                i?.堆叠数量 > 0 &&
			                i?.自定义数据.get("冷却剩余") == 0 && 
			                i?.自定义数据.get("攻击目标数") > 0 && 
			                !(i instanceof 充能魔杖)
			        );
			    if (武器) {
			        let maxCount = 0;
			        let maxRange = 0; 
			        let 目标怪物,
			            目标路径 = [];
			        let 目标路径有效 = []; 
			        武器.forEach((可用武器) => {
			            maxCount = Math.max(
			                maxCount,
			                可用武器.自定义数据.get("攻击目标数")
			            );
			            if (!(可用武器 instanceof 金币手枪))
			                maxRange = Math.max(
			                    maxRange,
			                    可用武器.最终攻击范围
			                ); 
			        });
			        let { 怪物, 路径 } = 获取周围怪物(maxCount, maxRange);
			        if (怪物 && 路径) {
			            武器.forEach((可用武器) => {
			                路径 = 路径.filter(
			                    (item, index) => 怪物[index].当前生命值 > 0
			                );
			                怪物 = 怪物.filter((item) => item.当前生命值 > 0);
			                目标路径有效 = []; 
			                目标怪物 = []; 
			
			                路径.forEach((item, index) => {
			                    if (item.length <= 可用武器.最终攻击范围 + 1) {
			                        目标路径有效.push(item);
			                        目标怪物.push(怪物[index]);
			                    }
			                });
			                if (目标怪物.length > 0) {
			                    if (可用武器.使用(目标怪物, 目标路径有效,玩家)) {
			                        Array.from(
			                            { length: 装备栏每页装备数 },
			                            (_, i) =>
			                                玩家装备.get(
			                                    当前装备页 * 装备栏每页装备数 +
			                                        i +
			                                        1
			                                )
			                        )
			                            .filter((v) => v != null)
			                            .forEach((装备) => {
			                                if (
			                                    装备 instanceof 宠物 &&
			                                    !装备.自定义数据.get("休眠中")
			                                ) {
			                                    装备.当玩家攻击(目标怪物); 
			                                }
			                            });
			                        
			                        
			                        互动 = true;
			                    }
			                }
			            });
			        }
			    }
			
			    if (!互动) 显示通知("周围没有可互动物体了...", "信息");
			    更新装备显示();
			    return;
			}
			
			
			function 克隆物品(原始物品, 附加配置 = {}) {
			    if (!原始物品 || typeof 原始物品.constructor !== 'function') {
			        console.error("无法克隆无效的物品:", 原始物品);
			        return 原始物品;
			    }
			
			    // 1. 从原始物品构建一个基础配置对象
			    const 基础配置 = {
			        类型: 原始物品.类型,
			        名称: 原始物品.名称,
			        图标: 原始物品.图标,
			        品质: 原始物品.品质,
			        堆叠数量: 原始物品.堆叠数量,
			        最大堆叠数量: 原始物品.最大堆叠数量,
			        颜色索引: 原始物品.颜色索引,
			        强化: 原始物品.强化,
			        能否拾起: 原始物品.能否拾起,
			        是否正常物品: 原始物品.是否正常物品,
			        是否隐藏: 原始物品.是否隐藏,
			        是否为隐藏物品: 原始物品.是否为隐藏物品,
			        效果描述: 原始物品.效果描述,
			        阻碍怪物: 原始物品.阻碍怪物,
			        数据: 原始物品.自定义数据 ? Object.fromEntries(原始物品.自定义数据) : {}
			    };
			
			    // 2. 将基础配置与用户传入的附加配置深度合并
			    const 最终配置 = { ...基础配置, ...附加配置 };
			    if (基础配置.数据 && 附加配置.数据) {
			        最终配置.数据 = { ...基础配置.数据, ...附加配置.数据 };
			    }
			
			    // 3. 使用原始物品的构造函数和最终配置创建新实例
			    const 克隆实例 = new 原始物品.constructor(最终配置);
			    
			for (const 键 in 原始物品) {
			        if (Object.hasOwnProperty.call(原始物品, 键)) {
			            if (
			                键 === "自定义数据" &&
			                原始物品.自定义数据 instanceof Map
			            ) {
			                克隆实例.自定义数据 = new Map(原始物品.自定义数据);
			            } else {
			                克隆实例[键] = 原始物品[键];
			            }
			        }
			    }
			
			    克隆实例.isActive = false;
			    克隆实例.显示元素 = null;
			    克隆实例.已装备 = false;
			    克隆实例.装备槽位 = null;
			    克隆实例.唯一标识 = Symbol(
			        Date.now().toString() + prng().toString()
			    );
			
			    return 克隆实例;
			}
			
			function 获取周围怪物(数量 = 1, 范围 = null, 原位置 = 玩家) {
			    if (当前天气效果.includes("诡魅") && 范围 > 2) {
			        // 假设范围>1表示远程
			        范围 = 2;
			    }
			    let 攻击范围 = 0;
			    if (范围 === null) {
			        const 当前武器 = Array.from(
			            { length: 装备栏每页装备数 },
			            (_, i) =>
			                玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			        )
			            .filter((v) => v != null)
			            .find(
			                (i) =>
			                    i.类型 === "武器" &&
			                    i.堆叠数量 > 0 &&
			                    i.自定义数据.get("冷却剩余") === 0
			            );
			        if (!当前武器) return { 路径: null, 怪物: null };
			        攻击范围 = 当前武器.最终攻击范围;
			    } else {
			        攻击范围 = 范围;
			    }
			    const 候选怪物 = [];
			    for (let dx = -攻击范围; dx <= 攻击范围; dx++) {
			        for (let dy = -攻击范围; dy <= 攻击范围; dy++) {
			            const x = 原位置.x + dx;
			            const y = 原位置.y + dy;
			            if (
			                x >= 0 &&
			                x < 地牢大小 &&
			                y >= 0 &&
			                y < 地牢大小 &&
			                地牢[y][x].关联怪物?.状态 === 怪物状态.活跃 &&
			                怪物状态表.get(地牢[y][x].关联怪物)?.类型 !== "魅惑"
			            ) {
			                const 怪物实例 = 地牢[y][x].关联怪物;
			                if (检查视线(原位置.x, 原位置.y, x, y, 攻击范围)) {
			                    候选怪物.push({
			                        怪物: 怪物实例,
			                        距离: Math.abs(dx) + Math.abs(dy),
			                        x: x,
			                        y: y,
			                    });
			                }
			            }
			        }
			    }
			    const 排序后 = 候选怪物.sort((a, b) => a.距离 - b.距离);
			    const 结果 = 排序后.slice(0, 数量);
			    const 路径数组 = [];
			    const 怪物数组 = [];
			    for (const item of 结果) {
			        let 路径 = [];
			        if (
			            快速直线检查(原位置.x, 原位置.y, item.x, item.y, 攻击范围)
			        ) {
			            路径 = 获取直线路径(原位置.x, 原位置.y, item.x, item.y);
			        } else {
			            路径 = 广度优先搜索路径(
			                原位置.x,
			                原位置.y,
			                item.x,
			                item.y,
			                攻击范围,
			                true
			            );
			        }
			        if (路径) {
			            路径.shift();
			            路径数组.push(路径);
			            怪物数组.push(item.怪物);
			        }
			    }
			    return 路径数组.length > 0
			        ? { 路径: 路径数组, 怪物: 怪物数组 }
			        : { 路径: null, 怪物: null };
			}
			function 获取直线路径(startX, startY, endX, endY) {
			    const path = [];
			    let currentX = startX;
			    let currentY = startY;
			    const dx = endX - startX;
			    const dy = endY - startY;
			    const steps = Math.max(Math.abs(dx), Math.abs(dy));
			    const xInc = dx / steps;
			    const yInc = dy / steps;
			    for (let i = 0; i <= steps; i++) {
			        const x = Math.round(currentX);
			        const y = Math.round(currentY);
			        path.push({ x: x, y: y });
			        currentX += xInc;
			        currentY += yInc;
			    }
			    return path;
			}
			// BFS U ARE MY GOD
			function 广度优先搜索路径(
			    startX,
			    startY,
			    endX,
			    endY,
			    maxSteps,
			    返回路径 = false,
			    不进入未知房间 = false,
			    路径必须可用 = false,
				避开楼梯 = false
			) {
			    const 最小步数记录 = new Array(地牢大小)
			        .fill()
			        .map(() => new Array(地牢大小).fill(Infinity));
			    const 前驱节点 = new Array(地牢大小)
			        .fill(null)
			        .map(() => new Array(地牢大小).fill(null));
			    const 队列 = [[startX, startY, 0]];
			    最小步数记录[startY][startX] = 0;
			    const 已访问 = new Set([`${startX},${startY}`]);
			    const 方向 = [
			        { dx: 0, dy: -1, 当前墙: "上", 反方向墙: "下" },
			        { dx: 0, dy: 1, 当前墙: "下", 反方向墙: "上" },
			        { dx: -1, dy: 0, 当前墙: "左", 反方向墙: "右" },
			        { dx: 1, dy: 0, 当前墙: "右", 反方向墙: "左" },
			    ];
			    while (队列.length > 0) {
			        const [x, y, step] = 队列.shift();
			        if (x === endX && y === endY) {
			            if (返回路径) {
			                return 从终点回溯路径(前驱节点, endX, endY);
			            }
			            return true;
			        }
			        if (step >= maxSteps) continue;
			        for (const dir of 方向) {
			            const 新X = x + dir.dx;
			            const 新Y = y + dir.dy;
			            const 新步数 = step + 1;
			            if (
			                新X < 0 ||
			                新X >= 地牢大小 ||
			                新Y < 0 ||
			                新Y >= 地牢大小
			            )
			                continue;
			            if (新步数 >= 最小步数记录[新Y][新X]) continue;
			            const 当前单元格 = 地牢[y][x];
			            const 下一单元格 = 地牢[新Y][新X];
			            if (
			                当前单元格.墙壁[dir.当前墙] ||
			                下一单元格.墙壁[dir.反方向墙]
			            )
			                continue;
			
			            const 移动方向 = getMoveDirection(x, y, 新X, 新Y);
			            if (
			                下一单元格.isOneWay &&
			                移动方向 !== 下一单元格.oneWayAllowedDirection
			            ) {
			                continue;
			            }

						if (避开楼梯 && (下一单元格.类型 === 单元格类型.楼梯下楼 || 下一单元格.类型 === 单元格类型.楼梯上楼)) {
							continue;
						}
			
			            if (
			                [单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                    下一单元格.背景类型
			                ) || (下一单元格.关联物品?.类型 === '开关砖' && 下一单元格.关联物品?.阻碍怪物)
			            )
			                continue;
			            if (不进入未知房间&&(!已访问房间.has(房间地图[新Y][新X]) && 房间地图[新Y][新X]!==-1)) continue;
			            if (路径必须可用&&!位置是否可用(新X,新Y,false,true)) continue;
			            
			            最小步数记录[新Y][新X] = 新步数;
			            前驱节点[新Y][新X] = { x: x, y: y };
			            队列.push([新X, 新Y, 新步数]);
			        }
			    }
			    return 返回路径 ? [] : false;
			}
			function A星寻路(起始X, 起始Y, 结束X, 结束Y, 最大步数) {
    const 开放列表 = [{ x: 起始X, y: 起始Y, g: 0, h: 0, f: 0, parent: null }];
    const 已关闭集合 = new Set();
    const 方向 = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];

    const 计算启发值 = (x, y) => Math.abs(x - 结束X) + Math.abs(y - 结束Y);

    while (开放列表.length > 0) {
        开放列表.sort((a, b) => a.f - b.f);
        const 当前节点 = 开放列表.shift();

        if (当前节点.x === 结束X && 当前节点.y === 结束Y) {
            const 路径 = [];
            let temp = 当前节点;
            while (temp) {
                路径.push({ x: temp.x, y: temp.y });
                temp = temp.parent;
            }
            return 路径.reverse();
        }

        已关闭集合.add(`${当前节点.x},${当前节点.y}`);

        if (当前节点.g >= 最大步数) continue;

        for (const dir of 方向) {
            const 新X = 当前节点.x + dir.dx;
            const 新Y = 当前节点.y + dir.dy;
            const 邻居键 = `${新X},${新Y}`;

            if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小 || 已关闭集合.has(邻居键)) continue;
            
            const 邻居单元格 = 地牢[新Y]?.[新X];
            if (!邻居单元格 || !快速检查相邻移动(当前节点.x, 当前节点.y, 新X, 新Y)) continue;
            if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(邻居单元格.背景类型) || (邻居单元格.关联物品?.类型 === '开关砖' && 邻居单元格.关联物品?.阻碍怪物)) continue;
            const 移动方向 = getMoveDirection(
                    当前节点.x,
                    当前节点.y,
                    新X,
                    新Y
                );
                if (
                    邻居单元格.isOneWay &&
                    移动方向 !== 邻居单元格.oneWayAllowedDirection
                )
                   continue;


            const g分数 = 当前节点.g + 1;
            let 开放列表中的邻居 = 开放列表.find(node => node.x === 新X && node.y === 新Y);

            if (!开放列表中的邻居 || g分数 < 开放列表中的邻居.g) {
                const h分数 = 计算启发值(新X, 新Y);
                if (开放列表中的邻居) {
                    开放列表中的邻居.g = g分数;
                    开放列表中的邻居.f = g分数 + h分数;
                    开放列表中的邻居.parent = 当前节点;
                } else {
                    开放列表.push({ x: 新X, y: 新Y, g: g分数, h: h分数, f: g分数 + h分数, parent: 当前节点 });
                }
            }
        }
    }
    return null;
}
			function 从终点回溯路径(前驱节点, endX, endY) {
			    const 路径 = [];
			    let currentX = endX;
			    let currentY = endY;
			    while (前驱节点[currentY][currentX] !== null) {
			        路径.push({ x: currentX, y: currentY });
			        const tempX = 前驱节点[currentY][currentX].x;
			        const tempY = 前驱节点[currentY][currentX].y;
			        currentX = tempX;
			        currentY = tempY;
			    }
			    路径.push({ x: currentX, y: currentY });
			    return 路径.reverse();
			}
			function 检查视线(startX, startY, endX, endY, maxSteps = Infinity) {
			    const 曼哈顿距离 =
			        Math.abs(endX - startX) + Math.abs(endY - startY);
			    if (曼哈顿距离 > maxSteps) return false;
			    const 目标单元格 = 地牢[endY]?.[endX];
    if (目标单元格?.关联物品 instanceof 烟雾) {
        if (startX !== endX || startY !== endY) {
            return false;
        }
    }
			    if (startX === endX && startY === endY) return true;
			    if (快速直线检查(startX, startY, endX, endY, maxSteps)) {
			        return true;
			    }
			    return 广度优先搜索路径(startX, startY, endX, endY, maxSteps);
			}
			function 快速直线检查(startX, startY, endX, endY, maxSteps,无视物品=false) {
			    const 曼哈顿距离 =
			        Math.abs(endX - startX) + Math.abs(endY - startY);
			    if (曼哈顿距离 > maxSteps) return false;
			    if (startX === endX && startY === endY) return true;
			
			    const path = 获取直线格子(startX, startY, endX, endY);
			    if (path.length -1 > maxSteps) return false;
			
			    
			    for(let i=1; i < path.length; i++) {
			        const prev = path[i-1];
			        const curr = path[i];
			
			        if (curr.x < 0 || curr.x >= 地牢大小 || curr.y < 0 || curr.y >= 地牢大小) return false;
			        
			        const 单元格 = 地牢[curr.y][curr.x];
			
			        if (([单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) || (单元格.关联物品?.类型 === '开关砖' && 单元格.关联物品?.阻碍怪物)) &&!无视物品) return false;
			
			        if ((Array.from(玩家装备.values()).some(item => item instanceof 潜行靴子) && 单元格.关联物品) && !(玩家.x === startX && 玩家.y === startY)) return false;
			
			        const 移动方向 = getMoveDirection(prev.x, prev.y, curr.x, curr.y);
			        if (单元格.isOneWay && 移动方向 !== 单元格.oneWayAllowedDirection) return false;
			
			        const dirs = [];
			        if (curr.x > prev.x) dirs.push("右");
			        else if (curr.x < prev.x) dirs.push("左");
			        
			        if (curr.y > prev.y) dirs.push("下");
			        else if (curr.y < prev.y) dirs.push("上");
			
			        for (const dir of dirs) {
			            const mapping = {
			                右: { 当前墙: "左", 反方向墙: "右" },
			                左: { 当前墙: "右", 反方向墙: "左" },
			                下: { 当前墙: "上", 反方向墙: "下" },
			                上: { 当前墙: "下", 反方向墙: "上" },
			            }[dir];
			            if (mapping && (地牢[curr.y][curr.x].墙壁[mapping.当前墙] || 地牢[prev.y][prev.x].墙壁[mapping.反方向墙])) {
			                return false;
			            }
			        }
			    }
			    return true;
			}
			function 获取移动方向(fromX, fromY, toX, toY) {
			    const dx = toX - fromX;
			    const dy = toY - fromY;
			    const 主要方向 =
			        Math.abs(dx) > Math.abs(dy)
			            ? dx > 0
			                ? "右"
			                : "左"
			            : dy > 0
			            ? "下"
			            : "上";
			    return {
			        右: { 当前墙: "右", 反方向墙: "左" },
			        左: { 当前墙: "左", 反方向墙: "右" },
			        下: { 当前墙: "下", 反方向墙: "上" },
			        上: { 当前墙: "上", 反方向墙: "下" },
			    }[主要方向];
			}
			
			function 计划显示格子特效(路径数组, 颜色 = "FF0000", 间隔 = 100) {
			    // 增加颜色参数，默认为红色
			    if (长按移动) {
			        //return;
			    }
			    const 可见路径 = 路径数组.filter((节点) => {
			        return (
			            节点.x >= 视口偏移X &&
			            节点.x < 视口偏移X + 相机显示边长 &&
			            节点.y >= 视口偏移Y &&
			            节点.y < 视口偏移Y + 相机显示边长
			        );
			    });
			    if (可见路径.length > 0) {
			        相机锁定 = true;
			        待显示格子特效队列.push({
			            路径: 可见路径,
			            颜色: 颜色,
			            间隔: 间隔,
			        });
			    }
			}
			function 显示格子特效(路径, 颜色 = "FF0000", 间隔 = 100) {
			    if (命令行模式开启) {
        const 画布Rect = canvas.getBoundingClientRect();
        const 特效容器 = document.getElementById("effectsContainer");
        路径.forEach((节点, index) => {
            if (!(节点.x >= 视口偏移X && 节点.x < 视口偏移X + 相机显示边长 && 节点.y >= 视口偏移Y && 节点.y < 视口偏移Y + 相机显示边长)) return;
            const 屏幕X = (节点.x - 当前相机X) * 单元格大小;
            const 屏幕Y = (节点.y - 当前相机Y) * 单元格大小;
            const 特效 = document.createElement("div");
            特效.textContent = '▓';
            特效.style.cssText = `
                position: absolute;
                left: ${屏幕X + 画布Rect.left}px;
                top: ${屏幕Y + 画布Rect.top}px;
                width: ${单元格大小}px;
                height: ${单元格大小}px;
                color: #${颜色};
                font-family: 'Courier New', monospace;
                font-size: ${单元格大小}px;
                line-height: ${单元格大小}px;
                text-align: center;
                opacity: 0.7;
                pointer-events: none;
                z-index: 998;
                transition: opacity 0.2s linear;
            `;
            const worldX = 节点.x;
            const worldY = 节点.y;
            const effectData = { element: 特效, worldX: worldX, worldY: worldY };
            特效容器.appendChild(特效);
            活动DOM特效.push(effectData);
            setTimeout(() => {
                特效.style.opacity = '0';
                setTimeout(() => {
                    特效.remove();
                    活动DOM特效 = 活动DOM特效.filter(item => item.element !== 特效);
                }, 200);
            }, 100 + index * 间隔);
        });
        return;
    }
			    const 画布Rect = canvas.getBoundingClientRect();
			    const 特效容器 = document.getElementById("effectsContainer");
			
			    路径.forEach((节点, index) => {
			        if (!(节点.x >= 视口偏移X &&
			            节点.x < 视口偏移X + 相机显示边长 &&
			            节点.y >= 视口偏移Y &&
			            节点.y < 视口偏移Y + 相机显示边长)) return;
			        const 屏幕X = (节点.x - 当前相机X) * 单元格大小;
			        const 屏幕Y = (节点.y - 当前相机Y) * 单元格大小;
			
			        const 特效 = document.createElement("div");
			        特效.className = "攻击路径特效";
			
			        特效.style.cssText = `
			position: absolute;
			left: ${屏幕X + 画布Rect.left}px;
			top: ${屏幕Y + 画布Rect.top}px;
			width: ${单元格大小}px;
			height: ${单元格大小}px;
			background: radial-gradient(circle,
			    ${hexToRgba(颜色, 0)} 0%,
			    ${hexToRgba(颜色, 0.3)} 70%,
			    transparent 100%
			);
			opacity: 0.7;
			pointer-events: none;
			z-index: 998;
			
			        `;
			
			        const worldX = 节点.x;
			        const worldY = 节点.y;
			        const effectData = {
			            element: 特效,
			            worldX: worldX,
			            worldY: worldY,
			        };
			
			        特效容器.appendChild(特效);
			        活动DOM特效.push(effectData);
			
			        const removalDelay = 200 + index * 间隔;
			        setTimeout(function () {
			            特效.remove();
			
			            活动DOM特效 = 活动DOM特效.filter(
			                (item) => item.element !== 特效
			            );
			        }, removalDelay);
			    });
			}
			function 尝试进入特殊房间(x, y) {
			    const 房间ID = 房间地图[y][x];
			    if (房间ID === -1) return;
			    const 房间 = 房间列表.find(t=>t.id==房间ID);
			    if (
			        房间 &&
			        !房间.已连接 &&
			        房间?.类型?.slice(0, 2) === "隐藏"
			    ) {
			        连接特殊房间(房间);
			        生成墙壁();
			        const 待销毁戒指 = [];
			        玩家背包.forEach((item) => {
			            if (
			                item instanceof 寻宝戒指 &&
			                item.自定义数据.get("生效层数") === 当前层数
			            ) {
			                待销毁戒指.push(item.唯一标识);
			            }
			        });
			        待销毁戒指.forEach((id) => {
			            处理销毁物品(id, true);
			        });
			        移动玩家(0, 0);
			        绘制();
			    }
			}
			function 尝试执行吹动(实例, 移动计划, 已执行, 风向DX, 风向DY) {
			    if (已执行.has(实例)) return true;
			    if (!移动计划.has(实例)) return true;
			
			    const { 新X, 新Y, 旧X, 旧Y, 类型 } = 移动计划.get(实例);
			
			    if (
			        新X < 0 ||
			        新X >= 地牢大小 ||
			        新Y < 0 ||
			        新Y >= 地牢大小 ||
			        !检查直线移动可行性(旧X, 旧Y, 新X, 新Y, true) ||
			        [单元格类型.墙壁, 单元格类型.上锁的门].includes(
			            地牢[新Y][新X]?.背景类型
			        )
			    ) {
			        已执行.add(实例);
			        return false;
			    }
			
			    const 占用单元格 = 地牢[新Y]?.[新X];
			    const 占用者 = 占用单元格?.关联物品 || 占用单元格?.关联怪物;
			
			    if (占用者) {
			        const 不可移动类型列表 = ["楼梯", "地形", "祭坛", "折跃门"];
			        const 物品是否不可移动 =
			            占用者 instanceof 物品 &&
			            不可移动类型列表.includes(占用者.类型);
			
			        if (物品是否不可移动) {
			            已执行.add(实例);
			            if (占用者 instanceof 火焰物品) {
			                if (地牢[旧Y]?.[旧X]?.关联物品 === 实例) {
			                    地牢[旧Y][旧X].关联物品 = null;
			                    if (地牢[旧Y]?.[旧X]?.类型 === 单元格类型.物品)
			                        地牢[旧Y][旧X].类型 = null;
			                    地牢[旧Y][旧X].颜色索引 = 颜色表.length;
			                }
			                添加日志(
			                    `${实例.名称} 被吹向火焰，烧毁了！`,
			                    "信息"
			                );
			                return true;
			            }
			            return false;
			        }
			        if (移动计划.has(占用者)&&!已执行.has(占用者)) {
			            const 占用者移动成功 = 尝试执行吹动(
			                占用者,
			                移动计划,
			                已执行,
			                风向DX,
			                风向DY
			            );
			            if (!占用者移动成功) {
			                已执行.add(实例);
			                return false;
			            }
			        } else {
			            已执行.add(实例);
			            return false;
			        }
			    }
			
			    try {
			        if (类型 === "物品") {
			            if (地牢[旧Y]?.[旧X]?.关联物品 === 实例) {
			                地牢[旧Y][旧X].关联物品 = null;
			                if (地牢[旧Y]?.[旧X]?.类型 === 单元格类型.物品)
			                    地牢[旧Y][旧X].类型 = null;
			                地牢[旧Y][旧X].颜色索引 = 颜色表.length;
			            }
			
			            实例.x = 新X;
			            实例.y = 新Y;
			
			            地牢[新Y][新X].类型 = 单元格类型.物品;
			            地牢[新Y][新X].关联物品 = 实例;
			            地牢[新Y][新X].颜色索引 = 实例.颜色索引;
			
			            添加日志(
			                `${实例.名称} 被大风吹到了 (${新X},${新Y})！`,
			                "信息"
			            );
			            已执行.add(实例);
			             return true;
			        } else if (类型 === "怪物") {
			            const 旧X = 实例.x;
			            const 旧Y = 实例.y;
			            实例.恢复背景类型();
			            实例.x = 新X;
			            实例.y = 新Y;
			            实例.保存新位置类型(新X, 新Y);
			            地牢[新Y][新X].类型 = 单元格类型.怪物;
			            地牢[新Y][新X].关联怪物 = 实例;
			            添加日志(
			                `${实例.类型} 被大风吹到了 (${新X},${新Y})！`,
			                "信息"
			            );
			            实例.处理地形效果();
			            怪物动画状态.set(实例, {
			    旧逻辑X: 旧X,
			    旧逻辑Y: 旧Y,
			    目标逻辑X: 新X,
			    目标逻辑Y: 新Y,
			    视觉X: 旧X,
			    视觉Y: 旧Y,
			    动画开始时间: Date.now(),
			    正在动画: true,
			});
			        }
			        已执行.add(实例);
			        return true;
			    } catch (错误) {
			        console.error(
			            `执行移动实例 ${
			                实例?.名称 || "未知"
			            } 到 (${新X}, ${新Y}) 时出错: `,
			            错误
			        );
			        已执行.add(实例);
			        return false;
			    }
			}
			
			function 处理大风效果() {
			    const 方向列表 = [
			        { dx: 0, dy: -1 },
			        { dx: 1, dy: 0 },
			        { dx: 0, dy: 1 },
			        { dx: -1, dy: 0 },
			    ];
			    const { dx: 风向DX, dy: 风向DY } =
			        方向列表[Math.floor(prng() * 4)];
			
			    const 画布 = document.getElementById("dungeonCanvas");
			    const 画布Rect = 画布.getBoundingClientRect();
			    const 视口起始X = Math.floor(当前相机X);
			    const 视口起始Y = Math.floor(当前相机Y);
			    const 视口宽度格 = Math.ceil(画布Rect.width / 单元格大小);
			    const 视口高度格 = Math.ceil(画布Rect.height / 单元格大小);
			    const 视口结束X = Math.min(
			        地牢大小 - 1,
			        视口起始X + 视口宽度格
			    );
			    const 视口结束Y = Math.min(
			        地牢大小 - 1,
			        视口起始Y + 视口高度格
			    );
			
			    const 移动计划 = new Map();
			    const 不可移动类型列表 = ["楼梯", "地形", "祭坛", "折跃门"];
			
			    for (let y = 视口起始Y; y <= 视口结束Y; y++) {
			        for (let x = 视口起始X; x <= 视口结束X; x++) {
			            const 物品 = 地牢[y]?.[x]?.关联物品;
			            if (
			                物品 &&
			                !不可移动类型列表.includes(物品.类型) &&
			                (已访问房间.has(房间地图[y][x]) ||
			                    房间地图[y][x] === -1)
			            ) {
			                if (prng() < 大风吹动概率) {
			                    const 新X = x + 风向DX;
			                    const 新Y = y + 风向DY;
			
			                    if (
			                        新X >= 0 &&
			                        新X < 地牢大小 &&
			                        新Y >= 0 &&
			                        新Y < 地牢大小 &&
			                        ![
			                            单元格类型.墙壁,
			                            单元格类型.上锁的门,
			                        ].includes(地牢[新Y][新X]?.背景类型) &&
			                        检查直线移动可行性(x, y, 新X, 新Y, true) &&
			                        (已访问房间.has(房间地图[y][x]) ||
			                            房间地图[y][x] === -1) &&
			                        (!(物品 instanceof 隐形毒气陷阱) ||
			                        !物品.自定义数据.get('已触发'))
			                    ) {
			                        移动计划.set(物品, {
			                            新X,
			                            新Y,
			                            旧X: x,
			                            旧Y: y,
			                            类型: "物品",
			                        });
			                    }
			                }
			            }
			        }
			    }
			
			    所有怪物.forEach((怪物) => {
			        const { x, y } = 怪物;
			        if (
			            怪物.状态 === 怪物状态.活跃 &&
			            x >= 视口起始X &&
			            x <= 视口结束X &&
			            y >= 视口起始Y &&
			            y <= 视口结束Y
			        ) {
			            if (prng() < 大风吹动概率) {
			                const 新X = x + 风向DX;
			                const 新Y = y + 风向DY;
			
			                if (
			                    新X >= 0 &&
			                    新X < 地牢大小 &&
			                    新Y >= 0 &&
			                    新Y < 地牢大小 &&
			                    ![
			                        单元格类型.墙壁,
			                        单元格类型.上锁的门,
			                    ].includes(地牢[新Y][新X]?.背景类型) &&
			                    检查直线移动可行性(x, y, 新X, 新Y, true)
			                ) {
			                    移动计划.set(怪物, {
			                        新X,
			                        新Y,
			                        旧X: x,
			                        旧Y: y,
			                        类型: "怪物",
			                    });
			                }
			            }
			        }
			    });
			
			    if (
			        玩家.x >= 视口起始X &&
			        玩家.x <= 视口结束X &&
			        玩家.y >= 视口起始Y &&
			        玩家.y <= 视口结束Y
			    ) {
			        if (prng() < 大风吹动概率) {
			            const 新X = 玩家.x + 风向DX;
			            const 新Y = 玩家.y + 风向DY;
			
			            if (
			                新X >= 0 &&
			                新X < 地牢大小 &&
			                新Y >= 0 &&
			                新Y < 地牢大小 &&
			                ![单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                    地牢[新Y][新X]?.背景类型
			                ) &&
			                检查直线移动可行性(玩家.x, 玩家.y, 新X, 新Y, true)
			            ) {
			                移动计划.set(玩家, {
			                    新X,
			                    新Y,
			                    旧X: 玩家.x,
			                    旧Y: 玩家.y,
			                    类型: "玩家",
			                });
			            }
			        }
			    }
			
			    const 已执行 = new Set();
			    const 待处理实例列表 = Array.from(移动计划.keys());
			
			    待处理实例列表
			        .filter((实例) => 实例 instanceof 物品)
			        .forEach((物品实例) => {
			            尝试执行吹动(
			                物品实例,
			                移动计划,
			                已执行,
			                风向DX,
			                风向DY
			            );
			        });
			
			    待处理实例列表
			        .filter((实例) => 实例 instanceof 怪物)
			        .forEach((怪物实例) => {
			            尝试执行吹动(
			                怪物实例,
			                移动计划,
			                已执行,
			                风向DX,
			                风向DY
			            );
			        });
			
			    //let 玩家被吹动 = false;
			    let 玩家目标X = 玩家.x;
			    let 玩家目标Y = 玩家.y;
			
			    if (移动计划.has(玩家) && !已执行.has(玩家)) {
			        const { 新X, 新Y } = 移动计划.get(玩家);
			
			        const 最终目标单元格 = 地牢[新Y]?.[新X];
			        const 最终占用者 = 最终目标单元格?.关联物品;
			        const 最终占用者不可移动 =
			            最终占用者 &&
			            (不可移动类型列表.includes(最终占用者.类型) ||
			                最终占用者.能否拾起 === false);
			
			        if (!最终占用者不可移动) {
			            玩家动画状态 = {
			正在动画: true,
			旧逻辑X: 玩家.x,
			旧逻辑Y: 玩家.y,
			目标逻辑X: 新X,
			目标逻辑Y: 新Y,
			视觉X: 玩家.x,
			视觉Y: 玩家.y,
			动画开始时间: Date.now()
			        };
			            let 旧X = 玩家.x
			            let 旧Y = 玩家.y
			            玩家.x = 新X;
			            玩家.y = 新Y;
			            //玩家被吹动 = true;
			            玩家目标X = 新X;
			            玩家目标Y = 新Y;
			            处理玩家着陆效果(旧X, 旧Y, 玩家目标X, 玩家目标Y);
			            添加日志("你被大风吹动了！", "警告");
			            已执行.add(玩家);
			        } else {
			            添加日志("你试图被风吹动，但撞到了障碍物！", "信息");
			        }
			    }
			
			    更新物体指示器();
			    所有怪物.forEach((m) => m.绘制血条());
			}
			function 开始挑战(房间实例) {
			    if (
			        !房间实例 ||
			        房间实例.类型 !== "挑战房间" ||
			        !房间实例.挑战状态 ||
			        房间实例.挑战状态.进行中 ||
			        房间实例.挑战状态.已完成
			    ) {
			        return;
			    }
			
			    显示通知(
			        `挑战开始于房间 ${房间实例.id}！门已封锁！`,
			        "警告",
			        true,
			        3000
			    );
			
			    房间实例.挑战状态.进行中 = true;
			    房间实例.挑战状态.当前波次 = 0;
			    房间实例.挑战状态.波次内怪物 = [];
			    房间实例.挑战状态.原始门数据 = [];
			
			    // 封锁门
			    房间实例.门.forEach((门坐标) => {
			        const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
			        if (
			            门单元格 &&
			            (门单元格.背景类型 === 单元格类型.门 ||
			                门单元格.背景类型 === 单元格类型.上锁的门)
			        ) {
			            房间实例.挑战状态.原始门数据.push({
			                x: 门坐标.x,
			                y: 门坐标.y,
			                原类型: 门单元格.背景类型,
			                原标识: 门单元格.标识, // 保存门实例的标识
			                原颜色索引: 门单元格.颜色索引,
			                原钥匙ID: 门单元格.钥匙ID,
			            });
			            门单元格.背景类型 = 单元格类型.墙壁;
			            门单元格.标识 = null; // 清除门标识，使其不再是功能性门
			            门单元格.颜色索引 = 颜色表.length; // 恢复默认墙壁颜色
			            门单元格.钥匙ID = null;
			            重置单元格(门坐标.x,门坐标.y)
			        }
			        // 同时处理配对门单元格（如果存在）
			        if (门单元格 && 门单元格.配对单元格位置) {
			            const 配对X = 门单元格.配对单元格位置.x;
			            const 配对Y = 门单元格.配对单元格位置.y;
			            const 配对单元格 = 地牢[配对Y]?.[配对X];
			            if (
			                配对单元格 &&
			                (配对单元格.背景类型 === 单元格类型.门 ||
			                    配对单元格.背景类型 === 单元格类型.上锁的门)
			            ) {
			                房间实例.挑战状态.原始门数据.push({
			                    x: 配对X,
			                    y: 配对Y,
			                    原类型: 配对单元格.背景类型,
			                    原标识: 配对单元格.标识,
			                    原颜色索引: 配对单元格.颜色索引,
			                    原钥匙ID: 配对单元格.钥匙ID,
			                });
			                配对单元格.背景类型 = 单元格类型.墙壁;
			                配对单元格.标识 = null;
			                配对单元格.颜色索引 = 颜色表.length;
			                配对单元格.钥匙ID = null;
			                重置单元格(配对X,配对Y)
			            }
			        }
			    });
			
			    生成墙壁(); // 更新墙壁连接信息，确保封锁效果
			    绘制(); // 立即重绘以显示锁住的门
			
			    刷新挑战房间下一波(房间实例);
			}
			
			function 刷新挑战房间下一波(房间实例) {
			    if (!房间实例.挑战状态.进行中) return;
			
			    房间实例.挑战状态.当前波次++;
			    if (房间实例.挑战状态.当前波次 > 房间实例.挑战状态.总波次) {
			        完成挑战(房间实例);
			        return;
			    }
			
			    显示通知(
			        `房间 ${房间实例.id}：第 ${房间实例.挑战状态.当前波次} 波！`,
			        "警告",
			        true,
			        2000
			    );
			
			    房间实例.挑战状态.波次当前回合数 =
			        房间实例.挑战状态.波次最大回合数; // 重置计时器
			
			    const 怪物数量 =
			        1 +
			        Math.floor((房间实例.挑战状态?.挑战怪物层级 ?? 当前层数) / 3) +
			        Math.floor(房间实例.挑战状态.当前波次 / 2);
			    生成挑战房间怪物(房间实例, 怪物数量);
			    绘制(); // 确保新生成的怪物显示
			}
			
			function 生成挑战房间怪物(房间实例, 数量) {
			    let 候选怪物配置;
			    let 怪物层级 = 房间实例.挑战状态?.挑战怪物层级 ?? 当前层数;
			    const { monsters: allMonsters } = 获取所有可用的定义();

			    if (房间实例.挑战状态?.候选怪物池 && 房间实例.挑战状态.候选怪物池.length > 0) {
			        候选怪物配置 = allMonsters.filter(def => 房间实例.挑战状态.候选怪物池.includes(def.类.name));
			        if (候选怪物配置.length === 0) {
			            console.warn(`挑战房间 ${房间实例.id} 的自定义怪物池无效或为空，回退到默认怪物池。`);
			            const 挑战怪物池 = [];
			            for (let i = 0; i <= 怪物层级; i++) {
			                if (怪物引入计划.has(i)) {
			                    怪物引入计划.get(i).forEach(怪物定义 => {
			                        if (!挑战怪物池.some(m => m.类.name === 怪物定义.类.name)) {
			                            挑战怪物池.push(怪物定义);
			                        }
			                    });
			                }
			            }
			            候选怪物配置 = 挑战怪物池;
			        } else {
			            怪物层级 = 3;
			        }
			    } else {
			        const 挑战怪物池 = [];
			        for (let i = 0; i <= 怪物层级; i++) {
			            if (怪物引入计划.has(i)) {
			                怪物引入计划.get(i).forEach(怪物定义 => {
			                    if (!挑战怪物池.some(m => m.类.name === 怪物定义.类.name)) {
			                        挑战怪物池.push(怪物定义);
			                    }
			                });
			            }
			        }
			        候选怪物配置 = 挑战怪物池;
			    }

			    const 最终候选怪物 = 候选怪物配置;

			    if (最终候选怪物.length === 0) {
			        console.warn(`挑战房间 ${房间实例.id} 在层数 ${怪物层级} 无法找到合适的怪物生成。`);
			        return;
			    }

			    for (let i = 0; i < 数量; i++) {
			        let 选中配置;
			        if (最终候选怪物[0].权重 !== undefined) {
			            const 总权重 = 最终候选怪物.reduce((sum, m) => sum + m.权重, 0);
			            let 随机值 = prng() * 总权重;
			            选中配置 = 最终候选怪物[0];
			            for (const m of 最终候选怪物) {
			                if (随机值 <= m.权重) {
			                    选中配置 = m;
			                    break;
			                }
			                随机值 -= m.权重;
			            }
			        } else {
			            选中配置 = 最终候选怪物[Math.floor(prng() * 最终候选怪物.length)];
			        }
			
			        let 放置成功 = false;
			        for (let 尝试次数 = 0; 尝试次数 < 20; 尝试次数++) {
			            const x = 房间实例.x + Math.floor(prng() * 房间实例.w);
			            const y = 房间实例.y + Math.floor(prng() * 房间实例.h);
			
			            if (位置是否可用(x, y, true)) {
			                const 强化概率 = 0.15 + 怪物层级 * 0.025 + 房间实例.挑战状态.当前波次 * 0.06;
			                const 怪物基础攻击 = (选中配置.类.prototype.基础攻击力 || 3) + Math.floor(怪物层级 / 4) + Math.floor(房间实例.挑战状态.当前波次 / 2);
			                const 怪物基础生命 = (选中配置.类.prototype.基础生命值 || 20) + 怪物层级 * 2 + 房间实例.挑战状态.当前波次 * 4;
			
			                const 新怪物 = new 选中配置.类({
			                    x: x,
			                    y: y,
			                    房间ID: 房间实例.id,
			                    强化: prng() < 强化概率,
			                    状态: 怪物状态.活跃,
			                    基础攻击力: 怪物基础攻击,
			                    基础生命值: 怪物基础生命,
			                });
			
			                新怪物.基础生命值 = 怪物基础生命;
			                新怪物.当前生命值 = 新怪物.基础生命值;
			
			                放置怪物到单元格(新怪物, x, y);
			                房间实例.挑战状态.波次内怪物.push(新怪物);
			                新怪物.绘制血条();
			                放置成功 = true;
			                break;
			            }
			        }
			    }
			}
			function 完成挑战(房间实例) {
			    显示通知(
			        `房间 ${房间实例.id} 挑战成功！门已开启。`,
			        "成功",
			        true,
			        3000
			    );
			
			    房间实例.挑战状态.进行中 = false;
			    房间实例.挑战状态.已完成 = true;
			
			    // 恢复门
			    房间实例.挑战状态.原始门数据.forEach((门数据) => {
			        const 门单元格 = 地牢[门数据.y]?.[门数据.x];
			        if (门单元格) {
			            门单元格.背景类型 = 门数据.原类型;
			            门单元格.标识 = 门数据.原标识; // 恢复门实例的标识
			            门单元格.颜色索引 = 门数据.原颜色索引;
			            门单元格.钥匙ID = 门数据.原钥匙ID;
			            // 如果原先是上锁的门，并且门实例列表中有记录，则恢复门实例状态
			            if (
			                门数据.原类型 === 单元格类型.上锁的门 &&
			                门数据.原标识
			            ) {
			                const 门实例 = 门实例列表.get(门数据.原标识);
			                if (门实例) {
			                    门实例.类型 = "上锁的门";
			                    门实例.是否上锁 = true;
			                }
			            } else if (
			                门数据.原类型 === 单元格类型.门 &&
			                门数据.原标识
			            ) {
			                const 门实例 = 门实例列表.get(门数据.原标识);
			                if (门实例) {
			                    门实例.类型 = "门";
			                    门实例.是否上锁 = false;
			                }
			            }
			        }
			    });
			
			    生成墙壁(); // 重新生成墙壁以正确显示恢复的门
			    生成奖励(房间实例); // 在房间内生成奖励物品
			    绘制();
			}
			function 处理挑战失败(房间实例) {
			    if (
			        !房间实例 ||
			        房间实例.类型 !== "挑战房间" ||
			        !房间实例.挑战状态 ||
			        !房间实例.挑战状态.进行中
			    ) {
			        return;
			    }
			    显示通知(
			        `由于你的离开，房间 ${房间实例.id} 的挑战失败了！`,
			        "错误",
			        true,
			        3000
			    );
			    房间实例.挑战状态.进行中 = false;
			    房间实例.挑战状态.已完成 = true;
			
			    房间实例.挑战状态.原始门数据.forEach((门数据) => {
			        const 门单元格 = 地牢[门数据.y]?.[门数据.x];
			        if (门单元格) {
			            门单元格.背景类型 = 门数据.原类型;
			            门单元格.标识 = 门数据.原标识;
			            门单元格.颜色索引 = 门数据.原颜色索引;
			            门单元格.钥匙ID = 门数据.原钥匙ID;
			            if (
			                门数据.原类型 === 单元格类型.上锁的门 &&
			                门数据.原标识
			            ) {
			                const 门实例 = 门实例列表.get(门数据.原标识);
			                if (门实例) {
			                    门实例.类型 = "上锁的门";
			                    门实例.是否上锁 = true;
			                }
			            } else if (
			                门数据.原类型 === 单元格类型.门 &&
			                门数据.原标识
			            ) {
			                const 门实例 = 门实例列表.get(门数据.原标识);
			                if (门实例) {
			                    门实例.类型 = "门";
			                    门实例.是否上锁 = false;
			                }
			            }
			        }
			    });
			    生成墙壁();
			    绘制();
			}
			function 获取方向中文(dx, dy) {
			    if (dx === 1) return "东";
			    if (dx === -1) return "西";
			    if (dy === 1) return "南";
			    if (dy === -1) return "北";
			    return "原地";
			}
			let 宠物状态表 = new WeakMap();

function 处理宠物着陆效果(宠物, 旧X, 旧Y, 新X, 新Y) {
    const 目标单元格 = 地牢[新Y]?.[新X];
    if (!目标单元格 || !目标单元格.关联物品) return;

    const 物品 = 目标单元格.关联物品;

    if (物品 instanceof 蛛网 || 物品 instanceof 渔网陷阱) {
        new 状态效果("牵制", "#FFFFFF", "网", 物品.自定义数据.get("牵制回合"), null, null, 宠物);
        添加日志(`${宠物.名称} 被 ${物品.名称} 缠住了！`, "警告");
        物品.移除自身();
    } else if (物品 instanceof 火焰物品) {
        new 状态效果("火焰", 效果颜色编号编号映射[效果名称编号映射.火焰], "火", 物品.自定义数据.get("火焰持续"), null, null, 宠物, 物品.自定义数据.get("火焰强度"));
        添加日志(`${宠物.名称} 踩到了火焰，着火了！`, "警告");
    } else if (物品 instanceof 毒液物品) {
        new 状态效果("中毒", 效果颜色编号编号映射[效果名称编号映射.中毒], "☠️", 物品.自定义数据.get("中毒持续"), null, null, 宠物, 物品.自定义数据.get("中毒强度"));
        添加日志(`${宠物.名称} 踩到了毒液，中毒了！`, "警告");
    }
}
			function 处理回合逻辑() {
			    if (玩家属性.允许移动 > 0) return;
			    if (地牢.length !== 地牢大小) return;
			    
			    玩家总移动回合数++;
			    更新胜利条件显示();
			    处理传送带效果();
			    更新武器冷却();
			    
			    if (当前出战宠物列表.length > 0) {
					当前出战宠物列表.forEach(pet => {if(pet.层数==当前层数) pet.执行回合AI()});
				}
				if(当前天气效果.includes('深夜')) 更新光源地图();
				if(房间列表.find(item=>item.id==房间地图[玩家.y][玩家.x])?.类型==='黑暗房间') 更新光源地图();
			
			    if (跳过怪物回合剩余次数 > 0) {
			    跳过怪物回合剩余次数--;
			    添加日志(`时空扭曲，怪物们停止了行动... (剩余 ${跳过怪物回合剩余次数} 回合)`, "信息");
			} else {
			    处理怪物回合();
			}
			绘制小地图();
			    所有怪物.forEach((m) => {
			        m.绘制血条();
			    });
			    当前出战宠物列表.forEach(宠物 => {
        const 状态 = 宠物状态表.get(宠物);
        if (状态) {
            状态.更新状态();
        }
    });
			    处理天气效果();
			    更新物体指示器();
			    if (当前层数 === 5) {
			        const 怪物数量下限 = 10;
			        if (所有怪物.length < 怪物数量下限) {
			            const 需生成数量 = 怪物数量下限 - 所有怪物.length;
			            生成迷宫怪物(需生成数量);
			        }
			    }
			    const 能量条 = document.querySelector(".power-bar");
			    const 当前能量 = parseFloat(能量条?.style.width) || 100;
			    let 能量变化 = 0;
			    if(当前能量 < 70) 能量变化 += (Math.round(prng() * 5) / 5)/自定义全局设置.初始能量值*100;
			    if(玩家属性.能量流失 > 0) 能量变化 -= 玩家属性.能量流失/自定义全局设置.初始能量值*100;
			
			    if (能量条 && 能量变化 !== 0) {
			         能量条.style.width = `${Math.max(0, Math.min(100, 当前能量 + 能量变化))}%`;
			    }
			    玩家状态.forEach((item) => {
			        item.更新状态();
			    });
			    所有计时器.forEach((item) => {
			        if(item) item?.更新倒计时();
			    });
			    if (房间列表.length>0) {
			    房间列表.forEach(房间 => {
			        if (房间?.isSurvivalChallenge) {
			            const monstersInRoom = 所有怪物.filter(m => m.房间ID === 房间.id);
			            if (monstersInRoom.length === 0) {
			                 let 石碑 = null;
			                 for(const row of 地牢) {
			                    for(const cell of row) {
			                        if(cell.关联物品 instanceof 挑战石碑 && cell.关联物品.自定义数据.get("已激活") && 房间地图[cell.y][cell.x] === 房间.id) {
			                            石碑 = cell.关联物品;
			                            break;
			                        }
			                    }
			                    if(石碑) break;
			                 }
			                if(石碑) {
			                    石碑.刷新生存挑战下一波(房间);
			                }
			            }
			        }
			    });
			    }
			    Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			        玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			    )
			        .filter((v) => v != null)
			        .forEach((装备) => {
			            if (装备 instanceof 宠物) {
			                装备.恢复生命值();
			            }
			        });
				当前出战宠物列表.forEach(pet => pet.恢复生命值());
			    
			    更新界面状态();
			    if (房间列表.length>0) {
			    房间列表.forEach((房间) => {
			        if (
			            房间.类型 === "挑战房间" &&
			            房间.挑战状态 &&
			            房间.挑战状态.进行中
			        ) {
			            房间.挑战状态.波次当前回合数--;
			            房间.挑战状态.波次内怪物 =
			                房间.挑战状态.波次内怪物.filter(
			                    (m) => m.当前生命值 > 0 && 所有怪物.includes(m)
			                );
			
			            if (房间.挑战状态.波次内怪物.length === 0) {
			                添加日志(
			                    `房间 ${房间.id} 第 ${房间.挑战状态.当前波次} 波怪物已清除！`,
			                    "成功"
			                );
			                刷新挑战房间下一波(房间);
			            } else if (
			                房间.挑战状态.当前波次 < 房间.挑战状态.总波次
			            ) {
			                if (房间.挑战状态.波次当前回合数 <= 0) {
			                    添加日志(
			                        `房间 ${房间.id} 第 ${房间.挑战状态.当前波次} 波时间到！`,
			                        "警告"
			                    );
			                    刷新挑战房间下一波(房间);
			                }
			            }
			        }
			    });
			    }
			}
			function 处理玩家着陆效果(旧X, 旧Y, 新X, 新Y) {
			    const 目标单元格 = 地牢[新Y]?.[新X];
			    if (!目标单元格) return false;
			    const 旧玩家房间ID = 房间地图[旧Y][旧X];
			        if (旧玩家房间ID !== -1) {
			            const 旧玩家所在房间 = 房间列表.find(t=>t.id==旧玩家房间ID);
			            if (
			                旧玩家所在房间 &&
			                旧玩家所在房间.类型 === "挑战房间" &&
			                旧玩家所在房间.挑战状态 &&
			                旧玩家所在房间.挑战状态.进行中 &&
			                房间地图[新Y][新X] !== 旧玩家房间ID
			            ) {
			                处理挑战失败(旧玩家所在房间);
			            }
			        }
			    if (目标单元格.关联物品?.自定义数据?.get('隐藏')) {
			        目标单元格.关联物品.使用();
			        目标单元格.关联物品.自定义数据.set('隐藏', false);
			        显示通知(`你踩到了一个隐藏的 ${目标单元格.关联物品.名称}！`, "警告");
			    }
			
			    if (
			        目标单元格.关联物品 &&
			        目标单元格.类型 === 单元格类型.物品 &&
			        目标单元格.关联物品.能否拾起 &&
			        !目标单元格.关联物品.是否被丢弃
			    ) {
			        if (尝试收集物品(目标单元格.关联物品)) {
			            目标单元格.类型 = null;
			            目标单元格.关联物品 = null;
			        }
			    } else if (
			        [单元格类型.楼梯下楼, 单元格类型.楼梯上楼].includes(
			            目标单元格.类型
			        )
			    ) {
			        if (
			            是否为教程层 &&
			            目标单元格.类型 === 单元格类型.楼梯下楼
			        ) {
			            是否为教程层 = false;
			            所有怪物.forEach((m) => {
			                m.绘制血条(true);
			                if (地牢[m.y] && 地牢[m.y][m.x])
			                    地牢[m.y][m.x].关联怪物 = null;
			            });
			            所有怪物 = [];
			            document.getElementById("跳过教程按钮").style.display =
			                "none";
			            重置玩家状态();
			            切换楼层(0);
			            return true;
			        } else if (目标单元格.关联物品?.使用) {
			            目标单元格.关联物品.使用();
			            return true;
			        }
			    } else if (目标单元格.关联物品 instanceof 折跃门) {
			        if (目标单元格.关联物品.使用()) {
			            return true;
			        }
			    }
			
			    const 目标房间ID = 房间地图[新Y][新X];
			    处理单向房间(旧X, 旧Y, 新X, 新Y);
			    if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
			        moveQueue = [];
			        isAutoMoving = false;
			        已访问房间.add(目标房间ID);
			        const 能量条 = document.querySelector(".power-bar");
			        const 当前能量 = parseFloat(能量条?.style.width) || 100;
			        if (能量条)
			            能量条.style.width = `${Math.min(
			                100,
			                当前能量 + 1.5/自定义全局设置.初始能量值*100
			            )}%`;
			        const 进入的房间 = 房间列表.find(t=>t.id==目标房间ID);
			        if (
			            进入的房间 &&
			            进入的房间.类型 === "挑战房间" &&
			            进入的房间.挑战状态 &&
			            !进入的房间.挑战状态.进行中 &&
			            !进入的房间.挑战状态.已完成
			        ) {
			            开始挑战(进入的房间);
			        }
			        if (是否为教程层) {
			            教程阶段 = 目标房间ID;
			            教程提示已显示 = false;
			            显示教程提示();
			        }
			    }
			    更新洞穴视野();
			
			    if(地牢生成方式==='default') {尝试进入特殊房间(新X, 新Y);}
			    return false;
			}
			function 更新洞穴视野() {
    if (地牢生成方式 !== 'cave' || 游戏状态 === '地图编辑器') return;
    const 视野半径 = 5;
    for (let y = 玩家.y - 视野半径; y <= 玩家.y + 视野半径; y++) {
        for (let x = 玩家.x - 视野半径; x <= 玩家.x + 视野半径; x++) {
            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
            if (Math.pow(x - 玩家.x, 2) + Math.pow(y - 玩家.y, 2) <= 视野半径 * 视野半径) {
                if (广度优先搜索路径(玩家.x, 玩家.y, x, y, 视野半径, false, false, false)) {
                    已揭示洞穴格子.add(`${x},${y}`);
                }
            }
        }
    }
}
			function 处理单向房间(旧X, 旧Y, 新X, 新Y) {
			const 新房间ID = 房间地图[新Y]?.[新X];
			const 进入的房间 = 房间列表.find(t=>t.id==新房间ID);
			if (新房间ID === -1) return;
			进入的房间?.门?.forEach(门坐标 => {
			    const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
			    if (!门单元格 || ![单元格类型.门, 单元格类型.上锁的门].includes(门单元格.背景类型)) {
			        return;
			    }
			
			    const 配对单元格坐标 = 门单元格.配对单元格位置;
			    const 配对单元格 = 配对单元格坐标 ? 地牢[配对单元格坐标.y]?.[配对单元格坐标.x] : null;
			
			    const 是入口门 = 进入的房间?.首次进入的门坐标系统?.some(
			        保存的坐标 => 保存的坐标.x === 门坐标.x && 保存的坐标.y === 门坐标.y
			    );
			
			    if (是入口门) {
			        门单元格.isOneWay = false;
			        门单元格.oneWayAllowedDirection = null;
			        if (配对单元格) {
			            配对单元格.isOneWay = false;
			            配对单元格.oneWayAllowedDirection = null;
			        }
			    }
			});
			
			if ((旧X !== undefined && 房间地图[旧Y]?.[旧X] === 新房间ID)) return;
			
			
			if (!进入的房间 || 进入的房间.类型 !== "单向房间") return;
			
			if (!进入的房间.首次进入的门坐标系统) {
			    进入的房间.首次进入的门坐标系统 = [];
			    let 最小距离 = Infinity;
			    let 最近门坐标 = null;
			
			    for (const 门坐标 of 进入的房间.门) {
			        const 距离 = Math.abs(新X - 门坐标.x) + Math.abs(新Y - 门坐标.y);
			        if (距离 < 最小距离) {
			            最小距离 = 距离;
			            最近门坐标 = 门坐标;
			        }
			    }
			
			    if (最近门坐标) {
			        const 主门单元格实例 = 地牢[最近门坐标.y]?.[最近门坐标.x];
			        if (主门单元格实例) {
			            进入的房间.首次进入的门坐标系统.push({ x: 最近门坐标.x, y: 最近门坐标.y });
			            if (主门单元格实例.配对单元格位置) {
			                进入的房间.首次进入的门坐标系统.push({ ...主门单元格实例.配对单元格位置 });
			            }
			        }
			    }
			}
			
			进入的房间.门.forEach(门坐标 => {
			    const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
			    if (!门单元格 || ![单元格类型.门, 单元格类型.上锁的门].includes(门单元格.背景类型)) {
			        return;
			    }
			
			    const 配对单元格坐标 = 门单元格.配对单元格位置;
			    const 配对单元格 = 配对单元格坐标 ? 地牢[配对单元格坐标.y]?.[配对单元格坐标.x] : null;
			
			    const 是入口门 = 进入的房间.首次进入的门坐标系统.some(
			        保存的坐标 => 保存的坐标.x === 门坐标.x && 保存的坐标.y === 门坐标.y
			    );
			
			    if (!是入口门) {
			        门单元格.isOneWay = true;
			        门单元格.oneWayAllowedDirection = randomlySetOneWayDirection(门单元格);
			        if (配对单元格) {
			            配对单元格.oneWayAllowedDirection = 门单元格.oneWayAllowedDirection;
			        }
			    }
			});
			        }
			
			        async function 移动玩家(dx, dy, 冷却 = true) {
			    if (游戏状态 === '地图编辑器') {
			        相机目标X += dx * 编辑器状态.相机速度;
			        相机目标Y += dy * 编辑器状态.相机速度;
			        let 新X = 玩家.x + dx;
			    let 新Y = 玩家.y + dy;
			    
			    if (
			        新X < 0 ||
			        新X >= 地牢大小 ||
			        新Y < 0 ||
			        新Y >= 地牢大小
			    )
			        return;
			        玩家动画状态 = {
			正在动画: true,
			旧逻辑X: 玩家.x,
			旧逻辑Y: 玩家.y,
			目标逻辑X: 新X,
			目标逻辑Y: 新Y,
			视觉X: 玩家.x,
			视觉Y: 玩家.y,
			动画开始时间: Date.now()
			        };
			    玩家.x = 新X
			    玩家.y = 新Y
			        绘制小地图();
			        更新视口();
			        return;
			    }
			
			    if (
			        玩家属性.允许移动 > 0 ||
			        (游戏状态 !== "游戏中" && 游戏状态 !== "图鉴" && 游戏状态 !== "编辑器游玩")
			    )
			        return false;
			    if (冷却) {
			        const now = Date.now();
			        if (now - 上次移动 < 50) return;
			        上次移动 = now;
			    }
			    const 能量条 = document.querySelector(".power-bar");
			    const 当前能量 = parseFloat(能量条.style.width) || 100;
			    const 眩晕状态 = 玩家状态.some((s) => s.类型 === "眩晕");
			    const 冻结状态 = 玩家状态.some((s) => s.类型 === "冻结");
			    const 缓慢状态 = 玩家状态.some((s) => s.类型 === "缓慢");
			    const 牵制状态 = 玩家状态.some((s) => s.类型 === "牵制");
			    
			
			    if (眩晕状态 && (dx !== 0 || dy !== 0)) {
			        添加日志("你晕头转向，胡乱移动！", "警告");
			        const 方向列表 = [
			            { dx: 0, dy: -1 },
			            { dx: 1, dy: 0 },
			            { dx: 0, dy: 1 },
			            { dx: -1, dy: 0 },
			        ];
			        const 可移动方向 = 方向列表.filter((dir) =>
			            检查移动可行性(
			                玩家.x,
			                玩家.y,
			                玩家.x + dir.dx,
			                玩家.y + dir.dy
			            )
			        );
			
			        if (可移动方向.length > 0) {
			            const 随机方向 =
			                可移动方向[
			                    Math.floor(prng() * 可移动方向.length)
			                ];
			            dx = 随机方向.dx;
			            dy = 随机方向.dy;
			        } else {
			            dx = 0;
			            dy = 0;
			        }
			
			        dx *= 玩家属性.移动步数;
			        dy *= 玩家属性.移动步数;
			
			        if (缓慢状态) {
			            dx = Math.sign(dx);
			            dy = Math.sign(dy);
			        }
			    } else {
			        if (缓慢状态) {
			            dx = Math.sign(dx);
			            dy = Math.sign(dy);
			        }
			    }
			    let 新X = 玩家.x + dx;
			    let 新Y = 玩家.y + dy;
			
			    
			    if (
			        新X < 0 ||
			        新X >= 地牢大小 ||
			        新Y < 0 ||
			        新Y >= 地牢大小
			    )
			        return;
			    相机锁定 = false;
			    if (玩家正在钩索) {
			        玩家正在钩索 = false;
			        clearTimeout(钩索移动定时器);
			    }
			    const 目标X_挖掘 = 玩家.x + Math.sign(dx);
			    const 目标Y_挖掘 = 玩家.y + Math.sign(dy);
			    if (玩家属性.能挖掘墙壁 && (dx !== 0 || dy !== 0) && !生存挑战激活) {
			        if (目标X_挖掘 >= 0 && 目标X_挖掘 < 地牢大小 && 目标Y_挖掘 >= 0 && 目标Y_挖掘 < 地牢大小) {
			            const 目标单元格 = 地牢[目标Y_挖掘]?.[目标X_挖掘];
			            if (目标单元格 && 目标单元格.背景类型 === 单元格类型.墙壁) {
			                 if(扣除能量(5)) {
			                    目标单元格.背景类型 = 地牢[玩家.y][玩家.x].背景类型;
			                    生成墙壁();
			                    
			                 } else {
			                    显示通知("能量不足，无法挖掘！", "错误");
			                    return false;
			                 }
			            }
			        }
			    }
			    let 剩余步数 = 缓慢状态 ? 1 : 玩家属性.移动步数;
			    let 实际移动 = 0;
			    let 目标X,
			        目标Y = 0;
			    let 旧玩家X = 玩家.x
			    let 旧玩家Y = 玩家.y
			    while (
			        剩余步数 > 0 &&
			        !(冻结状态 || 牵制状态) &&
			        (玩家.x !== 新X || 玩家.y !== 新Y)
			    ) {
			        目标X = 玩家.x + Math.sign(dx);
			        目标Y = 玩家.y + Math.sign(dy);
			        let 目标单元格 = 地牢[目标Y]?.[目标X];
			        let 当前单元格 = 地牢[玩家.y]?.[玩家.x];
			        if (!检查移动可行性(玩家.x, 玩家.y, 目标X, 目标Y)) break;
			        if (!目标单元格) {
			            更新视口();
			            绘制();
			            return;
			        }
			        if (
			            目标单元格.isOneWay &&
			            [单元格类型.门, 单元格类型.上锁的门].includes(
			                目标单元格.背景类型
			            )
			        ) {
			            const actualMoveMapDirection = getMoveDirection(
			                玩家.x,
			                玩家.y,
			                目标X,
			                目标Y
			            );
			            if (
			                actualMoveMapDirection !==
			                目标单元格.oneWayAllowedDirection
			            ) {
			                break;
			            }
			        }
			
			        const 旧X = 玩家.x;
			        const 旧Y = 玩家.y;
			        玩家.x = 目标X;
			        玩家.y = 目标Y;
			
			        let 触发中断 = 处理玩家着陆效果(旧X, 旧Y, 目标X, 目标Y);
			        
			
			        if (!触发中断) {
			            
			        } else {
			
			            break;
			        }
			        实际移动++;
			        剩余步数--;
			
			        if (当前激活卷轴列表.size > 0 && 实际移动 > 0) {
			            当前激活卷轴列表.forEach((卷轴) => {
			                卷轴.消耗能量();
			            });
			        }
			        
			    }
			    玩家动画状态 = {
			正在动画: true,
			旧逻辑X: 旧玩家X,
			旧逻辑Y: 旧玩家Y,
			目标逻辑X: 玩家.x,
			目标逻辑Y: 玩家.y,
			视觉X: 旧玩家X,
			视觉Y: 旧玩家Y,
			动画开始时间: Date.now()
			        };
			        玩家距离图=生成玩家距离图(玩家.x,玩家.y)
			        if(地牢生成方式==='default') {尝试进入特殊房间(玩家.x, 玩家.y);}
			    if (!切换动画&&(冻结状态 || 牵制状态 || 实际移动>0)) {
			        处理回合逻辑();
			    }
			    if (地牢[玩家.y][玩家.x].关联物品 instanceof 折跃门) {
			        地牢[玩家.y][玩家.x].关联物品.使用();
			    }
			    
			    if (实际移动 > 0 || 冻结状态) {
			        const 方向 =
			            Math.sign(dy) === -1
			                ? "上"
			                : Math.sign(dy) === 1
			                ? "下"
			                : Math.sign(dx) === -1
			                ? "左"
			                : Math.sign(dx) === 1
			                ? "右"
			                : "";
			        if ((!是否是自定义关卡 && 游戏状态!=='编辑器游玩') || 开发者模式) 移动历史.push(方向);
			
			        if (移动历史.length > 调试序列.length) {
			            移动历史=移动历史.slice(-调试序列.length);
			        }
			        Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			        )
			            .filter((v) => v != null)
			            .forEach((item) => {
			                if (item instanceof 寻宝戒指) {
			                    if (
			                        item.自定义数据.get("生效层数") ===
			                            当前层数 &&
			                        !item.自定义数据.get("已生成折跃门")
			                    ) {
			                        item.尝试生成折跃门();
			                    }
			                }
			            });
			
			        if (移动历史.join(",") === 调试序列.join(",")) {
			            const 当前房间ID = 房间地图[玩家.y][玩家.x];
			            if (当前房间ID !== -1) {
			                const 迅捷卷轴测试 = new 迅捷卷轴({});
			                放置物品到房间(迅捷卷轴测试, 房间列表[当前房间ID]);
			
			                const 秘银锁甲测试 = new 秘银锁甲({});
			                放置物品到房间(秘银锁甲测试, 房间列表[当前房间ID]);
			
			                const 跃迁卷轴测试 = new 跃迁卷轴({});
			                放置物品到房间(跃迁卷轴测试, 房间列表[当前房间ID]);
			
			                const 真言卷轴测试 = new 真言卷轴({});
			                放置物品到房间(真言卷轴测试, 房间列表[当前房间ID]);
			                const 调试工具实例 = new 调试工具({});
			                放置物品到房间(调试工具实例, 房间列表[当前房间ID]);
			
			                const 湮灭卷轴测试 = new 湮灭卷轴({});
			                放置物品到房间(湮灭卷轴测试, 房间列表[当前房间ID]);
			
			                const 贪婪卷轴测试 = new 贪婪卷轴({});
			                放置物品到房间(贪婪卷轴测试, 房间列表[当前房间ID]);
			
			                const 附魔卷轴测试 = new 附魔卷轴({});
			                放置物品到房间(附魔卷轴测试, 房间列表[当前房间ID]);
			
			                const 回旋镖测试 = new 回旋镖({});
			                放置物品到房间(回旋镖测试, 房间列表[当前房间ID]);
			
			                const 冰霜法杖测试 = new 冰霜法杖({});
			                放置物品到房间(冰霜法杖测试, 房间列表[当前房间ID]);
			
			                const 剧毒匕首测试 = new 剧毒匕首({});
			                放置物品到房间(剧毒匕首测试, 房间列表[当前房间ID]);
			
			                const 重力锤测试 = new 重力锤({});
			                放置物品到房间(重力锤测试, 房间列表[当前房间ID]);
			
			                const 闪电链法杖测试 = new 闪电链法杖({});
			                放置物品到房间(
			                    闪电链法杖测试,
			                    房间列表[当前房间ID]
			                );
			
			                const 大地猛击锤测试 = new 大地猛击锤({});
			                放置物品到房间(
			                    大地猛击锤测试,
			                    房间列表[当前房间ID]
			                );
			
			                const 穿云箭测试 = new 穿云箭({});
			                放置物品到房间(穿云箭测试, 房间列表[当前房间ID]);
			
			                const 荆棘鞭测试 = new 荆棘鞭({});
			                放置物品到房间(荆棘鞭测试, 房间列表[当前房间ID]);
			
			                const 能量药水测试 = new 能量药水({});
			                放置物品到房间(能量药水测试, 房间列表[当前房间ID]);
			
			                const 狂暴药水测试 = new 狂暴药水({});
			                放置物品到房间(狂暴药水测试, 房间列表[当前房间ID]);
			
			                const 神龟药水测试 = new 神龟药水({});
			                放置物品到房间(神龟药水测试, 房间列表[当前房间ID]);
			
			                const 治疗药水测试 = new 治疗药水({});
			                放置物品到房间(治疗药水测试, 房间列表[当前房间ID]);
			
			                const 透视药水测试 = new 透视药水({});
			                放置物品到房间(透视药水测试, 房间列表[当前房间ID]);
			
			                const 隐身药水测试 = new 隐身药水({});
			                放置物品到房间(隐身药水测试, 房间列表[当前房间ID]);
			
			                const 橡木法杖测试 = new 橡木法杖({});
			                放置物品到房间(橡木法杖测试, 房间列表[当前房间ID]);
			
			                const 金币手枪测试 = new 金币手枪({});
			                放置物品到房间(金币手枪测试, 房间列表[当前房间ID]);
			
			                const 寻宝戒指测试 = new 寻宝戒指({});
			                放置物品到房间(寻宝戒指测试, 房间列表[当前房间ID]);
			
			                const 炸弹测试 = new 炸弹({});
			                放置物品到房间(炸弹测试, 房间列表[当前房间ID]);
			
			                const 冰盾测试 = new 冰盾({});
			                放置物品到房间(冰盾测试, 房间列表[当前房间ID]);
			
			                const 重铸台测试 = new 重铸台({});
			                放置物品到房间(重铸台测试, 房间列表[当前房间ID]);
			
			                const 神秘商人测试 = new 神秘商人({});
			                放置物品到房间(神秘商人测试, 房间列表[当前房间ID]);
			
			                const 探险家测试 = new 探险家({});
			                放置物品到房间(探险家测试, 房间列表[当前房间ID]);
			
			                const 喷火枪测试 = new 喷火枪({});
			                放置物品到房间(喷火枪测试, 房间列表[当前房间ID]);
			
			                const 背包扩容祭坛测试 = new 背包扩容祭坛({});
			                放置物品到房间(
			                    背包扩容祭坛测试,
			                    房间列表[当前房间ID]
			                );
			
			                const 宠物测试 = new 水母({});
			                放置物品到房间(宠物测试, 房间列表[当前房间ID]);
			
			                const 金币测试 = new 金币({ 数量: 64 });
			                放置物品到房间(金币测试, 房间列表[当前房间ID]);
			                if (!彩蛋3触发) {
			                    显示通知("你被加强了，快上！", "信息", true);
			                    彩蛋3触发 = true;
			                }
			            }
			            移动历史 = [];
			        }
			        更新视口();
			        if (当前天气效果.includes("诡魅")) {
			            处理诡魅房间刷新(
			                玩家.x - dx,
			                玩家.y - dy,
			                玩家.x,
			                玩家.y
			            );
			        }
			    }
			    if (isAutoMoving && (玩家.x !== 新X || 玩家.y !== 新Y)) {
			        moveQueue = [];
			        isAutoMoving = false;
			    }
			    if (玩家属性.随机掉落 && prng() < 0.09) {
			        const 可掉落物品 = [...玩家背包.values()].filter(item => !item.是否隐藏 && !item.已装备);
			        if (可掉落物品.length > 0) {
			            const 掉落物品 = 可掉落物品[Math.floor(prng() * 可掉落物品.length)];
			            if (处理丢弃物品(掉落物品.唯一标识)) {
			                显示通知(`【诅咒】你的 ${掉落物品.获取名称()} 不小心掉了出来！`, "警告");
			            }
			        }
			    }
			    更新界面状态();
			    绘制();
			}
			function 扣除能量(能量, 是否卷轴 = false) {
			    if(调试无限能量) return true;
			    const 能量条 = document.querySelector(".power-bar");
			    let 当前能量 = Math.max(
			        Math.min(parseFloat(能量条.style.width), 100),
			        0
			    );
			    当前能量 -= 能量/自定义全局设置.初始能量值*100;
			    if (当前能量 <= 0) {
			        if (当前激活卷轴列表.size > 0) {
			            当前激活卷轴列表.forEach((卷轴) => {
			                当前激活卷轴列表.delete(卷轴);
			                卷轴.卸下();
			            });
			
			            当前能量 = 0;
			        }
			        更新装备显示();
			        if (是否卷轴)
			            显示通知("能量不足，已自动取消卷轴效果", "信息");
			        return false;
			    }
			    能量条.style.width = `${Math.max(0, 当前能量)}%`;
			    触发HUD显示();
			    return true;
			}
			function 检查移动可行性(
			    fromX,
			    fromY,
			    toX,
			    toY,
			    未解锁房间视作障碍 = false,
			    无视物品 = false
			) {
			    if (toX < 0 || toX >= 地牢大小 || toY < 0 || toY >= 地牢大小)
			        return false;
			    if (fromX < 0 || fromX >= 地牢大小 || fromY < 0 || fromY >= 地牢大小)
			        return false;
			    const 目标单元格实例 = 地牢[toY]?.[toX];
			    if (目标单元格实例?.关联物品 && !无视物品) {
			        if (目标单元格实例.关联物品 instanceof 红砖块 && 红蓝开关状态 === '红') return false;
			        if (目标单元格实例.关联物品 instanceof 蓝砖块 && 红蓝开关状态 === '蓝') return false;
			        if (目标单元格实例.关联物品 instanceof 绿砖块 && 绿紫开关状态 === '绿') return false;
			        if (目标单元格实例.关联物品 instanceof 紫砖块 && 绿紫开关状态 === '紫') return false;
			    }
			
			    const dx = toX - fromX;
			    const dy = toY - fromY;
			    const 方向 = {
			        dx: dx !== 0 ? (dx > 0 ? 1 : -1) : 0,
			        dy: dy !== 0 ? (dy > 0 ? 1 : -1) : 0,
			    };
			    if (Math.abs(dx) == 0 || Math.abs(dy) == 0) {
			        return 快速直线检查(
			            fromX,
			            fromY,
			            toX,
			            toY,
			            Math.max(Math.abs(dx), Math.abs(dy))
			        );
			    }
			
			    let currentX = fromX;
			    let currentY = fromY;
			
			    while (currentX !== toX || currentY !== toY) {
			        currentX += 方向.dx;
			        currentY += 方向.dy;
			
			        const 当前单元格 = 地牢[currentY][currentX];
			        const 前一单元格 =
			            地牢[currentY - 方向.dy][currentX - 方向.dx];
			
			        const 垂直移动 = 方向.dy !== 0;
			        const 墙方向 = 垂直移动
			            ? 方向.dy > 0
			                ? "下"
			                : "上"
			            : 方向.dx > 0
			            ? "右"
			            : "左";
			
			        if (垂直移动) {
			            if (
			                前一单元格.墙壁[方向.dy > 0 ? "下" : "上"] ||
			                当前单元格.墙壁[方向.dy > 0 ? "上" : "下"]
			            ) {
			                return false;
			            }
			        } else {
			            if (
			                前一单元格.墙壁[方向.dx > 0 ? "右" : "左"] ||
			                当前单元格.墙壁[方向.dx > 0 ? "左" : "右"]
			            ) {
			                return false;
			            }
			        }
			        if((当前单元格.关联物品?.类型 === '开关砖' && 当前单元格.关联物品?.阻碍怪物) &&!无视物品) return false;
			
			        if (
			            [单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                当前单元格.背景类型
			            )
			        ) {
			            return false;
			        }
			        if (
			            房间地图[currentY][currentX] !== 0 &&
			            房间地图[currentY][currentX] !== -1 &&
			            !已访问房间.has(房间地图[currentY][currentX]) &&
			            未解锁房间视作障碍
			        )
			            return false;
			    }
			    return true;
			}
			function 处理丢弃物品(唯一标识) {
			    const 物品实例 = 玩家背包.get(唯一标识);
			    if (!物品实例) return false;
			
			    let 目标X = 玩家.x;
			    let 目标Y = 玩家.y;
			    let 可用 = false;
			
			    if (位置是否可用(目标X, 目标Y, false)) {
			        可用 = true;
			    } else {
			        const 方向 = [
			            [0, -1],
			            [0, 1],
			            [-1, 0],
			            [1, 0],
			            [1, -1],
			            [1, 1],
			            [-1, 1],
			            [-1, -1],
			        ];
			        for (const [dx, dy] of 方向) {
			            const 新X = 玩家.x + dx;
			            const 新Y = 玩家.y + dy;
			
			            if (
			                新X >= 0 &&
			                新X < 地牢大小 &&
			                新Y >= 0 &&
			                新Y < 地牢大小 &&
			                位置是否可用(新X, 新Y) &&
			                检查移动可行性(玩家.x, 玩家.y, 新X, 新Y)
			            ) {
			                目标X = 新X;
			                目标Y = 新Y;
			                可用 = true;
			                break;
			            }
			        }
			    }
			
			    if (!可用) {
			        显示通知("周围没有空间丢弃物品！", "错误");
			        return false;
			    }
			    if (!物品实例.当被丢弃(目标X, 目标Y)) {
			        return false;
			    }
			    玩家背包.delete(唯一标识);
			    if (物品实例.已装备) {
			        物品实例.取消装备();
			        玩家装备.delete(物品实例.装备槽位);
			        物品实例.已装备 = false;
			        物品实例.装备槽位 = null;
			    }
			
			    物品实例.是否被丢弃 = true;
			    物品实例.isActive = false;
			    放置物品到单元格(物品实例, 目标X, 目标Y);
			
			    更新背包显示();
			    更新装备显示();
			    显示通知(`丢弃了 ${物品实例.获取名称()}`, "信息");
			    if (!彩蛋1触发) {
			                 检查Q字形彩蛋(目标X, 目标Y);
			             }
			    document.getElementById("浮动提示框").style.display = "none";
			
			    return true;
			}
			function 处理天气效果() {
			    if (当前天气效果.includes("雷暴")) {
			        处理雷暴效果();
			    }
			    if (当前天气效果.includes("大风")) {
			        处理大风效果();
			    }
			    if (当前天气效果.includes("严寒")) {
			        处理严寒效果();
			    } else {
			        解冻药水();
			    }
			}
			function 是否靠近火源(目标X, 目标Y) {
			    if (目标X === 玩家.x && 目标Y === 玩家.y) {
			        if (玩家状态.some((s) => s.类型 === "火焰")) return true;
			        if (
			            Array.from({ length: 装备栏每页装备数 }, (_, i) =>
			                玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			            )
			                .filter((v) => v != null)
			                .some(
			                    (装备) =>
			                        装备 instanceof 火把 &&
			                        装备.自定义数据?.get("耐久") > 0
			                )
			        )
			            return true;
			    }
			
			    const 方向数组 = [
			        [0, 0],
			        [0, -1],
			        [0, 1],
			        [-1, 0],
			        [1, 0],
			        [-1, -1],
			        [1, -1],
			        [-1, 1],
			        [1, 1],
			    ];
			    for (const [dx, dy] of 方向数组) {
			        const 检查X = 目标X + dx;
			        const 检查Y = 目标Y + dy;
			        if (
			            检查X >= 0 &&
			            检查X < 地牢大小 &&
			            检查Y >= 0 &&
			            检查Y < 地牢大小
			        ) {
			            const 单元格 = 地牢[检查Y]?.[检查X];
			            const 怪物实例 = 单元格?.关联怪物;
			            if (
			                单元格?.关联物品 instanceof 火焰物品 &&
			                单元格.关联物品.自定义数据.get("倒计时") > 0
			            ) {
			                return true;
			            } else if (
			                单元格?.关联物品 instanceof 火把 &&
			                单元格.关联物品.自定义数据.get("耐久") > 0 &&
			                单元格.关联物品.是否被丢弃
			            ) {
			                return true;
			            } else if (
			                怪物实例 &&
			                怪物状态表.get(怪物实例)?.类型 === "火焰"
			            ) {
			                return true;
			            }
			        }
			    }
			    return false;
			}
			function 解冻药水() {
			    let 解冻发生标志 = false;
			    玩家背包.forEach((物品实例) => {
			        if (
			            物品实例 instanceof 药水类 &&
			            物品实例.自定义数据.get("是否冻结")
			        ) {
			            物品实例.自定义数据.set("是否冻结", false);
			
			            解冻发生标志 = true;
			        }
			    });
			    if (解冻发生标志) {
			        添加日志("背包里的药水解冻了。", "信息");
			        更新背包显示();
			    }
			}
			
			function 处理严寒效果() {
			    if (
			        !玩家状态.some((s) => s.类型 === "冻结") &&
			        !是否靠近火源(玩家.x, 玩家.y)
			    ) {
			        if (prng() < 0.1) {
			            new 状态效果(
			                "冻结",
			                "#2196F3",
			                图标映射.冰冻怪物,
			                2,
			                null,
			                null,
			                null,
			                1
			            );
			            添加日志("你被严寒冻结了！", "错误");
			        }
			    }
			
			    let 有药水被冻结 = false;
			    玩家背包.forEach((物品实例) => {
			        if (
			            物品实例 instanceof 药水类 &&
			            !物品实例.自定义数据.get("是否冻结")
			        ) {
			            if (!是否靠近火源(玩家.x, 玩家.y)) {
			                物品实例.自定义数据.set("是否冻结", true);
			                有药水被冻结 = true;
			                添加日志(
			                    `${物品实例.获取名称()} 被冻结了！`,
			                    "警告"
			                );
			            }
			        }
			    });
			    if (有药水被冻结) {
			        更新背包显示();
			    }
			    if (是否靠近火源(玩家.x, 玩家.y)) {
			        解冻药水();
			    }
			}
			function 处理雷暴效果() {
			    let 雷击概率 = 0.1;
			    const 有铜质装备 = Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).some(装备 => 装备.材质 === 材料.铜质);
			    if (有铜质装备) {
			        雷击概率 = 0.25;
			    }
			    if (prng() < 雷击概率) {
			        const 玩家房间ID = 房间地图[玩家.y][玩家.x];
			        let rx=0
			        let ry=0
			        if (玩家房间ID === -1) {
			            rx =
			            玩家.x-7 +
			            Math.floor(prng() * 14);
			            ry =
			            玩家.y-7 +
			            Math.floor(prng() * 14);
			        } else {
			
			        const 玩家所在房间 = 房间列表[玩家房间ID];
			        if (
			            !玩家所在房间 ||
			            玩家所在房间.w < 2 ||
			            玩家所在房间.h < 2
			        )
			            return;
			
			        rx =
			            玩家所在房间.x +
			            Math.floor(prng() * (玩家所在房间.w - 1));
			        ry =
			            玩家所在房间.y +
			            Math.floor(prng() * (玩家所在房间.h - 1));
			        }
			        const 闪电坐标 = [
			            { x: rx, y: ry },
			            { x: rx + 1, y: ry },
			            { x: rx, y: ry + 1 },
			            { x: rx + 1, y: ry + 1 },
			        ];
			
			        计划显示格子特效(闪电坐标, "FFFF00", 50);
			
			        闪电坐标.forEach((坐标) => {
			            if (
			                坐标.x < 0 ||
			                坐标.x >= 地牢大小 ||
			                坐标.y < 0 ||
			                坐标.y >= 地牢大小
			            )
			                return;
			            const 单元格 = 地牢[坐标.y]?.[坐标.x];
			            if (!单元格) return;
			
			            if (
			                单元格.关联物品 &&
			                单元格.关联物品?.类型 !== "楼梯" &&
			                !(单元格.关联物品 instanceof 挑战石碑)
			            ) {
			                const 被毁物品 = 单元格.关联物品;
			                添加日志(`${被毁物品.名称} 被闪电摧毁了！`, "警告");
			                const 计时器索引 = 所有计时器.findIndex(
			                    (t) => t.唯一标识 === 被毁物品.唯一标识
			                );
			                if (计时器索引 !== -1) {
			                    所有计时器.splice(计时器索引, 1);
			                }
			                if (玩家背包.has(被毁物品.唯一标识)) {
			                    处理销毁物品(被毁物品.唯一标识, true);
			                }
			                单元格.关联物品 = null;
			                单元格.类型 = null;
			            }
			
			            if (单元格.关联怪物) {
			                const 怪物 = 单元格.关联怪物;
			                let 被击中日志 = `${怪物.类型} 被闪电击中`;
			                if (怪物.强化) {
			                    怪物.受伤(15, "雷暴");
			                    被击中日志 += `，损失了 15 点生命！`;
			                } else {
			                    怪物.强化 = true;
			                    怪物.绘制血条();
			                    显示通知(`${怪物.类型} 被闪电强化了！`, "警告");
			                    被击中日志 += `，并被强化了！`;
			                    绘制();
			                }
			                const 火焰强度 = 3;
			                const 火焰持续 = 3;
			                new 状态效果(
			                    "火焰",
			                    效果颜色编号映射[效果名称编号映射.火焰],
			                    "火",
			                    火焰持续,
			                    null,
			                    null,
			                    怪物,
			                    火焰强度
			                );
			                被击中日志 += ` 还着火了！`;
			
			                添加日志(被击中日志, "警告");
			            }
			
			            if (玩家.x === 坐标.x && 玩家.y === 坐标.y) {
			                伤害玩家(15, "雷暴");
			                显示通知("你被闪电击中了！", "错误");
			
			                const 火焰强度玩家 = 3;
			                const 火焰持续玩家 = 3;
			                new 状态效果(
			                    "火焰",
			                    效果颜色编号映射[效果名称编号映射.火焰],
			                    图标映射.火焰,
			                    火焰持续玩家,
			                    null,
			                    null,
			                    null,
			                    火焰强度玩家
			                );
			                添加日志("你被闪电点燃了！", "错误");
			            }
						当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && !pet.自定义数据.get("休眠中") && pet.x === 坐标.x && pet.y === 坐标.y && pet.层数==当前层数 ) {
        pet.受伤(15, "雷暴");
        显示通知(`${pet.名称} 被闪电击中了！`, "错误");
    }
});
			
			            if (位置是否可用(坐标.x, 坐标.y, false)) {
			                const 火焰 = new 火焰物品({
			                    强化: prng() < 0.1,
			                });
			                if (!放置物品到单元格(火焰, 坐标.x, 坐标.y)) {
			                    console.warn(
			                        `未能放置火焰物品在 (${坐标.x}, ${坐标.y})`
			                    );
			                }
			            }
			        });
			        绘制();
			    }
			}
			let 融合区物品 = [null, null, null, null]; // 存储物品的唯一标识 Symbol
			let 融合结果 = null; // 存储融合结果的物品实例
			
			const 融合配方列表 = [
			    {
			        输入: ["治疗药水", "治疗药水"].sort(),
			        输出类: "治疗药水",
			        输出数量: 1,
			        输出配置: { 强化: true },
			    },
			    {
			        输入: ["钢制长剑", "治疗药水"].sort(),
			        输出类: "吸血剑",
			        输出数量: 1,
			    },
			    {
			        输入: ["钢制长剑", "钢制长剑"].sort(),
			        输出类: "钢制长剑",
			        输出数量: 1,
			        输出配置: { 强化: true },
			    },
			];
			
			let fusionGoldQuantities = [0, 0, 0, 0];
			
			function 添加到融合区(物品实例, 起始元素) {
			    if (!物品实例) return;
			
			    const targetSlotIndex = 融合区物品.findIndex(格子 => 格子 === null);
			
			    if (targetSlotIndex === -1) {
			        显示通知("融合区已满！", "错误");
			        return;
			    }
			
			    if (物品实例 instanceof 金币) {
			        let goldSlotIndex = -1;
			        for (let i = 0; i < 4; i++) {
			const itemInSlot = 融合区物品[i];
			if (itemInSlot === null || (itemInSlot instanceof 金币 && fusionGoldQuantities[i] < 最大堆叠数)) {
			    goldSlotIndex = i;
			    break;
			}
			        }
			        if (goldSlotIndex === -1) {
			 显示通知("融合区已满或无合适槽位！", "错误");
			return;
			        }
			        物品实例.堆叠数量--;
			        if (融合区物品[goldSlotIndex] === null) {
			融合区物品[goldSlotIndex] = 物品实例;
			        }
			        fusionGoldQuantities[goldSlotIndex]++;
			        if (物品实例.堆叠数量 <= 0) {
			           玩家背包.delete(物品实例.唯一标识);
			           if (物品实例.装备槽位) 物品实例.取消装备()
			        }
			        const 获取目标元素的函数 = () => document.getElementById(`融合区格子${goldSlotIndex + 1}`);
			        创建并播放物品移动动画(起始元素, 获取目标元素的函数);
			    } else {
			        if (物品实例.堆叠数量 > 1) {
			物品实例.堆叠数量--; 
			const 移出物品 = 克隆物品(物品实例); 
			移出物品.堆叠数量 = 1;
			移出物品.实际唯一标识 = 物品实例.唯一标识
			融合区物品[targetSlotIndex] = 移出物品; 
			        } else {
			玩家背包.delete(物品实例.唯一标识); 
			if (物品实例.装备槽位) 物品实例.取消装备()
			物品实例.实际唯一标识 = 物品实例.唯一标识
			融合区物品[targetSlotIndex] = 物品实例; 
			        }
			        const 获取目标元素的函数 = () => document.getElementById(`融合区格子${targetSlotIndex + 1}`);
			        创建并播放物品移动动画(起始元素, 获取目标元素的函数);
			    }
			    
			    物品实例.isActive = false;
			    if (物品实例.显示元素) 物品实例.显示元素.classList.remove("active");
			    document.getElementById("浮动提示框").style.display = "none";
			    if (typeof gsap === 'undefined'&&命令行模式开启) {
			                setTimeout(()=>{更新融合窗口();
			        检查融合配方();
			        更新背包显示();
			        更新装备显示();}, 320);
			            } else {
			                更新融合窗口();
			        检查融合配方();
			        更新背包显示();
			        更新装备显示();
			            }
			    
			        
			}
			
			let 当前匹配的融合配方 = null;
			
			
			
			function 从融合区移除(格子索引) {
			    const 物品实例 = 融合区物品[格子索引];
			    if (物品实例 === null) return;
			    
			    document.getElementById("浮动提示框").style.display = "none";
			
			    if (物品实例 instanceof 金币) {
			        const goldAmountToReturn = fusionGoldQuantities[格子索引] || 0;
			        if (goldAmountToReturn > 0) {
			             fusionGoldQuantities[格子索引] = 0;
			             融合区物品[格子索引] = null;
			             尝试收集物品(new 金币({ 数量: goldAmountToReturn }), true);
			        } else {
			             融合区物品[格子索引] = null;
			        }
			    } else {
			        融合区物品[格子索引] = null; 
			        const 收集成功 = 尝试收集物品(物品实例, true);
			
			        if (!收集成功) {
			            融合区物品[格子索引] = 物品实例; 
			            显示通知("背包已满，无法取回！", "错误");
			        }
			    }
			    
			    检查融合配方();
			    更新融合窗口();
			    更新背包显示();
			    更新装备显示();
			}
			
			function 执行融合(){
			    if(!融合结果){
			        显示通知("没有有效的融合结果！","错误");
			        return;
			    }
			
			    const originalFusionSlotItems = [...融合区物品];
			    const consumedItemSymbols = new Set();
			    const consumedGoldQuantities = [0, 0, 0, 0];
			
			    if(当前匹配的融合配方 === "卷轴附魔融合"){
			        const 附魔卷轴实例 = originalFusionSlotItems.find(item => item instanceof 附魔卷轴 && item.自定义数据.get("已解锁"));
			        const 目标物品原件 = originalFusionSlotItems.find(item => item && (item instanceof 武器类 || item instanceof 防御装备类));
			
			        if(!附魔卷轴实例 || !目标物品原件){
			显示通知("融合错误：找不到卷轴或目标物品！","错误");
			return;
			        }
			
			        const 输出物品 = 克隆物品(目标物品原件);
			        const 附魔成功 = 附魔卷轴实例.附魔效果.call(附魔卷轴实例, 输出物品);
			
			        if(附魔成功){
			融合结果 = 输出物品;
			consumedItemSymbols.add(附魔卷轴实例.唯一标识);
			consumedItemSymbols.add(目标物品原件.唯一标识);
			输出物品.是否隐藏 = false;
			尝试收集物品(输出物品, true);
			附魔卷轴实例.可用次数 = (附魔卷轴实例.可用次数 === undefined ? 1 : 附魔卷轴实例.可用次数) - 1;
			if (附魔卷轴实例.可用次数 <= 0) {
			     处理销毁物品(附魔卷轴实例.唯一标识, true);
			}
			显示通知(`${输出物品.获取名称()} 附魔成功！`, "成功");
			        }else{
			显示通知("附魔失败！(能量不足或不兼容)", "错误");
			return;
			        }
			    } else if (当前匹配的融合配方 === "药水金币延长") {
			        const 药水实例 = originalFusionSlotItems.find(item => item instanceof 药水类);
			        if(!药水实例) {
			 显示通知("融合错误：找不到药水！", "错误");
			 return;
			        }
			
			        let 总消耗金币数量 = 0;
			        originalFusionSlotItems.forEach((item, index) => {
			if (item instanceof 金币 && fusionGoldQuantities[index] > 0) {
			    总消耗金币数量 += fusionGoldQuantities[index];
			    consumedGoldQuantities[index] = fusionGoldQuantities[index];
			}
			        });
			
			        const potionExtendEnergyCost = 2 * 总消耗金币数量;
			        if (!扣除能量(potionExtendEnergyCost)) {
			显示通知(`能量不足！需要 ${potionExtendEnergyCost} 点能量。`, "错误");
			return;
			        }
			
			        consumedItemSymbols.add(药水实例.唯一标识);
			        originalFusionSlotItems.forEach((item, index) => {
			if (item instanceof 金币 && consumedGoldQuantities[index] > 0) {
			    consumedItemSymbols.add(item.唯一标识);
			}
			        });
			        
			        const 延长后的药水 = 克隆物品(融合结果);
			        延长后的药水.唯一标识 = Symbol("ExtendedPotion_" + Date.now());
			        延长后的药水.是否隐藏 = false;
			        if(尝试收集物品(延长后的药水, true)){
			显示通知(`${延长后的药水.名称} 持续时间已延长！`, "成功");
			        } else {
			 显示通知("融合失败：无法将产物放入背包！", "错误");
			 const 能量条 = document.querySelector(".power-bar");
			 const 当前能量 = parseFloat(能量条.style.width) || 0;
			 if (能量条) 能量条.style.width = `${Math.min(100, 当前能量 + potionExtendEnergyCost/自定义全局设置.初始能量值*100)}%`;
			 return;
			        }
			
			    } else if (当前匹配的融合配方 === "木材转化融合" || 当前匹配的融合配方 === "铁器锈蚀融合") {
			        const energyCost = 10;
			        if (!扣除能量(energyCost)) {
			            显示通知(`能量不足！需要 ${energyCost} 点能量。`, "错误");
			            return;
			        }
			        const 产物 = 克隆物品(融合结果);
			        if (尝试收集物品(产物, true)) {
			            originalFusionSlotItems.forEach(item => {
			                if (item) consumedItemSymbols.add(item.唯一标识);
			            });
			            显示通知(`${产物.获取名称()} 转化成功！`, "成功");
			        } else {
			            显示通知("融合失败：无法将产物放入背包！", "错误");
			            const 能量条 = document.querySelector(".power-bar");
			            const 当前能量 = parseFloat(能量条.style.width) || 0;
			            if (能量条) 能量条.style.width = `${Math.min(100, 当前能量 + energyCost/自定义全局设置.初始能量值*100)}%`;
			            return;
			        }
			    } else if (当前匹配的融合配方 && typeof 当前匹配的融合配方 === "object" && 当前匹配的融合配方 !== "装备融合" && 当前匹配的融合配方 !== "词条融合") {
			        const 配方 = 当前匹配的融合配方;
			        const recipeEnergyCost = 5 * 配方.输入.length;
			        if (!扣除能量(recipeEnergyCost)) {
			显示通知(`能量不足！需要 ${recipeEnergyCost} 点能量。`, "错误");
			return;
			        }
			
			        const 实际输出物品 = 克隆物品(融合结果);
			        if (尝试收集物品(实际输出物品, true)) {
			const tempFusionItems = [...originalFusionSlotItems];
			配方.输入.forEach(requiredName => {
			    const foundIndex = tempFusionItems.findIndex(item => item && item.名称 === requiredName);
			    if (foundIndex !== -1) {
			        const itemToConsume = tempFusionItems.splice(foundIndex, 1)[0];
			        consumedItemSymbols.add(itemToConsume.唯一标识);
			    }
			});
			显示通知(`成功融合出 ${实际输出物品.获取名称()}！`, "成功");
			        } else {
			显示通知("融合失败：无法将产物放入背包！", "错误");
			const 能量条 = document.querySelector(".power-bar");
			const 当前能量 = parseFloat(能量条.style.width) || 0;
			if (能量条) 能量条.style.width = `${Math.min(100, 当前能量 + recipeEnergyCost/自定义全局设置.初始能量值*100)}%`;
			return;
			        }
			    } else if (当前匹配的融合配方 === "磨刀石打磨") {
			        const 磨刀石实例 = originalFusionSlotItems.find(item => item instanceof 磨刀石);
			        const 武器实例 = originalFusionSlotItems.find(item => item instanceof 武器类);
			        const energyCost = 15;
			        if (!扣除能量(energyCost)) {
			显示通知(`能量不足！需要 ${energyCost} 点能量。`, "错误");
			return;
			        }
			
			        const buffs = 武器实例.自定义数据.get("fusedBuffs") || [];
			        const buffUses = 20 + Math.floor(prng() * 11);
			        
			        let attackBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石攻击加成);
			        if (attackBuff) {
			attackBuff.value += 1;
			attackBuff.usesLeft = (attackBuff.usesLeft || 0) + buffUses;
			        } else {
			buffs.push({ type: 融合Buff类型.磨刀石攻击加成, value: 1, usesLeft: buffUses });
			        }
			        
			        let cooldownBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石冷却缩减);
			        if (cooldownBuff) {
			cooldownBuff.value += 1;
			cooldownBuff.usesLeft = (cooldownBuff.usesLeft || 0) + buffUses;
			        } else {
			buffs.push({ type: 融合Buff类型.磨刀石冷却缩减, value: 1, usesLeft: buffUses });
			        }
			        
			        武器实例.自定义数据.set("fusedBuffs", buffs);
			        if (武器实例.自定义数据.has('锈蚀度')) {
			            武器实例.自定义数据.set('锈蚀度', 0);
			            显示通知(`${武器实例.获取名称()} 被成功打磨，锈迹斑斑的表面焕然一新！`, "成功");
			        } else {
			            显示通知(`${武器实例.获取名称()} 被成功打磨！`, "成功");
			        }
			        磨刀石实例.自定义数据.set("耐久", 磨刀石实例.自定义数据.get("耐久") - 1);
			       
			        if(磨刀石实例.自定义数据.get("耐久") <= 0) {
			consumedItemSymbols.add(磨刀石实例.唯一标识);
			        } else {
			            从融合区移除(0);
			        }
			        从融合区移除(1)
			        从融合区移除(2)
			        从融合区移除(3)
			
			    } else if (当前匹配的融合配方 === "装备融合") {
			        const item1 = originalFusionSlotItems[0];
			        const item2 = originalFusionSlotItems[1];
			
			        if(!item1 || !item2 || !(item1 instanceof 武器类 || item1 instanceof 防御装备类) || !(item2 instanceof 武器类 || item2 instanceof 防御装备类)){
			显示通知("融合错误：只有武器或装备才能进行此类融合！", "错误");
			return;
			        }
			
			        const equipFusionEnergyCost = 20 + (item1.品质 + item2.品质) * 5;
			        if (!扣除能量(equipFusionEnergyCost)) {
			显示通知(`能量不足！需要 ${equipFusionEnergyCost} 点能量。`, "错误");
			return;
			        }
			        
			        const mergedItem = 克隆物品(融合结果);
			        mergedItem.唯一标识 = Symbol("MergedEquip_" + Date.now());
			        mergedItem.是否隐藏 = false;
			        
			        consumedItemSymbols.add(item1.唯一标识);
			        consumedItemSymbols.add(item2.唯一标识);
			        
			        if (尝试收集物品(mergedItem, true)) {
			显示通知(`${mergedItem.获取名称()} 融合成功！`, "成功");
			        } else {
			显示通知("融合失败：无法将产物放入背包！", "错误");
			return;
			        }
			    } else if (当前匹配的融合配方 === "词条融合") {
			        const 武器原件 = originalFusionSlotItems[0];
			        if (!武器原件 || !是否为有效融合武器(武器原件)) {
			显示通知("融合错误：原始武器无效！", "错误");
			return;
			        }
			
			        const 待消耗材料实例 = [];
			        let 总计消耗金币数量 = 0;
			
			        for (let i = 1; i <= 3; i++) {
			const 物品 = originalFusionSlotItems[i];
			if (物品) {
			    if (物品 instanceof 金币 && fusionGoldQuantities[i] > 0) {
			        总计消耗金币数量 += fusionGoldQuantities[i];
			    } else if (!(物品 instanceof 金币) && 是否为有效融合材料(物品)) {
			        待消耗材料实例.push(物品);
			    }
			}
			        }
			        
			        const energyCostBuff = 10 + 待消耗材料实例.length * 3 + 总计消耗金币数量 * 0.5;
			        if (!扣除能量(energyCostBuff)) {
			显示通知(`能量不足！需要 ${energyCostBuff} 点能量。`, "错误");
			return;
			        }
			
			        待消耗材料实例.forEach(材料 => consumedItemSymbols.add(材料.唯一标识));
			        if (总计消耗金币数量 > 0) {
			originalFusionSlotItems.forEach((item, index) => {
			    if(item instanceof 金币 && fusionGoldQuantities[index] > 0) {
			        consumedItemSymbols.add(item.唯一标识);
			        consumedGoldQuantities[index] = fusionGoldQuantities[index];
			    }
			});
			        }
			        
			        const 应用的Buffs = 融合结果.自定义数据.get("fusedBuffs");
			        if (应用的Buffs && 应用的Buffs.length > 0) {
			 const 旧Buffs = 武器原件.自定义数据.get("fusedBuffs") || [];
			 武器原件.自定义数据.set("fusedBuffs", 合并Buff列表(旧Buffs, 应用的Buffs));
			 const materialChangeBuff = 应用的Buffs.find(b => b.type === 'MATERIAL_CHANGE');
			 if (materialChangeBuff) {
			     武器原件.材质 = materialChangeBuff.value;
			 }
			 const rustIncreaseBuff = 应用的Buffs.find(b => b.type === 'RUST_INCREASE');
			 if (rustIncreaseBuff) {
			     let rust = 武器原件.自定义数据.get('锈蚀度') || 0;
			     武器原件.自定义数据.set('锈蚀度', rust + rustIncreaseBuff.value);
			 }
			 const 耐久倍率 = 应用的Buffs.find(b => b.type === 'DURABILITY_MULTIPLIER');
			 if (耐久倍率) {
			     武器原件.自定义数据.set('原耐久',Math.round(武器原件.自定义数据.get('原耐久')*(1+耐久倍率.value)*10)/10);
			     武器原件.自定义数据.set('耐久',Math.round(武器原件.自定义数据.get('耐久')*(1+耐久倍率.value)*10)/10);
			 }
			 const 耐久加成 = 应用的Buffs.find(b => b.type === 'DURABILITY_BONUS');
			 if (耐久加成) {
			     武器原件.自定义数据.set('原耐久',武器原件.自定义数据.get('原耐久')+耐久加成.value);
			     武器原件.自定义数据.set('耐久',武器原件.自定义数据.get('耐久')+耐久加成.value);
			 }
			 显示通知(`${武器原件.获取名称()} 强化成功！`, "成功");
			        } else {
			 显示通知(`${武器原件.获取名称()} 没有获得强化效果。`, "信息");
			        }
			    }
			
			    for (let i = 0; i < 4; i++) {
			        const 物品实例 = originalFusionSlotItems[i];
			        if (物品实例 && consumedItemSymbols.has(物品实例.唯一标识)) {
			if (物品实例 instanceof 金币) {
			
			} else {
			     处理销毁物品(物品实例.唯一标识,true);
			}
			融合区物品[i] = null;
			if (物品实例 instanceof 金币) fusionGoldQuantities[i] = 0;
			        }
			    }
			    
			    融合结果 = null;
			    当前匹配的融合配方 = null;
			    检查融合配方()
			    更新融合窗口();
			    更新背包显示();
			    更新装备显示();
			}
			function 检查融合配方(){
			    当前匹配的融合配方=null;
			    const 输出格子=document.getElementById("融合输出格子");
			    输出格子.innerHTML="";
			    融合结果=null;
			    输出格子.onclick=null;
			    const 融合槽有效条目=[];
			    for(let i=0;i<4;i++){
			        const 物品实例=融合区物品[i];
			        if(物品实例){
			if(物品实例 instanceof 金币){
			    if(fusionGoldQuantities[i]>0){
			        融合槽有效条目.push({item:物品实例,quantityInSlot:fusionGoldQuantities[i],});
			    }
			}else{
			    融合槽有效条目.push({item:物品实例,quantityInSlot:物品实例.堆叠数量,});
			}
			        }
			    }
			
			    if(融合槽有效条目.length===0){
			        return;
			    }
			
			    const 融合槽物品实例列表=融合槽有效条目.map((entry)=>entry.item);
			    const 融合槽物品名称列表_sorted=融合槽物品实例列表.map((item)=>item.名称).sort();
			
			    const 磨刀石实例=融合槽物品实例列表.find(item=>item instanceof 磨刀石);
			    const 武器实例ForSharpen=融合槽物品实例列表.find(item=>item instanceof 武器类);
			    const 融合区第一个是磨刀石=融合区物品[0] instanceof 磨刀石;
			
			    if(融合槽物品实例列表.length===2&&磨刀石实例&&武器实例ForSharpen&&融合区第一个是磨刀石){
			        if(磨刀石实例.自定义数据.get("耐久")>0){
			当前匹配的融合配方="磨刀石打磨";
			融合结果=克隆物品(武器实例ForSharpen);
			融合结果.唯一标识=Symbol("SharpenPreview_"+Date.now());
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			        }
			    }
			
			    const 附魔卷轴实例=融合槽物品实例列表.find((item)=>item instanceof 附魔卷轴&&item.自定义数据.get("已解锁"));
			    const 其他物品实例列表=融合槽物品实例列表.filter((item)=>!(item instanceof 附魔卷轴));
			
			    if(附魔卷轴实例&&其他物品实例列表.length===1){
			        const 目标物品实例=其他物品实例列表[0];
			        if(目标物品实例 instanceof 武器类||目标物品实例 instanceof 防御装备类){
			const 附魔兼容性={
			    火焰附魔:["武器","防御装备"],
			    保护附魔:["防御装备"],
			    耐久附魔:["武器","防御装备"],
			    锋利附魔:["武器"],
			    爆炸保护附魔:["防御装备"],
			    连锁附魔:["武器"],
			    荆棘附魔:["防御装备"],
			};
			const 附魔种类=附魔卷轴实例.当前附魔效果名;
			const 允许列表=附魔兼容性[附魔种类];
			let 兼容=允许列表&&允许列表.includes(目标物品实例.类型);
			if(兼容&&目标物品实例.自定义数据.get("附魔")?.some((e)=>e.种类===附魔种类&&e.等级>=附魔卷轴实例.品质)){
			    兼容=false;
			}
			
			if(兼容){
			    当前匹配的融合配方="卷轴附魔融合";
			    融合结果=克隆物品(目标物品实例);
			    const 输入物品是否有不可破坏=[附魔卷轴实例,目标物品实例].some(item=>item.自定义数据?.get("不可破坏"));
			    if(输入物品是否有不可破坏){
			        融合结果.自定义数据.set("不可破坏",true);
			    }
			    const 预览元素=融合结果.生成显示元素("融合");
			    const 附魔提示=document.createElement("div");
			    附魔提示.textContent=`将被附魔: ${附魔种类} (${附魔卷轴实例.品质}级)`;
			    附魔提示.style.color="cyan";
			    附魔提示.style.fontSize="0.8em";
			    附魔提示.style.textAlign="center";
			    预览元素.appendChild(附魔提示);
			    输出格子.appendChild(预览元素);
			    输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			    return;
			}
			        }
			    }
			
			    const firstSlotItem=融合区物品[0];
			    if(firstSlotItem&&firstSlotItem instanceof 药水类){
			        let onlyPotionAndGold=true;
			        let totalGold=0;
			        if(融合槽有效条目.length>1){
			for(let i=1;i<4;i++){
			    const itemSymbol=融合区物品[i];
			    if(itemSymbol){
			        const item=itemSymbol;
			        if(item instanceof 金币&&fusionGoldQuantities[i]>0){
			            totalGold+=fusionGoldQuantities[i];
			        }else{
			            onlyPotionAndGold=false;
			            break;
			        }
			    }
			}
			        }else{
			onlyPotionAndGold=false;
			        }
			
			        if(onlyPotionAndGold&&totalGold>0){
			const 新药水=克隆物品(firstSlotItem);
			const 原基础持续=新药水.自定义数据.get("基础持续时间")||3;
			const 延长回合=totalGold;
			新药水.自定义数据.set("基础持续时间",原基础持续+延长回合);
			新药水.效果描述=(新药水.效果描述||"").replace(/持续\s*\d+\s*回合/g,`持续 ${新药水.持续时间} 回合`);
			新药水.唯一标识=Symbol("FusionPotionExtendPreview_"+Date.now());
			融合结果=新药水;
			当前匹配的融合配方="药水金币延长";
			
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			        }
			    }
			
			    const combinedRecipeList=[...已发现的程序生成配方,...融合配方列表,];
			
			    for(const 配方 of combinedRecipeList){
			        const sortedRecipeInputs=[...配方.输入].sort();
			        if(融合槽物品名称列表_sorted.length===sortedRecipeInputs.length&&
			融合槽物品名称列表_sorted.every((name,index)=>name===sortedRecipeInputs[index])){
			const 输出类构造器=window[配方.输出类];
			if(输出类构造器){
			    const 输出配置=配方.输出配置?{...配方.输出配置}:{};
			    const 输入物品是否有不可破坏=融合槽物品实例列表.some(item=>item.自定义数据?.get("不可破坏"));
			    融合结果=new 输出类构造器(输出配置);
			    融合结果.堆叠数量=配方.输出数量||1;
			    融合结果.唯一标识=Symbol("FusionRecipePreview_"+Date.now());
			    if(输入物品是否有不可破坏){
			        融合结果.自定义数据.set("不可破坏",true);
			    }
			    当前匹配的融合配方=配方;
			    const 预览元素=融合结果.生成显示元素("融合");
			    预览元素.style.cursor="pointer";
			    输出格子.appendChild(预览元素);
			    输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			    return;
			}
			        }
			    }
			
			    if(融合槽有效条目.length===2){
			        const item1=融合槽有效条目[0].item;
			        const item2=融合槽有效条目[1].item;
			        if(item1&&item2&&item1.名称===item2.名称&&
			(item1 instanceof 武器类||item1 instanceof 防御装备类)&&
			(item2 instanceof 武器类||item2 instanceof 防御装备类)&&
			item1.constructor.name===item2.constructor.name){
			
			融合结果=克隆物品(item1);
			融合结果.唯一标识=Symbol("FusionEquipPreview_"+Date.now());
			当前匹配的融合配方="装备融合";
			const mergedBuffs=合并Buff列表(item1.自定义数据.get("fusedBuffs"),item2.自定义数据.get("fusedBuffs"));
			if(mergedBuffs.length>0)
			    融合结果.自定义数据.set("fusedBuffs",mergedBuffs);
			else 融合结果.自定义数据.delete("fusedBuffs");
			const mergedEnchantments=合并附魔列表(item1.自定义数据.get("附魔"),item2.自定义数据.get("附魔"));
			融合结果.自定义数据.set("附魔",mergedEnchantments);
			const item1Dur=item1.自定义数据.get("耐久")||0;
			const item1MaxDur=item1.自定义数据.get("原耐久")||item1Dur;
			const item2Dur=item2.自定义数据.get("耐久")||0;
			const item2MaxDur=item2.自定义数据.get("原耐久")||item2Dur;
			const newMaxDur=item1MaxDur+Math.floor(item2MaxDur*0.3);
			const newCurrDur=Math.min(newMaxDur,item1Dur+Math.floor(item2Dur*0.7));
			融合结果.自定义数据.set("耐久",newCurrDur);
			融合结果.自定义数据.set("原耐久",newMaxDur);
			融合结果.强化=item1.强化||item2.强化;
			if(item1.自定义数据.get("不可破坏")||item2.自定义数据.get("不可破坏")){
			    融合结果.自定义数据.set("不可破坏",true);
			}else{
			    融合结果.自定义数据.delete("不可破坏");
			}
			
			融合结果.品质=Math.max(item1.品质,item2.品质);
			融合结果.颜色索引=融合结果.品质-1;
			
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			        }
			    }
			
			    const 武器槽实例=融合区物品[0];
			    if(武器槽实例&&是否为有效融合武器(武器槽实例)){
			        const 材料实例列表=[];
			        let 金币总量=0;
			
			        for(let i=1;i<4;i++){
			const 物品=融合区物品[i];
			if(物品){
			    if(物品 instanceof 金币){
			        金币总量+=fusionGoldQuantities[i];
			    }else if(是否为有效融合材料(物品)){
			        材料实例列表.push(物品);
			    }
			}
			        }
			
			        if(材料实例列表.length>0||金币总量>0){
			const buffs=计算融合Buff(武器槽实例,材料实例列表,金币总量);
			融合结果=克隆物品(武器槽实例);
			融合结果.唯一标识=Symbol("FusionBuffPreview_"+Date.now());
			当前匹配的融合配方="词条融合";
			const 输入物品是否有不可破坏=[武器槽实例,...材料实例列表].some(item=>item.自定义数据?.get("不可破坏"));
			if(输入物品是否有不可破坏){
			    融合结果.自定义数据.set("不可破坏",true);
			}
			
			if(buffs.length>0){
			    融合结果.自定义数据.set("fusedBuffs",buffs);
			}else{
			    融合结果.自定义数据.delete("fusedBuffs");
			}
			
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			        }
			        
			    }
			    if (融合区物品[0] && 融合区物品[1] && 融合区物品[0].材质 === 材料.木质 && 融合区物品[1] instanceof 药水类){
			        当前匹配的融合配方="木材转化融合";
			        融合结果=克隆物品(融合区物品[0]);
			融合结果.唯一标识=Symbol("MaterialChangePreview_"+Date.now());
			融合结果.材质=材料.普通;
			const 预览元素=融合结果.生成显示元素("融合");
			预览元素.style.cursor="pointer";
			输出格子.appendChild(预览元素);
			输出格子.onclick=()=>setTimeout(()=>执行融合(),0);
			return;
			    }
			}
			
			function 更新融合窗口() {
			    const 窗口 = document.getElementById("融合窗口");
			    if (!窗口) return;
			
			    for (let i = 1; i <= 4; i++) {
			        const 格子 = document.getElementById(`融合区格子${i}`);
			        格子.innerHTML = "";
			        格子.onclick = () =>
			            setTimeout(() => {
			                从融合区移除(i - 1);
			            }, 0);
			    }
			
			    融合区物品.forEach((物品实例, index) => {
			        if (物品实例 !== null) {
			            const 格子 = document.getElementById(
			                `融合区格子${index + 1}`
			            );
			            const 物品元素 = 物品实例.生成显示元素("融合");
			            物品元素.style.cursor = "pointer";
			
			            if (物品实例 instanceof 金币) {
			                let 堆叠元素 = 物品元素.querySelector(".物品堆叠");
			                if (!堆叠元素) {
			                    堆叠元素 = document.createElement("div");
			                    堆叠元素.className = "物品堆叠";
			                    物品元素.appendChild(堆叠元素);
			                }
			                堆叠元素.textContent = `x${fusionGoldQuantities[index]}`;
			            } else {
			                 const 堆叠元素 = 物品元素.querySelector(".物品堆叠");
			                 if (堆叠元素) 堆叠元素.remove();
			            }
			            
			            格子.appendChild(物品元素);
			        }
			    });
			
			    const 输出格子 = document.getElementById("融合输出格子");
			    输出格子.innerHTML = "";
			    输出格子.onclick = null;
			    if (融合结果) {
			        const 结果元素 = 融合结果.生成显示元素("融合");
			        结果元素.style.cursor = "pointer";
			        输出格子.appendChild(结果元素);
			        输出格子.onclick = () =>
			            setTimeout(() => {
			                执行融合();
			            }, 0);
			    }
			}
			
			function 清空融合区() {
			    for (let i = 0; i < 融合区物品.length; i++) {
			        
			        if (
			            融合区物品[i] !== null &&
			            玩家背包.get(融合区物品[i]) instanceof 金币
			        ) {
			            const goldToReturn = fusionGoldQuantities[i];
			            if (goldToReturn > 0) {
			                尝试收集物品(
			                    new 金币({ 数量: goldToReturn }),
			                    true
			                );
			            }
			            玩家背包.get(融合区物品[i]).是否隐藏 = false;
			            fusionGoldQuantities[i] = 0;
			            融合区物品[i] = null;
			        } else if (融合区物品[i] !== null) {
			            从融合区移除(i); 
			        }
			    }
			    融合结果 = null;
			    更新融合窗口();
			    更新背包显示(); 
			}
			
			let 已发现的程序生成配方 = [];
			let 程序生成配方列表 = [];
			function 生成单个随机融合配方(层数) {
			    const MAX_ATTEMPTS = 50;
			    for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
			        const numInputs = Math.round(prng() * 0.7) + 2; 
			        const inputs = [];
			        const inputItemNames = [];
			
			        const 可用物品池 = Object.values(物品池)
			            .flat()
			            .filter(
			                (itemCfg) =>
			                    itemCfg.最小层 <= 层数 &&
			                    (itemCfg.类 instanceof 物品 && new itenCfg.类({}).是否正常物品) &&
			                    itemCfg.类.name !== "配方卷轴" &&
			                    itemCfg.类.name !== "神秘商人" &&
			                    itemCfg.类.name !== "探险家" &&
			                    itemCfg.类.name !== "物品祭坛" &&
			                    itemCfg.类.name !== "耐久祭坛" &&
			                    itemCfg.类.name !== "背包扩容祭坛" &&
			                    itemCfg.类.name !== "重铸台" &&
			                    itemCfg.类.name !== "折跃门" &&
			                    itemCfg.类.name !== "寻宝戒指" &&
			                    itemCfg.类.name !== "罐子" &&
			                    itemCfg.类.name !== "洗身砚" &&
			                    itemCfg.类.name !== "神龛" &&
			                    itemCfg.类.name !== "挑战石碑"
			            );
			
			        if (
			            可用物品池.length < numInputs &&
			            !(
			                numInputs === 2 &&
			                可用物品池.length === 1 &&
			                prng() < 0.5
			            )
			        )
			            continue; 
			
			        let canUseSpecial = true; 
			        for (let i = 0; i < numInputs; i++) {
			            let selectedItemConfig;
			            if (canUseSpecial && prng() < 0.3) {
			                
			                if (prng() < 0.7 && 层数 >= 0) {
			                    
			                    selectedItemConfig = {
			                        类: 金币,
			                        name: "金币",
			                        isSpecial: true,
			                        品质: 1,
			                    };
			                } else if (层数 >= 1) {
			                    
			                    selectedItemConfig = {
			                        类: 钥匙,
			                        name: "钥匙",
			                        isSpecial: true,
			                        品质: 1,
			                    };
			                } else if (可用物品池.length > 0) {
			                    selectedItemConfig =
			                        可用物品池[
			                            Math.floor(
			                                prng() * 可用物品池.length
			                            )
			                        ];
			                } else {
			                    continue; 
			                }
			                if (selectedItemConfig.isSpecial)
			                    canUseSpecial = false; 
			            } else if (可用物品池.length > 0) {
			                selectedItemConfig =
			                    可用物品池[
			                        Math.floor(
			                            prng() * 可用物品池.length
			                        )
			                    ];
			            } else {
			                break; 
			            }
			
			            if (selectedItemConfig) {
			                const tempInstance = new selectedItemConfig.类({});
			                inputs.push(tempInstance.名称); 
			                inputItemNames.push(tempInstance.名称);
			            }
			        }
			
			        if (inputs.length !== numInputs) continue; 
			
			        
			        const outputPool = 可用物品池.filter(
			            (itemCfg) =>
			                (!inputItemNames.includes(
			                    new itemCfg.类({}).名称
			                ) && 
			                    itemCfg.品质 >
			                        Math.min(
			                            ...inputs.map(
			                                (name) =>
			                                    (
			                                        可用物品池.find(
			                                            (cfg) =>
			                                                new cfg.类({})
			                                                    .名称 === name
			                                        ) || { 品质: 1 }
			                                    ).品质
			                            )
			                        ))
			        );
			
			        if (outputPool.length === 0) continue;
			        const outputItemConfig =
			            outputPool[
			                Math.floor(prng() * outputPool.length)
			            ];
			        const outputInstance = new outputItemConfig.类({});
			
			        const recipe = {
			            输入: inputs.sort(),
			            输出类: outputItemConfig.类.name,
			            输出类名称: outputInstance.名称,
			            输出数量: 1,
			            输出配置: {
			                品质: outputInstance.品质,
			                强化: true,
			            },
			            说明: `${inputItemNames.join(" + ")} = ${
			                outputInstance.名称
			            }[强]`,
			            发现层数: 层数,
			        };
			
			        
			        const existingRecipe = 程序生成配方列表.find(
			            (r) =>
			                r.输出类名称 === recipe.输出类名称 &&
			                r.输入.length === recipe.输入.length &&
			                r.输入.every(
			                    (val, index) => val === recipe.输入[index]
			                )
			        );
			        const existingHardcodedRecipe = 融合配方列表.find(
			            (r) =>
			                (r.输出类名称 || r.输出类) === recipe.输出类名称 &&
			                r.输入.length === recipe.输入.length &&
			                r.输入.every(
			                    (val, index) => val === recipe.输入[index]
			                )
			        );
			
			        if (!existingRecipe && !existingHardcodedRecipe) {
			            程序生成配方列表.push(recipe);
			            return recipe;
			        }
			    }
			    return null;
			}
			
			function 生成并放置随机配方卷轴(层数) {
			    if (层数 === null || 层数 < 0 || 是否为教程层) {
			        return;
			    }

			    
			    const 卷轴数量 = 1 + Math.floor(prng() * 层数);
			    let 成功放置数量 = 0;

			    for (let i = 0; i < 卷轴数量; i++) {
			        
			        const 新配方 = 生成单个随机融合配方(层数);

			        if (新配方) {
			            console.log(`为第 ${层数} 层生成了新的配方知识: ${新配方.说明}`);

			            const 配方物品 = new 配方卷轴({
			                recipeData: 新配方,
			                层数: 层数,
			            });

			            
			            const 可用房间 = 房间列表.filter(
			                (房间) => 房间.类型 === "房间" && !上锁房间列表.some(r => r.id === 房间.id)
			            );

			            if (可用房间.length > 0) {
			                
			                const 目标房间 = 可用房间[Math.floor(prng() * 可用房间.length)];
			                if (放置物品到房间(配方物品, 目标房间)) {
			                    成功放置数量++;
			                } else {
			                    console.warn(`无法在房间 ${目标房间.id} 为配方 "${新配方.说明}" 找到放置位置。`);
			                }
			            } else {
			                console.warn("没有找到合适的房间来放置配方卷轴。");
			            }
			        }
			    }

			    if (成功放置数量 > 0) {
			        console.log(`在第 ${层数} 层成功放置了 ${成功放置数量} 个配方卷轴。`);
			    }
			}
			
			function 合并Buff列表(list1, list2) {
			    const merged = new Map();
			
			    function addOrUpdateBuff(buff) {
			        const existing = merged.get(buff.type);
			        if (existing) {
			            if (
			                typeof existing.value === "number" &&
			                typeof buff.value === "number"
			            ) {
			                existing.value += buff.value;
			                let 上限 = 1.0;
			                if (
			                    buff.type.includes("MULTIPLIER") ||
			                    buff.type.includes("CHANCE") ||
			                    buff.type.includes("STEAL") ||
			                    buff.type.includes("PERCENT")
			                ) {
			                    上限 =
			                        {
			                            [融合Buff类型.攻击倍率]: 0.75,
			                            [融合Buff类型.冷却倍率]: 0.9,
			                            [融合Buff类型.耐久倍率]: 1.5,
			                            [融合Buff类型.防御倍率]: 0.75,
			                            [融合Buff类型.中毒几率]: 0.8,
			                            [融合Buff类型.冰冻几率]: 0.8,
			                            [融合Buff类型.生命偷取]: 0.7,
			                            [融合Buff类型.击退几率]: 0.8,
			                            [融合Buff类型.攻击吸能]: 0.7,
			                            [融合Buff类型.火焰伤害]: 0.8,
			                            [融合Buff类型.闪避几率]: 0.7,
			                            [融合Buff类型.暴击几率]: 0.6,
			                            [融合Buff类型.暴击伤害倍率]: 2.5,
			                        }[buff.type] || 1.0;
			                    existing.value = Math.min(existing.value, 上限);
			                } else if (buff.type === 融合Buff类型.冷却缩减) {
			                    
			                    上限 = 5;
			                    existing.value = Math.max(
			                        0,
			                        Math.min(existing.value, 上限)
			                    );
			                } else if (
			                    buff.type === 融合Buff类型.固定伤害减免
			                ) {
			                    上限 = 10;
			                    existing.value = Math.min(existing.value, 上限);
			                } else if (buff.type === 融合Buff类型.受击回能) {
			                    上限 = 30;
			                    existing.value = Math.min(existing.value, 上限);
			                } else if (buff.type === 融合Buff类型.范围加成) {
			                    上限 = 5;
			                    existing.value = Math.min(existing.value, 上限);
			                } else if (buff.type.includes("加成")) {
			                    existing.value = Math.min(existing.value, 15);
			                }
			            }
			        } else {
			            merged.set(buff.type, { ...buff });
			        }
			    }
			
			    (list1 || []).forEach(addOrUpdateBuff);
			    (list2 || []).forEach(addOrUpdateBuff);
			
			    return Array.from(merged.values());
			}
			
			function 合并附魔列表(list1, list2) {
			    const merged = new Map();
			
			    function addOrUpdateEnchantment(enchant) {
			        const existing = merged.get(enchant.种类);
			        if (existing) {
			            if (enchant.等级 > existing.等级) {
			                merged.set(enchant.种类, { ...enchant });
			            }
			        } else {
			            merged.set(enchant.种类, { ...enchant });
			        }
			    }
			    (list1 || []).forEach(addOrUpdateEnchantment);
			    (list2 || []).forEach(addOrUpdateEnchantment);
			    return Array.from(merged.values());
			}
			
			function 哈希字符串(str) {
			    let hash = 0;
			    if (!str || str.length === 0) return hash;
			    for (let i = 0; i < str.length; i++) {
			        const char = str.charCodeAt(i);
			        hash = (hash << 5) - hash + char;
			        hash |= 0;
			    }
			    return Math.abs(hash);
			}
			
			function 种子伪随机数(seed) {
			    let t = (seed += 0x6d2b79f5);
			    t = Math.imul(t ^ (t >>> 15), t | 1);
			    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
			    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
			}
			
			function 是否为有效融合武器(物品) {
			    return 物品 instanceof 武器类 || 物品 instanceof 防御装备类;
			}
			
			function 是否为有效融合材料(物品) {
			    return (
			        物品 instanceof 炸弹 ||
			        物品 instanceof 卷轴类 ||
			        物品.类型 === "药水" ||
			        物品 instanceof 钥匙
			    );
			}
			
			function 计算融合Buff(武器, 材料列表, 金币数量) {
			    if (!武器) return [];
			
			    const 基础种子字符串 = 武器.唯一标识.toString()+材料列表?.[0]?.实际唯一标识?.toString();
			    let 组合种子字符串 = 基础种子字符串;
			    const 有效材料 = 材料列表.filter((m) => m != null);
			    if (有效材料.length === 0 && 金币数量 === 0) return [];
			
			    有效材料.sort((a, b) =>
			        a.constructor.name.localeCompare(b.constructor.name)
			    );
			    有效材料.forEach(
			        (mat) => (组合种子字符串 += mat.constructor.name)
			    );
			    组合种子字符串 += 金币数量;
			
			    const 组合种子 = 哈希字符串(组合种子字符串);
			    const 最终Buff列表 = [];
			    const 金币增幅系数 =
			        1 + Math.log10(Math.max(1, (金币数量 || 0) / 2 + 1)) * 0.45;
			
			    const 是否武器 = 武器 instanceof 武器类;
			    const 是否防具 = 武器 instanceof 防御装备类;
			
			    有效材料.forEach((材料, 索引) => {
			        const 材料种子 = 哈希字符串(
			            组合种子字符串 + 索引 + 最终Buff列表.length
			        );
			        const 随机数生成 = () =>
			            种子伪随机数(材料种子 + 最终Buff列表.length);
			
			        let buff类型 = null;
			        let buff数值 = 0;
			        const 可能的Buff列表 = [];
			
			        if (材料 instanceof 炸弹) {
			            if (是否武器)
			                可能的Buff列表.push(
			                    融合Buff类型.攻击加成,
			                    融合Buff类型.火焰伤害,
			                    融合Buff类型.暴击几率,
			                    融合Buff类型.击退几率
			                );
			            if (是否防具)
			                可能的Buff列表.push(
			                    融合Buff类型.防御加成,
			                    融合Buff类型.固定伤害减免,
			                    融合Buff类型.火焰伤害
			                );
			            可能的Buff列表.push(融合Buff类型.耐久加成);
			        } else if (材料 instanceof 卷轴类) {
			            if (是否武器)
			                可能的Buff列表.push(
			                    融合Buff类型.冷却缩减,
			                    融合Buff类型.范围加成,
			                    融合Buff类型.攻击倍率,
			                    融合Buff类型.攻击吸能,
			                    融合Buff类型.暴击伤害倍率
			                );
			            if (是否防具)
			                可能的Buff列表.push(
			                    融合Buff类型.防御倍率,
			                    融合Buff类型.闪避几率,
			                    融合Buff类型.受击回能,
			                    融合Buff类型.中毒几率
			                );
			            可能的Buff列表.push(
			                融合Buff类型.冰冻几率,
			                融合Buff类型.耐久倍率
			            );
			        } else if (材料.类型 === "药水") {
			            if (是否武器)
			                可能的Buff列表.push(
			                    融合Buff类型.生命偷取,
			                    融合Buff类型.中毒几率,
			                    融合Buff类型.暴击伤害倍率,
			                    融合Buff类型.攻击吸能
			                );
			            if (是否防具)
			                可能的Buff列表.push(
			                    融合Buff类型.防御加成,
			                    融合Buff类型.受击回能,
			                    融合Buff类型.中毒几率
			                );
			            可能的Buff列表.push(融合Buff类型.耐久加成);
			        } else if (材料 instanceof 钥匙) {
			            if (是否武器) {
			                可能的Buff列表.push(融合Buff类型.幸运一击);
			                可能的Buff列表.push(融合Buff类型.暴击几率);
			            }
			            可能的Buff列表.push(融合Buff类型.耐久加成);
			        }
			
			        if (可能的Buff列表.length === 0) return;
			
			        buff类型 =
			            可能的Buff列表[
			                Math.floor(随机数生成() * 可能的Buff列表.length)
			            ];
			
			        switch (buff类型) {
			            case 融合Buff类型.攻击加成:
			                buff数值 = Math.round(
			                    (1 + 随机数生成() * 3) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.攻击倍率:
			                buff数值 = Math.min(
			                    0.3,
			                    (0.03 + 随机数生成() * 0.12) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.冷却缩减:
			                buff数值 = Math.round(
			                    (1 + 随机数生成() * 1) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.冷却倍率:
			                buff数值 = Math.min(
			                    0.5,
			                    (0.05 + 随机数生成() * 0.15) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.耐久加成:
			                if (材料 instanceof 钥匙) {
			                    buff数值 = Math.round(
			                        (2 +
			                            随机数生成() * 5 +
			                            (金币数量 > 0 ? 金币数量 / 5 : 0)) *
			                            金币增幅系数 *
			                            0.8
			                    );
			                } else {
			                    buff数值 = Math.round(
			                        (5 + 随机数生成() * 20) * 金币增幅系数
			                    );
			                }
			                break;
			            case 融合Buff类型.耐久倍率:
			                buff数值 = Math.min(
			                    1.5,
			                    (0.1 + 随机数生成() * 0.25) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.范围加成:
			                buff数值 =
			                    是否武器 &&
			                    武器.自定义数据.has("攻击范围") &&
			                    武器.自定义数据.get("攻击范围") > 1 &&
			                    随机数生成() < 0.7
			                        ? Math.round(1 * 金币增幅系数)
			                        : 0;
			                break;
			            case 融合Buff类型.防御加成:
			                buff数值 = Math.round(
			                    (1 + 随机数生成() * 2) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.防御倍率:
			                buff数值 = Math.min(
			                    0.3,
			                    (0.05 + 随机数生成() * 0.1) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.中毒几率:
			            case 融合Buff类型.冰冻几率:
			            case 融合Buff类型.生命偷取:
			            case 融合Buff类型.击退几率:
			            case 融合Buff类型.攻击吸能:
			            case 融合Buff类型.火焰伤害:
			            case 融合Buff类型.闪避几率:
			                buff数值 = Math.min(
			                    0.4,
			                    (0.05 + 随机数生成() * 0.2) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.暴击几率:
			                if (材料 instanceof 钥匙) {
			                    let 基础值 = 0.025;
			                    let 品质加成 = 材料.品质 * 0.018;
			                    let 金币效应 =
			                        金币数量 > 10
			                            ? 0.025
			                            : 金币数量 > 0
			                            ? 0.012
			                            : 0;
			                    buff数值 = Math.min(
			                        0.22,
			                        (基础值 + 品质加成 + 金币效应) *
			                            金币增幅系数
			                    );
			                } else {
			                    buff数值 = Math.min(
			                        0.25,
			                        (0.03 + 随机数生成() * 0.1) * 金币增幅系数
			                    );
			                }
			                break;
			            case 融合Buff类型.暴击伤害倍率:
			                buff数值 = Math.min(
			                    1.0,
			                    (0.1 + 随机数生成() * 0.4) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.固定伤害减免:
			                buff数值 = Math.round(
			                    (1 + 随机数生成() * 1) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.受击回能:
			                buff数值 = Math.round(
			                    (3 + 随机数生成() * 7) * 金币增幅系数
			                );
			                break;
			            case 融合Buff类型.幸运一击:
			                if (材料 instanceof 钥匙) {
			                    let 基础值 = 0.035;
			                    let 品质加成 = 材料.品质 * 0.022;
			                    let 金币效应 =
			                        金币数量 > 10
			                            ? 0.03
			                            : 金币数量 > 0
			                            ? 0.018
			                            : 0;
			                    buff数值 = Math.min(
			                        0.28,
			                        (基础值 + 品质加成 + 金币效应) *
			                            金币增幅系数
			                    );
			                } else {
			                    buff数值 = Math.min(
			                        0.25,
			                        (0.02 +
			                            材料.品质 * 0.015 +
			                            (武器.品质 - 1) * 0.01) *
			                            金币增幅系数
			                    );
			                }
			                break;
			            default:
			                buff数值 = 0;
			        }
			
			        if (
			            buff数值 !== null &&
			            buff数值 !== undefined &&
			            !isNaN(buff数值) &&
			            Math.abs(buff数值) > 0.001
			        ) {
			            const 已存在Buff索引 = 最终Buff列表.findIndex(
			                (b) => b.type === buff类型
			            );
			            if (已存在Buff索引 > -1) {
			                if (
			                    typeof 最终Buff列表[已存在Buff索引].value ===
			                        "number" &&
			                    typeof buff数值 === "number"
			                ) {
			                    最终Buff列表[已存在Buff索引].value += buff数值;
			                    let 上限 = 1.0;
			                    if (
			                        buff类型.includes("MULTIPLIER") ||
			                        buff类型.includes("CHANCE") ||
			                        buff类型.includes("STEAL") ||
			                        buff类型.includes("PERCENT")
			                    ) {
			                        上限 =
			                            {
			                                [融合Buff类型.攻击倍率]: 0.75,
			                                [融合Buff类型.冷却倍率]: 0.9,
			                                [融合Buff类型.耐久倍率]: 1.5,
			                                [融合Buff类型.防御倍率]: 0.75,
			                                [融合Buff类型.中毒几率]: 0.8,
			                                [融合Buff类型.冰冻几率]: 0.8,
			                                [融合Buff类型.生命偷取]: 0.7,
			                                [融合Buff类型.击退几率]: 0.8,
			                                [融合Buff类型.攻击吸能]: 0.7,
			                                [融合Buff类型.火焰伤害]: 0.8,
			                                [融合Buff类型.闪避几率]: 0.7,
			                                [融合Buff类型.暴击几率]: 0.6,
			                                [融合Buff类型.暴击伤害倍率]: 2.5,
			                            }[buff类型] || 1.0;
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                上限
			                            );
			                    } else if (buff类型 === 融合Buff类型.冷却缩减) {
			                        
			                        上限 = 5;
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.max(
			                                0,
			                                Math.min(
			                                    最终Buff列表[已存在Buff索引]
			                                        .value,
			                                    上限
			                                )
			                            );
			                    } else if (
			                        buff类型 === 融合Buff类型.固定伤害减免
			                    ) {
			                        上限 = 10;
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                上限
			                            );
			                    } else if (buff类型 === 融合Buff类型.受击回能) {
			                        上限 = 30;
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                上限
			                            );
			                    } else if (
			                        buff类型 === 融合Buff类型.范围加成 &&
			                        武器.自定义数据.has("攻击范围")
			                    ) {
			                        上限 = Math.floor(
			                            武器.自定义数据.get("攻击范围") * 0.5
			                        );
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                上限
			                            );
			                    } else if (buff类型.includes("加成")) {
			                        最终Buff列表[已存在Buff索引].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引].value,
			                                15
			                            );
			                    }
			                }
			            } else {
			                最终Buff列表.push({
			                    type: buff类型,
			                    value: buff数值,
			                });
			            }
			        }
			    });
			
			    if (有效材料.length === 0 && 金币数量 >= 10) {
			        const 金币随机数 = 种子伪随机数(组合种子 + 1);
			        if (
			            金币随机数 <
			            (0.45 + Math.log10(金币数量 / 5 + 1) * 0.1) *
			                金币增幅系数
			        ) {
			            let 所有可能Buff_gold;
			            if (是否武器) {
			                所有可能Buff_gold = [
			                    融合Buff类型.攻击加成,
			                    融合Buff类型.攻击倍率,
			                    融合Buff类型.冷却缩减,
			                    融合Buff类型.耐久加成,
			                    融合Buff类型.暴击几率,
			                    融合Buff类型.范围加成,
			                    融合Buff类型.中毒几率,
			                    融合Buff类型.冰冻几率,
			                    融合Buff类型.火焰伤害,
			                    融合Buff类型.幸运一击,
			                ];
			            } else if (是否防具) {
			                所有可能Buff_gold = [
			                    融合Buff类型.防御加成,
			                    融合Buff类型.防御倍率,
			                    融合Buff类型.耐久加成,
			                    融合Buff类型.闪避几率,
			                    融合Buff类型.固定伤害减免,
			                    融合Buff类型.受击回能,
			                    融合Buff类型.中毒几率,
			                ];
			            } else {
			                所有可能Buff_gold = [融合Buff类型.耐久加成];
			            }
			
			            const 随机Buff类型 =
			                所有可能Buff_gold[
			                    Math.floor(
			                        种子伪随机数(组合种子 + 2) *
			                            所有可能Buff_gold.length
			                    )
			                ];
			            let 随机Buff数值 = 0;
			            switch (随机Buff类型) {
			                case 融合Buff类型.攻击加成:
			                    随机Buff数值 = Math.round(
			                        (1 + 种子伪随机数(组合种子 + 3) * 1.5) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.攻击倍率:
			                    随机Buff数值 = Math.min(
			                        0.1,
			                        (0.01 + 种子伪随机数(组合种子 + 4) * 0.04) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.冷却缩减:
			                    随机Buff数值 = Math.round(
			                        种子伪随机数(组合种子 + 5) *
			                            1 *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.耐久加成:
			                    随机Buff数值 = Math.round(
			                        (5 + 种子伪随机数(组合种子 + 6) * 15) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.防御加成:
			                    随机Buff数值 = Math.round(
			                        (1 + 种子伪随机数(组合种子 + 7) * 1) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.防御倍率:
			                    随机Buff数值 = Math.min(
			                        0.15,
			                        (0.02 + 种子伪随机数(组合种子 + 8) * 0.05) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.暴击几率:
			                    随机Buff数值 = Math.min(
			                        0.08,
			                        (0.01 +
			                            种子伪随机数(组合种子 + 9) * 0.025) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.范围加成:
			                    if (
			                        是否武器 &&
			                        武器.自定义数据.has("攻击范围") &&
			                        武器.自定义数据.get("攻击范围") > 1
			                    )
			                        随机Buff数值 = Math.round(1 * 金币增幅系数);
			                    else 随机Buff数值 = 0;
			                    break;
			                case 融合Buff类型.闪避几率:
			                    随机Buff数值 = Math.min(
			                        0.05,
			                        (0.01 +
			                            种子伪随机数(组合种子 + 10) * 0.02) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.固定伤害减免:
			                    随机Buff数值 = Math.round(
			                        种子伪随机数(组合种子 + 11) *
			                            1 *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.受击回能:
			                    随机Buff数值 = Math.round(
			                        (2 + 种子伪随机数(组合种子 + 12) * 5) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.中毒几率:
			                    随机Buff数值 = Math.min(
			                        0.15,
			                        (0.02 +
			                            种子伪随机数(组合种子 + 13) * 0.05) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.冰冻几率:
			                    随机Buff数值 = Math.min(
			                        0.15,
			                        (0.02 +
			                            种子伪随机数(组合种子 + 14) * 0.05) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.火焰伤害:
			                    随机Buff数值 = Math.min(
			                        0.15,
			                        (0.02 +
			                            种子伪随机数(组合种子 + 15) * 0.05) *
			                            金币增幅系数
			                    );
			                    break;
			                case 融合Buff类型.幸运一击:
			                    随机Buff数值 = Math.min(
			                        0.12,
			                        (0.015 +
			                            种子伪随机数(组合种子 + 16) * 0.035) *
			                            金币增幅系数
			                    );
			                    break;
			                default:
			                    随机Buff数值 = 0;
			                    break;
			            }
			            if (随机Buff数值 > 0.001 && 随机Buff类型) {
			                const 已存在Buff索引_gold = 最终Buff列表.findIndex(
			                    (b) => b.type === 随机Buff类型
			                );
			                if (已存在Buff索引_gold > -1) {
			                    最终Buff列表[已存在Buff索引_gold].value +=
			                        随机Buff数值;
			                    let 上限 = 1.0;
			                    if (
			                        随机Buff类型.includes("MULTIPLIER") ||
			                        随机Buff类型.includes("CHANCE") ||
			                        随机Buff类型.includes("STEAL") ||
			                        随机Buff类型.includes("PERCENT")
			                    ) {
			                        上限 =
			                            {
			                                [融合Buff类型.攻击倍率]: 0.5,
			                                [融合Buff类型.冷却倍率]: 0.75,
			                                [融合Buff类型.耐久倍率]: 1.0,
			                                [融合Buff类型.防御倍率]: 0.5,
			                                [融合Buff类型.中毒几率]: 0.6,
			                                [融合Buff类型.冰冻几率]: 0.6,
			                                [融合Buff类型.生命偷取]: 0.5,
			                                [融合Buff类型.击退几率]: 0.6,
			                                [融合Buff类型.攻击吸能]: 0.5,
			                                [融合Buff类型.火焰伤害]: 0.6,
			                                [融合Buff类型.闪避几率]: 0.5,
			                                [融合Buff类型.暴击几率]: 0.4,
			                                [融合Buff类型.暴击伤害倍率]: 1.5,
			                                [融合Buff类型.幸运一击]: 0.3,
			                            }[随机Buff类型] || 1.0;
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                上限
			                            );
			                    } else if (
			                        随机Buff类型 === 融合Buff类型.冷却缩减
			                    ) {
			                        const 武器基础冷却 =
			                            武器.自定义数据.get("冷却回合") || 1;
			                        上限 =
			                            武器基础冷却 > 0 ? 武器基础冷却 - 1 : 0;
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.max(
			                                0,
			                                Math.min(
			                                    最终Buff列表[
			                                        已存在Buff索引_gold
			                                    ].value,
			                                    上限
			                                )
			                            );
			                        上限 = 99999;
			                    } else if (
			                        随机Buff类型 === 融合Buff类型.固定伤害减免
			                    ) {
			                        上限 = 5;
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                上限
			                            );
			                    } else if (
			                        随机Buff类型 === 融合Buff类型.受击回能
			                    ) {
			                        上限 = 20;
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                上限
			                            );
			                    } else if (
			                        随机Buff类型 === 融合Buff类型.范围加成 &&
			                        武器.自定义数据.has("攻击范围")
			                    ) {
			                        上限 = Math.floor(
			                            武器.自定义数据.get("攻击范围") * 0.5
			                        );
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                上限
			                            );
			                    } else if (随机Buff类型.includes("加成")) {
			                        最终Buff列表[已存在Buff索引_gold].value =
			                            Math.min(
			                                最终Buff列表[已存在Buff索引_gold]
			                                    .value,
			                                15
			                            );
			                    }
			                } else {
			                    最终Buff列表.push({
			                        type: 随机Buff类型,
			                        value: 随机Buff数值,
			                    });
			                }
			            }
			        }
			    }
			
			    let buffMaterialCount = 0;
			    有效材料.forEach((mat) => {
			        if (
			            mat instanceof 卷轴类 ||
			            mat.类型 === "药水" ||
			            mat instanceof 钥匙
			        ) {
			            buffMaterialCount++;
			        }
			    });
			
			    if (有效材料.some(m => m instanceof 药水类)) {
			        if (武器.材质 === 材料.木质) {
			            最终Buff列表.push({ type: 'MATERIAL_CHANGE', value: 材料.普通 });
			        } else if (武器.材质 === 材料.铁质) {
			            最终Buff列表.push({ type: 'RUST_INCREASE', value: Math.round(武器.攻击力*0.5) });
			        }
			    }
			    if (buffMaterialCount >= 2) {
			        const synergySeed = 哈希字符串(
			            组合种子字符串 + "Synergy" + 最终Buff列表.length
			        );
			        let synergyValue = 0;
			        if (是否武器) {
			            synergyValue = Math.round(
			                (1 + 种子伪随机数(synergySeed) * 1) * 金币增幅系数
			            );
			        } else if (是否防具) {
			            synergyValue = Math.round(
			                (1 + 种子伪随机数(synergySeed) * 0.5) * 金币增幅系数
			            );
			        }
			        if (synergyValue > 0) {
			            const existingSynergy = 最终Buff列表.find(
			                (b) => b.type === 融合Buff类型.协同效应
			            );
			            if (existingSynergy) {
			                existingSynergy.value += synergyValue;
			                if (是否武器)
			                    existingSynergy.value = Math.min(
			                        existingSynergy.value,
			                        3
			                    );
			                if (是否防具)
			                    existingSynergy.value = Math.min(
			                        existingSynergy.value,
			                        2
			                    );
			            } else {
			                最终Buff列表.push({
			                    type: 融合Buff类型.协同效应,
			                    value: synergyValue,
			                });
			            }
			        }
			    }
			    return 最终Buff列表;
			}
			
			function 格式化Buff提示(buff) {
			    const 格式化数值 = (类型, 数值) => {
			        if (
			            类型.includes("MULTIPLIER") ||
			            类型.includes("CHANCE") ||
			            类型.includes("STEAL") ||
			            类型.includes("PERCENT") ||
			            类型 === 融合Buff类型.幸运一击
			        )
			            return `${(数值 * 100).toFixed(1)}%`;
			        if (
			            类型.includes("REDUCTION") &&
			            类型 !== 融合Buff类型.固定伤害减免
			        )
			            return `${数值.toFixed(1)}`;
			        return `+${数值.toFixed(1)}`;
			    };
			    switch (buff.type) {
			        case 融合Buff类型.攻击加成:
			            return `攻击力 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.攻击倍率:
			            return `攻击力 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.冷却缩减:
			            return `冷却 -${格式化数值(buff.type, buff.value)}回合`;
			        case 融合Buff类型.冷却倍率:
			            return `冷却缩减 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.耐久加成:
			            return `最大耐久 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.耐久倍率:
			            return `最大耐久 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.范围加成:
			            return `攻击范围 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.中毒几率:
			            return `附加中毒 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.火焰伤害:
			            return `附加燃烧 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.冰冻几率:
			            return `附加冰冻 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.生命偷取:
			            return `生命偷取 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.防御加成:
			            return `防御力 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.防御倍率:
			            return `防御力 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.暴击几率:
			            return `暴击几率 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.暴击伤害倍率:
			            return `暴击伤害 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.击退几率:
			            return `几率击退 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.攻击吸能:
			            return `攻击吸能 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.闪避几率:
			            return `闪避几率 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.固定伤害减免:
			            return `伤害减免 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.受击回能:
			            return `受击回能 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.幸运一击:
			            return `幸运一击 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.协同效应:
			            return `协同效应 ${格式化数值(buff.type, buff.value)}`;
			        case 融合Buff类型.磨刀石攻击加成:
			            return `磨刀石强化攻击: +${buff.value.toFixed(0)} (剩余${buff.usesLeft}次)`;
			        case 融合Buff类型.磨刀石冷却缩减:
			            return `磨刀石强化冷却: -${buff.value.toFixed(0)} (剩余${buff.usesLeft}次)`;
			        case 'MATERIAL_CHANGE':
			        case 'RUST_INCREASE':
			            return;
			        default:
			            return `未知强化: ${buff.type}`;
			    }
			}
			
			function 伤害玩家(原始攻击力, 伤害来源 = null) {
			    if (调试无限生命) return;
			    if (地牢[玩家.y]?.[玩家.x]?.关联物品 instanceof 烟雾) {
        添加日志("烟雾保护了你！", "成功");
        return;
    }
			    let 最终攻击力 = 原始攻击力;
			    let 伤害来源文本 =
			        伤害来源 instanceof 怪物
			            ? 伤害来源.类型
			            : 伤害来源 || "未知来源";
			
			    let 闪避成功 = false;
			
			    for (const 装备 of Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null)) {
			        if (装备 instanceof 防御装备类) {
			            const buffs = 装备.自定义数据.get("fusedBuffs") || [];
			            const dodgeBuff = buffs.find(
			                (b) => b.type === 融合Buff类型.闪避几率
			            );
			            if (dodgeBuff && prng() < dodgeBuff.value) {
			                闪避成功 = true;
			                添加日志(
			                    `通过 ${装备.获取名称()} 闪避了来自 ${伤害来源文本} 的攻击！`,
			                    "成功"
			                );
			                break;
			            }
			        }
			    }
			
			    if (闪避成功) {
			        触发HUD显示();
			        return;
			    }
			    let 守卫者减伤比例 = 0;
    Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).forEach((装备) => {
        if (装备 instanceof 守卫者盔甲) {
            守卫者减伤比例 += 装备.强化 ? 0.10 : 0.05;
        }
    });

    守卫者减伤比例 = Math.min(0.85, 守卫者减伤比例);

    if (守卫者减伤比例 > 0) {
        最终攻击力 *= (1 - 守卫者减伤比例);
    }
			
			    Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).  forEach((装备) => {
			            if (最终攻击力 <= 0) return; 
			
			            if (
			                装备 instanceof 宠物 &&
			                !装备.自定义数据.get("休眠中")
			            ) {
			                最终攻击力 = 装备.当玩家被攻击(
			                    最终攻击力,
			                    伤害来源
			                );
			            }
			            if (装备 instanceof 防御装备类) {
			                最终攻击力 = 装备.当被攻击(最终攻击力, 伤害来源);
			            }
			        });
			
			    最终攻击力 = Math.max(0, 最终攻击力 - (玩家属性.防御加成 || 0));
			
			    if (最终攻击力 <= 0 && 原始攻击力 > 0)
			        最终攻击力 = Math.round(prng() * 100) / 100;
			
			    if (最终攻击力 > 0) {
			        玩家总受到伤害 += 最终攻击力;
			        if (isAutoMoving) {
			        moveQueue = [];
			        isAutoMoving = false;
			    }
			    }
			
			    更新装备显示();
			    触发扣血特效();
			
			    const 玩家最大生命值 = 100 + (玩家属性.最大生命值加成 || 0);
			
			    const 生命条 = document.querySelector(".health-bar");
			    const 当前宽度 = parseFloat(生命条.style.width) || 100;
			    let 新宽度 = Math.max(0, 当前宽度 - (最终攻击力 / 玩家最大生命值) * 100);
			    if (游戏状态 === "图鉴" && 最终攻击力 > 0)
			        新宽度 = Math.max(1, 新宽度);
			    生命条.style.width = `${新宽度}%`;
			    更新胜利条件显示();
			
			    if (最终攻击力 > 0) {
			        添加日志(
			            `受到了 ${伤害来源文本} 的伤害！损失了 ${最终攻击力.toFixed(
			                1
			            )} 点血量！`,
			            `警告`
			        );
			    } else if (原始攻击力 > 0) {
			        添加日志(`成功抵挡了来自 ${伤害来源文本} 的攻击！`, `成功`);
			    }
			
			    触发HUD显示();
			    let 实际击退 = false;
			    let 击退后X = 玩家.x,
			        原始X = 玩家.x;
			    let 击退后Y = 玩家.y,
			        原始Y = 玩家.y;
			    if (新宽度 > 0 && 伤害来源 instanceof 怪物 && 游戏设置.受伤时击退) {
			        let dx = 玩家.x - 伤害来源?.x;
			        let dy = 玩家.y - 伤害来源?.y;
			        let 击退DX = 0,
			            击退DY = 0;
			
			        if (Math.abs(dx) > Math.abs(dy))
			            击退DX =
			                Math.sign(dx) ||
			                (dy === 0 ? (prng() < 0.5 ? 1 : -1) : 0);
			        else if (Math.abs(dy) > Math.abs(dx))
			            击退DY =
			                Math.sign(dy) ||
			                (dx === 0 ? (prng() < 0.5 ? 1 : -1) : 0);
			        else if (dx !== 0 && dy !== 0) {
			            if (prng() < 0.5) 击退DX = Math.sign(dx);
			            else 击退DY = Math.sign(dy);
			        }
			        if (击退DX === 0 && 击退DY === 0) {
			            if (prng() < 0.5)
			                击退DX = prng() < 0.5 ? 1 : -1;
			            else 击退DY = prng() < 0.5 ? 1 : -1;
			        }
			
			        if (击退DX !== 0 || 击退DY !== 0) {
			            const 新X = 玩家.x + 击退DX;
			            const 新Y = 玩家.y + 击退DY;
			            if (
			                新X >= 0 &&
			                新X < 地牢大小 &&
			                新Y >= 0 &&
			                新Y < 地牢大小 &&
			                检查移动可行性(玩家.x, 玩家.y, 新X, 新Y) &&
			                ![单元格类型.墙壁, 单元格类型.上锁的门].includes(
			                    地牢[新Y]?.[新X]?.背景类型
			                )
			            ) {
			                const 目标单元格 = 地牢[新Y]?.[新X];
			                const 目标物品 = 目标单元格?.关联物品;
			                const 不可移动类型列表 = ["楼梯"];
			                const 目标不可移动 =
			                    目标物品 &&
			                    (不可移动类型列表.includes(目标物品.类型) ||
			                        目标物品.能否拾起 === false);
			                if (!目标不可移动) {
			                    玩家.x = 新X;
			                    玩家.y = 新Y;
			                    击退后X = 新X;
			                    击退后Y = 新Y;
			                    实际击退 = true;
			                }
			            }
			        }
			    }
			    if (实际击退) {
			        const 触发中断 = 处理玩家着陆效果(
			            原始X,
			            原始Y,
			            击退后X,
			            击退后Y
			        );
			        if (!触发中断) 更新视口();
			    }
			
			    if (新宽度 <= 0) {
			        玩家死亡();
			    }
			}
			function 更新武器冷却() {
			    const 时间加速 = 当前激活卷轴列表.has(Array.from(当前激活卷轴列表).find(item => item instanceof 时间卷轴));
			    const 冷却减少量 = 时间加速 ? 2 : 1;
			
			    玩家背包.forEach((item) => {
			        if ((item.类型 === "武器" || item instanceof 钩索) && item.自定义数据.get("冷却剩余") > 0) {
			            item.自定义数据.set("冷却剩余", Math.max(0, item.自定义数据.get("冷却剩余") - 冷却减少量));
			        }
			    });
			    更新装备显示();
			}
			function 寻找传送带最远可达点(起始X, 起始Y, 向量DX, 向量DY, 力度) {
			    let 最终X = 起始X;
			    let 最终Y = 起始Y;
			
			    for (let i = 1; i <= 力度; i++) {
			        const 下一步X = 起始X + 向量DX * i;
			        const 下一步Y = 起始Y + 向量DY * i;
			
			        if (下一步X < 0 || 下一步X >= 地牢大小 || 下一步Y < 0 || 下一步Y >= 地牢大小) {
			            break;
			        }
			
			        const 上一步X = 起始X + 向量DX * (i - 1);
			        const 上一步Y = 起始Y + 向量DY * (i - 1);
			
			        if (!检查移动可行性(上一步X, 上一步Y, 下一步X, 下一步Y)) {
			            break;
			        }
			
			        const 目标单元格 = 地牢[下一步Y]?.[下一步X];
			        if (!目标单元格 || (目标单元格.关联怪物) || (目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物)) {
			            break;
			        }
			
			        最终X = 下一步X;
			        最终Y = 下一步Y;
			    }
			
			    return { x: 最终X, y: 最终Y };
			}
			function 处理传送带效果() {
			    const 传送带列表 = [];
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			const 物品 = 地牢[y]?.[x]?.关联物品;
			if (物品 instanceof 传送带) {
			    传送带列表.push(物品);
			}
			        }
			    }
			
			    if (传送带列表.length === 0) return;
			
			    const 移动计划 = new Map();
			
			    for (const 带 of 传送带列表) {
			        const 单元格 = 地牢[带.y]?.[带.x];
			        const 怪物 = 单元格?.关联怪物;
			        const 物品 = 单元格?.关联物品 !== 带 ? 单元格?.关联物品 : null;
			        
			        let 移动方向 = 带.自定义数据.get('方向');
			        
			        const 向量 = { N: {dx: 0, dy: -1}, S: {dx: 0, dy: 1}, E: {dx: 1, dy: 0}, W: {dx: -1, dy: 0} }[移动方向];
			        const 力度 = 带.自定义数据.get('力度') ?? 1;
			
			        if (向量 && 力度 >= 0) {
			const 检查并计划移动 = (实体, 类型) => {
			    if (实体) {
			        const { x: 新X, y: 新Y } = 寻找传送带最远可达点(带.x, 带.y, 向量.dx, 向量.dy, 力度);
			        if (新X !== 带.x || 新Y !== 带.y) {
			             移动计划.set(实体, { 新X, 新Y, 旧X: 带.x, 旧Y: 带.y, 类型 });
			        }
			        if (带.自定义数据?.get('开关激发')) 红蓝开关状态 = 红蓝开关状态 === '红' ? '蓝' : '红';
			    }
			};
			
			检查并计划移动(怪物, "怪物");
			if (物品 && 物品.能否拾起) {
			    检查并计划移动(物品, "物品");
			}
			if (玩家.x === 带.x && 玩家.y === 带.y) {
			    检查并计划移动(玩家, "玩家");
			}
			        }
			    }
			
			    const 成功移动列表 = [];
			    移动计划.forEach((计划, 生物) => {
			        const { 新X, 新Y, 旧X, 旧Y, 类型 } = 计划;
			        const 目标单元格 = 地牢[新Y]?.[新X];
			
			        if (目标单元格 && !(目标单元格.关联怪物 && 类型!=='玩家') && !(目标单元格.关联物品 && 目标单元格.关联物品.阻碍怪物)) {
			if (类型 === "怪物") {
			    if(!检查移动可行性(旧X,旧Y,新X,新Y)) {
			        推开生物(生物.x,生物.y);
			        return;
			    }
			     生物.恢复背景类型();
			     怪物动画状态.set(生物, {
			    旧逻辑X: 旧X,
			    旧逻辑Y: 旧Y,
			    目标逻辑X: 新X,
			    目标逻辑Y: 新Y,
			    视觉X: 旧X,
			    视觉Y: 旧Y,
			    动画开始时间: Date.now(),
			    正在动画: true,
			});
			
			     生物.x = 新X;
			     生物.y = 新Y;
			     生物.保存新位置类型(新X, 新Y);
			     目标单元格.类型 = 单元格类型.怪物;
			     目标单元格.关联怪物 = 生物;
			     成功移动列表.push(生物);
			} else if (类型 === "物品") {
			     地牢[旧Y][旧X].关联物品 = 地牢[旧Y][旧X].关联物品 === 生物 ? null : 地牢[旧Y][旧X].关联物品;
			     if(地牢[旧Y][旧X].关联物品 === null) 地牢[旧Y][旧X].类型 = null;
			     生物.x = 新X;
			     生物.y = 新Y;
			     
			     目标单元格.类型 = 单元格类型.物品;
			     目标单元格.关联物品 = 生物;
			     成功移动列表.push(生物);
			} else if (类型 === "玩家") {
			     玩家.x = 新X;
			     玩家.y = 新Y;
			     玩家动画状态 = {
			正在动画: true,
			旧逻辑X: 旧X,
			旧逻辑Y: 旧Y,
			目标逻辑X: 玩家.x,
			目标逻辑Y: 玩家.y,
			视觉X: 旧X,
			视觉Y: 旧Y,
			动画开始时间: Date.now()
			        };
			     处理玩家着陆效果(旧X, 旧Y, 新X, 新Y);
			     
			     更新视口();
			     成功移动列表.push(玩家);
			}
			        }
			    });
			}
			function 处理怪物回合() {
			    
			    if (地牢.length !== 地牢大小) return;
			        const 当前房间ID = 房间地图[玩家.y][玩家.x];
			        跟踪玩家怪物数 = 0;
			        所有怪物.forEach((m) => {
			            if (地牢[m.y]?.[m.x]?.关联物品 instanceof 传送带) return;
			            if (房间地图[m.y][m.x] === 当前房间ID) {
			                m.状态 = 怪物状态.活跃;
			            }
			        });
			        const 玩家穿了潜行靴子 = Array.from(玩家装备.values()).some(item => item instanceof 潜行靴子);
			        const 有金质装备 = Array.from({ length: 装备栏每页装备数 }, (_, i) => 玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)).filter(v => v != null).some(装备 => 装备.材质 === 材料.金质);
			        
			        所有怪物.forEach(m => {
			            if (m instanceof 超速怪物 && m.状态 === 怪物状态.活跃) {
			                const 范围 = m.加速范围;
			                const 加速值 = m.加速回合数;
			                for (let dy = -范围; dy <= 范围; dy++) {
			                    for (let dx = -范围; dx <= 范围; dx++) {
			                        const x = m.x + dx;
			                        const y = m.y + dy;
			                        const 邻居 = 地牢[y]?.[x]?.关联怪物;
			                        if (邻居 && 邻居.状态 === 怪物状态.活跃) {
			                            邻居.本回合行动次数 = 加速值;
			                        }
			                    }
			                }
			            }
			        });
			
			        所有怪物.forEach((m) => {
			            if (m.状态 === 怪物状态.活跃 || m.始终追踪玩家) {
			                
			                const 我的状态 = 怪物状态表.get(m);
			                我的状态?.更新状态();
			
			                if (地牢[m.y]?.[m.x]?.关联物品 instanceof 传送带) return;
			                const 行动次数 = m.本回合行动次数 || 1;
			                const 原始移动距离 = m.基础移动距离;
			                    for (let i = 0; i < 行动次数; i++) {
			                if (m instanceof 同步怪物 || m instanceof 巡逻怪物) {
			                    m.尝试移动();
			                    m.目标 = m.选择目标();
			                    
			                    m.尝试攻击();
			                    return;
			                }else if (m.始终追踪玩家) {
			                    m.追踪玩家();
			                }
			                
			                const 距离玩家 = Math.abs(m.x - 玩家.x) + Math.abs(m.y - 玩家.y);
			                if(有金质装备 && 距离玩家 > 5) {
			                    m.基础移动距离 += 1;
			                }
			
			                let 目标 = m.选择目标();
			                m.目标 = 目标;
			                let { x, y } = 目标;
			
			                let 可以追踪 = true;
			                if (玩家穿了潜行靴子 && 怪物状态表.get(m)?.类型 !== "魅惑" && 目标 === 玩家) {
			                    可以追踪 = 快速直线检查(m.x, m.y, 玩家.x, 玩家.y, m.跟踪距离);
			                }
			
			                const 曼哈顿距离 = Math.abs(m.x - x) + Math.abs(m.y - y);
			
			                if (可以追踪 && 曼哈顿距离 <= m.跟踪距离) {
			                    m.通向目标路径 = m.计算目标路径(x, y);
			                    if (m.通向目标路径) {
			                        const 截断点 = Math.max(0, m.通向目标路径.length - Math.floor(m.攻击范围 / 2));
			                        m.目标路径 = m.通向目标路径.slice(0, 截断点);
			                    } else {
			                        m.目标路径 = null;
			                    }
			                } else {
			                    m.通向目标路径 = null;
			                    m.目标路径 = null;
			                    if (玩家穿了潜行靴子) { 
			                        const 方向列表 = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
			                        const 可移动方向 = 方向列表.filter(dir => 检查移动可行性(m.x, m.y, m.x + dir.dx, m.y + dir.dy));
			                        if (可移动方向.length > 0) {
			                            const 随机方向 = 可移动方向[Math.floor(prng() * 可移动方向.length)];
			                            const 随机路径 = [{ x: m.x + 随机方向.dx, y: m.y + 随机方向.dy }];
			                            m.通向目标路径 = 随机路径;
			                            m.目标路径 = 随机路径;
			                            m.目标 = {x:玩家.x,y:玩家.y}
			                        }
			                    }
			                }
			                if (m.通向目标路径) {
			                    
			                        if (m.目标路径 && m.目标路径.length > 0 && !(m.通向目标路径.length > 1 && 玩家状态.some((s) => s.类型 === "隐身") && 怪物状态表.get(m)?.类型 !== "魅惑" && !(m instanceof 王座守护者 && m.当前阶段 === 3))) {
			                            if (怪物状态表.get(m)?.类型 !== "魅惑") m.追击玩家中 = true;
			                            m.尝试移动();
			                            if (m.目标路径 && m.通向目标路径) {
			                            m.通向目标路径.shift()
			                            m.目标路径.shift()
			                            }
			                        } else {
			                            m.追击玩家中 = false;
			                            if (m.x==m.目标.x&&m.y==m.目标.y) {
			                                m.追击玩家中 = true;
			                                跟踪玩家怪物数++;
			                            }
			                            if (m instanceof 王座守护者 && !m.强制释放随机技能()) {
			                        const 方向列表 = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
			                        const 可移动方向 = 方向列表.filter(dir => 检查移动可行性(m.x, m.y, m.x + dir.dx, m.y + dir.dy));
			                        if (可移动方向.length > 0) {
			                            const 随机方向 = 可移动方向[Math.floor(prng() * 可移动方向.length)];
			                            m.目标路径 = [{ x: m.x + 随机方向.dx, y: m.y + 随机方向.dy }];
			                            m.目标 = {x: m.x + 随机方向.dx, y: m.y + 随机方向.dy};
			                            m.尝试移动();
			                            if (m.目标路径 && m.通向目标路径) {
			                            m.通向目标路径.shift()
			                            m.目标路径.shift()
			                            }
			                        }
			                    }
			                        }
			
			                        if (m.通向目标路径 && !(m.通向目标路径.length > 1 && 玩家状态.some((s) => s.类型 === "隐身") && 怪物状态表.get(m)?.类型 !== "魅惑")) {
			                            m.尝试攻击();
			                        } else {
			                            m.绘制血条();
			                        }
			                        if (m.当前生命值 <= 0) break;
			                        if (m instanceof 大魔法师) {
			                        m.更新技能冷却();
			                    }
			                    
			                    
			                } else {
			                    m.追击玩家中 = false;
			                    if (m instanceof 王座守护者 && !m.强制释放随机技能()) {
			                        const 方向列表 = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
			                        const 可移动方向 = 方向列表.filter(dir => 检查移动可行性(m.x, m.y, m.x + dir.dx, m.y + dir.dy));
			                        if (可移动方向.length > 0) {
			                            const 随机方向 = 可移动方向[Math.floor(prng() * 可移动方向.length)];
			                            m.目标路径 = [{ x: m.x + 随机方向.dx, y: m.y + 随机方向.dy }];
			                            m.目标 = {x: m.x + 随机方向.dx, y: m.y + 随机方向.dy};
			                            m.尝试移动();
			                        }
			                    }
			                }
			                }
			                    if (!(m instanceof 超速怪物) && m?.本回合行动次数 > 1) m.本回合行动次数 = 1;
			                m.基础移动距离 = 原始移动距离;
			            }
			        });
			    
			
			    const 提示元素 =
			        怪物追踪提示.容器元素.querySelector(".hud-label");
			    if (跟踪玩家怪物数 > 3) {
			        提示元素.classList.add("怪物数量警告");
			    } else {
			        提示元素.classList.remove("怪物数量警告");
			    }
			    怪物追踪提示.更新({
			        内容: `追踪怪物：${跟踪玩家怪物数}`,
			    });
			}
			
			function 切换日志显示() {
			    日志面板可见 = !日志面板可见;
			    const 按钮 = document.querySelector(
			        "#设置菜单 button:nth-child(1)"
			    ); 
			    if (日志面板可见) {
			        document.querySelector(".日志面板").classList.add("可见");
			        按钮.textContent = "关闭日志界面"; 
			    } else {
			        document
			            .querySelector(".日志面板")
			            .classList.remove("可见");
			        按钮.textContent = "打开日志界面"; 
			    }
			}
			function 打开游戏内设置() {
    const 菜单 = document.getElementById("设置菜单");
    if (菜单.classList.contains("显示")) {
        关闭设置菜单();
    }

    打开设置窗口();

    玩家属性.允许移动++; 
}

			            function 切换背包显示() {
			    const 弹窗 = document.querySelector(".背包弹窗");
			    const 融合窗口 = document.getElementById("融合窗口");
			    const 背包标题元素 = 弹窗.querySelector(":scope > .弹窗头部 > h3");
			    const 当前状态 = 弹窗.classList.contains("显示中");
			    
			    if (当前状态) {
			        玩家属性.允许移动 -= 1;
			        融合窗口.style.display = 'none';
			        融合窗口.classList.remove("显示中");
			        document.querySelectorAll(".物品条目").forEach((el) => {
			            el.classList.remove("active");
			            if (el.__物品实例) {
			                el.__物品实例.isActive = false;
			            }
			        });
			    } else {
			        玩家属性.允许移动 += 1;
			        if (游戏状态 === '地图编辑器') {
			             融合窗口.style.display = 'none';
			             document.getElementById('背包整理按钮').style.display = 'none';
			             if (背包标题元素) {
			                背包标题元素.innerHTML = `编辑器工具箱`;
			             }
			        } else {
			            更新融合窗口();
			            融合窗口.style.display = "flex";
			            document.getElementById('背包整理按钮').style.display = 'flex';
			            requestAnimationFrame(() => {
			                融合窗口.classList.add("显示中");
			                融合窗口.style.opacity = 1;
			                融合窗口.style.transform = "translateX(0)";
			                融合窗口.style.pointerEvents = "auto";
			                融合窗口.style["flex-direction"] = "row";
			            });
			            if (背包标题元素) {
			                背包标题元素.innerHTML = `背包 (容量：<span id="当前容量">0</span>/<span id="最大容量">${最大背包容量}</span>)`;
			            }
			            更新背包显示();
			        }
			    }
			    
			    界面可见性.背包 = !当前状态;
			    
			    弹窗.classList.toggle("显示中", !当前状态);
			    document.getElementById("浮动提示框").style.display = "none";
			}
			function 初始化背包事件监听() {
    const 容器 = document.getElementById("背包物品栏");
    const 显示提示框 = (事件, 物品实例) => {
        const 提示框 = document.getElementById("浮动提示框");
        提示框.innerHTML = 物品实例.获取提示().replace(/\n/g, "<br>");
        提示框.style.display = "block";
        const 提示框宽度 = 提示框.offsetWidth;
        const 提示框高度 = 提示框.offsetHeight;
        const 视口宽度 = window.innerWidth;
        const 视口高度 = window.innerHeight;
        let left = 事件.pageX + 15;
        let top = 事件.pageY + 15;
        if (left + 提示框宽度 > 视口宽度 - 10) {
            left = 事件.pageX - 提示框宽度 - 15;
        }
        if (top + 提示框高度 > 视口高度 - 10) {
            top = 视口高度 - 提示框高度 - 10;
        }
        left = Math.max(5, Math.min(left, 视口宽度 - 提示框宽度 - 5));
        top = Math.max(5, Math.min(top, 视口高度 - 提示框高度 - 5));
        提示框.style.left = `${left}px`;
        提示框.style.top = `${top}px`;
    };
    const 隐藏提示框 = () => {
        document.getElementById("浮动提示框").style.display = "none";
    };
    容器.addEventListener('click', (事件) => {
        const 物品条目 = 事件.target.closest('.物品条目');
        if (!物品条目) return;
        const 物品实例 = 物品条目.__物品实例;
        if (!物品实例) return;
        const 目标按钮 = 事件.target.closest('button');
		const 目标链接 = 事件.target.closest('a');
		if (命令行模式开启 && 目标链接) {
			事件.preventDefault();
			事件.stopPropagation();
			const 动作 = 目标链接.dataset.action;
			switch (动作) {
				case 'equip':
					const 装备按钮 = { style: {} };
					if (物品实例.已装备) {
						物品实例.取消装备();
						显示通知("已卸下", "成功");
					} else {
						if (物品实例.装备()) {
							显示通知("已装备", "成功");
						} else {
							显示通知("槽位已满", "错误");
						}
					}
					更新装备显示();
					break;
				case 'drop':
					处理丢弃物品(物品实例.唯一标识);
					break;
				case 'use':
					使用背包物品(物品实例.唯一标识);
					break;
				case 'fuse':
					添加到融合区(物品实例, 物品条目);
					break;
			}
			更新背包显示();
			隐藏提示框();
			return;
		}
        if (目标按钮) {
            事件.stopPropagation();
            if (目标按钮.classList.contains('装备按钮')) {
                const 起始元素 = 物品条目;
                if (物品实例.已装备) {
                    物品实例.取消装备();
                    显示通知("已卸下", "成功");
                    更新装备显示();
                } else {
                    if (物品实例.装备()) {
                        显示通知("已装备", "成功");
                        更新背包显示();
                        const 获取目标元素的函数 = () => document.getElementById(`装备槽${((物品实例.装备槽位 - 1) % 装备栏每页装备数) + 1}`);
                        创建并播放物品移动动画(起始元素, 获取目标元素的函数);
                        if (typeof gsap === 'undefined'&&命令行模式开启) {
                            setTimeout(更新装备显示, 260);
                        } else {
                            更新装备显示();
                        }
                    } else {
                        显示通知("槽位已满", "错误");
                    }
                }
                目标按钮.style.background = 物品实例.已装备 ? "#f44336" : "#FF9800";
                隐藏提示框();
            } else if (目标按钮.classList.contains('丢弃按钮')) {
                处理丢弃物品(物品实例.唯一标识);
            } else if (目标按钮.classList.contains('使用按钮')) {
                使用背包物品(物品实例.唯一标识);
            } else if (目标按钮.classList.contains('上屏按钮')) {
                添加到融合区(物品实例, 物品条目);
            }
        } else {
            const 当前是否已激活 = 物品条目.classList.contains('active');
            document.querySelectorAll('.物品容器 .物品条目.active').forEach(el => el.classList.remove('active'));
            if (!当前是否已激活) {
                物品条目.classList.add('active');
                显示提示框(事件, 物品实例);
            } else {
                隐藏提示框();
            }
        }
    });
    容器.addEventListener('contextmenu', (e) => {
        if (命令行模式开启) {
            e.preventDefault();
            return;
        }
        const 物品条目 = e.target.closest('.物品条目');
        if (!物品条目) return;
        e.preventDefault();
        const 物品实例 = 物品条目.__物品实例;
        if (!物品实例) return;
        const 起始元素 = 物品条目;
        if (物品实例.已装备) {
            物品实例.取消装备();
            显示通知("已卸下", "成功");
            更新装备显示();
        } else {
            if (物品实例.装备()) {
                显示通知("已装备", "成功");
                更新背包显示();
                const 获取目标元素的函数 = () => document.getElementById(`装备槽${((物品实例.装备槽位 - 1) % 装备栏每页装备数) + 1}`);
                创建并播放物品移动动画(起始元素, 获取目标元素的函数);
                if (typeof gsap === 'undefined'&&命令行模式开启) {
                    setTimeout(更新装备显示, 260);
                } else {
                    更新装备显示();
                }
            } else {
                显示通知("槽位已满！", "错误");
            }
        }
        const 装备按钮 = 物品条目.querySelector('.装备按钮');
        if (装备按钮) {
            装备按钮.style.background = 物品实例.已装备 ? '#f44336' : '#FF9800';
        }
    });
    容器.addEventListener('mouseover', (事件) => {
        if (命令行模式开启 || 事件.target.closest('button')) return;
        const 物品条目 = 事件.target.closest('.物品条目');
        if (物品条目 && !物品条目.classList.contains('active')) {
            const 物品实例 = 物品条目.__物品实例;
            if (物品实例) {
                显示提示框(事件, 物品实例);
            }
        }
    });
    容器.addEventListener('mouseout', (事件) => {
        if (命令行模式开启) return;
        const 物品条目 = 事件.target.closest('.物品条目');
        if (物品条目 && !物品条目.classList.contains('active')) {
            隐藏提示框();
        }
    });
    已初始化--;
}

			document.addEventListener("click", (e) => {
			    const 弹窗 = document.querySelector(".背包弹窗");
			    const 背包区域 = document.querySelector(".背包弹窗 .物品容器");
			    if (document.getElementById("全局设置窗口").style.display === 'block' && !e.target.closest("#全局设置窗口") && !e.target.closest('#全局设置按钮')) {
			        关闭全局设置窗口();
			    }
			    if (
			        界面可见性.背包 &&
			        !e.target.closest(".背包弹窗") &&
			        !e.target.closest("#背包按钮")
			    ) {
			        切换背包显示();
			    } else if (
			        教程提示已显示 &&
			        !e.target.closest("#教程提示窗口") &&
			        !e.target.closest("#游戏模式选择菜单")
			    ) {
			        关闭教程提示();
			    } else if (
			        document
			            .getElementById("设置菜单")
			            .classList.contains("显示") &&
			        !e.target.closest("#设置按钮")
			    ) {
			        切换设置菜单();
			    } else if (
			        document.getElementById("教程回放窗口").style.display ===
			            "block" &&
			        !e.target.closest(".教程提示窗口") &&
			        !e.target.closest("#回放教程按钮")
			    ) {
			        关闭教程回放窗口();
			    }
			    if (!e.target.closest(".物品条目") && 界面可见性.背包) {
			        document.getElementById("浮动提示框").style.display =
			            "none";
			        document.querySelectorAll(".物品条目").forEach((el) => {
			            el.classList.remove("active");
			            if (el.__物品实例) {
			                el.__物品实例.isActive = false;
			                //console.log(el.__物品实例.类型);
			            }
			        });
			    }
			});
			function showGameInfo() {
    const overlay = document.getElementById('gameInfoOverlay');
    if (!overlay) return;

    
    overlay.style.display = 'flex';
    requestAnimationFrame(() => {
        overlay.classList.add('show');
    });
}

function hideGameInfo() {
    const overlay = document.getElementById('gameInfoOverlay');
    if (!overlay) return;

    overlay.classList.remove('show');
    
    setTimeout(() => {
        overlay.style.display = 'none';
    }, 300); 
}



const gameTitle = document.getElementById('游戏标题');
const gameInfoOverlay = document.getElementById('gameInfoOverlay');
const closeGameInfoBtn = document.getElementById('closeGameInfoBtn');

if (gameTitle) {
    gameTitle.addEventListener('click', showGameInfo);
    
    gameTitle.style.cursor = 'pointer'; 
}

if (closeGameInfoBtn) {
    closeGameInfoBtn.addEventListener('click', hideGameInfo);
}

if (gameInfoOverlay) {
    
    gameInfoOverlay.addEventListener('click', (event) => {
        if (event.target === gameInfoOverlay) {
            hideGameInfo();
        }
    });
}
			
			document.addEventListener("keydown", (e) => {
			    if(!e.key) return;
if (e.key === "Escape") {
    const settingsOverlay = document.getElementById("设置窗口遮罩");
    const backpackWindow = document.querySelector(".背包弹窗");

    
    // 1. 关闭主设置窗口
    if (settingsOverlay && settingsOverlay.classList.contains('显示')) {
        e.preventDefault(); 
        关闭设置窗口();
        return; 
    }

    // 2. 关闭游戏内简易设置菜单
    const gameMenu = document.getElementById("设置菜单");
    if (gameMenu && gameMenu.classList.contains('显示')) {
        e.preventDefault();
        关闭设置菜单();
        return;
    }
    
    // 3. 关闭背包窗口
    if (backpackWindow && backpackWindow.classList.contains('显示中')) {
        e.preventDefault();
        切换背包显示();
        return;
    }

    // 4. 如果没有其他窗口打开，并且在游戏场景中，则打开主设置窗口
    const inGameStates = ["游戏中", "编辑器游玩", "图鉴", "地图编辑器"];
    if (inGameStates.includes(游戏状态)) {
        e.preventDefault();
        打开游戏内设置(); 
		return;
    }
}
			    if (游戏状态 === '地图编辑器') {
                    const editorHotkeys = 游戏设置.热键绑定;
                    const key = e.key.toLowerCase();
			        if (e.key === editorHotkeys.编辑器确认) {
			            const activeElement = document.activeElement;
			            if (activeElement && activeElement.tagName.toLowerCase() === 'textarea' && activeElement.dataset.key === '内容') {
			            } else {
			                e.preventDefault();
			                if (document.getElementById('编辑器属性面板遮罩').style.display === 'block') {
			                    document.getElementById('保存属性按钮').click();
			                } else if (document.getElementById('全局设置窗口').style.display === 'block') {
			                    document.getElementById('保存全局设置按钮').click();
			                }
			            }
			        } else if (key === editorHotkeys.编辑器游玩.toLowerCase()) {
			            从当前位置开始游玩();
			        } else if (key === editorHotkeys.编辑器删除工具.toLowerCase()) {
			            设置编辑器选中项({ 名称: '删除工具', 图标: 图标映射.删除, 类型: '工具' });
			            显示通知('已选中: 删除工具', '信息');
			        } else if ((e.ctrlKey || e.metaKey)) {
			            e.preventDefault();
			            if (key === editorHotkeys.编辑器撤销.toLowerCase()) {
			                if (e.shiftKey) {
			                    redoEditorAction();
			                } else {
			                    undoEditorAction();
			                }
			                return;
			            }
			            if (key === editorHotkeys.编辑器重做.toLowerCase()) {
			                redoEditorAction();
			                return;
			            }
			        }
			    }
				if (动画帧运行过) {
					const keyMap = {
						ArrowUp: "up", w: "up", W: "up",
						ArrowLeft: "left", a: "left", A: "left",
						ArrowDown: "down", s: "down", S: "down",
						ArrowRight: "right", d: "right", D: "right",
					};
					if (e.key.toLowerCase() === (游戏设置.热键绑定.等待 || ' ').toLowerCase() && !休息定时器 && 玩家属性.允许移动 <= 0 && !玩家正在休息) {
						e.preventDefault();
						休息定时器 = setTimeout(开始休息, 500);
					} else if (keyMap[e.key] && 玩家属性.允许移动 <= 0) {
						const direction = keyMap[e.key];
						if (移动状态[direction]) return;
						移动状态[direction] = true;
						const dx = 移动状态.left ? -玩家属性.移动步数 : 移动状态.right ? 玩家属性.移动步数 : 0;
						const dy = 移动状态.up ? -玩家属性.移动步数 : 移动状态.down ? 玩家属性.移动步数 : 0;
						if (dx !== 0 || dy !== 0) {
				移动玩家(dx, dy);
						}
						clearTimeout(开始移动定时器);
						开始移动定时器 = setTimeout(开始移动, 250);
						e.preventDefault();
					} else if (功能键映射[e.key.toLowerCase()]) {
						功能键映射[e.key.toLowerCase()]();
					} else if (e.key === "Escape" && 界面可见性.背包) {
						切换背包显示();
					}
				}
			});
			
			
			document.addEventListener("keyup", (e) => {
			    const keyMap = {
			        ArrowUp: "up",
			        w: "up",
			        W: "up",
			        ArrowLeft: "left",
			        a: "left",
			        A: "left",
			        ArrowDown: "down",
			        s: "down",
			        S: "down",
			        ArrowRight: "right",
			        d: "right",
			        D: "right",
			    };
			    if (e.key.toLowerCase() === (游戏设置.热键绑定.等待 || ' ').toLowerCase()) {
					if (休息定时器) {
						clearTimeout(休息定时器);
						休息定时器 = null;
						if (!玩家正在休息) {
							玩家等待();
						}
					}
					if (玩家正在休息) {
						停止休息();
					}
					e.preventDefault();
				}
			    if (keyMap[e.key]) {
			        const direction = keyMap[e.key];
			        移动状态[direction] = false; // 清除移动状态
			        clearTimeout(开始移动定时器); // 重要！清除 开始移动 定时器
			        停止移动();
			        e.preventDefault();
			    }
			});
			function 获取玩家视野范围() {
			    if (玩家状态.some(s => s.类型 === '失明')) return 0;
			    const 玩家房间ID = 房间地图[玩家.y]?.[玩家.x];
			    const 玩家所在房间 =
			        玩家房间ID !== undefined && 玩家房间ID !== -1
			            ? 房间列表[玩家房间ID]
			            : null;
			    if (玩家所在房间?.类型==="黑暗房间") return 1;
			    const 画布 = document.getElementById("dungeonCanvas");
			    const 画布Rect = 画布.getBoundingClientRect();
			    if (!当前天气效果.includes("深夜")) return Math.floor(画布Rect.width / 单元格大小 / 2);
			    
			    let 基础视野 = 3; // 默认视野范围
			    let 视野加成 = 0;
			    玩家装备.forEach((物品) => {
			        if (物品 instanceof 火把) {
			            视野加成 += 物品.自定义数据.get("视野加成") || 0;
			        }
			    });
			    return 基础视野 + 视野加成;
			}
let 光源地图 = new Set();
			
function 是否在光源范围内(目标X, 目标Y) {
    const 玩家房间ID = 房间地图[玩家.y]?.[玩家.x];
    const 玩家所在房间 = (玩家房间ID !== undefined && 玩家房间ID !== -1) ? 房间列表[玩家房间ID] : null;

    // 优先处理最简单的逻辑
    if (玩家状态.some(s => s.类型 === '失明')) return false;


    
    const 目标房间ID = 房间地图[目标Y]?.[目标X];
    if (目标房间ID !== -1) {
        const 目标房间 = 房间列表[目标房间ID];
        // 如果目标在黑暗房间，而玩家不在，则目标不可见
        if (目标房间 && 目标房间.类型 === "黑暗房间" && 玩家房间ID !== 目标房间ID) {
            return false;
        }
    }
// 如果不是深夜且不在黑暗房间，则默认可见
    if (!当前天气效果.includes("深夜") && (!玩家所在房间 || 玩家所在房间.类型 !== "黑暗房间")) {
        return true;
    }
    // 核心优化：直接查询预先计算好的光源地图
    return 光源地图.has(`${目标X},${目标Y}`);
}

function 更新光源地图() {
    光源地图.clear();
    const 玩家视野 = 获取玩家视野范围(); // 现在这个函数很快

    // 1. 计算玩家自身视野
    if (玩家视野 > 0) {
        // 使用一个更优的圆形范围近似算法
        for (let y = 玩家.y - 玩家视野; y <= 玩家.y + 玩家视野; y++) {
            for (let x = 玩家.x - 玩家视野; x <= 玩家.x + 玩家视野; x++) {
                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
                
                // 使用曼哈顿距离或圆形距离来初步筛选，减少视线检查次数
                if (Math.abs(x - 玩家.x) + Math.abs(y - 玩家.y) <= 玩家视野) {
                    if (检查视线(玩家.x, 玩家.y, x, y, 玩家视野 + 1)) {
                        光源地图.add(`${x},${y}`);
                    }
                }
            }
        }
    }

    // 2. 遍历所有潜在的外部光源（一次性完成）
    const 检查并添加光源 = (光源) => {
        const 光照范围 = 光源.自定义数据?.get("光照范围");
        if (光照范围 > 0 && 光源.x >= 0 && 光源.y >= 0) {
            for (let dy = -光照范围; dy <= 光照范围; dy++) {
                for (let dx = -光照范围; dx <= 光照范围; dx++) {
                    const 目标X = 光源.x + dx;
                    const 目标Y = 光源.y + dy;
                    if (
			                目标X < 0 ||
			                目标X >= 地牢大小 ||
			                目标Y < 0 ||
			                目标Y >= 地牢大小
			            )
			                continue;
                    if (Math.abs(dx) + Math.abs(dy) <= 光照范围) {
                         if (检查视线(光源.x, 光源.y, 目标X, 目标Y, 光照范围 + 1)) {
                            光源地图.add(`${目标X},${目标Y}`);
                        }
                    }
                }
            }
        }
    };
    
    // 检查计时器中的光源 (如地上的火把, 照明弹光源)
    所有计时器.forEach(计时器 => {
        if (计时器 && 计时器.自定义数据?.has("光照范围") && 计时器?.x) {
             检查并添加光源(计时器);
        }
    });
    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const cell = 地牢[y][x];
			            if (cell?.关联物品?.自定义数据?.has("光照范围")) {
			                检查并添加光源(cell?.关联物品);
			        }
			        }
			    }

    // 检查怪物身上的光源 (如燃烧状态)
    所有怪物.forEach(怪物 => {
        if (怪物状态表.get(怪物)?.类型 === "火焰") {
            检查并添加光源({ x: 怪物.x, y: 怪物.y, 自定义数据: new Map([['光照范围', 2]]) });
        }
    });
}

			const 图标映射_原始 = { ...图标映射 };
			function 切换文本模式() {
				//游戏设置.文本模式 = !游戏设置.文本模式;
				中文模式 = 游戏设置.文本模式;
				图标映射 = 中文模式 ? 中文对照图标映射 : 图标映射_原始;
			    楼梯图标 = {
			        下楼: 图标映射.下楼楼梯,
			        上楼: 图标映射.上楼楼梯,
			    };

				
				document.querySelector("#背包按钮").innerHTML = getIconHTML('背包按钮');
				document.querySelector("#互动按钮").innerHTML = getIconHTML('互动按钮');

				const 整理图标 = document.querySelector("#背包整理按钮 .整理图标");
				const 整理文本 = document.querySelector("#背包整理按钮 .整理文本");
				if(整理图标 && 整理文本){
					整理图标.style.display = 游戏设置.文本模式 ? 'none' : 'inline';
					整理文本.style.display = 游戏设置.文本模式 ? 'inline' : 'none';
				}

				更新背包显示();
				更新装备显示();
				更新编辑器快速访问栏();
				绘制();
			}
			let 切换动画 = false;
			function 切换动画模式() {
			    切换动画 = !切换动画; // 切换状态
			
			    
			    const 主菜单切换按钮 = document.getElementById("切换动画按钮");
			    if (主菜单切换按钮) {
			        主菜单切换按钮.textContent = 切换动画
			            ? "已切换为自动"
			            : "已切换为回合制";
			    }
			}
			
			function 使用装备槽物品(槽位编号) {
			    const 物品实例 = 玩家装备.get(槽位编号);
			
			    if (!物品实例) return;
			
			    // 无需考虑堆叠
			    if (物品实例.类型 === "武器") {
			        if (
			            物品实例.堆叠数量 > 0 &&
			            物品实例.自定义数据.get("冷却剩余") == 0
			        ) {
			            const { 怪物, 路径 } = 获取周围怪物(
			                物品实例.自定义数据.get("攻击目标数"),
			                物品实例.最终攻击范围
			            );
			            if (怪物 !== null) {
			                if (物品实例.使用(怪物, 路径,玩家)) {
			                    Array.from(
			                        { length: 装备栏每页装备数 },
			                        (_, i) =>
			                            玩家装备.get(
			                                当前装备页 * 装备栏每页装备数 +
			                                    i +
			                                    1
			                            )
			                    )
			                        .filter((v) => v != null)
			                        .forEach((装备) => {
			                            if (
			                                装备 instanceof 宠物 &&
			                                !装备.自定义数据.get("休眠中")
			                            ) {
			                                装备.当玩家攻击(怪物);
			                            }
			                        });
			                    更新装备显示();
			                    绘制();
			                    return true;
			                }
			            } else {
			                if (当前天气效果.includes("诡魅")) {
			                    显示通知(
			                        "太远了...看不清怪物的真实位置了...",
			                        "错误"
			                    );
			                } else {
			                    if(物品实例.自定义数据.get("攻击目标数")>0) 显示通知("附近没有目标", "错误");
			                }
			            }
			        } else {
			            显示通知("武器还未准备好", "错误");
			            return false;
			        }
			    }
			    if (物品实例.类型 === "卷轴") {
			        显示通知("请使用卷轴键使用该物品", "错误");
			        return false;
			    }
			    if (物品实例.使用()) {
			        if (物品实例.堆叠数量 <= 0) {
			            if (物品实例.装备槽位)
			                玩家装备.delete(物品实例.装备槽位);
			            玩家背包.delete(物品实例.唯一标识);
			        }
			        更新背包显示();
			        更新装备显示();
			        显示通知("已使用物品", "成功");
			        return true;
			    } else {
			        if (物品实例.类型 !== "武器") {
			            显示通知("无法使用该物品", "错误");
			        }
			    }
			    return false;
			}
			
			function 卸下装备槽物品(槽位编号) {
			    const 当前物品 = 玩家装备.get(槽位编号);
			
			    if (当前物品) {
			        当前物品.取消装备();
			        显示通知("已卸下", "成功");
			        更新装备显示();
			        更新背包显示();
			
			        const 槽位 = document.getElementById(`装备槽${槽位编号}`);
			        槽位.style.transform = "scale(0.95)";
			        setTimeout(() => (槽位.style.transform = "scale(1)"), 200);
			    }
			}
			function 处理销毁物品(唯一标识, 直接清理 = false) {
			    const 目标物品 = 玩家背包.get(唯一标识);
			    if (!直接清理) {
			        if (!confirm("确定要销毁这个物品吗？")) return false;
			    }
			    if (!目标物品) return false;
			
			    const 物品元素 = 目标物品.显示元素;
			    document.getElementById("浮动提示框").style.display = "none";
			
			    if (!直接清理 && 物品元素 && document.body.contains(物品元素)) {
			        const 烟花容器 = document.createElement("div");
			        烟花容器.style.position = "fixed";
			        const rect = 物品元素.getBoundingClientRect();
			        烟花容器.style.left = `${rect.left + rect.width / 2}px`;
			        烟花容器.style.top = `${rect.top + rect.height / 2}px`;
			        烟花容器.style.zIndex = 99999;
			        document.body.appendChild(烟花容器);
			
			        for (let i = 0; i < 12; i++) {
			            const 粒子 = document.createElement("div");
			            粒子.className = "烟花粒子";
			            粒子.innerHTML = ["✨", "❄️", "⚡", "⭐", "💥", "🔥"][
			                i % 6
			            ];
			            粒子.style.color =
			                目标物品.颜色表[目标物品.颜色索引] || "#fff";
			            粒子.style.setProperty(
			                "--tx",
			                Math.cos((i * 30 * Math.PI) / 180)
			            );
			            粒子.style.setProperty(
			                "--ty",
			                Math.sin((i * 30 * Math.PI) / 180)
			            );
			            烟花容器.appendChild(粒子);
			        }
			        setTimeout(() => 烟花容器.remove(), 800);
			        物品元素.style.opacity = "0";
			        物品元素.style.transition = "opacity 0.2s";
			    }
			
			    if (目标物品.安全销毁()) {
			        [...玩家背包.values()].forEach((item) => {
			            if (item instanceof 宠物) {
			                for (let 槽位 in item.自定义数据.get("装备")) {
			                    if (
			                        item.自定义数据.get("装备")[槽位] ===
			                        目标物品
			                    ) {
			                        item.自定义数据.get("装备")[槽位] = null;
			                        item.更新宠物管理窗口();
			                    }
			                }
			            }
			        });
			        if (目标物品.装备槽位) 玩家装备.delete(目标物品.装备槽位);
			        玩家背包.delete(唯一标识);
			        更新背包显示();
			        更新装备显示();
			    }
			    return true;
			}
			function 尝试收集物品(新物品, 直接收集 = false) {
			    if (!新物品) return;
			    if (新物品.当被收集 && !新物品.当被收集("玩家")) {
			        return false;
			    }
			    if (!新物品.能否拾起) return false;
			
			    const 现有物品 = [...玩家背包.values()].find((item) =>
			        item.可堆叠于(新物品)
			    );
			
			    if (现有物品) {
			        if (现有物品.堆叠数量 < 现有物品.最大堆叠数量) {
			            if (
			                现有物品.堆叠数量 + 新物品.堆叠数量 >=
			                现有物品.最大堆叠数量
			            ) {
			                新物品.堆叠数量 -=
			                    现有物品.最大堆叠数量 - 现有物品.堆叠数量;
			                现有物品.堆叠数量 = 现有物品.最大堆叠数量;
			                return 尝试收集物品(新物品, 直接收集);
			            } else {
			                现有物品.堆叠数量 += 新物品.堆叠数量;
			                更新背包显示();
			                更新装备显示();
			                const 特效元素 = document.createElement("div");
			                if (中文模式) {
			                
			                特效元素.className = "收集特效";
			                特效元素.style.cssText = `
			   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
			   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
			 `;
			                if (新物品.类型 === "金币") {
			                    特效元素.style.cssText = `
			   --辉光颜色: ${颜色表[2]};
			   color: ${颜色表[2]};
			 `;
			                }
			                特效元素.innerHTML = 新物品.显示图标;
			                } else {
			                
							const iconHTML = getIconHTML(新物品.显示图标);
							特效元素.innerHTML = iconHTML;

							if (iconHTML.startsWith('<img')) {
								特效元素.className = "收集特效-滤镜";
							} else {
								特效元素.className = "收集特效";
							}
							
							特效元素.style.setProperty('--辉光颜色', 新物品.类型 === "金币" ? 颜色表[2] : (新物品.颜色表[新物品.颜色索引] || "#FFF"));
							
			                
			                }
			                if (!直接收集) {
			                    document.body.appendChild(特效元素);
			                }
			                setTimeout(() => 特效元素.remove(), 1100);
			                return true;
			            }
			        }
			    }
			
			    if (
			        [...玩家背包.values()].reduce(
			            (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
			            0
			        ) >= 最大背包容量
			    ) {
			        更新背包显示();
			        更新装备显示();
			        显示通知("背包已满！", "错误");
			        return false;
			    }
			    if (新物品.堆叠数量 > 0) {
			        新物品.是否被丢弃 = false;
			        玩家背包.set(新物品.唯一标识, 新物品);
			        添加日志(`已收集物品 ${新物品.获取名称()}`, "信息");
			    }
			    更新背包显示();
			    更新装备显示();
			    const 特效元素 = document.createElement("div");
			                if (中文模式 || 命令行模式开启) {
			                
			                特效元素.className = "收集特效";
			                特效元素.style.cssText = `
			   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
			   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
			 `;
			                if (新物品.类型 === "金币") {
			                    特效元素.style.cssText = `
			   --辉光颜色: ${颜色表[2]};
			   color: ${颜色表[2]};
			 `;
			                }
			                特效元素.innerHTML = 新物品.显示图标;
			                } else {
			                
							const iconHTML = getIconHTML(新物品.显示图标);
							特效元素.innerHTML = iconHTML;

							if (iconHTML.startsWith('<img')) {
								特效元素.className = "收集特效-滤镜";
							} else {
								特效元素.className = "收集特效";
							}
							
							特效元素.style.setProperty('--辉光颜色', 新物品.类型 === "金币" ? 颜色表[2] : (新物品.颜色表[新物品.颜色索引] || "#FFF"));
							
			                
			                }
				
			    if (!直接收集) {
			        document.body.appendChild(特效元素);
			    }
			    setTimeout(() => 特效元素.remove(), 1100);
			    return true;
			}
			
			function 使用背包物品(物品标识) {
			    const 物品实例 = 玩家背包.get(物品标识);
			    if (!物品实例) return false;
			    if (物品实例.类型 === "武器") {
			        if (
			            物品实例.堆叠数量 > 0 &&
			            物品实例.自定义数据.get("冷却剩余") == 0
			        ) {
			            const { 怪物, 路径 } = 获取周围怪物(
			                物品实例.自定义数据.get("攻击目标数"),
			                物品实例.最终攻击范围
			            );
			            if (怪物 !== null) {
			                if (物品实例.使用(怪物, 路径)) {
			                    Array.from(
			                        { length: 装备栏每页装备数 },
			                        (_, i) =>
			                            玩家装备.get(
			                                当前装备页 * 装备栏每页装备数 +
			                                    i +
			                                    1
			                            )
			                    )
			                        .filter((v) => v != null)
			                        .forEach((装备) => {
			                            if (
			                                装备 instanceof 宠物 &&
			                                !装备.自定义数据.get("休眠中")
			                            ) {
			                                装备.当玩家攻击(怪物);
			                            }
			                        });
			                    更新装备显示();
			                    绘制();
			                    互动 = true;
			                    return true;
			                }
			                //失败后回退到 物品实例.使用()
			            } else {
			                if (当前天气效果.includes("诡魅")) {
			                    显示通知(
			                        "太远了...看不清怪物的真实位置了...",
			                        "错误"
			                    );
			                } else {
			                    显示通知("附近没有目标", "错误");
			                }
			            }
			        } else {
			            显示通知("武器还未准备好", "错误");
			            return false;
			        }
			    }
			    if (物品实例.类型 === "卷轴") {
			        显示通知("请在装备栏中使用该物品", "错误");
			        return false;
			    }
			    if (物品实例.使用()) {
			        document.getElementById("浮动提示框").style.display =
			            "none";
			        if (物品实例.堆叠数量 <= 0) {
			            if (物品实例.装备槽位)
			                玩家装备.delete(物品实例.装备槽位);
			            玩家背包.delete(物品标识);
			            物品实例.isActive = false;
			        }
			        更新背包显示();
			        更新装备显示();
			        显示通知("已使用物品", "成功");
			        return true;
			    } else {
			        显示通知("无法使用该物品", "错误");
			    }
			    return false;
			}
			function 应用命令行风格() {
	//命令行模式开启 = !命令行模式开启;
	document.body.classList.toggle('命令行风格', 命令行模式开启);
	图标映射 = 命令行模式开启 ? 命令行图标映射 : 图标映射_原始;
	楼梯图标 = { 下楼: 图标映射.下楼楼梯, 上楼: 图标映射.上楼楼梯 };
	更新界面元素以适应风格();
	绘制();
	更新背包显示();
	更新装备显示();
}
function 更新界面元素以适应风格() {
	const 背包按钮 = document.getElementById('背包按钮');
	const 互动按钮 = document.getElementById('互动按钮');
	const 设置按钮 = document.getElementById('设置按钮');
	const hud切换按钮 = document.getElementById('hudToggle');
	const 回放教程按钮 = document.getElementById('回放教程按钮');
	const 跳过教程按钮 = document.getElementById('跳过教程按钮');
	const 方向上 = document.getElementById('upBtn');
	const 方向下 = document.getElementById('downBtn');
	const 方向左 = document.getElementById('leftBtn');
	const 方向右 = document.getElementById('rightBtn');
	//const 按钮图标映射 = {默认: "HUD智能",常显: "HUD常显",常隐: "HUD常隐"};
	if (命令行模式开启) {
		背包按钮.textContent = '[背包]';
		互动按钮.textContent = '[互动]';
		设置按钮.textContent = '[设置]';
		//hud切换按钮.textContent = '[HUD]';
		回放教程按钮.textContent = '[教程]';
		跳过教程按钮.textContent = '[跳过]';
		方向上.textContent = '^';
		方向下.textContent = 'v';
		方向左.textContent = '<';
		方向右.textContent = '>';
	} else {
		背包按钮.innerHTML = getIconHTML(图标映射.背包按钮);
		互动按钮.innerHTML = getIconHTML(图标映射.互动按钮);
		设置按钮.innerHTML = '⚙️';
		//hud切换按钮.innerHTML = getIconHTML(按钮图标映射[hud模式]);
		回放教程按钮.textContent = '回看教程';
		跳过教程按钮.textContent = '跳过';
		方向上.textContent = '↑';
		方向下.textContent = '↓';
		方向左.textContent = '←';
		方向右.textContent = '→';
	}
}
function 获取墙壁字符(单元格) {
	const 上邻 = 单元格.y > 0 && 地牢[单元格.y - 1][单元格.x].背景类型 === 单元格类型.墙壁;
	const 下邻 = 单元格.y < 地牢大小 - 1 && 地牢[单元格.y + 1][单元格.x].背景类型 === 单元格类型.墙壁;
	const 左邻 = 单元格.x > 0 && 地牢[单元格.y][单元格.x - 1].背景类型 === 单元格类型.墙壁;
	const 右邻 = 单元格.x < 地牢大小 - 1 && 地牢[单元格.y][单元格.x + 1].背景类型 === 单元格类型.墙壁;
	const 连接 = (上邻 ? 1 : 0) | (下邻 ? 2 : 0) | (左邻 ? 4 : 0) | (右邻 ? 8 : 0);
	if (连接 === 0) return '#';
	const 映射 = {0: ' ', 1: '│', 2: '│', 3: '│', 4: '─', 5: '┘', 6: '┐', 7: '┤', 8: '─', 9: '└', 10: '┌', 11: '├', 12: '─', 13: '┴', 14: '┬', 15: '┼'};
	return 映射[连接] || '#';
}

			function 更新背包显示() {
			    const 容器 = document.getElementById("背包物品栏");
			    document.getElementById("最大容量").textContent = 最大背包容量;
			    if (命令行模式开启) {
        容器.innerHTML = '';
        const 物品们 = [...玩家背包.values()].filter(item => !item.是否隐藏);
        物品们.forEach(物品实例 => {
            const 元素 = document.createElement("div");
            元素.className = '物品条目';
            元素.__物品实例 = 物品实例;
            let 名称 = 物品实例.获取名称();
            名称 = 名称.replace(/\[\d+\s*级\]/g, '').replace(/\[强化\]/g, '').trim();
            const 堆叠 = 物品实例.堆叠数量 > 1 ? `x${物品实例.堆叠数量}` : '';
            const 文本 = document.createElement('div');
            文本.style.margin = '0';
            文本.style.whiteSpace = 'div';
            文本.textContent = `> ${名称.padEnd(20)} ${堆叠}`;
            元素.appendChild(文本);
            const 操作容器 = document.createElement('div');
            操作容器.className = '操作链接';
            const 装备文本 = 物品实例.已装备 ? '[卸下]' : '[装备]';
            操作容器.innerHTML = `
                <a href="#" data-action="equip">${装备文本}</a>
                <a href="#" data-action="drop">[丢弃]</a>
                <a href="#" data-action="use">[使用]</a>
                <a href="#" data-action="fuse">[融合]</a>
            `;
            元素.appendChild(操作容器);
            容器.appendChild(元素);
        });
        document.getElementById("当前容量").textContent = [...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0);
        return;
    }
			    const domItemMap = new Map();
			    for (const child of 容器.children) {
			        if (child.__物品实例) {
			            domItemMap.set(child.__物品实例.唯一标识, child);
			        }
			    }
			
			    const backpackItemSymbols = new Set(玩家背包.keys());
			
			    for (const [symbol, item] of 玩家背包.entries()) {
			        if (item.是否隐藏) {
			            if (domItemMap.has(symbol)) {
			                domItemMap.get(symbol).remove();
			                domItemMap.delete(symbol);
			            }
			            continue;
			        }
			
			        let 元素 = domItemMap.get(symbol);
			
			        if (元素) {
			            const 堆叠元素 = 元素.querySelector(".物品堆叠");
			            if (item.堆叠数量 > 1) {
			                if (堆叠元素) {
			                    堆叠元素.textContent = `x${item.堆叠数量}`;
			                } else {
			                    const newStackEl = document.createElement("div");
			                    newStackEl.className = "物品堆叠";
			                    newStackEl.textContent = `x${item.堆叠数量}`;
			                    元素.appendChild(newStackEl);
			                }
			            } else {
			                if (堆叠元素) 堆叠元素.remove();
			            }
			            
			            const 名称元素 = 元素.querySelector('.物品名称');
			            if (名称元素) 名称元素.textContent = item.获取名称();
			
			            domItemMap.delete(symbol);
			        } else {
			            元素 = item.生成显示元素();
			            容器.appendChild(元素);
			        }
			    }
			
			    for (const symbolToDelete of domItemMap.keys()) {
			         domItemMap.get(symbolToDelete).remove();
			    }
			
			    document.getElementById("当前容量").textContent = [...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0);
			}
			
			function 初始化装备系统() {
			    const 装备栏元素 = document.querySelector(".装备栏");
			
			    const 处理装备槽点击 = (槽位, 实际槽位编号) => {
			        const 当前物品 = 玩家装备.get(实际槽位编号);
			        if (!当前物品) return;
			
			        if (当前物品 instanceof 卷轴类) {
			            if (当前激活卷轴列表.has(当前物品)) {
			                当前激活卷轴列表.delete(当前物品);
			                当前物品.卸下();
			                const 物品元素 = 槽位.querySelector(".物品条目");
			                if (物品元素) 物品元素.classList.remove("卷轴闪烁");
			                显示通知("已禁用卷轴", "成功");
			            } else {
			                当前激活卷轴列表.add(当前物品);
			                if (当前物品.使用()) {
			                    显示通知("已启用卷轴", "成功");
			                    const 物品元素 =
			                        槽位.querySelector(".物品条目");
			                    if (物品元素)
			                        物品元素.classList.add("卷轴闪烁");
			                } else {
			                    当前激活卷轴列表.delete(当前物品);
			                }
			                更新装备显示();
			            }
			        } else {
			            使用装备槽物品(实际槽位编号);
			        }
			    };
			
			    if ("ontouchstart" in window && 装备栏元素) {
			        装备栏元素.addEventListener(
			            "touchstart",
			            (e) => {
			                触摸起始X = e.touches[0].clientX;
			                触摸移动X = 触摸起始X;
			                装备栏滑动中 = false;
			            },
			            { passive: true }
			        );
			
			        装备栏元素.addEventListener("touchmove", (e) => {
			            if (!触摸起始X) return;
			            触摸移动X = e.touches[0].clientX;
			            const deltaX = 触摸移动X - 触摸起始X;
			            if (Math.abs(deltaX) > 20) {
			                装备栏滑动中 = true;
			            }
			        });
			
			        装备栏元素.addEventListener("touchend", (e) => {
			            if (!触摸起始X || !装备栏滑动中) {
			                触摸起始X = 0;
			                return;
			            }
			            const deltaX = 触摸移动X - 触摸起始X;
			            const 滑动阈值 = 50;
			            if (deltaX < -滑动阈值) {
			                切换装备页(1);
			            } else if (deltaX > 滑动阈值) {
			                切换装备页(-1);
			            }
			            触摸起始X = 0;
			            触摸移动X = 0;
			            装备栏滑动中 = false;
			        });
			
			        装备栏元素.addEventListener("touchcancel", (e) => {
			            触摸起始X = 0;
			            触摸移动X = 0;
			            装备栏滑动中 = false;
			        });
			    }
			

			
			    document.querySelectorAll(".装备槽").forEach((槽位, index) => {
			        const handleTouchEnd = (e) => {
			            if (装备栏滑动中) return;
			            const 实际槽位编号 =
			                当前装备页 * 装备栏每页装备数 + (index + 1);
			            处理装备槽点击(槽位, 实际槽位编号);
			        };
			
			        槽位.addEventListener("touchend", handleTouchEnd);
			        槽位.addEventListener("touchcancel", handleTouchEnd);
			
			        if (!("ontouchstart" in window)) {
			            槽位.addEventListener("contextmenu", (e) => {
			                e.preventDefault();
			                卸下装备槽物品(
			                    当前装备页 * 装备栏每页装备数 + (index + 1)
			                );
			            });
			            槽位.addEventListener("click", (e) => {
			                const 实际槽位编号 =
			                    当前装备页 * 装备栏每页装备数 + (index + 1);
			                处理装备槽点击(槽位, 实际槽位编号);
			            });
			        }
			    });
			}
			function 切换装备页(方向) {
			    const 旧页 = 当前装备页;
			    当前装备页 += 方向;
			
			    let 最高槽位 = 最大背包容量;
			    const 最大有效页 = Math.min(最大装备页-1,Math.max(0, Math.ceil(最高槽位 / 装备栏每页装备数) - 1));
			
			    当前装备页 = Math.max(0, Math.min(当前装备页, 最大有效页));
			
			    if (当前装备页 !== 旧页) {
			        更新装备显示();
			
			        const 装备栏元素 = document.querySelector(".装备栏");
			        if (装备栏元素) {
			            装备栏元素.style.transition = "transform 0.1s ease-out";
			            装备栏元素.style.transform = `translateX(${
			                方向 > 0 ? "-" : ""
			            }5px)`;
			            setTimeout(() => {
			                装备栏元素.style.transform = "";
			            }, 100);
			        }
			    }
			}
			function 更新装备显示() {
			    for (
			        let i = 1 + 当前装备页 * 装备栏每页装备数;
			        i <= 装备栏每页装备数 + 当前装备页 * 装备栏每页装备数;
			        i++
			    ) {
			        const 槽位 = document.getElementById(
			            `装备槽${((i - 1) % 装备栏每页装备数) + 1}`
			        );
			        if (!槽位) continue;
			
			        const 装备物品 = 玩家装备.get(i);
			
			        if (装备物品 && !装备物品.是否隐藏) {
			            const 克隆元素 = 装备物品
			                .生成显示元素("装备")
			                .cloneNode(true);
			            if (window.outerWidth < 770) {
			                克隆元素.style.transform = "scale(0.55)";
			            }
			            克隆元素.classList.remove("active");
			            克隆元素.classList.remove("hover");
			            克隆元素.__物品实例 = 装备物品;
			            克隆元素.removeAttribute("data-quality");
			
			            [
			                "丢弃按钮",
			                "使用按钮",
			                "装备按钮",
			                "上屏按钮",
			            ].forEach((className) => {
			                克隆元素.querySelector(`.${className}`)?.remove();
			            });
			
			            if (
			                装备物品 instanceof 武器类 &&
			                (装备物品.自定义数据.get("冷却剩余") > 0 ||
			                    槽位.querySelector(`.冷却遮罩`))
			            ) {
			                if (槽位.innerHTML === "" || 槽位?.firstChild?.__物品实例!== 装备物品) {
			                    槽位.innerHTML = ""
			                    if (!(装备物品 instanceof 追踪风弹)){
			                    const 耐久标签 = document.createElement("div");
			                    耐久标签.className = "耐久标签";
			                    耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
			                        "耐久"
			                    )}`;
			                    克隆元素.appendChild(耐久标签);
			                    槽位.appendChild(克隆元素);
			                    }
			                }
			                let 遮罩 = 槽位.querySelector(`.冷却遮罩`);
			                if (!遮罩) {
			                    遮罩 = document.createElement("div");
			                }
			                遮罩.className = "冷却遮罩";
			                const 进度 =
			                    1 -
			                    装备物品.自定义数据.get("冷却剩余") /
			                        装备物品.最终冷却回合;
			                遮罩.style.clipPath = `inset(${进度 * 100}% 0 0 0)`;
			                if (!槽位.querySelector(`.冷却遮罩`)) {
			                    槽位.appendChild(遮罩);
			                }
			                if (进度 === 1) {
			                    setTimeout(() => 遮罩.remove(), 220);
			                }
			                continue;
			            }
			            if (
			                装备物品 instanceof 防御装备类 ||
			                (装备物品 instanceof 武器类 &&
			                    !槽位.querySelector(`.冷却遮罩`))
			            ) {
			                if (!(装备物品 instanceof 追踪风弹)){
			                const 耐久标签 = document.createElement("div");
			                耐久标签.className = "耐久标签";
			                耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
			                    "耐久"
			                )}`;
			                克隆元素.appendChild(耐久标签);
			                }
			            }
			            if (
			                装备物品 instanceof 卷轴类 &&
			                当前激活卷轴列表.has(装备物品)
			            ) {
			                克隆元素.classList.add("卷轴闪烁");
			            }
			            if (装备物品 instanceof 宠物) {
			                const 血量标签 = document.createElement("div");
			                血量标签.className = "宠物血量标签";
			                血量标签.textContent = `HP: ${装备物品.自定义数据.get(
			                    "当前生命值"
			                )} / ${装备物品.自定义数据.get("最大生命值")}`;
			                克隆元素.appendChild(血量标签);
			            }
			            槽位.innerHTML = "";
			            槽位.appendChild(克隆元素);
			        } else {
			            槽位.innerHTML = "";
			        }
			    }
			}
			function 怪物放置物品(物品, x, y, 能否拾起 = false) {
			    let 目标X = x;
			    let 目标Y = y;
			    let 可用 = false;
			    if (位置是否可用(目标X, 目标Y, false)) {
			        可用 = true;
			    } else {
			        const 主要方向 = [
			            [0, -1],
			            [0, 1],
			            [-1, 0],
			            [1, 0],
			        ];
			
			        const 次要方向 = [
			            [1, -1],
			            [1, 1],
			            [-1, 1],
			            [-1, -1],
			        ];
			
			        for (const [dx, dy] of 主要方向) {
			            const 新X = x + dx;
			            const 新Y = y + dy;
			
			            if (
			                新X < 0 ||
			                新X >= 地牢大小 ||
			                新Y < 0 ||
			                新Y >= 地牢大小
			            )
			                continue;
			            if (位置是否可用(新X, 新Y)) {
			                目标X = 新X;
			                目标Y = 新Y;
			                可用 = true;
			                break;
			            }
			        }
			
			        if (!可用) {
			            for (const [dx, dy] of 次要方向) {
			                const 新X = x + dx;
			                const 新Y = y + dy;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    continue;
			                if (位置是否可用(新X, 新Y)) {
			                    目标X = 新X;
			                    目标Y = 新Y;
			                    可用 = true;
			                    break;
			                }
			            }
			        }
			    }
			    if (!可用) {
			        添加日志("怪物放置物品：没有可放置的位置");
			        return { x: null, y: null, 新物品: null };
			    }
			    let 放置物品 = 物品;
			    放置物品.堆叠数量 = 1;
			    放置物品.能否拾起 = 能否拾起;
			    放置怪物到单元格(放置物品, 目标X, 目标Y);
			    return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
			}
			
			function 玩家放置物品(物品, 能否拾起 = false) {
			    let 目标X = 玩家.x;
			    let 目标Y = 玩家.y;
			    let 可用 = false;
			    if (位置是否可用(目标X, 目标Y, false)) {
			        可用 = true;
			    } else {
			        const 主要方向 = [
			            [0, -1],
			            [0, 1],
			            [-1, 0],
			            [1, 0],
			        ];
			
			        const 次要方向 = [
			            [1, -1],
			            [1, 1],
			            [-1, 1],
			            [-1, -1],
			        ];
			
			        for (const [dx, dy] of 主要方向) {
			            const 新X = 玩家.x + dx;
			            const 新Y = 玩家.y + dy;
			
			            if (
			                新X < 0 ||
			                新X >= 地牢大小 ||
			                新Y < 0 ||
			                新Y >= 地牢大小
			            )
			                continue;
			            if (位置是否可用(新X, 新Y)) {
			                目标X = 新X;
			                目标Y = 新Y;
			                可用 = true;
			                break;
			            }
			        }
			
			        if (!可用) {
			            for (const [dx, dy] of 次要方向) {
			                const 新X = 玩家.x + dx;
			                const 新Y = 玩家.y + dy;
			
			                if (
			                    新X < 0 ||
			                    新X >= 地牢大小 ||
			                    新Y < 0 ||
			                    新Y >= 地牢大小
			                )
			                    continue;
			                if (位置是否可用(新X, 新Y)) {
			                    目标X = 新X;
			                    目标Y = 新Y;
			                    可用 = true;
			                    break;
			                }
			            }
			        }
			    }
			    if (!可用) {
			        添加日志("玩家放置物品：没有可放置的位置");
			        return { x: null, y: null, 新物品: null };
			    }
			    let 放置物品 = 克隆物品(物品);
			    放置物品.堆叠数量 = 1;
			    放置物品.能否拾起 = 能否拾起;
			    放置物品到单元格(放置物品, 目标X, 目标Y);
			    return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
			}
			function 放置怪物到单元格(怪物, x, y) {
			    if (位置是否可用(x, y,false) || (地牢[y][x].类型==单元格类型.物品&&!地牢[y][x].关联物品?.阻碍怪物)) {
			        地牢[y][x].类型 = 单元格类型.怪物;
			        地牢[y][x].关联怪物 = 怪物;
			        怪物.x = x;
			        怪物.y = y;
			        怪物.房间ID = 房间地图[y][x];
			        所有怪物.push(怪物);
			        //绘制();
			        return true;
			    }
			    return false;
			}
			function 刷新房间内容(房间) {
			    添加日志(`房间 ${房间.id} 的气息变得混乱不清...`, "警告");
			    已访问房间.delete(房间.id);
			
			    for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			        for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			            const 单元格 = 地牢[y]?.[x];
			            if (!单元格) continue;
			
			            if (单元格.关联物品) {
			                const 物品实例 = 单元格.关联物品;
			                if (
			                    物品实例 instanceof 钥匙 ||
			                    物品实例.类型 === "楼梯"
			                ) {
			                    continue;
			                }
			
			                所有计时器 = 所有计时器.filter(
			                    (计时器) =>
			                        计时器.唯一标识 !== 物品实例.唯一标识
			                );
			
			                if (玩家背包.has(物品实例.唯一标识)) {
			                    处理销毁物品(物品实例.唯一标识, true);
			                } else {
			                }
			                单元格.关联物品 = null;
			                单元格.类型 = null;
			                单元格.颜色索引 = 颜色表.length;
			            }
			
			            if (单元格.关联怪物) {
			                const 怪物实例 = 单元格.关联怪物;
			
			                所有怪物 = 所有怪物.filter((m) => m !== 怪物实例);
			
			                怪物状态表.delete(怪物实例);
			
			                怪物实例.血条元素?.remove();
			                单元格.关联怪物 = null;
			            }
			        }
			    }
			
			    const 怪物生成层级 = (游戏状态 === '地图编辑器' || 游戏状态 === '编辑器游玩' || 是否是自定义关卡) 
			                    ? (自定义全局设置.诡魅天气怪物层级?? 1) 
			                    : 当前层数;
			
			    const 怪物数量 = Math.floor(prng() * 3) + 1;
			    const 诡魅怪物池 = [];
			    for (let i = 0; i <= 怪物生成层级; i++) {
			        if (怪物引入计划.has(i)) {
			            怪物引入计划.get(i).forEach(怪物定义 => {
			                if (!诡魅怪物池.some(m => m.类.name === 怪物定义.类.name)) {
			                    诡魅怪物池.push(怪物定义);
			                }
			            });
			        }
			    }
			    const 候选怪物 = 诡魅怪物池.filter(m => m.类.name !== "大魔法师");

			    if (候选怪物.length > 0) {
			        for (let i = 0; i < 怪物数量; i++) {
			            const 总权重 = 候选怪物.reduce(
			                (sum, m) => sum + m.权重,
			                0
			            );
			            let 随机值 = prng() * 总权重;
			            let 选中配置 = 候选怪物[0];
			            for (const m of 候选怪物) {
			                if (随机值 <= m.权重) {
			                    选中配置 = m;
			                    break;
			                }
			                随机值 -= m.权重;
			            }
			
			            let 放置成功 = false;
			            for (let 尝试 = 0; 尝试 < 10; 尝试++) {
			                const x =
			                    房间.x + Math.floor(prng() * 房间.w);
			                const y =
			                    房间.y + Math.floor(prng() * 房间.h);
			                if (位置是否可用(x, y, false)) {
			                    const 新怪物 = new 选中配置.类({
			                        x: x,
			                        y: y,
			                        房间ID: 房间.id,
			                        强化: prng() < 0.1,
			                    });
			                    放置怪物到单元格(新怪物, x, y);
			                    放置成功 = true;
			                    break;
			                }
			            }
			        }
			    }
			
			    if (prng() < 0.5) {
			        const 数量 = Math.floor(prng() * (5 + 当前层数)) + 1;
			        放置物品到房间(new 金币({ 数量: 数量 }), 房间);
			    } else if (prng() < 0.3) {
			        生成物品([房间]);
			    }
			}
			function 解谜成功(房间) {
			    for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			        for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			            if (
			                地牢[y][x].类型 === 单元格类型.物品 &&
			                地牢[y][x].关联物品 instanceof 棋子
			            ) {
			                地牢[y][x].类型 = null;
			                地牢[y][x].关联物品 = null;
			            }
			        }
			    }
			    生成奖励(房间);
			    显示通知("解谜成功！获得了丰厚奖励！", "成功");
			    绘制();
			}
			function 检查解谜是否成功(棋子数量) {
			    const 当前房间ID = 房间地图[玩家.y][玩家.x];
			    if (当前房间ID === -1) return false;
			
			    const 当前房间 = 房间列表[当前房间ID];
			    if (当前房间.类型 !== "隐藏解谜棋盘") return false;
			    let 棋子现存数量 = 0;
			    const 棋盘宽度 = 当前房间.w;
			    const 棋盘高度 = 当前房间.h;
			    const 棋盘 = Array(棋盘高度)
			        .fill(null)
			        .map(() => Array(棋盘宽度).fill(0));
			    const 棋子列表 = [];
			
			    for (let y = 当前房间.y; y < 当前房间.y + 当前房间.h; y++) {
			        for (let x = 当前房间.x; x < 当前房间.x + 当前房间.w; x++) {
			            if (
			                地牢[y][x].类型 === 单元格类型.物品 &&
			                地牢[y][x].关联物品 instanceof 棋子 &&
			                地牢[y][x].关联物品.堆叠数量 === 1
			            ) {
			                棋盘[y - 当前房间.y][x - 当前房间.x] =
			                    地牢[y][x].关联物品;
			                棋子列表.push({
			                    x: x - 当前房间.x,
			                    y: y - 当前房间.y,
			                    棋子: 地牢[y][x].关联物品,
			                });
			                棋子现存数量++;
			            }
			        }
			    }
			    if (棋子现存数量 >= 棋子数量) {
			        for (const 棋子信息 of 棋子列表) {
			            const 攻击位置 = 棋子信息.棋子.可攻击位置(
			                棋子信息.x,
			                棋子信息.y,
			                棋盘
			            );
			            for (const 其他棋子信息 of 棋子列表) {
			                if (棋子信息 === 其他棋子信息) continue;
			                if (
			                    攻击位置.some(
			                        (pos) =>
			                            pos.x === 其他棋子信息.x &&
			                            pos.y === 其他棋子信息.y
			                    )
			                ) {
			                    return false;
			                }
			            }
			        }
			
			        解谜成功(当前房间);
			        return true;
			    }
			    return false;
			}
			function 生成解谜棋盘(房间) {
			    const 棋盘大小 = Math.min(房间.w, 房间.h);
			    const 棋盘 = Array(棋盘大小)
			        .fill(null)
			        .map(() => Array(棋盘大小).fill(0));
			    const 棋子种类 = {
			        A: [国际象棋车, 国际象棋象],
			        B: [国际象棋马, 中国象棋炮],
			    };
			
			    const 首个棋子层级 = prng() < 0.6 ? "A" : "B";
			    const 首个棋子类 =
			        棋子种类[首个棋子层级][
			            Math.floor(
			                prng() * 棋子种类[首个棋子层级].length
			            )
			        ];
			    棋盘[0][0] = new 首个棋子类({});
			
			    for (let y = 0; y < 棋盘大小; y++) {
			        for (let x = 0; x < 棋盘大小; x++) {
			            if (x === 0 && y === 0) continue;
			            if (棋盘[y][x]) continue;
			
			            let 当前层级 = "A";
			            while (当前层级) {
			                const 可放置棋子 = [];
			                for (const 棋子类 of 棋子种类[当前层级]) {
			                    if (可以放置(x, y, 棋子类, 棋盘)) {
			                        可放置棋子.push(棋子类);
			                    }
			                }
			
			                if (可放置棋子.length > 0) {
			                    const 权重 = 可放置棋子.map((棋子类) => {
			                        const 威胁数 = 计算新增威胁格子数(
			                            x,
			                            y,
			                            棋子类,
			                            棋盘
			                        );
			                        return 1 / (威胁数 + 1);
			                    });
			
			                    const 最小权重 = Math.min(...权重);
			
			                    if (当前层级 === "A") {
			                        可放置棋子.push("下一层");
			                        权重.push(最小权重);
			                    }
			
			                    const 总权重 = 权重.reduce(
			                        (sum, w) => sum + w,
			                        0
			                    );
			                    let 随机数 = prng() * 总权重;
			                    let 选中棋子类 = null;
			                    for (let i = 0; i < 可放置棋子.length; i++) {
			                        if (随机数 < 权重[i]) {
			                            选中棋子类 = 可放置棋子[i];
			                            break;
			                        }
			                        随机数 -= 权重[i];
			                    }
			
			                    if (选中棋子类) {
			                        if (选中棋子类 === "下一层") {
			                            当前层级 = "B";
			                        } else {
			                            棋盘[y][x] = new 选中棋子类({});
			                            break;
			                        }
			                    }
			                } else {
			                    if (当前层级 === "A") {
			                        当前层级 = "B";
			                    } else {
			                        break;
			                    }
			                }
			            }
			        }
			    }
			    const 棋子 = [];
			    房间.棋子数量 = 0;
			    for (let i = 0; i < 棋盘大小; i++) {
			        for (let j = 0; j < 棋盘大小; j++) {
			            if (棋盘[j][i]) {
			                棋子.push(棋盘[j][i]);
			            }
			        }
			    }
			    棋子.forEach((棋子) => {
			        放置物品到房间(棋子, 房间);
			        房间.棋子数量++;
			    });
			    return { 棋盘 };
			}
			
			function 可以放置(x, y, 棋子类, 棋盘) {
			    if (棋盘[y][x]) return false;
			
			    for (let i = 0; i < 棋盘.length; i++) {
			        for (let j = 0; j < 棋盘[i].length; j++) {
			            const 已放置棋子 = 棋盘[j][i];
			            if (已放置棋子) {
			                const 攻击位置 = 已放置棋子.可攻击位置(i, j, 棋盘);
			                if (
			                    攻击位置.some(
			                        (pos) => pos.x === x && pos.y === y
			                    )
			                ) {
			                    return false;
			                }
			            }
			        }
			    }
			
			    const 临时棋盘 = 棋盘.map((row) =>
			        row.map((cell) => (cell ? new cell.constructor() : null))
			    );
			    临时棋盘[y][x] = new 棋子类();
			    const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(
			        x,
			        y,
			        临时棋盘
			    );
			    for (let i = 0; i < 棋盘.length; i++) {
			        for (let j = 0; j < 棋盘.length; j++) {
			            if (临时棋盘[j][i] && (i !== x || j !== y)) {
			                if (
			                    新棋子攻击位置.some(
			                        (pos) => pos.x === i && pos.y === j
			                    )
			                ) {
			                    return false;
			                }
			            }
			        }
			    }
			
			    for (let i = 0; i < 棋盘.length; i++) {
			        for (let j = 0; j < 棋盘.length; j++) {
			            if (临时棋盘[j][i] instanceof 中国象棋炮) {
			                const 炮的攻击位置 = 临时棋盘[j][i].可攻击位置(
			                    i,
			                    j,
			                    临时棋盘
			                );
			                for (let m = 0; m < 棋盘.length; m++) {
			                    for (let n = 0; n < 棋盘.length; n++) {
			                        if (
			                            临时棋盘[n][m] &&
			                            (m !== i || n !== j)
			                        ) {
			                            if (
			                                炮的攻击位置.some(
			                                    (pos) =>
			                                        pos.x === m && pos.y === n
			                                )
			                            ) {
			                                return false;
			                            }
			                        }
			                    }
			                }
			            }
			        }
			    }
			    return true;
			}
			
			function 计算新增威胁格子数(x, y, 棋子类, 棋盘) {
			    const 临时棋盘 = 棋盘.map((row) =>
			        row.map((cell) => (cell ? new cell.constructor() : null))
			    );
			    临时棋盘[y][x] = new 棋子类();
			    const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(
			        x,
			        y,
			        临时棋盘
			    );
			
			    let 新增威胁数 = 0;
			
			    for (let i = 0; i < 棋盘.length; i++) {
			        for (let j = 0; j < 棋盘[i].length; j++) {
			            if (临时棋盘[j][i] === null) {
			                if (
			                    新棋子攻击位置.some(
			                        (pos) => pos.x === i && pos.y === j
			                    ) ||
			                    !可以放置(i, j, 棋子类, 临时棋盘)
			                ) {
			                    新增威胁数++;
			                }
			            }
			        }
			    }
			    return 新增威胁数;
			}
			
			        function 显示通知(内容, 类型 = "信息", 强制显示 = false, 持续时间 = 1500) {
			添加日志(内容, 类型);
			if (!是否显示通知 && !强制显示) {
			    return;
			}
			
			const 容器 = document.querySelector(".通知容器") || document.createElement("div");
			if (!document.body.contains(容器)) {
			    容器.className = "通知容器";
			    document.body.appendChild(容器);
			}
			
			const 最大通知数 = 2;
			
			// 当通知数量达到或超过上限时，立即移除最旧的通知
			while (容器.children.length >= 最大通知数) {
			    const 待移除通知 = Array.from(容器.children).find(n => !n.classList.contains('持久'));
			    if (待移除通知) {
			        clearTimeout(待移除通知._timer); // 清除其自动消失的计时器
			        待移除通知.remove(); // 立即从DOM中移除
			    } else {
			        // 如果所有通知都是持久性的，则无法添加新通知
			        console.warn("无法显示新通知，因为所有可见通知都是持久性的。");
			        return;
			    }
			}
			
			const 图标表 = {
			    信息: "ℹ️",
			    成功: 图标映射.成功,
			    警告: "⚠️",
			    错误: 图标映射.错误,
			};
			const 通知 = document.createElement("div");
			通知.className = `通知条目 ${类型}`;
			if(强制显示) 通知.classList.add('持久');
			
			通知.innerHTML = `
			    <span class="通知图标">${图标表[类型]}</span>
			    <span class="通知内容">${内容}</span>
			    <button class="关闭按钮">×</button>
			`;//其实这里也可以xss注入...
			
			通知.querySelector('.关闭按钮').addEventListener('click', () => {
			    if (通知._timer) clearTimeout(通知._timer);
			    隐藏通知(通知);
			});
			
			
			    通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
			    通知.addEventListener('mouseenter', () => clearTimeout(通知._timer));
			    通知.addEventListener('mouseleave', () => {
			        通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
			    });
			
			
			容器.appendChild(通知);
			        }
			
			function 生成天气效果() {
			    当前天气效果 = [];
			
			    const 乱序天气列表 = [...所有天气列表].sort(
			        () => prng() - 0.5
			    );
			
			    const 要选择的数量 =
			        prng() < 0.5 ? 1 : Math.min(2, 乱序天气列表.length);
			
			    当前天气效果 = 乱序天气列表.slice(0, 要选择的数量);
			
			    if (当前天气效果.includes("深夜")) {
			        显示通知("夜幕降临，周围变得一片漆黑...", "警告");
			    }
			    if (当前天气效果.includes("雷暴")) {
			        显示通知("乌云密布，雷声滚滚...", "警告");
			    }
			    if (当前天气效果.includes("大风")) {
			        显示通知("狂风呼啸，站稳脚跟！", "警告");
			    }
			    if (当前天气效果.includes("严寒")) {
			        显示通知("严冬将至...", "警告");
			    }
			    if (当前天气效果.includes("诡魅")) {
			        显示通知(
			            "空气中弥漫着诡异的气息，你的感知似乎受到了干扰...",
			            "警告"
			        );
			    }
			}
			function 放置巨人(巨人实例, x, y) {
			    const 区域 = [
			        {x: x, y: y},
			        {x: x + 1, y: y},
			        {x: x, y: y + 1},
			        {x: x + 1, y: y + 1}
			    ];
			
			    for (const 位置 of 区域) {
			        if (!位置是否可用(位置.x, 位置.y, false)) {
			            return false; 
			        }
			    }
			    
			    巨人实例.保存新位置类型(x, y);
			    放置怪物到单元格(巨人实例, x, y);
			    巨人实例.部位列表.forEach((部位, 索引) => {
			        const 偏移 = 巨人实例.部位偏移[索引];
			        放置怪物到单元格(部位, x + 偏移.dx, y + 偏移.dy);
			    });
			    
			    return true;
			}
			function 处理诡魅房间刷新(旧玩家X, 旧玩家Y, 玩家X, 玩家Y) {
			    const 旧视野房间ID集合 = 获取视野内房间ID(旧玩家X, 旧玩家Y);
			    const 新视野房间ID集合 = 获取视野内房间ID(玩家X, 玩家Y);
			    房间列表.forEach((房间) => {
			        if (
			            房间.类型?.slice(0, 2) === "隐藏" ||
			            !已访问房间.has(房间.id) ||
			            新视野房间ID集合.has(房间.id) ||
			            房间.id === 0
			        ) {
			            return;
			        }
			        if (旧视野房间ID集合.has(房间.id)) {
			            刷新房间内容(房间);
			        }
			    });
			}
			
			function 获取视野内房间ID(中心X, 中心Y) {
			    const 视野范围 = 获取玩家视野范围() + 2;
			    const 房间ID集合 = new Set();
			    const 检查范围 = 视野范围;
			
			    for (let dy = -检查范围; dy <= 检查范围; dy++) {
			        for (let dx = -检查范围; dx <= 检查范围; dx++) {
			            const 检查X = 中心X + dx;
			            const 检查Y = 中心Y + dy;
			
			            if (
			                检查X >= 0 &&
			                检查X < 地牢大小 &&
			                检查Y >= 0 &&
			                检查Y < 地牢大小
			            ) {
			                const 距离 = Math.abs(dx) + Math.abs(dy);
			                if (距离 <= 视野范围) {
			                    const 房间ID = 房间地图[检查Y][检查X];
			                    if (房间ID !== -1) {
			                        房间ID集合.add(房间ID);
			                    }
			                }
			            }
			        }
			    }
			    return 房间ID集合;
			}
			
			
			function 隐藏通知(通知元素) {
			    if (!通知元素 || !通知元素.parentElement) return;
			
			    通知元素.classList.add("离场");
			    通知元素.addEventListener("animationend", () => {
			        通知元素.remove();
			
			        const 容器 = document.querySelector(".通知容器");
			        if (容器 && 容器.children.length === 0) {
			            容器.remove();
			        }
			    });
			}
			function 添加日志(内容, 类型 = "信息") {
			    const 时间戳 = new Date().toLocaleTimeString();
			    const 条目 = document.createElement("div");
			    条目.className = `日志条目 ${类型}`;
			    条目.innerHTML = `<span class="日志时间">[${时间戳}]</span> ${内容}`;
			
			    document.getElementById("logContent").appendChild(条目);
			
			    条目.scrollIntoView({ behavior: "smooth" });
			    日志历史.push({ 时间戳, 内容, 类型 });
			}
			function 收纳通知() {
			    是否显示通知 = !是否显示通知;
			    let 按钮 = document.querySelector(
			        "#设置菜单 button:nth-child(2)"
			    );
			    if (是否显示通知) {
			        按钮.innerHTML = "收纳通知";
			        显示通知("已重新显示通知", "信息");
			        按钮.textContent = "收纳通知";
			    } else {
			        按钮.innerHTML = "显示通知";
			        显示通知("已将通知收纳入日志中", "信息");
			        按钮.textContent = "显示通知";
			    }
			}
			
			function 关闭重铸界面() {
			    const 遮罩 = window.当前重铸遮罩;
			    if (!遮罩) return;
			
			    const 弹窗 = 遮罩.querySelector(".重铸弹窗");
			    if (!弹窗) return;
			
			    弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
			    弹窗.style.opacity = 0;
			
			    弹窗.querySelectorAll(".重铸物品").forEach((el) => {
			        el.__物品实例 = null;
			    });
			
			    setTimeout(() => {
			        遮罩.remove();
			        window.当前重铸遮罩 = null
			        window.当前重铸台 = null;
			        更新背包显示();
			        玩家属性.允许移动 -= 1;
			    }, 300);
			}
			function 显示修复界面(修复台实例) {
			 if (界面可见性.背包) 切换背包显示();
			 玩家属性.允许移动++;
			
			 const 遮罩 = document.createElement("div");
			 遮罩.id = "repairOverlay";
			 遮罩.className = "重铸遮罩";
			
			 const 弹窗 = document.createElement("div");
			 弹窗.id = "repairWindow";
			 弹窗.className = "重铸弹窗";
			 弹窗.innerHTML = `
			     <div class="重铸弹窗-header">
			         <h3>装备修复 (修复台耐久: ${修复台实例.自定义数据.get("耐久")}/${修复台实例.自定义数据.get("最大耐久")})</h3>
			         <button class="关闭按钮" id="closeRepairBtn">×</button>
			     </div>
			     <div id="repairableItemsContainer" class="重铸弹窗-items" style="max-height: 60vh;">
			         <!-- 物品们排排站 -->
			     </div>
			     <div class="交易底部" style="justify-content: space-around; padding-top: 15px; border-top: 1px solid #444;">
			         <span>修复费用: <span id="repairCostDisplay" style="color: var(--yellow); font-weight: bold;">-</span> 金币</span>
			         <button id="executeRepairBtn" class="菜单按钮" style="min-width: 150px;">修复选中装备</button>
			     </div>
			 `;
			
			 遮罩.appendChild(弹窗);
			 document.body.appendChild(遮罩);
			
			 const 物品列表容器 = document.getElementById('repairableItemsContainer');
			 const 费用显示 = document.getElementById('repairCostDisplay');
			 let 已选物品元素 = null;
			
			 const 填充可修复物品 = () => {
			     物品列表容器.innerHTML = '';
			     const 可修复物品 = [...玩家背包.values(), ...玩家装备.values()].filter(item =>
			         item && (item instanceof 武器类 || item instanceof 防御装备类) &&
			         item.自定义数据.has('耐久') && item.自定义数据.has('原耐久') &&
			         item.自定义数据.get('耐久') < item.自定义数据.get('原耐久') &&
			         !item.自定义数据.get('不可破坏')
			     );
			
			     if (可修复物品.length === 0) {
			         物品列表容器.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">没有需要修复的装备。</p>';
			         return;
			     }
			
			     可修复物品.forEach(item => {
			         const 元素 = document.createElement("div");
			         元素.className = "重铸物品"; // 复用样式
			         元素.innerHTML = `
			             ${item.强化 ? '<div class="重铸台强化标识">★</div>' : ""}
			             <div class="物品图标">${item.图标}</div>
			             <div class="物品名称">${item.名称}</div>
			             <div class="重铸台耐久标签">耐久 ${item.自定义数据.get("耐久")}/${item.自定义数据.get("原耐久")}</div>
			         `;
			         元素.__物品实例 = item;
			         元素.onclick = () => {
			             if (已选物品元素) {
			                 已选物品元素.classList.remove('selected');
			             }
			             元素.classList.add('selected');
			             已选物品元素 = 元素;
			             const cost = 修复台实例.计算修复消耗(item);
			             费用显示.textContent = cost;
			         };
			         物品列表容器.appendChild(元素);
			     });
			 };
			
			 填充可修复物品();
			
			 document.getElementById('closeRepairBtn').onclick = 关闭修复界面;
			 document.getElementById('executeRepairBtn').onclick = () => 执行修复(修复台实例);
			 
			 // 动画效果
			 遮罩.style.display = 'block';
			 requestAnimationFrame(() => {
			     弹窗.style.opacity = 1;
			     弹窗.style.transform = "translate(-50%, -50%) scale(1)";
			 });
			}
			
			function 关闭修复界面() {
			 const 遮罩 = document.getElementById("repairOverlay");
			 if (!遮罩) return;
			
			 const 弹窗 = 遮罩.querySelector(".重铸弹窗");
			 if (弹窗) {
			     弹窗.style.opacity = 0;
			     弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
			 }
			
			 setTimeout(() => {
			     遮罩.remove();
			     玩家属性.允许移动--;
			     玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
			 }, 300);
			}
			
			function 执行修复(修复台实例) {
			 const 选中元素 = document.querySelector("#repairableItemsContainer .selected");
			 if (!选中元素) {
			     显示通知("请先选择一件需要修复的装备！", "错误");
			     return;
			 }
			
			 const 待修复物品 = 选中元素.__物品实例;
			 const 修复费用 = 修复台实例.计算修复消耗(待修复物品);
			 if (待修复物品 instanceof 时空罗盘) {
			    显示通知("该物品无法被修复。", "信息");
			    return;
			 }
			 if (修复费用 <= 0) {
			     显示通知("该物品无需修复。", "信息");
			     return;
			 }
			 
			 if (!扣除金币(修复费用)) {
			     显示通知(`金币不足！需要 ${修复费用} 金币。`, "错误");
			     return;
			 }
			
			 const 剩余耐久 = 修复台实例.自定义数据.get("耐久") - 1;
			 修复台实例.自定义数据.set("耐久", 剩余耐久);
			 修复台实例.效果描述 = `消耗金币，可将一件装备/武器的耐久完全修复。\n剩余使用次数：${剩余耐久}/${修复台实例.自定义数据.get("最大耐久")}`;
			
			 待修复物品.自定义数据.set('耐久', 待修复物品.自定义数据.get('原耐久'));
			
			 显示通知(`成功修复 ${待修复物品.获取名称()}，花费了 ${修复费用} 金币！`, "成功");
			 
			 关闭修复界面();
			 更新背包显示();
			 更新装备显示();
			}
			function 执行重铸() {
			    const 源元素 = document.querySelector("#sourceItems .selected");
			    const 材料元素 = document.querySelector(
			        "#materialItems .selected"
			    );
			
			    const 源物品 = 源元素?.__物品实例;
			    const 材料物品 = 材料元素?.__物品实例;
			
			    if (!源物品 || !材料物品) {
			        显示通知("需要选择两个有效装备", "错误");
			        return;
			    }
			    if (源物品 === 材料物品) {
			        显示通知("需要选择两个不同装备", "错误");
			        return;
			    }
			    if (源物品.名称 !== 材料物品.名称) {
			        显示通知("装备名称不一致", "错误");
			        return;
			    }
			
			    const 当前耐久 = 源物品.自定义数据.get("耐久");
			    const 最大耐久 = 源物品.自定义数据.get("原耐久");
			    const 可用空间 = 最大耐久 - 当前耐久;
			    const 可转移量 = Math.min(
			        材料物品.自定义数据.get("耐久"),
			        可用空间
			    );
			
			    if (可转移量 <= 0) {
			        显示通知(
			            可用空间 <= 0 ? "目标已满耐久" : "材料无可用耐久",
			            "错误"
			        );
			        return;
			    }
			    const 消耗金币 = 当前重铸台.计算消耗(源物品, 材料物品);
			    if (!扣除金币(消耗金币)) {
			        显示通知("金币不足！", "错误");
			        return false;
			    }
			
			    源物品.自定义数据.set("耐久", 当前耐久 + 可转移量);
			    处理销毁物品(材料物品.唯一标识, true);
			
			    const 剩余耐久 = 当前重铸台.自定义数据.get("耐久") - 1;
			    当前重铸台.自定义数据.set("耐久", 剩余耐久);
			    当前重铸台.效果描述 = `将同名装备的耐久融合\n剩余耐久：${剩余耐久}/${当前重铸台.自定义数据.get(
			        "最大耐久"
			    )}`;
			
			    显示通知(`消耗 ${消耗金币} 金币成功修复！`, "成功");
			    关闭重铸界面();
			}
			function 扣除金币(数量) {
			    const 可用金币总量 = [...玩家背包.values()]
			        .filter(
			            (i) =>
			                i instanceof 金币 && !i.是否隐藏 && i.堆叠数量 > 0
			        )
			        .reduce((sum, i) => sum + i.堆叠数量, 0);
			
			    if (可用金币总量 < 数量) {
			        return false;
			    }
			
			    const 可见金币列表 = [...玩家背包.values()].filter(
			        (i) => i instanceof 金币 && !i.是否隐藏 && i.堆叠数量 > 0
			    );
			
			    let 剩余扣除 = 数量;
			
			    for (const 金币实例 of 可见金币列表) {
			        if (剩余扣除 === 0) break;
			        const 本次可扣除 = Math.min(金币实例.堆叠数量, 剩余扣除);
			        金币实例.堆叠数量 -= 本次可扣除;
			        剩余扣除 -= 本次可扣除;
			
			        if (金币实例.堆叠数量 === 0) {
			            玩家背包.delete(金币实例.唯一标识);
			        }
			    }
			    return 剩余扣除 === 0;
			}
			
			function 触发扣血特效() {
			    const 特效 = document.getElementById("扣血特效");
			    特效.style.animation = "none";
			    特效.offsetHeight;
			    特效.style.animation = "扣血脉冲 0.8s ease-out";
			}
			
			let 指示器缓存 = new Map();
			
			function 计算精确边缘位置(怪物) {
			    const 画布 = document.getElementById("dungeonCanvas");
			    const 画布Rect = 画布.getBoundingClientRect();
			
			    const 视口左边界 = 当前相机X;
			    const 视口右边界 =
			        当前相机X + Math.floor(画布Rect.width / 单元格大小) - 1;
			    const 视口上边界 = 当前相机Y;
			    const 视口下边界 =
			        当前相机Y + Math.floor(画布Rect.height / 单元格大小) - 1;
			
			    if (
			        怪物.x >= 视口左边界 &&
			        怪物.x <= 视口右边界 &&
			        怪物.y >= 视口上边界 &&
			        怪物.y <= 视口下边界
			    ) {
			        return null;
			    }
			
			    const 玩家像素X =
			        (玩家.x - 当前相机X) * 单元格大小 + 单元格大小 / 2;
			    const 玩家像素Y =
			        (玩家.y - 当前相机Y) * 单元格大小 + 单元格大小 / 2;
			
			    const dx =
			        (怪物.x - 当前相机X) * 单元格大小 +
			        单元格大小 / 2 -
			        玩家像素X;
			    const dy =
			        (怪物.y - 当前相机Y) * 单元格大小 +
			        单元格大小 / 2 -
			        玩家像素Y;
			
			    // 计算射线方向向量
			    const 方向长度 = Math.sqrt(dx * dx + dy * dy);
			    if (方向长度 === 0) return null;
			    const dirX = dx / 方向长度;
			    const dirY = dy / 方向长度;
			
			    // 计算与画布边界的交点（使用视口实际尺寸）
			    const 画布左 = 0;
			    const 画布右 = 画布Rect.width;
			    const 画布上 = 0;
			    const 画布下 = 画布Rect.height;
			
			    let t = Infinity;
			
			    if (dirX < 0) {
			        const tLeft = (画布左 - 玩家像素X) / dirX;
			        const y = 玩家像素Y + dirY * tLeft;
			        if (y >= 画布上 && y <= 画布下) t = tLeft;
			    }
			
			    if (dirX > 0) {
			        const tRight = (画布右 - 玩家像素X) / dirX;
			        const y = 玩家像素Y + dirY * tRight;
			        if (y >= 画布上 && y <= 画布下) t = Math.min(t, tRight);
			    }
			
			    if (dirY < 0) {
			        const tTop = (画布上 - 玩家像素Y) / dirY;
			        const x = 玩家像素X + dirX * tTop;
			        if (x >= 画布左 && x <= 画布右) t = Math.min(t, tTop);
			    }
			
			    if (dirY > 0) {
			        const tBottom = (画布下 - 玩家像素Y) / dirY;
			        const x = 玩家像素X + dirX * tBottom;
			        if (x >= 画布左 && x <= 画布右) t = Math.min(t, tBottom);
			    }
			
			    if (t === Infinity) return null;
			
			    // 计算最终交点位置（页面坐标）
			    return {
			        x: 玩家像素X + dirX * t + 画布Rect.left,
			        y: 玩家像素Y + dirY * t + 画布Rect.top,
			    };
			}
			
			function 更新物体指示器() {
			    const 容器 = document.getElementById("怪物指示器容器");
			    const 可见怪物 = new Set();

			    所有怪物.forEach((怪物, index) => {
			        if (怪物.状态 !== 怪物状态.活跃) return;
			        if (!怪物.追击玩家中) return;
			        if (怪物 instanceof 巨人部位 || 怪物 instanceof 蜈蚣部位) return;
			
			        const 位置 = 计算精确边缘位置(怪物);
			        if (!位置) {
			            if (指示器缓存.has(index))
			                指示器缓存.get(index).remove();
			            return;
			        }
			
			        let 指示器 = 指示器缓存.get(index);
			        if (!指示器) {
			            指示器 = document.createElement("div");
			            指示器.className = "怪物指示器";
			            容器.appendChild(指示器);
			            指示器缓存.set(index, 指示器);
			        }
			
			        指示器.style.transform = `translate(${位置.x}px, ${位置.y}px)`;
			        可见怪物.add(index);
			    });
			
			    指示器缓存.forEach((指示器, key) => {
			        if (!可见怪物.has(key)) {
			            指示器.remove();
			            指示器缓存.delete(key);
			        }
			    });
			    const 玩家寻宝戒指列表 = Array.from(
			        { length: 装备栏每页装备数 },
			        (_, i) =>
			            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
			    )
			        .filter((v) => v != null)
			        .filter((item) => item instanceof 寻宝戒指);
			    let 玩家寻宝戒指 = null;
			    if (玩家寻宝戒指列表) {
			        玩家寻宝戒指 = 玩家寻宝戒指列表.find(
			            (item) => item.自定义数据.get("生效层数") === 当前层数
			        );
			    } else {
			        const 指示器 = document.querySelector(".折跃门指示器");
			        if (指示器) {
			            指示器.style.display = "none";
			        }
			    }
			    if (玩家寻宝戒指) {
			        const 折跃门位置 =
			            玩家寻宝戒指.自定义数据.get("折跃门位置");
			        if (折跃门位置) {
			            const 屏幕位置 = 计算精确边缘位置({
			                x: 折跃门位置.x,
			                y: 折跃门位置.y,
			            });
			
			            let 指示器 = document.querySelector(".折跃门指示器");
			            if (!指示器) {
			                指示器 = document.createElement("div");
			                指示器.className = "怪物指示器 折跃门指示器";
			                指示器.style.background = "gold";
			                指示器.style.boxShadow = "0 0 8px gold";
			                容器.appendChild(指示器);
			            }
			            if (屏幕位置) {
			                指示器.style.transform = `translate(${屏幕位置.x}px, ${屏幕位置.y}px)`;
			                指示器.style.display = "block";
			            } else {
			                指示器.style.display = "none";
			            }
			        } else {
			            const 指示器 = document.querySelector(".折跃门指示器");
			            if (指示器) {
			                指示器.style.display = "none";
			            }
			        }
			    } else {
			        const 指示器 = document.querySelector(".折跃门指示器");
			        if (指示器) {
			            指示器.style.display = "none";
			        }
			    }

			    const 玩家定位器地图 = Array.from(玩家装备.values()).find(item => item instanceof 定位器地图);
			    let 楼梯指示器 = document.querySelector(".楼梯指示器");

			    if (玩家定位器地图) {
			        let 楼梯位置 = null;
			        for (let y = 0; y < 地牢大小; y++) {
			            for (let x = 0; x < 地牢大小; x++) {
			                if (地牢[y]?.[x]?.类型 === 单元格类型.楼梯下楼||地牢[y]?.[x]?.关联物品 instanceof 旗帜) {
			                    楼梯位置 = { x, y };
			                    break;
			                }
			            }
			            if (楼梯位置) break;
			        }

			        if (楼梯位置) {
			            const 屏幕位置 = 计算精确边缘位置(楼梯位置);
			            if (!楼梯指示器) {
			                楼梯指示器 = document.createElement("div");
			                楼梯指示器.className = "怪物指示器 楼梯指示器";
			                楼梯指示器.style.background = "#2196f3";
			                楼梯指示器.style.boxShadow = "0 0 8px #2196f3";
			                容器.appendChild(楼梯指示器);
			            }
			            
			            if (屏幕位置) {
			                楼梯指示器.style.transform = `translate(${屏幕位置.x}px, ${屏幕位置.y}px)`;
			                楼梯指示器.style.display = "block";
			            } else {
			                楼梯指示器.style.display = "none";
			            }
			        } else if (楼梯指示器) {
			            楼梯指示器.style.display = "none";
			        }
			    } else if (楼梯指示器) {
			        楼梯指示器.style.display = "none";
			    }
			}
			function hexToRgba(hex, alpha) {
			    let r = parseInt(hex.slice(0, 2), 16),
			        g = parseInt(hex.slice(2, 4), 16),
			        b = parseInt(hex.slice(4, 6), 16);
			
			    if (alpha) {
			        return (
			            "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")"
			        );
			    } else {
			        return "rgb(" + r + ", " + g + ", " + b + ")";
			    }
			}
			// Hex转RGB
			function hexToRgb(hex) {
			    hex = hex.replace(/^#/, "");
			    if (hex.length === 3) {
			        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
			    }
			    const num = parseInt(hex, 16);
			    return [(num >> 16) & 0xff, (num >> 8) & 0xff, num & 0xff];
			}
			function blendColors(hexArray) {
			    if (hexArray.length === 0) return "#000000"; // 处理空数组情况
			
			    // RGB转HSL
			    function rgbToHsl(r, g, b) {
			        (r /= 255), (g /= 255), (b /= 255);
			        const max = Math.max(r, g, b),
			            min = Math.min(r, g, b);
			        let h,
			            s,
			            l = (max + min) / 2;
			
			        if (max === min) {
			            h = s = 0;
			        } else {
			            const d = max - min;
			            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			            switch (max) {
			                case r:
			                    h = (g - b) / d + (g < b ? 6 : 0);
			                    break;
			                case g:
			                    h = (b - r) / d + 2;
			                    break;
			                case b:
			                    h = (r - g) / d + 4;
			                    break;
			            }
			            h *= 60;
			        }
			        return [h, s, l];
			    }
			
			    // HSL转RGB
			    function hslToRgb(h, s, l) {
			        let r, g, b;
			        if (s === 0) {
			            r = g = b = l; // 灰色
			        } else {
			            const hue2rgb = (p, q, t) => {
			                if (t < 0) t += 1;
			                if (t > 1) t -= 1;
			                if (t < 1 / 6) return p + (q - p) * 6 * t;
			                if (t < 1 / 2) return q;
			                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
			                return p;
			            };
			            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
			            const p = 2 * l - q;
			            r = hue2rgb(p, q, h / 360 + 1 / 3);
			            g = hue2rgb(p, q, h / 360);
			            b = hue2rgb(p, q, h / 360 - 1 / 3);
			        }
			        return [
			            Math.round(r * 255),
			            Math.round(g * 255),
			            Math.round(b * 255),
			        ];
			    }
			
			    // RGB转Hex
			    function rgbToHex(r, g, b) {
			        return (
			            "#" +
			            [r, g, b]
			                .map((x) => {
			                    const hex = x.toString(16);
			                    return hex.length === 1 ? "0" + hex : hex;
			                })
			                .join("")
			        );
			    }
			
			    // 处理每个Hex颜色
			    const hslArray = hexArray.map((hex) => {
			        const [r, g, b] = hexToRgb(hex);
			        return rgbToHsl(r, g, b);
			    });
			
			    // 计算平均H（向量平均）
			    let sumSin = 0,
			        sumCos = 0;
			    for (const [h] of hslArray) {
			        const radians = (h * Math.PI) / 180;
			        sumSin += Math.sin(radians);
			        sumCos += Math.cos(radians);
			    }
			    const avgH =
			        (Math.atan2(
			            sumSin / hexArray.length,
			            sumCos / hexArray.length
			        ) *
			            180) /
			        Math.PI;
			    const normalizedH = (avgH + 360) % 360; // 确保在0-360度之间
			
			    // 计算平均S和L
			    const avgS =
			        hslArray.reduce((sum, [, s]) => sum + s, 0) /
			        hexArray.length;
			    const avgL =
			        hslArray.reduce((sum, [, , l]) => sum + l, 0) /
			        hexArray.length;
			
			    // 转换回RGB并转为Hex
			    const [r, g, b] = hslToRgb(normalizedH, avgS, avgL);
			    return rgbToHex(r, g, b);
			}
			function 打开收购窗口(npc) {
			    if (界面可见性.背包) 切换背包显示();
			    玩家属性.允许移动 += 1;
			    NPC互动中 = true; // 标记互动中
			    当前NPC = npc; // 保存当前NPC引用
			
			    const 窗口 = document.getElementById("收购窗口");
			    const 需求列表容器 = document.getElementById("收购需求列表");
			    const 玩家列表容器 = document.getElementById("玩家可售列表");
			    const 金币显示 = document.getElementById("收购窗口金币");
			
			    需求列表容器.innerHTML = "";
			    玩家列表容器.innerHTML = "";
			
			    金币显示.textContent = [...玩家背包.values()]
			        .filter((i) => i instanceof 金币)
			        .reduce((sum, i) => sum + i.堆叠数量, 0);
			
			    // 显示收购需求
			    const 需求 = npc.自定义数据.get("收购需求") || [];
			    需求.forEach((req) => {
			        const 元素 = document.createElement("div");
			        元素.className = "收购需求条目";
			        元素.innerHTML = `
			         <span class="需求图标" style="color:${
			             物品池[
			                 Object.keys(物品池).find((key) =>
			                     物品池[key].some(
			                         (item) => item.类.name === req.类名
			                     )
			                 )
			             ]?.find((item) => item.类.name === req.类名)?.类
			                 ?.prototype?.颜色表?.[req.颜色索引] ?? "#FFF"
			         }">${req.图标}</span>
			         <span class="需求名称">${req.名称}${
			            req.强化需求 ? " [强]" : ""
			        } </span>
			         <span class="需求价格">??? 金币</span> <!-- 价格在点击玩家物品时计算 -->
			     `;
			        需求列表容器.appendChild(元素);
			    });
			
			    // 显示玩家可出售物品
			    玩家背包.forEach((item) => {
			        // 检查是否满足任一收购需求
			        const 匹配需求 = 需求.find(
			            (req) =>
			                item.名称 === req.名称 &&
			                (req.强化需求 ? item.强化 === true : true) // 强化需求匹配
			        );
			
			        if (匹配需求) {
			            const 价格 = npc.计算收购价格(item, 匹配需求);
			            if (价格 > 0) {
			                // 价格为0表示不满足强化需求等硬性条件
			                const 元素 = document.createElement("div");
			                元素.className = "玩家可售条目";
			                元素.innerHTML = `
			                <span class="物品图标" style="color:${
			                    item.颜色表[item.颜色索引] ?? "#FFF"
			                }">${item.图标}</span>
			                <span class="物品名称">${item.获取名称()} ${
			                    item.堆叠数量 > 1 ? `x${item.堆叠数量}` : ""
			                }</span>
			                <span class="出售价格">${价格} 金币</span>
			            `;
			                元素.onclick = () => 尝试出售(item, 价格, npc);
			                玩家列表容器.appendChild(元素);
			            }
			        }
			    });
			
			    窗口.style.display = "flex"; // 使用 flex 以便内部布局生效
			}
			
			function 关闭收购窗口() {
			    const 窗口 = document.getElementById("收购窗口");
			    窗口.classList.add("关闭中");
			    setTimeout(() => {
			        窗口.style.display = "none";
			        窗口.classList.remove("关闭中");
			        玩家属性.允许移动 -= 1;
			    }, 300);
			    NPC互动中 = false; // 结束互动
			    当前NPC = null;
			}
			
			function 尝试出售(物品实例, 价格, npc) {
			    if (npc.自定义数据.get("交易次数") <= 0) {
			        显示通知("探险家已经不想再收购了。", "警告");
			        关闭收购窗口();
			        return;
			    }
			
			    // 1. 预计算出售后的背包容量变化
			    let 潜在空格子 = 0;
			    if (物品实例.堆叠数量 === 1) {
			        潜在空格子 = 1; // 如果物品完全移除，会空出一个格子
			    }
			    const 当前物品数量 = [...玩家背包.values()].reduce(
			        (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
			        0
			    );
			    const 预计出售后物品数量 = 当前物品数量 - 潜在空格子;
			
			    // 2. 检查是否有足够的空间放金币
			    const 金币实例 = [...玩家背包.values()].find(
			        (i) => i instanceof 金币
			    );
			    let 需要的金币格子 = 0;
			    if (金币实例) {
			        const 可堆叠空间 = 最大堆叠数 - 金币实例.堆叠数量;
			        const 剩余金币 = 价格 - Math.min(价格, 可堆叠空间);
			        if (剩余金币 > 0) {
			            需要的金币格子 = Math.ceil(剩余金币 / 最大堆叠数); // 计算需要多少个新格子放剩余金币
			        }
			    } else {
			        需要的金币格子 = Math.ceil(价格 / 最大堆叠数); // 没有金币实例，计算需要多少新格子
			    }
			
			    // 比较预计的背包占用和最大容量
			    if (预计出售后物品数量 + 需要的金币格子 > 最大背包容量) {
			        显示通知("背包空间不足，无法完成交易！", "错误");
			        return; // 出售失败
			    }
			    if (物品实例.堆叠数量 > 1) {
			        物品实例.堆叠数量 -= 1;
			    } else {
			        玩家背包.delete(物品实例.唯一标识);
			        if (物品实例.已装备) {
			            玩家装备.delete(物品实例.装备槽位);
			            物品实例.已装备 = false;
			            物品实例.装备槽位 = null;
			        }
			    }
			
			    尝试收集物品(new 金币({ 数量: 价格 }), true); // 直接收集
			
			    npc.自定义数据.set(
			        "交易次数",
			        npc.自定义数据.get("交易次数") - 1
			    );
			
			    // 6. 刷新收购窗口内容
			    玩家属性.允许移动 -= 1;
			    打开收购窗口(npc); // 重新打开以刷新列表和金币
			
			    // 7. 更新UI
			    更新背包显示();
			    更新装备显示();
			    显示通知(
			        `成功出售 ${物品实例.名称}，获得 ${价格} 金币！`,
			        "成功"
			    );
			
			    // 8. 如果交易次数用完，自动关闭窗口
			    if (npc.自定义数据.get("交易次数") <= 0) {
			        显示通知("探险家满意地离开了。", "信息");
			        关闭收购窗口();
			    }
			}
			function 打开交易窗口(npc) {
			    if (npc.自定义数据.get("刷新次数") === 0) {
			        显示通知("货物已告罄", "信息");
			        return;
			    }
			    玩家属性.允许移动 += 1;
			
			    当前NPC = npc;
			    const 窗口 = document.getElementById("交易窗口");
			    窗口.querySelector("#交易次数").textContent =
			        npc.自定义数据.get("刷新次数");
			    窗口.querySelector("#当前金币").textContent = [
			        ...玩家背包.values(),
			    ]
			        .filter((i) => i instanceof 金币)
			        .reduce((sum, i) => sum + i.堆叠数量, 0);
			
			    const 库存容器 = 窗口.querySelector(".库存列表");
			    库存容器.innerHTML = "";
			
			    npc.自定义数据.get("库存").forEach((物品) => {
			        let 价格 = npc.获取价格(物品);
			        const 元素 = document.createElement("div");
			        元素.className = "交易物品条目";
			        元素.innerHTML = `
			<div class="物品头">
			    <span style="color:${
			        物品.颜色表[物品.颜色索引]
			    }; font-family: color-emoji">${物品.图标}</span>
			    ${物品.获取名称()}
			    <span class="物品价格">${价格} 金币</span>
			</div>
			<div class="物品描述">${物品.效果描述 || "神秘物品"}</div>
			        `;
			
			        元素.addEventListener("click", () => 尝试购买(物品, 价格));
			        库存容器.appendChild(元素);
			    });
			
			    窗口.style.display = "block";
			    窗口.classList.remove("关闭中");
			    document.body.appendChild(窗口);
			}
			
			function 尝试购买(物品, 价格) {
			    const npc = 当前NPC;
			    const 金币列表 = [...玩家背包.values()].filter(
			        (i) => i instanceof 金币
			    );
			    const 总金币 = 金币列表.reduce((sum, i) => sum + i.堆叠数量, 0);
			
			    if (总金币 < 价格) {
			        显示通知("金币不足！", "错误");
			        return;
			    }
			    // 添加物品
			    if (物品.类型 === "NPC" && !彩蛋2触发) {
			        显示通知("就是你小子在酒吧里点了一个酒吧!?", "信息", true);
			        彩蛋2触发 = true;
			    }
			    const 新物品 = 克隆物品(物品);
			    if (!尝试收集物品(新物品, true)) {
			        //注意：如果购买物品数量多，则会出现部分成功收集并返回false的情况
			        return;
			    }
			
			    if (!扣除金币(价格)) {
			        显示通知("金币不足！", "错误");
			        return;
			    }
			
			    // 更新NPC状态
			    npc.自定义数据.set(
			        "刷新次数",
			        npc.自定义数据.get("刷新次数") - 1
			    );
			
			    更新背包显示();
			    显示通知(`购买 ${物品.名称} 成功！`, "成功");
			    关闭交易窗口();
			}
			
			function 关闭交易窗口() {
			    document.getElementById("交易窗口").classList.add("关闭中");
			    setTimeout(() => {
			        document.getElementById("交易窗口").style.display = "none";
			        玩家属性.允许移动 -= 1;
			    }, 300);
			
			    当前NPC = null;
			    NPC互动中 = false;
			}
			
			function 进入教程层() {
			    是否为教程层 = true;
			    教程阶段 = 0;
			    教程提示已显示 = false;
			    document.getElementById("跳过教程按钮").style.display = "block";
			    生成教程地牢();
			    setTimeout(() => {
			        显示教程提示();
			    }, 200);
			    更新物体指示器();
			    所有怪物.forEach((m) => {
			        m.绘制血条();
			    });
			    更新洞穴视野();
			}
			
			function 跳过教程() {
			    是否为教程层 = false;
			    document.getElementById("跳过教程按钮").style.display = "none";
			    所有怪物.forEach((m) => {
			        m.绘制血条(true);
			        if (地牢[m.y] && 地牢[m.y][m.x])
			            地牢[m.y][m.x].关联怪物 = null;
			    });
			    所有怪物 = [];
			    当前出战宠物列表 = [];
			    重置玩家状态();
			    最高教程阶段 = 6;
			    切换楼层(0);
			    更新洞穴视野();
			}
			
			function 重置玩家状态() {
			    最大背包容量 = 12;
			    if (当前激活卷轴列表.size > 0) {
			        当前激活卷轴列表.forEach((卷轴) => {
			            当前激活卷轴列表.delete(卷轴);
			            卷轴.卸下();
			        });
			    }
			    玩家属性 = { ...初始玩家属性 };
			    玩家背包.clear();
			    玩家装备.clear();
			    玩家状态.forEach((m) => {
			        m.移除状态();
			    });
			    玩家状态 = [];
			    // 重置 HUD
			    document.querySelector(".health-bar").style.width = "100%";
			    document.querySelector(".power-bar").style.width = "100%";
			    更新装备显示();
			    更新背包显示();
			    应用职业效果(玩家职业);
			    if (开发者模式) {
try {
尝试收集物品(new 调试工具({}), true);
} catch (e) {}
}
			}
			
			function 生成教程地牢() {
			    地牢 = Array(地牢大小)
			        .fill()
			        .map((_, y) =>
			            Array(地牢大小)
			                .fill()
			                .map((_, x) => new 单元格(x, y))
			        );
			    房间列表 = [];
			    上锁房间列表 = [];
			    所有怪物 = [];
			    门实例列表 = new Map();
			    房间地图 = Array(地牢大小)
			        .fill()
			        .map(() => Array(地牢大小).fill(-1));
			    已访问房间 = new Set();
			
			    const 教程房间配置 = [
			        { x: 10, y: 10, w: 7, h: 5, id: 0, 门: [] }, // 初始房间：移动教学
			        { x: 20, y: 10, w: 7, h: 5, id: 1, 门: [] }, // 背包、装备教学：钢制长剑
			        { x: 30, y: 10, w: 7, h: 5, id: 2, 门: [] }, // 战斗、HUD、互动教学：普通怪物
			        { x: 40, y: 10, w: 7, h: 5, id: 3, 门: [] }, // 上锁房间、药水、强化：上锁的门，房间内有狂暴药水
			        { x: 50, y: 10, w: 7, h: 5, id: 4, 门: [] }, // 卷轴、冰冻怪物：冰冻怪物，清净卷轴（未鉴定）
			        { x: 60, y: 10, w: 7, h: 5, id: 5, 门: [] }, // 新物品：商人、祭坛、宠物
			        { x: 70, y: 10, w: 7, h: 5, id: 6, 门: [] }, // 下楼
			    ];
			
			    for (const 房间配置 of 教程房间配置) {
			        房间列表.push(房间配置);
			        放置房间(房间配置);
			    }
			    房间列表.sort((a,b)=>a.id-b.id)
			
			    for (let i = 0; i < 房间列表.length - 1; i++) {
			        let 路径 = 连接房间(房间列表[i], 房间列表[i + 1]);
			        if (路径) {
			            生成走廊(路径);
			        }
			    }
			    生成墙壁();
			
			    const 颜色索引 = 3 % 颜色表.length;
			    房间列表[3].门.forEach((门) => {
			        const 单元格 = 地牢[门.y][门.x];
			        门实例列表.get(单元格.标识).类型 = "上锁的门";
			        if (单元格.背景类型 === 单元格类型.门) {
			            单元格.背景类型 = 单元格类型.上锁的门;
			            单元格.钥匙ID = 房间列表[3].id;
			            单元格.颜色索引 = 颜色索引;
			        }
			    });
			    上锁房间列表.push({ ...房间列表[3], 颜色索引 });
			
			    const 第一个房间 = 房间列表[0];
			    玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
			    玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			    已访问房间.add(第一个房间.id);
			
			    放置物品到房间(new 钢制长剑({ 不可破坏: true }), 房间列表[1]);
			    放置怪物到单元格(
			        new 怪物({
			            掉落概率: 1,
			            基础攻击力: 1,
			            基础生命值: 15,
			            掉落物: new 钥匙({
			                对应门ID: 上锁房间列表[0].id,
			                颜色索引: 上锁房间列表[0].颜色索引,
			                地牢层数: -1,
			            }),
			        }),
			        房间列表[2].x + 3,
			        房间列表[2].y + 2
			    );
			
			    放置怪物到单元格(
			        new 怪物({
			            基础攻击力: 1,
			            基础生命值: 15,
			            强化: true,
			            掉落物: new 金币({ 数量: 64 }),
			        }),
			        房间列表[3].x + 3,
			        房间列表[3].y + 2
			    );
			    放置物品到房间(
			        new 清净卷轴({ 已解锁: false, 强化: true }),
			        房间列表[3]
			    );
			    放置物品到房间(new 狂暴药水({ 强化: true }), 房间列表[3]);
			
			    放置怪物到单元格(
			        new 冰冻怪物({
			            基础攻击力: 3,
			            基础生命值: 45,
			            掉落物: new 冰盾({}),
			            掉落概率: 1,
			        }),
			        房间列表[4].x + 2,
			        房间列表[4].y + 2
			    );
			    放置物品到房间(new 神秘商人({}), 房间列表[5]);
			    放置物品到房间(new 物品祭坛({}), 房间列表[5]);
			    放置物品到房间(new 宠物({}), 房间列表[5]);
			    //生成解谜棋盘(房间列表[1]);
			    //房间列表[1].类型 = "隐藏解谜棋盘"
			    放置楼梯(
			        房间列表[房间列表.length - 1],
			        楼梯图标.下楼,
			        单元格类型.楼梯下楼
			    );
			    房间列表.forEach((房间) => 更新房间墙壁(房间));
			    更新视口();
			    绘制();
			}
			function 显示教程提示(强制 = false) {
			    if (教程提示已显示 && !强制) return;
			
			    const 提示窗口 = document.getElementById("教程提示窗口");
			    const 提示内容元素 = document.getElementById("教程提示内容");
			
			    if (教程阶段 > 最高教程阶段) {
			        最高教程阶段 = 教程阶段;
			    }
			
			    let 提示文本 = 获取教程文本(教程阶段);
			
			    if (提示文本 === "未知教程阶段") {
			        提示窗口.style.display = "none";
			        return;
			    }
			
			    提示内容元素.innerHTML = 提示文本;
			    提示窗口.style.display = "block";
			    玩家属性.允许移动++;
			    教程提示已显示 = true;
			}
			
			function 打开教程回放窗口() {
			    if (教程提示已显示) 关闭教程提示();
			    const 回放窗口 = document.getElementById("教程回放窗口");
			    当前回放阶段 = 0;
			    显示回放教程页(当前回放阶段);
			    回放窗口.style.display = "block";
			    玩家属性.允许移动 += 1;
			
			    document.getElementById("上一页教程按钮").onclick = () => {
			        if (当前回放阶段 > 0) {
			            当前回放阶段 = 获取上一个有效阶段(当前回放阶段);
			            显示回放教程页(当前回放阶段);
			        }
			    };
			    document.getElementById("下一页教程按钮").onclick = () => {
			        const 下一阶段 = 获取下一个有效阶段(当前回放阶段);
			        if (下一阶段 !== null && 下一阶段 <= 最高教程阶段) {
			            当前回放阶段 = 下一阶段;
			            显示回放教程页(当前回放阶段);
			        }
			    };
			}
			
			function 获取上一个有效阶段(当前阶段) {
			    let 上一阶段 = 当前阶段;
			    do {
			        if (上一阶段 === 2.5) 上一阶段 = 2;
			        else 上一阶段 = Math.floor(上一阶段 - 1);
			    } while (
			        上一阶段 > 0 &&
			        获取教程文本(上一阶段) === "未知教程阶段"
			    );
			    return Math.max(0, 上一阶段);
			}
			
			function 获取下一个有效阶段(当前阶段) {
			    let 下一阶段 = 当前阶段;
			    do {
			        if (下一阶段 === 2) 下一阶段 = 2.5;
			        else 下一阶段 = Math.ceil(下一阶段 + 1);
			    } while (
			        获取教程文本(下一阶段) === "未知教程阶段" &&
			        下一阶段 <= 6
			    ); // 假设最大阶段是6
			
			    return 下一阶段 <= 6 ? 下一阶段 : null; // 如果超过最大阶段，返回null
			}
			
			function 显示回放教程页(阶段) {
			    const 内容元素 = document.getElementById("教程回放内容");
			    const 页码元素 = document.getElementById("教程页码");
			    const 上一页按钮 = document.getElementById("上一页教程按钮");
			    const 下一页按钮 = document.getElementById("下一页教程按钮");
			
			    内容元素.innerHTML = 获取教程文本(阶段);
			
			    let 当前页码 = 1;
			    let 总页数 = 1;
			    let temp阶段 = 0;
			    while (temp阶段 < 最高教程阶段) {
			        const 下一阶段 = 获取下一个有效阶段(temp阶段);
			        if (下一阶段 === null || 下一阶段 > 最高教程阶段) break;
			        总页数++;
			        if (下一阶段 <= 阶段) 当前页码++;
			        temp阶段 = 下一阶段;
			    }
			
			    页码元素.textContent = `${当前页码} / ${总页数}`;
			
			    上一页按钮.disabled = 阶段 <= 0;
			    const 下一阶段 = 获取下一个有效阶段(阶段);
			    下一页按钮.disabled =
			        下一阶段 === null || 下一阶段 > 最高教程阶段;
			}
			
			function 关闭教程回放窗口() {
			    const 回放窗口 = document.getElementById("教程回放窗口");
			    回放窗口.classList.add("关闭中"); // 复用关闭动画类
			    setTimeout(() => {
			        回放窗口.style.display = "none";
			        回放窗口.classList.remove("关闭中");
			    }, 300);
			    玩家属性.允许移动 -= 1;
			}
			function 获取教程文本(阶段) {
			    let 提示文本 = "";
			    const isMobile = window.innerWidth < 769;
			
			    switch (阶段) {
			        case 0:
			            提示文本 = isMobile
			                ? `欢迎来到中文地牢！<br>
			    <b>基础移动：</b><br>
			    - 长按方向键可以连续移动。<br>
			    - 直接点击地图上的目标位置，角色会自动寻路。<br>
			    <br>
			    <b>注意：</b>长按移动会忽略攻击和互动，适合快速探索。<br>
			    <b>兼容模式:</b>如果 emoji 无法显示，可以点击设置按钮⚙️再点击'切换为中文模式'按钮`
			                : `欢迎来到中文地牢！<br>
			    <b>基础移动：</b><br>
			    - 使用 W (上)、A (左)、S (下)、D (右) 键 或 ↑↓←→ 方向键移动。<br>
			    - 直接点击地图上的目标位置，角色会自动寻路。<br>
			    <br>
			    <b>兼容模式:</b>如果 emoji 无法显示，可以在主菜单切换成汉字模式`;
			            break;
			        case 1:
			            提示文本 = isMobile
			                ? `<b>背包与装备：</b><br>
			    - 打开背包：点击屏幕下方的背包图标 ${图标映射.背包按钮}。<br>
			    - 背包功能：<br>
			        - 点击物品：使用、丢弃或装备物品。丢弃的物品按互动键可以捡回。<br>
			        - 装备武器：点击武器，再点击“装备”按钮（${图标映射.装备按钮}）。<br>
			       
			    - 装备栏 (屏幕右下角的“田”字格)：<br>
			        - 单击装备槽内物品以使用，左右滑动可以换页<br>
			    请尝试打开背包，装备上你找到的钢制长剑。`
			                : `<b>背包与装备：</b><br>
			    - 打开背包：按 E 键。<br>
			    - 背包功能：<br>
			        - 点击物品：使用、丢弃或装备物品。丢弃的物品按互动键可以捡回。<br>
			        - 装备武器：点击武器，再点击“装备”按钮（${图标映射.装备按钮}）。<br>
			      
			    - 装备栏 (屏幕右下角的“田”字格)：<br>
			        - 使用数字键 1-4 使用对应槽位物品，右键卸下，J、K键可以换页。<br>
			    请尝试打开背包，装备上你找到的钢制长剑。`;
			            break;
			        case 2: // 进入房间时的提示
			            提示文本 = isMobile
			                ? `<b>战斗与HUD：</b><br>
			    - HUD（屏幕左上角）：<br>
			         - 显示/隐藏：点击眼睛图标 ${图标映射.HUD智能} 按钮。<br>
			        - ❤️ 生命条：显示你的生命值。<br>
			        - ⚡ 能量条：显示你的能量值（使用卷轴等特殊物品会消耗）。<br>
			    - 武器有冷却时间与耐久，耐久即将耗尽时可以停止使用，后续等待机会修补<br>
			    <b>战斗：</b><br>
			    - 靠近怪物，使用已装备的武器攻击它（点击装备栏中武器）。<br>
			    - 击败怪物可获得战利品。<br>`
			                : `<b>战斗与HUD：</b><br>
			    - HUD（屏幕左上角）：<br>
			        - 显示/隐藏：按 Q 键。<br>
			        - ❤️ 生命条：显示你的生命值。<br>
			        - ⚡ 能量条：显示你的能量值（使用卷轴等特殊物品会消耗）。<br>
			     - 武器有冷却时间与耐久，耐久即将耗尽时可以停止使用，后续等待机会修补<br>
			    <b>战斗：</b><br>
			    - 靠近怪物，使用已装备的武器攻击它（按对应数字键）。<br>
			    - 击败怪物可获得战利品。<br>`;
			            break;
			
			        case 2.5: // 击败怪物后的提示
			            提示文本 = isMobile
			                ? `<b>互动：</b><br>
			    - 点击屏幕下方的互动按钮 ${图标映射.互动按钮}。<br>
			    - 互动功能：<br>
			        - 拾取周围的物品（直接走到物品的格子上也可以拾取）。<br>
			        - 打开上锁的门（需要拥有对应颜色的钥匙）。<br>
			        - 与 NPC、祭坛等互动。<br>
			        - 自动选择武器并攻击范围内的敌人。<br>
			     <b>提示：</b>掉落的钥匙有光晕，门的颜色和钥匙发出的光晕的颜色要一致才能解锁。<br>
			     请使用互动键拾取钥匙,并尝试打开下一道门.`
			                : `<b>互动：</b><br>
			    - 按 F 键。<br>
			    - 互动功能：<br>
			        - 拾取周围的物品（直接走到物品的格子上也可以拾取）。<br>
			        - 打开上锁的门（需要拥有对应颜色的钥匙）。<br>
			        - 与 NPC、祭坛等互动。<br>
			        - 自动选择武器并攻击范围内的敌人。<br>
			    <b>提示：</b>掉落的钥匙有光晕，门的颜色和钥匙发出的光晕的颜色要一致才能解锁。<br>
			     请使用互动键拾取钥匙,并尝试打开下一道门.`;
			            break;
			        case 3:
			            提示文本 = `你成功打开了上锁的房间！<br>
			    <b>强化物品：</b><br>
			    - 上锁房间内通常有更高品质的物品，它们带有强化效果，属性更强。<br>
			    - 注意：怪物也会被强化！<br>
			    <br>
			    <b>药水：</b><br>
			    - 药水有持续时间，效果会在一定回合后消失。<br>
			    - 在关键时候打开背包使用药水,它可以救你一命！`;
			            break;
			        case 4:
			            提示文本 = isMobile
			                ? `<b>卷轴与能量：</b><br>
			    - 卷轴是强大的消耗品，但使用需要消耗能量，能量条在左上角的HUD中显示，并随玩家移动恢复。<br>
			    - 卷轴使用方法：<br>
			        1. 装备：打开背包(${图标映射.背包按钮})，点击卷轴，再点击“装备”按钮(${图标映射.装备按钮})。<br>
			        2. 激活：点击屏幕下方的卷轴图标 ${图标映射.卷轴按钮} 按钮,再点击装备栏中高亮的卷轴。<br>
			    - 你获得的清净卷轴可以移除自身的所有状态效果。<br>
			    - 卷轴需要使用特殊卷轴解读后才能知道效果。<br>
			    - 激活后再点击装备槽中高亮的卷轴可以取消激活`
			                : `<b>卷轴与能量：</b><br>
			    - 卷轴是强大的消耗品，但使用需要消耗能量，能量条在左上角的HUD中显示。玩家移动/探索房间/击杀怪物均可恢复能量，但是只依靠玩家移动恢复能量是不可取的。<br>
			    - 卷轴使用方法：<br>
			        1. 装备：打开背包(E)，点击卷轴，再点击“装备”按钮(${图标映射.装备按钮})。<br>
			        2. 激活：按 R 键。<br>
			     - 你获得的清净卷轴可以移除自身的所有状态效果。<br>
			    - 卷轴需要使用特殊卷轴解读后才能知道效果。<br>
			    - 激活后再点击装备槽中高亮的卷轴可以取消激活`;
			            break;
			
			        case 5:
			            提示文本 = `<b>探索更多：</b><br>
			   这个房间里有一些特殊的物品，为你展示地牢物品的多样。<br>
			    如果背包已满，你可以尝试丢掉一些物品或将它们装备给宠物。<br>
			    如果装备槽已满，长按或右键已装备物品可以将其卸下<br>
			    遇到未知物品尝试与其互动 或 拾起后在背包中使用。`;
			            break;
			        case 6:
			            提示文本 = isMobile
			                ? `<b>开始游戏：</b><br>
			    点击设置⚙️可以打开功能菜单<br>
			    - 地牢有很多层，每层都有不同的怪物和宝藏。<br>
			    - 找到并走下楼梯 ${图标映射.下楼楼梯} 即可进入下一层，开始你的冒险！`
			                : `<b>开始游戏：</b><br>
			    按 G 键可以打开日志界面。<br>
			    按 Z 键可以导出存档。<br>
			    按 U 键可以自杀。<br>
			    - 地牢有很多层，每层都有不同的怪物和宝藏。<br>
			    - 找到并走下楼梯 ${图标映射.下楼楼梯} 即可进入下一层，开始你的冒险！`;
			            break;
			        case "首领挑战":
    提示文本 = `<b>首领挑战模式：</b><br>你将面对一系列强大的首领和怪物组合。祝你好运！`;
    break;
			        default:
			            提示文本 = "未知教程阶段"; // 或者返回空字符串
			    }
			    return 提示文本;
			}
			function 关闭教程提示() {
			    const 提示窗口 = document.getElementById("教程提示窗口");
			    if (提示窗口) {
			        提示窗口.classList.add("关闭中");
			        教程提示已显示 = false;
			        setTimeout(() => {
			            提示窗口.style.display = "none";
			            提示窗口.classList.remove("关闭中");
			            玩家属性.允许移动 -= 1;
			            玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
			        }, 300);
			    }
			}
			
			const 安全参数 = {
			    方程组: [
			        {
			            a: 7,
			            b: 3,
			            c: 2,
			            d: 5,
			        },
			        {
			            a: 4,
			            b: 9,
			            c: 6,
			            d: 8,
			        },
			    ],
			    模数: 9973,
			};
			
			function 生成死亡凭证(L) {
			    let R;
			    do {
			        // R ≡ (L^2 + 1) mod 13
			        const 基础值 = (L * L + 1) % 13;
			        R =
			            基础值 +
			            Math.floor(prng() * (安全参数.模数 - 基础值)) *
			                13;
			    } while (R >= 安全参数.模数 || R === 0);
			
			    const 方程计算 = (系数, L, R) => {
			        const 项1 = 系数.a * L;
			        const 项2 = 系数.b * R * R;
			        const 项3 = 系数.c * L * R;
			        const 项4 = 系数.d * R * R * R;
			        return (项1 + 项2 + 项3 + 项4) % 安全参数.模数;
			    };
			
			    const C1 = 方程计算(安全参数.方程组[0], L, R);
			    const C2 = 方程计算(安全参数.方程组[1], L, R);
			
			    const 组件 = [
			        L.toString().padStart(3, "0"),
			        R.toString().padStart(4, "0"),
			        (C1 + C2).toString().padStart(3, "0"),
			    ];
			
			    return 组件.join("-");
			}
			
			function 验证死亡凭证(凭证, 待验层数) {
			    const [L部分, R部分, C部分] = 凭证.split("-");
			    const L = parseInt(L部分);
			    const R = parseInt(R部分);
			    const 总校验码 = parseInt(C部分);
			
			    if (L !== 待验层数 || R <= 0 || R >= 安全参数.模数)
			        return false;
			
			    // R ≡ (L² +1) mod 13
			    if (R % 13 !== (L * L + 1) % 13) return false;
			
			    const 方程计算 = (系数, L, R) => {
			        const 计算值 =
			            系数.a * L +
			            系数.b * R * R +
			            系数.c * L * R +
			            系数.d * R * R * R;
			        return 计算值 % 安全参数.模数;
			    };
			
			    const 真实C1 = 方程计算(安全参数.方程组[0], L, R);
			    const 真实C2 = 方程计算(安全参数.方程组[1], L, R);
			
			    return 真实C1 + 真实C2 === 总校验码;
			}
			
			function CopyTextToClipboard(val) {
			    const textArea = document.createElement("textArea");
			    textArea.value = val;
			    textArea.style.width = 0;
			    textArea.style.position = "fixed";
			    textArea.style.left = "-999px";
			    textArea.style.top = "10px";
			    textArea.setAttribute("readonly", "readonly");
			    document.body.appendChild(textArea);
			
			    textArea.select();
			    document.execCommand("copy");
			    document.body.removeChild(textArea);
			}
			function 获取附魔描述(enchantments) {
			    const numberToRoman = (num) => {
			        const romanMap = {
			            1: "I",
			            2: "II",
			            3: "III",
			            4: "IV",
			            5: "V",
			            6: "VI",
			            7: "VII",
			            8: "VIII",
			            9: "IX",
			            10: "X",
			        };
			        return romanMap[num] || "";
			    };
			
			    return enchantments
			        .map((enchant) => {
			            const romanLevel = numberToRoman(enchant.等级);
			            return `[${enchant.种类}] ${romanLevel}级`;
			        })
			        .join("\n");
			}
			
			function 切换设置菜单() {
    const 菜单 = document.getElementById("设置菜单");
    const 重置按钮 = document.getElementById("重置关卡按钮");
    const 导出按钮 = document.getElementById("导出存档按钮");
    const 导出当前状态按钮 = document.getElementById("导出当前状态按钮");
	const 复制画面按钮 = document.getElementById("复制画面按钮");

    if (菜单.classList.contains("显示")) {
        菜单.classList.remove("显示");
        菜单.classList.add("隐藏");
        setTimeout(() => {
            菜单.classList.remove("隐藏");
            玩家属性.允许移动 -= 1;
        }, 300);
    } else {
        if (重置按钮) {
             重置按钮.style.display = 是否是自定义关卡 ? 'block' : 'none';
        }
        if (导出按钮) {
             导出按钮.style.display = 是否是自定义关卡 ? 'none' : 'block';
             if (是否为教程层) {
            导出按钮.style.display = 'none';
        }
        if (游戏状态 === "图鉴") {
            导出按钮.style.display = 'none';
        }
        }
        if (导出当前状态按钮) {
            导出当前状态按钮.style.display = (游戏状态 === '编辑器游玩' && 开发者模式) ? 'block' : 'none';
        }
		if (复制画面按钮) {
			复制画面按钮.style.display = 命令行模式开启 ? 'block' : 'none';
		}
        菜单.classList.remove("隐藏");
        菜单.classList.add("显示");
        玩家属性.允许移动 += 1;
    }
}

function 获取单元格字符(x, y) {
	if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return ' ';

	const 玩家在当前位置 = 玩家.x === x && 玩家.y === y;
	if (玩家在当前位置) return '@';

	const 单元格 = 地牢[y]?.[x];
	if (!单元格) return '   ';

	const 怪物 = 单元格.关联怪物;
	if (怪物) return 怪物.图标 || 'M';
	
	const 物品 = 单元格.关联物品;
	if (物品 && !物品.是否为隐藏物品) return 物品.图标 || '§';

	switch (单元格.背景类型) {
		case 单元格类型.墙壁: return 获取墙壁字符(单元格);
		case 单元格类型.门: return ' +';
		case 单元格类型.上锁的门: return ' #';
		case 单元格类型.走廊: return ' ·';
		case 单元格类型.房间: return ' .';
		default: return ' ';
	}
}

function 复制命令行画面() {
	if (!命令行模式开启) {
		显示通知("此功能仅在命令行模式下可用。", "警告");
		return;
	}

	const 视野大小 = 相机显示边长;
	const 画面字符串数组 = [];
	
	for (let y = 0; y < 视野大小; y++) {
		let 行 = '';
		for (let x = 0; x < 视野大小; x++) {
			const 世界X = 视口偏移X + x;
			const 世界Y = 视口偏移Y + y;
			行 += 获取单元格字符(世界X, 世界Y);
		}
		画面字符串数组.push(行);
	}
	
	const 最终字符串 = 画面字符串数组.join('\n');
	CopyTextToClipboard(最终字符串);
	显示通知("当前画面已复制到剪贴板！", "成功");
	关闭设置菜单();
}
			
			function 关闭设置菜单() {
			    const 菜单 = document.getElementById("设置菜单");
			    菜单.classList.remove("显示");
			    菜单.classList.add("隐藏"); // 添加隐藏类以触发动画
			    setTimeout(() => {
			        菜单.classList.remove("隐藏");
			        玩家属性.允许移动 -= 1;
			        玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
			    }, 300);
			}
			async function 导出当前状态为创意关卡() {
    if (游戏状态 !== '编辑器游玩' || !开发者模式) {
        显示通知("此功能仅在开发者模式下的编辑器游玩中使用。", "错误");
        return;
    }

    const 关卡标题 = prompt("请输入关卡标题：", "我的实时状态关卡");
    if (关卡标题 === null || 关卡标题.trim() === "") {
        显示通知("已取消发布。", "信息");
        return;
    }

    try {
        const 实时状态字符串 = 保存游戏状态();
        if (!实时状态字符串) {
            throw new Error("无法获取当前游戏状态。");
        }
        
        const 地图数据 = JSON.parse(实时状态字符串);

        // 设置为已发布状态
        地图数据.关卡标题 = 关卡标题;
        地图数据.isPublished = true;
        地图数据.强制动画模式 = 切换动画;
        
        // 清理不应包含在发布文件中的编辑器特定数据
        delete 地图数据.编辑器状态数据;
        delete 地图数据.配方信息;

        // --- 签名开始 ---
        delete 地图数据.signature;
        const 数据字符串 = JSON.stringify(地图数据);
        地图数据.signature = await 生成签名(数据字符串);
        // --- 签名结束 ---
        
        const 地图字符串最终 = JSON.stringify(地图数据);
        const 数据块 = new Blob([地图字符串最终], { type: 'application/json' });
        const 下载链接 = URL.createObjectURL(数据块);
        const 链接元素 = document.createElement('a');
        链接元素.href = 下载链接;
        const 时间戳 = new Date().toISOString().replace(/[:.]/g, "-");
        链接元素.download = `[DEV]${关卡标题}_${时间戳}.json`;
        document.body.appendChild(链接元素);
        链接元素.click();
        document.body.removeChild(链接元素);
        URL.revokeObjectURL(下载链接);
        显示通知('当前状态已作为创意关卡导出!', '成功');
    } catch (e) {
        显示通知('导出当前状态时发生错误！', '错误');
        console.error(e);
    }
}
			function 更新视口(直接更新 = false, x = 玩家.x, y = 玩家.y) {
			    const 视野偏移 = Math.floor(相机显示边长 / 2);
			    let 目标X = x - 视野偏移;
			    let 目标Y = y - 视野偏移;
			
			    const 检查视口碰撞 = (试探X, 试探Y) => {
			        for (let viewY = 0; viewY < 相机显示边长; viewY++) {
			            for (let viewX = 0; viewX < 相机显示边长; viewX++) {
			                const worldX = 试探X + viewX;
			                const worldY = 试探Y + viewY;
			
			                if (worldX < 0 || worldX >= 地牢大小 || worldY < 0 || worldY >= 地牢大小) continue;
			
			                const 单元格 = 地牢[worldY]?.[worldX];
			                if (单元格?.关联物品?.阻碍视野 && 游戏状态!=='地图编辑器') {
			                    return false; 
			                }
			            }
			        }
			        return true;
			    };
			
			    let 最终目标X = 当前相机X;
			    let 最终目标Y = 当前相机Y;
			
			    let 试探X = Math.max(0, Math.min(目标X, 地牢大小 - 相机显示边长));
			    if (检查视口碰撞(Math.floor(试探X), Math.floor(当前相机Y))) {
			        最终目标X = 试探X;
			    } else {
			        最终目标X = Math.floor(当前相机X);
			    }
			
			    let 试探Y = Math.max(0, Math.min(目标Y, 地牢大小 - 相机显示边长));
			    if (检查视口碰撞(Math.floor(最终目标X), Math.floor(试探Y))) {
			        最终目标Y = 试探Y;
			    } else {
			        最终目标Y = Math.floor(当前相机Y);
			    }
			
			    if (相机目标X !== 最终目标X || 相机目标Y !== 最终目标Y) {
			        相机锁定 = true;
			        相机目标X = 最终目标X;
			        相机目标Y = 最终目标Y;
			        if (直接更新) {
			            视口偏移X = Math.floor(最终目标X);
			            视口偏移Y = Math.floor(最终目标Y);
			            当前相机X = 最终目标X;
			            当前相机Y = 最终目标Y;
			        }
			    }
			}
			function 查找配对传送门(源传送门) {
			    if (!源传送门) return null;
			    for (const 传送门 of 所有传送门) {
			        if ((传送门.y !== 源传送门.y || 传送门.x !== 源传送门.x) && 传送门.自定义数据.get('传送门ID') === 源传送门.自定义数据.get('传送门ID')) {
			            return 传送门;
			        }
			    }
			    return null;
			}
			
			function 寻找传送出口(传送门) {
			    const 方向 = [[0, 1], [0, -1], [1, 0], [-1, 0]];
			    for (const [dx, dy] of 方向) {
			        const x = 传送门.x + dx;
			        const y = 传送门.y + dy;
			        if (位置是否可用(x, y, false)) {
			            return { x, y };
			        }
			    }
			    return null; 
			}
			
			function 方向到向量(方向) {
			    if (方向 === 'N') return { dx: 0, dy: -1 };
			    if (方向 === 'S') return { dx: 0, dy: 1 };
			    if (方向 === 'E') return { dx: 1, dy: 0 };
			    if (方向 === 'W') return { dx: -1, dy: 0 };
			    return null;
			}
			
			function 向量到角度(dx, dy) {
			    return (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
			}
			function 旋转方向(原始方向, 旋转角度) {
			    const 方向列表 = ['N', 'E', 'S', 'W'];
			    const 角度 = ((旋转角度 % 360) + 360) % 360;
			
			    const 当前索引 = 方向列表.indexOf(原始方向);
			    if (当前索引 === -1) {
			        return 原始方向; 
			    }
			
			    if (角度 === 0) {
			        return 原始方向;
			    }
			
			    const 步数 = 角度 / 90;
			    const 新索引 = (当前索引 + 步数) % 4;
			    
			    return 方向列表[新索引];
			}
			
			function 应用旋转({ dx, dy }, 旋转角度) {
			    const 弧度 = 旋转角度 * Math.PI / 180;
			    const cos = Math.cos(弧度);
			    const sin = Math.sin(弧度);
			    const 新dx = Math.round(dx * cos - dy * sin);
			    const 新dy = Math.round(dx * sin + dy * cos);
			    return { dx: 新dx, dy: 新dy };
			}
			
			function 寻找传送门出口向量(传送门) {
			    const { x, y } = 传送门;
			    const 检查方向 = [
			        { dir: 'N', dx: 0, dy: -1 }, { dir: 'S', dx: 0, dy: 1 },
			        { dir: 'E', dx: 1, dy: 0 }, { dir: 'W', dx: -1, dy: 0 }
			    ];
			    for (const { dx, dy } of 检查方向) {
			        const 邻居X = x + dx;
			        const 邻居Y = y + dy;
			        const 邻居单元格 = 地牢[邻居Y]?.[邻居X];
			        if (邻居单元格 && [单元格类型.房间, 单元格类型.走廊].includes(邻居单元格.背景类型) && !邻居单元格?.阻碍视野) {
			            return { dx, dy };
			        }
			    }
			    return null; // 如果周围都被墙堵住了，则没有出口
			}
			function 旋转墙壁属性(墙壁对象, 旋转角度) {
			    const 新墙壁 = { 上: false, 右: false, 下: false, 左: false };
			    const 角度 = ((旋转角度 % 360) + 360) % 360;
			
			    if (角度 === 0) {
			        return { ...墙壁对象 };
			    }
			
			    if (角度 === 90) {
			        if (墙壁对象.上) 新墙壁.右 = true;
			        if (墙壁对象.右) 新墙壁.下 = true;
			        if (墙壁对象.下) 新墙壁.左 = true;
			        if (墙壁对象.左) 新墙壁.上 = true;
			    } else if (角度 === 180) {
			        if (墙壁对象.上) 新墙壁.下 = true;
			        if (墙壁对象.下) 新墙壁.上 = true;
			        if (墙壁对象.左) 新墙壁.右 = true;
			        if (墙壁对象.右) 新墙壁.左 = true;
			    } else if (角度 === 270) {
			        if (墙壁对象.上) 新墙壁.左 = true;
			        if (墙壁对象.左) 新墙壁.下 = true;
			        if (墙壁对象.下) 新墙壁.右 = true;
			        if (墙壁对象.右) 新墙壁.上 = true;
			    } else {
			        return { ...墙壁对象 };
			    }
			
			    return 新墙壁;
			}
			function 快速检查相邻移动(起始X, 起始Y, 目标X, 目标Y,无视物品=false) {
			
			
			    const 起始单元格 = 地牢[起始Y]?.[起始X];
			    const 目标单元格 = 地牢[目标Y]?.[目标X];
			
			    if (!起始单元格 || !目标单元格) {
			        return false;
			    }
			
			    if ((目标单元格.关联物品?.类型 === '开关砖' && 目标单元格.关联物品?.阻碍怪物 &&!无视物品) || 单元格类型.墙壁===目标单元格.背景类型 || (单元格类型.上锁的门===目标单元格.背景类型&&!无视物品)) {
			        return false;
			    }
			    const dx = 目标X - 起始X;
			    const dy = 目标Y - 起始Y;
			
			    if (dx === 1 && (起始单元格.墙壁.右 || 目标单元格.墙壁.左)) return false;
			    if (dx === -1 && (起始单元格.墙壁.左 || 目标单元格.墙壁.右)) return false;
			    if (dy === 1 && (起始单元格.墙壁.下 || 目标单元格.墙壁.上)) return false;
			    if (dy === -1 && (起始单元格.墙壁.上 || 目标单元格.墙壁.下)) return false;
			
			    return true;
			}
			function 处理沉浸式传送门() {
			    if(所有传送门.length===0) return;
			    显示通知('正在生成循环回廊...','信息');
			    setTimeout(() => {
			    const 渲染距离上限 = 4999;
			    const 传送深度上限 = 9999;
			    
			    
			    // 队列状态: { x, y (世界坐标), 距离, 深度, 偏移X, 偏移Y (已旋转的累积屏幕偏移), 旋转 (0, 90, 180, 270) }
			    const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0, 深度: 0, 偏移X: 0, 偏移Y: 0, 旋转: 0,出传送门:null}];
			    const 已访问 = new Set();
			    const 待绘制列表 = [];
			    let 完全生成=true
			
			    while (队列.length > 0) {
			        let { x, y, 距离, 深度, 偏移X, 偏移Y, 旋转,出传送门 } = 队列.shift();
			
			        let 访问键 = `${x},${y},${偏移X},${偏移Y}`;
			        if (已访问.has(访问键)) continue;
			        if (距离 > 渲染距离上限 || 深度 > 传送深度上限) {
			            完全生成=false
			            continue;
			        }
			        已访问.add(访问键);
			
			        const 单元格 = 地牢[y]?.[x];
			        if (!单元格) continue;
			        
			        待绘制列表.push({单元格, 偏移X, 偏移Y, 旋转});
			
			        const 标准方向 = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
			        
			        for (const 方向 of 标准方向) {
			            const 变换后方向 = 应用旋转(方向, 旋转);
			            const 邻居X = x + 方向.dx;
			            const 邻居Y = y + 方向.dy;
			            访问键 = `${邻居X},${邻居Y},${偏移X+方向.dx-变换后方向.dx},${偏移Y+方向.dy-变换后方向.dy}`;
			            if (已访问.has(访问键)) continue;
			
			            if (邻居X-(偏移X+方向.dx-变换后方向.dx) >= 0 && 邻居X-(偏移X+方向.dx-变换后方向.dx) < 地牢大小 && 邻居Y-(偏移Y+方向.dy-变换后方向.dy) >= 0 && 邻居Y-(偏移Y+方向.dy-变换后方向.dy) < 地牢大小 && 快速检查相邻移动(x, y, 邻居X, 邻居Y,true)) {
			                const 邻居单元格 = 地牢[邻居Y][邻居X];
			                const 邻居物品 = 邻居单元格?.关联物品;
			
			                if (邻居物品 instanceof 沉浸式传送门) {
			                if (邻居物品.x===出传送门?.x&&邻居物品.y===出传送门?.y) continue
			                    const 目标传送门 = 查找配对传送门(邻居物品);
			                    if (目标传送门) {
			                        
			                        const 出口向量 = 寻找传送门出口向量(目标传送门);
			                        if (出口向量) {
			                            const 进入向量 = { dx: 邻居X - x, dy: 邻居Y - y };
			                            
			                            const 进入角度 = 向量到角度(进入向量.dx, 进入向量.dy);
			                            const 出口角度 = 向量到角度(出口向量.dx, 出口向量.dy);
			                            
			                            const 传送门旋转 = (出口角度 - 进入角度 + 720) % 360;
			                            const 新旋转 = (720-(-旋转 + 传送门旋转)) % 360;
			                            const 位移向量 = { dx: 目标传送门.x - 邻居物品.x, dy: 目标传送门.y - 邻居物品.y };
			                            
			                            const 旋转后位移 = 应用旋转(位移向量, 0);
			
			
			                            const 新偏移X = 偏移X+旋转后位移.dx+方向.dx-变换后方向.dx;
			                            const 新偏移Y = 偏移Y+旋转后位移.dy+方向.dy-变换后方向.dy;
			
			                            const 出口坐标X = 目标传送门.x;
			                            const 出口坐标Y = 目标传送门.y;
			
			                            队列.push({ x: 出口坐标X, y: 出口坐标Y, 距离: 距离 + 2, 深度: 深度 + 1, 偏移X: 新偏移X, 偏移Y: 新偏移Y, 旋转: 新旋转,出传送门:{x:目标传送门?.x,y:目标传送门?.y}  });
			                        }
			                    }
			                } else {
			                    
			                    队列.push({ x: 邻居X, y: 邻居Y, 距离: 距离 + 1, 深度, 偏移X:偏移X+方向.dx-变换后方向.dx, 偏移Y:偏移Y+方向.dy-变换后方向.dy, 旋转,出传送门 });
			                }
			            }
			        }
			    }
			    
			    待绘制列表.forEach(({单元格, 偏移X, 偏移Y, 旋转}) => {
			        if (偏移X==0&&偏移Y==0){
			            单元格.阻碍视野 = false;
			            return;
			        } else if(单元格.阻碍视野) return;
			        let cell=克隆单元格(单元格)
			        cell.x = 单元格.x-偏移X
			        cell.y = 单元格.y-偏移Y
			        if (地牢[cell.y][cell.x].阻碍视野) return;
			        if (cell.关联物品?.x && cell.关联物品?.y) {
			            cell.关联物品.x = cell.x
			            cell.关联物品.y = cell.y
			            if (cell.关联物品 instanceof 沉浸式传送门) {
			                cell.关联物品=null
			                if (cell.类型===单元格类型.物品) cell.类型=null
			            } else if(cell.关联物品 instanceof 传送带){
			                cell.关联物品.自定义数据.set('方向',旋转方向(cell.关联物品.自定义数据.get('方向'),旋转))
			            }
			        }
			        if (cell.关联怪物?.x && cell.关联怪物?.y) {
			            cell.关联怪物.x = cell.x
			            cell.关联怪物.y = cell.y
			            所有怪物.push(cell.关联怪物)
			        }
			        if (cell.是否强制墙壁) {
			            const 新墙壁 = 旋转墙壁属性(cell.墙壁,旋转)
			            cell.墙壁 = 新墙壁;
			        }
			        cell.阻碍视野 = true;
			        
			        if (地牢[cell.y]?.[cell.x]) 地牢[cell.y][cell.x] = cell
			        
			    });
			    生成墙壁()
			    if (!完全生成) 显示通知('超过追踪上限，回廊生成不完全','警告');
			    }, 500);
			    
			}
			let 动画帧运行过 = false;
			function 动画帧() {
			    if (!动画帧运行过) {
			        动画帧运行过 = true;
			        已初始化--;
			    }
			    const dx = 相机目标X - 当前相机X;
			    const dy = 相机目标Y - 当前相机Y;
			
			    当前相机X += dx * 相机移动速度;
			    当前相机Y += dy * 相机移动速度;
			    const 当前时间 = Date.now();
			    // 检测移动完成
			    if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) {
			        当前相机X = 相机目标X;
			        当前相机Y = 相机目标Y;
			
			        
			
			        更新物体指示器();
			    }
			    if (待显示格子特效队列.length > 0) {
			        for (let i = 待显示格子特效队列.length - 1; i >= 0; i--) {
			            const 路径数据 = 待显示格子特效队列[i];
			            显示格子特效(
			                路径数据.路径,
			                路径数据.颜色,
			                路径数据.间隔
			            );
			        }
			        待显示格子特效队列 = [];
			    }
			
			    if (活动DOM特效.length > 0) {
			        const 画布RectUpdate = canvas.getBoundingClientRect(); // 获取最新的画布位置信息
			        活动DOM特效.forEach((item) => {
			            // 检查元素是否还存在于 DOM 中，防止意外移除导致错误
			            if (document.body.contains(item.element)) {
			                // 使用平滑插值的相机位置 (当前相机X/Y) 计算屏幕坐标
			                const 屏幕X =
			                    (item.worldX - 当前相机X) * 单元格大小;
			                const 屏幕Y =
			                    (item.worldY - 当前相机Y) * 单元格大小;
			                // 更新 DOM 元素的屏幕位置
			                item.element.style.left = `${
			                    屏幕X + 画布RectUpdate.left
			                }px`;
			                item.element.style.top = `${
			                    屏幕Y + 画布RectUpdate.top
			                }px`;
			            } else {
			                // 如果元素意外地不在 DOM 中了，从跟踪数组中清理掉
			                活动DOM特效 = 活动DOM特效.filter(
			                    (trackedItem) =>
			                        trackedItem.element !== item.element
			                );
			            }
			        });
			    }
			    所有怪物.forEach((怪物) => {
			        const 动画状态 = 怪物动画状态.get(怪物);
			        if (动画状态?.正在动画) {
			            const 已过时间 = 当前时间 - 动画状态.动画开始时间;
			            const t = Math.min(1, 已过时间 / 怪物移动动画时长); // 插值因子 (0 到 1)
			
			            // 使用线性插值计算视觉逻辑坐标
			            动画状态.视觉X =
			                动画状态.旧逻辑X +
			                (动画状态.目标逻辑X - 动画状态.旧逻辑X) * t;
			            动画状态.视觉Y =
			                动画状态.旧逻辑Y +
			                (动画状态.目标逻辑Y - 动画状态.旧逻辑Y) * t;
			
			            // 如果动画完成
			            if (t >= 1) {
			                动画状态.正在动画 = false;
			                动画状态.视觉X = 动画状态.目标逻辑X; // 确保最终位置精确
			                动画状态.视觉Y = 动画状态.目标逻辑Y;
			            }
			        }
			    });
			    const 动画状态玩家 = 玩家动画状态;
			if (动画状态玩家.正在动画) {
			    const 已过时间 = 当前时间 - 动画状态玩家.动画开始时间;
			    const 动画时长 = 120;
			    const t = Math.min(1, 已过时间 / 动画时长);
			
			    动画状态玩家.视觉X = 动画状态玩家.旧逻辑X + (动画状态玩家.目标逻辑X - 动画状态玩家.旧逻辑X) * t;
			    动画状态玩家.视觉Y = 动画状态玩家.旧逻辑Y + (动画状态玩家.目标逻辑Y - 动画状态玩家.旧逻辑Y) * t;
			
			    if (t >= 1) {
			        动画状态玩家.正在动画 = false;
			    }
			}
			当前出战宠物列表.forEach(pet => {
    if (!pet || !pet.是否已放置) return;

    const 动画状态 = 怪物动画状态.get(pet);
    if (动画状态?.正在动画) {
        const 已过时间 = 当前时间 - 动画状态.动画开始时间;
        const t = Math.min(1, 已过时间 / 怪物移动动画时长); // 插值因子 (0 到 1)

        // 使用线性插值计算视觉逻辑坐标
        动画状态.视觉X =
            动画状态.旧逻辑X +
            (动画状态.目标逻辑X - 动画状态.旧逻辑X) * t;
        动画状态.视觉Y =
            动画状态.旧逻辑Y +
            (动画状态.目标逻辑Y - 动画状态.旧逻辑Y) * t;

        // 如果动画完成
        if (t >= 1) {
            动画状态.正在动画 = false;
            动画状态.视觉X = 动画状态.目标逻辑X; // 确保最终位置精确
            动画状态.视觉Y = 动画状态.目标逻辑Y;
        }
    }
});
			    if (待显示爆炸范围.length > 0) {
			        const 画布RectExplosion = canvas.getBoundingClientRect();
			
			        待显示爆炸范围.forEach((explosionData) => {
			             if (explosionData && explosionData.爆炸范围.length > 0) {
			             const 特效容器 = document.getElementById("effectsContainer");
			                explosionData.爆炸范围.forEach(({ x, y, 距离 }) => {
			                    const 屏幕X = (x - 当前相机X) * 单元格大小;
			                    const 屏幕Y = (y - 当前相机Y) * 单元格大小;
			                    if (
			                        屏幕X + 单元格大小 < 0 || 
			                        屏幕X > 画布RectExplosion.width || 
			                        屏幕Y + 单元格大小 < 0 || 
			                        屏幕Y > 画布RectExplosion.height
			                    ) {
			                        return;
			                    }
			                    const 特效 = document.createElement("div");
			                    if (命令行模式开启) {
                        特效.textContent = ['@', 'O', 'o', '*', '.'][Math.min(距离, 4)];
                        特效.style.cssText = `
                            position: absolute; left: ${屏幕X + 画布RectExplosion.left}px; top: ${屏幕Y + 画布RectExplosion.top}px;
                            width: ${单元格大小}px; height: ${单元格大小}px; color: #FFD700;
                            font-family: 'Courier New', monospace; font-size: ${单元格大小}px; line-height: ${单元格大小}px;
                            text-align: center; pointer-events: none; z-index: 999;
                            opacity: 1; transition: opacity ${0.4 + (距离 / explosionData.范围) * 0.1}s;
                        `;
                    } else {
                        特效.style.cssText = `
                            position: absolute; left: ${屏幕X + 画布RectExplosion.left}px; top: ${屏幕Y + 画布RectExplosion.top}px;
                            width: ${单元格大小}px; height: ${单元格大小}px; background: ${获取爆炸颜色(距离, explosionData.范围)};
                            opacity: 0.7; animation: 爆炸闪烁 ${0.4 + (距离 / explosionData.范围) * 0.1}s;
                            pointer-events: none; z-index: 999;
                        `;
                    }
			
			                    特效容器.appendChild(特效);
			
			                    const worldX = x;
			                    const worldY = y;
			                    const effectData = {
			                        element: 特效,
			                        worldX: worldX,
			                        worldY: worldY,
			                    };
			                    活动DOM特效.push(effectData);
			
			                    setTimeout(() => {
			                        特效.remove();
			                        活动DOM特效 = 活动DOM特效.filter(
			                            (item) => item.element !== 特效
			                        );
			                    }, 500); 
			                });
			            }
			        });
			
			        待显示爆炸范围 = [];
			    }
			
			    if (
			        (游戏状态 === "图鉴" || 游戏状态 === "游戏中" || 游戏状态 === "编辑器游玩") &&
			        当前时间 - 上次自动回合时间 >= 自动回合间隔 &&
			        切换动画
			    ) {
			        if (!死亡界面已显示 && 玩家属性.允许移动 <= 0) {
			            处理回合逻辑();
			            上次自动回合时间 = 当前时间;
			        }
			    }
			
			    // 更新整数视口
			    视口偏移X = Math.floor(当前相机X);
			    视口偏移Y = Math.floor(当前相机Y);
			
			    if (所有传送门.length > 0 && 游戏状态 !== '地图编辑器') {
			    //处理沉浸式传送门();
			    绘制()
			} else {
			    绘制();
			}
			    requestAnimationFrame(动画帧);
			}
			function 获取爆炸颜色(距离) {
			    const 渐变 = [
			        "radial-gradient(circle, #ff0000 0%, #ff4500 70%, transparent 100%)",
			        "radial-gradient(circle, #ff4500 0%, #ff8c00 70%, transparent 100%)",
			        "radial-gradient(circle, #ff8c00 0%, #ffd700 70%, transparent 100%)",
			    ];
			    return 渐变[Math.min(距离, 2)];
			}
			function 绘制() {
			
			    const 缓冲区域 = 1;
			    const 起始X = Math.max(0, Math.floor(当前相机X - 缓冲区域));
			    const 结束X = Math.min(
			        地牢大小,
			        起始X + 相机显示边长 + 缓冲区域 * 2
			    );
			    const 起始Y = Math.max(0, Math.floor(当前相机Y - 缓冲区域));
			    const 结束Y = Math.min(
			        地牢大小,
			        起始Y + 相机显示边长 + 缓冲区域 * 2
			    );
			    const 清理X = (起始X - 当前相机X) * 单元格大小 - 单元格大小;
			    const 清理Y = (起始Y - 当前相机Y) * 单元格大小 - 单元格大小;
			    const 清理宽 = (结束X - 起始X + 2) * 单元格大小;
			    const 清理高 = (结束Y - 起始Y + 2) * 单元格大小;
			    ctx.clearRect(清理X, 清理Y, 清理宽, 清理高);
			
			    const 小数偏移X = (当前相机X % 1) * 单元格大小;
			    const 小数偏移Y = (当前相机Y % 1) * 单元格大小;
			
			    for (let y = 起始Y; y < 结束Y; y++) {
			        for (let x = 起始X; x < 结束X; x++) {
			            if (地牢.length > 0 && 地牢[y]?.[x]) {
			                地牢[y][x].绘制();
			            }
			        }
			    }
			    
			    if (moveQueue.length > 0) {
			        drawPath(moveQueue);
			    }
			    
			    所有怪物.forEach((怪物实例) => {
			        if (怪物实例 instanceof 巨人部位) return;
			
			        const 动画状态 = 怪物动画状态.get(怪物实例);
			        let 绘制逻辑X = 怪物实例.x;
			        let 绘制逻辑Y = 怪物实例.y;
			        const 正在动画 = 动画状态?.正在动画;
			
			        if (正在动画) {
			            绘制逻辑X =
			                动画状态.视觉X !== undefined
			                    ? 动画状态.视觉X
			                    : 怪物实例.x;
			            绘制逻辑Y =
			                动画状态.视觉Y !== undefined
			                    ? 动画状态.视觉Y
			                    : 怪物实例.y;
			        }
			
			        const 怪物视口X = 绘制逻辑X - 视口偏移X;
			        const 怪物视口Y = 绘制逻辑Y - 视口偏移Y;
			        const 怪物所在房间ID = 房间地图[怪物实例.y]?.[怪物实例.x];
			        const 怪物所在房间 =
			            怪物所在房间ID !== -1 ? 房间列表[怪物所在房间ID] : null;
			        if (
			            怪物视口X >= -缓冲区域 &&
			            怪物视口X < 相机显示边长 + 缓冲区域 &&
			            怪物视口Y >= -缓冲区域 &&
			            怪物视口Y < 相机显示边长 + 缓冲区域 &&
			            (怪物实例.隐身中 ?? false) === false &&
			            (怪物所在房间ID === -1 ||
			                已访问房间.has(怪物所在房间ID) ||
			                (玩家属性.透视 && !当前天气效果.includes("诡魅") && !当前天气效果.includes("深夜")) ||
			                游戏状态 === "图鉴" ||
			                游戏状态 === '地图编辑器') &&
			            (
			                !(玩家状态.some(s => s.类型 === '失明') || (当前天气效果.includes("深夜")&& 游戏状态 !== '地图编辑器') ||
			                    (怪物所在房间 &&
			                        怪物所在房间.类型 === "黑暗房间") && 游戏状态 !== '地图编辑器') ||
			                是否在光源范围内(怪物实例.x, 怪物实例.y)
			            ) && 
			            !(地牢生成方式 === 'cave' && !已揭示洞穴格子.has(`${怪物实例.x},${怪物实例.y}`) && 游戏状态 !== '地图编辑器' && !玩家属性.透视)
			        ) {
			            let 怪物屏幕X, 怪物屏幕Y, 怪物图标大小;
			            if (怪物实例 instanceof 巨人怪物) {
			                怪物屏幕X = (绘制逻辑X - 当前相机X + 1) * 单元格大小;
			                怪物屏幕Y = (绘制逻辑Y - 当前相机Y + 1) * 单元格大小;
			                怪物图标大小 = 单元格大小 * 1.8;
			            } else {
			                怪物屏幕X = (绘制逻辑X - 当前相机X + 0.5) * 单元格大小;
			                怪物屏幕Y = (绘制逻辑Y - 当前相机Y + 0.5) * 单元格大小;
			                怪物图标大小 = 单元格大小 * 0.8;
			            }
			            if (命令行模式开启) {
                ctx.fillStyle = 怪物实例.受击动画 ? '#FF0000' : (怪物实例.颜色 || '#FFFFFF');
                ctx.font = `bold ${怪物图标大小}px 'Courier New', monospace`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(怪物实例.图标, 怪物屏幕X, 怪物屏幕Y);
                if (游戏状态 !== '地图编辑器') 怪物实例.绘制血条();
            } else {
			            ctx.font = `${怪物图标大小}px color-emoji`;
			            ctx.textAlign = "center";
			            ctx.textBaseline = "middle";
			
			            if (怪物实例.受击动画 && !(怪物实例 instanceof 蜈蚣部位)) {
			                ctx.fillStyle = "#FF0000";
			            } else {
			                ctx.fillStyle = 怪物实例.颜色 || "#FFFFFF";
			            }
			
			            const monsterKey = 怪物实例.图标;
                        
                        
                        if (怪物实例 instanceof 巡逻怪物) {
                            ctx.save();
                            ctx.translate(怪物屏幕X, 怪物屏幕Y);
                            const dir = 怪物实例.巡逻方向;
                            if (游戏设置.emoji风格=="toss-face"&&游戏设置.emojiCDN是否可用){
                            switch (dir) {
                                case 'W': ctx.scale(-1, 1); break;
                                case 'N': ctx.rotate(-Math.PI / 2); break;
                                case 'S': ctx.rotate(Math.PI / 2); break;
                                default: break;
                            }
                            
                            } else {
                            switch (dir) {
                                case 'E': ctx.scale(-1, 1); break;
                                case 'N': ctx.rotate(Math.PI / 2); break;
                                case 'S': ctx.rotate(-Math.PI / 2); break;
                                default: break;
                            }
                            }
                            drawIcon(ctx, monsterKey, 0, 0, 怪物图标大小, ctx.fillStyle);
                            ctx.restore();
                        } else if (怪物实例 instanceof 蜈蚣怪物) {
                            ctx.save();
                            ctx.translate(怪物屏幕X, 怪物屏幕Y);
                            switch (怪物实例.朝向) {
                                case 'E': ctx.scale(-1, 1); break;
                                case 'N': ctx.rotate(Math.PI / 2); break;
                                case 'S': ctx.rotate(-Math.PI / 2); break;
                                default: break;
                            }
                            drawIcon(ctx, monsterKey, 0, 0, 怪物图标大小, ctx.fillStyle);
                            ctx.restore();
                        } else {
                            drawIcon(ctx, monsterKey, 怪物屏幕X, 怪物屏幕Y, 怪物图标大小, ctx.fillStyle);
                        }
                        }
			            怪物实例.绘制增益效果(怪物屏幕X, 怪物屏幕Y);
			
			            const 怪物当前状态 = 怪物状态表.get(怪物实例);
			            if (怪物当前状态) {
			                ctx.fillStyle = 怪物当前状态.颜色 || "#FFFFFF";
			                ctx.font = `${单元格大小 * 0.5}px Arial`;
			                const 状态图标X = 怪物屏幕X + 单元格大小 * 0.3;
			                const 状态图标Y = 怪物屏幕Y - 单元格大小 * 0.3;
			                ctx.fillText(
			                    怪物当前状态.图标 || "?",
			                    状态图标X,
			                    状态图标Y
			                );
			            } else if (怪物实例.强化 && 怪物实例.类型 != "伪装怪物") {
			                ctx.fillStyle = "#FF0000";
			                ctx.font = `${单元格大小 * 0.5}px Arial`;
			                const 强化标记X = 怪物屏幕X + 单元格大小 * 0.3;
			                const 强化标记Y = 怪物屏幕Y - 单元格大小 * 0.3;
			                ctx.fillText("强", 强化标记X, 强化标记Y);
			            }
			            if(游戏状态 !== '地图编辑器') 怪物实例.绘制血条();
			        }
			    });
				当前出战宠物列表.forEach(pet => {
					const 宠物所在房间ID = 房间地图[pet?.y]?.[pet?.x];
			        const 宠物所在房间 =
			            宠物所在房间ID !== -1 ? 房间列表[宠物所在房间ID] : null;
    if (pet && pet.是否已放置  && pet.层数==当前层数 && (
        !(玩家状态.some(s => s.类型 === '失明') || 当前天气效果.includes("深夜") ||
            (宠物所在房间 &&
                宠物所在房间.类型 === "黑暗房间") && 游戏状态 !== '地图编辑器') ||
        是否在光源范围内(pet.x, pet.y)
    ) && !(地牢生成方式 === 'cave' && !已揭示洞穴格子.has(`${pet.x},${pet.y}`) && 游戏状态 !== '地图编辑器' && !玩家属性.透视)) {
        const 动画状态 = 怪物动画状态.get(pet);
			        let 绘制逻辑X = pet.x;
			        let 绘制逻辑Y = pet.y;
			        const 正在动画 = 动画状态?.正在动画;
			
			        if (正在动画) {
			            绘制逻辑X = 动画状态.视觉X !== undefined ? 动画状态.视觉X : pet.x;
			            绘制逻辑Y = 动画状态.视觉Y !== undefined ? 动画状态.视觉Y : pet.y;
			        }
			        
			        const 宠物屏幕X = (绘制逻辑X - 当前相机X + 0.5) * 单元格大小;
			        const 宠物屏幕Y = (绘制逻辑Y - 当前相机Y + 0.5) * 单元格大小;
			
			        ctx.font = `${单元格大小 * 0.8}px color-emoji`;
			        ctx.textAlign = "center";
			        ctx.textBaseline = "middle";
			        ctx.fillStyle = pet.颜色表[pet.颜色索引] || '#FFFFFF';
			        ctx.shadowColor = pet.颜色表[pet.颜色索引] || '#FFFFFF';
			        ctx.shadowBlur = 10;
			        drawIcon(ctx, pet.显示图标, 宠物屏幕X, 宠物屏幕Y, 单元格大小 * 0.8, ctx.fillStyle);
			        ctx.shadowBlur = 0;
			        const 宠物状态 = 宠物状态表.get(pet);
                if (宠物状态) {
                    ctx.fillStyle = 宠物状态.颜色 || '#FFFFFF';
                    ctx.font = `${单元格大小 * 0.5}px Arial`;
                    const 状态图标X = 宠物屏幕X + 单元格大小 * 0.3;
                    const 状态图标Y = 宠物屏幕Y - 单元格大小 * 0.3;
                    ctx.fillText(宠物状态.图标 || "?", 状态图标X, 状态图标Y);
                }
			        if(!命令行模式开启) {
			        const 血条高度 = 4;
			        const 血条Y = (绘制逻辑Y - 当前相机Y) * 单元格大小 - 6;
			        const 宽度 = 单元格大小;
			        const 血条X = (绘制逻辑X - 当前相机X) * 单元格大小;
			        
			        const 血量百分比 = Math.max(0, (pet.自定义数据.get("当前生命值") / pet.自定义数据.get("最大生命值")) * 100);
			        ctx.fillStyle = '#444';
			        ctx.fillRect(血条X, 血条Y, 宽度, 血条高度);
			        ctx.fillStyle = '#33cc33';
			        ctx.fillRect(血条X, 血条Y, 宽度 * (血量百分比 / 100), 血条高度);
			        } else {
			        ctx.font = `${单元格大小 * 0.3}px 'Courier New', monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            const 血量百分比 = Math.max(0,Math.max(0, (pet.自定义数据.get("当前生命值") / pet.自定义数据.get("最大生命值")) * 100));
            const 总格数 = 7;
            const 实心格数 = Math.round(血量百分比 * 总格数);
            const 空心格数 = 总格数 - 实心格数;
            const 血条文本 = `[${'#'.repeat(实心格数)}${'.'.repeat(空心格数)}]`;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(血条文本, 屏幕X + 单元格大小 / 2, 屏幕Y);
			        }
    }
});
			    
			    if(编辑器状态.正在划区 || (编辑器状态.正在复制选区 && 编辑器状态.当前选中?.名称 === '复制工具')) {
			        ctx.save();
			        ctx.fillStyle = 'rgba(0, 150, 255, 0.3)';
			        ctx.strokeStyle = '#0096FF';
			        ctx.lineWidth = 2;
			        const 起点 = 编辑器状态.正在划区 ? 编辑器状态.划区起点 : 编辑器状态.复制起点;
			        const startScreenX = (起点.x - 当前相机X) * 单元格大小;
			        const startScreenY = (起点.y - 当前相机Y) * 单元格大小;
			        const currentScreenX = (玩家.x - 当前相机X) * 单元格大小;
			        const currentScreenY = (玩家.y - 当前相机Y) * 单元格大小;
			        const rectX = Math.min(startScreenX, currentScreenX);
			        const rectY = Math.min(startScreenY, currentScreenY);
			        const rectW = Math.abs(startScreenX - currentScreenX) + 单元格大小;
			        const rectH = Math.abs(startScreenY - currentScreenY) + 单元格大小;
			        ctx.fillRect(rectX, rectY, rectW, rectH);
			        ctx.strokeRect(rectX, rectY, rectW, rectH);
			        ctx.restore();
			    } else if (编辑器剪贴板 && 编辑器状态.当前选中?.名称 === '复制工具') {
			        ctx.save();
			        ctx.globalAlpha = 0.6;
			        const { 宽度, 高度, 数据, 只包含实体 } = 编辑器剪贴板;
			        for (const 条目 of 数据) {
			            const 目标X = 玩家.x + 条目.相对X;
			            const 目标Y = 玩家.y + 条目.相对Y;
			            const screenX = (目标X - 当前相机X) * 单元格大小;
			            const screenY = (目标Y - 当前相机Y) * 单元格大小;
			
			            if (只包含实体) {
			                ctx.fillStyle = 'rgba(200, 200, 255, 0.4)';
			                ctx.fillRect(screenX, screenY, 单元格大小, 单元格大小);
			            } else {
			                const tempCell = 克隆单元格(条目.单元格克隆);
			                tempCell.x = 目标X;
			                tempCell.y = 目标Y;
			                tempCell.绘制();
			            }
			        }
			        ctx.restore();
			    }
			    if (游戏状态 === '地图编辑器' && 编辑器状态.模式 === '设置起点') {
			        ctx.save();
			        ctx.fillStyle = 'rgba(76, 175, 80, 0.5)';
			        const 屏幕X = (玩家初始位置.x - 当前相机X) * 单元格大小;
			        const 屏幕Y = (玩家初始位置.y - 当前相机Y) * 单元格大小;
			        ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
			        ctx.restore();
			    }
			    const 玩家动画 = 玩家动画状态;
			let 玩家绘制X = 玩家.x;
			let 玩家绘制Y = 玩家.y;
			
			if (玩家动画.正在动画) {
			    玩家绘制X = 玩家动画.视觉X;
			    玩家绘制Y = 玩家动画.视觉Y;
			}
			
			const 玩家屏幕X = (玩家绘制X - 当前相机X + 0.5) * 单元格大小;
			const 玩家屏幕Y = (玩家绘制Y - 当前相机Y + 0.5) * 单元格大小;
			
			if (moveQueue.length > 0) {
			    drawPath(moveQueue);
			}
			
			const hexArray_ = [];
			if (玩家状态.length > 0) {
			    玩家状态.forEach((item) => {
			        hexArray_.push(item.颜色);
			    });
			    ctx.fillStyle = blendColors(hexArray_);
			} else {
			    ctx.fillStyle = "#ff4444";
			}
			if (命令行模式开启) {
		//ctx.fillStyle = '#FF0000';
		ctx.font = `bold ${单元格大小 * 0.9}px 'Courier New', monospace`;
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillText('@', 玩家屏幕X, 玩家屏幕Y);
	} else {
		//ctx.fillStyle = "#ff4444";
		ctx.beginPath();
		ctx.arc(玩家屏幕X, 玩家屏幕Y, 单元格大小 / 3, 0, Math.PI * 2);
		ctx.fill();
		ctx.stroke();
	}
			
			}
			document.addEventListener("touchstart", (e) => {
			    if (window.innerWidth >= 769) return;
			    const isBackpackVisible = document.querySelector(".背包弹窗.显示中");
			    if (isBackpackVisible && document.getElementById('浮动提示框').style.display !== 'none') {
			        document.getElementById('浮动提示框').style.display = 'none';
			    }
			});
			function 绘制小地图() {
			    if (地牢.length !== 地牢大小) return;
			    const 小地图 = document.getElementById("小地图");
			    if (
			        (当前天气效果.includes("诡魅") ||
			        当前天气效果.includes("深夜")) &&
			        游戏状态!=="地图编辑器"
			    ) {
			        小地图Ctx.fillStyle = "#000000";
			        小地图Ctx.fillRect(0, 0, 小地图.width, 小地图.height);
			
			        小地图Ctx.fillStyle = "#555";
			        小地图Ctx.font = "20px Arial";
			        小地图Ctx.textAlign = "center";
			        小地图Ctx.textBaseline = "middle";
			        小地图Ctx.fillText(
			            "地图受到干扰",
			            小地图.width / 2,
			            小地图.height / 2
			        );
			        return;
			    }
			    
			    const 缩放比例 = 小地图.width/地牢大小;
			    小地图Ctx.fillStyle = "#1a1a1a";
			    小地图Ctx.fillRect(0, 0, 小地图.width, 小地图.height);
			    if (地牢.length > 0) {
			        for (let y = 0; y < 地牢大小; y++) {
			            for (let x = 0; x < 地牢大小; x++) {
			                const 物品 = 地牢[y]?.[x]?.关联物品;
			                if (地牢生成方式 === 'cave' && !已揭示洞穴格子.has(`${x},${y}`) && 游戏状态 !== '地图编辑器') continue;
			                if (
			                    物品 &&
			                    (物品 instanceof 护卫植物 ||
			                        物品 instanceof 远射植物) &&
			                    已访问房间.has(房间地图[y][x])
			                ) {
			                    小地图Ctx.fillStyle = "#228B22";
			                    小地图Ctx.beginPath();
			                    小地图Ctx.arc(
			                        x * 缩放比例 + 缩放比例 / 2,
			                        y * 缩放比例 + 缩放比例 / 2,
			                        缩放比例 * 0.7,
			                        0,
			                        Math.PI * 2
			                    );
			                    小地图Ctx.fill();
			                }
			                if (物品 && 物品 instanceof 旗帜) {
			                    小地图Ctx.fillStyle = "#FFD700";
			                    小地图Ctx.font = `${缩放比例 * 4}px color-emoji`;
			                    小地图Ctx.textAlign = "center";
			                    小地图Ctx.textBaseline = "middle";
			                    小地图Ctx.fillText(物品.图标, x * 缩放比例 + 缩放比例 / 2, y * 缩放比例 + 缩放比例 / 2);
			                }
			                if (地牢[y][x]?.背景类型 === 单元格类型.走廊) {
			                    小地图Ctx.strokeStyle = "#666666";
			                    小地图Ctx.strokeRect(
			                        x * 缩放比例,
			                        y * 缩放比例,
			                        缩放比例,
			                        缩放比例
			                    );
			                }
			            }
			        }
			    }
			
			    房间列表.forEach((房间) => {
			        if (!房间) return;
			        const 已访问 = 已访问房间.has(房间.id);
			        const 是上锁房间 = 上锁房间列表.some(
			            (r) => r.id === 房间.id
			        );
			
			        if (是上锁房间) {
			            const 颜色索引 = 上锁房间列表.find(
			                (r) => r.id === 房间.id
			            ).颜色索引;
			            小地图Ctx.strokeStyle = 颜色表[颜色索引] || "#FFD700";
			        } else {
			            小地图Ctx.strokeStyle = 已访问 ? "#4caf50" : "#666666";
			        }
			
			        小地图Ctx.strokeRect(
			            房间.x * 缩放比例,
			            房间.y * 缩放比例,
			            房间.w * 缩放比例,
			            房间.h * 缩放比例
			        );
			
			        if (已访问) {
			            小地图Ctx.fillStyle = "#4caf5022";
			            小地图Ctx.fillRect(
			                房间.x * 缩放比例,
			                房间.y * 缩放比例,
			                房间.w * 缩放比例,
			                房间.h * 缩放比例
			            );
			        }
			    });
			    传送点列表.forEach((点) => {
			        if (点.层数 === 当前层数) {
			            const 传送点X = 点.x * 缩放比例 + 缩放比例 / 2;
			            const 传送点Y = 点.y * 缩放比例 + 缩放比例 / 2;
			            const 半径 = 缩放比例 * 0.8;
			
			            小地图Ctx.shadowColor = "#FF00FF";
			            小地图Ctx.shadowBlur = 8;
			
			            小地图Ctx.fillStyle = "#FF00FF";
			            小地图Ctx.beginPath();
			            小地图Ctx.arc(传送点X, 传送点Y, 半径, 0, Math.PI * 2);
			            小地图Ctx.fill();
			
			            小地图Ctx.shadowBlur = 0;
			            小地图Ctx.fillStyle = "#FFFFFF";
			            小地图Ctx.beginPath();
			            小地图Ctx.arc(
			                传送点X,
			                传送点Y,
			                半径 * 0.3,
			                0,
			                Math.PI * 2
			            );
			            小地图Ctx.fill();
			        }
			    });
			
			    if (上次死亡地点 && 上次死亡地点.层数 === 当前层数) {
			        const 死亡X = 上次死亡地点.x * 缩放比例;
			        const 死亡Y = 上次死亡地点.y * 缩放比例;
			        const 标记尺寸 = 缩放比例 * 2.5;
			
			        小地图Ctx.shadowColor = "rgba(255, 0, 0, 0.8)";
			        小地图Ctx.shadowBlur = 10;
			
			        小地图Ctx.fillStyle = "rgba(200, 0, 0, 0.8)";
			        小地图Ctx.beginPath();
			        小地图Ctx.arc(
			            死亡X + 缩放比例 / 2,
			            死亡Y + 缩放比例 / 2,
			            标记尺寸 * 0.5,
			            0,
			            Math.PI * 2
			        );
			        小地图Ctx.fill();
			
			        小地图Ctx.shadowBlur = 0;
			
			        小地图Ctx.font = `${标记尺寸 * 0.8}px color-emoji`;
			        小地图Ctx.textAlign = "center";
			        小地图Ctx.textBaseline = "middle";
			        小地图Ctx.fillStyle = "#FFFFFF";
			        小地图Ctx.fillText(
			            图标映射.死亡图标,
			            死亡X + 缩放比例 / 2,
			            死亡Y + 缩放比例 / 2 + 标记尺寸 * 0.05
			        );
			    }
			
			    小地图Ctx.shadowColor = "transparent";
			    小地图Ctx.shadowBlur = 0;
			
			    小地图Ctx.fillStyle = "#ff0000";
			    小地图Ctx.beginPath();
			    小地图Ctx.arc(
			        玩家.x * 缩放比例,
			        玩家.y * 缩放比例,
			        Math.max(3, 缩放比例 / 2),
			        0,
			        Math.PI * 2
			    );
			    小地图Ctx.fill();
			    小地图Ctx.strokeStyle = "#ffffff";
			    小地图Ctx.lineWidth = 2;
			    小地图Ctx.stroke();
			    当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置  && pet.层数==当前层数 ) {
        const 宠物X = pet.x * 缩放比例;
        const 宠物Y = pet.y * 缩放比例;
        const 宠物图标半径 = Math.max(2, 缩放比例 / 2.5);

        小地图Ctx.fillStyle = "#2196F3";
        小地图Ctx.beginPath();
        小地图Ctx.arc(
            宠物X,
            宠物Y,
            宠物图标半径,
            0,
            Math.PI * 2
        );
        小地图Ctx.fill();
        小地图Ctx.strokeStyle = "#FFFFFF";
        小地图Ctx.lineWidth = 1;
        小地图Ctx.stroke();
    }
});
const markers = 地图标记.get(当前层数) || [];
			    markers.forEach(marker => {
			        小地图Ctx.fillStyle = "#FFD700";
			        小地图Ctx.font = `${缩放比例 * 3}px color-emoji`;
			        小地图Ctx.textAlign = "center";
			        小地图Ctx.textBaseline = "middle";
			        小地图Ctx.fillText(marker.icon, marker.x * 缩放比例 + 缩放比例, marker.y * 缩放比例 + 缩放比例);
			    });
			
			    小地图Ctx.shadowColor = "transparent";
			    小地图Ctx.shadowBlur = 0;
			
			    小地图Ctx.fillStyle = "#ff0000";
			    小地图Ctx.beginPath();
			    小地图Ctx.arc(
			        玩家.x * 缩放比例,
			        玩家.y * 缩放比例,
			        Math.max(3, 缩放比例 / 2),
			        0,
			        Math.PI * 2
			    );
			    小地图Ctx.fill();
			    小地图Ctx.strokeStyle = "#ffffff";
			    小地图Ctx.lineWidth = 2;
			    小地图Ctx.stroke();
			    当前出战宠物列表.forEach(pet => {
    if (pet && pet.是否已放置 && pet.层数==当前层数 ) {
        const 宠物X = pet.x * 缩放比例;
        const 宠物Y = pet.y * 缩放比例;
        const 宠物图标半径 = Math.max(2, 缩放比例 / 2.5);

        小地图Ctx.fillStyle = "#2196F3";
        小地图Ctx.beginPath();
        小地图Ctx.arc(
            宠物X,
            宠物Y,
            宠物图标半径,
            0,
            Math.PI * 2
        );
        小地图Ctx.fill();
        小地图Ctx.strokeStyle = "#FFFFFF";
        小地图Ctx.lineWidth = 1;
        小地图Ctx.stroke();
    }
});
			
			    const 视野半径 = Math.floor(相机显示边长 / 2);
			    const 视野框X = (玩家.x - 视野半径) * 缩放比例;
			    const 视野框Y = (玩家.y - 视野半径) * 缩放比例;
			    const 视野框尺寸 = 相机显示边长 * 缩放比例;
			
			    小地图Ctx.strokeStyle = "#ffd700";
			    小地图Ctx.lineWidth = 1;
			    小地图Ctx.strokeRect(视野框X, 视野框Y, 视野框尺寸, 视野框尺寸);
			}
			async function startAutoMove() {
			    if (moveQueue.length === 0) return;
			    isAutoMoving = true;
			    const moveInterval = setInterval(() => {
			        if (moveQueue.length === 0) {
			            clearInterval(moveInterval);
			            return;
			        }
			        if (玩家属性.允许移动 <= 0) {
			            let targetIndex = Math.min(
			                玩家属性.移动步数 - 1,
			                moveQueue.length - 1
			            );
			            let validMove = true;
			            // 检查直线可行性
			            for (let i = 0; i <= targetIndex; i++) {
			                if (
			                    !检查直线移动可行性(
			                        玩家.x,
			                        玩家.y,
			                        moveQueue[i].x,
			                        moveQueue[i].y
			                    )
			                ) {
			                    targetIndex = i - 1;
			                    validMove = false;
			                    break;
			                }
			            }
			            if (targetIndex >= 0 && validMove) {
			                const target = moveQueue[targetIndex];
			                移动玩家(
			                    target.x - 玩家.x,
			                    target.y - 玩家.y,
			                    false
			                );
			                moveQueue = moveQueue.slice(targetIndex + 1);
			            } else {
			                // 无法多格移动时单格移动
			                const target = moveQueue.shift();
			                移动玩家(
			                    target.x - 玩家.x,
			                    target.y - 玩家.y,
			                    false
			                );
			            }
			        }
			    }, 移动间隔); // 间隔时间
			}
			function 打开配方书() {
			    if (
			        游戏状态 === "游戏中" &&
			        玩家属性.允许移动 > 0 &&
			        document.getElementById("配方书遮罩").style.display ===
			            "block"
			    )
			        return;
			    if (游戏状态 === "地图编辑器" || 游戏状态 === "死亡界面" || 游戏状态==="胜利"||游戏状态==="图鉴选择") return;
			    if (游戏状态 === "游戏中") 玩家属性.允许移动++;
			
			    const 遮罩 = document.getElementById("配方书遮罩");
			    const 窗口 = document.getElementById("配方书窗口");
			    const 内容容器 = document.getElementById("配方书内容容器");
			    const 关闭按钮 = document.getElementById("关闭配方书按钮");
			
			    内容容器.innerHTML = "";
			
			    const 所有已知配方 = new Map();
			
			    融合配方列表.forEach((配方) => {
			        if (配方.说明) {
			            所有已知配方.set(配方.说明, 配方);
			        } else {
			            const inputNames = 配方.输入.join(" + ");
			            const outputName = 配方.输出类名称 || 配方.输出类;
			            const tempDesc = `${inputNames} = ${outputName}`;
			            所有已知配方.set(tempDesc, { ...配方, 说明: tempDesc });
			        }
			    });
			    已发现的程序生成配方.forEach((配方) => {
			        if (配方.说明) {
			            所有已知配方.set(配方.说明, 配方);
			        }
			    });
			
			    if (所有已知配方.size === 0) {
			        内容容器.innerHTML =
			            "<p style='text-align: center; color: #888;'>尚未发现任何配方。</p>";
			    } else {
			        所有已知配方.forEach((配方) => {
			            const 配方条目 = document.createElement("div");
			            配方条目.style.cssText = `
			            background: rgba(255, 255, 255, 0.05);
			            padding: 10px 15px;
			            border: 1px solid rgba(76, 175, 80, 0.3);
			            border-radius: 6px;
			            font-size: 0.95em;
			            line-height: 1.5;
			            color: #e0e0e0;
			            text-align: left;
			        `;
			            配方条目.textContent =
			                配方.说明 ||
			                `${配方.输入.join(" + ")} → ${
			                    配方.输出类名称 || 配方.输出类
			                }`;
			            内容容器.appendChild(配方条目);
			        });
			    }
			
			    关闭按钮.onclick = 关闭配方书;
			
			    遮罩.style.display = "block";
			    窗口.style.opacity = 0;
			    窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
			    requestAnimationFrame(() => {
			        窗口.style.transition =
			            "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
			        窗口.style.opacity = 1;
			        窗口.style.transform = "translate(-50%, -50%) scale(1)";
			    });
			}
			
			function 关闭配方书() {
			    const 遮罩 = document.getElementById("配方书遮罩");
			    const 窗口 = document.getElementById("配方书窗口");
			    if (!遮罩 || !窗口 || 遮罩.style.display === "none") return;
			
			    窗口.style.transition =
			        "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
			    窗口.style.opacity = 0;
			    窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
			    setTimeout(() => {
			        遮罩.style.display = "none";
			        if (游戏状态 === "游戏中") {
			            玩家属性.允许移动--;
			            玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
			        }
			    }, 300);
			}
			
			function 应用永久Buffs() {
			    // 先重置为初始值
			    玩家属性 = {...初始玩家属性}
			
			    // 应用永久Buff
			    Object.keys(永久Buffs).forEach(key => {
			        if (key !== '已获得效果') {
			            if (typeof 玩家属性[key] === 'number' && typeof 永久Buffs[key] === 'number') {
			                玩家属性[key] = (玩家属性[key] || 0) + 永久Buffs[key];
			            } else {
			                玩家属性[key] = 永久Buffs[key];
			            }
			        }
			    });
			
			    // 确保已获得的效果列表也同步
			    玩家属性.已获得神龛效果 = Array.from(永久Buffs.已获得效果);
			    
			
			}
			function 检查直线移动可行性(
			    fromX,
			    fromY,
			    toX,
			    toY,
			    未解锁房间视作障碍 = false
			) {
			    const dx = toX - fromX;
			    const dy = toY - fromY;
			
			    if (dx !== 0 && dy !== 0) return false; // 禁止斜向移动
			
			    const steps = Math.max(Math.abs(dx), Math.abs(dy));
			    const dirX = dx > 0 ? 1 : dx < 0 ? -1 : 0;
			    const dirY = dy > 0 ? 1 : dy < 0 ? -1 : 0;
			
			    for (let i = 1; i <= steps; i++) {
			        const x = fromX + dirX * i;
			        const y = fromY + dirY * i;
			
			        if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
			            return false;
			        if (
			            !检查移动可行性(
			                x - dirX,
			                y - dirY,
			                x,
			                y,
			                未解锁房间视作障碍
			            )
			        )
			            return false;
			    }
			
			    return true;
			}
			const 主菜单容器 = document.getElementById("主菜单容器");
			const 新建游戏按钮 = document.getElementById("新建游戏按钮");
			const 读取存档按钮 = document.getElementById("读取存档按钮");
			const 图鉴按钮 = document.getElementById("图鉴按钮");
			const 读凭证按钮 = document.getElementById("读凭证按钮");
			const 地图编辑器按钮 = document.getElementById("地图编辑器按钮");
			地图编辑器按钮.addEventListener("click", () => {
			    进入地图编辑器();
			});
			function 收集所有定义() {
			    const definitions = 获取所有可用的定义();
			    所有物品定义 = definitions.items;
			    所有怪物定义 = definitions.monsters;
			}
			
			function 显示主菜单() {
			    游戏状态 = "主菜单";
			    所有地牢层.clear();
			    document.body.classList.remove("游戏进行中", "地图编辑器模式", "编辑器游玩模式", "初始化");
			    主菜单容器.style.display = 'flex';
			    主菜单容器.style.pointerEvents = "auto";
			    document.getElementById('编辑器工具栏').style.display = 'none';
			    document.getElementById('笔刷工具容器').style.display = 'none';
			    document.getElementById('扳手工具菜单').style.display = 'none';
			    document.getElementById('返回编辑器按钮').style.display = 'none';
			
			    const 死亡遮罩 = document.getElementById("死亡遮罩");
			    if (死亡遮罩) 死亡遮罩.remove();
			    死亡界面已显示 = false;
			    if (typeof gsap === 'undefined') {
			        
			        return;
			    }
			
			    const 动画时间线 = gsap.timeline();
			    
			    gsap.set(主菜单容器, { autoAlpha: 1 });
			    gsap.set("#游戏标题", { autoAlpha: 0, y: -40, scale: 0.5 });
			    gsap.set("#菜单选项 .菜单按钮", { autoAlpha: 0, y: 10 });
			
			    动画时间线
			        .to("#游戏标题", {
			autoAlpha: 1,
			y: 0,
			scale: 1,
			duration: 0.5,
			ease: "expo.out",
			delay: 0.3,
			        })
			        .to(
			"#菜单选项 .菜单按钮",
			{
			    autoAlpha: 1,
			    y: 0,
			    duration: 0.2,
			    stagger: 0.1,
			    ease: "power2.out",
			},
			"-=0.6" 
			        );
			}
			
			function 隐藏主菜单() {
			    主菜单容器.style.display = "none";
			    游戏状态 = "游戏中";
			    if (typeof gsap === 'undefined') {
			        游戏状态 = "游戏中";
			        document.body.classList.add("游戏进行中");
			        return;
			    }
			    
			    gsap.to("#主菜单容器", {
			        autoAlpha: 0,
			        duration: 0.9,
			        ease: "power2.in",
			        onComplete: () => {
			
			document.body.classList.add("游戏进行中");
			
			        }
			    });
			}
			
			function 显示游戏模式选择() {
			    主菜单容器.style.display = 'none';
			    游戏模式选择菜单.style.display = 'flex';
			
			    if (typeof gsap === 'undefined') {
			        游戏模式选择菜单.style.opacity = '1';
			        游戏模式选择菜单.style.pointerEvents = 'auto';
			        document.getElementById("游戏模式标题").style.opacity = '1';
			        document.getElementById("游戏模式标题").style.transform = 'translateY(0px)';
			        document.querySelectorAll("#游戏模式选项 .菜单按钮, #返回主菜单按钮").forEach(按钮 => {
			按钮.style.opacity = '1';
			按钮.style.transform = 'translateY(0px)';
			        });
			    } else {
			        const 动画时间线 = gsap.timeline();
			        gsap.set(游戏模式选择菜单, { autoAlpha: 0 });
			    gsap.set("#游戏模式标题", { autoAlpha: 0, y: -30 });
			    gsap.set("#游戏模式选项 .菜单按钮, #返回主菜单按钮", { autoAlpha: 0, y: 20 });
			
			    动画时间线
			        .to(游戏模式选择菜单, { autoAlpha: 1, duration: 0.2 })
			        .to("#游戏模式标题", { autoAlpha: 1, y: 0, duration: 0.3, ease: "power2.out" })
			        .to("#游戏模式选项 .菜单按钮, #返回主菜单按钮", { 
			autoAlpha: 1, 
			y: 0, 
			duration: 0.3, 
			stagger: 0.1, 
			ease: "power2.out" 
			        }, "-=0.5");
			    }
			}
			
			function 隐藏游戏模式选择() {
			    if (typeof gsap === 'undefined') {
			        游戏模式选择菜单.style.display = 'none';
			        return;
			    }
			    gsap.to(游戏模式选择菜单, {
			        autoAlpha: 0,
			        duration: 0.3,
			        ease: "power2.in",
			        onComplete: () => {
			游戏模式选择菜单.style.display = 'none';
			        }
			    });
			}
			
function 启动游戏(存档数据 = null, 是否是创意关卡 = false, 种子 = null, 职业 = null) {
			    程序生成配方列表 = [];
			    已发现的程序生成配方 = [];
			
			    if (存档数据) {
			        console.log("正在加载存档...", 存档数据);
			        try {
			            当前游戏种子 = 存档数据.当前游戏种子 || Date.now().toString();
			            初始化随机数生成器(当前游戏种子);
			            生成怪物引入计划();

			            恢复游戏状态(存档数据, 是否是创意关卡);
			            处理玩家着陆效果(玩家.x,玩家.y,玩家.x,玩家.y)
			            if (存档数据.配方信息) {
			                程序生成配方列表 =
			                    存档数据.配方信息.程序生成配方列表 || [];
			                已发现的程序生成配方 =
			                    存档数据.配方信息.已发现的程序生成配方 || [];
			                
			                已发现的程序生成配方.forEach((discoveredRecipe) => {
			                    if (
			                        !融合配方列表.some(
			                            (r) => r.说明 === discoveredRecipe.说明
			                        )
			                    ) {
			                        融合配方列表.push(discoveredRecipe);
			                    }
			                });
			            }
			            if (是否是创意关卡) 是否是自定义关卡 = true;
			            if (存档数据.强制动画模式) 切换动画 = 存档数据.强制动画模式;
			
			            初始化canvas();
			            
			            
			            更新视口();
			            更新背包显示();
			            更新装备显示();
			            更新界面状态();
			            更新物体指示器();
			
			            最高教程阶段 = 存档数据.教程?.最高阶段 || 6;
			            是否为教程层 = false;
			            document.getElementById("跳过教程按钮").style.display =
			                "none";
			            
			            显示通知("存档加载成功！", "成功");
			            处理沉浸式传送门();
			            绘制();
			        } catch (错误) {
			            console.error("加载存档失败:", 错误);
			            显示通知("加载存档失败", "错误");
			            显示主菜单();
			        }
			    } else {
			        重置所有游戏状态();
			        初始化canvas();
			        当前游戏种子 = 种子 || Date.now().toString();
			        初始化随机数生成器(当前游戏种子);
			        生成怪物引入计划();
			        if(职业) 玩家职业 = 职业;
			        
			        
			        if (window.innerWidth < 769) {
			            document
			                .getElementById("小地图容器")
			                .classList.add("隐藏");
			        }
			        
			        当前层数 = null;
			        游戏开始时间 = Date.now();
			        进入教程层();
			        
			    }
			    if(已初始化 > 0) 动画帧();
			    if(已初始化 > 0) 初始化装备系统();
			    if(已初始化 > 0) 初始化背包事件监听();
			    绘制小地图();
			    更新洞穴视野();
			    隐藏主菜单();
			    
			}
			function 揭示并激活陷阱群(陷阱ID, 中毒持续, 中毒强度) {
			    const 待转换列表 = [];
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const 物品 = 地牢[y]?.[x]?.关联物品;
			            if (物品 instanceof 隐形毒气陷阱 && 物品.自定义数据.get('关联陷阱ID') === 陷阱ID) {
			                待转换列表.push({x, y, 物品});
			            }
			        }
			    }
			
			    if (待转换列表.length > 0) {
			         显示通知(`陷阱被激活了，周围的毒气喷涌而出！`, "警告", true);
			    }
			
			    待转换列表.forEach(条目 => {
			        const {x, y, 物品} = 条目;
			        if(地牢[y]?.[x]?.关联物品 === 物品) {
			            const 新毒气 = new 毒气({
			                中毒持续:中毒持续,
			                中毒强度:中毒强度,
			                来源:'陷阱',
			
			                    倒计时: 9999,
			                    爆炸时间: 9999,
			            });
			            地牢[y][x].关联物品 = null;
			            地牢[y][x].类型 = null;
			            if (放置物品到单元格(新毒气, x, y)) {
			               所有计时器.push(新毒气);
			            }
			        }
			    });
			    绘制();
			}
			
			function 生成毒气陷阱群(房间) {
			    if (房间.id === 0 || 房间.类型 !== '房间') return;
			
			    const 模式 = prng() < 0.5 ? '十字' : 'X形';
			    let 长度 = 2 + Math.floor(prng() * 2);
			
			    let 放置成功 = false;
			    for (let 尝试 = 0; 尝试 < 100; 尝试++) {
			        const 中心X = 房间.x + 1 + Math.floor(prng() * (房间.w - 2));
			        const 中心Y = 房间.y + 1 + Math.floor(prng() * (房间.h - 2));
			
			        const 陷阱坐标 = [];
			        if (位置是否可用(中心X, 中心Y, false)) {
			            陷阱坐标.push({ x: 中心X, y: 中心Y });
			        } else {
			            continue;
			        }
			
			        const 方向集 = 模式 === '十字'
			            ? [[1, 0], [-1, 0], [0, 1], [0, -1]]
			            : [[1, 1], [-1, -1], [1, -1], [-1, 1]];
			
			        let 路径失败 = false;
			        for (const [dx, dy] of 方向集) {
			            let prevX = 中心X;
			            let prevY = 中心Y;
			            for (let i = 1; i <= 长度; i++) {
			                const currX = 中心X + i * dx;
			                const currY = 中心Y + i * dy;
			
			                if (检查移动可行性(prevX, prevY, currX, currY, false) && 位置是否可用(currX, currY, false) && ((地牢[currY][currX].背景类型==单元格类型.房间 && 地牢生成方式 == 'default')||地牢生成方式 == 'cave')) {
			                    陷阱坐标.push({ x: currX, y: currY });
			                    prevX = currX;
			                    prevY = currY;
			                } else {
			                    路径失败 = true;
			                    break;
			                }
			            }
			        }
			        if (路径失败) {
			            路径失败 = false;
			            continue;
			        }
			
			        const 最终坐标列表 = [...new Map(陷阱坐标.map(item => [`${item.x},${item.y}`, item])).values()];
			        const 是否全部可用 = 最终坐标列表.every(pos => 位置是否可用(pos.x, pos.y, false));
			
			        if (是否全部可用 && 最终坐标列表.length > 2) {
			            const 陷阱ID = 生成时间随机数(15);
			            const 强化 = prng() < 0.15 + 当前层数 * 0.02;
			
			            最终坐标列表.forEach(pos => {
			                 const 新陷阱 = new 隐形毒气陷阱({强化: 强化, 关联陷阱ID: 陷阱ID});
			                 放置物品到单元格(新陷阱, pos.x, pos.y);
			            });
			            放置成功 = true;
			            break;
			        }
			        if (尝试 % 50 === 0) 长度 = 2 + Math.floor(prng() * 2);
			    }
			}
			function 生成时间随机数(length = 16) {
			  const timestamp = Date.now().toString(); // 13位
			  const randomLen = length - timestamp.length;
			  if (randomLen <= 0) {
			    // 长度过短，直接截取时间戳部分
			    return Number(timestamp.slice(0, length));
			  }
			  const randomStr = Math.floor(prng() * (10 ** randomLen))
			    .toString()
			    .padStart(randomLen, '0');
			  return Number(timestamp + randomStr);
			}
			
			function 重置所有游戏状态() {
			    融合区物品 = [null, null, null, null];
			    融合结果 = null;
			    传送点列表 = [];
			    所有怪物.forEach((m) => {
			        m.绘制血条(true);
			    });
			    所有怪物.forEach((怪物) => {
			        怪物动画状态.delete(怪物);
			    });
			    地牢 = [];
			    房间列表 = [];
			    上锁房间列表 = [];
			    宠物状态表 = new WeakMap();
			    
			    游戏开始时间 = null;
			    上次死亡地点 = null;
			    调试无限生命=false
			    调试无限能量=false
			    玩家仆从列表 = [];
			    所有怪物 = [];
			    if(地牢生成方式==='cave') 已揭示洞穴格子 = new Set();
			    
			    所有计时器 = [];
			    当前天气效果=[];
			    玩家死亡次数 = 0;
			    //当前关卡存档数据字符串 = null; 这是重置创意关卡的字符串
			    红蓝开关状态 = '红';
			    绿紫开关状态 = '绿';
			    自定义全局设置 = {
			    初始生命值: 100,
			    初始能量值: 100,
			    初始背包容量: 12,
			    玩家属性: {
			        移动步数: 1,
			        攻击加成: 0,
			        防御加成: 0,
			        死亡次数限制: 0,
			    },
			    胜利条件: {
			        回合数限制: 0,
			        伤害限制: 0,
			        生命下限: 0,
			        清除所有怪物: false,
			    },
			    全局天气: [],
			    禁用传送菜单: false,
			    诡魅天气怪物层级: 1,
			    奖励物品层级: 1,
			};
			        初始玩家属性 = {
			    移动步数: 1,
			    攻击加成: 0,
			    防御加成: 0,
			    掉落倍率: 1,
			    透视: false,
			    允许移动: 0,
			    能挖掘墙壁: false,
			    最大生命值加成: 0,
			    怪物反伤: false,
			    挑战波数增加: 0,
			    随机掉落: false,
			    初始能量加成: 0,
			    耐久消耗减免: 0,
			    能量流失: 0,
			    商店价格倍率: 1,
			    已获得神龛效果: [],
			};
			编辑器状态 = {
			    当前选中: null, 
			    模式: '编辑',
			    选中实例: null, 
			    相机速度: 1,
			    正在划区: false,
			    划区起点: { x: 0, y: 0 },
			    上次放置的背景: null,
				笔刷模式: '单个',
				笔刷形状: '圆形',
				笔刷半径: 3,
			};
			    玩家背包 = new Map();
			    玩家装备 = new Map();
			    门实例列表 = new Map();
			    已访问房间 = new Set();
			    房间地图 = Array(地牢大小)
			        .fill()
			        .map(() => Array(地牢大小).fill(-1));
			    玩家初始位置 = { x: 0, y: 0 };
			    玩家.x = 0;
			    玩家.y = 0;
			    当前层数 = 0; // 不进入教程
			    
			    永久Buffs = { 已获得效果: new Set() };
			    玩家状态.forEach((m) => {
			        m.移除状态();
			    });
			    if (当前激活卷轴列表.size > 0) {
			        当前激活卷轴列表.forEach((卷轴) => {
			            当前激活卷轴列表.delete(卷轴);
			            卷轴.卸下();
			        });
			    }
			    是否是自定义关卡 = false;
			    玩家属性 = { ...初始玩家属性 };
			    玩家状态 = [];
			    移动历史 = [];
			    已击杀怪物数 = 0;
			    NPC互动中 = false;
			    当前NPC = null;
			    死亡界面已显示 = false;
			    教程阶段 = 0;
			    最高教程阶段 = 0;
			    是否为教程层 = false;
			    日志历史 = [];
			    最大背包容量 = 12;
			    玩家总移动回合数 = 0;
			    玩家总受到伤害 = 0;
			    Object.keys(胜利条件提示元素组).forEach(键 => {
			        if (胜利条件提示元素组[键]) {
			            胜利条件提示元素组[键].销毁();
			            胜利条件提示元素组[键] = null;
			        }
			    });
			
			    document.getElementById("背包物品栏").innerHTML = "";
			    document
			        .querySelectorAll(".装备槽")
			        .forEach((槽) => (槽.innerHTML = ""));
			    document.getElementById("logContent").innerHTML = ""; // 清空日志面板内容
			
			    document.querySelector(".health-bar").style.width = "100%";
			    document.querySelector(".power-bar").style.width = "100%";
			    怪物追踪提示.更新({ 内容: `追踪怪物：0` });
			    击杀提示.更新({ 内容: `已击杀怪物：0` });
			
			    界面可见性 = { hud: false, 背包: false };
			    if (开发者模式) {
try {
尝试收集物品(new 调试工具({}), true);
} catch (e) {}
}
			}
			function 打开全局设置窗口() {
			    const 窗口 = document.getElementById("全局设置窗口");
			    
			    document.getElementById('设置_初始生命值').value = 自定义全局设置.初始生命值;
			    document.getElementById('设置_初始能量值').value = 自定义全局设置.初始能量值;
			    document.getElementById('设置_初始背包容量').value = 自定义全局设置.初始背包容量;
			    document.getElementById('设置_初始移动步数').value = 自定义全局设置.玩家属性.移动步数;
			    document.getElementById('设置_初始攻击加成').value = 自定义全局设置.玩家属性.攻击加成;
			    document.getElementById('设置_初始防御加成').value = 自定义全局设置.玩家属性.防御加成;
			    
			    document.getElementById('设置_禁用休息').checked = 自定义全局设置.禁用休息 || false;
			    
			
			    document.getElementById('设置_禁用传送菜单').checked = 自定义全局设置.禁用传送菜单 || false;
			    document.getElementById('设置_禁用大地图').checked = 自定义全局设置.禁用大地图 || false;
			    document.getElementById('设置_回合数限制').value = 自定义全局设置.胜利条件.回合数限制;
			    document.getElementById('设置_伤害限制').value = 自定义全局设置.胜利条件.伤害限制;
			    document.getElementById('设置_生命下限').value = 自定义全局设置.胜利条件.生命下限;
			    document.getElementById('设置_清除所有怪物').checked = 自定义全局设置.胜利条件.清除所有怪物 || false;
			    document.getElementById('设置_死亡次数限制').value = 自定义全局设置.胜利条件.死亡次数限制 || 0;
			    
			    document.getElementById('设置_相机视野大小').value = 相机显示边长;
			    document.getElementById('设置_诡魅天气怪物层级').value = 自定义全局设置.诡魅天气怪物层级?? 1;
			    document.getElementById('设置_奖励物品层级').value = 自定义全局设置.奖励物品层级?? 1;
			    
			    const 天气容器 = document.getElementById('天气选择容器');
			    天气容器.innerHTML = '';
			    所有天气列表.forEach(天气 => {
			        const 选项包装 = document.createElement('div');
			        选项包装.className = '天气选项';
			        const 复选框 = document.createElement('input');
			        复选框.type = 'checkbox';
			        复选框.id = `天气_${天气}`;
			        复选框.value = 天气;
			        if (自定义全局设置.全局天气.includes(天气)) {
			            复选框.checked = true;
			        }
			        const 标签 = document.createElement('label');
			        标签.htmlFor = `天气_${天气}`;
			        标签.textContent = 天气;
			
			        选项包装.appendChild(复选框);
			        选项包装.appendChild(标签);
			        天气容器.appendChild(选项包装);
			    });
			
			    窗口.style.display = 'block';
			    窗口.style.opacity = 0;
			    窗口.style.transform = 'translate(-50%, -50%) scale(0.9)';
			    requestAnimationFrame(() => {
			        窗口.style.transition = 'opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)';
			        窗口.style.opacity = 1;
			        窗口.style.transform = 'translate(-50%, -50%) scale(1)';
			    });
			
			    document.getElementById('编辑器保存按钮').onclick = 下载地图文件;
			    document.getElementById('编辑器加载按钮').onclick = () => {
			        const 文件输入控件 = document.getElementById("存档文件输入");
			        文件输入控件.value = '';
			        文件输入控件.onchange = (事件) => {
			            const 文件 = 事件.target.files[0];
			            if (文件) {
			                const reader = new FileReader();
			                reader.onload = (读取事件) => {
			                    const 存档字符串 = 读取事件.target.result;
			                    try {
			                        const 预览数据 = JSON.parse(存档字符串);
									if (!开发者模式) {
			                        if (预览数据.isPublished) {
			                            显示通知("编辑器不能加载已发布的创意关卡！", "错误");
			                            return;
			                        }
								}
			                        if (预览数据.版本 && 预览数据.所有地牢层数据) {
			                            显示楼层选择窗口(存档字符串);
			                        } else {
			                            saveEditorState();
			                            导入地图(存档字符串);
			                        }
			                    } catch (e) {
			                        显示通知("文件格式错误或无法识别！", "错误");
			                    }
			                };
			                reader.readAsText(文件);
			            }
			        };
			        文件输入控件.click();
			        关闭全局设置窗口();
			    };
			    document.getElementById('编辑器设置起点按钮').onclick = () => {
			        if (编辑器状态.模式 === '设置起点') {
			            编辑器状态.模式 = 旧编辑器状态 || '编辑';
			            显示通知("已取消设置起点", "信息");
			        } else {
			            旧编辑器状态 = 编辑器状态.模式;
			            编辑器状态.模式 = '设置起点';
			            显示通知("请在地图上点击设置玩家起点", "信息");
			        }
			        关闭全局设置窗口();
			    };
			    document.getElementById('编辑器模板按钮').onclick = () => {
			        地牢生成方式 = 'default';
			        generateDungeonTemplate();
			        const 互动按钮元素 = document.getElementById('互动按钮');
			        if(互动按钮元素) 互动按钮元素.style.background = '';
			        关闭全局设置窗口();
			    };
			    document.getElementById('编辑器洞穴模板按钮').onclick = () => {
    地牢生成方式 = 'cave';
			        generateDungeonTemplate();
    const 互动按钮元素 = document.getElementById('互动按钮');
    if(互动按钮元素) 互动按钮元素.style.background = '';
    关闭全局设置窗口();
};
document.getElementById('编辑器迷宫模板按钮').onclick = () => {
    地牢生成方式 = 'maze';
			        generateDungeonTemplate();
    const 互动按钮元素 = document.getElementById('互动按钮');
    if(互动按钮元素) 互动按钮元素.style.background = '';
    关闭全局设置窗口();
};
			    document.getElementById('关闭全局设置按钮').onclick = 关闭全局设置窗口;
			    document.getElementById('保存全局设置按钮').onclick = 保存全局设置;
			}
			
			function 关闭全局设置窗口() {
			    
			    const 窗口 = document.getElementById("全局设置窗口");
			    if (!窗口 || 窗口.style.display === 'none') return;
			
			    窗口.style.opacity = 0;
			    窗口.style.display = 'none'
			    窗口.style.transform = 'translate(-50%, -50%) scale(0.9)';
			}
			function 显示楼层选择窗口(存档字符串) {
			    const 存档数据 = JSON.parse(存档字符串);
			    const 楼层列表容器 = document.getElementById('楼层选择列表');
			    const 遮罩 = document.getElementById('楼层选择遮罩');
			    楼层列表容器.innerHTML = ''; 
			
			    const 楼层号列表 = Object.keys(存档数据.所有地牢层数据);
			
			    if (楼层号列表.length === 0) {
			        显示通知("此存档中没有找到楼层数据。", "错误");
			        return;
			    }
			
			    楼层号列表.forEach(楼层号 => {
			        const 按钮 = document.createElement('button');
			        按钮.className = '菜单按钮';
			        按钮.textContent = `第 ${楼层号} 层`;
			        按钮.onclick = () => {
			            const 选中楼层数据 = 存档数据.所有地牢层数据[楼层号];
			            
			            const 伪造的地图数据 = {
			                所有传送门:存档数据.所有传送门,
			                编辑器状态数据: {},
			                所有地牢层数据: {
			                    "-1": 选中楼层数据
			                },
			                当前层数: -1,
			                玩家: {
			                    x: 选中楼层数据.玩家初始位置?.x ?? 50,
			                    y: 选中楼层数据.玩家初始位置?.y ?? 50,
			                    属性: {},
			                    背包: [],
			                    装备: [],
			                }
			            };
			            
			            saveEditorState();
			            导入地图(JSON.stringify(伪造的地图数据));
			            自定义全局设置 = 存档数据.自定义全局设置;
			            const 初始房间 = 房间列表.find(r => r.id === 0);
			    if (初始房间) {
			        初始房间.已探索 = true;
			    }
			    if (parseInt(楼层号,10)!==-1){
			
			    let 胜利旗帜位置 = null;
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const cell = 地牢[y][x];
			            if (cell.关联物品 && (cell.类型 === 单元格类型.楼梯下楼 || cell.类型 === 单元格类型.楼梯上楼)) {
			                if (cell.类型 === 单元格类型.楼梯下楼) {
			                    胜利旗帜位置 = {x, y};
			                }
			                cell.关联物品 = null;
			                cell.类型 = null;
			            } else if (cell.关联物品 instanceof 寻宝戒指) {
			                cell.关联物品.自定义数据.set('生效层数',-1);
			            } else if (cell.关联物品 instanceof 隐形虫洞陷阱) {
			                cell.关联物品 = null;
			                cell.类型 = null;
			                
			            } else if (cell.关联物品 instanceof 配方卷轴) {
			                cell.关联物品 = null;
			                cell.类型 = null;
			                
			            } else if (cell.关联物品 instanceof 召唤怪物陷阱) {
			                cell.关联物品.自定义数据.set('怪物层级',当前层数);
			            } else if (cell.关联物品 instanceof 钥匙) {
			                cell.关联物品.自定义数据.set('地牢层数',-1);
			            } else if (cell.关联物品 instanceof 神秘商人) {
			                cell.关联物品.自定义数据.set('商品层数',当前层数);
			                cell.关联物品.生成库存(Math.max(cell.关联物品.自定义数据.get('商品层数'), 0));
			            } else if (cell.关联物品 instanceof 探险家) {
			                cell.关联物品.自定义数据.set('需求层数',当前层数);
			                cell.关联物品.生成收购需求(cell.关联物品.自定义数据.get('需求层数'));
			            }
			        }
			    }
			    if (胜利旗帜位置) {
			        放置物品到单元格(new 旗帜(), 胜利旗帜位置.x, 胜利旗帜位置.y);
			    }
			    }
			
			    //生成并放置随机配方卷轴(当前层数);
			    
			    游戏状态 = '地图编辑器';
			    红蓝开关状态 = '红';
			    绿紫开关状态 = '绿';
			    当前层数 = -1;
			    处理房间状态();
			            关闭楼层选择窗口();
			        };
			        楼层列表容器.appendChild(按钮);
			    });
			
			    document.getElementById('关闭楼层选择按钮').onclick = 关闭楼层选择窗口;
			    遮罩.style.display = 'block';
			}
			
			function 关闭楼层选择窗口() {
			    const 遮罩 = document.getElementById('楼层选择遮罩');
			    if (遮罩) {
			        遮罩.style.display = 'none';
			    }
			}
			function 处理HUD切换按钮点击() {
			    if (游戏状态 === '地图编辑器') {
			        切换编辑器工具栏模式();
			    } else {
			        切换HUD模式();
			    }
			}
			
			function 保存全局设置() {
			    自定义全局设置.初始生命值 = parseInt(document.getElementById('设置_初始生命值').value) || 100;
			    自定义全局设置.初始能量值 = parseInt(document.getElementById('设置_初始能量值').value) || 100;
			    自定义全局设置.初始背包容量 = parseInt(document.getElementById('设置_初始背包容量').value) || 12;
			    
			    自定义全局设置.玩家属性.移动步数 = parseInt(document.getElementById('设置_初始移动步数').value) || 1;
			    自定义全局设置.玩家属性.攻击加成 = parseInt(document.getElementById('设置_初始攻击加成').value) || 0;
			    自定义全局设置.玩家属性.防御加成 = parseInt(document.getElementById('设置_初始防御加成').value) || 0;
			
			    自定义全局设置.禁用传送菜单 = document.getElementById('设置_禁用传送菜单').checked;
			    自定义全局设置.禁用大地图 = document.getElementById('设置_禁用大地图').checked;
			    自定义全局设置.胜利条件.回合数限制 = parseInt(document.getElementById('设置_回合数限制').value) || 0;
			    自定义全局设置.胜利条件.伤害限制 = parseInt(document.getElementById('设置_伤害限制').value) || 0;
			    自定义全局设置.胜利条件.生命下限 = parseInt(document.getElementById('设置_生命下限').value) || 0;
			    自定义全局设置.胜利条件.清除所有怪物 = document.getElementById('设置_清除所有怪物').checked;
			    自定义全局设置.胜利条件.死亡次数限制 = parseInt(document.getElementById('设置_死亡次数限制').value) || 0;
			    
			    自定义全局设置.禁用休息 = document.getElementById('设置_禁用休息').checked;
			    自定义全局设置.禁用传送菜单 = document.getElementById('设置_禁用传送菜单').checked;
			
			    const 新视野大小 = parseInt(document.getElementById('设置_相机视野大小').value);
			    if (新视野大小) {
			        相机显示边长 = 新视野大小;
			        初始化canvas();
			        更新视口();
			        绘制();
			    }
			
			    自定义全局设置.诡魅天气怪物层级 = parseInt(document.getElementById('设置_诡魅天气怪物层级').value)?? 1;
			    自定义全局设置.奖励物品层级 = parseInt(document.getElementById('设置_奖励物品层级').value) || 1;
			
			    自定义全局设置.全局天气 = [];
			    document.querySelectorAll('#天气选择容器 input:checked').forEach(复选框 => {
			        自定义全局设置.全局天气.push(复选框.value);
			    });
			    当前天气效果=[...自定义全局设置.全局天气];
			    显示通知("全局设置已保存！", "成功");
			    关闭全局设置窗口();
			}
			
			async function 生成签名(dataString) {
			    const textToEncode = dataString + 数据完整性密钥;
			    const encoder = new TextEncoder();
			    const data = encoder.encode(textToEncode);
			    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
			    const hashArray = Array.from(new Uint8Array(hashBuffer));
			    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
			    return hashHex;
			}
			function 检查胜利条件() {
			    const 条件 = 自定义全局设置.胜利条件;
			    const 生命条 = document.querySelector(".health-bar");
			    const 当前生命 = parseFloat(生命条.style.width) || 100;
			
			    let 失败消息 = [];
			    if (条件.死亡次数限制 > 0 && 玩家死亡次数 >= 条件.死亡次数限制) {
			        失败消息.push(`超过了最大死亡次数 (${条件.死亡次数限制-1})`);
			        
			    }
			    if (条件.回合数限制 > 0 && 玩家总移动回合数 > 条件.回合数限制) {
			        失败消息.push(`超过了回合数限制 (${玩家总移动回合数}/${条件.回合数限制})`);
			    }
			    if (条件.伤害限制 > 0 && 玩家总受到伤害 > 条件.伤害限制) {
			        失败消息.push(`承受伤害过多 (${玩家总受到伤害.toFixed(1)}/${条件.伤害限制})`);
			    }
			    if (条件.生命下限 > 0 && 当前生命 < 条件.生命下限) {
			        失败消息.push(`生命值过低 (${当前生命.toFixed(1)}% / ${条件.生命下限}%)`);
			    }
			
			    if (失败消息.length > 0) {
			        显示通知(`胜利条件未达成：${失败消息.join('，')}。`, '错误', true);
			    } else {
			        显示胜利界面();
			    }
			}
			const 游戏模式选择菜单 = document.getElementById("游戏模式选择菜单");
			const 返回主菜单按钮 = document.getElementById("返回主菜单按钮");
			const 无尽地牢按钮 = document.getElementById("无尽地牢按钮");
			const 创意关卡按钮 = document.getElementById("创意关卡按钮");
			const 创意关卡文件输入 = document.getElementById("创意关卡文件输入");
			
			
			
			async function 导入创意关卡(存档字符串) {
			    try {
			        const 存档数据 = JSON.parse(存档字符串);
			        if (!存档数据.isPublished) {
			            显示通知("这不是一个已发布的创意关卡文件！", "错误");
			            return false;
			        }
			
			        // --- 验证签名开始 ---
			        const 接收到的签名 = 存档数据.signature;
			        if (!接收到的签名) {
			            显示通知("加载失败：关卡文件缺少签名，可能已损坏或来自旧版本。", "错误");
			            return false;
			        }
			
			        delete 存档数据.signature; // 从数据中移除签名以进行校验
			        const 待验证数据字符串 = JSON.stringify(存档数据);
			        const 预期签名 = await 生成签名(待验证数据字符串);
			
			        if (接收到的签名 !== 预期签名) {
			            显示通知("加载失败：关卡文件已被篡改或已损坏！", "错误");
			            return false;
			        }
			        // --- 验证签名结束 ---
			
			        
			        if (存档数据.游戏版本 && 存档数据.游戏版本 > 游戏版本) {
			    显示通知(`存档版本 (${存档数据.游戏版本}) 高于当前游戏版本 (${游戏版本})，无法加载！`, "错误");
			    显示主菜单();
			    return false;
			}
			for (let i=0;i<Math.ceil(Math.random()*10);i++) prng()
			        启动游戏(存档数据, true);
			        当前关卡存档数据字符串 = 存档字符串;
			        if (存档数据.关卡标题) {
			            显示通知(`欢迎来到：${存档数据.关卡标题}`, "信息", true, 4000);
			        }
			        return true;
			    } catch (error) {
			        console.error("加载创意关卡时出错:", error);
			        显示通知("加载创意关卡失败，文件格式错误或数据损坏。", "错误");
			        return false;
			    }
			}
			function 重置创意关卡() {
			    if (!是否是自定义关卡) return;
			    if (!当前关卡存档数据字符串) {
			        显示通知("无法重置：未找到关卡数据！", "错误");
			        return;
			    }
			
			    显示自定义确认对话框(
			        "你确定要重新开始当前关卡吗？<br>所有进度都将被重置。",
			        () => {
			            关闭设置菜单(); 
			            
			            setTimeout(() => {
			                启动游戏(JSON.parse(当前关卡存档数据字符串), true);
			            }, 310);
			        }
			    );
			}
			async function 发布关卡() {
			    if (!编辑器状态备份) {
			        显示通知("找不到原始地图状态，发布失败！", "错误");
			        return;
			    }
			
			    const 关卡标题 = prompt("请输入关卡标题：", "我的创意关卡");
			    if (关卡标题 === null || 关卡标题.trim() === "") {
			        显示通知("已取消发布。", "信息");
			        return;
			    }
			        
			    try {
			        const 地图数据 = JSON.parse(编辑器状态备份);
			        地图数据.玩家.属性.允许移动 = 0;
			        
			        地图数据.玩家.x = 玩家初始位置.x;
			        地图数据.玩家.y = 玩家初始位置.y;
			        
			        地图数据.关卡标题 = 关卡标题;
			        地图数据.isPublished = true;
			        地图数据.强制动画模式 = 切换动画;
			        地图数据.作者设置_相机视野 = 相机显示边长;
        			地图数据.作者设置_受伤击退 = 游戏设置.受伤时击退;
			        delete 地图数据.编辑器状态数据;
			        delete 地图数据.配方信息;
			
			        // --- 签名开始 ---
			        delete 地图数据.signature; // 确保先移除旧签名（如果有）
			        const 数据字符串 = JSON.stringify(地图数据);
			        地图数据.signature = await 生成签名(数据字符串); // 生成并附加签名
			        // --- 签名结束 ---
			        
			        const 地图字符串最终 = JSON.stringify(地图数据);
			        const 数据块 = new Blob([地图字符串最终], { type: 'application/json' });
			        const 下载链接 = URL.createObjectURL(数据块);
			        const 链接元素 = document.createElement('a');
			        链接元素.href = 下载链接;
			        const 时间戳 = new Date().toISOString().replace(/[:.]/g, "-");
			        链接元素.download = `${关卡标题}_${时间戳}.json`;
			        document.body.appendChild(链接元素);
			        链接元素.click();
			        document.body.removeChild(链接元素);
			        URL.revokeObjectURL(下载链接);
			        显示通知('关卡已成功发布!', '成功');
			    } catch (e) {
			        显示通知('发布关卡时发生错误！', '错误');
			        console.error(e);
			    }
			}
			
			if (新建游戏按钮) {
			    
			    新建游戏按钮.addEventListener("click", 显示游戏模式选择);
			}
			const 无尽洞穴按钮 = document.getElementById("无尽洞穴按钮");
if (无尽洞穴按钮) {
    无尽洞穴按钮.addEventListener("click", () => {
        地牢生成方式 = 'cave'; // 设置为洞穴生成器
        document.getElementById('种子筛选器按钮').style.display='none';
        显示职业选择界面();
    });
}
const 无尽迷宫按钮 = document.getElementById("无尽迷宫按钮");
if (无尽迷宫按钮) {
    无尽迷宫按钮.addEventListener("click", () => {
        地牢生成方式 = 'maze'; // 设置为迷宫生成器
        
        显示职业选择界面();
    });
}
			if (返回主菜单按钮) {
			    返回主菜单按钮.addEventListener("click", () => {
			        隐藏游戏模式选择();
			        显示主菜单();
			    });
			}
			
			if (无尽地牢按钮) {
			    无尽地牢按钮.addEventListener("click", () => {
			        地牢生成方式 = 'default';
			        //隐藏游戏模式选择();
			        document.getElementById('种子筛选器按钮').style.display='flex';
			        显示职业选择界面();
			    });
			}
			function 净化HTML(文本) {
			    if (typeof 文本 !== 'string') return '';
			    const 映射表 = {
			        '<': '&lt;',
			        '>': '&gt;',
			    };
			    return 文本.replace(/[&<>"']/g, (匹配) => 映射表[匹配]);
			}
			
			function 显示创意关卡浏览器() {
			    隐藏游戏模式选择();
			    const 浏览器容器 = document.getElementById("创意关卡浏览器");
			    const 返回按钮 = document.getElementById('返回游戏模式选择按钮');
			    const 标题 = 浏览器容器.querySelector('h2');
			    const 上传区域 = document.getElementById('上传区域');
			    const 搜索区域 = document.getElementById('搜索与列表区域');
			    if (typeof gsap === 'undefined') {
			        刷新关卡列表()
			        return;
			    }
			    
			    const 动画时间线 = gsap.timeline({
			        onComplete: 刷新关卡列表
			    });
			
			    gsap.set(浏览器容器, { autoAlpha: 0 });
			    gsap.set(返回按钮, { autoAlpha: 0, scale: 0.8 });
			    gsap.set(标题, { autoAlpha: 0, y: -30 });
			    gsap.set([上传区域, 搜索区域], { autoAlpha: 0, y: 30 });
			
			    动画时间线
			        .to(浏览器容器, { 
			autoAlpha: 1, 
			duration: 0.4, 
			ease: "power2.inOut",
			onStart: () => {
			    浏览器容器.style.display = 'flex';
			}
			        })
			        .to(返回按钮, { 
			autoAlpha: 1, 
			scale: 1, 
			duration: 0.5, 
			ease: 'back.out(1.7)' 
			        }, "-=0.2")
			        .to(标题, { 
			autoAlpha: 1, 
			y: 0, 
			duration: 0.6, 
			ease: 'power2.out' 
			        }, '<')
			        .to([上传区域, 搜索区域], { 
			autoAlpha: 1, 
			y: 0, 
			duration: 0.5, 
			stagger: 0.1, 
			ease: 'power2.out' 
			        }, "-=0.4");
			}
			
			function 隐藏创意关卡浏览器() {
			    const 浏览器容器 = document.getElementById("创意关卡浏览器");
			    const 返回按钮 = document.getElementById('返回游戏模式选择按钮');
			    const 标题 = 浏览器容器.querySelector('h2');
			    const 上传区域 = document.getElementById('上传区域');
			    const 搜索区域 = document.getElementById('搜索与列表区域');
			    if (typeof gsap === 'undefined') {
			        浏览器容器.style.display = 'none';
			        显示游戏模式选择();
			        return;
			    }
			    
			    gsap.to([返回按钮, 标题, 上传区域, 搜索区域], { 
			        autoAlpha: 0, 
			        y: 15, 
			        duration: 0.1, 
			        ease: 'power2.in' 
			    });
			
			    gsap.to(浏览器容器, {
			        autoAlpha: 0,
			        duration: 0.2,
			        ease: "power2.in",
			        onComplete: () => {
			浏览器容器.style.display = 'none';
			显示游戏模式选择();
			        }
			    });
			}
			function safeEncode(str) {
			    
			    return btoa(unescape(encodeURIComponent(str)));
			}
			
			function safeDecode(str) {
			    
			    try {
			        return decodeURIComponent(escape(atob(str)));
			    } catch (e) {
			        console.warn("Base64解码失败，返回原始字符串:", str, e);
			        return str;
			    }
			}
			
			window.addEventListener('load', () => {
			    try {
			        if (window.location.hash && window.location.hash.startsWith('#levelData=')) {
			const encodedData = window.location.hash.substring('#levelData='.length);
			const decodedDataString = decodeURIComponent(escape(atob(encodedData)));
			const levelData = JSON.parse(decodedDataString);
			
			// 隐藏主菜单，直接启动游戏
			const 主菜单容器 = document.getElementById("主菜单容器");
			主菜单容器.style.display = 'none';
			
			启动游戏(levelData, true); 
			
			// 清理 hash，防止刷新时重复加载
			history.pushState("", document.title, window.location.pathname + window.location.search);
			        }
			    } catch (error) {
			        console.error("从URL加载关卡失败:", error);
			        alert("加载创意关卡失败，数据可能已损坏！将返回主菜单。");
			        // 如果加载失败，确保主菜单能够正常显示
			        const 主菜单容器 = document.getElementById("主菜单容器");
			        主菜单容器.style.display = 'flex';
			    }
			});
			
			async function 上传关卡处理函数() {
			    const fileInput = document.getElementById('关卡文件输入');
			    const titleInput = document.getElementById('关卡标题输入');
			    const authorInput = document.getElementById('关卡作者输入');
			    const tagsInput = document.getElementById('关卡标签输入');
			    const passwordInput = document.getElementById('关卡上传密码输入');
			    
			    const originalFile = fileInput.files[0];
			    const title = 净化HTML(titleInput.value);
			    const author = 净化HTML(authorInput.value);
			    const tags = tagsInput.value.split(',').map(s => 净化HTML(s.trim())).filter(Boolean);
			    const password = passwordInput.value;
			
			    if (!originalFile || !title || !password) {
			        显示通知("必须选择关卡文件、填写标题和设置删除密码！", "错误");
			        return;
			    }
			    if (!originalFile.name.endsWith('.json')) {
			        显示通知("请上传.json格式的关卡文件！", "错误");
			        return;
			    }
			
			    const reader = new FileReader();
			    reader.onload = async (e) => {
			        const fileContent = e.target.result;
			        try {
			            const levelData = JSON.parse(fileContent);
			            const levelGameVersion = levelData.游戏版本;
			
			            if (!levelGameVersion) {
			                 throw new Error("关卡文件缺少必需的游戏版本信息！");
			            }
			
			            if (!levelData.isPublished) {
			                throw new Error("只能上传已发布的创意关卡文件！");
			            }
			            const receivedSignature = levelData.signature;
			            if (!receivedSignature) {
			                throw new Error("关卡文件缺少签名，可能已损坏或来自旧版本。");
			            }
			            delete levelData.signature;
			            const dataToVerifyString = JSON.stringify(levelData);
			            const expectedSignature = await 生成签名(dataToVerifyString);
			            if (receivedSignature !== expectedSignature) {
			                throw new Error("关卡文件签名验证失败，可能已被篡改！");
			            }
			            
			            const encodedFileName = safeEncode(originalFile.name);
			            const newSafeFile = new File([fileContent], encodedFileName, {
			                type: originalFile.type,
			                lastModified: originalFile.lastModified,
			            });
			            显示通知('开始上传创意关卡','信息');
			            
			            await uploadLevel(newSafeFile, { title, author, tags, version: levelGameVersion, password });
			            
			            显示通知('关卡上传成功！', '成功');
			            fileInput.value = '';
			            titleInput.value = '';
			            authorInput.value = '';
			            tagsInput.value = '';
			            passwordInput.value = '';
			            刷新关卡列表();
			
			        } catch (error) {
			            console.error("上传验证失败:", error);
			            显示通知('上传失败: ' + error.message, '错误');
			        }
			    };
			    reader.onerror = () => {
			        显示通知('读取文件失败！', '错误');
			    };
			    reader.readAsText(originalFile);
			}
			
			async function uploadLevel(file, {title, author, tags, version, password}) {
			  const storagePath = Date.now() + '_' + file.name;
			  
			  const { error } = await supabase.storage.from('levels').upload(
			      storagePath, 
			      file
			  );
			
			  if(error) throw error;
			
			  const { data: { publicUrl } } = supabase.storage.from('levels').getPublicUrl(storagePath);
			  
			  const { error: err2 } = await supabase.from('levels').insert([{
			      filename: file.name, 
			      title: safeEncode(title),
			      author: safeEncode(author),
			      file_url: publicUrl,
			      tags: tags.map(tag => safeEncode(tag)),
			      version: safeEncode(version),
			      upload_password: password
			  }]);
			  if(err2) throw err2;
			}
			
			async function searchLevels({keyword}) {
			    if (!supabase) {
			        throw new Error("Supabase 客户端未初始化。");
			    }
			    if (!keyword) {
			        return getLevelList();
			    }
			    let { data, error } = await supabase.rpc('search_levels_decoded', {
			        search_keyword: keyword
			    });
			
			    if (error) {
			        console.error("搜索关卡时出错 (RPC):", error);
			        throw error;
			    }
			    return data;
			}
			
			async function getLevelList() {
			  let { data, error } = await supabase.from('levels').select('*, clearances').order('uploaded_at',{ascending:false}).limit(20);
			  if (error) throw error;
			  return data;
			}
			
			async function 刷新关卡列表() {
			    const kw = document.getElementById('搜索关卡输入').value;
			    const listElement = document.getElementById('关卡列表');
			    listElement.innerHTML = '<li>正在加载...</li>';
			
			    try {
			        const lv = kw ? await searchLevels({ keyword: kw }) : await getLevelList();
			        listElement.innerHTML = '';
			
			        if (lv && lv.length > 0) {
			lv.forEach(l => {
			    const decodedTitle = safeDecode(l.title || '');
			    const decodedAuthor = safeDecode(l.author || '');
			    const playCount = l.play_count || 0;
			    const likes = l.likes || 0;
			    const clearances = l.clearances || 0;
			
			    const listItem = document.createElement('li');
			    listItem.style.cssText = "background: rgba(255,255,255,0.08); padding: 15px; border-radius: 6px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; cursor: pointer;";
			    
			    listItem.addEventListener('click', () => 显示关卡详情(l));
			
			    const contentDiv = document.createElement('div');
			    
			    const titleElement = document.createElement('b');
			    titleElement.style.cssText = "font-size: 1.2em; color: #fff;";
			    titleElement.textContent = decodedTitle;
			    
			    const statsDiv = document.createElement('div');
			    statsDiv.style.cssText = "display: flex; align-items: center; gap: 15px; margin-top: 5px; flex-wrap: wrap;";
			
			    const authorSpan = document.createElement('span');
			    authorSpan.style.cssText = "color: #aaa; font-size: 0.9em;";
			    authorSpan.textContent = `by ${decodedAuthor || '匿名作者'}`;
			
			    const playSpan = document.createElement('span');
			    playSpan.style.cssText = "color: #4caf50; font-size: 0.9em;";
			    playSpan.textContent = `👁️ ${playCount}`;
			
			    const likeSpan = document.createElement('span');
			    likeSpan.style.cssText = "color: #66bb6a; font-size: 0.9em;";
			    likeSpan.textContent = `👍 ${likes}`;
			    
			    const clearanceSpan = document.createElement('span');
			    clearanceSpan.style.cssText = "color: #ffd700; font-size: 0.9em;";
			    clearanceSpan.textContent = `🏆 ${clearances}`;
			
			    statsDiv.appendChild(authorSpan);
			    statsDiv.appendChild(playSpan);
			    statsDiv.appendChild(likeSpan);
			    statsDiv.appendChild(clearanceSpan);
			
			    contentDiv.appendChild(titleElement);
			    contentDiv.appendChild(statsDiv);
			
			    const arrowSpan = document.createElement('span');
			    arrowSpan.style.cssText = "font-size: 1.5em; color: #666;";
			    arrowSpan.textContent = '>';
			
			    listItem.appendChild(contentDiv);
			    listItem.appendChild(arrowSpan);
			    
			    listElement.appendChild(listItem);
			});
			if (typeof gsap === 'undefined') {
			        return;
			    }
			gsap.fromTo(listElement.children, 
			    { autoAlpha: 0, y: 20 }, 
			    { autoAlpha: 1, y: 0, duration: 0.4, stagger: 0.05, ease: "power2.out" }
			);
			
			        } else {
			listElement.innerHTML = '<li style="text-align: center; color: #888; padding: 20px;">没有找到关卡。</li>';
			        }
			    } catch (error) {
			        console.error("获取关卡列表失败:", error);
			        listElement.innerHTML = '<li style="text-align: center; color: #888; padding: 20px;">加载失败，请检查网络并刷新。</li>';
			    }
			}
			async function 游玩创意关卡(url, level_id) {
			    try {
			        显示通知('正在加载关卡...', '信息', true);
			        当前关卡ID = level_id;
			
			        if (supabase && level_id) {
			            const { error } = await supabase.rpc('increment_play_count', {
			                level_id_to_increment: level_id
			            });
			            if (error) {
			                console.error('增加游玩次数失败:', error);
			            }
			        }
			
			        let levelDataString;
			
			        if (当前加载的关卡数据缓存 && 当前加载的关卡数据缓存.id == level_id) {
			            levelDataString = 当前加载的关卡数据缓存.data;
			        } else {
			            const response = await fetch(url);
			            if (!response.ok) {
			                throw new Error(`网络响应错误: ${response.statusText}`);
			            }
			            levelDataString = await response.text();
			        }
			        
			        document.getElementById('关卡详情界面').style.display = 'none';
			    document.getElementById('创意关卡浏览器').style.display = 'none';
			        await 导入创意关卡(levelDataString);
			
			    } catch (error) {
			        console.error('加载创意关卡失败:', error);
			        显示通知('加载创意关卡失败: ' + error.message, '错误');
			        当前关卡ID = null;
			    }
			}
			
			
			async function 显示关卡详情(关卡数据) {
			    const 详情界面 = document.getElementById('关卡详情界面');
			    const 左侧 = document.getElementById('关卡详情_左侧');
			    const 右侧 = document.getElementById('关卡详情_右侧');
			    const 返回浏览器按钮 = document.getElementById('返回浏览器按钮');
			    if (typeof gsap !== 'undefined') {
			        gsap.set(详情界面, { autoAlpha: 0 });
			    gsap.set(左侧, { autoAlpha: 0, x: -50 });
			    gsap.set(右侧, { autoAlpha: 0, x: 50 });
			    gsap.set(返回浏览器按钮, { autoAlpha: 0, y: 20 });
			    
			    const 动画时间线 = gsap.timeline();
			    动画时间线
			        .to(详情界面, { 
			autoAlpha: 1, 
			duration: 0.3, 
			ease: "power2.inOut",
			onStart: () => {
			    详情界面.style.display = 'flex';
			}
			        })
			        .to([左侧, 右侧], { 
			autoAlpha: 1, 
			x: 0, 
			duration: 0.6, 
			stagger: 0.1, 
			ease: 'power2.out' 
			        }, "-=0.1")
			        .to(返回浏览器按钮, { 
			autoAlpha: 1, 
			y: 0, 
			duration: 0.5, 
			ease: 'power2.out' 
			        }, "-=0.4");
			        
			    }
			    
			
			    const 小地图画布 = document.getElementById('详情_小地图');
			    const 小地图上下文 = 小地图画布.getContext('2d');
			    小地图上下文.clearRect(0, 0, 小地图画布.width, 小地图画布.height);
			    小地图上下文.fillStyle = "#000";
			    小地图上下文.fillRect(0, 0, 小地图画布.width, 小地图画布.height);
			    小地图上下文.fillStyle = "#555";
			    小地图上下文.font = "20px Arial";
			    小地图上下文.textAlign = "center";
			    小地图上下文.textBaseline = "middle";
			    小地图上下文.fillText("加载中...", 小地图画布.width / 2, 小地图画布.height / 2);
			
			    document.getElementById('详情_标题').textContent = safeDecode(关卡数据.title || '无标题');
			    document.getElementById('详情_作者').textContent = `作者: ${safeDecode(关卡数据.author || '匿名')}`;
			    document.getElementById('详情_版本').textContent = `游戏版本: v${safeDecode(关卡数据.version || '未知')}`;
			    document.getElementById('详情_游玩次数').textContent = `👁️ ${关卡数据.play_count || 0}`;
			    document.getElementById('详情_通关次数').textContent = `🏆 ${关卡数据.clearances || 0}`;
			    document.getElementById('详情_赞').textContent = `👍 ${关卡数据.likes || 0}`;
			    document.getElementById('详情_踩').textContent = `👎 ${关卡数据.dislikes || 0}`;
			
			    const 按钮容器 = document.getElementById('详情_操作按钮容器');
			    按钮容器.innerHTML = '';
			
			    const 创建按钮 = (文本, 类名, 点击事件) => {
			        const 按钮 = document.createElement('button');
			        按钮.className = `菜单按钮 ${类名}`;
			        按钮.textContent = 文本;
			        按钮.addEventListener('click', 点击事件);
			        return 按钮;
			    };
			    
			    const 游玩按钮 = 创建按钮('开始游玩', '', () => 游玩创意关卡(关卡数据.file_url, 关卡数据.id));
			    
			    const 评价按钮容器 = document.createElement('div');
			    评价按钮容器.style.cssText = "display: flex; gap: 1rem; justify-content: center;";
			    
			    const 点赞按钮 = 创建按钮('赞 👍', '', () => 点赞或点踩(关卡数据.id, 'likes'));
			    点赞按钮.style.cssText = "flex-grow: 1; padding: 8px 16px; font-size: 1em; min-width: 120px;";
			    
			    const 点踩按钮 = 创建按钮('踩 👎', '', () => 点赞或点踩(关卡数据.id, 'dislikes'));
			    点踩按钮.style.cssText = "flex-grow: 1; padding: 8px 16px; font-size: 1em; min-width: 120px;";
			
			    评价按钮容器.appendChild(点赞按钮);
			    评价按钮容器.appendChild(点踩按钮);
			
			    const 删除按钮 = 创建按钮('删除关卡', '', () => 删除关卡(关卡数据.id));
			    删除按钮.style.background = 'rgba(200, 50, 50, 0.2)';
			    删除按钮.style.borderColor = '#f44336';
			
			    按钮容器.appendChild(游玩按钮);
			    按钮容器.appendChild(评价按钮容器);
			    按钮容器.appendChild(删除按钮);
			
			    try {
			        const response = await fetch(关卡数据.file_url);
			        const levelDataString = await response.text();
			        const levelData = JSON.parse(levelDataString);
			        当前加载的关卡数据缓存 = { id: 关卡数据.id, data: levelDataString };
			        绘制详情小地图(levelData, '详情_小地图');
			    } catch(e) {
			        console.error("加载小地图失败:", e);
			        小地图上下文.clearRect(0, 0, 小地图画布.width, 小地图画布.height);
			        小地图上下文.fillStyle = "#000";
			        小地图上下文.fillRect(0, 0, 小地图画布.width, 小地图画布.height);
			        小地图上下文.fillStyle = "#800";
			        小地图上下文.fillText("地图预览加载失败", 小地图画布.width / 2, 小地图画布.height / 2);
			    }
			}
			function 绘制详情小地图(关卡数据, 画布ID) {
			    const 楼层数据 = 关卡数据.所有地牢层数据[关卡数据.当前层数];
			    if (!楼层数据) return;
			
			    const 小地图 = document.getElementById(画布ID);
			    const 小地图Ctx = 小地图.getContext("2d");
			    小地图.width = 300;
			    小地图.height = 300;
			
			    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
			
			    const 更新边界 = (x, y) => {
			        minX = Math.min(minX, x);
			        minY = Math.min(minY, y);
			        maxX = Math.max(maxX, x);
			        maxY = Math.max(maxY, y);
			    };
			
			    if (楼层数据.房间列表) {
			        楼层数据.房间列表.forEach(房间 => {
			            if (房间) {
			                更新边界(房间.x, 房间.y);
			                更新边界(房间.x + 房间.w - 1, 房间.y + 房间.h - 1);
			            }
			        });
			    }
			
			    if (楼层数据.序列化地牢格子) {
			        楼层数据.序列化地牢格子.forEach((row, y) => {
			            row.forEach((cellData, x) => {
			                if (cellData && cellData.背景类型 === 2) { 
			                    更新边界(x, y);
			                }
			            });
			        });
			    }
			
			    if (minX === Infinity) {
			        小地图Ctx.fillStyle = "#000";
			        小地图Ctx.fillRect(0, 0, 小地图.width, 小地图.height);
			        小地图Ctx.fillStyle = "#555";
			        小地图Ctx.font = "20px Arial";
			        小地图Ctx.textAlign = "center";
			        小地图Ctx.textBaseline = "middle";
			        小地图Ctx.fillText("无地图数据", 小地图.width / 2, 小地图.height / 2);
			        return;
			    }
			
			    const mapWidth = maxX - minX + 1;
			    const mapHeight = maxY - minY + 1;
			    const padding = 10;
			
			    const 缩放比例 = Math.min(
			        (小地图.width - padding * 2) / mapWidth,
			        (小地图.height - padding * 2) / mapHeight
			    );
			
			    const offsetX = (小地图.width - mapWidth * 缩放比例) / 2;
			    const offsetY = (小地图.height - mapHeight * 缩放比例) / 2;
			
			    小地图Ctx.fillStyle = "#1a1a1a";
			    小地图Ctx.fillRect(0, 0, 小地图.width, 小地图.height);
			    
			    小地图Ctx.strokeStyle = "#666666";
			    小地图Ctx.lineWidth = 0.5;
			    if (楼层数据.序列化地牢格子) {
			        楼层数据.序列化地牢格子.forEach((row, y) => {
			            row.forEach((cellData, x) => {
			                if (cellData && cellData.背景类型 === 单元格类型.走廊) { 
			                    const drawX = (x - minX) * 缩放比例 + offsetX;
			                    const drawY = (y - minY) * 缩放比例 + offsetY;
			                    小地图Ctx.strokeRect(drawX, drawY, 缩放比例, 缩放比例);
			                }
			            });
			        });
			    }
			
			    if (楼层数据.房间列表) {
			        楼层数据.房间列表.forEach(房间 => {
			            if (!房间) return;
			            const 是上锁房间 = 楼层数据.上锁房间列表?.some(r => r.id === 房间.id);
			            
			            小地图Ctx.strokeStyle = 是上锁房间 ? "#FFD700" : "#4caf50";
			            小地图Ctx.lineWidth = 1;
			
			            const drawX = (房间.x - minX) * 缩放比例 + offsetX;
			            const drawY = (房间.y - minY) * 缩放比例 + offsetY;
			            const drawW = 房间.w * 缩放比例;
			            const drawH = 房间.h * 缩放比例;
			
			            小地图Ctx.strokeRect(drawX, drawY, drawW, drawH);
			            小地图Ctx.fillStyle = "#4caf5022";
			            小地图Ctx.fillRect(drawX, drawY, drawW, drawH);
			        });
			    }
			    
			    if (楼层数据.序列化地上物品) {
			        楼层数据.序列化地上物品.forEach(itemData => {
			            if (itemData && itemData.类名 === '旗帜') {
			                const 物品配置 = itemData.配置;
			                小地图Ctx.fillStyle = "#FFD700";
			                小地图Ctx.font = `${缩放比例 * 2}px color-emoji`;
			                小地图Ctx.textAlign = "center";
			                小地图Ctx.textBaseline = "middle";
			                小地图Ctx.fillText(物品配置.图标, (物品配置.x - minX) * 缩放比例 + offsetX + (缩放比例 / 2), (物品配置.y - minY) * 缩放比例 + offsetY + (缩放比例 / 2));
			            }
			        });
			    }
			
			    const 玩家起始点 = 楼层数据.玩家初始位置 || {x: 50, y: 50};
			    if (玩家起始点) {
			        小地图Ctx.fillStyle = "#ff0000";
			        小地图Ctx.beginPath();
			        小地图Ctx.arc(
			            (玩家起始点.x - minX) * 缩放比例 + offsetX,
			            (玩家起始点.y - minY) * 缩放比例 + offsetY,
			            Math.max(2, 缩放比例 * 0.75),
			            0,
			            Math.PI * 2
			        );
			        小地图Ctx.fill();
			        小地图Ctx.strokeStyle = "#ffffff";
			        小地图Ctx.lineWidth = 0.5;
			        小地图Ctx.stroke();
			    }
			}
			function 隐藏关卡详情() {
			    const 详情界面 = document.getElementById('关卡详情界面');
			    const 左侧 = document.getElementById('关卡详情_左侧');
			    const 右侧 = document.getElementById('关卡详情_右侧');
			    const 返回浏览器按钮 = document.getElementById('返回浏览器按钮');
			    if (typeof gsap === 'undefined') {
			        详情界面.style.display = 'none';
			        当前加载的关卡数据缓存 = null;
			        return;
			    }
			    gsap.to([左侧, 右侧, 返回浏览器按钮], { 
			        autoAlpha: 0, 
			        y: 10, 
			        duration: 0.3, 
			        ease: 'power2.in' 
			    });
			    
			    gsap.to(详情界面, {
			        autoAlpha: 0,
			        duration: 0.4,
			        ease: "power2.in",
			        onComplete: () => {
			详情界面.style.display = 'none';
			当前加载的关卡数据缓存 = null;
			        }
			    });
			}
			
			async function 点赞或点踩(关卡ID, 操作类型) {
			    const 投票记录键 = `voted_${关卡ID}`;
			    if (localStorage.getItem(投票记录键)) {
			        显示通知("你已经对这个关卡投过票了！", "警告");
			        return;
			    }
			
			    try {
			        const rpc名称 = 操作类型 === 'likes' ? 'increment_likes' : 'increment_dislikes';
			        const { error } = await supabase.rpc(rpc名称, {
			            level_id_to_increment: 关卡ID
			        });
			
			        if (error) throw error;
			        
			        localStorage.setItem(投票记录键, 'true');
			        显示通知("投票成功！", "成功");
			
			        const 计数元素 = document.getElementById(操作类型 === 'likes' ? '详情_赞' : '详情_踩');
			        const [图标, 旧计数值] = 计数元素.textContent.split(' ');
			        计数元素.textContent = `${图标} ${parseInt(旧计数值) + 1}`;
			
			    } catch (error) {
			        console.error('投票失败:', error);
			        显示通知('投票失败: ' + error.message, '错误');
			    }
			}
			
			            async function 删除关卡(关卡ID) {
			    const 密码 = prompt("请输入你上传时设置的删除密码：");
			    if (密码 === null) return;
			    if (密码.trim() === "") {
			        显示通知("密码不能为空！", "错误");
			        return;
			    }
			
			    try {
			        显示通知("正在验证密码...", "信息");
			        const { data: fileUrl, error: rpcError } = await supabase.rpc('verify_level_password_and_get_url', {
			            level_id_to_check: 关卡ID,
			            password_to_check: 密码
			        });
			
			        if (rpcError) throw rpcError;
			
			        if (fileUrl === 'LEVEL_NOT_FOUND' || fileUrl === 'PASSWORD_INCORRECT' || !fileUrl) {
			            显示通知("删除失败：密码错误或关卡不存在。", '错误');
			            return;
			        }
			        
			        显示通知("正在从存储中删除文件...", "信息");
			        const filePath = fileUrl.split('/levels/')[1];
			        const { error: storageError } = await supabase.storage.from('levels').remove([filePath]);
			
			        if (storageError) {
			            console.error("存储文件删除失败:", storageError);
			            throw new Error("存储文件删除失败: " + storageError.message);
			        }
			
			        显示通知("正在删除数据库记录...", "信息");
			        const { error: dbError } = await supabase
			            .from('levels')
			            .delete()
			            .match({ id: 关卡ID });
			
			        if (dbError) throw dbError;
			
			        显示通知('关卡已成功删除！', '成功');
			        隐藏关卡详情();
			        刷新关卡列表();
			
			    } catch (error) {
			        console.error('删除关卡时出错:', error);
			        显示通知('删除关卡时出错: ' + error.message, '错误');
			    }
			}
			
			
			function 显示胜利界面() {
			    if (游戏状态 === '图鉴') return;
			
			    const 是编辑器游玩模式 = 游戏状态 === '编辑器游玩';
			    游戏状态 = "胜利";
			    if (是否是自定义关卡 && 当前关卡ID) {
			        supabase.rpc('increment_clearances', { level_id_to_increment: 当前关卡ID }).then(({ error }) => {
			            if (error) console.error('增加通关次数失败:', error);
			        });
			    }
			
			    const 胜利遮罩 = document.createElement("div");
			    胜利遮罩.id = "死亡遮罩";
			    胜利遮罩.style.background = 'linear-gradient(45deg, rgba(0, 20, 0, 0.9) 0%, rgba(0, 60, 0, 0.95) 100%)';
			
			    let 按钮HTML = ``;
			    if (是编辑器游玩模式 && !临时测试) {
			        按钮HTML = `
			            <button class="重生按钮" id="返回编辑器按钮_胜利界面" style="border-color: #ffd700;">返回编辑器</button>
			            <button class="重生按钮" id="发布关卡按钮" style="border-color: #4caf50;">发布关卡</button>
			        `;
			    } else {
			         按钮HTML = `<button class="重生按钮" id="返回主菜单按钮_胜利" style="border-color: #ffd700;">返回主菜单</button>`;
			    }
			        
			    胜利遮罩.innerHTML = `
			        <div class="死亡内容容器" style="border-color: #ffd700;">
			            <div class="骷髅容器">
			                <div class="动态骷髅" style="text-shadow: 0 0 30px #ffd700; animation: none;">🏆</div>
			            </div>
			            <h2 style="color: #ffd700; text-shadow: 0 0 10px #ffd700;">胜利！</h2>
			            <div class="重生选项" style="flex-direction: row; gap: 15px;">
			                ${按钮HTML}
			            </div>
			        </div>
			    `;
			    
			    if (是编辑器游玩模式) {
			        document.getElementById('返回编辑器按钮').style.display = 'none';
			        胜利遮罩.querySelector("#返回编辑器按钮_胜利界面").addEventListener("click", () => {
			            胜利遮罩.remove();
			            返回编辑器模式(); 
			        });
			        胜利遮罩.querySelector("#发布关卡按钮").addEventListener("click", () => {
			            发布关卡();
			            胜利遮罩.remove();
			            返回编辑器模式();
			        });
			    } else {
			        胜利遮罩.querySelector("#返回主菜单按钮_胜利").addEventListener("click", () => {
			            胜利遮罩.remove();
			            
			            重置所有游戏状态();
			            显示主菜单();
			        });
			    }
			
			    document.body.appendChild(胜利遮罩);
			}
			
			function 切换编辑器工具栏模式() {
			    const 模式顺序 = ['常显', '常隐'];
			    const 当前索引 = 模式顺序.indexOf(编辑器工具栏模式);
			    编辑器工具栏模式 = 模式顺序[(当前索引 + 1) % 模式顺序.length];
			    应用编辑器工具栏模式();
			    显示通知(`工具栏模式: ${编辑器工具栏模式}`, '信息');
			}
			
			function 应用编辑器工具栏模式() {
			    const 工具栏 = document.getElementById('编辑器工具栏');
			    const 笔刷栏 = document.getElementById('笔刷工具容器');
			    
			    const 切换按钮 = document.getElementById('hudToggle');
			    
			    const 图标 = {  '常显': '👁️', '常隐': '😑' };
			    切换按钮.textContent = 图标[编辑器工具栏模式];
			
			    
			    
			    const hideToolbar = () => {
			        工具栏.style.opacity = '0';
			        工具栏.style.pointerEvents = 'none';
			        笔刷栏.style.opacity = '0';
			        笔刷栏.style.pointerEvents = 'none';
			    };
			
			    const showToolbar = () => {
			        工具栏.style.opacity = '1';
			        工具栏.style.pointerEvents = 'auto';
			        笔刷栏.style.opacity = '1';
			        笔刷栏.style.pointerEvents = 'auto';
			    };
			
			    if (编辑器工具栏模式 === '常显') {
			        showToolbar();
			        工具栏.onmouseenter = null;
			        工具栏.onmouseleave = null;
			    } else if (编辑器工具栏模式 === '常隐') {
			        hideToolbar();
			        工具栏.onmouseenter = null;
			        工具栏.onmouseleave = null;
			    } 
			}
			function 编辑器鼠标按下处理(e) { 编辑器画布事件处理(e.clientX, e.clientY, 'start', e); }
			function 编辑器鼠标移动处理(e) { 编辑器画布事件处理(e.clientX, e.clientY, 'move', e); }
			function 编辑器鼠标抬起处理(e) { 编辑器画布事件处理(e.clientX, e.clientY, 'end', e); }
			function 编辑器触摸开始处理(e) { const touch = e.touches[0]; 编辑器画布事件处理(touch.clientX, touch.clientY, 'start', e); }
			function 编辑器触摸移动处理(e) { const touch = e.touches[0]; 编辑器画布事件处理(touch.clientX, touch.clientY, 'move', e); }
			function 编辑器触摸结束处理(e) { const touch = e.changedTouches[0]; 编辑器画布事件处理(touch.clientX, touch.clientY, 'end', e); }
			function 进入地图编辑器() {
			    document.getElementById("全局设置窗口").style.display = 'none';
			    游戏状态 = "地图编辑器";
			    document.body.classList.add("地图编辑器模式");
			    document.body.classList.remove("游戏进行中", "编辑器游玩模式");
			    隐藏主菜单();
			
			    重置所有游戏状态();
			    
			    游戏状态 = "地图编辑器";
			    最高教程阶段 = 6;
			    document.body.classList.add("地图编辑器模式");
			
			    地牢 = Array(地牢大小).fill().map((_, y) => Array(地牢大小).fill().map((_, x) => new 单元格(x, y)));
			    
			    当前层数 = -1; 
			    玩家初始位置 = { x: Math.floor(地牢大小 / 2), y: Math.floor(地牢大小 / 2) };
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			
			    初始化canvas();
			    if(已初始化 > 0) 初始化装备系统();
			    if(已初始化 > 0) 初始化背包事件监听();
			    初始化编辑器工具栏();
			    应用编辑器工具栏模式();
			    
			    获取所有可用的定义(); 
			    
			    玩家背包.clear(); 
			    填充编辑器背包();
			    
			    const canvasElement = document.getElementById('dungeonCanvas');
			    //canvas.removeEventListener("touchstart", 处理地图点击);
			    canvas.removeEventListener("click", 处理地图单击);
			
			    canvas.addEventListener('mousedown', 编辑器鼠标按下处理);
			    canvas.addEventListener('mousemove', 编辑器鼠标移动处理);
			    canvas.addEventListener('mouseup', 编辑器鼠标抬起处理);
			    canvas.addEventListener('touchstart', 编辑器触摸开始处理);
			    canvas.addEventListener('touchmove', 编辑器触摸移动处理);
			    canvas.addEventListener('touchend', 编辑器触摸结束处理);
			    canvas.addEventListener('contextmenu', 编辑器右键处理);
			
			    更新视口();
			    生成怪物引入计划();
			    const 初始房间大小 = 10;
const 房间起始X = Math.floor(玩家初始位置.x - 初始房间大小 / 2);
const 房间起始Y = Math.floor(玩家初始位置.y - 初始房间大小 / 2);
const 初始房间 = {
    x: 房间起始X, y: 房间起始Y, w: 初始房间大小, h: 初始房间大小,
    id: 0, 名称: '房间_0', 类型: '房间', 已探索: true, 门: []
};
房间列表.push(初始房间);
房间列表.sort((a,b)=>a.id-b.id)
放置房间(初始房间);
生成墙壁();
//已访问房间.add(0);
			    绘制小地图();
			    if(已初始化 > 0) 动画帧();
			    
			    saveEditorState();
			    updateUndoRedoButtons();
			    显示通知("已进入地图编辑器", "信息");
			}
			function 初始化编辑器工具栏() {
			    const 工具栏 = document.getElementById("编辑器工具栏");
			    工具栏.style.display = 'flex';
			
			    document.getElementById('全局设置按钮').onclick = 打开全局设置窗口;
			    document.getElementById('编辑器撤回按钮').onclick = undoEditorAction;
			    document.getElementById('编辑器重做按钮').onclick = redoEditorAction;
			    
			    
			    document.getElementById('编辑器游玩按钮').onclick = 进入编辑器游玩模式;
			    document.getElementById('返回编辑器按钮').onclick = 返回编辑器模式;

				const 笔刷工具容器 = document.getElementById('笔刷工具容器');
				const 笔刷设置容器 = document.getElementById('笔刷设置容器');
				const 工具选择 = document.getElementById('编辑器工具选择');
				const 形状选择 = document.getElementById('笔刷形状选择');
				const 尺寸滑块 = document.getElementById('笔刷尺寸滑块');
				const 尺寸值 = document.getElementById('笔刷尺寸值');

				工具选择.onchange = () => {
					编辑器状态.笔刷模式 = 工具选择.value;
					笔刷设置容器.style.display = (编辑器状态.笔刷模式 === '笔刷') ? 'flex' : 'none';
				};

				形状选择.onchange = () => {
					编辑器状态.笔刷形状 = 形状选择.value;
				};

				尺寸滑块.oninput = () => {
					编辑器状态.笔刷半径 = parseInt(尺寸滑块.value);
					尺寸值.textContent = 尺寸滑块.value;
				};
			}
			let 编辑器状态备份 = null;
			let 编辑器玩家 = {...玩家};
			
			function saveEditorState() {
			    const currentState = 导出地图();
			    if (undoStack.length > 0 && undoStack[undoStack.length - 1] === currentState) {
			        return;
			    }
			    undoStack.push(currentState);
			    if (undoStack.length > MAX_UNDO_STEPS) {
			        undoStack.shift();
			    }
			    redoStack = [];
			    updateUndoRedoButtons();
			}
			
			function undoEditorAction() {
			    if (undoStack.length <= 1) {
			        显示通知("没有更多可撤回的操作", "警告");
			        return;
			    }
			    
			    const currentState = undoStack.pop();
			    redoStack.push(currentState);
			    编辑器玩家 = {...玩家}
			    
			    const previousState = undoStack[undoStack.length - 1];
			    导入地图(previousState);
			    
			    updateUndoRedoButtons();
			    玩家.x=编辑器玩家.x
			    玩家.y=编辑器玩家.y
			    更新视口(true)
			}
			
			function redoEditorAction() {
			    if (redoStack.length === 0) {
			        显示通知("没有可重做的操作", "警告");
			        return;
			    }
			    
			    const nextState = redoStack.pop();
			    undoStack.push(nextState);
			    let 编辑器玩家 = {...玩家}
			    导入地图(nextState);
			    玩家.x=编辑器玩家.x
			    玩家.y=编辑器玩家.y
			    更新视口(true)
			    updateUndoRedoButtons();
			}
			
			function updateUndoRedoButtons() {
			    const undoButton = document.getElementById('编辑器撤回按钮');
			    const redoButton = document.getElementById('编辑器重做按钮');
			    if(undoButton) undoButton.disabled = undoStack.length <= 1;
			    if(redoButton) redoButton.disabled = redoStack.length === 0;
			}
			
			            function generateDungeonTemplate() {
			    const levelInput = prompt("请输入要生成的模板地牢层数 (例如: 3):", "3");
			    if (levelInput === null) return;
			    
			    const levelNumber = parseInt(levelInput);
			    if (isNaN(levelNumber) || levelNumber < 0) {
			        显示通知("请输入一个有效的非负整数层数！", "错误");
			        return;
			    }
			
			    if (!confirm(`确定要生成第 ${levelNumber} 层的模板吗？这将覆盖当前编辑器中的所有内容。`)) {
			        return;
			    }
			
			    saveEditorState();
			    
			    重置所有游戏状态();
			    游戏状态 = '游戏中';
			    当前层数 = levelNumber;
			    if (当前层数 === 5) {
			            //初始化随机数生成器(当前游戏种子);
			            生成迷宫关卡();
			        } else if (当前层数 === 10) {
			            //初始化随机数生成器(当前游戏种子);
			            生成法师图书馆();
			        } else if (当前层数 === 15) {
			            //初始化随机数生成器(当前游戏种子);
			            生成最终首领楼层();
			        } else {
			    生成地牢();
			    //更新洞穴视野();
			    }
			    
			    const 初始房间 = 房间列表.find(r => r.id === 0);
			    if (初始房间) {
			        初始房间.已探索 = true;
			    }
			
			    let 胜利旗帜位置 = null;
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const cell = 地牢[y][x];
			            if (cell.关联物品 && (cell.类型 === 单元格类型.楼梯下楼 || cell.类型 === 单元格类型.楼梯上楼)) {
			                if (cell.类型 === 单元格类型.楼梯下楼) {
			                    胜利旗帜位置 = {x, y};
			                }
			                cell.关联物品 = null;
			                cell.类型 = null;
			            } else if (cell.关联物品 instanceof 寻宝戒指) {
			                cell.关联物品.自定义数据.set('生效层数',-1);
			            } else if (cell.关联物品 instanceof 隐形虫洞陷阱) {
			                cell.关联物品 = null;
			                cell.类型 = null;
			                
			            } else if (cell.关联物品 instanceof 配方卷轴) {
			                cell.关联物品 = null;
			                cell.类型 = null;
			                
			            } else if (cell.关联物品 instanceof 召唤怪物陷阱) {
			                cell.关联物品.自定义数据.set('怪物层级',当前层数);
			            } else if (cell.关联物品 instanceof 钥匙) {
			                cell.关联物品.自定义数据.set('地牢层数',-1);
			            } else if (cell.关联物品 instanceof 神秘商人) {
			                cell.关联物品.自定义数据.set('商品层数',当前层数);
			                cell.关联物品.生成库存(Math.max(cell.关联物品.自定义数据.get('商品层数'), 0));
			            } else if (cell.关联物品 instanceof 探险家) {
			                cell.关联物品.自定义数据.set('需求层数',当前层数);
			                cell.关联物品.生成收购需求(cell.关联物品.自定义数据.get('需求层数'));
			            }
			        }
			    }
			    if (胜利旗帜位置) {
			        放置物品到单元格(new 旗帜(), 胜利旗帜位置.x, 胜利旗帜位置.y);
			    }
			
			    生成并放置随机配方卷轴(当前层数);
			    
			    游戏状态 = '地图编辑器';
			    当前层数 = -1;
			    处理房间状态();
			    更新编辑器快速访问栏();
			    
			    填充编辑器背包();
			    绘制小地图();
			
			    更新视口();
			    
			    saveEditorState();
			    显示通知(`已生成第 ${levelNumber} 层地牢模板。`, '成功');
			}
			function 返回编辑器模式() {
			    游戏状态 = '地图编辑器';
			    if (编辑器状态备份) {
			        编辑器玩家 = {...玩家}
			        导入地图(编辑器状态备份);
			        if (位置是否可用(编辑器玩家.x,编辑器玩家.y,false)) {
			        玩家.x=编辑器玩家.x
			        玩家.y=编辑器玩家.y
			        }
			        更新视口()
			        编辑器状态备份 = null;
			    }
			    临时测试 = false;
			    
			    编辑器状态.模式 = '编辑';
			    document.body.classList.add('地图编辑器模式');
			    document.body.classList.remove('游戏进行中');
			    document.body.classList.remove('编辑器游玩模式');
			    document.getElementById('编辑器工具栏').style.display = 'flex';
			   
			    document.getElementById('返回编辑器按钮').style.display = 'none';
			    应用编辑器工具栏模式();
			
			    //canvas.removeEventListener("touchstart", 处理地图点击);
			    canvas.removeEventListener("click", 处理地图单击);
			
			    canvas.addEventListener('mousedown', 编辑器鼠标按下处理);
			    canvas.addEventListener('mousemove', 编辑器鼠标移动处理);
			    canvas.addEventListener('mouseup', 编辑器鼠标抬起处理);
			    canvas.addEventListener('touchstart', 编辑器触摸开始处理);
			    canvas.addEventListener('touchmove', 编辑器触摸移动处理);
			    canvas.addEventListener('touchend', 编辑器触摸结束处理);
			    canvas.addEventListener('contextmenu', 编辑器右键处理);
			
			    玩家背包.clear();
			    填充编辑器背包();
			    
			    更新编辑器快速访问栏();
			
			    绘制();
			    
			}
			
			function 创建并放置房间(起始横坐标, 起始纵坐标, 结束横坐标, 结束纵坐标) {
			    const 左上角横坐标 = Math.min(起始横坐标, 结束横坐标);
			    const 左上角纵坐标 = Math.min(起始纵坐标, 结束纵坐标);
			    const 宽度 = Math.abs(起始横坐标 - 结束横坐标) + 1;
			    const 高度 = Math.abs(起始纵坐标 - 结束纵坐标) + 1;
			
			    for(let 纵坐标=左上角纵坐标; 纵坐标 < 左上角纵坐标 + 高度; 纵坐标++) {
			        for(let 横坐标=左上角横坐标; 横坐标 < 左上角横坐标 + 宽度; 横坐标++) {
			            if (房间地图[纵坐标]?.[横坐标] !== -1 && 房间地图[纵坐标]?.[横坐标] !== undefined) {
			                显示通知("无法创建房间，与其他房间重叠！", "错误");
			                return;
			            }
			        }
			    }
			
			    let 新ID = 房间列表.length
			    
			        let i = 0
			        while(房间列表.some(item=>item.id==房间列表.length+i)) {
			        i++;
			        
			        }
			        新ID=房间列表.length+i
			    
			    
			    const 新房间 = {
			        x: 左上角横坐标, y: 左上角纵坐标,
			        w: 宽度,
			        h: 高度,
			        id: 新ID,
			        名称: `房间_${新ID}`,
			        类型: '房间',
			        已探索: false,
			        门: []
			    };
			
			    for(let 纵坐标 = 左上角纵坐标; 纵坐标 < 左上角纵坐标 + 高度; 纵坐标++) {
			        for(let 横坐标 = 左上角横坐标; 横坐标 < 左上角横坐标 + 宽度; 横坐标++) {
			            地牢[纵坐标][横坐标].背景类型 = 单元格类型.房间;
			            
			            房间地图[纵坐标][横坐标] = 新ID;
			        }
			    }
			    房间列表[新ID] = 新房间;
			   
			    const 边缘格子列表 = [];
			    for (let 纵坐标 = 左上角纵坐标; 纵坐标 < 左上角纵坐标 + 高度; 纵坐标++) {
			        for (let 横坐标 = 左上角横坐标; 横坐标 < 左上角横坐标 + 宽度; 横坐标++) {
			            if (横坐标 === 左上角横坐标 || 横坐标 === 左上角横坐标 + 宽度 - 1 || 纵坐标 === 左上角纵坐标 || 纵坐标 === 左上角纵坐标 + 高度 - 1) {
			                边缘格子列表.push({x: 横坐标, y: 纵坐标});
			            }
			        }
			    }
			    
			    for(const 格子坐标 of 边缘格子列表) {
			        const 方向列表 = [{dx:0, dy:-1}, {dx:0, dy:1}, {dx:-1, dy:0}, {dx:1, dy:0}];
			        for (const 方向 of 方向列表) {
			            const 邻居横坐标 = 格子坐标.x + 方向.dx;
			            const 邻居纵坐标 = 格子坐标.y + 方向.dy;
			            
			            
			            if (邻居横坐标 < 0 || 邻居横坐标 >= 地牢大小 || 邻居纵坐标 < 0 || 邻居纵坐标 >= 地牢大小) continue;
			            
			            const 邻居单元格 = 地牢[邻居纵坐标][邻居横坐标];
			            
			            
			            if (邻居单元格 && (邻居单元格.背景类型 === 单元格类型.门 || 邻居单元格.背景类型 === 单元格类型.上锁的门)) {
			                const 门实例 = 门实例列表.get(邻居单元格.标识);
			                
			                if (门实例) {
			                    // 1. 将门关联到新房间
			                    门实例.房间ID = 新房间.id;
			                    
			                    // 2. 将门添加到新房间的门列表中（防止重复）
			                    if (!新房间.门.some(门位置 => 门位置.x === 邻居横坐标 && 门位置.y === 邻居纵坐标)) {
			                        新房间.门.push({x: 邻居横坐标, y: 邻居纵坐标});
			                    }
			                    
			                    // 3. 同步属性
			                    const 是否房间已上锁 = 上锁房间列表.some(房间 => 房间.id === 新房间.id);
			                    const 房间颜色索引 = 是否房间已上锁 ? 上锁房间列表.find(房间 => 房间.id === 新房间.id).颜色索引 : 颜色表.length;
			
			                    邻居单元格.背景类型 = 是否房间已上锁 ? 单元格类型.上锁的门 : 单元格类型.门;
			                    门实例.是否上锁 = 是否房间已上锁;
			                    
			                    // 同步颜色索引
			                    邻居单元格.颜色索引 = 房间颜色索引;
			                }
			            }
			    
			        }
			    }
			   
			
			    生成墙壁();
			    绘制();
			    打开属性编辑器(新房间, 左上角横坐标, 左上角纵坐标);
			}
			
			function 填充编辑器背包() {
			    const 容器 = document.getElementById("背包物品栏");
			    const 弹窗 = document.querySelector(".背包弹窗");
			    
			    容器.innerHTML = "";
			    玩家背包.clear(); 
			    
			    const { items: allItems, monsters: allMonsters } = 获取所有可用的定义();
			
			    const 分区 = {
			        '工具': [],
			        '背景': [],
			        '物品': [],
			        '怪物': []
			    };
			
			    const 工具和地形 = [
			        { 名称: '手形/编辑', 类型: '工具', 图标: 图标映射.手形 },
			        { 名称: '删除工具', 类型: '工具', 图标: 图标映射.删除 },
			        { 名称: '房间工具', 类型: '工具', 图标: 图标映射.房间工具 },
			        { 名称: '复制工具', 类型: '工具', 图标: 图标映射.复制工具 },
			        { 名称: '房间编辑工具', 类型: '工具', 图标: 图标映射.房间编辑 },
			        { 名称: '扳手', 类型: '工具', 图标: 图标映射.扳手 },
			        { 名称: '房间地板', 类型: '背景', 绘制类型: 单元格类型.房间, 图标: 图标映射.地板 },
			        { 名称: '走廊', 类型: '背景', 绘制类型: 单元格类型.走廊, 图标: 图标映射.走廊 },
			        { 名称: '墙壁', 类型: '背景', 绘制类型: 单元格类型.墙壁, 图标: 图标映射.墙壁 },
			        { 名称: '门', 类型: '背景', 绘制类型: 单元格类型.门, 图标: 图标映射.门 },
			        { 名称: '上锁的门', 类型: '背景', 绘制类型: 单元格类型.上锁的门, 图标: 图标映射.锁 },
			        { 名称: '卷轴滚动墙', 类型: '物品', 图标: 图标映射.卷轴滚动墙, 类: 卷轴滚动墙 },
			        { 名称: '刷怪笼', 类型: '物品', 类: 刷怪笼, 图标: 图标映射.刷怪笼 },
			        { 名称: '传送带', 类型: '物品', 类: 传送带, 图标: 图标映射.传送带 },
			        { 名称: '红蓝开关', 类型: '物品', 类: 红蓝开关, 图标: 图标映射.红蓝开关},
			        { 名称: '红砖块', 类型: '物品', 类: 红砖块, 图标: 图标映射.红砖块},
			        { 名称: '蓝砖块', 类型: '物品', 类: 蓝砖块, 图标: 图标映射.蓝砖块},
			        { 名称: '绿紫开关', 类型: '物品', 类: 绿紫开关, 图标: 图标映射.绿紫开关 },
			        { 名称: '绿砖块', 类型: '物品', 类: 绿砖块, 图标: 图标映射.绿砖块 },
			        { 名称: '紫砖块', 类型: '物品', 类: 紫砖块, 图标: 图标映射.紫砖块 },
			        { 名称: '开关脉冲器', 类型: '物品', 图标: 图标映射.开关脉冲器, 类: 开关脉冲器 },
			        { 名称: '钥匙', 类型: '物品', 类: 钥匙,默认配置:{地牢层数:-1} },
			        { 名称: '胜利旗帜', 类型: '物品', 图标: 图标映射.旗帜, 类: 旗帜 },
			        { 名称: '告示牌', 类型: '物品', 图标: 图标映射.告示牌, 类: 告示牌 },
			        { 名称: '存档点', 类型: '物品', 图标: 图标映射.存档点, 类: 存档点 },
			        { 名称: '传送门', 类型: '物品', 图标: 图标映射.传送门, 类: 传送门 },
			        { 名称: '沉浸式传送门', 类型: '物品', 类: 沉浸式传送门, 图标: 图标映射.沉浸式传送门 },
			    ];
			
			    分区.工具.push(...工具和地形.filter(t => t.类型 === '工具'));
			    分区.背景.push(...工具和地形.filter(t => t.类型 === '背景'));
			    分区.物品.push(...工具和地形.filter(t => t.类型 === '物品'));
			    分区.物品.push(...allItems.filter(item => item.类.name !== '隐形虫洞陷阱' && item.类.name !== '配方卷轴'));
			    分区.怪物.push(...allMonsters);
			    分区.怪物.push({ 类: 巡逻怪物 }, { 类: 同步怪物 });
			    
			    Object.keys(分区).forEach(分区名 => {
			        const 分区标题 = document.createElement('h4');
			        分区标题.textContent = 分区名;
			        分区标题.style.cssText = "width: 100%; text-align: center; color: #4caf50; border-bottom: 1px solid #4caf50; margin: 10px 0; padding-bottom: 5px;";
			        容器.appendChild(分区标题);
			
			        const addedNames = new Set();
			        分区[分区名].forEach(def => {
			let 实例;
			let itemElem;
			let isVirtual = false;
			let itemName;
			if (def.类型 === '背景' || def.类型 === '工具') {
			        实例 = { 
			        名称: def.名称, 
			        图标: def.图标, 
			        品质: 1, 
			        颜色索引: 5, 
			        获取名称: () => def.名称, 
			        显示图标: def.图标, 
			        类型: 分区名, 
			        绘制类型: def.绘制类型,
			        类: def.类,
			    };
			    itemName = def.名称;
			    isVirtual = true;
			} else if (分区名 === '怪物') {
			    实例 = new def.类({玩家放置:true});
			    itemName = 实例.类型;
			    实例.名称 = itemName;
			    isVirtual = false;
			} else {
			    
			    const Cls = def.类 || def;
			    
			    const 构造配置 = def.默认配置 || {};
			    实例 = new Cls(构造配置);
			    itemName = 实例.名称;
			    实例.堆叠数量 = 1;
			    if (实例 instanceof 卷轴类) {
			        实例.自定义数据.set('已解锁', true);
			    }
			    isVirtual = false;
			}
			
			if (!itemName || addedNames.has(itemName)) return;
			addedNames.add(itemName);
			
			if (isVirtual) {
			    if (def.类) {
			        实例 = new def.类({});
			        isVirtual = false;
			    }
			}
			
			if (isVirtual) {
			    itemElem = document.createElement('div');
			    itemElem.className = '物品条目 hover';
			    itemElem.innerHTML = `
			        <div class="物品图标" style="font-size: 2em; color: ${实例.颜色 || '#FFFFFF'};">${getIconHTML(实例.图标 || 实例.显示图标)}</div>
			        <div class="物品名称">${实例.名称 || 实例.获取名称()}</div>
			    `;
			} else if (实例 instanceof 怪物) {
			    itemElem = document.createElement('div');
			    itemElem.className = '物品条目 hover';
			    itemElem.innerHTML = `
			        <div class="物品图标" style="font-size: 2em; color: ${实例.颜色 || '#FFFFFF'};">${getIconHTML(实例.图标)}</div>
			        <div class="物品名称">${实例.类型}</div>
			    `;
			} else {
			        if (实例 && typeof 实例?.生成显示元素 === 'function') {
			        itemElem = 实例?.生成显示元素();
			        itemElem?.querySelectorAll('.装备按钮, .丢弃按钮, .使用按钮, .上屏按钮')?.forEach(btn => btn?.remove());
			    }
			}
			
			if (itemElem) {
			    itemElem.onclick = (e) => {
			        e.stopPropagation();
			        设置编辑器选中项(实例);
			        document.querySelectorAll('#背包物品栏 .物品条目').forEach(el => el.classList.remove('active'));
			        itemElem.classList.add('active');
			        显示通知(`已选中: ${实例.名称 || 实例.类型}`, '信息');
			    };
			
			    容器.appendChild(itemElem);
			}
			        });
			    });
			}
			function 推开生物(x, y) {
			    const 单元格 = 地牢[y]?.[x];
			    if (!单元格 || !单元格.关联怪物) return;
			
			    const 怪物 = 单元格.关联怪物;
			    const 方向 = [[0, -1], [0, 1], [-1, 0], [1, 0], [-1, -1], [1, -1], [-1, 1], [1, 1]];
			
			    for (const [dx, dy] of 方向) {
			        const 新X = x + dx;
			        const 新Y = y + dy;
			        const 目标单元格 = 地牢[新Y]?.[新X];
			        if (位置是否可用(新X,新Y,false)) {
			怪物.恢复背景类型();
			怪物.x = 新X;
			怪物.y = 新Y;
			怪物.处理地形效果()
			怪物.保存新位置类型(新X, 新Y);
			地牢[新Y][新X].类型 = 单元格类型.怪物;
			地牢[新Y][新X].关联怪物 = 怪物;
			添加日志(`${怪物.类型} 被砖块顶到了 (${新X}, ${新Y})!`, "信息");
			怪物动画状态.set(怪物, {
			    旧逻辑X: x,
			    旧逻辑Y: y,
			    目标逻辑X: 新X,
			    目标逻辑Y: 新Y,
			    视觉X: x,
			    视觉Y: y,
			    动画开始时间: Date.now(),
			    正在动画: true,
			});
			return;
			        }
			    }
			}
			function 更新所有门朝向() {
			    for (let 纵坐标 = 0; 纵坐标 < 地牢大小; 纵坐标++) {
			        for (let 横坐标 = 0; 横坐标 < 地牢大小; 横坐标++) {
			            const 单元格对象 = 地牢[纵坐标]?.[横坐标];
			            if (单元格对象 && (单元格对象.背景类型 === 单元格类型.门 || 单元格对象.背景类型 === 单元格类型.上锁的门)) {
			                let 方向 = 'NS'; 
			                const 左邻居可通行 = 地牢[纵坐标]?.[横坐标 - 1] && 地牢[纵坐标][横坐标 - 1].背景类型 !== 单元格类型.墙壁;
			                const 右邻居可通行 = 地牢[纵坐标]?.[横坐标 + 1] && 地牢[纵坐标][横坐标 + 1].背景类型 !== 单元格类型.墙壁;
			                if (左邻居可通行 && 右邻居可通行) {
			                    方向 = 'EW';
			                }
			                单元格对象.doorOrientation = 方向;
			            }
			        }
			    }
			}
			
			function 编辑器放置逻辑(横坐标, 纵坐标) {
			    if (编辑器状态.当前选中?.名称 === '房间编辑工具') {
			        const 房间标识 = 房间地图[纵坐标]?.[横坐标];
			        if (房间标识 !== -1 && 房间列表[房间标识]) {
			打开属性编辑器(房间列表[房间标识], 横坐标, 纵坐标);
			        } else {
			const 单元格对象 = 地牢[纵坐标]?.[横坐标];
			if (单元格对象) 打开属性编辑器(单元格对象, 横坐标, 纵坐标);
			        }
			        return;
			    }
			    const 选中项 = 编辑器状态.当前选中;
			    const 单元格对象 = 地牢[纵坐标]?.[横坐标];
			    if (!单元格对象) return;
			
			    if (!选中项 || 编辑器状态.模式 === '编辑') {
			        打开属性编辑器(单元格对象, 横坐标, 纵坐标);
			        return;
			    }
			
			    if (选中项.名称 === '删除工具') {
			        if (单元格对象.关联物品 || 单元格对象.关联怪物) {
			if (单元格对象.关联物品) {
			所有计时器 = 所有计时器.filter(计时器 => 计时器.唯一标识.toString() !== 单元格对象.关联物品?.唯一标识.toString());
			所有传送门 = 所有传送门.filter(item => item.唯一标识.toString() !== 单元格对象.关联物品?.唯一标识.toString());
			        if (单元格对象.关联物品.唯一标识 && 玩家背包.has(单元格对象.关联物品.唯一标识)) {
			        处理销毁物品(单元格对象.关联物品.唯一标识, true);
			        }
			        
			        单元格对象.关联物品 = null;
			}
			if (单元格对象.关联怪物) {
			    let 现有怪物=单元格对象.关联怪物
			    if (现有怪物 instanceof 蜈蚣怪物) {
			        现有怪物?.身体部位?.forEach(item=>{item.移除自身(true)})
			        现有怪物.移除自身()
			    } else if (现有怪物 instanceof 蜈蚣部位) {
			        现有怪物?.主体?.身体部位?.forEach(item=>{item.移除自身(true)})
			        现有怪物.主体?.移除自身()
			    }
			    所有怪物 = 所有怪物.filter(怪物 => 怪物 !== 单元格对象.关联怪物);
			    单元格对象.关联怪物 = null;
			}
			单元格对象.类型 = null;
			        } else {
			重置单元格(横坐标, 纵坐标);
			        }
			    } else {
			        const 现有怪物 = 单元格对象.关联怪物;
			        const 现有物品 = 单元格对象.关联物品;
			
			        const 是放置怪物 = 选中项 instanceof 怪物;
			        const 是放置物品或背景 = 选中项 instanceof 物品 || 选中项.类型 === '背景';
			        
			        if (是放置怪物) {
			if (现有怪物) {
			    if (现有怪物 instanceof 蜈蚣怪物) {
			        现有怪物?.身体部位?.forEach(item=>{item.移除自身(true)})
			        现有怪物.移除自身()
			    } else if (现有怪物 instanceof 蜈蚣部位) {
			        现有怪物?.主体?.身体部位?.forEach(item=>{item.移除自身(true)})
			        现有怪物.主体?.移除自身()
			    }
			    所有怪物 = 所有怪物.filter(怪物 => 怪物 !== 现有怪物);
			}
			if (现有物品 && 现有物品.阻碍怪物) {
			所有计时器 = 所有计时器.filter(计时器 => 计时器.唯一标识.toString() !== 单元格对象.关联物品?.唯一标识.toString());
			所有传送门 = 所有传送门.filter(item => item.唯一标识.toString() !== 单元格对象.关联物品?.唯一标识.toString());
			    单元格对象.关联物品 = null;
			    
			}
			单元格对象.关联怪物 = null;
			        } else if (是放置物品或背景) {
			if (现有怪物 && 选中项.阻碍怪物) {
			    所有怪物 = 所有怪物.filter(怪物 => 怪物 !== 现有怪物);
			    单元格对象.关联怪物 = null;
			    清除怪物 = true;
			}
			if (现有物品) {
			    所有计时器 = 所有计时器.filter(计时器 => 计时器.唯一标识.toString() !== 单元格对象.关联物品?.唯一标识.toString());
			    所有传送门 = 所有传送门.filter(item => item.唯一标识.toString() !== 单元格对象.关联物品?.唯一标识.toString());
			    单元格对象.关联物品 = null;
			    
			}
			        }
			
			        if (选中项.类型 === '背景') {
			if (编辑器状态.上次放置的背景) {
			    单元格对象.阻碍视野 = 编辑器状态.上次放置的背景.阻碍视野;
			    
			}
			编辑器状态.上次放置的背景 = 单元格对象;
			if ([单元格类型.门, 单元格类型.上锁的门].includes(单元格对象.背景类型) && 单元格对象.标识) {
			    const 门实例 = 门实例列表.get(单元格对象.标识);
			    if (门实例) {
			        if (门实例.房间ID !== null && 房间列表[门实例.房间ID]) {
			            const 房间 = 房间列表[门实例.房间ID];
			            房间.门 = 房间.门.filter(门坐标 => !(门坐标.x === 横坐标 && 门坐标.y === 纵坐标));
			        }
			        const 配对位置 = 单元格对象.配对单元格位置;
			        if (配对位置) {
			            const 配对单元格 = 地牢[配对位置.y]?.[配对位置.x];
			            if (配对单元格) {
			                    const 配对房间 = 房间列表[门实例.房间ID];
			                    if (配对房间) {
			                            配对房间.门 = 配对房间.门.filter(门坐标 => 
			                                !(门坐标.x === 配对位置.x && 门坐标.y === 配对位置.y)
			                            );
			                    }
			                    配对单元格.背景类型 = 单元格类型.墙壁;
			                    配对单元格.类型 = 单元格类型.墙壁;
			                    配对单元格.标识 = null;
			                    配对单元格.钥匙ID = null;
			                    配对单元格.配对单元格位置 = null;
			                    配对单元格.doorOrientation = null;
			            }
			        }
			        门实例列表.delete(单元格对象.标识);
			    }
			}
			单元格对象.背景类型 = 选中项.绘制类型;
			单元格对象.类型 = 选中项.绘制类型;
			所有计时器 = 所有计时器.filter(计时器 => 计时器.唯一标识.toString() !== 单元格对象.关联物品?.唯一标识.toString());
			所有传送门 = 所有传送门.filter(item => item.唯一标识.toString() !== 单元格对象.关联物品?.唯一标识.toString());
			单元格对象.关联物品 = null; 
			单元格对象.关联怪物 = null;
			if (选中项.绘制类型 === 单元格类型.门 || 选中项.绘制类型 === 单元格类型.上锁的门) {
			    let 方向 = 'NS'; 
			    const 左邻居可通行 = 地牢[纵坐标]?.[横坐标 - 1] && 地牢[纵坐标][横坐标 - 1].背景类型 !== 单元格类型.墙壁;
			    const 右邻居可通行 = 地牢[纵坐标]?.[横坐标 + 1] && 地牢[纵坐标][横坐标 + 1].背景类型 !== 单元格类型.墙壁;
			    if(左邻居可通行 && 右邻居可通行) {
			        方向 = 'EW';
			    }
			    单元格对象.doorOrientation = 方向;
			
			    const 最近房间 = 寻找最近的房间(横坐标, 纵坐标);
			    const 门实例 = new 门({ 关联房间ID: 最近房间 ? 最近房间.id : null, 位置: { x: 横坐标, y: 纵坐标 } });
			    if(选中项.绘制类型 === 单元格类型.上锁的门) {
			        门实例.是否上锁 = true;
			    }
			    单元格对象.标识 = 门实例.唯一标识;
			    单元格对象.钥匙ID = null;
			    门实例列表.set(门实例.唯一标识, 门实例);
			    if (最近房间) {
			        最近房间.门.push({ x: 横坐标, y: 纵坐标 });
			    }
			    if (选中项.绘制类型 === 单元格类型.上锁的门) {
			        单元格对象.颜色索引 = 0;
			    }
			} else {
			    单元格对象.标识 = null;
			    单元格对象.doorOrientation = null;
			}
			生成墙壁();
			更新所有门朝向();
			        } else if (选中项 instanceof 物品) {
			 let 实例;
			if (选中项 instanceof 传送带 && 上次放置的传送带) {
			    const 最后方向 = 上次放置的传送带.自定义数据.get('方向') || 'E';
			    实例 = new 传送带({ 数据: { 方向: 最后方向 } });
			} else if (选中项 instanceof 开关脉冲器 && 上次放置的开关脉冲器) {
			    const 冷却回合 = 上次放置的开关脉冲器.自定义数据.get('冷却回合') || 1;
			    实例 = new 开关脉冲器({ 方向: 冷却回合 });
			} else if (选中项 instanceof 沉浸式传送门){
			    实例 = new 沉浸式传送门({ 传送门ID:所有传送门.slice(-1)[0]?.自定义数据?.get('传送门ID')??0 });
			} else if (选中项 instanceof 隐形毒气陷阱 && 上次放置的隐形毒气陷阱) {
			    const id = 上次放置的隐形毒气陷阱.自定义数据.get('关联陷阱ID') || 0;
			    const 强度 = 上次放置的隐形毒气陷阱.自定义数据.get('中毒强度') || 0;
			    实例 = new 隐形毒气陷阱({ 关联陷阱ID: id,中毒强度:强度 });
			} else {
			    实例 = 克隆物品(选中项, { 玩家放置: true });
			}
			if (实例 instanceof 卷轴类) 实例.已解锁=false;
			
			if(放置物品到单元格(实例, 横坐标, 纵坐标,单元格类型.物品,false,true)) {
			    if(实例 instanceof 传送带) {
			        上次放置的传送带 = 实例;
			    }else if(实例 instanceof 隐形毒气陷阱) {
			        上次放置的隐形毒气陷阱 = 实例;
			    }
			}
			        } else if (是放置怪物) {
			const 实例 = new 选中项.constructor({x:横坐标,y:纵坐标});
			实例.状态 = 怪物状态.休眠;
			放置怪物到单元格(实例, 横坐标, 纵坐标);
			        }
			    }
			    
			}
			            function 寻找最近的房间(x, y) {
			    let 最近房间 = null;
			    let 最小距离 = Infinity;
			    房间列表.forEach(room => {
			        if (!room) return;
			        const 中心X = room.x + Math.floor(room.w / 2);
			        const 中心Y = room.y + Math.floor(room.h / 2);
			        const 距离 = Math.abs(x - 中心X) + Math.abs(y - 中心Y);
			        if (距离 < 最小距离) {
			            最小距离 = 距离;
			            最近房间 = room;
			        }
			    });
			    return 最近房间;
			}
			
			function 更新编辑器快速访问栏() {
			    for (let i = 1; i <= 装备栏每页装备数; i++) {
			        const 槽位 = document.getElementById(`装备槽${i}`);
			        if (!槽位) continue;
			        槽位.innerHTML = "";
			
			        const 物品实例 = 编辑器最近使用列表[i - 1];
			        if (物品实例) {
			            const isVirtual = !(物品实例 instanceof 物品) && !(物品实例 instanceof 怪物);
			            const 克隆元素 = document.createElement('div');
			            克隆元素.className = '物品条目';
			            克隆元素.innerHTML = `
			                <div class="物品图标" style="color: ${'#FFFFFF'};">${getIconHTML(物品实例.图标 || 物品实例.显示图标)}</div>
			                <div class="物品名称">${物品实例.名称 || 物品实例.类型}</div>
			            `;
			             const 图标元素 = 克隆元素.querySelector(".物品图标");
			            图标元素.style.fontSize = '2.5em';
			            if (!isVirtual) {
			                if (物品实例 instanceof 怪物) {
			                    图标元素.style.color = 物品实例.颜色 || '#FFFFFF'; 
			                    图标元素.style.textShadow = `0 0 8px ${物品实例.颜色 || '#FFFFFF'}`;
			                } else if (物品实例.颜色表) {
			                    图标元素.style.color = 物品实例.颜色表[物品实例.颜色索引];
			                    图标元素.style.textShadow = `0 0 8px ${物品实例.颜色表[物品实例.颜色索引]}`;
			                }
			            }
			            克隆元素.onclick = () => {
			                设置编辑器选中项(物品实例);
			                //显示通知(`已从快速访问栏选中: ${物品实例.名称 || 物品实例.获取名称()}`, '信息');
			            };
			            槽位.appendChild(克隆元素);
			        }
			    }
			}
			
			function 设置编辑器选中项(实例) {
			    if (编辑器状态.模式 === '传送') {
			        编辑器状态.模式 = '编辑';
			        const 互动按钮元素 = document.getElementById('互动按钮');
			        if(互动按钮元素) 互动按钮元素.style.background = '';
			    }
			    const 扳手菜单 = document.getElementById('扳手工具菜单');
	if (实例.名称 === '扳手') {
		扳手菜单.style.display = 'flex';
		//更新扳手菜单();
	} else {
		扳手菜单.style.display = 'none';
	}
			    if (实例.名称 === '手形/编辑') {
			        编辑器状态.当前选中 = null;
			        编辑器状态.模式 = '编辑';
					document.getElementById('笔刷工具容器').style.display = 'none';
					document.getElementById('扳手工具菜单').style.display = 'none';
			    } else {
			        编辑器状态.当前选中 = 实例;
			        编辑器状态.模式 = '绘制';
					if (实例.类型 === '背景') {
						document.getElementById('笔刷工具容器').style.display = 'flex';
					} else {
						document.getElementById('笔刷工具容器').style.display = 'none';
					}
			    }
			    
			    const 现有索引 = 编辑器最近使用列表.findIndex(item => (item.名称 || item.类型 || item.获取名称()) === (实例.名称 || 实例.类型 || 实例.获取名称()));
			    if (现有索引 !== -1) {
			        编辑器最近使用列表.splice(现有索引, 1);
			    }
			    编辑器最近使用列表.unshift(实例);
			    if (编辑器最近使用列表.length > 装备栏每页装备数) {
			        编辑器最近使用列表.pop();
			    }
			    更新编辑器快速访问栏();
			}
			function 更新扳手规则窗口() {
	const 容器 = document.getElementById('扳手规则容器');
	容器.innerHTML = '';
	const 操作列表 = [
		{值: '+', 文本: '+'}, {值: '-', 文本: '-'},
		{值: '*', 文本: '×'}, {值: '/', 文本: '÷'},
		{值: '=', 文本: '='}, {值: 'rand', 文本: '随机'},
	];
	扳手规则列表.forEach((规则, 索引) => {
		const 规则条目 = document.createElement('div');
		规则条目.className = '扳手规则条目';
		const 属性输入 = document.createElement('input');
		属性输入.type = 'text';
		属性输入.className = '属性输入';
		属性输入.placeholder = '自定义.耐久';
		属性输入.value = 规则.属性;
		属性输入.onchange = (e) => { 扳手规则列表[索引].属性 = e.target.value; };
		const 操作选择 = document.createElement('select');
		操作选择.className = '操作选择';
		操作列表.forEach(操作 => {
			const 选项 = document.createElement('option');
			选项.value = 操作.值;
			选项.textContent = 操作.文本;
			if (操作.值 === 规则.操作) 选项.selected = true;
			操作选择.appendChild(选项);
		});
		操作选择.onchange = (e) => {
			扳手规则列表[索引].操作 = e.target.value;
			更新扳手规则窗口();
		};
		const 数值输入容器 = document.createElement('div');
		数值输入容器.className = '数值输入';
		数值输入容器.style.display = 'flex';
		数值输入容器.style.gap = '2px';
		if (规则.操作 === 'rand') {
			const 输入1 = document.createElement('input');
			输入1.type = 'text';
			输入1.placeholder = '最小值';
			输入1.value = 规则.数值1 || '';
			输入1.onchange = (e) => { 扳手规则列表[索引].数值1 = e.target.value; };
			const 输入2 = document.createElement('input');
			输入2.type = 'text';
			输入2.placeholder = '最大值';
			输入2.value = 规则.数值2 || '';
			输入2.onchange = (e) => { 扳手规则列表[索引].数值2 = e.target.value; };
			数值输入容器.appendChild(输入1);
			数值输入容器.appendChild(输入2);
		} else {
			const 输入 = document.createElement('input');
			输入.type = 'text';
			输入.placeholder = '值 (true/false)';
			输入.value = 规则.数值1 || '';
			输入.onchange = (e) => { 扳手规则列表[索引].数值1 = e.target.value; };
			数值输入容器.appendChild(输入);
		}
		const 删除按钮 = document.createElement('button');
		删除按钮.className = '删除规则按钮';
		删除按钮.textContent = '×';
		删除按钮.onclick = () => {
			扳手规则列表.splice(索引, 1);
			更新扳手规则窗口();
		};
		规则条目.appendChild(属性输入);
		规则条目.appendChild(操作选择);
		规则条目.appendChild(数值输入容器);
		规则条目.appendChild(删除按钮);
		容器.appendChild(规则条目);
	});
}
function 应用单个扳手规则(目标实体, 规则) {
	const 属性路径 = 规则.属性.split('.');
	let 目标 = 目标实体;
	let isCustomData = false;
	for (let i = 0; i < 属性路径.length - 1; i++) {
		const part = 属性路径[i];
		if (part === '自定义数据') {
			目标 = 目标.自定义数据;
			isCustomData = true;
		} else {
			if (typeof 目标[part] === 'undefined') return;
			目标 = 目标[part];
		}
	}
	const 属性名 = 属性路径[属性路径.length - 1];
	if (!目标) return;
	const 当前值 = isCustomData ? 目标.get(属性名) : 目标[属性名];
	let 值1 = 规则.数值1;
	let 值2 = 规则.数值2;
	if (String(值1).toLowerCase() === 'true') {
		值1 = true;
	} else if (String(值1).toLowerCase() === 'false') {
		值1 = false;
	} else if (!isNaN(parseFloat(值1))) {
		值1 = parseFloat(值1);
	}
	let 新值 = 当前值;
	switch (规则.操作) {
		case '+': if (typeof 当前值 === 'number') 新值 = 当前值 + (值1 || 0); break;
		case '-': if (typeof 当前值 === 'number') 新值 = 当前值 - (值1 || 0); break;
		case '*': if (typeof 当前值 === 'number') 新值 = 当前值 * (值1 || 1); break;
		case '/': if (typeof 当前值 === 'number' && (值1 || 0) !== 0) 新值 = 当前值 / (值1 || 1); break;
		case '=': 新值 = 值1; break;
		case 'rand':
			const num1 = parseFloat(值1);
			const num2 = parseFloat(值2);
			if (!isNaN(num1) && !isNaN(num2)) {
				新值 = Math.floor(prng() * (Math.max(num1, num2) - Math.min(num1, num2) + 1)) + Math.min(num1, num2);
			}
			break;
	}
	if (isCustomData) {
		目标.set(属性名, 新值);
	} else {
		目标[属性名] = 新值;
	}
	if (目标实体 instanceof 怪物 && (属性名 === '基础生命值' || 属性名 === '生命值')) {
		目标实体.当前生命值 = 新值;
	}
}
function 初始化扳手工具() {
    const 打开按钮 = document.getElementById('打开扳手规则按钮');
    const 关闭按钮 = document.getElementById('关闭扳手规则按钮');
    const 添加按钮 = document.getElementById('添加扳手规则按钮');
    const 遮罩 = document.getElementById('扳手规则窗口遮罩');

    打开按钮.onclick = 打开扳手规则窗口;
    关闭按钮.onclick = 关闭扳手规则窗口;
    添加按钮.onclick = () => {
        扳手规则列表.push({ 属性: '品质', 操作: '=', 数值1: '1' });
        更新扳手规则窗口();
    };
    遮罩.onclick = (e) => {
        if (e.target === 遮罩) {
            关闭扳手规则窗口();
        }
    };
}
function 打开扳手规则窗口() {
    const 遮罩 = document.getElementById('扳手规则窗口遮罩');
    遮罩.style.display = 'flex';
    requestAnimationFrame(() => {
        遮罩.classList.add('显示');
    });
    更新扳手规则窗口();
}

function 关闭扳手规则窗口() {
    const 遮罩 = document.getElementById('扳手规则窗口遮罩');
    遮罩.classList.remove('显示');
    setTimeout(() => {
        遮罩.style.display = 'none';
    }, 300);
}
function 应用所有扳手规则(目标实体) {
    if (扳手规则列表.length === 0) {
        显示通知("没有定义任何规则。", "警告");
        return;
    }
    扳手规则列表.forEach(规则 => {
        应用单个扳手规则(目标实体, 规则);
    });
    显示通知(`已对 ${目标实体.名称 || 目标实体.类型} 应用 ${扳手规则列表.length} 条规则。`, "成功");
    绘制();
}

初始化扳手工具();
			function 重置单元格(横坐标, 纵坐标,刷新墙壁=true) {
			    const 单元格 = 地牢[纵坐标]?.[横坐标];
			    if (!单元格) return;
			
			    if (单元格.关联物品) {
			if (单元格.关联物品.唯一标识 && 玩家背包.has(单元格.关联物品.唯一标识)) {
			处理销毁物品(单元格.关联物品.唯一标识, true);
			}
			
			    所有计时器 = 所有计时器.filter(计时器 => 计时器.唯一标识.toString() !== 单元格.关联物品.唯一标识.toString());
			    所有传送门 = 所有传送门.filter(item => item.唯一标识.toString() !== 单元格.关联物品?.唯一标识.toString());
			
			单元格.关联物品 = null;
			    }
			    if (单元格.关联怪物) {
			        let 现有怪物=单元格.关联怪物
			        if (现有怪物 instanceof 蜈蚣怪物) {
			        现有怪物?.身体部位?.forEach(item=>{item.移除自身(true)})
			        现有怪物.移除自身()
			    } else if (现有怪物 instanceof 蜈蚣部位) {
			        现有怪物?.主体?.身体部位?.forEach(item=>{item.移除自身(true)})
			        现有怪物.主体?.移除自身()
			    }
			        所有怪物 = 所有怪物.filter(怪物 => 怪物 !== 单元格.关联怪物);
			        单元格.关联怪物 = null;
			    }
			    
			    if (单元格.标识 && 门实例列表.has(单元格.标识)) {
			        const 门实例 = 门实例列表.get(单元格.标识);
			        if (门实例.房间ID !== null && 房间列表[门实例.房间ID]) {
			房间列表[门实例.房间ID].门 = 房间列表[门实例.房间ID].门.filter(门坐标 => !(门坐标.x === 横坐标 && 门坐标.y === 纵坐标));
			        }
			        门实例列表.delete(单元格.标识);
			    }
			    
			    单元格.类型 = null;
			    单元格.背景类型 = 单元格类型.墙壁;
			    单元格.标识 = null;
			    单元格.钥匙ID = null;
			    单元格.颜色索引 = 颜色表.length;
			    单元格.墙壁 = { 上: false, 右: false, 下: false, 左: false };
			    单元格.是否强制墙壁 = false
			    单元格.阻碍视野 = false
			    
			    
			    
			    if(刷新墙壁) 生成墙壁();
			    绘制();
			}
			function 编辑器右键处理(e) {
			    e.preventDefault();
			    const rect = canvas.getBoundingClientRect();
			    const x = e.clientX - rect.left;
			    const y = e.clientY - rect.top;
			    const gridX = Math.floor(当前相机X + x / 单元格大小);
			    const gridY = Math.floor(当前相机Y + y / 单元格大小);
			    if (gridX < 0 || gridX >= 地牢大小 || gridY < 0 || gridY >= 地牢大小) return;
			    打开属性编辑器(地牢[gridY][gridX], gridX, gridY);
			}
			
			function 从当前位置开始游玩() {
			    临时测试 = true;
			    
			    处理房间状态();
			    编辑器状态备份 = 导出地图();
			    编辑器玩家 = {...玩家}
			    if (!编辑器状态备份) {
			        显示通知("无法备份地图状态，无法进入游玩模式。", "错误");
			        return;
			    }
			    游戏状态 = '编辑器游玩';
			    document.body.classList.remove('地图编辑器模式');
			    document.body.classList.add('编辑器游玩模式');
			    document.body.classList.add('游戏进行中');
			    document.getElementById('编辑器工具栏').style.display = 'none';
			    document.getElementById('笔刷工具容器').style.display = 'none';
			    document.getElementById('返回编辑器按钮').style.display = 'block';
			
			    canvas.removeEventListener('mousedown', 编辑器鼠标按下处理);
			    canvas.removeEventListener('mousemove', 编辑器鼠标移动处理);
			    canvas.removeEventListener('mouseup', 编辑器鼠标抬起处理);
			    canvas.removeEventListener('touchstart', 编辑器触摸开始处理);
			    canvas.removeEventListener('touchmove', 编辑器触摸移动处理);
			    canvas.removeEventListener('touchend', 编辑器触摸结束处理);
			    canvas.removeEventListener('contextmenu', 编辑器右键处理);
			    
			    //canvas.addEventListener("touchstart", 处理地图点击);
			    canvas.addEventListener("click", 处理地图单击);
			    
			    document.getElementById("背包物品栏").innerHTML = '';
			    玩家背包.clear();
			    const 背包弹窗 = document.querySelector('.背包弹窗');
			    const 背包标题元素 = 背包弹窗.querySelector(':scope > .弹窗头部 > h3');
			    if(背包标题元素){
			        背包标题元素.innerHTML = `背包 (容量：<span id="当前容量">0</span>/<span id="最大容量">${最大背包容量}</span>)`;
			    }
			    const 互动按钮元素 = document.getElementById('互动按钮');
			    if(互动按钮元素) 互动按钮元素.style.background = '';
			
			    Object.assign(玩家属性, 自定义全局设置.玩家属性);
			    玩家属性.最大生命值加成 = 自定义全局设置.初始生命值 - 100;
			    初始玩家属性 = {...玩家属性};
			    最大背包容量 = 自定义全局设置.初始背包容量;
			    document.querySelector(".health-bar").style.width = "100%";
			    document.querySelector(".power-bar").style.width = `100%`;
			    玩家总移动回合数 = 0;
			    玩家总受到伤害 = 0;
			    当前天气效果 = [...自定义全局设置.全局天气];
			    if (当前天气效果.length > 0) {
			        显示通知(`当前天气: ${当前天气效果.join(', ')}`, '信息', true);
			    }
			
			    
			    玩家属性.允许移动 = 0;
			    const 玩家起始房间ID = 房间地图[玩家.y]?.[玩家.x];
			    if (玩家起始房间ID !== -1 && 玩家起始房间ID !== undefined) {
			        已访问房间.add(玩家起始房间ID);
			    }
			    
			    更新装备显示();
			    更新背包显示();
			    更新视口();
			    更新胜利条件显示();
			    处理沉浸式传送门();
			    显示通知('已进入游玩模式。点击左上角按钮返回。', '信息');
			}
			function 克隆物品编辑器(原始物品) {
			    if (!原始物品 || typeof 原始物品.constructor !== 'function') {
			        return null;
			    }
			    const 构造器 = 原始物品.constructor;
			    const 克隆实例 = new 构造器({});
			
			    for (const 键 in 原始物品) {
			        if (Object.hasOwnProperty.call(原始物品, 键)) {
			            if (键 === "自定义数据" && 原始物品.自定义数据 instanceof Map) {
			                克隆实例.自定义数据 = new Map(原始物品.自定义数据);
			            } else if (键 !== '唯一标识' && 键 !== '显示元素' && 键 !== 'isActive' && 键 !== '已装备' && 键 !== '装备槽位') {
			                克隆实例[键] = 原始物品[键];
			            }
			        }
			    }
			    克隆实例.唯一标识 = Symbol(Date.now().toString() + prng().toString());
			    return 克隆实例;
			}
			
			function 克隆怪物编辑器(原始怪物) {
			    if (!原始怪物 || typeof 原始怪物.constructor !== 'function' || 原始怪物 instanceof 巨人怪物 || 原始怪物 instanceof 巨人部位 || 原始怪物 instanceof 蜈蚣怪物 || 原始怪物 instanceof 蜈蚣部位) {
			        return null; //未开发
			    }
			    const 配置 = {}
			    for (const 键 in 原始怪物) {
			        if (Object.hasOwnProperty.call(原始怪物, 键)) {
			            if (键!== '掉落物') {
			                配置[键] = 原始怪物[键];
			            }
			        }
			    }
			    const 构造器 = 原始怪物.constructor;
			    const 克隆实例 = new 构造器(配置);
			    for (const 键 in 原始怪物) {
			        if (Object.hasOwnProperty.call(原始怪物, 键)) {
			            
			            if (键 === '掉落物' && 原始怪物.掉落物) {
			                克隆实例.掉落物 = 克隆物品编辑器(原始怪物.掉落物);
			            } else {
			                if(原始怪物[键] && 键!=='巡逻方向') 克隆实例[键] = 原始怪物[键];
			            }
			        }
			    }
			    return 克隆实例;
			}
			
			function 克隆单元格(原始单元格) {
			    const 克隆实例 = new 单元格(原始单元格.x, 原始单元格.y);
			    for (const 键 in 原始单元格) {
			        
			            if (键 === '关联物品' && 原始单元格.关联物品) {
			                克隆实例.关联物品 = 克隆物品编辑器(原始单元格.关联物品);
			            } else if (键 === '关联怪物' && 原始单元格.关联怪物) {
			                克隆实例.关联怪物 = 克隆怪物编辑器(原始单元格.关联怪物);
			            } else if (键 !== '唯一标识') {
			                克隆实例[键] = deepClone(原始单元格[键]);
			            }
			        
			    }
			    return 克隆实例;
			}
			
			function 编辑器复制选区(x1, y1, x2, y2) {
			    const 左上角X = Math.min(x1, x2);
			    const 左上角Y = Math.min(y1, y2);
			    const 右下角X = Math.max(x1, x2);
			    const 右下角Y = Math.max(y1, y2);
			
			    const 复制的数据 = [];
			    let 只包含实体 = true;
			
			    for (let y = 左上角Y; y <= 右下角Y; y++) {
			        for (let x = 左上角X; x <= 右下角X; x++) {
			            const 原始单元格 = 地牢[y]?.[x];
			            if (原始单元格) {
			                复制的数据.push({
			                    相对X: x - 左上角X,
			                    相对Y: y - 左上角Y,
			                    单元格克隆: 克隆单元格(原始单元格)
			                });
			                if (!原始单元格.关联物品 && !原始单元格.关联怪物) {
			                    只包含实体 = false;
			                }
			            }
			        }
			    }
			
			    if (复制的数据.length === 0) {
			        显示通知("选区为空，未复制任何内容。", "警告");
			        return;
			    }
			
			    编辑器剪贴板 = {
			        宽度: 右下角X - 左上角X + 1,
			        高度: 右下角Y - 左上角Y + 1,
			        数据: 复制的数据,
			        只包含实体: 只包含实体
			    };
			
			    显示通知(`已复制 ${编辑器剪贴板.宽度}x${编辑器剪贴板.高度} 的区域。再次点击以粘贴。`, "成功");
			    绘制();
			}
			
			function 编辑器粘贴选区(粘贴左上角X, 粘贴左上角Y) {
			    if (!编辑器剪贴板) return;
			    saveEditorState();
			
			    const { 宽度, 高度, 数据, 只包含实体 } = 编辑器剪贴板;
			    const 门映射 = new Map();
			
			    for (const 条目 of 数据) {
			        const 目标X = 粘贴左上角X + 条目.相对X;
			        const 目标Y = 粘贴左上角Y + 条目.相对Y;
			
			        if (目标X < 0 || 目标X >= 地牢大小 || 目标Y < 0 || 目标Y >= 地牢大小) continue;
			
			        const 目标单元格 = 地牢[目标Y][目标X];
			        const 源单元格克隆 = 条目.单元格克隆;
			
			        
			
			        if (只包含实体) {
			            if (源单元格克隆.关联物品) {
			                放置物品到单元格(源单元格克隆.关联物品, 目标X, 目标Y);
			            }
			            if (源单元格克隆.关联怪物) {
			                放置怪物到单元格(源单元格克隆.关联怪物, 目标X, 目标Y);
			            }
			            目标单元格.类型 = 源单元格克隆.类型;
			        } else {
			            重置单元格(目标X, 目标Y,false);
			            目标单元格.背景类型 = 源单元格克隆.背景类型;
			            目标单元格.类型 = 源单元格克隆.类型;
			            目标单元格.墙壁 = deepClone(源单元格克隆.墙壁);
			            目标单元格.颜色索引 = 源单元格克隆.颜色索引;
			            目标单元格.是否强制墙壁 = 源单元格克隆.是否强制墙壁;
			            目标单元格.阻碍视野 = 源单元格克隆.阻碍视野;
			
			            if (源单元格克隆.关联物品) {
			                放置物品到单元格(源单元格克隆.关联物品, 目标X, 目标Y);
			            }
			            if (源单元格克隆.关联怪物) {
			                放置怪物到单元格(源单元格克隆.关联怪物, 目标X, 目标Y);
			            }
			
			            if (源单元格克隆.标识) {
			                if (!门映射.has(源单元格克隆.标识.toString())) {
			                    门映射.set(源单元格克隆.标识.toString(), new 门({ 关联房间ID: null, 位置: { x: 目标X, y: 目标Y } }));
			                }
			                const 新门实例 = 门映射.get(源单元格克隆.标识.toString());
			                目标单元格.标识 = 新门实例.唯一标识;
			                门实例列表.set(新门实例.唯一标识, 新门实例);
			            }
			        }
			    }
			
			    生成墙壁();
			    //绘制();
			    显示通知("粘贴完成。", "成功");
			    编辑器剪贴板 = null; 
			}
			function 编辑器画布事件处理(clientX, clientY, eventType, originalEvent) {
			    if (游戏状态!=='地图编辑器') return;
			    if (originalEvent.buttons === 2) {
			        return;
			    }
			     if (
			        document.getElementById('编辑器属性面板遮罩').style.display === 'block' ||
			        originalEvent.target.closest('.背包弹窗') ||
			        originalEvent.target.closest('#编辑器工具栏')
			    ) {
			        if(eventType === 'start' || eventType === 'move') {
			             编辑器状态.正在划区 = false; 
			             编辑器状态.正在复制选区 = false;
			        }
			        return;
			    }
			    originalEvent.preventDefault();
			
			    const rect = canvas.getBoundingClientRect();
			    const x = clientX - rect.left;
			    const y = clientY - rect.top;
			    const gridX = Math.floor(当前相机X + x / 单元格大小);
			    const gridY = Math.floor(当前相机Y + y / 单元格大小);
			    
			    if (gridX < 0 || gridX >= 地牢大小 || gridY < 0 || gridY >= 地牢大小) return;
			    
			    const now = Date.now();
			    const DOUBLE_CLICK_TIME = 300; 
			    
			
			    if (eventType === 'start') {
			        
			        if (now - (编辑器状态.上次点击时间 || 0) < DOUBLE_CLICK_TIME && 编辑器状态.上次点击格子 && 编辑器状态.上次点击格子.x === gridX && 编辑器状态.上次点击格子.y === gridY) {
			             saveEditorState();
			             编辑器状态.正在划区 = true;
			             编辑器状态.划区起点 = { x: gridX, y: gridY };
			             玩家.x = gridX;
			             玩家.y = gridY;
			        } else {
			            
			            计划显示格子特效([{ x: gridX, y: gridY }], "FFFFFF", 0);
			            if(编辑器状态.模式 === '传送') {
			               玩家.x = gridX;
			               玩家.y = gridY;
			               更新视口();
			               绘制();
			            } else if (编辑器状态.模式 === '设置起点') {
			                saveEditorState();
			                const 房间ID = 房间地图[gridY]?.[gridX];
			                if (房间ID === undefined) {
			                    显示通知("玩家起点必须设置在地牢内！", "错误");
			                    return;
			                }
			                
			                玩家初始位置.x = gridX;
			                玩家初始位置.y = gridY;
			                显示通知(`玩家起点已设置为 (${gridX}, ${gridY})`, '成功');
			                编辑器状态.模式 = 旧编辑器状态;
			                编辑器状态.上次点击时间 = now;
			                编辑器状态.上次点击格子 = { x: gridX, y: gridY };
			                绘制小地图();
			                return;
			            } else if (编辑器状态.当前选中?.名称 === '房间工具') {
			            saveEditorState();
			                编辑器状态.正在划区 = true;
			                编辑器状态.划区起点 = { x: gridX, y: gridY };
			                玩家.x = gridX;
			                玩家.y = gridY;
			            } else if (编辑器状态.当前选中?.名称 === '复制工具') {
			            if (编辑器剪贴板) {
			                编辑器粘贴选区(gridX, gridY);
			            } else {
			                saveEditorState();
			                编辑器状态.正在复制选区 = true;
			                编辑器状态.复制起点 = { x: gridX, y: gridY };
			            }
			            } else if (编辑器状态.当前选中?.名称 === '扳手') {
				saveEditorState();
				const 目标单元格 = 地牢[gridY]?.[gridX];
				if (目标单元格) {
					const 目标实体 = 目标单元格.关联怪物 || 目标单元格.关联物品;
					if (目标实体) {
						应用所有扳手规则(目标实体);
					} else {
						显示通知("这里没有可以修改的物品或怪物。", "警告");
					}
				}
			} else if (编辑器状态.当前选中?.类型 === '背景' && 编辑器状态.笔刷模式 === '油漆桶') {
							油漆桶填充(gridX, gridY, 编辑器状态.当前选中.绘制类型);
						} else if (编辑器状态.当前选中?.类型 === '背景' && 编辑器状态.笔刷模式 === '笔刷') {
							saveEditorState();
							笔刷绘制(gridX, gridY);
						} else {
							saveEditorState();
			                编辑器放置逻辑(gridX, gridY);
			            }
			        }
			        编辑器状态.上次点击时间 = now;
			        编辑器状态.上次点击格子 = { x: gridX, y: gridY };
			    } else if (eventType === 'move' && (编辑器状态.正在划区 || 编辑器状态.正在复制选区)) {
			        玩家.x = gridX;
			        玩家.y = gridY;
			    } else if (eventType === 'end') {
			        if (编辑器状态.正在复制选区) {
			            编辑器状态.正在复制选区 = false;
			            编辑器复制选区(编辑器状态.复制起点.x, 编辑器状态.复制起点.y, gridX, gridY);
			            更新所有门朝向();
			            更新视口();
			        生成墙壁();
			        saveEditorState();
			        } else if (编辑器状态.正在划区) {
			            编辑器状态.正在划区 = false;
			            const 起始横坐标 = 编辑器状态.划区起点.x;
			            const 起始纵坐标 = 编辑器状态.划区起点.y;
			            if (编辑器状态.当前选中?.名称 === '房间工具') {
			                 创建并放置房间(起始横坐标, 起始纵坐标, gridX, gridY);
			                 更新所有门朝向();
			                 
			            } else {
			                const 左上角横坐标 = Math.min(起始横坐标, gridX);
			                const 左上角纵坐标 = Math.min(起始纵坐标, gridY);
			                const 右下角横坐标 = Math.max(起始横坐标, gridX);
			                const 右下角纵坐标 = Math.max(起始纵坐标, gridY);
			
			                for (let 纵 = 左上角纵坐标; 纵 <= 右下角纵坐标; 纵++) {
			                    for (let 横 = 左上角横坐标; 横 <= 右下角横坐标; 横++) {
			                        编辑器放置逻辑(横, 纵);
			                    }
			                }
			            }
			            更新视口();
			        生成墙壁();
			        saveEditorState();
			        } else if (编辑器状态.当前选中?.类型 === '背景') {
			            生成墙壁();
			        }
			        
			    } else if(eventType === 'move' && (originalEvent.buttons === 1 || originalEvent.touches)) {
			        if (编辑器状态.当前选中?.类型 === '背景' && 编辑器状态.笔刷模式 === '笔刷') {
						笔刷绘制(gridX, gridY);
					} else if (编辑器状态.当前选中 && 编辑器状态.当前选中.名称 !== '房间工具' && 编辑器状态.当前选中.名称 !== '复制工具') {
						 编辑器放置逻辑(gridX, gridY);
					}
			    }
			    绘制小地图();
			}
			    
			            function 更新胜利条件显示() {
			    const 条件 = 自定义全局设置.胜利条件;
			    const 有效条件 = Object.values(条件).some(val => val > 0);
			
			    const 清理提示 = (提示类型) => {
			        if (胜利条件提示元素组[提示类型]) {
			            胜利条件提示元素组[提示类型].销毁();
			            胜利条件提示元素组[提示类型] = null;
			        }
			    };
			
			    if (!有效条件 || (游戏状态 !== '编辑器游玩' && 游戏状态 !== '游戏中')) {
			        Object.keys(胜利条件提示元素组).forEach(清理提示);
			        return;
			    }
			
			    if (!胜利条件提示元素组.标题) {
			        胜利条件提示元素组.标题 = new 文本元素({内容: "胜利条件:"});
			        const 标题元素 = 胜利条件提示元素组.标题.容器元素.querySelector('.hud-label');
			        if (标题元素) 标题元素.style.fontWeight = 'bold';
			        胜利条件提示元素组.标题.容器元素.style.marginTop = '8px';
			        胜利条件提示元素组.标题.容器元素.style.borderTop = '1px dashed #444';
			        胜利条件提示元素组.标题.容器元素.style.paddingTop = '8px';
			    }
			    
			    if (条件.回合数限制 > 0) {
			        if (!胜利条件提示元素组.回合) {
			            胜利条件提示元素组.回合 = new 进度条元素({图标: 图标映射.沙漏, 初始值: 0});
			        }
			        const 进度 = Math.min(100, (玩家总移动回合数 / 条件.回合数限制) * 100);
			        const 颜色 = 玩家总移动回合数 > 条件.回合数限制 ? '#ff4444' : '#4caf50';
			        胜利条件提示元素组.回合.更新({
			            数值: 100 - 进度,
			            标签: `${玩家总移动回合数} / ${条件.回合数限制}`,
			            颜色: 颜色
			        });
			    } else {
			        清理提示('回合');
			    }
			
			    if (条件.伤害限制 > 0) {
			        if (!胜利条件提示元素组.伤害) {
			            胜利条件提示元素组.伤害 = new 进度条元素({图标: 图标映射.爱心, 初始值: 0});
			        }
			        const 进度 = Math.min(100, (玩家总受到伤害 / 条件.伤害限制) * 100);
			        const 颜色 = 玩家总受到伤害 > 条件.伤害限制 ? '#ff4444' : '#4caf50';
			        胜利条件提示元素组.伤害.更新({
			            数值: 100 - 进度,
			            标签: `${玩家总受到伤害.toFixed(1)} / ${条件.伤害限制}`,
			            颜色: 颜色
			        });
			    } else {
			        清理提示('伤害');
			    }
			
			    if (条件.生命下限 > 0) {
			        if (!胜利条件提示元素组.生命) {
			            胜利条件提示元素组.生命 = new 进度条元素({图标: 图标映射.修补心, 初始值: 100});
			        }
			        const 当前生命 = parseFloat(document.querySelector(".health-bar")?.style.width) || 100;
			        const 颜色 = 当前生命 < 条件.生命下限 ? '#ff4444' : '#4caf50';
			        胜利条件提示元素组.生命.更新({
			            数值: 当前生命,
			            标签: `> ${条件.生命下限}%`,
			            颜色: 颜色
			        });
			    } else {
			        清理提示('生命');
			    }
			    if (条件.死亡次数限制 > 0) {
			        if (!胜利条件提示元素组.死亡) {
			            胜利条件提示元素组.死亡 = new 进度条元素({图标: 图标映射.死亡图标, 初始值: 100});
			        }
			        const 进度 = Math.min(100, (玩家死亡次数 / 条件.死亡次数限制) * 100);
			        const 颜色 = 玩家死亡次数 >= 条件.死亡次数限制 ? '#ff4444' : '#4caf50';
			        胜利条件提示元素组.死亡.更新({
			            数值: 100 - 进度,
			            标签: `${玩家死亡次数} / ${条件.死亡次数限制}`,
			            颜色: 颜色
			        });
			    } else {
			        清理提示('死亡');
			    }
			}
			function 处理房间状态() {
			    if (游戏状态 !== "地图编辑器") return;
			    
			    房间列表.forEach(房间 => {
			        if (!房间) return;
			
			        if (房间.已探索) {
			            已访问房间.add(房间.id);
			        } else {
			            已访问房间.delete(房间.id);
			        }
			        if (房间.挑战状态) {
			            房间.挑战状态.已完成 = false;
			        }
			    });
			}
			
			
			function 打开属性编辑器(对象, 横坐标, 纵坐标) {
			    const 遮罩 = document.getElementById('编辑器属性面板遮罩');
			    const 面板 = document.getElementById('编辑器属性面板');
			    const 标题 = document.getElementById('属性面板标题');
			    const 内容 = document.getElementById('属性面板内容');
			    const 保存按钮 = document.getElementById('保存属性按钮');
			    const 删除按钮 = document.getElementById('删除对象按钮');
			    const 关闭按钮 = document.getElementById('关闭属性面板按钮');
			
			    内容.innerHTML = '';
			    const 当前单元格 = 地牢[纵坐标]?.[横坐标];
			    let 目标对象;
			    let 是房间编辑器 = false;
			    let 房间标识 = 房间地图[纵坐标]?.[横坐标];
			    let 是上锁房间 = 上锁房间列表.some(房间 => 房间.id === 房间标识);
			
			    if (编辑器状态.当前选中?.名称 === '房间编辑工具' && 房间标识 !== -1 && 房间列表[房间列表.findIndex(item=>item?.id==房间标识)]) {
			        目标对象 = 房间列表[房间列表.findIndex(item=>item?.id==房间标识)];
			        是房间编辑器 = true;
			    } else if (对象.id !== undefined && 房间列表[房间列表.findIndex(item=>item?.id==对象.id)] === 对象) {
			        目标对象 = 对象;
			        是房间编辑器 = true;
			    } else {
			        目标对象 = 当前单元格.关联物品 || 当前单元格.关联怪物 || (([单元格类型.门, 单元格类型.上锁的门].includes(当前单元格.背景类型) && 门实例列表.get(当前单元格.标识)) ? 门实例列表.get(当前单元格.标识) : 当前单元格);
			    }
			    
			    标题.textContent = `编辑 (${横坐标}, ${纵坐标}) ${目标对象.名称 || 目标对象.类型 || '单元格'}`;
			    编辑器状态.选中实例 = 目标对象;
			
			    const 当前编辑对象 = 目标对象;
			    
			    const 创建字段 = (键, 值, 父对象, 是自定义数据 = false, 待更新对象 = 父对象) => {
			        const 包装元素 = document.createElement('div');
			        包装元素.style.cssText = 'margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;';
			        const 标签 = document.createElement('label');
			        
			        let 显示文本 = 键;
			        if (键 === 'isOneWay') {
			显示文本 = '是否单向';
			if (父对象 instanceof 单元格 && ![单元格类型.门, 单元格类型.上锁的门].includes(父对象.背景类型)) return null;
			        }
			        if (键 === 'oneWayAllowedDirection') 显示文本 = '允许方向';
			
			        标签.textContent = 显示文本;
			        标签.style.marginRight = '10px';
			        包装元素.appendChild(标签);
			        
			        let 输入框;
			        if (键 === 'oneWayAllowedDirection' && (父对象 instanceof 门 || (父对象 instanceof 单元格 && [单元格类型.门, 单元格类型.上锁的门].includes(父对象.背景类型)))) {
			输入框 = document.createElement('select');
			const 门方向 = (父对象 instanceof 门 ? 地牢[父对象.所在位置.y][父对象.所在位置.x].doorOrientation : 父对象.doorOrientation);
			let 方向选项 = ['无'];
			if (门方向 === 'NS') {
			    方向选项.push('N', 'S');
			} else if (门方向 === 'EW') {
			    方向选项.push('E', 'W');
			}
			方向选项.forEach(方向 => {
			    const 选项 = document.createElement('option');
			    选项.value = 方向 === '无' ? '' : 方向;
			    选项.textContent = 方向;
			    if (选项.value === (值 || '')) 选项.selected = true;
			    输入框.appendChild(选项);
			});
			        } else if (键 === '关联房间ID' && 父对象 instanceof 门) {
			    输入框 = document.createElement('select');
			    const 默认选项 = document.createElement('option');
			    默认选项.value = "-1";
			    默认选项.textContent = "无";
			    输入框.appendChild(默认选项);
			    房间列表.forEach(房间 => {
			    if(房间) {
			        const 选项 = document.createElement('option');
			        选项.value = 房间.id;
			        选项.textContent = `${房间.名称} (ID: ${房间.id})`;
			        if (房间.id === 值) 选项.selected = true;
			        输入框.appendChild(选项);
			    }
			    });
			        } else if (键 === '钥匙对应房间ID' && 父对象 === null) {
			输入框 = document.createElement('select');
			const 默认选项 = document.createElement('option');
			默认选项.value = "-1";
			默认选项.textContent = "万能钥匙";
			if (parseInt(值) === -1) 默认选项.selected = true;
			输入框.appendChild(默认选项);
			上锁房间列表.forEach(上锁房间 => {
			    const 房间 = 房间列表[房间列表.findIndex(item=>item?.id==上锁房间.id)];
			    if (房间) {
			        const 选项 = document.createElement('option');
			        选项.value = 房间.id;
			        选项.textContent = `${房间.名称 || `房间 ${房间.id}`}`;
			        if (房间.id === parseInt(值)) {
			            选项.selected = true;
			        }
			        输入框.appendChild(选项);
			    }
			});
			        } else if (键 === '对应门ID' && 父对象 instanceof 钥匙) {
			输入框 = document.createElement('select');
			
			const 默认选项 = document.createElement('option');
			默认选项.value = "-1";
			默认选项.textContent = "万能钥匙";
			if (parseInt(值) === -1) 默认选项.selected = true;
			输入框.appendChild(默认选项);
			
			上锁房间列表.forEach(上锁房间 => {
			    const 房间 = 房间列表[房间列表.findIndex(item=>item?.id==上锁房间.id)];
			    if (房间) {
			        const 选项 = document.createElement('option');
			        选项.value = 房间.id;
			        选项.textContent = `${房间.名称 || `房间 ${房间.id}`}`;
			        if (房间.id === parseInt(值)) {
			            选项.selected = true;
			        }
			        输入框.appendChild(选项);
			    }
			});
			        } else if (键 === '颜色索引' && ((父对象 instanceof 单元格 && [单元格类型.门, 单元格类型.上锁的门].includes(父对象.背景类型)) || 父对象 instanceof 门 || 父对象 instanceof 钥匙 || 是房间编辑器)) {
			输入框 = document.createElement('select');
			颜色名表.forEach((名称, 索引) => {
			    const 选项 = document.createElement('option');
			    选项.value = 索引;
			    选项.textContent = 名称;
			    if (索引 === parseInt(值)) 选项.selected = true;
			    输入框.appendChild(选项);
			});
			        }
			        else if (键 === '材质' && 父对象 instanceof 物品) {
			输入框 = document.createElement('select');
			const 材料列表 = Object.values(材料);
			材料列表.forEach(材质 => {
			    const 选项 = document.createElement('option');
			    选项.value = 材质;
			    选项.textContent = 材质;
			    if (材质 === 值) 选项.selected = true;
			    输入框.appendChild(选项);
			});
			        } else if (typeof 值 === 'boolean') {
			输入框 = document.createElement('input');
			输入框.type = 'checkbox';
			输入框.checked = 值;
			        } else if (键 === '类型' && 父对象.id !== undefined) { 
			输入框 = document.createElement('select');
			const 类型列表 = ['房间', '挑战房间', '单向房间', '黑暗房间', '隐藏解谜棋盘', '隐藏罐子房间', '隐藏植物房间', '隐藏书库房间', '隐藏药水房间'];
			类型列表.forEach(类型 => {
			    const 选项 = document.createElement('option');
			    选项.value = 类型;
			    选项.textContent = 类型;
			    if (类型 === 值) 选项.selected = true;
			    输入框.appendChild(选项);
			});
			        } else if (typeof 值 === 'number') {
			输入框 = document.createElement('input');
			输入框.type = 'number';
			输入框.value = 值;
			输入框.style.width = '100px';
			        } else {
			输入框 = document.createElement('input');
			输入框.type = 'text';
			输入框.value = 值;
			输入框.style.width = '150px';
			        }
			        输入框.style.marginLeft = 'auto';
			        输入框.dataset.key = 键;
			        输入框.dataset.isCustom = 是自定义数据;
			        输入框.dataset.parent = 待更新对象 === 'isLockedFlag' ? 'isLockedFlag' : (是自定义数据 ? 'customData' : 'direct');
			        if (待更新对象 === '挑战状态') {
			输入框.dataset.parentKey = '挑战状态';
			        }
			        包装元素.appendChild(输入框);
			        return 包装元素;
			    };
			
			        if (目标对象 instanceof 刷怪笼) {
			        const { monsters } = 获取所有可用的定义();
			        const monsterOptions = monsters.map(m => {
			            const instance = new m.类({});
			            return { name: instance.类型, value: m.类.name };
			        }).filter((v, i, a) => a.findIndex(t => (t.name === v.name)) === i);
			        
			        const spawnerRow = 创建字段('生成物类名', 目标对象.自定义数据.get('生成物类名'), 目标对象, true);
			        const spawnerSelect = document.createElement('select');
			        monsterOptions.forEach(opt => {
			            const option = document.createElement('option');
			            option.value = opt.value;
			            option.textContent = opt.name;
			            if(opt.value === 目标对象.自定义数据.get('生成物类名')) option.selected = true;
			            spawnerSelect.appendChild(option);
			        });
			        spawnerSelect.dataset.key = '生成物类名';
			        spawnerSelect.dataset.isCustom = 'true';
			        spawnerRow.replaceChild(spawnerSelect, spawnerRow.querySelector('input'));
			        spawnerSelect.style.marginLeft = 'auto';
			        内容.appendChild(spawnerRow);
			
			        const patrolRow = 创建字段('巡逻方向', 目标对象.自定义数据.get('巡逻方向'), 目标对象, true);
			        const patrolSelect = document.createElement('select');
			        ['N', 'S', 'E', 'W'].forEach(dir => {
			            const option = document.createElement('option');
			            option.value = dir;
			            option.textContent = dir;
			            if (dir === 目标对象.自定义数据.get('巡逻方向')) option.selected = true;
			            patrolSelect.appendChild(option);
			        });
			        patrolSelect.dataset.key = '巡逻方向';
			        patrolSelect.dataset.isCustom = 'true';
			        patrolRow.replaceChild(patrolSelect, patrolRow.querySelector('input'));
			        patrolSelect.style.marginLeft = 'auto';
			        内容.appendChild(patrolRow);
			    }
			    
			    if (目标对象 instanceof 传送带) {
			        const directionRow = 创建字段('方向', 目标对象.自定义数据.get('方向'), 目标对象, true);
			        const directionSelect = document.createElement('select');
			        ['N', 'S', 'E', 'W'].forEach(dir => {
			const option = document.createElement('option');
			option.value = dir;
			option.textContent = dir;
			if (dir === 目标对象.自定义数据.get('方向')) option.selected = true;
			directionSelect.appendChild(option);
			        });
			        directionSelect.dataset.key = '方向';
			        directionSelect.dataset.isCustom = 'true';
			        directionRow.replaceChild(directionSelect, directionRow.querySelector('input'));
			        directionSelect.style.marginLeft = 'auto';
			        内容.appendChild(directionRow);
			        
			    }
			    
			    if (目标对象 instanceof 巡逻怪物) {
			        const patrolRow = 创建字段('巡逻方向', 目标对象.巡逻方向, 目标对象);
			        const patrolSelect = document.createElement('select');
			        ['N', 'S', 'E', 'W'].forEach(dir => {
			const option = document.createElement('option');
			option.value = dir;
			option.textContent = dir;
			if (dir === 目标对象.巡逻方向) option.selected = true;
			patrolSelect.appendChild(option);
			        });
			        patrolSelect.dataset.key = '巡逻方向';
			        patrolRow.replaceChild(patrolSelect, patrolRow.querySelector('input'));
			        patrolSelect.style.marginLeft = 'auto';
			        内容.appendChild(patrolRow);
			    }
			
			    if (目标对象 instanceof 怪物) {
			        const 掉落物行 = 创建字段('掉落物', null, 目标对象);
			        const 掉落物选择器 = document.createElement('select');
			        掉落物选择器.dataset.key = '掉落物';
			    
			        const 保留选项 = document.createElement('option');
			        保留选项.value = 'original';
			        保留选项.textContent = '保留原样';
			        掉落物选择器.appendChild(保留选项);
			    
			        const 无掉落选项 = document.createElement('option');
			        无掉落选项.value = 'null';
			        无掉落选项.textContent = '无';
			        掉落物选择器.appendChild(无掉落选项);
			    
			        const { items: allItems } = 获取所有可用的定义();
			        const addedItemNames = new Set();
			    
			        const 可掉落物品定义 = allItems.filter(def => {
			try {
			    const 实例 = new def.类({});
			    const 可掉落类型 = ['武器', '防御装备', '药水', '卷轴', '饰品', '消耗品', '钥匙', '金币', '工具','炸弹'];
			    return 可掉落类型.includes(实例.类型)
			} catch (e) {
			    return false;
			}
			        });
			        
			
			        可掉落物品定义.forEach(itemDef => {
			const 实例 = new itemDef.类({});
			const itemName = 实例.名称;
			if (!(实例 instanceof 万能钥匙) && itemName && !addedItemNames.has(itemName)) {
			    const 选项 = document.createElement('option');
			    选项.value = itemDef.类.name;
			    选项.textContent = itemName;
			    掉落物选择器.appendChild(选项);
			    addedItemNames.add(itemName);
			}
			        });
			    
			        if (目标对象.掉落物 && 目标对象.掉落物.constructor) {
			掉落物选择器.value = 目标对象.掉落物.constructor.name;
			        } else if (目标对象.掉落物 === null) {
			    掉落物选择器.value = 'null';
			        } else {
			掉落物选择器.value = 'original';
			        }
			    
			        掉落物行.replaceChild(掉落物选择器, 掉落物行.querySelector('input'));
			        掉落物选择器.style.marginLeft = 'auto';
			        内容.appendChild(掉落物行);
			    
			        const 钥匙ID容器 = document.createElement('div');
			        const 钥匙ID行 = 创建字段('钥匙对应房间ID', (目标对象.掉落物 instanceof 钥匙 ? 目标对象.掉落物.自定义数据.get('对应门ID') : -1), null);
			        钥匙ID容器.appendChild(钥匙ID行);
			        内容.appendChild(钥匙ID容器);
			    
			        const 更新钥匙ID可见性 = () => {
			钥匙ID容器.style.display = 掉落物选择器.value === '钥匙' ? 'flex' : 'none';
			        };
			    
			        掉落物选择器.onchange = 更新钥匙ID可见性;
			        更新钥匙ID可见性(); 
			    }
			
			    if (目标对象 instanceof 挑战石碑) {
			        const 奖励容器 = document.createElement('div');
			        奖励容器.id = 'custom-reward-container';
			        奖励容器.innerHTML = '<h5 style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">自定义奖励</h5>';
			        
			        const 奖励列表 = 目标对象.自定义数据.get('自定义奖励') || [];
			        const { items: 所有可用物品 } = 获取所有可用的定义();
			
			        const 重绘奖励列表 = () => {
			    奖励容器.querySelectorAll('.reward-item').forEach(el => el.remove());
			    奖励列表.forEach((奖励, 索引) => {
			            const 奖励行 = document.createElement('div');
			            奖励行.className = 'reward-item';
			            奖励行.style.cssText = 'display: flex; gap: 5px; align-items: center; margin-bottom: 5px;';
			            const 选择框 = document.createElement('select');
			            所有可用物品.forEach(itemDef => {
			                const 选项 = document.createElement('option');
			                选项.value = itemDef.类.name;
			                const 实例 = new itemDef.类({});
			                选项.textContent = 实例.名称 || 实例.类型;
			                if(奖励.类名 === itemDef.类.name) 选项.selected = true;
			                选择框.appendChild(选项);
			            });
			            选择框.onchange = () => {
			                奖励列表[索引].类名 = 选择框.value;
			                奖励列表[索引].配置 = {}; 
			            };
			
			            const 删除按钮 = document.createElement('button');
			            删除按钮.textContent = '×';
			            删除按钮.onclick = () => {
			            奖励列表.splice(索引, 1);
			            重绘奖励列表();
			            };
			            奖励行.appendChild(选择框);
			            奖励行.appendChild(删除按钮);
			            奖励容器.appendChild(奖励行);
			    });
			        };
			
			        const 添加奖励按钮 = document.createElement('button');
			        添加奖励按钮.textContent = '添加奖励物品';
			        添加奖励按钮.className = '菜单按钮';
			        添加奖励按钮.style.cssText = "padding: 5px 10px; font-size: 0.8em; margin-top: 5px;";
			        添加奖励按钮.onclick = () => {
			奖励列表.push({ 类名: 所有可用物品[0].类.name, 配置: {} });
			重绘奖励列表();
			        };
			
			        重绘奖励列表();
			        奖励容器.appendChild(添加奖励按钮);
			        内容.appendChild(奖励容器);
			    }
			
			    if (!(当前编辑对象 instanceof 物品) && !(当前编辑对象 instanceof 怪物) && !(当前编辑对象 instanceof 门) && !(当前编辑对象.id !== undefined)) {
			        const 墙壁包装器 = document.createElement('div');
			        墙壁包装器.innerHTML = '<h5>墙壁</h5>';
			        墙壁包装器.style.border = '1px solid #555';
			        墙壁包装器.style.padding = '10px';
			        墙壁包装器.style.borderRadius = '8px';
			        ['上', '下', '左', '右'].forEach(方向 => {
			墙壁包装器.appendChild(创建字段(方向, 当前单元格.墙壁[方向], 当前单元格.墙壁));
			        });
			        内容.appendChild(墙壁包装器);
			        内容.appendChild(创建字段('是否强制墙壁', 当前单元格.是否强制墙壁, 当前单元格));
			        编辑器状态.上次放置的背景 = 当前编辑对象;
			    }
			
			    if (是房间编辑器) {
			        内容.appendChild(创建字段('id', 当前编辑对象.id, 当前编辑对象));
			        内容.appendChild(创建字段('名称', 当前编辑对象.名称, 当前编辑对象));
			        内容.appendChild(创建字段('类型', 当前编辑对象.类型, 当前编辑对象));
			        内容.appendChild(创建字段('已探索', 当前编辑对象.已探索 || false, 当前编辑对象));
			        内容.appendChild(创建字段('是否上锁', 是上锁房间, 当前编辑对象, false, 'isLockedFlag'));
			        内容.appendChild(创建字段('颜色索引', 当前编辑对象.颜色索引 || 0, 当前编辑对象));
			        const 挑战设置容器 = document.createElement('div');
			        挑战设置容器.innerHTML = '<h5 style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">挑战房间属性</h5>';
			                    if((当前编辑对象?.挑战状态?.当前波次 === undefined)) 当前编辑对象.挑战状态 = { 进行中: false, 已完成: false, 当前波次: 0, 总波次: 5, 波次最大回合数: 30, 波次当前回合数: 0, 波次内怪物: [], 原始门数据: [],挑战怪物层级:1 };
			        
			        const 挑战状态 = 当前编辑对象.挑战状态 || {};
			        const 总波次 = 挑战状态.总波次 ?? 5;
			        const 波次最大回合数 = 挑战状态.波次最大回合数 ?? 30;
			        const 挑战怪物层级 = 挑战状态.挑战怪物层级 ?? 1;
			
			        挑战设置容器.appendChild(创建字段('总波次', 总波次, 当前编辑对象, false, '挑战状态'));
			        挑战设置容器.appendChild(创建字段('波次最大回合数', 波次最大回合数, 当前编辑对象, false, '挑战状态'));
			        挑战设置容器.appendChild(创建字段('挑战怪物层级', 挑战怪物层级, 当前编辑对象, false, '挑战状态'));
			        
			        const 怪物池容器 = document.createElement('div');
			        怪物池容器.innerHTML = '<p style="margin: 10px 0 5px 0; font-size: 0.9em; color: #ccc;">候选怪物 (默认使用层级生成)</p>';
			        怪物池容器.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px;';
			        
			        const 默认怪物层级 = 挑战怪物层级 === -1 ? (当前层数 ?? 0) : 挑战怪物层级;
			        const 默认池 = new Set(怪物池["上锁房间"].filter(m => m.最小层 <= 默认怪物层级).map(cfg => cfg.类.name));
			        const 当前候选怪物池 = new Set(挑战状态.候选怪物池 || 默认池);
			        const { monsters: allMonsters } = 获取所有可用的定义();
			
			        allMonsters.forEach(def => {
			const 怪物实例 = new def.类({玩家放置:true});
			const 包装 = document.createElement('div');
			包装.style.display = 'flex';
			包装.style.alignItems = 'center';
			const 复选框 = document.createElement('input');
			复选框.type = 'checkbox';
			复选框.id = `monster-check-${怪物实例.类型}`;
			复选框.dataset.className = def.类.name;
			复选框.checked = 当前候选怪物池.has(def.类.name);
			const 标签 = document.createElement('label');
			标签.htmlFor = 复选框.id;
			标签.textContent = 怪物实例.类型;
			标签.style.marginLeft = '5px';
			包装.appendChild(复选框);
			包装.appendChild(标签);
			怪物池容器.appendChild(包装);
			        });
			        挑战设置容器.appendChild(怪物池容器);
			
			        内容.appendChild(挑战设置容器);
			    } else if (目标对象 instanceof 传送门) {
			        内容.appendChild(创建字段('是否随机', 目标对象.自定义数据.get('是否随机'), 目标对象, true));
			        const 目标X字段 = 创建字段('目标X', 目标对象.自定义数据.get('目标X'), 目标对象, true);
			        const 目标Y字段 = 创建字段('目标Y', 目标对象.自定义数据.get('目标Y'), 目标对象, true);
			        内容.appendChild(目标X字段);
			        内容.appendChild(目标Y字段);
			    
			        const isRandomCheckbox = 内容.querySelector('input[data-key="是否随机"]');
			        const updateVisibility = () => {
			const isChecked = isRandomCheckbox.checked;
			目标X字段.style.display = isChecked ? 'none' : 'flex';
			目标Y字段.style.display = isChecked ? 'none' : 'flex';
			        };
			        isRandomCheckbox.addEventListener('change', updateVisibility);
			        updateVisibility();
			} else if (目标对象 instanceof 告示牌) {
			        const 文本区域 = document.createElement('textarea');
			        文本区域.value = 目标对象.自定义数据.get('内容') || '';
			        文本区域.style.width = '100%';
			        文本区域.style.minHeight = '100px';
			        文本区域.dataset.key = '内容';
			        文本区域.dataset.isCustom = 'true';
			        内容.appendChild(文本区域);
			    } else if (目标对象 instanceof 存档点) {
			        内容.appendChild(创建字段('目标X', 目标对象.自定义数据.get('目标X'), 目标对象, true));
			        内容.appendChild(创建字段('目标Y', 目标对象.自定义数据.get('目标Y'), 目标对象, true));
			    }
			    else if (目标对象 instanceof 开关脉冲器) {
			        const 状态行 = 创建字段('监测状态', 目标对象.自定义数据.get('监测状态'), 目标对象, true);
			        const 状态选择 = document.createElement('select');
			        ['红', '蓝', '绿', '紫'].forEach(状态 => {
			const 选项 = document.createElement('option');
			选项.value = 状态.toLowerCase();
			选项.textContent = 状态;
			if (选项.value === 目标对象.自定义数据.get('监测状态')) 选项.selected = true;
			状态选择.appendChild(选项);
			        });
			        状态选择.dataset.key = '监测状态';
			        状态选择.dataset.isCustom = 'true';
			        状态行.replaceChild(状态选择, 状态行.querySelector('input'));
			        状态选择.style.marginLeft = 'auto';
			        内容.appendChild(状态行);
			        内容.appendChild(创建字段('脉冲范围', 目标对象.自定义数据.get('脉冲范围'), 目标对象, true));
			        内容.appendChild(创建字段('脉冲冷却', 目标对象.自定义数据.get('脉冲冷却'), 目标对象, true));
			    } else {
			        for (const 键 in 目标对象) {
			if (Object.hasOwnProperty.call(目标对象, 键) && ['string', 'number', 'boolean'].includes(typeof 目标对象[键])) {
			        if (键 === 'id' || 键 === '已连接' || 键 === 'x' || 键 === 'y' || 键 === '是否强制墙壁' || 键 === '材质' || 键 === '掉落物' || 键 === '巡逻方向') continue;
			        let 控件 = 创建字段(键, 目标对象[键], 目标对象);
			        if(控件) 内容.appendChild(控件);
			}
			        }
			        if (目标对象 instanceof 物品) {
			内容.appendChild(创建字段('材质', 目标对象.材质, 目标对象));
			        }
			    }
			    
			    if (目标对象 instanceof 门) {
			内容.appendChild(创建字段('关联房间ID', 目标对象.房间ID, 目标对象));
			
			内容.appendChild(创建字段('颜色索引', 当前单元格.颜色索引, 目标对象));
			            const hr = document.createElement('hr');
			hr.style.borderColor = '#444';
			内容.appendChild(hr);
			
			const oneWayTitle = document.createElement('h5');
			oneWayTitle.textContent = "单向门设置";
			内容.appendChild(oneWayTitle);
			
			const isOneWayCheckbox = 创建字段('isOneWay', 当前单元格.isOneWay, 当前单元格);
			const oneWayDirectionSelect = 创建字段('oneWayAllowedDirection', 当前单元格.oneWayAllowedDirection, 当前单元格);
			
			内容.appendChild(isOneWayCheckbox);
			内容.appendChild(oneWayDirectionSelect);
			
			const checkboxInput = isOneWayCheckbox.querySelector('input[type="checkbox"]');
			const selectContainer = oneWayDirectionSelect;
			
			selectContainer.style.display = checkboxInput.checked ? 'flex' : 'none';
			checkboxInput.addEventListener('change', () => {
			    selectContainer.style.display = checkboxInput.checked ? 'flex' : 'none';
			});
			    }
			    
			    if (目标对象 instanceof 钥匙) {
			        内容.appendChild(创建字段('对应门ID', 目标对象.自定义数据.get('对应门ID'), 目标对象, true));
			        内容.appendChild(创建字段('地牢层数', 目标对象.自定义数据.get('地牢层数'), 目标对象, true));
			        内容.appendChild(创建字段('颜色索引', 目标对象.颜色索引, 目标对象, false));
			    }
			
			    if (目标对象 instanceof 罐子) {
			        const 罐子标题 = document.createElement('h5');
			        罐子标题.textContent = '罐子内容';
			        内容.appendChild(罐子标题);
			
			        const 类型选择器 = document.createElement('select');
			        类型选择器.dataset.key = '内容物类型';
			        ['随机', '物品', '怪物'].forEach(类型 => {
			const 选项 = document.createElement('option');
			选项.value = 类型;
			选项.textContent = 类型;
			if (类型 === (目标对象.自定义数据.get('内容物类型') || '随机')) 选项.selected = true;
			类型选择器.appendChild(选项);
			        });
			        const 类型行 = 创建字段('内容物类型', null, 目标对象, true);
			        类型行.replaceChild(类型选择器, 类型行.querySelector('input'));
			        类型选择器.style.marginLeft = 'auto'; 
			        内容.appendChild(类型行);
			
			        const 类名选择器容器 = document.createElement('div');
			        const 类名选择器 = document.createElement('select');
			        类名选择器容器.style.cssText = 'display: flex; flex-direction: column; gap: 10px;';
			        类名选择器.dataset.key = '内容物类名';
			        const 随机层数容器 = document.createElement('div');
			        随机层数容器.style.display = 'none';
			        随机层数容器.appendChild(创建字段('随机层数', 目标对象.自定义数据.get('随机层数') || 999, 目标对象, true));
			
			        const 更新类名选项 = () => {
			const 选定类型 = 类型选择器.value;
			类名选择器.innerHTML = '';
			随机层数容器.style.display = 'none';
			类名选择器容器.style.display = 'none';
			
			if (选定类型 === '随机') {
			    随机层数容器.style.cssText = 'display: flex; flex-direction: column; gap: 10px;';
			} else {
			    类名选择器容器.style.cssText = 'display: flex; flex-direction: column; gap: 10px;';
			    const 无选项 = document.createElement('option');
			    无选项.value = '';
			    无选项.textContent = '无';
			    类名选择器.appendChild(无选项);
			
			    const 定义池 = 选定类型 === '物品' ? 获取所有可用的定义().items : 获取所有可用的定义().monsters;
			    定义池.forEach(定义 => {
			        const 实例 = new 定义.类({});
			        const 选项 = document.createElement('option');
			        选项.value = 定义.类.name;
			        选项.textContent = 实例.名称 || 实例.类型;
			        if (选项.value === 目标对象.自定义数据.get('内容物类名')) 选项.selected = true;
			        类名选择器.appendChild(选项);
			    });
			}
			        };
			        
			        类型选择器.onchange = 更新类名选项;
			        const 类名行 = 创建字段('内容物类名', null, 目标对象, true);
			        类名行.replaceChild(类名选择器, 类名行.querySelector('input'));
			        类名选择器.style.marginLeft = 'auto'; 
			        类名选择器容器.appendChild(类名行);
			        内容.appendChild(类名选择器容器);
			        内容.appendChild(随机层数容器);
			        更新类名选项();
			
			    }
			
			    if (目标对象.自定义数据 instanceof Map && !(目标对象 instanceof 告示牌)) {
			const 自定义标题 = document.createElement('h5');
			自定义标题.textContent = '自定义数据';
			自定义标题.style.marginTop = '15px';
			内容.appendChild(自定义标题);
			        目标对象.自定义数据.forEach((值, 键) => {
			    if (['string', 'number', 'boolean'].includes(typeof 值)) {
			    if (!['对应门ID', '地牢层数', '内容物类型', '内容物类名', '随机层数', '是否随机', '目标X', '目标Y', '自定义奖励','方向','巡逻方向', '监测状态', '脉冲范围', '脉冲冷却'].includes(键)) {
			        if (键 === '生成物类名' && 目标对象 instanceof 刷怪笼) return;
			        内容.appendChild(创建字段(键, 值, 目标对象, true));
			    }
			    }
			        });
			    }
			
			    保存按钮.onclick = () => {
			        saveEditorState();
			        if (当前编辑对象 instanceof 怪物) {
			const 掉落物选择 = 内容.querySelector('select[data-key="掉落物"]')?.value;
			if (掉落物选择 === 'original') {
			} else if (掉落物选择 === 'null') {
			    当前编辑对象.掉落物 = null;
			    当前编辑对象.掉落概率 = 0
			} else {
			    const ItemClass = window[掉落物选择];
			    if (ItemClass) {
			        let config = {};
			        if (掉落物选择 === '钥匙') {
			            const 钥匙ID行 = 内容.querySelector('select[data-key="钥匙对应房间ID"]');
			            const 房间ID = 钥匙ID行 ? parseInt(钥匙ID行.value, 10) : -1;
			            let 颜色索引 = 0;
			            if (房间ID !== -1) {
			                const 对应上锁房间 = 上锁房间列表.find(r => r.id === 房间ID);
			                if (对应上锁房间) 颜色索引 = 对应上锁房间.颜色索引 || 0;
			            }
			            config = { 对应门ID: 房间ID, 颜色索引: 颜色索引,地牢层数:-1 };
			        }
			        当前编辑对象.掉落物 = new ItemClass(config);
			    }
			}
			        }
			
			        if (当前编辑对象 instanceof 挑战石碑) {
			    const 奖励列表 = [];
			    内容.querySelectorAll('.reward-item').forEach(奖励行 => {
			            const 类名 = 奖励行.querySelector('select').value;
			            if (类名) {
			                奖励列表.push({ 类名: 类名, 配置: {} }); 
			            }
			    });
			    当前编辑对象.自定义数据.set('自定义奖励', 奖励列表);
			        }
			
			        if (当前编辑对象 instanceof 罐子) {
			const 类型选择器 = 内容.querySelector('select[data-key="内容物类型"]');
			const 类名选择器 = 内容.querySelector('select[data-key="内容物类名"]');
			const 随机层数输入框 = 内容.querySelector('input[data-key="随机层数"]');
			if (类型选择器 && 类名选择器 && 随机层数输入框) {
			    const 选定类型 = 类型选择器.value;
			    当前编辑对象.自定义数据.set('内容物类型', 选定类型);
			    if (选定类型 === '随机') {
			        当前编辑对象.自定义数据.set('随机层数', parseInt(随机层数输入框.value, 10) || 999);
			        当前编辑对象.自定义数据.delete('内容物类名');
			    } else {
			        当前编辑对象.自定义数据.set('内容物类名', 类名选择器.value);
			        当前编辑对象.自定义数据.delete('随机层数');
			    }
			}
			        }
			
			        内容.querySelectorAll('input, select, textarea').forEach(输入框 => {
			const 键 = 输入框.dataset.key;
			if (键==='掉落物') return;
			const 是自定义数据 = 输入框.dataset.isCustom === 'true';
			let 值 = 输入框.value;
			if (输入框.type === 'checkbox') 值 = 输入框.checked;
			else if (输入框.type === 'number' && !Number.isNaN(parseFloat(值))) 值 = parseFloat(值);
			            else if (输入框.tagName === 'SELECT' && 键 !== '类型' && 键 !== 'oneWayAllowedDirection' && 键 !== '对应门ID' && 键 !== '材质' && 键 !== '掉落物' && 键 !== '内容物类型' && 键 !== '内容物类名' && 键 !== '钥匙对应房间ID' && 键 !== '方向' && 键 !== '巡逻方向' && 键 !== '生成物类名' && 键 !== '监测状态') 值 = parseInt(值, 10);
			
			if (['上', '下', '左', '右'].includes(键)) {
			        当前单元格.墙壁[键] = 值;
			} else if(是自定义数据) {
			    if(键 === '对应门ID') 值 = parseInt(值, 10);
			    if (!['内容物类型', '内容物类名', '随机层数'].includes(键)) {
			
			            当前编辑对象.自定义数据.set(键, 值);
			        
			        if (当前编辑对象 instanceof 传送带) {
			            
			            上次放置的传送带 = 当前编辑对象;
			        }
			        if (当前编辑对象 instanceof 开关脉冲器) {
			            
			            上次放置的开关脉冲器 = 当前编辑对象;
			        }
			        if (当前编辑对象 instanceof 隐形毒气陷阱) {
			            
			            上次放置的隐形毒气陷阱 = 当前编辑对象;
			        }
			    }
			} else {
			    if (键 === '是否强制墙壁') {
			        当前单元格.是否强制墙壁 = 值;
			    } else if(输入框.dataset.parent === 'isLockedFlag'){
			        const 房间 = 当前编辑对象;
			        const 上锁房间索引 = 上锁房间列表.findIndex(lr => lr.id === 房间.id);
			        if (值 && 上锁房间索引 === -1) { 
			            房间.颜色索引 = 房间.颜色索引 || 0; 
			            上锁房间列表.push({...房间, 颜色索引: 房间.颜色索引});
			        } else if (!值 && 上锁房间索引 !== -1) { 
			            上锁房间列表.splice(上锁房间索引, 1);
			            delete 房间.颜色索引;
			        }
			        房间.门.forEach(门坐标 => {
			            const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
			            if(门单元格) {
			                门单元格.背景类型 = 值 ? 单元格类型.上锁的门 : 单元格类型.门;
			                if(值) 门单元格.颜色索引 = 房间.颜色索引 || 0;
			                const 门实例 = 门实例列表.get(门单元格.标识);
			                if (门实例) {
			                    门实例.类型 = 值 ? '上锁的门' : '门';
			                    门实例.是否上锁 = 值;
			                }
			                
			            }
			        });
			    } else if (输入框.dataset.parentKey === '挑战状态' && 当前编辑对象.id !== undefined) {
			        
			        if (!isNaN(值) || typeof 值 === 'boolean' || typeof 值 === 'string') {
			            当前编辑对象.挑战状态[键] = 值;
			        }
			    } else if (键 === '颜色索引') {
			        const 整数值 = parseInt(值);
			        if (是房间编辑器) {
			            const 房间 = 当前编辑对象;
			            房间.颜色索引 = 整数值;
			            const 上锁房间索引 = 上锁房间列表.findIndex(lr => lr.id === 房间.id);
			            if(上锁房间索引 !== -1) {
			                上锁房间列表[上锁房间索引].颜色索引 = 整数值;
			            }
			            房间.门.forEach(门坐标 => {
			                const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
			                if (门单元格 && 门单元格.背景类型 === 单元格类型.上锁的门) {
			                    门单元格.颜色索引 = 整数值;
			                }
			            });
			        } else if (当前编辑对象 instanceof 门) {
			            当前单元格.颜色索引 = 整数值;
			        } else {
			            当前编辑对象[键] = 整数值;
			        }
			    } else if (键 === '关联房间ID' && 当前编辑对象 instanceof 门) {
			        const 新房间ID = 值 === -1 || Number.isNaN(parseInt(值)) ? null : parseInt(值);
			        const 旧房间ID = 当前编辑对象.房间ID;
			        
			        if (旧房间ID !== null && 房间列表[房间列表.findIndex(item=>item?.id==旧房间ID)]) {
			            房间列表[房间列表.findIndex(item=>item?.id==旧房间ID)].门 = 房间列表[房间列表.findIndex(item=>item?.id==旧房间ID)].门.filter(门坐标 => !(门坐标.x === 当前编辑对象.所在位置.x && 门坐标.y === 当前编辑对象.所在位置.y));
			        }
			        
			        当前编辑对象.房间ID = 新房间ID;
			        
			        if (新房间ID !== null && 房间列表[房间列表.findIndex(item=>item?.id==新房间ID)]) {
			            if (!房间列表[房间列表.findIndex(item=>item?.id==新房间ID)].门.some(门坐标 => 门坐标.x === 当前编辑对象.所在位置.x && 门坐标.y === 当前编辑对象.所在位置.y)) {
			                房间列表[房间列表.findIndex(item=>item?.id==新房间ID)].门.push({...当前编辑对象.所在位置});
			            }
			        }
			        房间列表.sort((a,b)=>a.id-b.id)
			    } else if ((键 === '是否上锁' || 键 === 'isOneWay' || 键 === 'oneWayAllowedDirection') && ([单元格类型.门, 单元格类型.上锁的门].includes(当前单元格.背景类型) || 当前编辑对象 instanceof 门)) {
			        const cellToUpdate = 当前编辑对象 instanceof 门 ? 地牢[当前编辑对象.所在位置.y][当前编辑对象.所在位置.x] : 当前编辑对象;
			        const doorInstance = 当前编辑对象 instanceof 门 ? 当前编辑对象 : 门实例列表.get(当前编辑对象.标识);
			        if (键 === '是否上锁' && doorInstance) {
			            doorInstance.是否上锁 = 值;
			            cellToUpdate.背景类型 = 值 ? 单元格类型.上锁的门 : 单元格类型.门;
			            doorInstance.类型 = 值 ? '上锁的门' : '门';
			        } else {
			            cellToUpdate[键] = 值;
			        }
			        const 配对位置 = cellToUpdate.配对单元格位置;
			        if (配对位置) {
			            const 配对单元格 = 地牢[配对位置.y]?.[配对位置.x];
			            if (配对单元格) {
			                    if (键 === '是否上锁' && doorInstance) {
			                    配对单元格.背景类型 = 值 ? 单元格类型.上锁的门 : 单元格类型.门;
			                    } else {
			                    配对单元格[键] = 值;
			                    }
			            }
			        }
			    } else if (键 === 'id' && 是房间编辑器) {
			        const 新ID = parseInt(值);
			        const 旧ID = 当前编辑对象.id;
			        if (新ID !== 旧ID && !Number.isNaN(新ID) && !房间列表.some(item=>item?.id==新ID)) {
			            
			            房间列表.splice(房间列表.indexOf(当前编辑对象),1);
			            房间列表.push(当前编辑对象);
			            房间列表.sort((a,b)=>a.id-b.id)
			            当前编辑对象.id = 新ID;
			            for(let ry = 当前编辑对象.y; ry < 当前编辑对象.y + 当前编辑对象.h; ry++) {
			                for(let rx = 当前编辑对象.x; rx < 当前编辑对象.x + 当前编辑对象.w; rx++) {
			                    if(房间地图[ry]?.[rx] === 旧ID) {
			                        房间地图[ry][rx] = 新ID;
			                    }
			                }
			            }
			            当前编辑对象.门.forEach(门坐标 => {
			                const 门实例 = 门实例列表.get(地牢[门坐标.y][门坐标.x].标识);
			                
			                if (门实例) 门实例.房间ID = 新ID;
			            });
			        } else if (新ID !== 旧ID) {
			            显示通知(`房间ID ${新ID} 已存在或无效！`, '错误');
			        }
			    } else {
			        if (键 === '类型' && 是房间编辑器) {
			            return;
			        }
			        if(键) {
			            当前编辑对象[键] = 值;
			            
			        }
			    }
			}
			if (当前编辑对象 instanceof 巡逻怪物) 当前编辑对象.初始巡逻();
			if (当前编辑对象 instanceof 蜈蚣怪物) {
    const 长度输入框 = 内容.querySelector('input[data-key="长度"]');
    if (长度输入框) {
        const 新长度 = parseInt(长度输入框.value);
        if (!isNaN(新长度) && 新长度 > 0 && 新长度 !== 当前编辑对象.长度) {
            当前编辑对象?.身体部位?.forEach(item=>{item.移除自身(true)});
            当前编辑对象.长度 = 新长度;
            当前编辑对象.身体部位 = []
            当前编辑对象.初始化身体部位();
            显示通知("蜈蚣长度已更新。", "成功");
        }
    }
}
			        });
			if (是房间编辑器) {
			const 房间 = 当前编辑对象;
			const 旧类型 = 房间.类型;
			const 新类型 = 内容.querySelector('select[data-key="类型"]').value;
			
			if (新类型 !== 旧类型) {
			    清空房间内容(房间);
			    房间.类型 = 新类型;
			    
			    delete 房间.棋子数量;
			    
			    switch(新类型) {
			        
			        case '隐藏解谜棋盘':
			            生成解谜棋盘(房间);
			            break;
			        case '隐藏罐子房间':
			            生成罐子房间内容(房间);
			            break;
			        case '隐藏植物房间':
			            生成植物房间内容(房间);
			            break;
			        case '隐藏书库房间':
			            生成书库房间内容(房间);
			            break;
			        case '隐藏药水房间':
			            生成药水房内容(房间);
			            break;
			    }
			}
			
			房间.挑战状态.候选怪物池 = [];
			内容.querySelectorAll('input[type="checkbox"][data-class-name]').forEach(checkbox => {
			    if (checkbox.checked) {
			        房间.挑战状态.候选怪物池.push(checkbox.dataset.className);
			    }
			});
			
			const 是起始房间 = (
			    玩家初始位置.x >= 房间.x && 玩家初始位置.x < 房间.x + 房间.w &&
			    玩家初始位置.y >= 房间.y && 玩家初始位置.y < 房间.y + 房间.h
			);
			const 已探索 = 内容.querySelector('input[data-key="已探索"]').checked;
			if (是起始房间 && !已探索) {
			    
			    房间.已探索 = true; 
			    const 已探索输入框 = 内容.querySelector('input[data-key="已探索"]');
			    if (已探索输入框) 已探索输入框.checked = true;
			} else {
			    房间.已探索 = 已探索;
			}
			        }
			        for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const cell = 地牢[y][x];
			            if (cell.关联物品 instanceof 神秘商人) {
			                cell.关联物品.生成库存(Math.max(cell.关联物品.自定义数据.get('商品层数'), 0));
			            } else if (cell.关联物品 instanceof 探险家) {
			                cell.关联物品.生成收购需求(cell.关联物品.自定义数据.get('需求层数'));
			            }
			        }
			    }
			        生成墙壁();
			        显示通知('属性已保存', '成功');
			        关闭属性编辑器();
			    };
			    删除按钮.onclick = () => {
			        saveEditorState();
			        if (当前单元格 && (当前单元格.关联物品 === 对象.关联物品 || 当前单元格.关联怪物 === 对象.关联怪物)) {
			重置单元格(横坐标,纵坐标);
			        } else if (对象 instanceof 单元格 && [单元格类型.门, 单元格类型.上锁的门].includes(对象.背景类型)) {
			重置单元格(横坐标, 纵坐标); 
			        } else if (对象.id !== undefined && 房间列表[房间列表.findIndex(item=>item?.id==对象.id)] === 对象) {
			const 房间 = 房间列表[房间列表.findIndex(item=>item?.id==对象.id)];
			for(let ry = 房间.y; ry < 房间.y + 房间.h; ry++){
			        for(let rx = 房间.x; rx < 房间.x + 房间.w; rx++){
			            房间地图[ry][rx] = -1;
			        }
			}
			const 上锁房间索引 = 上锁房间列表.findIndex(lr => lr.id === 房间.id);
			if(上锁房间索引 !== -1) {
			    上锁房间列表.splice(上锁房间索引, 1);
			}
			房间列表.filter(item => item !== 对象);
			生成墙壁();
			        }
			        显示通知('对象已删除', '成功');
			        关闭属性编辑器();
			    };
			
			    关闭按钮.onclick = 关闭属性编辑器;
			    遮罩.style.display = 'block';
			}
			
			function 清空房间内容(房间) {
			    if (!房间) return;
			    
			    for (let 纵坐标 = 房间.y; 纵坐标 < 房间.y + 房间.h; 纵坐标++) {
			        for (let 横坐标 = 房间.x; 横坐标 < 房间.x + 房间.w; 横坐标++) {
			            const 单元格 = 地牢[纵坐标]?.[横坐标];
			            if (单元格) {
			                // 移除物品
			                if (单元格.关联物品) {
			                    // 如果物品在计时器列表中，也一并移除
			                    const 计时器索引 = 所有计时器.findIndex(计时器 => 计时器.唯一标识 === 单元格.关联物品.唯一标识);
			                    if (计时器索引 !== -1) {
			                        所有计时器.splice(计时器索引, 1);
			                    }
			                    单元格.关联物品 = null;
			                }
			                // 移除怪物
			                if (单元格.关联怪物) {
			                    所有怪物 = 所有怪物.filter(怪物 => 怪物 !== 单元格.关联怪物);
			                    单元格.关联怪物 = null;
			                }
			                // 重置单元格类型，但保留背景类型
			                if (单元格.类型 !== null) {
			                    单元格.类型 = null;
			                }
			            }
			        }
			    }
			    绘制();
			}
			function 关闭属性编辑器() {
			    const 遮罩 = document.getElementById('编辑器属性面板遮罩');
			    遮罩.style.display = 'none';
			    编辑器状态.选中实例 = null;
			    绘制小地图();
			}
			
			            function 下载地图文件() {
			    const 地图字符串 = 导出地图();
			    if (!地图字符串) {
			        显示通知('导出地图失败！', '错误');
			        return;
			    }
			    const 数据块 = new Blob([地图字符串], { type: 'application/json' });
			    const 下载链接 = URL.createObjectURL(数据块);
			    const 链接元素 = document.createElement('a');
			    链接元素.href = 下载链接;
			    const 时间戳 = new Date().toISOString().replace(/[:.]/g, "-");
			    链接元素.download = `自定义地图_${时间戳}.json`;
			    document.body.appendChild(链接元素);
			    链接元素.click();
			    document.body.removeChild(链接元素);
			    URL.revokeObjectURL(下载链接);
			    显示通知('地图已导出!', '成功');
			}
			
			function 进入编辑器游玩模式() {
			    处理房间状态();
			    编辑器状态备份 = 导出地图();
			    编辑器玩家 = {...玩家}
			    if(!编辑器状态备份) {
			        显示通知("无法备份地图状态，无法进入游玩模式。", "错误");
			        return;
			    }
			
			    游戏状态 = '编辑器游玩';
			    document.body.classList.remove('地图编辑器模式');
			    document.body.classList.add('编辑器游玩模式');
			    document.body.classList.add('游戏进行中');
			    document.getElementById('编辑器工具栏').style.display = 'none';
			    document.getElementById('笔刷工具容器').style.display = 'none';
			    document.getElementById('扳手工具菜单').style.display = 'none';
			    document.getElementById('返回编辑器按钮').style.display = 'block';
			
			    canvas.removeEventListener('mousedown', 编辑器鼠标按下处理);
			    canvas.removeEventListener('mousemove', 编辑器鼠标移动处理);
			    canvas.removeEventListener('mouseup', 编辑器鼠标抬起处理);
			    canvas.removeEventListener('touchstart', 编辑器触摸开始处理);
			    canvas.removeEventListener('touchmove', 编辑器触摸移动处理);
			    canvas.removeEventListener('touchend', 编辑器触摸结束处理);
			    canvas.removeEventListener('contextmenu', 编辑器右键处理);
			
			    //canvas.addEventListener("touchstart", 处理地图点击);
			    canvas.addEventListener("click", 处理地图单击);
			    
			    document.getElementById("背包物品栏").innerHTML = '';
			    玩家背包.clear();
			    const 背包弹窗 = document.querySelector('.背包弹窗');
			    const 背包标题元素 = 背包弹窗.querySelector(':scope > .弹窗头部 > h3');
			    if (背包标题元素) {
			        背包标题元素.innerHTML = `背包 (容量：<span id="当前容量">0</span>/<span id="最大容量">${最大背包容量}</span>)`;
			    }
			    const 互动按钮元素 = document.getElementById('互动按钮');
			    if (互动按钮元素) 互动按钮元素.style.background = '';
			    Object.assign(玩家属性, 自定义全局设置.玩家属性);
			    玩家属性.最大生命值加成 = 自定义全局设置.初始生命值 - 100;
			    初始玩家属性.最大生命值加成 = 自定义全局设置.初始生命值 - 100;
			    初始玩家属性 = {...玩家属性};
			
			    最大背包容量 = 自定义全局设置.初始背包容量;
			    
			    document.querySelector(".health-bar").style.width = "100%";
			    document.querySelector(".power-bar").style.width = "100%";
			    
			    
			    玩家总移动回合数 = 0;
			    玩家总受到伤害 = 0;
			    
			    当前天气效果 = [...自定义全局设置.全局天气];
			    if (当前天气效果.length > 0) {
			        显示通知(`当前天气: ${当前天气效果.join(', ')}`, '信息', true);
			    }
			
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			    玩家属性.允许移动 = 0;
			    for (let i=0;i<Math.ceil(Math.random()*10);i++) prng()
			    
			
			    const 玩家起始房间ID = 房间地图[玩家.y]?.[玩家.x];
			    if (玩家起始房间ID !== -1 && 玩家起始房间ID !== undefined) {
			        已访问房间.add(玩家起始房间ID);
			    }
			    所有怪物.forEach(monster => {
			if (monster instanceof 巡逻怪物) {
			    monster.初始巡逻();
			}
			        });
			        
			    for (let y = 0; y < 地牢大小; y++) {
			        for (let x = 0; x < 地牢大小; x++) {
			            const cell = 地牢[y][x];
			            if (cell?.关联物品?.玩家放置) {
			                if(!所有计时器.some(t => t.唯一标识 === cell.关联物品.唯一标识)) {
			            所有计时器.push(cell.关联物品);
			        }
			                
			            }
			        }
			    }
			    更新装备显示();
			    更新背包显示();
			    更新视口(true);
			    更新光源地图();
			    更新洞穴视野();
			    绘制小地图();
			    更新胜利条件显示();
			    处理沉浸式传送门();
			    绘制();
			
			    显示通知('已进入游玩模式。点击左上角按钮返回。', '信息');
			}
			function 导出地图() {
			    处理房间状态();
			    玩家背包.clear();
			    const 地图存档数据 = 保存游戏状态(); 
			    填充编辑器背包();
			    return 地图存档数据;
			}
			
			function 导入地图(存档字符串) {
			     try {
			        const 地图数据 = JSON.parse(存档字符串);
			        if (!地图数据 || (!地图数据.版本 && !地图数据.编辑器状态数据)) {
			            显示通知("地图或存档数据无效！", "错误");
			            return;
			        }
			
			        if (游戏状态 === '地图编辑器') {
			            if (地图数据.isPublished) {
			                显示通知("编辑器无法加载已发布的创意关卡！", "错误");
			                return;
			            }
			            if (地图数据.版本 && !地图数据.编辑器状态数据) {
			                显示通知("编辑器无法加载游戏存档文件！", "错误");
			                return;
			            }
			        }
			        
			        重置所有游戏状态(); 
			        恢复游戏状态(地图数据);
			
			        游戏状态 = "地图编辑器";
			        最高教程阶段 = 6;
			        document.body.classList.add("地图编辑器模式");
			        document.body.classList.remove("游戏进行中", "编辑器游玩模式");
			        更新编辑器快速访问栏();
			        
			        获取所有可用的定义();
			        填充编辑器背包();
			        
			        玩家.x = 地图数据.玩家.x;
			        玩家.y = 地图数据.玩家.y;
			        
			        更新视口();
			        绘制小地图();
			        
			        显示通知("地图加载成功！", "成功");
			    } catch (错误) {
			        console.error("导入地图失败:", 错误);
			        显示通知("导入地图失败，文件格式错误。", "错误");
			        进入地图编辑器(); 
			    }
			}
			
			
			
			function 序列化单元格(单元格实例, 物品标识映射, 怪物索引映射) {
			    if (!单元格实例) return null;
			    try {
			        const 序列化数据 = {};
			        
			        if (单元格实例.类型 !== 单元格类型.墙壁) 序列化数据.类型 = 单元格实例.类型;
			        if (单元格实例.背景类型 !== 单元格类型.墙壁) 序列化数据.背景类型 = 单元格实例.背景类型;
			        if (单元格实例.是否强制墙壁) 序列化数据.是否强制墙壁 = true;
			        
			        const 墙壁数据 = {};
			        let 有墙 = false;
			        for (const 方向 in 单元格实例.墙壁) {
			            if (单元格实例.墙壁[方向]) {
			                墙壁数据[方向] = true;
			                有墙 = true;
			            }
			        }
			        if (有墙) 序列化数据.墙壁 = 墙壁数据;
			
			        if (单元格实例.钥匙ID !== null) 序列化数据.钥匙ID = 单元格实例.钥匙ID;
			        if (单元格实例.颜色索引 !== 颜色表.length) 序列化数据.颜色索引 = 单元格实例.颜色索引;
			
			        if (单元格实例.类型 === 单元格类型.楼梯下楼 || 单元格实例.类型 === 单元格类型.楼梯上楼) {
			            if (单元格实例.关联物品?.图标) 序列化数据.关联物品图标 = 单元格实例.关联物品.图标;
			        } else if (单元格实例.关联物品) {
			            const 关联物品标识 = 物品标识映射.get(单元格实例.关联物品.唯一标识);
			            if (关联物品标识) {
			                序列化数据.关联物品标识 = 关联物品标识;
			            } else {
			                const serializedItem = 序列化物品(单元格实例.关联物品);
			                if (serializedItem) {
			                    序列化数据.关联物品标识 = serializedItem.唯一标识符串;
			                    if (!物品标识映射.has(单元格实例.关联物品.唯一标识)) {
			                        物品标识映射.set(单元格实例.关联物品.唯一标识, 序列化数据.关联物品标识);
			                    }
			                }
			            }
			        }
			        
			        if (单元格实例.关联怪物) {
			            const 关联怪物索引 = 怪物索引映射.get(单元格实例.关联怪物);
			            if (关联怪物索引 !== undefined) {
			               序列化数据.关联怪物索引 = 关联怪物索引;
			            }
			        }
			
			        if (单元格实例.标识) 序列化数据.标识符串 = 单元格实例.标识.toString();
			        if (单元格实例.配对单元格位置) 序列化数据.配对单元格位置 = { ...单元格实例.配对单元格位置 };
			        if (单元格实例.isOneWay) 序列化数据.isOneWay = true;
			        if (单元格实例.oneWayAllowedDirection) 序列化数据.oneWayAllowedDirection = 单元格实例.oneWayAllowedDirection;
			        if (单元格实例.doorOrientation) 序列化数据.doorOrientation = 单元格实例.doorOrientation;
			        if (单元格实例.阻碍视野) 序列化数据.阻碍视野 = 单元格实例.阻碍视野;
			
			        return 序列化数据;
			    } catch (e) {
			        console.error(`序列化单元格 (${单元格实例.x}, ${单元格实例.y}) 失败:`, e);
			        return null;
			    }
			}
			
function 保存游戏状态() {
			    console.log("开始打包游戏状态...");
			    try {
			        const 全局物品标识映射 = new Map();
			        [...玩家背包.values(), ...玩家装备.values()].forEach(
			            (物品实例) => {
			                if (物品实例) {
			                    全局物品标识映射.set(
			                        物品实例.唯一标识,
			                        物品实例.唯一标识.toString()
			                    );
			                }
			            }
			        );
					当前出战宠物列表.forEach(pet => {
						全局物品标识映射.set(
			                pet.唯一标识,
			                pet.唯一标识.toString()
			            );
});
			        const 当前楼层所有怪物 = 所有地牢层.get(当前层数)?.所有怪物 || [];
			        const 怪物索引映射 = new Map();
			        当前楼层所有怪物.forEach((怪物, 索引) => 怪物索引映射.set(怪物, 索引));
			
			        const 序列化玩家背包 = Array.from(玩家背包.values())
			            .map(序列化物品)
			            .filter((物品数据) => 物品数据 != null);
			
			        const 序列化玩家装备 = Array.from(玩家装备.entries())
			            .map(([槽位, 物品实例]) =>
			                物品实例
			                    ? {
			                          槽位: 槽位,
			                          唯一标识符串: 全局物品标识映射.get(
			                              物品实例.唯一标识
			                          ),
			                      }
			                    : null
			            )
			            .filter((装备数据) => 装备数据 != null);
			
			        const 序列化玩家状态 = 玩家状态
			            .map((状态实例) => {
			                let 来源标识符串 = null;
			                if (状态实例.来源 && 状态实例.来源.唯一标识) {
			                    来源标识符串 = 全局物品标识映射.get(
			                        状态实例.来源.唯一标识
			                    );
			                }
			                return {
			                    类型: 状态实例.类型,
			                    颜色: 状态实例.颜色,
			                    图标: 状态实例.图标,
			                    持续时间: 状态实例.持续时间,
			                    剩余回合: 状态实例.剩余回合,
			                    强度: 状态实例.强度,
			                    来源类名: 状态实例.来源?.constructor.name,
			                    来源标识符串: 来源标识符串,
			                };
			            })
			            .filter((状态数据) => 状态数据 != null);
			
			        const 序列化激活卷轴 = Array.from(当前激活卷轴列表)
			            .map((卷轴实例) =>
			                全局物品标识映射.get(卷轴实例.唯一标识)
			            )
			            .filter((标识符串) => 标识符串 != null);
			
			        const 当前楼层临时数据 = {
			            地牢数组: 地牢,
			            房间列表: 房间列表,
			            上锁房间列表: 上锁房间列表,
			            已访问房间: 已访问房间,
			            房间地图: 房间地图,
			            门实例列表: 门实例列表,
			            所有怪物: 所有怪物,
			            所有计时器: 所有计时器,
			            玩家初始位置: 玩家初始位置,
			            玩家位置: 玩家,
			            当前天气效果: 当前天气效果.length == 0 ? 自定义全局设置.全局天气 : 当前天气效果,
			            已放置配方卷轴:
			                所有地牢层.get(当前层数)?.已放置配方卷轴 || false,
			            地牢生成方式: 地牢生成方式,
			            已揭示洞穴格子: deepClone(已揭示洞穴格子),
			        };
			
			        const 序列化所有楼层数据 = {};
			        for (const [层号, 楼层数据] of 所有地牢层.entries()) {
			            if (层号 !== 当前层数)
			                序列化所有楼层数据[层号] = 序列化楼层(
			                    层号,
			                    楼层数据,
			                    全局物品标识映射
			                );
			        }
			        if (当前层数 !== null) {
			            序列化所有楼层数据[当前层数] = 序列化楼层(
			                当前层数,
			                当前楼层临时数据,
			                全局物品标识映射
			            );
			        }
			        const 序列化所有传送门 = 所有传送门.map(p => 序列化物品(p)).filter(Boolean);
			
			        const 当前生命值百分比 =
			            parseFloat(
			                document.querySelector(".health-bar")?.style.width
			            ) || 100;
			        const 当前能量值百分比 =
			            parseFloat(
			                document.querySelector(".power-bar")?.style.width
			            ) || 100;

					let 编辑器状态数据 = {};
					if (游戏状态 === '地图编辑器') {
						编辑器状态数据 = {
							玩家位置: { x: 玩家.x, y: 玩家.y },
							相机位置: { x: 当前相机X, y: 当前相机Y },
							模式: 编辑器状态.模式,
							工具栏模式: 编辑器工具栏模式,
							当前选中: null,
							笔刷设置: {
								模式: 编辑器状态.笔刷模式,
								形状: 编辑器状态.笔刷形状,
								半径: 编辑器状态.笔刷半径,
							},
							最近使用列表: 编辑器最近使用列表.map((实例) => {
								const isVirtual = !(实例 instanceof 物品) && !(实例 instanceof 怪物);
								if (isVirtual) {
									return {
										isVirtual: true,
										名称: 实例.名称,
										类型: 实例.类型,
										图标: 实例.图标,
										绘制类型: 实例.绘制类型,
										类: 实例.类?.name
									};
								} else if (实例 instanceof 怪物) {
									return {
										isVirtual: false,
										图鉴类型: "怪物",
										类名: 实例.constructor.name,
									};
								} else {
									return {
										isVirtual: false,
										图鉴类型: "物品",
										类名: 实例.constructor.name,
									};
								}
							}),
						};
						if (编辑器状态.当前选中) {
							const isVirtual = !(编辑器状态.当前选中 instanceof 物品) && !(编辑器状态.当前选中 instanceof 怪物);
							if(isVirtual) {
								编辑器状态数据.当前选中 = {
									isVirtual: true,
									名称: 编辑器状态.当前选中.名称,
									类型: 编辑器状态.当前选中.类型,
									图标: 编辑器状态.当前选中.图标,
									绘制类型: 编辑器状态.当前选中.绘制类型,
									类: 编辑器状态.当前选中.类?.name
								};
							} else if (编辑器状态.当前选中 instanceof 怪物) {
								编辑器状态数据.当前选中 = { isVirtual: false, 图鉴类型: '怪物', 类名: 编辑器状态.当前选中.constructor.name };
							} else {
								编辑器状态数据.当前选中 = { isVirtual: false, 图鉴类型: '物品', 类名: 编辑器状态.当前选中.constructor.name };
							}
						}
					}
			
			        const 存档数据 = {
			            版本: 存档版本,
			            游戏版本: 游戏版本,
			            保存时间: new Date().toISOString(),
			            当前游戏种子: 当前游戏种子 || Date.now().toString(),
			            玩家职业: 玩家职业,
			            所有传送门: 序列化所有传送门,
			            游戏开始时间: 游戏开始时间,
			            红蓝开关状态: 红蓝开关状态,
			            绿紫开关状态: 绿紫开关状态,
			            自定义全局设置: {...自定义全局设置,
			                            全局天气: 自定义全局设置.全局天气.length > 0 ? 自定义全局设置.全局天气 : 当前天气效果},
			            编辑器状态数据: 编辑器状态数据,
			            地图标记: Object.fromEntries(Array.from(地图标记.entries()).map(([k, v]) => [k, v])),
			            当前层数: 当前层数,
			            玩家: {
			                x: 玩家.x,
			                y: 玩家.y,
			                属性: { ...玩家属性 },
			                最大背包容量: 最大背包容量,
			                背包:
			                    游戏状态 !== "地图编辑器"
			                        ? 序列化玩家背包
			                        : [],
			                装备: 序列化玩家装备,
			                状态: 序列化玩家状态,
			                当前生命值百分比: 当前生命值百分比,
			                当前能量值百分比: 当前能量值百分比,
			                最大背包容量: 最大背包容量,
			                最大装备槽数量: 最大装备槽数量,
			            },
			            当前出战宠物列表: 当前出战宠物列表.map(pet => 序列化物品(pet)).filter(Boolean),
			            教程: {
			                阶段: 教程阶段,
			                最高阶段: 最高教程阶段,
			                是否教程层: 是否为教程层,
			            },
			            UI: {
			                hud模式: hud模式,
			                显示模式: 显示模式,
			                激活卷轴列表: 序列化激活卷轴,
			                日志历史:
			                    游戏状态 !== "地图编辑器" ? 日志历史 : [],
			                当前装备页: 当前装备页,
			            },
			            游戏统计: { 
			                已击杀怪物数: 已击杀怪物数,
			                玩家总移动回合数: 玩家总移动回合数,
			                玩家总受到伤害: 玩家总受到伤害
			            },
			            所有地牢层数据: 序列化所有楼层数据,
			            传送点列表: 传送点列表.map((点) => ({ ...点 })),
			            上次死亡地点: 上次死亡地点
			                ? { ...上次死亡地点 }
			                : null,
			            永久Buffs: {
			                ...永久Buffs,
			                已获得效果: Array.from(
			                    永久Buffs.已获得效果 || []
			                ),
			            },
			            生存挑战激活: 生存挑战激活,
			            序列化生存挑战备份单元格: 生存挑战备份单元格.map(
			                (备份) => ({
			                    x: 备份.x,
			                    y: 备份.y,
			                    类型: 备份.类型,
			                    背景类型: 备份.背景类型,
			                    墙壁: { ...备份.墙壁 },
			                    关联物品标识: 备份.关联物品
			                        ? 全局物品标识映射.get(
			                              备份.关联物品.唯一标识
			                          )
			                        : null,
			                    关联怪物索引: 备份.关联怪物
			                        ? 怪物索引映射.get(备份.关联怪物)
			                        : null,
			                    颜色索引: 备份.颜色索引,
			                    标识: 备份.标识 ? 备份.标识.toString() : null,
			                })
			            ),
			            配方信息: {
			                程序生成配方列表: 程序生成配方列表,
			                已发现的程序生成配方: 已发现的程序生成配方,
			            },
			        };
			        const 序列化数据 = JSON.stringify(存档数据, null, 2);
			        console.log("游戏状态打包完成！");
			        return 序列化数据;
			    } catch (错误) {
			        console.error("打包游戏状态失败:", 错误);
			        显示通知("打包游戏状态失败！", "错误");
			        return null;
			    }
			}
			
			function 恢复游戏状态(存档数据, 是否是创意关卡 = false) {
			    if (存档数据.游戏版本 && 存档数据.游戏版本 > 游戏版本) {
			    显示通知(`存档版本 (${存档数据.游戏版本}) 高于当前游戏版本 (${游戏版本})，无法加载！`, "错误");
			    
			    return;
			}
			    console.log("开始恢复游戏状态...");
			    if (!存档数据) {
			        console.error("无效的存档数据，无法恢复。");
			        显示通知("存档数据损坏，无法加载！", "错误");
			        return;
			    }
			    重置所有游戏状态();
			    try {
			        当前层数 = 存档数据.当前层数 ?? 0;
			        地图标记 = new Map(Object.entries(存档数据.地图标记 || {}).map(([k, v]) => [parseInt(k, 10), v]));
			        游戏开始时间 = 存档数据.游戏开始时间 || Date.now();
			        当前游戏种子 = 存档数据.当前游戏种子 || Date.now().toString();
			        初始化随机数生成器(当前游戏种子);
			        自定义全局设置 = 存档数据.自定义全局设置 || {
			    初始生命值: 100,
			    初始能量值: 100,
			    初始背包容量: 12,
			    玩家属性: {
			        移动步数: 1,
			        攻击加成: 0,
			        防御加成: 0,
			    },
			    胜利条件: {
			        回合数限制: 0,
			        伤害限制: 0,
			        生命下限: 0,
			        清除所有怪物: false,
			        死亡次数限制: 0,
			    },
			    全局天气: [],
			    禁用传送菜单: false,
			    诡魅天气怪物层级: 1,
			    奖励物品层级: 1,
			};
			//if (是否是自定义关卡) {
						if (存档数据.作者设置_相机视野) {
							相机显示边长 = 存档数据.作者设置_相机视野;
							游戏设置.相机视野大小 = 存档数据.作者设置_相机视野;
							自定义全局设置.作者设置_相机视野 = 存档数据.作者设置_相机视野;
						}
						if (存档数据.作者设置_受伤击退 !== undefined) {
							游戏设置.受伤时击退 = 存档数据.作者设置_受伤击退;
							自定义全局设置.作者设置_受伤击退 = 存档数据.作者设置_受伤击退;
						}
						if (存档数据.强制动画模式 !== undefined) {
							切换动画 = 存档数据.强制动画模式;
							自定义全局设置.强制动画模式 = 存档数据.强制动画模式;
						}
					//}
			        
			        教程阶段 = 存档数据.教程?.阶段 ?? 0;
			        玩家职业 = 存档数据.玩家职业 || null;
			        最高教程阶段 = 存档数据.教程?.最高阶段 ?? 0;
			        是否为教程层 = 存档数据.教程?.是否教程层 ?? false;
			        hud模式 = 存档数据.UI?.hud模式 ?? "默认";
			        显示模式 = 存档数据.UI?.显示模式 ?? "装备";
			        日志历史 = 存档数据.UI?.日志历史 || [];
			        最大装备槽数量 = 存档数据.玩家?.最大装备槽数量 ?? 8;
			        红蓝开关状态 = 存档数据?.红蓝开关状态 ?? '红';
			        绿紫开关状态 = 存档数据?.绿紫开关状态 ?? '绿';
			        当前装备页 = 存档数据.UI?.当前装备页 ?? 0;
			        上次死亡地点 = 存档数据.上次死亡地点 || null;
			        程序生成配方列表 =
			            存档数据.配方信息?.程序生成配方列表 || [];
			        已发现的程序生成配方 =
			            存档数据.配方信息?.已发现的程序生成配方 || [];
			
			        已发现的程序生成配方.forEach((discoveredRecipe) => {
			            if (
			                !融合配方列表.some(
			                    (r) => r.说明 === discoveredRecipe.说明
			                )
			            ) {
			                融合配方列表.push(discoveredRecipe);
			            }
			        });
			
			        日志历史.forEach((log) => 添加日志(log.内容, log.类型));
			        
			        const 全局物品实例映射 = new Map();
			        const 全局物品标识映射 = new Map();
			        
			        当前天气效果 = null;
			
			        if (是否是创意关卡) {
			            玩家属性 = { ...初始玩家属性, ...自定义全局设置.玩家属性 };
			            初始玩家属性 = {...玩家属性};
			            玩家属性.最大生命值加成 = 自定义全局设置.初始生命值 - 100;
			            初始玩家属性.最大生命值加成 = 自定义全局设置.初始生命值 - 100;
			            当前天气效果 = 自定义全局设置.全局天气
			            最大背包容量 = 自定义全局设置.初始背包容量;
			            玩家背包 = new Map();
			            玩家装备 = new Map();
			            玩家状态 = [];
			            当前激活卷轴列表 = new Set();
			        } else {
			            玩家属性 = { ...初始玩家属性, ...(存档数据.玩家?.属性 || {}) };
			            最大背包容量 = 存档数据.玩家?.最大背包容量 ?? 12;
			            已击杀怪物数 = 存档数据.游戏统计?.已击杀怪物数 ?? 0;
			            玩家总移动回合数 = 存档数据.游戏统计?.玩家总移动回合数 ?? 0;
			            玩家总受到伤害 = 存档数据.游戏统计?.玩家总受到伤害 ?? 0;
			            击杀提示.更新({ 内容: `已击杀怪物: ${已击杀怪物数}` });
			
			            玩家背包 = new Map();
			            if (存档数据.玩家?.背包) {
			                存档数据.玩家.背包.forEach((物品数据) => {
			                    const 实例 = 恢复物品(物品数据, 全局物品标识映射);
			                    if (实例) {
			                        玩家背包.set(实例.唯一标识, 实例);
			                        全局物品实例映射.set(物品数据.唯一标识符串, 实例);
			                    }
			                });
			            }
			
			            玩家装备 = new Map();
			            if (存档数据.玩家?.装备) {
			                存档数据.玩家.装备.forEach((装备数据) => {
			                    const 实例 = 全局物品实例映射.get(装备数据.唯一标识符串);
			                    if (实例) {
			                        实例.已装备 = true;
			                        实例.装备槽位 = 装备数据.槽位;
			                        玩家装备.set(实例.装备槽位, 实例);
			                    }
			                });
			            }
			            
			            玩家状态 = [];
			            if (存档数据.玩家?.状态) {
			                存档数据.玩家.状态.forEach((状态数据) => {
			                    let 来源实例 = null;
			                    if (状态数据.来源标识符串) {
			                        来源实例 = 全局物品实例映射.get(状态数据.来源标识符串);
			                    }
			                    new 状态效果(状态数据.类型, 状态数据.颜色, 状态数据.图标, 状态数据.持续时间, 状态数据.剩余回合, 来源实例, null, 状态数据.强度);
			                });
			            }
			
			            当前激活卷轴列表 = new Set();
			            if (存档数据.UI?.激活卷轴列表) {
			                存档数据.UI.激活卷轴列表.forEach((标识符串) => {
			                    const 实例 = 全局物品实例映射.get(标识符串);
			                    if (实例 instanceof 卷轴类) {
			                        当前激活卷轴列表.add(实例);
			                        实例.使用();
			                    }
			                });
			            }
			        }
			
			        当前出战宠物列表 = [];
if (存档数据.当前出战宠物列表) {
    存档数据.当前出战宠物列表.forEach(petData => {
        const petInstance = 恢复物品(petData, 全局物品标识映射);
        if (petInstance) {
            当前出战宠物列表.push(petInstance);
            if (!全局物品实例映射.has(petData.唯一标识符串)) {
                 全局物品实例映射.set(petData.唯一标识符串, petInstance);
            }
        }
    });
}
			
			        所有地牢层 = new Map();
			        if (存档数据.所有地牢层数据) {
			            for (const [层号Str, 楼层存档] of Object.entries(存档数据.所有地牢层数据)) {
			                const 层号 = parseInt(层号Str);
			                if (!isNaN(层号) && 楼层存档) {
			                    const 恢复后楼层 = 恢复楼层(层号, 楼层存档, 全局物品实例映射, 全局物品标识映射);
			                    if (恢复后楼层) {
			                        所有地牢层.set(层号, 恢复后楼层);
			                    }
			                }
			            }
			        }
			        生存挑战激活 = 存档数据.生存挑战激活 || false;
			        生存挑战备份单元格 = [];
			        if (存档数据.序列化生存挑战备份单元格 && 生存挑战激活) {
			            const 当前楼层数据 = 所有地牢层.get(当前层数);
			            if (当前楼层数据) {
			                存档数据.序列化生存挑战备份单元格.forEach(序列化备份 => {
			                    const 恢复的备份 = {
			                        x: 序列化备份.x,
			                        y: 序列化备份.y,
			                        类型: 序列化备份.类型,
			                        背景类型: 序列化备份.背景类型,
			                        墙壁: { ...序列化备份.墙壁 },
			                        颜色索引: 序列化备份.颜色索引,
			                        标识: 序列化备份.标识 ? Symbol(序列化备份.标识.slice(7, -1)) : null,
			                        关联物品: null,
			                        关联怪物: null,
			                    };
			
			                    if (序列化备份.关联物品标识) {
			                        恢复的备份.关联物品 = 全局物品实例映射.get(序列化备份.关联物品标识) || null;
			                    }
			                    if (序列化备份.关联怪物索引 !== null) {
			                        恢复的备份.关联怪物 = 当前楼层数据.所有怪物[序列化备份.关联怪物索引] || null;
			                    }
			                    生存挑战备份单元格.push(恢复的备份);
			                });
			            }
			        }
			
			        传送点列表 = 存档数据.传送点列表 || [];
			        if (所有地牢层.has(当前层数)) {
			            const 当前楼层数据 = 所有地牢层.get(当前层数);
			            地牢 = 当前楼层数据.地牢数组;
			            地牢大小 = 地牢.length;
			            房间列表 = 当前楼层数据.房间列表;
			            上锁房间列表 = 当前楼层数据.上锁房间列表;
			            已访问房间 = 当前楼层数据.已访问房间;
			            房间地图 = 当前楼层数据.房间地图;
			            门实例列表 = 当前楼层数据.门实例列表;
			            所有怪物 = 当前楼层数据.所有怪物;
			            所有计时器 = 当前楼层数据.所有计时器;
			            玩家初始位置 = 当前楼层数据.玩家初始位置;
			            当前天气效果 = 当前楼层数据.当前天气效果;
			            地牢生成方式 = 当前楼层数据.地牢生成方式;
			            已揭示洞穴格子 = 当前楼层数据.已揭示洞穴格子 || new Set();
			            
			            if (是否是创意关卡) {
			                玩家.x = 玩家初始位置.x;
			                玩家.y = 玩家初始位置.y;
			            } else {
			                玩家.x = 存档数据.玩家?.x ?? 当前楼层数据.玩家位置?.x ?? 玩家初始位置.x;
			                玩家.y = 存档数据.玩家?.y ?? 当前楼层数据.玩家位置?.y ?? 玩家初始位置.y;
			            }
			
			            怪物状态表 = new WeakMap();
			            所有怪物.forEach((怪物) => {
			                const 怪物存档数据 = 存档数据.所有地牢层数据[当前层数]?.序列化怪物列表?.find((m) => 怪物.x === m.配置.x && 怪物.y === m.配置.y);
			                if (怪物存档数据?.状态效果) {
			                    new 状态效果(怪物存档数据.状态效果.类型, 怪物存档数据.状态效果.颜色, 怪物存档数据.状态效果.图标, 怪物存档数据.状态效果.持续时间, 怪物存档数据.状态效果.剩余回合, null, 怪物, 怪物存档数据.状态效果.强度);
			                }
			            });
			        } else {
			            console.warn(`存档中未找到当前层 ${当前层数} 的数据，将重新生成！`);
			            房间列表 = [];
			            上锁房间列表 = [];
			            所有怪物 = [];
			            所有计时器 = [];
			            已访问房间 = new Set();
			            门实例列表 = new Map();
			            房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
			            生成地牢();
			            更新洞穴视野();
			            生成并放置随机配方卷轴(当前层数);
			            玩家.x = 玩家初始位置.x;
			            玩家.y = 玩家初始位置.y;
			            if (房间列表.length > 0) 已访问房间.add(房间列表[房间列表.findIndex(item=>item?.id==0)].id);
			        }
			
			        if (存档数据.永久Buffs) {
			            永久Buffs = { ...存档数据.永久Buffs };
			            永久Buffs.已获得效果 = new Set(存档数据.永久Buffs.已获得效果 || []);
			        } else {
			            永久Buffs = { 已获得效果: new Set() };
			        }
			        应用永久Buffs();
			
			        const healthBar = document.querySelector(".health-bar");
			        const powerBar = document.querySelector(".power-bar");
			
			        if (是否是创意关卡) {
			            if (healthBar) healthBar.style.width = "100%";
			            if (powerBar) powerBar.style.width = `100%`;
			        } else {
			            const 保存的生命百分比 = 存档数据.玩家?.当前生命值百分比 ?? 100;
			            const 保存的能量百分比 = 存档数据.玩家?.当前能量值百分比 ?? 100;
			            if (healthBar) {
			                healthBar.style.width = `${Math.max(0, Math.min(100, 保存的生命百分比))}%`;
			                if (保存的生命百分比 <= 20) healthBar.classList.add("低数值警告");
			                else healthBar.classList.remove("低数值警告");
			            }
			            if (powerBar) {
			                powerBar.style.width = `${Math.max(0, Math.min(100, 保存的能量百分比))}%`;
			                if (保存的能量百分比 <= 20) powerBar.classList.add("低数值警告");
			                else powerBar.classList.remove("低数值警告");
			            }
			        }
			        所有传送门 = [];
			        if (存档数据.所有传送门) {
			            存档数据.所有传送门.forEach(传送门数据 => {
			                const 实例 = 全局物品实例映射.get(传送门数据.唯一标识符串);
			                if (实例) {
			                    所有传送门.push(实例);
			                    
			                }
			            });
			        }
			        地牢大小 = 地牢.length;
			        应用职业效果(玩家职业);

					if (存档数据.编辑器状态数据 && Object.keys(存档数据.编辑器状态数据).length > 0) {
						玩家.x = 存档数据.编辑器状态数据.玩家位置.x;
						玩家.y = 存档数据.编辑器状态数据.玩家位置.y;
						当前相机X = 存档数据.编辑器状态数据.相机位置.x;
						当前相机Y = 存档数据.编辑器状态数据.相机位置.y;
						相机目标X = 当前相机X;
						相机目标Y = 当前相机Y;
						编辑器状态.模式 = 存档数据.编辑器状态数据.模式;
						编辑器工具栏模式 = 存档数据.编辑器状态数据.工具栏模式;
						
						if(存档数据.编辑器状态数据.笔刷设置){
							编辑器状态.笔刷模式 = 存档数据.编辑器状态数据.笔刷设置.模式;
							编辑器状态.笔刷形状 = 存档数据.编辑器状态数据.笔刷设置.形状;
							编辑器状态.笔刷半径 = 存档数据.编辑器状态数据.笔刷设置.半径;
						}
						
						if (存档数据.编辑器状态数据.当前选中) {
							const 选中数据 = 存档数据.编辑器状态数据.当前选中;
							if (选中数据.isVirtual) {
								编辑器状态.当前选中 = 选中数据;
							} else {
								const { items, monsters } = 获取所有可用的定义();
								const 集合 = 选中数据.图鉴类型 === '物品' ? items : monsters;
								const 定义 = 集合.find(def => def.类.name === 选中数据.类名);
								if (定义) 编辑器状态.当前选中 = new 定义.类({});
							}
							}

						编辑器最近使用列表 = (存档数据.编辑器状态数据.最近使用列表 || []).map(itemData => {
							if (itemData.isVirtual) {
								return itemData;
							} else {
								const { items, monsters } = 获取所有可用的定义();
								const collection = itemData.图鉴类型 === '物品' ? items : monsters;
								const definition = collection.find(def => def.类.name === itemData.类名);
								return definition ? new definition.类({}) : null;
							}
						}).filter(Boolean);
					}
			
			        console.log("游戏状态恢复完成！");
			    } catch (错误) {
			        console.error("恢复游戏状态时发生严重错误:", 错误);
			        显示通知("加载存档时发生严重错误，将开始新游戏。", "错误");
			        显示主菜单();
			    }
			}
			
			function 恢复单元格(
			    单元格数据,
			    x,
			    y,
			    全局物品实例映射,
			    怪物实例映射,
			    门实例映射
			) {
			    const 单元格实例 = new 单元格(x, y);
			    if (!单元格数据) return 单元格实例;
			    
			    单元格实例.是否强制墙壁 = 单元格数据.是否强制墙壁 || false;
			    单元格实例.类型 = 单元格数据.类型 ?? 单元格类型.墙壁;
			    单元格实例.背景类型 = 单元格数据.背景类型 ?? 单元格实例.类型;
			    单元格实例.墙壁 = {上: false, 右: false, 下: false, 左: false, ...单元格数据.墙壁};
			    单元格实例.钥匙ID = 单元格数据.钥匙ID ?? null;
			    单元格实例.颜色索引 = 单元格数据.颜色索引 ?? 颜色表.length;
			    单元格实例.阻碍视野 = 单元格数据.阻碍视野 ?? false;
			
			    单元格实例.关联物品 = null;
			    单元格实例.关联怪物 = null;
			
			    if (
			        单元格实例.类型 === 单元格类型.楼梯下楼 ||
			        单元格实例.类型 === 单元格类型.楼梯上楼
			    ) {
			        const 图标 =
			            单元格数据.关联物品图标 ||
			            (单元格实例.类型 === 单元格类型.楼梯下楼
			                ? 楼梯图标.下楼
			                : 楼梯图标.上楼);
			        单元格实例.关联物品 = {
			            类型: "楼梯",
			            图标: 图标,
			            显示图标: 图标,
			            颜色索引: 颜色表.length,
			            唯一标识: Symbol(`楼梯_${单元格实例.类型}`),
			            获取名称: () =>
			                单元格实例.类型 === 单元格类型.楼梯下楼
			                    ? "下楼楼梯"
			                    : "上楼楼梯",
			            自定义数据: new Map(),
			            品质: 1,
			            能否拾起: false,
			            是否正常物品: false,
			            是否隐藏: false,
			            是否为隐藏物品: false,
			            效果描述: null,
			            已装备: false,
			            装备槽位: null,
			            堆叠数量: 1,
			            最大堆叠数量: 1,
			            颜色表: 颜色表,
			            使用: () => {
			                const 目标层数 =
			                    单元格实例.类型 === 单元格类型.楼梯下楼
			                        ? 当前层数 + 1
			                        : 当前层数 - 1;
			                切换楼层(目标层数, false, null, true);
			            },
			        };
			    }
			    else if (单元格数据.关联物品标识) {
			        const 物品实例 = 全局物品实例映射.get(
			            单元格数据.关联物品标识
			        );
			        if (物品实例) {
			            单元格实例.关联物品 = 物品实例;
			            物品实例.x = x;
			            物品实例.y = y;
			        } else {
			            console.warn(
			                `单元格 (${x},${y}) 关联物品标识 ${单元格数据.关联物品标识} 未找到对应实例`
			            );
			        }
			    }
			
			    if (
			        单元格数据.关联怪物索引 !== null &&
			        单元格数据.关联怪物索引 !== undefined
			    ) {
			        单元格实例.关联怪物 = 单元格数据.关联怪物索引;
			    }
			
			    if (单元格数据.标识符串) {
			        const 门实例 = 门实例映射.get(单元格数据.标识符串);
			        if (门实例) {
			            单元格实例.标识 = 门实例.唯一标识;
			        } else {
			            单元格实例.临时门标识符串 = 单元格数据.标识符串;
			        }
			    }
			    单元格实例.配对单元格位置 = 单元格数据.配对单元格位置 || null;
			    
			    单元格实例.isOneWay = 单元格数据.isOneWay || false;
			    单元格实例.oneWayAllowedDirection = 单元格数据.oneWayAllowedDirection || null;
			    单元格实例.doorOrientation = 单元格数据.doorOrientation || null;
			
			    return 单元格实例;
			}
			/**
			 * 序列化单个物品实例
			 * @param {物品} 物品实例
			 * @returns {object | null} 可序列化的物品数据，如果物品无效则返回 null
			 */
			function 序列化物品(物品实例) {
			    if (!物品实例 || !物品实例.constructor) {
			        console.warn("尝试序列化无效物品", 物品实例);
			        return null;
			    }
			    try {
			        const 类名 = 物品实例.constructor.name;
			        const 配置 = {
			类型: 物品实例.类型,
			名称: 物品实例.名称,
			图标: 物品实例.图标,
			品质: 物品实例.品质,
			数量: 物品实例.堆叠数量,
			最大堆叠数量: 物品实例.最大堆叠数量,
			颜色索引: 物品实例.颜色索引,
			强化: 物品实例.强化,
			能否拾起: 物品实例.能否拾起,
			是否正常物品: 物品实例.是否正常物品,
			是否隐藏: 物品实例.是否隐藏,
			是否为隐藏物品: 物品实例.是否为隐藏物品,
			效果描述: 物品实例.效果描述,
			已装备: 物品实例.已装备,
			装备槽位: 物品实例.装备槽位,
			x: 物品实例.x,
			y: 物品实例.y,
			是否被丢弃: 物品实例.是否被丢弃 || false,
			阻碍怪物: 物品实例.阻碍怪物,
			材质: 物品实例.材质,
			玩家放置: 物品实例.玩家放置,
			数据: 物品实例.自定义数据
			    ? Object.fromEntries(物品实例.自定义数据)
			    : null,
			        };
			        if (物品实例 instanceof 刷怪笼) {
			const spawnedList = 配置.数据.当前生成物列表 || [];
			配置.数据.当前生成物标识列表 = spawnedList.map(instance => {
			    if (instance instanceof 怪物) {
			        const index = 所有怪物.findIndex(m => m === instance);
			        return index !== -1 ? `怪物_${index}` : null;
			    } else if (instance instanceof 物品) {
			        return instance.唯一标识.toString();
			    }
			    return null;
			}).filter(id => id !== null);
			delete 配置.数据.当前生成物列表;
			        }
			
			        if (物品实例 instanceof 武器类) {
			配置.数据.冷却剩余 = 物品实例.自定义数据.get("冷却剩余") ?? 0;
			        }
			        if (物品实例 instanceof 宠物) {
			配置.是否已放置 = 物品实例.是否已放置 ?? false;
			配置.层数=物品实例.层数
			        }
			
			        if (物品实例 instanceof 附魔卷轴) {
			配置.数据.可用次数 = 物品实例.可用次数;
			const 效果索引 = 物品实例.附魔池.findIndex(
			    (func) => func === 物品实例.附魔效果
			);
			if (效果索引 !== -1) {
			    配置.数据.附魔效果名 = 物品实例.效果名[效果索引];
			} else {
			    console.warn("无法找到附魔卷轴的效果名:", 物品实例);
			}
			        }
			
			        if (
			物品实例 instanceof 神秘商人 ||
			物品实例 instanceof 物品祭坛
			        ) {
			配置.数据.库存序列化 = (
			    物品实例.自定义数据.get("库存") || []
			)
			    .map(序列化物品)
			    .filter((item) => item !== null);
			delete 配置.数据.库存;
			        }
			
			        if (物品实例 instanceof 宠物) {
			const 宠物装备 = 物品实例.自定义数据.get("装备") || {};
			配置.数据.装备标识 = {};
			for (const 槽位 in 宠物装备) {
			    if (宠物装备[槽位] && 宠物装备[槽位].唯一标识) {
			        配置.数据.装备标识[槽位] =
			            宠物装备[槽位].唯一标识.toString();
			    } else {
			        配置.数据.装备标识[槽位] = null;
			    }
			}
			配置.数据.技能 = JSON.parse(
			    JSON.stringify(
			        物品实例.自定义数据.get("技能") || []
			    )
			);
			delete 配置.数据.装备;
			        }
			
			        if (物品实例 instanceof 折跃门) {
			const 目标房间 = 物品实例.自定义数据.get("目标房间");
			配置.数据.目标房间ID = 目标房间 ? 目标房间.id : null;
			        }
			
			        return {
			类名: 类名,
			唯一标识符串: 物品实例.唯一标识.toString(),
			配置: 配置,
			        };
			    } catch (e) {
			        console.error(
			`序列化物品 ${物品实例?.名称} (${物品实例?.constructor?.name}) 失败:`,
			e
			        );
			        return null;
			    }
			}
			
			/**
			 * 序列化单个怪物实例 - 扩展版
			 * @param {怪物} 怪物实例
			 * @param {number} 怪物索引
			 * @param {Array<怪物>} 当前楼层所有怪物列表 - 用于查找引用索引
			 * @returns {object | null} 可序列化的怪物数据
			 */
			function 序列化怪物(怪物实例, 怪物索引, 当前楼层所有怪物列表) {
			    if (!怪物实例 || !怪物实例.constructor) {
			        console.warn("尝试序列化无效怪物", 怪物实例);
			        return null;
			    }
			    const 类名 = 怪物实例.constructor.name;
			    try {
			        let 仇恨目标标识 = null;
			        if (怪物实例.仇恨 === 玩家) {
			仇恨目标标识 = "玩家";
			        } else if (怪物实例.仇恨 instanceof 怪物) {
			const 仇恨索引 = 当前楼层所有怪物列表.findIndex(
			    (m) => m === 怪物实例.仇恨
			);
			if (仇恨索引 !== -1) {
			    仇恨目标标识 = `怪物_${仇恨索引}`;
			} else {
			    console.warn(
			        `怪物 ${怪物索引} 的仇恨目标未在当前楼层找到:`,
			        怪物实例.仇恨
			    );
			}
			        }
			
			        const 状态效果数据 = 怪物状态表.get(怪物实例);
			        let 序列化状态 = null;
			        if (状态效果数据) {
			序列化状态 = {
			    类型: 状态效果数据.类型,
			    颜色: 状态效果数据.颜色,
			    图标: 状态效果数据.图标,
			    持续时间: 状态效果数据.持续时间,
			    剩余回合: 状态效果数据.剩余回合,
			    强度: 状态效果数据.强度,
			};
			        }
			
			        const 配置 = {
			x: 怪物实例.x,
			y: 怪物实例.y,
			图标: 怪物实例.图标,
			房间ID: 怪物实例.房间ID,
			当前生命值: 怪物实例.当前生命值,
			状态: 怪物实例.状态,
			强化: 怪物实例.强化,
			攻击冷却剩余: 怪物实例.攻击冷却回合剩余,
			受伤冻结回合剩余: 怪物实例.受伤冻结回合剩余,
			仇恨目标标识: 仇恨目标标识,
			基础攻击力: 怪物实例.基础攻击力,
			基础生命值: 怪物实例.基础生命值,
			移动率: 怪物实例.移动率,
			基础移动距离: 怪物实例.基础移动距离,
			基础攻击范围: 怪物实例.基础攻击范围,
			跟踪距离: 怪物实例.跟踪距离,
			攻击冷却: 怪物实例.攻击冷却,
			受伤冻结回合: 怪物实例.受伤冻结回合,
			掉落概率: 怪物实例.掉落概率,
			当前格: 怪物实例.当前格,
			始终追踪玩家: 怪物实例.始终追踪玩家,
			携带药水: 怪物实例.携带药水 ? { ...怪物实例.携带药水 } : null,
			永久增益: [...怪物实例.永久增益],
			残血逃跑: 怪物实例.残血逃跑,
			        };
			
			        if (怪物实例 instanceof 王座守护者) {
			配置.当前阶段 = 怪物实例.当前阶段;
			配置.技能冷却剩余 = { ...怪物实例.技能冷却剩余 };
			配置.无敌 = 怪物实例.无敌;
			配置.无敌次数 = 怪物实例.无敌次数;
			配置.皇家守卫索引列表 = 怪物实例.皇家守卫列表
			    .map(guard => 当前楼层所有怪物列表.findIndex(m => m === guard))
			    .filter(index => index !== -1);
			配置.激活的墓碑索引列表 = 怪物实例.激活的墓碑列表
			    .map(tombstone => 当前楼层所有怪物列表.findIndex(m => m === tombstone))
			    .filter(index => index !== -1);
			        }
			        if (怪物实例 instanceof 蜈蚣怪物 || 怪物实例 instanceof 蜈蚣部位) {
    怪物实例.存档ID = 怪物实例.存档ID || `centipede_${prng()}`;
    配置.存档ID = 怪物实例.存档ID;
}
if (怪物实例 instanceof 蜈蚣怪物) {
    配置.身体部位ID列表 = 怪物实例.身体部位.map(p => {
        p.存档ID = p.存档ID || `centipede_${prng()}`;
        return p.存档ID;
    });
    配置.长度 = 怪物实例.长度;
    配置.朝向 = 怪物实例.朝向;
}
if (怪物实例 instanceof 蜈蚣部位) {
    配置.主体ID = 怪物实例.主体?.存档ID;
    配置.跟随ID = 怪物实例.跟随?.存档ID;
    配置.基础颜色 = 怪物实例.基础颜色;
}
if (怪物实例 instanceof 骷髅仆从) {
    配置.生命周期 = 怪物实例.生命周期;
}
			        if (怪物实例 instanceof 腐蚀怪物) {
			配置.腐蚀强度 = 怪物实例.腐蚀强度;
			配置.腐蚀持续 = 怪物实例.腐蚀持续;
			        }
			        if (怪物实例 instanceof 盗贼怪物) {
			配置.偷窃几率 = 怪物实例.偷窃几率;
			配置.偷窃武器几率 = 怪物实例.偷窃武器几率;
			配置.偷到的金币 = 怪物实例.偷到的金币;
			配置.偷到的武器列表序列化 = 怪物实例.偷到的武器列表
			    .map(序列化物品)
			    .filter((i) => i != null);
			        }
			        if (怪物实例 instanceof 吸能怪物) {
			配置.吸能比例 = 怪物实例.吸能比例;
			配置.最小吸能 = 怪物实例.最小吸能;
			        }
			        if (怪物实例 instanceof 剧毒云雾怪物) {
			配置.毒云范围 = 怪物实例.毒云范围;
			配置.毒云持续 = 怪物实例.毒云持续;
			配置.毒云强度 = 怪物实例.毒云强度;
			        }
			        if (怪物实例 instanceof 召唤师怪物) {
			配置.召唤冷却剩余 = 怪物实例.召唤冷却剩余;
			配置.最大召唤物数量 = 怪物实例.最大召唤物数量;
			配置.召唤物类名 = 怪物实例.召唤物类.name;
			配置.当前召唤物索引列表 = 怪物实例.当前召唤物列表
			    .map((仆从) =>
			        当前楼层所有怪物列表.findIndex(
			            (m) => m === 仆从
			        )
			    )
			    .filter((index) => index !== -1);
			        }
			        if (怪物实例 instanceof 幽灵仆从) {
			配置.生命周期 = 怪物实例.生命周期;
			const 召唤者索引 = 当前楼层所有怪物列表.findIndex(
			    (m) => m === 怪物实例.召唤者
			);
			配置.召唤者索引 = 召唤者索引 !== -1 ? 召唤者索引 : null;
			        }
			        if (怪物实例 instanceof 萨满怪物) {
			配置.治疗冷却剩余 = 怪物实例.治疗冷却剩余;
			        }
			        if (怪物实例 instanceof 大史莱姆怪物) {
			        }
			        if (怪物实例 instanceof 瞬移怪物) {
			配置.瞬移几率 = 怪物实例.瞬移几率;
			配置.受击瞬移几率 = 怪物实例.受击瞬移几率;
			        }
			        if (怪物实例 instanceof 伪装怪物) {
			配置.伪装状态 = 怪物实例.伪装状态;
			        }
			        if (怪物实例 instanceof 炸弹怪物) {
			配置.携带炸弹 = 怪物实例.携带炸弹;
			        }
			        if (怪物实例 instanceof 大魔法师) {
			配置.技能冷却 = 怪物实例.技能冷却;
			配置.隐身中 = 怪物实例.隐身中;
			配置.isClone = 怪物实例.isClone;
			const 分身索引 = 怪物实例.分身
			    ? 当前楼层所有怪物列表.findIndex(
			            (m) => m === 怪物实例.分身
			        )
			    : -1;
			配置.分身索引 = 分身索引 !== -1 ? 分身索引 : null;
			        }
			        if (怪物实例 instanceof 旋风怪物) {
			配置.召唤冷却剩余 = 怪物实例.召唤冷却剩余;
			配置.最大召唤物数量 = 怪物实例.最大召唤物数量;
			配置.当前召唤物索引列表 = 怪物实例.当前召唤物列表
			    .map((旋) =>
			        当前楼层所有怪物列表.findIndex((m) => m === 旋)
			    )
			    .filter((index) => index !== -1);
			        }
			        if (怪物实例 instanceof 旋风) {
			配置.生命周期 = 怪物实例.生命周期;
			        }
			        if (怪物实例 instanceof 超速怪物) {
			配置.加速范围 = 怪物实例.加速范围 ?? 10;
			配置.加速回合数 = 怪物实例.加速回合数 ?? 2;
			        }
			        if (怪物实例 instanceof 巡逻怪物) {
			            配置.随机游走 = 怪物实例.随机游走;
			            配置.巡逻方向 = 怪物实例.巡逻方向;
			            配置.随机游走方向 = 怪物实例.随机游走方向;
			        }
			
			        const 掉落物序列化 = 怪物实例.掉落物
			? 序列化物品(怪物实例.掉落物)
			: null;
			
			        return {
			类名: 类名,
			怪物索引: 怪物索引,
			配置: 配置,
			掉落物: 掉落物序列化,
			状态效果: 序列化状态,
			        };
			    } catch (e) {
			        console.error(
			`序列化怪物 ${怪物实例?.类型} (${类名}) 失败:`,
			e
			        );
			        return null;
			    }
			}
			
			function 序列化楼层(层号, 楼层原始数据, 全局物品标识映射) {
			    console.log(`开始序列化楼层 ${层号}`);
			    if (!楼层原始数据) {
			        console.warn(`楼层 ${层号} 数据不存在，跳过序列化`);
			        return null;
			    }
			    try {
			        const {
			地牢数组 = [],
			房间列表 = [],
			上锁房间列表 = [],
			已访问房间 = new Set(),
			房间地图 = [],
			门实例列表 = new Map(),
			所有怪物 = [],
			所有计时器 = [],
			玩家初始位置 = { x: 0, y: 0 },
			玩家位置 = 玩家位置,
			当前天气效果 = [],
			已揭示洞穴格子 = 已揭示洞穴格子,
			地牢生成方式 = 地牢生成方式,
			        } = 楼层原始数据;
			
			        const 地上物品列表 = [];
			        for (let y = 0; y < 地牢数组.length; y++) {
			for (let x = 0; x < 地牢数组[y]?.length; x++) {
			    const 物品 = 地牢数组[y][x]?.关联物品;
			    if (物品) {
			        地上物品列表.push(物品);
			        if (!全局物品标识映射.has(物品.唯一标识)) {
			            全局物品标识映射.set(
			                物品.唯一标识,
			                物品.唯一标识.toString()
			            );
			        }
			    }
			}
			        }
			        const 序列化地上物品 = 地上物品列表
			.map(序列化物品)
			.filter((i) => i != null);
			
			        const 怪物索引映射 = new Map();
			        const 序列化怪物列表 = 所有怪物
			.map((怪物, 索引) => {
			    怪物索引映射.set(怪物, 索引);
			    return 序列化怪物(怪物, 索引, 所有怪物);
			})
			.filter((m) => m != null);
			
			        const 序列化地牢格子 = 地牢数组.map((行) =>
			行
			    .map((单元格) =>
			        序列化单元格(
			            单元格,
			            全局物品标识映射,
			            怪物索引映射
			        )
			    )
			    .filter((g) => g != null)
			        );
			
			        const 序列化物品列表 = 所有计时器
			.map(序列化物品)
			.filter((b) => b != null);
			        序列化物品列表.forEach((炸弹数据) => {
			if (炸弹数据) {
			    const 符号 = Symbol(
			        炸弹数据.唯一标识符串.slice(7, -1)
			    );
			    if (!全局物品标识映射.has(符号)) {
			        全局物品标识映射.set(
			            符号,
			            炸弹数据.唯一标识符串
			        );
			    }
			}
			        });
			
			        const 序列化门实例 = Array.from(门实例列表.values()).map(
			(门) => ({
			    唯一标识符串: 门.唯一标识.toString(),
			    类型: 门.类型,
			    是否上锁: 门.是否上锁,
			    房间ID: 门.房间ID,
			    所在位置: { ...门.所在位置 },
			})
			        );
			        const 序列化挑战房间状态 = (楼层原始数据.房间列表 || [])
			.filter((r) => r.类型 === "挑战房间" && r.挑战状态)
			.map((r) => {
			    const 挑战状态 = r.挑战状态;
			    const 挑战状态拷贝 = {
			        进行中: 挑战状态.进行中,
			        已完成: 挑战状态.已完成,
			        当前波次: 挑战状态.当前波次,
			        总波次: 挑战状态.总波次,
			        波次最大回合数: 挑战状态.波次最大回合数,
			        波次当前回合数: 挑战状态.波次当前回合数,
			        挑战怪物层级: 挑战状态.挑战怪物层级,
			        候选怪物池: 挑战状态.候选怪物池,
			        波次内怪物: [],
			        原始门数据: [],
			    };
			
			    if (
			        挑战状态.波次内怪物 &&
			        Array.isArray(挑战状态.波次内怪物)
			    ) {
			        挑战状态拷贝.波次内怪物 =
			            挑战状态.波次内怪物
			                .map((怪实例) => {
			                    const 索引 = (
			                        楼层原始数据.所有怪物 || []
			                    ).findIndex((m) => m === 怪实例);
			                    return 索引 !== -1
			                        ? `怪物_${索引}`
			                        : null;
			                })
			                .filter((id) => id !== null);
			    }
			
			    if (
			        挑战状态.原始门数据 &&
			        Array.isArray(挑战状态.原始门数据)
			    ) {
			        挑战状态拷贝.原始门数据 =
			            挑战状态.原始门数据.map((门数据) => ({
			                ...门数据,
			                原标识: 门数据.原标识
			                    ? 门数据.原标识.toString()
			                    : null,
			            }));
			    }
			
			    return {
			        id: r.id,
			        状态: 挑战状态拷贝,
			    };
			});
			        console.log(`楼层 ${层号} 序列化完成`);
			        return {
			玩家位置: 玩家位置,
			地牢生成方式: 地牢生成方式,
    已揭示洞穴格子: Array.from(已揭示洞穴格子|| new Set()),
			玩家初始位置: (玩家初始位置 && 玩家初始位置.x !== undefined) ? { ...玩家初始位置 } : { x: 50, y: 50 },
			房间列表: 房间列表.map((r) => {
			    const { 挑战状态, ...restOfRoom } = r;
			    return {
			        ...restOfRoom,
			        门: r.门 ? [...r.门] : [],
			    };
			}),
			上锁房间列表: 上锁房间列表.map((r) => {
			    const { 挑战状态, ...restOfRoom } = r;
			    return {
			        ...restOfRoom,
			        门: r.门 ? [...r.门] : [],
			    };
			}),
			已访问房间数组: Array.from(已访问房间 || new Set()),
			房间地图: 房间地图.map((row) => [...row]),
			挑战状态列表: 序列化挑战房间状态,
			序列化地上物品: 序列化地上物品,
			序列化怪物列表: 序列化怪物列表,
			序列化物品列表: 序列化物品列表,
			序列化地牢格子: 序列化地牢格子,
			序列化门实例: 序列化门实例,
			序列化玩家仆从索引: 玩家仆从列表
    .map(仆从 => 所有怪物.findIndex(m => m === 仆从))
    .filter(index => index !== -1 && 所有怪物[index].层数 === 层号),
			当前天气效果: [...当前天气效果],
			        };
			    } catch (e) {
			        console.error(`序列化楼层 ${层号} 失败:`, e);
			        return null;
			    }
			}
			
			/**
			 * 恢复单个物品实例
			 * @param {object} 物品数据
			 * @param {Map<string, Symbol>} 全局物品标识映射 - string -> symbol
			 * @returns {物品 | null}
			 */
			function 恢复物品(物品数据, 全局物品标识映射) {
			    if (!物品数据 || !物品数据.类名) return null;
			    const 类构造器 = window[物品数据.类名];
			    if (!类构造器 || typeof 类构造器 !== "function") {
			        console.warn(`未找到物品类构造器: ${物品数据.类名}`);
			        return null;
			    }
			    try {
			        const 配置 = { ...物品数据.配置 };
			        const 标识符串 = 物品数据.唯一标识符串;
			        let 唯一标识 = 全局物品标识映射.get(标识符串);
			
			        if (!唯一标识) {
			if (物品数据.类名 === "钥匙") {
			    配置.对应门ID = 配置.数据?.对应门ID;
			    配置.地牢层数 = 配置.数据?.地牢层数;
			    if (
			        配置.对应门ID !== undefined &&
			        配置.地牢层数 !== undefined
			    ) {
			        唯一标识 = Symbol.for(
			            `${配置.地牢层数}层${配置.对应门ID}`
			        );
			    } else {
			        console.warn(
			            "钥匙缺少门ID或层数信息，无法恢复Symbol.for:",
			            配置
			        );
			        唯一标识 = Symbol(标识符串);
			    }
			} else if (标识符串 && 标识符串.startsWith("Symbol(")) {
			    const description = 标识符串.slice(7, -1);
			    唯一标识 = Symbol(description);
			} else {
			    console.warn(
			        "物品缺少有效唯一标识符串，生成新Symbol:",
			        物品数据
			    );
			    唯一标识 = Symbol(
			        `恢复_${物品数据.类名}_${Date.now()}`
			    );
			}
			全局物品标识映射.set(标识符串, 唯一标识);
			        }
			
			        if (配置.数据) {
			配置.数据 = new Map(Object.entries(配置.数据));
			        } else {
			配置.数据 = new Map();
			        }
			
			        const 实例 = new 类构造器({ ...配置, 唯一标识: 唯一标识 });
			        
			        实例.自定义数据 = 配置.数据;
			        实例.是否隐藏 = 配置.是否隐藏;
			        实例.堆叠数量 = 配置.数量;
			        实例.图标 = 配置.图标;
			        实例.材质=配置.材质
			
			        if (实例 instanceof 武器类) {
			实例.自定义数据.set(
			    "冷却剩余",
			    配置.数据.get("冷却剩余") ?? 0
			);
			        }
			if (实例.名称 && 图标映射[实例.名称]) {
			            实例.图标 = 图标映射[实例.名称];
			        }
			        if (实例 instanceof 药水类) {
			                实例.图标 = 图标映射.药水;
			            } else if (实例 instanceof 祭坛类) {
			                实例.图标 = 图标映射.祭坛;
			            }
			        if (实例 instanceof 附魔卷轴) {
			实例.可用次数 = 配置.数据.get("可用次数") ?? 1;
			const 效果名 = 配置.数据.get("附魔效果名");
			const 效果索引 = 实例.效果名.indexOf(效果名);
			if (效果索引 !== -1) {
			    实例.附魔效果 = 实例.附魔池[效果索引];
			} else {
			    console.warn(`无法恢复附魔卷轴效果: ${效果名}`);
			}
			        }
			        
			        if (实例 instanceof 刷怪笼) {
			实例.临时生成物标识列表 = 配置.数据.get('当前生成物标识列表') || [];
			        }
			        if (实例 instanceof 隐形毒气陷阱){
			            实例.自定义数据.set('激活后图标',图标映射.毒气);
			        }			
			        实例.x = 配置.x ?? null;
			        实例.y = 配置.y ?? null;
			        实例.是否被丢弃 = 配置.是否被丢弃 ?? false;
			
			        实例.已装备 = false;
			        实例.装备槽位 = null;
			
			        return 实例;
			    } catch (e) {
			        console.error(`恢复物品 ${物品数据.类名} 失败:`, e);
			        return null;
			    }
			}
			
			/**
			 * 恢复单个怪物实例
			 * @param {object} 怪物数据
			 * @param {Map<string, 物品>} 全局物品实例映射
			 * @param {Map<number, 怪物>} 当前楼层怪物映射 (用于存储恢复的实例)
			 * @returns {怪物 | null}
			 */
			
			function 恢复怪物(怪物数据, 全局物品实例映射, 当前楼层怪物映射) {
			    if (!怪物数据 || !怪物数据.类名) return null;
			    const 类构造器 = window[怪物数据.类名];
			    if (!类构造器 || typeof 类构造器 !== "function") {
			        console.warn(`未找到怪物类构造器: ${怪物数据.类名}`);
			        return null;
			    }
			    try {
			        const 配置 = { ...怪物数据.配置 };
			
			        let 掉落物实例 = null;
			        if (怪物数据.掉落物) {
			const 临时物品标识映射 = new Map();
			掉落物实例 = 恢复物品(
			    怪物数据.掉落物,
			    临时物品标识映射
			);
			if (掉落物实例) {
			    const 全局实例 = 全局物品实例映射.get(
			        怪物数据.掉落物.唯一标识符串
			    );
			    if (全局实例) 掉落物实例 = 全局实例;
			    else
			        全局物品实例映射.set(
			            怪物数据.掉落物.唯一标识符串,
			            掉落物实例.唯一标识
			        );
			}
			        }
			        
			        delete 配置.掉落物;
			
			        const 实例 = new 类构造器(配置);
			        
			
			        实例.掉落物 = 掉落物实例;
			
			        实例.图标 = 配置.图标 ?? 实例.图标;
			        实例.基础生命值 = 配置.基础生命值 ?? 实例.生命值;
			        实例.基础攻击力 = 配置.基础攻击力 ?? 实例.生命值;
			        实例.当前生命值 = 配置.当前生命值 ?? 实例.生命值;
			        实例.状态 = 配置.状态 ?? 怪物状态.休眠;
			        实例.攻击冷却回合剩余 = 配置.攻击冷却回合剩余 ?? 0;
			        实例.受伤冻结回合剩余 = 配置.受伤冻结回合剩余 ?? 0;
			        实例.移动率 = 配置.移动率 ?? 实例.移动率;
			        实例.基础移动距离 = 配置.基础移动距离 ?? 实例.基础移动距离;
			        实例.基础攻击范围 = 配置.基础攻击范围 ?? 实例.基础攻击范围;
			        实例.跟踪距离 = 配置.跟踪距离 ?? 实例.跟踪距离;
			        实例.攻击冷却 = 配置.攻击冷却 ?? 实例.攻击冷却;
			        实例.受伤冻结回合 = 配置.受伤冻结回合 ?? 实例.受伤冻结回合;
			        实例.掉落概率 = 配置.掉落概率 ?? 实例.掉落概率;
			        实例.始终追踪玩家 = 配置.始终追踪玩家 ?? 实例.始终追踪玩家;
			        if (实例.类型 && 图标映射[实例.类型] && !(实例 instanceof 伪装怪物)) {
			            实例.图标 = 图标映射[实例.类型];
			        }
			        if (实例 instanceof 王座守护者) {
			实例.当前阶段 = 配置.当前阶段 || 1;
			实例.技能冷却剩余 = 配置.技能冷却剩余 || { ...实例.技能冷却 };
			实例.无敌 = 配置.无敌 || false;
			实例.无敌次数 = 配置.无敌次数 || 0;
			实例.临时守卫索引列表 = 配置.皇家守卫索引列表 || [];
			实例.临时墓碑索引列表 = 配置.激活的墓碑索引列表 || [];
			        }
			        if (配置.存档ID) {
    实例.存档ID = 配置.存档ID;
}
if (实例 instanceof 蜈蚣怪物) {
    实例.临时身体部位ID列表 = 配置.身体部位ID列表 || [];
    实例.朝向 = 配置.朝向 || 'W'
}
if (实例 instanceof 蜈蚣部位) {
    实例.临时主体ID = 配置.主体ID;
    实例.临时跟随ID = 配置.跟随ID;
    实例.基础颜色 = 配置.基础颜色;
}
if (实例 instanceof 骷髅仆从) {
    实例.生命周期 = 配置.生命周期 ?? 30;
    实例.主人 = 玩家;
}
			        if (实例 instanceof 腐蚀怪物) {
			实例.腐蚀强度 = 配置.腐蚀强度 ?? 1;
			实例.腐蚀持续 = 配置.腐蚀持续 ?? 4;
			        }
			        if (实例 instanceof 盗贼怪物) {
			实例.偷窃几率 = 配置.偷窃几率 ?? 0.5;
			实例.偷窃武器几率 = 配置.偷窃武器几率 ?? 0.15;
			实例.偷到的金币 = 配置.偷到的金币 ?? 0;
			实例.偷到的武器列表 = (配置.偷到的武器列表序列化 || [])
			    .map((wData) => 恢复物品(wData, 全局物品实例映射))
			    .filter((w) => w != null);
			        }
			        if (实例 instanceof 吸能怪物) {
			实例.吸能比例 = 配置.吸能比例 ?? 0.3;
			实例.最小吸能 = 配置.最小吸能 ?? 5;
			        }
			        if (实例 instanceof 剧毒云雾怪物) {
			实例.毒云范围 = 配置.毒云范围 ?? 1;
			实例.毒云持续 = 配置.毒云持续 ?? 3;
			实例.毒云强度 = 配置.毒云强度 ?? 2;
			        }
			        if (实例 instanceof 召唤师怪物) {
			实例.召唤冷却剩余 = 配置.召唤冷却剩余 ?? 0;
			实例.最大召唤物数量 = 配置.最大召唤物数量 ?? 2;
			实例.召唤物类 = window[配置.召唤物类名] || 幽灵仆从;
			实例.临时召唤物索引列表 = 配置.当前召唤物索引列表 || [];
			        }
			        if (实例 instanceof 幽灵仆从) {
			实例.生命周期 = 配置.生命周期 ?? 8;
			实例.临时召唤者索引 = 配置.召唤者索引;
			        }
			        if (实例 instanceof 萨满怪物) {
			实例.治疗冷却剩余 = 配置.治疗冷却剩余 ?? 0;
			        }
			        if (实例 instanceof 瞬移怪物) {
			实例.瞬移几率 = 配置.瞬移几率 ?? 0.6;
			实例.受击瞬移几率 = 配置.受击瞬移几率 ?? 0.4;
			        }
			        if (实例 instanceof 伪装怪物) {
			实例.伪装状态 = 配置.伪装状态 ?? false; 
			        }
			        if (实例 instanceof 炸弹怪物) {
			实例.携带炸弹 = 配置.携带炸弹 ?? true;
			        }
			        if (实例 instanceof 大魔法师) {
			实例.技能冷却 = 配置.技能冷却 ?? {
			    隐身术: 0,
			    分身术: 0,
			    火球术: 0,
			    冰冻术: 0,
			    传送术: 0,
			    召唤术: 0,
			};
			实例.隐身中 = 配置.隐身中 ?? false;
			实例.isClone = 配置.isClone ?? false;
			实例.临时分身索引 = 配置.分身索引;
			        }
			        if (实例 instanceof 旋风怪物) {
			实例.召唤冷却剩余 = 配置.召唤冷却剩余 ?? 0;
			实例.最大召唤物数量 = 配置.最大召唤物数量 ?? 1;
			实例.临时召唤物索引列表 = 配置.当前召唤物索引列表 || [];
			        }
			        if (实例 instanceof 旋风) {
			实例.生命周期 = 配置.生命周期 ?? 10;
			        }
			        if (实例 instanceof 超速怪物) {
			实例.加速范围 = 配置.加速范围 ?? 10;
			实例.加速回合数 = 配置.加速回合数 ?? 2;
			        }
			        
			        if (实例 instanceof 巡逻怪物) {
			 实例.随机游走 = 配置.随机游走 ?? false;
			 实例.随机游走方向 = 配置.随机游走方向 || '';
			 实例.巡逻方向 = 配置.巡逻方向 || 'E';
			        }
			        
			        if (怪物数据.怪物索引 !== undefined) {
			当前楼层怪物映射.set(怪物数据.怪物索引, 实例);
			        }
			
			        if (怪物数据.状态效果) {
			const 效果 = new 状态效果(
			    怪物数据.状态效果.类型,
			    怪物数据.状态效果.颜色,
			    怪物数据.状态效果.图标,
			    怪物数据.状态效果.持续时间,
			    怪物数据.状态效果.剩余回合,
			    null,
			    实例,
			    怪物数据.状态效果.强度
			);
			        }
			        实例.临时状态效果 = 怪物数据.状态效果;
			
			        实例.临时仇恨目标标识 = 配置.仇恨目标标识;
			
			        return 实例;
			    } catch (e) {
			        console.error(`恢复怪物 ${怪物数据.类名} 失败:`, e);
			        return null;
			    }
			}
			
			function 恢复楼层(
			    层号,
			    楼层存档数据,
			    全局物品实例映射,
			    全局物品标识映射
			) {
			    console.log(`开始恢复楼层 ${层号}`);
			    if (!楼层存档数据) {
			        console.warn(`楼层 ${层号} 存档数据无效，跳过恢复`);
			        return null;
			    }
			    try {
			        const 楼层数据 = {
			玩家位置: 楼层存档数据.玩家位置,
			玩家初始位置: (楼层存档数据.玩家初始位置 && 楼层存档数据.玩家初始位置.x !== undefined && 楼层存档数据.玩家初始位置.y !== undefined) 
			        ? { ...楼层存档数据.玩家初始位置 } 
			        : { x: 50, y: 50 },
			房间列表: [...(楼层存档数据.房间列表 || [])],
			上锁房间列表: [...(楼层存档数据.上锁房间列表 || [])],
			已访问房间: new Set(楼层存档数据.已访问房间数组 || []),
			房间地图: [...(楼层存档数据.房间地图 || [])],
			地牢数组: [],
			所有怪物: [],
			所有计时器: [],
			门实例列表: new Map(),
			地牢生成方式: 楼层存档数据.地牢生成方式 || 'default',
			已揭示洞穴格子: 楼层存档数据.已揭示洞穴格子 || new Set(),
			当前天气效果: [...(楼层存档数据.当前天气效果 || [])],
			        };
			    if (楼层数据.地牢生成方式 === 'cave' && 楼层数据.已揭示洞穴格子) {
        楼层数据.已揭示洞穴格子 = new Set(楼层数据.已揭示洞穴格子);
    }
			        const 地上物品实例映射 = new Map();
			        if (楼层存档数据.序列化地上物品) {
			楼层存档数据.序列化地上物品.forEach((物品数据) => {
			    let 实例 = 全局物品实例映射.get(
			        物品数据.唯一标识符串
			    );
			    if (!实例) {
			        实例 = 恢复物品(物品数据, 全局物品标识映射);
			        if (实例) {
			            全局物品实例映射.set(
			                物品数据.唯一标识符串,
			                实例
			            );
			        }
			    }
			    if (实例) {
			        地上物品实例映射.set(
			            物品数据.唯一标识符串,
			            实例
			        );
			        实例.x = 物品数据.配置?.x ?? null;
			        实例.y = 物品数据.配置?.y ?? null;
			    }
			});
			        }
			
			        const 门实例映射 = new Map();
			        if (楼层存档数据.序列化门实例) {
			楼层存档数据.序列化门实例.forEach((门数据) => {
			    let 唯一标识;
			    const 现有符号 = 全局物品标识映射.get(
			        门数据.唯一标识符串
			    );
			    if (现有符号) {
			        唯一标识 = 现有符号;
			    } else {
			        唯一标识 = Symbol(
			            门数据.唯一标识符串.slice(7, -1)
			        );
			        全局物品标识映射.set(
			            门数据.唯一标识符串,
			            唯一标识
			        );
			    }
			
			    const 实例 = new 门({
			        关联房间ID: 门数据.房间ID,
			        位置: { ...门数据.所在位置 },
			    });
			    实例.唯一标识 = 唯一标识;
			    实例.类型 = 门数据.类型;
			    实例.是否上锁 = 门数据.是否上锁;
			    楼层数据.门实例列表.set(唯一标识, 实例);
			    门实例映射.set(门数据.唯一标识符串, 实例);
			});
			        }
			
			        楼层数据.地牢数组 = Array(地牢大小)
			.fill()
			.map((_, y) =>
			    Array(地牢大小)
			        .fill()
			        .map((_, x) => {
			            const 单元格数据 =
			                楼层存档数据.序列化地牢格子?.[y]?.[x];
			            return 恢复单元格(
			                单元格数据,
			                x,
			                y,
			                全局物品实例映射,
			                new Map(),
			                门实例映射
			            );
			        })
			);
			        for (let y = 0; y < 地牢大小; y++) {
			for (let x = 0; x < 地牢大小; x++) {
			    const 单元格 = 楼层数据.地牢数组[y][x];
			    if (单元格.临时门标识符串) {
			        const 门实例 = 门实例映射.get(
			            单元格.临时门标识符串
			        );
			        if (门实例) {
			            单元格.标识 = 门实例.唯一标识;
			        }
			        delete 单元格.临时门标识符串;
			    }
			}
			        }
			
			        const 当前楼层怪物映射 = new Map();
			        if (楼层存档数据.序列化怪物列表) {
			楼层数据.所有怪物 = 楼层存档数据.序列化怪物列表
			    .map((怪物数据) =>
			        恢复怪物(
			            怪物数据,
			            全局物品实例映射,
			            当前楼层怪物映射
			        )
			    )
			    .filter((m) => m != null);
			        }
			
			        楼层数据.所有怪物.forEach((怪物实例, 索引) => {
			if (怪物实例.x !== null && 怪物实例.y !== null) {
			    const 单元格 =
			        楼层数据.地牢数组[怪物实例.y]?.[怪物实例.x];
			    if (单元格) {
			        if (!(单元格.关联怪物 instanceof 怪物)) {
			            单元格.关联怪物 = 怪物实例;
			            单元格.类型 = 单元格类型.怪物;
			        }
			    }
			}
			if (怪物实例.临时仇恨目标标识) {
			    const 标识 = 怪物实例.临时仇恨目标标识;
			    if (标识 === "玩家") {
			        怪物实例.仇恨 = 玩家;
			    } else if (标识.startsWith("怪物_")) {
			        const 仇恨索引 = parseInt(标识.split("_")[1]);
			        怪物实例.仇恨 =
			            当前楼层怪物映射.get(仇恨索引) || null;
			    }
			    delete 怪物实例.临时仇恨目标标识;
			}
			if (
			    怪物实例 instanceof 召唤师怪物 &&
			    怪物实例.临时召唤物索引列表
			) {
			    怪物实例.当前召唤物列表 =
			        怪物实例.临时召唤物索引列表
			            .map((召唤索引) =>
			                当前楼层怪物映射.get(召唤索引)
			            )
			            .filter((仆从) => 仆从 != null);
			    delete 怪物实例.临时召唤物索引列表;
			}
			if (
			    怪物实例 instanceof 幽灵仆从 &&
			    怪物实例.临时召唤者索引 !== undefined
			) {
			    怪物实例.召唤者 =
			        当前楼层怪物映射.get(怪物实例.临时召唤者索引) ||
			        null;
			    delete 怪物实例.临时召唤者索引;
			}
			if (
			    怪物实例 instanceof 大魔法师 &&
			    怪物实例.临时分身索引 !== undefined
			) {
			    怪物实例.分身 =
			        当前楼层怪物映射.get(怪物实例.临时分身索引) ||
			        null;
			    delete 怪物实例.临时分身索引;
			}
			if (
			    怪物实例 instanceof 旋风怪物 &&
			    怪物实例.临时召唤物索引列表
			) {
			    怪物实例.当前召唤物列表 =
			        怪物实例.临时召唤物索引列表
			            .map((召唤索引) =>
			                当前楼层怪物映射.get(召唤索引)
			            )
			            .filter((旋) => 旋 instanceof 旋风);
			    delete 怪物实例.临时召唤物索引列表;
			}
			if (怪物实例.临时状态效果) {
			    const 状态数据 = 怪物实例.临时状态效果;
			    new 状态效果(
			        状态数据.类型,
			        状态数据.颜色,
			        状态数据.图标,
			        状态数据.持续时间,
			        状态数据.剩余回合,
			        null,
			        怪物实例,
			        状态数据.强度
			    );
			    delete 怪物实例.临时状态效果;
			}
			        });
			        const 蜈蚣部分映射 = new Map();
楼层数据.所有怪物.forEach(m => {
    if (m.存档ID) {
        蜈蚣部分映射.set(m.存档ID, m);
    }
});

楼层数据.所有怪物.forEach(m => {
    if (m instanceof 蜈蚣怪物 && m.临时身体部位ID列表) {
        m.身体部位 = m.临时身体部位ID列表.map(id => 蜈蚣部分映射.get(id)).filter(Boolean);
        delete m.临时身体部位ID列表;
    }
    if (m instanceof 蜈蚣部位) {
        if (m.临时主体ID) {
            m.主体 = 蜈蚣部分映射.get(m.临时主体ID);
            delete m.临时主体ID;
        }
        if (m.临时跟随ID) {
            m.跟随 = 蜈蚣部分映射.get(m.临时跟随ID);
            delete m.临时跟随ID;
        }
    }
});
			
			        if (楼层存档数据.序列化物品列表) {
			楼层数据.所有计时器 = 楼层存档数据.序列化物品列表
			    .map((物品数据) => {
			        let 实例 = 全局物品实例映射.get(
			            物品数据.唯一标识符串
			        );
			        if (!实例) {
			            实例 = 恢复物品(物品数据, 全局物品标识映射);
			            if (实例)
			                全局物品实例映射.set(
			                    物品数据.唯一标识符串,
			                    实例
			                );
			        }
			        return 实例;
			    })
			    .filter((b) => b != null);
			        }
			
			        for (const 物品实例 of 全局物品实例映射.values()) {
			if (物品实例 instanceof 宠物) {
			    const 装备标识 =
			        物品实例.自定义数据.get("装备标识") || {};
			    const 恢复后装备 = {};
			    for (const 槽位 in 装备标识) {
			        const 标识符串 = 装备标识[槽位];
			        if (标识符串) {
			            const 装备物品实例 =
			                全局物品实例映射.get(标识符串);
			            if (
			                装备物品实例 &&
			                ((槽位 === "武器" &&
			                    装备物品实例 instanceof 武器类) ||
			                    (槽位 === "防具" &&
			                        装备物品实例 instanceof
			                            防御装备类))
			            ) {
			                恢复后装备[槽位] = 装备物品实例;
			            }
			        } else {
			            恢复后装备[槽位] = null;
			        }
			    }
			    物品实例.自定义数据.set("装备", 恢复后装备);
			} else if (物品实例 instanceof 折跃门) {
			    const 目标房间ID =
			        物品实例.自定义数据.get("目标房间");
			    if (
			        目标房间ID !== null &&
			        目标房间ID !== undefined
			    ) {
			        const 目标房间 = 楼层数据.房间列表.find(
			            (r) => r.id === 目标房间ID.id
			        );
			        if (目标房间) {
			            物品实例.自定义数据.set(
			                "目标房间",
			                目标房间
			            );
			        }
			    } else {
			        物品实例.自定义数据.set("目标房间", null);
			    }
			} else if (
			    物品实例 instanceof 神秘商人 ||
			    物品实例 instanceof 物品祭坛
			) {
			    const 库存序列化 =
			        物品实例.自定义数据.get("库存序列化") || [];
			    const 恢复后库存 = [];
			    库存序列化.forEach((物品数据) => {
			        let 库存物品实例 = 全局物品实例映射.get(
			            物品数据.唯一标识符串
			        );
			        if (!库存物品实例) {
			            库存物品实例 = 恢复物品(
			                物品数据,
			                全局物品标识映射
			            );
			            if (库存物品实例)
			                全局物品实例映射.set(
			                    物品数据.唯一标识符串,
			                    库存物品实例
			                );
			        }
			        if (库存物品实例) {
			            恢复后库存.push(库存物品实例);
			        }
			    });
			    物品实例.自定义数据.set("库存", 恢复后库存);
			}
			        }
			        if (
			楼层存档数据.挑战状态列表 &&
			Array.isArray(楼层存档数据.挑战状态列表)
			        ) {
			楼层存档数据.挑战状态列表.forEach((存档的挑战状态) => {
			    const 对应房间 = 楼层数据.房间列表.find(
			        (r) => r.id === 存档的挑战状态.id
			    );
			    if (对应房间 && 存档的挑战状态.状态) {
			        对应房间.类型 = "挑战房间";
			        对应房间.挑战状态 = JSON.parse(
			            JSON.stringify(存档的挑战状态.状态)
			        );
			
			        if (
			            对应房间.挑战状态.波次内怪物 &&
			            Array.isArray(对应房间.挑战状态.波次内怪物)
			        ) {
			            对应房间.挑战状态.波次内怪物 =
			                对应房间.挑战状态.波次内怪物
			                    .map((怪物标识符) => {
			                        if (
			                            typeof 怪物标识符 ===
			                                "string" &&
			                            怪物标识符.startsWith(
			                                "怪物_"
			                            )
			                        ) {
			                            const 索引 = parseInt(
			                                怪物标识符.split("_")[1]
			                            );
			                            return (
			                                楼层数据.所有怪物[
			                                    索引
			                                ] || null
			                            );
			                        }
			                        return null;
			                    })
			                    .filter((m) => m !== null);
			        }
			
			        if (
			            对应房间.挑战状态.原始门数据 &&
			            Array.isArray(对应房间.挑战状态.原始门数据)
			        ) {
			            对应房间.挑战状态.原始门数据.forEach(
			                (门数据) => {
			                    if (
			                        门数据.原标识 &&
			                        typeof 门数据.原标识 ===
			                            "string"
			                    ) {
			                        let 门符号 =
			                            全局物品标识映射.get(
			                                门数据.原标识
			                            );
			                        if (
			                            !门符号 &&
			                            门数据.原标识.startsWith(
			                                "Symbol("
			                            )
			                        ) {
			                            const description =
			                                门数据.原标识.slice(
			                                    7,
			                                    -1
			                                );
			                            门符号 =
			                                Symbol(description);
			                            全局物品标识映射.set(
			                                门数据.原标识,
			                                门符号
			                            );
			                        }
			                        门数据.原标识 =
			                            门符号 || 门数据.原标识;
			                    }
			                }
			            );
			        }
			    }
			});
			        }
			        if (楼层存档数据.序列化玩家仆从索引) {
    楼层存档数据.序列化玩家仆从索引.forEach(索引 => {
        const 仆从 = 楼层数据.所有怪物[索引];
        if (仆从 instanceof 骷髅仆从 && !玩家仆从列表.includes(仆从)) {
            玩家仆从列表.push(仆从);
        }
    });
}
			        
			        楼层数据.所有怪物.forEach(monster => {
			if (monster instanceof 王座守护者) {
			    monster.皇家守卫列表 = (monster.临时守卫索引列表 || []).map(index => 楼层数据.所有怪物[index]).filter(Boolean);
			    monster.激活的墓碑列表 = (monster.临时墓碑索引列表 || []).map(index => 楼层数据.所有怪物[index]).filter(Boolean);
			    delete monster.临时守卫索引列表;
			    delete monster.临时墓碑索引列表;
			}
			        });
			        
			        const allFloorItems = [...(楼层数据.所有计时器 || []), ...(地上物品实例映射.values() || [])];
			        allFloorItems.forEach(item => {
			if (item instanceof 刷怪笼 && item.临时生成物标识列表) {
			    item.自定义数据.set('当前生成物列表', item.临时生成物标识列表.map(id => {
			        if (typeof id === 'string' && id.startsWith('怪物_')) {
			            const index = parseInt(id.split('_')[1]);
			            return 楼层数据.所有怪物[index] || null;
			        }
			        return 全局物品实例映射.get(id) || null;
			    }).filter(Boolean));
			    delete item.临时生成物标识列表;
			}
			        });
			
			        console.log(`楼层 ${层号} 恢复完成`);
			        return 楼层数据;
			    } catch (e) {
			        console.error(`恢复楼层 ${层号} 失败:`, e);
			        return null;
			    }
			}
			function 导出存档() {
			    if (是否为教程层) {
			        显示通知("不支持在教程关卡导出存档", "错误");
			        return;
			    }
			    if (游戏状态 === "图鉴") {
			        显示通知("不支持在图鉴导出存档", "错误");
			        return;
			    }
			    if (是否是自定义关卡) {
			        显示通知("不支持在创意关卡导出存档", "错误");
			        return;
			    }
			    if (游戏状态 === "地图编辑器" || 游戏状态 === "编辑器游玩") {
			    显示通知("不支持在地图编辑器导出存档", "错误");
			        return;
			    }
			    if (游戏状态 === "地图编辑器" || 游戏状态 === "死亡界面" || 游戏状态==="胜利"||游戏状态==="图鉴选择") return;
			    玩家属性.允许移动 -= 1;
			
			    const 存档字符串 = 保存游戏状态(); // 调用只返回字符串的版本
			    玩家属性.允许移动 += 1;
			    if (存档字符串) {
			        const 数据块 = new Blob([存档字符串], {
			            type: "application/json",
			        });
			        const 下载链接 = URL.createObjectURL(数据块);
			        const 链接元素 = document.createElement("a");
			        链接元素.href = 下载链接;
			        // 文件名包含日期和时间戳
			        const 时间戳 = new Date()
			            .toISOString()
			            .replace(/[:.]/g, "-");
			        链接元素.download = `中文地牢存档_${时间戳}.json`;
			        document.body.appendChild(链接元素);
			        链接元素.click(); // 模拟点击下载
			        document.body.removeChild(链接元素); // 清理 DOM
			        URL.revokeObjectURL(下载链接); // 释放对象 URL
			        显示通知("存档已导出为文件。", "成功"); // 导出成功提示
			    } else {
			        显示通知("导出存档失败！", "错误"); // 保存失败时提示
			    }
			}
			
			function 导入存档(存档字符串) {
			    try {
			        const 存档数据 = JSON.parse(存档字符串);
					if (!开发者模式) {
			
			        if (存档数据.isPublished) {
			            显示通知("无法通过此按钮加载已发布的创意关卡！", "错误");
			            return;
			        }
			
			        if (Object.keys(存档数据.编辑器状态数据).length!==0) {
			            显示通知("无法通过此按钮加载地图编辑器文件！", "错误");
			            return;
			        }
				}
			
			        if (存档数据 && 存档数据.版本) {
			            if (存档数据.版本 === 存档版本) {
			                启动游戏(存档数据);
			                if(已初始化 > 0) 初始化装备系统()
			                if(已初始化 > 0) 初始化背包事件监听()
			                if(已初始化 > 0) 动画帧();
			            } else {
			                显示通知("存档版本不匹配！", "错误");
			            }
			        } else {
			            显示通知("存档数据无效或缺少版本信息！", "错误");
			        }
			    } catch (错误) {
			        console.error("导入存档失败:", 错误);
			        显示通知("导入存档失败，数据格式错误或损坏！", "错误");
			    }
			}
			
			读取存档按钮.addEventListener("click", () => {
			    const 文件输入控件 = document.getElementById("存档文件输入");
			    文件输入控件.value = ""; // 清空，确保 change 事件触发
			
			    // 为本次点击设置专属的 onchange 事件
			    文件输入控件.onchange = (事件) => {
			        const 选择的文件 = 事件.target.files[0];
			        if (!选择的文件) return;
			
			        if (!选择的文件.name.toLowerCase().endsWith(".json")) {
			显示通知("请选择有效的 JSON 存档文件！", "错误");
			return;
			        }
			
			        const 文件阅读器 = new FileReader();
			        文件阅读器.onload = (读取事件) => {
			const 存档字符串 = 读取事件.target.result;
			导入存档(存档字符串); // 调用正确的存档加载函数
			        };
			        文件阅读器.onerror = () => 显示通知("读取存档文件失败！", "错误");
			        文件阅读器.readAsText(选择的文件);
			
			        // 清理，防止下次误触发
			        文件输入控件.onchange = null; 
			    };
			
			    文件输入控件.click();
			});
			
			
			
			读凭证按钮.addEventListener("click", () => {
			    const 凭证 = prompt("请输入死亡凭证:");
			    if (凭证) {
			        const parts = 凭证.split("-");
			        if (parts.length === 3) {
			            const L = parseInt(parts[0]);
			            if (!isNaN(L) && 验证死亡凭证(凭证, L)) {
			                alert(`凭证有效！记录最高层数：${L}`);
			            } else {
			                alert("无效的死亡凭证！");
			            }
			        } else {
			            alert("凭证格式错误！");
			        }
			    }
			});
			function 生成图鉴地牢(分区索引 = 0, 每层条目数 = 9) {
			    // 提供默认值
			    
			    地牢 = Array(地牢大小)
			        .fill()
			        .map((_, y) =>
			            Array(地牢大小)
			                .fill()
			                .map((_, x) => new 单元格(x, y))
			        );
			    房间列表 = [];
			    上锁房间列表 = []; 
			    所有怪物 = []; 
			    怪物状态表 = new WeakMap(); 
			    门实例列表 = new Map();
			    房间地图 = Array(地牢大小)
			        .fill()
			        .map(() => Array(地牢大小).fill(-1));
			    已访问房间 = new Set(); 
			
			    
			    const 所有条目定义 = [
			        ...所有物品定义.map((def) => ({
			            ...def,
			            图鉴类型: "物品",
			        })),
			        ...所有怪物定义.map((def) => ({
			            ...def,
			            图鉴类型: "怪物",
			        })),
			    ];
			    const 总条目数 = 所有条目定义.length;
			
			    
			    const 房间尺寸 = 5; 
			    const 间距 = -1; 
			    const 走廊宽度 = 3; 
			    const 中心Y = Math.floor(地牢大小 / 2); 
			
			    
			    const 起始条目索引 = 分区索引 * 每层条目数;
			    const 结束条目索引 = Math.min(
			        起始条目索引 + 每层条目数,
			        总条目数
			    ); 
			    const 当前分区条目数 = 结束条目索引 - 起始条目索引;
			    if (当前分区条目数 <= 0) {
			        console.warn(`图鉴分区 ${分区索引 + 1} 没有条目可显示。`);
			        
			        玩家初始位置.x = Math.floor(地牢大小 / 2);
			        玩家初始位置.y = 中心Y;
			        玩家.x = 玩家初始位置.x;
			        玩家.y = 玩家初始位置.y;
			        更新视口();
			        return; 
			    }
			
			    
			    const 走廊起始X = 5; 
			    const 走廊结束X = Math.min(
			        地牢大小 - 2,
			        走廊起始X + 当前分区条目数 * (房间尺寸 + 间距) + 4
			    );
			    for (let x = 走廊起始X; x <= 走廊结束X; x++) {
			        for (
			            let dy = -Math.ceil(走廊宽度 / 2);
			            dy <= Math.floor(走廊宽度 / 2);
			            dy++
			        ) {
			            const y = 中心Y + dy;
			            if (y >= 0 && y < 地牢大小 && 地牢[y]?.[x]) {
			                
			                地牢[y][x].背景类型 = 单元格类型.走廊;
			            }
			        }
			    }
			
			    
			    let 当前X = 走廊起始X + 4; 
			    let 房间ID计数 = 0;
			    let 实际放置条目计数 = 0; 
			
			    
			    const 放置条目 = (条目定义, 类型) => {
			        
			        const 房间Y偏移 = Math.floor(走廊宽度 / 2) + 2; 
			        const 房间Y =
			            中心Y +
			            (实际放置条目计数 % 2 === 0
			                ? -(房间Y偏移 + 房间尺寸)
			                : 房间Y偏移); 
			        const 房间起始X = 当前X;
			        const 房间起始Y = 房间Y;
			
			        
			        if (
			            房间起始X + 房间尺寸 >= 地牢大小 ||
			            房间起始Y < 0 ||
			            房间起始Y + 房间尺寸 >= 地牢大小
			        ) {
			            console.warn(
			                `图鉴房间 ${房间ID计数} (类型: ${类型}) 在 (${房间起始X}, ${房间起始Y}) 超出边界，跳过。`
			            );
			            当前X += 房间尺寸 + 间距; 
			            
			            return false; 
			        }
			
			        
			        const 新房间 = {
			            x: 房间起始X,
			            y: 房间起始Y,
			            w: 房间尺寸,
			            h: 房间尺寸,
			            id: 房间ID计数,
			            门: [],
			            类型: "图鉴展示", 
			        };
			        房间列表.push(新房间);
			        放置房间(新房间); 
			        房间列表.sort((a,b)=>a.id-b.id)
			
			        
			        let 门X = 房间起始X + Math.floor(房间尺寸 / 2);
			        let 门Y房间侧, 门Y走廊侧;
			        if (实际放置条目计数 % 2 === 0) {
			            
			            门Y房间侧 = 房间起始Y + 房间尺寸 - 1; 
			            门Y走廊侧 = 门Y房间侧 + 1; 
			        } else {
			            
			            门Y房间侧 = 房间起始Y; 
			            门Y走廊侧 = 门Y房间侧 - 1; 
			        }
			
			        
			        if (地牢[门Y房间侧]?.[门X] && 地牢[门Y走廊侧]?.[门X]) {
			            const 门实例 = new 门({
			                关联房间ID: 新房间.id,
			                位置: { x: 门X, y: 门Y房间侧 },
			            }); 
			            地牢[门Y房间侧][门X].背景类型 = 单元格类型.门;
			            地牢[门Y走廊侧][门X].背景类型 = 单元格类型.门;
			            地牢[门Y房间侧][门X].标识 = 门实例.唯一标识; 
			            地牢[门Y走廊侧][门X].标识 = 门实例.唯一标识;
			            门实例列表.set(门实例.唯一标识, 门实例); 
			            新房间.门.push({ x: 门X, y: 门Y房间侧 }); 
			            新房间.门.push({ x: 门X, y: 门Y走廊侧 });
			            
			            地牢[门Y房间侧][门X].墙壁 = {
			                上: false,
			                下: false,
			                左: false,
			                右: false,
			            };
			            地牢[门Y走廊侧][门X].墙壁 = {
			                上: false,
			                下: false,
			                左: false,
			                右: false,
			            };
			            
			            if (地牢[门Y房间侧 + 1]?.[门X])
			                地牢[门Y房间侧 + 1][门X].墙壁.上 = false;
			            if (地牢[门Y房间侧 - 1]?.[门X])
			                地牢[门Y房间侧 - 1][门X].墙壁.下 = false;
			            if (地牢[门Y走廊侧 + 1]?.[门X])
			                地牢[门Y走廊侧 + 1][门X].墙壁.上 = false;
			            if (地牢[门Y走廊侧 - 1]?.[门X])
			                地牢[门Y走廊侧 - 1][门X].墙壁.下 = false;
			        } else {
			            console.warn(
			                `无法为图鉴房间 ${新房间.id} 在 (${门X}, ${门Y房间侧}) 和 (${门X}, ${门Y走廊侧}) 放置门。`
			            );
			        }
			
			        
			        const 放置X = 房间起始X + Math.floor(房间尺寸 / 2);
			        const 放置Y = 房间起始Y + Math.floor(房间尺寸 / 2);
			        if (类型 === "物品") {
			            try {
			                const 实例 = new 条目定义.类({}); 
			                实例.堆叠数量 = 1; 
			                if (实例 instanceof 卷轴类) {
			                    实例.自定义数据.set("已解锁", true);
			                }
			                放置物品到单元格(实例, 放置X, 放置Y); 
			            } catch (错误) {
			                console.error(
			                    `图鉴：无法实例化物品 ${条目定义.类?.name}:`,
			                    错误
			                );
			            }
			        } else if (类型 === "怪物") {
			            try {
			                const 实例 = new 条目定义.类({
			                    x: 放置X,
			                    y: 放置Y,
			                    状态: 怪物状态.休眠,
			                }); 
			                实例.状态 = 怪物状态.休眠; 
			                放置怪物到单元格(实例, 放置X, 放置Y); 
			            } catch (错误) {
			                console.error(
			                    `图鉴：无法实例化怪物 ${条目定义.类?.name}:`,
			                    错误
			                );
			            }
			        }
			
			        
			        当前X += 房间尺寸 + 间距;
			        房间ID计数++;
			        实际放置条目计数++; 
			        return true; 
			    };
			
			    
			    for (let i = 起始条目索引; i < 结束条目索引; i++) {
			        const 当前条目定义 = 所有条目定义[i];
			        放置条目(当前条目定义, 当前条目定义.图鉴类型);
			    }
			
			    
			    玩家初始位置.x = 走廊起始X + 1; 
			    玩家初始位置.y = 中心Y;
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			    const 总分区数 = Math.ceil(总条目数 / 每层条目数);
			    const 楼梯上X = 走廊起始X;
			    const 楼梯上Y = 中心Y;
			    const 楼梯下X = 走廊结束X;
			    const 楼梯下Y = 中心Y;
			
			    
			    if (分区索引 > 0) {
			        
			        const 上楼梯实例 = {
			            图标: 楼梯图标.上楼,
			            显示图标: 楼梯图标.上楼,
			            类型: "楼梯", 
			            使用: () => {
							所有计时器=[];
			                进入图鉴地牢(分区索引 - 1, 每层条目数);
			            },
			            获取名称: () => "上一个分区",
			            唯一标识: Symbol("图鉴上楼梯"), 
			            自定义数据: new Map(),
			            品质: 1,
			            颜色索引: 颜色表.length,
			            堆叠数量: 1,
			            最大堆叠数量: 1,
			            能否拾起: false,
			            是否正常物品: false,
			            是否隐藏: false,
			            是否为隐藏物品: false,
			            效果描述: null,
			            已装备: false,
			            装备槽位: null,
			            颜色表: 颜色表,
			        };
			        
			        if (
			            地牢[楼梯上Y]?.[楼梯上X] &&
			            地牢[楼梯上Y][楼梯上X].背景类型 === 单元格类型.走廊
			        ) {
			            放置物品到单元格(
			                上楼梯实例,
			                楼梯上X,
			                楼梯上Y,
			                单元格类型.楼梯上楼
			            );
			        } else {
			            console.warn(
			                `无法在 (${楼梯上X}, ${楼梯上Y}) 放置上楼梯`
			            );
			        }
			    }
			
			    
			    if (分区索引 < 总分区数 - 1) {
			        
			        const 下楼梯实例 = {
			            图标: 楼梯图标.下楼,
			            显示图标: 楼梯图标.下楼,
			            类型: "楼梯", 
			            使用: () => {
							所有计时器=[];
			                进入图鉴地牢(分区索引 + 1, 每层条目数);
			            },
			            获取名称: () => "下一个分区",
			            唯一标识: Symbol("图鉴下楼梯"), 
			            自定义数据: new Map(),
			            品质: 1,
			            颜色索引: 颜色表.length,
			            堆叠数量: 1,
			            最大堆叠数量: 1,
			            能否拾起: false,
			            是否正常物品: false,
			            是否隐藏: false,
			            是否为隐藏物品: false,
			            效果描述: null,
			            已装备: false,
			            装备槽位: null,
			            颜色表: 颜色表,
			        };
			        
			        if (
			            地牢[楼梯下Y]?.[楼梯下X] &&
			            地牢[楼梯下Y][楼梯下X].背景类型 === 单元格类型.走廊
			        ) {
			            放置物品到单元格(
			                下楼梯实例,
			                楼梯下X,
			                楼梯下Y,
			                单元格类型.楼梯下楼
			            );
			        } else {
			            console.warn(
			                `无法在 (${楼梯下X}, ${楼梯下Y}) 放置下楼梯`
			            );
			        }
			    }
			    const 初始武器 = new 钢制长剑({ 不可破坏: true });
			    放置物品到单元格(初始武器, 玩家.x + 2, 玩家.y);
			    放置物品到单元格(
			        new 迅捷卷轴({
			            数量: 1,
			            已解锁: true,
			            能量消耗: 0,
			        }),
			        玩家.x + 1,
			        玩家.y
			    );
			
			    
			    生成墙壁(); 
			    房间列表.forEach((房间) => 更新房间墙壁(房间)); 
			
			    更新视口(); 
			}
			function 进入图鉴地牢(分区索引, 每层条目数) {
			    
			    当前层数 = -2 - 分区索引; // 用负数区分不同分区
			    最大背包容量 = 24;
			    所有地牢层 = new Map();
			    document.getElementById("logContent").innerHTML = "";
			    document.querySelector(".health-bar").style.width = "100%";
			    document.querySelector(".power-bar").style.width = "100%";
			
			    生成图鉴地牢(分区索引, 每层条目数); // 调用生成函数，传入分区信息
			
			    更新背包显示();
			    更新装备显示();
			    更新界面状态();
			    if(已初始化 > 0) 动画帧(); // 启动动画
			    隐藏主菜单(); // 确保主菜单隐藏
			    是否为教程层 = false;
			    document.getElementById("跳过教程按钮").style.display = "none";
			    最高教程阶段 = 6;
			    游戏状态 = "图鉴";
			    显示通知(`已进入图鉴分区 ${分区索引 + 1}`, "信息");
			}
			function 打开图鉴分区选择() {

			    游戏状态 = "图鉴选择"; 
			    收集所有定义();
			    
			    主菜单容器.style.opacity = 0;
			    主菜单容器.style.pointerEvents = "none";
			    document.body.classList.remove("游戏进行中"); 
			
			    
			    const 物品总数 = 所有物品定义.length;
			    const 怪物总数 = 所有怪物定义.length;
			    const 总条目数 = 物品总数 + 怪物总数;
			    const 房间尺寸 = 5; 
			    const 间距 = -1; 
			    
			    const 可用宽度 = 地牢大小 - 10;
			    const 每侧房间数 = Math.floor(可用宽度 / (房间尺寸 + 间距));
			    const 每层条目数 = Math.max(1, 每侧房间数); 
			    const 总分区数 = Math.ceil(总条目数 / 每层条目数);
			
			    
			    const 遮罩 = document.getElementById("图鉴分区选择遮罩");
			    const 窗口 = document.getElementById("图鉴分区选择窗口");
			    const 列表容器 = document.getElementById("图鉴分区列表容器");
			    const 关闭按钮 = document.getElementById("关闭图鉴选择按钮");
			
			    列表容器.innerHTML = ""; 
			
			    if (总分区数 === 0) {
			        列表容器.innerHTML =
			            "<p style='text-align: center; color: #888;'>图鉴内容为空。</p>";
			    } else {
			        for (let i = 0; i < 总分区数; i++) {
			            const 分区按钮 = document.createElement("button");
			            分区按钮.className = "菜单按钮"; 
			            分区按钮.style.minWidth = "150px"; 
			            分区按钮.textContent = `图鉴分区 ${i + 1}`;
			            分区按钮.onclick = () => {
			                关闭图鉴分区选择(); 
			                初始化canvas();
			                if(已初始化 > 0) 初始化装备系统();
			                if(已初始化 > 0) 初始化背包事件监听();
			                进入图鉴地牢(i, 每层条目数);
			            };
			            列表容器.appendChild(分区按钮);
			        }
			    }
			
			    
			    关闭按钮.onclick = 关闭图鉴分区选择;
			
			    遮罩.style.display = "block";
			    
			    窗口.style.opacity = 0;
			    窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
			    requestAnimationFrame(() => {
			        窗口.style.transition =
			            "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
			        窗口.style.opacity = 1;
			        窗口.style.transform = "translate(-50%, -50%) scale(1)";
			    });
			}
			function 关闭图鉴分区选择() {
			    const 遮罩 = document.getElementById("图鉴分区选择遮罩");
			    const 窗口 = document.getElementById("图鉴分区选择窗口");
			    if (!遮罩 || !窗口 || 遮罩.style.display === "none") return; 
			
			    窗口.style.transition =
			        "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
			    窗口.style.opacity = 0;
			    窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
			    setTimeout(() => {
			        遮罩.style.display = "none";
			        
			        if (游戏状态 === "图鉴选择") {
			            显示主菜单();
			        }
			    }, 300); 
			}
			图鉴按钮.addEventListener("click", () => {
			    打开图鉴分区选择();
			});
			
			//初始化canvas();
			//初始化装备系统();
			if (window.innerWidth < 769) {
			    document.getElementById("小地图容器").classList.add("隐藏");
			}
			function 获取直线格子(x0, y0, x1, y1) {
			    const 格子列表 = [];
			    const ix0 = Math.floor(x0);
			    const iy0 = Math.floor(y0);
			    const ix1 = Math.floor(x1);
			    const iy1 = Math.floor(y1);
			
			    const dx = Math.abs(ix1 - ix0);
			    const dy = -Math.abs(iy1 - iy0);
			    let sx = ix0 < ix1 ? 1 : -1;
			    let sy = iy0 < iy1 ? 1 : -1;
			    let err = dx + dy;
			    let e2;
			
			    let 当前X = ix0;
			    let 当前Y = iy0;
			
			    while (true) {
			        格子列表.push({ x: 当前X, y: 当前Y });
			        if (当前X === ix1 && 当前Y === iy1) break;
			        e2 = 2 * err;
			        if (e2 >= dy) {
			            err += dy;
			            当前X += sx;
			        }
			        if (e2 <= dx) {
			            err += dx;
			            当前Y += sy;
			        }
			    }
			    return 格子列表;
			}
			function 放置怪物到房间(怪物实例, 目标房间) {
			    if (!怪物实例 || !目标房间) {
			        console.error("放置怪物到房间：无效的怪物实例或目标房间。");
			        return false;
			    }
			
			    if (怪物实例 instanceof 巨人怪物) {
			         for (let 尝试计数 = 0; 尝试计数 < 50; 尝试计数++) {
			            const 随机X = 目标房间.x + Math.floor(prng() * (目标房间.w - 2));
			            const 随机Y = 目标房间.y + Math.floor(prng() * (目标房间.h - 2));
			            if (放置巨人(怪物实例, 随机X, 随机Y)) {
			                怪物实例.房间ID = 目标房间.id;
			                return true;
			            }
			        }
			        console.warn(`在房间 ${目标房间.id} 多次尝试后未能放置巨人怪物。`);
			        return false;
			    }
			
			    let 放置成功 = false;
			    const 最大尝试次数 = 目标房间.w * 目标房间.h * 2; 
			
			    for (let 尝试计数 = 0; 尝试计数 < 最大尝试次数; 尝试计数++) {
			        const 随机X =
			            目标房间.x + Math.floor(prng() * 目标房间.w);
			        const 随机Y =
			            目标房间.y + Math.floor(prng() * 目标房间.h);
			
			        if (位置是否可用(随机X, 随机Y, false)) {
			            if (放置怪物到单元格(怪物实例, 随机X, 随机Y)) {
			                怪物实例.房间ID = 目标房间.id; 
			                放置成功 = true;
			                break; 
			            }
			        }
			    }
			
			    if (!放置成功) {
			        console.warn(
			            `在房间 ${目标房间.id} (${
			                目标房间.类型 || "未知类型"
			            }) 中多次尝试后未能放置怪物 ${
			                怪物实例.类型
			            }。房间可能已满或无合适位置。`
			        );
			    }
			    return 放置成功;
			}
			function isObject(value) {
  return typeof value === 'object' && value !== null;
}

/**
 * 深拷贝函数：支持对象、数组、Date、Map、Set 等类型，自动处理循环引用。
 *
 * @param {any} target - 要深拷贝的目标值
 * @returns {any} 返回深拷贝后的新对象
 */
function deepClone(target) {
  // 缓存已拷贝对象，防止循环引用导致栈溢出
  const map = new Map();
  /**
   * 递归克隆函数
   * @param {any} _value - 当前处理的值
   * @returns {any} 拷贝后的值
   */
  function clone(_value) {
    // 如果是已经处理过的对象，直接返回缓存结果（防止循环引用）
    if (map.has(_value)) return map.get(_value);

    // 原始类型（number、string、boolean、null、undefined、symbol）直接返回
    if (!isObject(_value)) return _value;

    // 函数类型不做处理，直接返回引用本身
    if (typeof _value === 'function') {
      map.set(_value, _value);
      return _value;
    }

    let result;

    // Date 类型
    if (_value instanceof Date) {
      result = new Date(_value);
      map.set(_value, result);
      return result;
    }

    // Map 类型
    if (_value instanceof Map) {
      result = new Map();
      map.set(_value, result);
      _value.forEach((val, key) => {
        result.set(key, clone(val));
      });
      return result;
    }

    // Set 类型
    if (_value instanceof Set) {
      result = new Set();
      map.set(_value, result);
      _value.forEach((item) => {
        result.add(clone(item));
      });
      return result;
    }

    // 普通对象或数组
    result = Array.isArray(_value) ? [] : {};
    map.set(_value, result);

    // 递归处理对象自身的可枚举属性（不包括原型链上的）
    for (const key in _value) {
      if (Object.hasOwn(_value, key)) {
        result[key] = clone(_value[key]);
      }
    }

    return result;
  }

  return clone(target);
}
			function 生成沉没的迷宫() {
			    // =================================================
			    // 1. 初始化与重置游戏状态
			    // =================================================
			    //console.log("正在生成特殊关卡：沉没的迷宫...");
			    地牢 = Array(地牢大小)
			        .fill()
			        .map((_, y) =>
			            Array(地牢大小)
			                .fill()
			                .map((_, x) => new 单元格(x, y))
			        );
			    房间列表 = [];
			    上锁房间列表 = [];
			    所有怪物 = [];
			    怪物状态表 = new WeakMap();
			    门实例列表 = new Map();
			    房间地图 = Array(地牢大小)
			        .fill()
			        .map(() => Array(地牢大小).fill(-1));
			    已访问房间 = new Set();
			    所有计时器 = [];
			    当前天气效果 = [];
			
			    // =================================================
			    // 2. 定义迷宫的房间布局
			    // =================================================
			    const 房间布局 = [
			        // --- 中央区域 ---
			        {
			            名称: "中央大厅",
			            id: 0,
			            x: 45,
			            y: 45,
			            w: 11,
			            h: 11,
			            门: [],
			        },
			        {
			            名称: "北翼大门",
			            id: 1,
			            x: 48,
			            y: 38,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			        {
			            名称: "东翼大门",
			            id: 2,
			            x: 58,
			            y: 48,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			        {
			            名称: "南翼大门",
			            id: 3,
			            x: 48,
			            y: 58,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			        {
			            名称: "西翼大门",
			            id: 4,
			            x: 38,
			            y: 48,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			
			        // --- 北翼：冰霜主题 ---
			        {
			            名称: "北翼_冰霜回廊",
			            id: 5,
			            x: 46,
			            y: 28,
			            w: 9,
			            h: 7,
			            门: [],
			        },
			        {
			            名称: "北翼_冰封大殿",
			            id: 6,
			            x: 47,
			            y: 15,
			            w: 7,
			            h: 9,
			            门: [],
			        },
			        {
			            名称: "北翼_守卫室",
			            id: 7,
			            x: 40,
			            y: 16,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			        {
			            名称: "北翼_宝库",
			            id: 8,
			            x: 56,
			            y: 16,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			
			        // --- 东翼：火焰与爆炸主题 ---
			        {
			            名称: "东翼_灼热通道",
			            id: 9,
			            x: 66,
			            y: 47,
			            w: 9,
			            h: 7,
			            门: [],
			        },
			        {
			            名称: "东翼_爆裂熔炉",
			            id: 10,
			            x: 79,
			            y: 46,
			            w: 9,
			            h: 9,
			            门: [],
			        },
			        {
			            名称: "东翼_守卫室",
			            id: 11,
			            x: 80,
			            y: 39,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			        {
			            名称: "东翼_宝库",
			            id: 12,
			            x: 80,
			            y: 57,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			
			        // --- 南翼：剧毒与自然主题 ---
			        {
			            名称: "南翼_藤蔓走廊",
			            id: 13,
			            x: 46,
			            y: 66,
			            w: 9,
			            h: 7,
			            门: [],
			        },
			        {
			            名称: "南翼_毒沼之心",
			            id: 14,
			            x: 47,
			            y: 77,
			            w: 7,
			            h: 9,
			            门: [],
			        },
			        {
			            名称: "南翼_守卫室",
			            id: 15,
			            x: 56,
			            y: 78,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			        {
			            名称: "南翼_宝库",
			            id: 16,
			            x: 40,
			            y: 78,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			
			        // --- 西翼：诡诈与敏捷主题 ---
			        {
			            名称: "西翼_幻影之道",
			            id: 17,
			            x: 26,
			            y: 47,
			            w: 9,
			            h: 7,
			            门: [],
			        },
			        {
			            名称: "西翼_诡诈大厅",
			            id: 18,
			            x: 13,
			            y: 46,
			            w: 9,
			            h: 9,
			            门: [],
			        },
			        {
			            名称: "西翼_守卫室",
			            id: 19,
			            x: 14,
			            y: 57,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			        {
			            名称: "西翼_宝库",
			            id: 20,
			            x: 14,
			            y: 39,
			            w: 5,
			            h: 5,
			            门: [],
			        },
			
			        // --- 最终区域 ---
			        {
			            名称: "四色祭坛",
			            id: 21,
			            x: 25,
			            y: 25,
			            w: 9,
			            h: 9,
			            门: [],
			        },
			        {
			            名称: "最终秘室",
			            id: 22,
			            x: 26,
			            y: 13,
			            w: 7,
			            h: 7,
			            门: [],
			        },
			    ];
			
			    const 获取房间 = (名称) =>
			        房间列表.find((r) => r.名称 === 名称);
			
			    房间列表 = 房间布局;
			    房间列表.forEach((房间配置) => {
			        放置房间(房间配置);
			    });
			
			    // =================================================
			    // 3. 连接房间，构建迷宫路径
			    // =================================================
			    let 已连接房间对 = new Set();
			    const 连接并生成走廊 = (房间A, 房间B) => {
			        const 房间对ID = [房间A.id, 房间B.id].sort().join("-");
			        if (已连接房间对.has(房间对ID)) return;
			        const 路径 = 连接房间(房间A, 房间B);
			        if (路径) {
			            生成走廊(路径);
			            已连接房间对.add(房间对ID);
			        } else {
			            console.warn(
			                `无法连接房间 '${房间A.名称}' 和 '${房间B.名称}'`
			            );
			        }
			    };
			
			    // --- 主干道连接 ---
			    连接并生成走廊(获取房间("中央大厅"), 获取房间("北翼大门"));
			    连接并生成走廊(获取房间("中央大厅"), 获取房间("东翼大门"));
			    连接并生成走廊(获取房间("中央大厅"), 获取房间("南翼大门"));
			    连接并生成走廊(获取房间("中央大厅"), 获取房间("西翼大门"));
			
			    // --- 各翼内部连接 ---
			    连接并生成走廊(获取房间("北翼大门"), 获取房间("北翼_冰霜回廊"));
			    连接并生成走廊(
			        获取房间("北翼_冰霜回廊"),
			        获取房间("北翼_冰封大殿")
			    );
			    连接并生成走廊(
			        获取房间("北翼_冰封大殿"),
			        获取房间("北翼_守卫室")
			    );
			    连接并生成走廊(
			        获取房间("北翼_冰封大殿"),
			        获取房间("北翼_宝库")
			    );
			
			    连接并生成走廊(获取房间("东翼大门"), 获取房间("东翼_灼热通道"));
			    连接并生成走廊(
			        获取房间("东翼_灼热通道"),
			        获取房间("东翼_爆裂熔炉")
			    );
			    连接并生成走廊(
			        获取房间("东翼_爆裂熔炉"),
			        获取房间("东翼_守卫室")
			    );
			    连接并生成走廊(
			        获取房间("东翼_爆裂熔炉"),
			        获取房间("东翼_宝库")
			    );
			
			    连接并生成走廊(获取房间("南翼大门"), 获取房间("南翼_藤蔓走廊"));
			    连接并生成走廊(
			        获取房间("南翼_藤蔓走廊"),
			        获取房间("南翼_毒沼之心")
			    );
			    连接并生成走廊(
			        获取房间("南翼_毒沼之心"),
			        获取房间("南翼_守卫室")
			    );
			    连接并生成走廊(
			        获取房间("南翼_毒沼之心"),
			        获取房间("南翼_宝库")
			    );
			
			    连接并生成走廊(获取房间("西翼大门"), 获取房间("西翼_幻影之道"));
			    连接并生成走廊(
			        获取房间("西翼_幻影之道"),
			        获取房间("西翼_诡诈大厅")
			    );
			    连接并生成走廊(
			        获取房间("西翼_诡诈大厅"),
			        获取房间("西翼_守卫室")
			    );
			    连接并生成走廊(
			        获取房间("西翼_诡诈大厅"),
			        获取房间("西翼_宝库")
			    );
			
			    // --- 最终区域连接 ---
			    连接并生成走廊(获取房间("四色祭坛"), 获取房间("最终秘室"));
			
			    // --- 增加迷宫复杂度的额外连接 ---
			    连接并生成走廊(获取房间("北翼_守卫室"), 获取房间("四色祭坛"));
			    连接并生成走廊(获取房间("西翼_宝库"), 获取房间("四色祭坛"));
			    连接并生成走廊(
			        获取房间("东翼_灼热通道"),
			        获取房间("北翼_冰霜回廊")
			    );
			    连接并生成走廊(
			        获取房间("南翼_藤蔓走廊"),
			        获取房间("西翼_幻影之道")
			    );
			
			    // =================================================
			    // 4. 设置门锁与钥匙 (已重构)
			    // =================================================
			    const 锁定房间门 = (房间名称, 颜色索引) => {
			        const 房间 = 获取房间(房间名称);
			        if (!房间) return;
			        上锁房间列表.push({ ...房间, 颜色索引 });
			        房间.门.forEach((门坐标) => {
			            const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
			            if (门单元格 && 门单元格.背景类型 === 单元格类型.门) {
			                门单元格.背景类型 = 单元格类型.上锁的门;
			                门单元格.钥匙ID = 房间.id;
			                门单元格.颜色索引 = 颜色索引;
			                const 门实例 = 门实例列表.get(门单元格.标识);
			                if (门实例) {
			                    门实例.类型 = "上锁的门";
			                    门实例.是否上锁 = true;
			                }
			            }
			        });
			    };
			
			    // --- 锁定除北翼外的所有区域 ---
			    锁定房间门("东翼大门", 1); // 蓝色
			    锁定房间门("南翼大门", 2); // 黄色
			    锁定房间门("西翼大门", 3); // 品红色
			    锁定房间门("最终秘室", 4); // 红色
			    // 注意：北翼大门现在是默认开启的，不调用锁定函数
			
			    // --- 放置钥匙，形成线性流程 ---
			    // 东翼钥匙（蓝色）放在北翼宝库
			    放置物品到房间(
			        new 钥匙({
			            对应门ID: 获取房间("东翼大门").id,
			            颜色索引: 1,
			            地牢层数: 当前层数,
			        }),
			        获取房间("北翼_宝库")
			    );
			    // 南翼钥匙（黄色）放在东翼宝库
			    放置物品到房间(
			        new 钥匙({
			            对应门ID: 获取房间("南翼大门").id,
			            颜色索引: 2,
			            地牢层数: 当前层数,
			        }),
			        获取房间("东翼_宝库")
			    );
			    // 西翼钥匙（品红色）放在南翼宝库
			    放置物品到房间(
			        new 钥匙({
			            对应门ID: 获取房间("西翼大门").id,
			            颜色索引: 3,
			            地牢层数: 当前层数,
			        }),
			        获取房间("南翼_宝库")
			    );
			    // 最终秘室钥匙（红色）放在西翼宝库
			    放置物品到房间(
			        new 钥匙({
			            对应门ID: 获取房间("最终秘室").id,
			            颜色索引: 4,
			            地牢层数: 当前层数,
			        }),
			        获取房间("西翼_宝库")
			    );
			
			    // =================================================
			    // 5. 填充内容：怪物、物品和特殊NPC
			    // =================================================
			    // --- 中央大厅 ---
			    放置物品到房间(new 探险家({}), 获取房间("中央大厅"));
			    放置物品到房间(new 物品祭坛({}), 获取房间("中央大厅"));
			
			    // --- 北翼 (冰霜) ---
			    放置怪物到房间(
			        new 冰冻怪物({ 强化: true }),
			        获取房间("北翼_冰封大殿")
			    );
			    放置怪物到房间(new 盔甲怪物({}), 获取房间("北翼_冰封大殿"));
			    放置怪物到房间(
			        new 盔甲怪物({ 强化: true }),
			        获取房间("北翼_守卫室")
			    );
			    放置物品到房间(
			        new 冰霜法杖({ 强化: true }),
			        获取房间("北翼_宝库")
			    );
			    放置怪物到房间(new 冰冻怪物({}), 获取房间("北翼_宝库")); // 宝库增加怪物
			
			    // --- 东翼 (火焰) ---
			    放置怪物到房间(
			        new 炸弹怪物({ 强化: true }),
			        获取房间("东翼_爆裂熔炉")
			    );
			    放置物品到房间(
			        new 喷火枪({ 强化: true }),
			        获取房间("东翼_爆裂熔炉")
			    );
			    放置怪物到房间(
			        new 盔甲怪物({ 强化: true }),
			        获取房间("东翼_守卫室")
			    );
			    放置物品到房间(
			        new 炸弹({ 数量: 5, 强化: true }),
			        获取房间("东翼_宝库")
			    );
			    放置怪物到房间(new 炸弹怪物({}), 获取房间("东翼_宝库")); // 宝库增加怪物
			
			    // --- 南翼 (剧毒) ---
			    放置怪物到房间(
			        new 仙人掌怪物({ 强化: true }),
			        获取房间("南翼_毒沼之心")
			    );
			    放置怪物到房间(new 腐蚀怪物({}), 获取房间("南翼_毒沼之心"));
			    放置怪物到房间(
			        new 盔甲怪物({ 强化: true }),
			        获取房间("南翼_守卫室")
			    );
			    放置物品到房间(
			        new 剧毒匕首({ 强化: true }),
			        获取房间("南翼_宝库")
			    );
			    放置怪物到房间(new 腐蚀怪物({}), 获取房间("南翼_宝库")); // 宝库增加怪物
			
			    // --- 西翼 (诡诈) ---
			    放置怪物到房间(
			        new 瞬移怪物({ 强化: true }),
			        获取房间("西翼_诡诈大厅")
			    );
			    放置怪物到房间(new 敏捷怪物({}), 获取房间("西翼_诡诈大厅"));
			    放置怪物到房间(
			        new 盔甲怪物({ 强化: true }),
			        获取房间("西翼_守卫室")
			    );
			    放置物品到房间(
			        new 隐身药水({ 数量: 2 }),
			        获取房间("西翼_宝库")
			    );
			    放置怪物到房间(new 伪装怪物({}), 获取房间("西翼_宝库")); // 宝库增加怪物
			
			    // --- 最终区域 ---
			    放置物品到单元格(
			        new 物品({ 名称: "绿色锁孔", 图标: "🟢", 能否拾起: false }),
			        27,
			        27
			    );
			    放置物品到单元格(
			        new 物品({ 名称: "蓝色锁孔", 图标: "🔵", 能否拾起: false }),
			        31,
			        27
			    );
			    放置物品到单元格(
			        new 物品({ 名称: "黄色锁孔", 图标: "🟡", 能否拾起: false }),
			        27,
			        31
			    );
			    放置物品到单元格(
			        new 物品({ 名称: "品红锁孔", 图标: "🟣", 能否拾起: false }),
			        31,
			        31
			    );
			
			    放置怪物到房间(
			        new 大魔法师({ 强化: true }),
			        获取房间("最终秘室")
			    );
			    放置物品到房间(
			        new 真言卷轴({ 强化: true, 已解锁: true }),
			        获取房间("最终秘室")
			    );
			
			    // =================================================
			    // 6. 最终设置
			    // =================================================
			    生成墙壁();
			    房间列表.forEach((房间) => 更新房间墙壁(房间));
			
			    const 起始房间 = 获取房间("中央大厅");
			    玩家初始位置.x = 起始房间.x + Math.floor(起始房间.w / 2);
			    玩家初始位置.y = 起始房间.y + Math.floor(起始房间.h / 2);
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			    已访问房间.add(起始房间.id);
			
			    放置楼梯(
			        获取房间("最终秘室"),
			        楼梯图标.下楼,
			        单元格类型.楼梯下楼
			    );
			
			    更新视口();
			    更新界面状态()
			}
			
			function 生成迷宫怪物(数量) {
			    const 迷宫尺寸 = 85;
			    const 偏移X = Math.floor((地牢大小 - 迷宫尺寸) / 2);
			    const 偏移Y = Math.floor((地牢大小 - 迷宫尺寸) / 2);
			    const 怪物候选池 = 怪物池["普通房间"].filter(
			        (m) =>
			            m.最小层 <= 5 &&
			            m.类.name !== "米诺陶" &&
			            m.类.name !== "大魔法师"
			    );
			
			    if (怪物候选池.length === 0) return;
			
			    for (let i = 0; i < 数量; i++) {
			        let 放置成功 = false;
			        for (let 尝试 = 0; 尝试 < 50; 尝试++) {
			            const x = 偏移X + Math.floor(prng() * 迷宫尺寸);
			            const y = 偏移Y + Math.floor(prng() * 迷宫尺寸);
			
			            if (
			                地牢[y]?.[x]?.背景类型 === 单元格类型.走廊 &&
			                !地牢[y][x].关联物品 &&
			                !地牢[y][x].关联怪物
			            ) {
			                const 距离玩家 =
			                    Math.abs(x - 玩家.x) + Math.abs(y - 玩家.y);
			                if (距离玩家 > 15) {
			                    const 怪物配置 =
			                        怪物候选池[
			                            Math.floor(
			                                prng() * 怪物候选池.length
			                            )
			                        ];
			                    const 新怪物 = new 怪物配置.类({
			                        强化: prng() < 0.3,
			                    });
			                    if (放置怪物到单元格(新怪物, x, y)) {
			                        新怪物.状态 = 怪物状态.活跃;
			                        新怪物.绘制血条();
			                        放置成功 = true;
			                        break;
			                    }
			                }
			            }
			        }
			    }
			}
			function 生成迷宫关卡() {
			    当前层数 = 5;
			    地牢 = Array(地牢大小)
			        .fill()
			        .map((_, y) =>
			            Array(地牢大小)
			                .fill()
			                .map((_, x) => new 单元格(x, y))
			        );
			    房间列表 = [];
			    上锁房间列表 = [];
			    所有怪物 = [];
			    怪物状态表 = new WeakMap();
			    门实例列表 = new Map();
			    房间地图 = Array(地牢大小)
			        .fill()
			        .map(() => Array(地牢大小).fill(-1));
			    已访问房间 = new Set();
			    所有计时器 = [];
			    当前天气效果 = [];
			
			    const 迷宫网格尺寸 = 43;
			    const 通道宽度 = 2;
			    const 迷宫尺寸 = 迷宫网格尺寸 * 通道宽度;
			    const 迷宫X偏移 = Math.floor((地牢大小 - 迷宫尺寸) / 2);
			    const 迷宫Y偏移 = Math.floor((地牢大小 - 迷宫尺寸) / 2);
			
			    let 迷宫网格 = Array(迷宫网格尺寸)
			        .fill(1)
			        .map(() => Array(迷宫网格尺寸).fill(1));
			    let 堆栈 = [];
			    let 起始格子X = 1,
			        起始格子Y = 1;
			    迷宫网格[起始格子Y][起始格子X] = 0;
			    堆栈.push({ x: 起始格子X, y: 起始格子Y });
			
			    while (堆栈.length > 0) {
			        let 当前节点 = 堆栈.pop();
			        let 邻居列表 = [];
			        const 方向数组 = [
			            [0, 2],
			            [0, -2],
			            [2, 0],
			            [-2, 0],
			        ];
			        方向数组.sort(() => prng() - 0.5);
			
			        for (const [方向X, 方向Y] of 方向数组) {
			            const 新格子X = 当前节点.x + 方向X;
			            const 新格子Y = 当前节点.y + 方向Y;
			            if (
			                新格子X > 0 &&
			                新格子X < 迷宫网格尺寸 - 1 &&
			                新格子Y > 0 &&
			                新格子Y < 迷宫网格尺寸 - 1 &&
			                迷宫网格[新格子Y][新格子X] === 1
			            ) {
			                邻居列表.push({
			                    x: 新格子X,
			                    y: 新格子Y,
			                    墙壁X: 当前节点.x + 方向X / 2,
			                    墙壁Y: 当前节点.y + 方向Y / 2,
			                });
			            }
			        }
			
			        if (邻居列表.length > 0) {
			            堆栈.push(当前节点);
			            let 选定邻居 = 邻居列表[0];
			            迷宫网格[选定邻居.墙壁Y][选定邻居.墙壁X] = 0;
			            迷宫网格[选定邻居.y][选定邻居.x] = 0;
			            堆栈.push({ x: 选定邻居.x, y: 选定邻居.y });
			        }
			    }
			
			    for (let 格子Y = 0; 格子Y < 迷宫网格尺寸; 格子Y++) {
			        for (let 格子X = 0; 格子X < 迷宫网格尺寸; 格子X++) {
			            if (迷宫网格[格子Y][格子X] === 0) {
			                for (let 偏移Y = 0; 偏移Y < 通道宽度; 偏移Y++) {
			                    for (let 偏移X = 0; 偏移X < 通道宽度; 偏移X++) {
			                        const 最终X =
			                            格子X * 通道宽度 + 偏移X + 迷宫X偏移;
			                        const 最终Y =
			                            格子Y * 通道宽度 + 偏移Y + 迷宫Y偏移;
			                        if (地牢[最终Y]?.[最终X]) {
			                            地牢[最终Y][最终X].背景类型 =
			                                单元格类型.走廊;
			                        }
			                    }
			                }
			            }
			        }
			    }
			    生成墙壁();
			
			    玩家初始位置.x = 起始格子X * 通道宽度 + 迷宫X偏移;
			    玩家初始位置.y = 起始格子Y * 通道宽度 + 迷宫Y偏移;
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			    已访问房间.add(-1);
			    放置楼梯(
			        { x: 玩家初始位置.x, y: 玩家初始位置.y, w: 2, h: 2 },
			        楼梯图标.上楼,
			        单元格类型.楼梯上楼
			    );
			    let 首领X, 首领Y;
			    let 首领已放置 = false;
			    for (
			        let 尝试次数 = 0;
			        尝试次数 < 100 && !首领已放置;
			        尝试次数++
			    ) {
			        let 格子X =
			            迷宫网格尺寸 - Math.floor(prng() * 5) - 2;
			        let 格子Y =
			            迷宫网格尺寸 - Math.floor(prng() * 5) - 2;
			        if (
			            格子X > 0 &&
			            格子Y > 0 &&
			            迷宫网格[格子Y][格子X] === 0
			        ) {
			            首领X = 格子X * 通道宽度 + 迷宫X偏移;
			            首领Y = 格子Y * 通道宽度 + 迷宫Y偏移;
			            if (
			                Math.abs(首领X - 玩家初始位置.x) +
			                    Math.abs(首领Y - 玩家初始位置.y) >
			                50
			            ) {
			                首领已放置 = true;
			            }
			        }
			    }
			    if (!首领已放置) {
			        首领X = (迷宫网格尺寸 - 2) * 通道宽度 + 迷宫X偏移;
			        首领Y = (迷宫网格尺寸 - 2) * 通道宽度 + 迷宫Y偏移;
			    }
			
			    const 首领 = new 米诺陶({ 强化: true });
			    放置怪物到单元格(首领, 首领X, 首领Y);
			    首领.状态 = 怪物状态.活跃;
			
			    const 物品数量 = 5 + Math.floor(prng() * 5);
			    const 可用物品池 = Object.values(物品池)
			        .flat()
			        .filter(
			            (i) =>
			                i.最小层 <= 5 &&
			                i.类.name !== "米诺陶" &&
			                i.类.name !== "大魔法师"
			        );
			
			    for (let i = 0; i < 物品数量; i++) {
			        let 物品X, 物品Y;
			        for (let 尝试次数 = 0; 尝试次数 < 50; 尝试次数++) {
			            const 格子X =
			                Math.floor(prng() * (迷宫网格尺寸 - 2)) + 1;
			            const 格子Y =
			                Math.floor(prng() * (迷宫网格尺寸 - 2)) + 1;
			            if (迷宫网格[格子Y][格子X] === 0) {
			                物品X = 格子X * 通道宽度 + 迷宫X偏移;
			                物品Y = 格子Y * 通道宽度 + 迷宫Y偏移;
			                if (位置是否可用(物品X, 物品Y, false)) {
			                    const 物品配置 =
			                        可用物品池[
			                            Math.floor(
			                                prng() * 可用物品池.length
			                            )
			                        ];
			                    if (物品配置.类.name !== "治疗药水") {
			                        放置物品到单元格(
			                            new 物品配置.类({
			                                强化: prng() < 0.2,
			                            }),
			                            物品X,
			                            物品Y
			                        );
			                        break;
			                    }
			                }
			            }
			        }
			    }
			
			    const 药水数量 = 4 + Math.floor(prng() * 3);
			    for (let i = 0; i < 药水数量; i++) {
			        let 药水X, 药水Y;
			        for (let 尝试次数 = 0; 尝试次数 < 50; 尝试次数++) {
			            const 格子X =
			                Math.floor(prng() * (迷宫网格尺寸 - 2)) + 1;
			            const 格子Y =
			                Math.floor(prng() * (迷宫网格尺寸 - 2)) + 1;
			            if (迷宫网格[格子Y][格子X] === 0) {
			                药水X = 格子X * 通道宽度 + 迷宫X偏移;
			                药水Y = 格子Y * 通道宽度 + 迷宫Y偏移;
			                if (位置是否可用(药水X, 药水Y, false)) {
			                    放置物品到单元格(
			                        new 治疗药水({ 强化: true }),
			                        药水X,
			                        药水Y
			                    );
			                    break;
			                }
			            }
			        }
			    }
			
			    生成迷宫怪物(15);
			
			    更新视口();
			    更新界面状态();
			    绘制();
			}
			function 生成迷宫出口(x, y) {
			    const 楼梯 = {
			        类型: "楼梯",
			        图标: 楼梯图标.下楼,
			        显示图标: 楼梯图标.下楼,
			        颜色索引: 颜色表.length,
			        使用: () => {
			            切换楼层(当前层数 + 1, false, null, true);
			        },
			        唯一标识: Symbol(`楼梯_下楼`),
			        获取名称: () => "下楼楼梯",
			        自定义数据: new Map(),
			        品质: 1,
			        能否拾起: false,
			        是否正常物品: false,
			        是否隐藏: false,
			        是否为隐藏物品: false,
			        效果描述: null,
			        已装备: false,
			        装备槽位: null,
			        堆叠数量: 1,
			        最大堆叠数量: 1,
			        颜色表: 颜色表,
			    };
			
			    if (位置是否可用(x, y, false)) {
			        放置物品到单元格(楼梯, x, y, 单元格类型.楼梯下楼);
			    } else {
			        切换楼层(当前层数 + 1, false, null, true);
			    }
			}
			function 检查房间连通性(房间) {
			    const 墙壁类型 = 单元格类型.墙壁;
			    const 地板类型 = 单元格类型.房间;
			
			    const 地板格子 = [];
			    for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
			        for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
			            if (地牢[y]?.[x]?.背景类型 === 地板类型) {
			                地板格子.push({ x, y });
			            }
			        }
			    }
			
			    if (地板格子.length === 0) return true;
			
			    const 起始点 = 地板格子[0];
			    const 队列 = [起始点];
			    const 已访问 = new Set([`${起始点.x},${起始点.y}`]);
			    let 可达计数 = 0;
			
			    while (队列.length > 0) {
			        const 当前 = 队列.shift();
			        可达计数++;
			
			        const 方向 = [
			            [0, 1],
			            [0, -1],
			            [1, 0],
			            [-1, 0],
			        ];
			        for (const [dx, dy] of 方向) {
			            const 邻居X = 当前.x + dx;
			            const 邻居Y = 当前.y + dy;
			            const 邻居键 = `${邻居X},${邻居Y}`;
			
			            if (
			                邻居X >= 房间.x &&
			                邻居X < 房间.x + 房间.w &&
			                邻居Y >= 房间.y &&
			                邻居Y < 房间.y + 房间.h &&
			                地牢[邻居Y]?.[邻居X]?.背景类型 === 地板类型 &&
			                !已访问.has(邻居键)
			            ) {
			                已访问.add(邻居键);
			                队列.push({ x: 邻居X, y: 邻居Y });
			            }
			        }
			    }
			
			    return 可达计数 === 地板格子.length;
			}
			
			function 生成符文圈群组(房间, 数量 = 1) {
			    for (let i = 0; i < 数量; i++) {
			        const 尺寸 = 2 + Math.floor(prng() * 2);
			        const 效果列表 = ["狂暴", "神龟", "缓慢", "中毒"];
			        // 为整个群组确定一个初始效果和周期
			        const 初始效果类型 =
			            效果列表[Math.floor(prng() * 效果列表.length)];
			        const 初始剩余周期 = Math.floor(prng() * 10);
			
			        let 放置成功 = false;
			        for (let 尝试 = 0; 尝试 < 20; 尝试++) {
			            const 起始X =
			                房间.x +
			                Math.floor(prng() * (房间.w - 尺寸));
			            const 起始Y =
			                房间.y +
			                Math.floor(prng() * (房间.h - 尺寸));
			
			            let 可以放置 = true;
			            for (let y = 起始Y; y < 起始Y + 尺寸; y++) {
			                for (let x = 起始X; x < 起始X + 尺寸; x++) {
			                    if (!位置是否可用(x, y, false)) {
			                        可以放置 = false;
			                        break;
			                    }
			                }
			                if (!可以放置) break;
			            }
			
			            if (可以放置) {
			                for (let y = 起始Y; y < 起始Y + 尺寸; y++) {
			                    for (let x = 起始X; x < 起始X + 尺寸; x++) {
			                        // 使用相同的初始效果和周期来创建符文圈
			                        放置物品到单元格(
			                            new 符文圈({
			                                效果类型: 初始效果类型,
			                                周期: 10,
			                                剩余周期: 初始剩余周期,
			                            }),
			                            x,
			                            y
			                        );
			                    }
			                }
			                放置成功 = true;
			                break;
			            }
			        }
			    }
			}
			
			function 生成法师图书馆() {
			    当前层数 = 10;
			
			    地牢 = Array(地牢大小)
			        .fill()
			        .map((_, y) =>
			            Array(地牢大小)
			                .fill()
			                .map((_, x) => new 单元格(x, y))
			        );
			    房间列表 = [];
			    上锁房间列表 = [];
			    所有怪物 = [];
			    怪物状态表 = new WeakMap();
			    门实例列表 = new Map();
			    房间地图 = Array(地牢大小)
			        .fill()
			        .map(() => Array(地牢大小).fill(-1));
			    已访问房间 = new Set();
			    所有计时器 = [];
			    当前天气效果 = [];
			
			    const 房间布局 = [
			        {
			            名称: "中央大厅",
			            id: 0,
			            x: 45,
			            y: 45,
			            w: 11,
			            h: 11,
			            门: [],
			        },
			        {
			            名称: "火焰之径",
			            id: 1,
			            x: 58,
			            y: 48,
			            w: 20,
			            h: 5,
			            门: [],
			        },
			        {
			            名称: "火焰宝库",
			            id: 2,
			            x: 80,
			            y: 48,
			            w: 7,
			            h: 7,
			            门: [],
			        },
			        {
			            名称: "冰霜书库",
			            id: 3,
			            x: 47,
			            y: 15,
			            w: 7,
			            h: 25,
			            门: [],
			        },
			        {
			            名称: "冰霜宝库",
			            id: 4,
			            x: 48,
			            y: 5,
			            w: 7,
			            h: 7,
			            门: [],
			        },
			        {
			            名称: "奥术回廊",
			            id: 5,
			            x: 22,
			            y: 48,
			            w: 21,
			            h: 5,
			            门: [],
			        },
			        {
			            名称: "奥术宝库",
			            id: 6,
			            x: 13,
			            y: 48,
			            w: 7,
			            h: 7,
			            门: [],
			        },
			        {
			            名称: "剧毒档案室",
			            id: 7,
			            x: 48,
			            y: 58,
			            w: 5,
			            h: 11,
			            门: [],
			        },
			        {
			            名称: "剧毒宝库",
			            id: 8,
			            x: 48,
			            y: 71,
			            w: 7,
			            h: 7,
			            门: [],
			        },
			        {
			            名称: "最终秘室",
			            id: 9,
			            x: 60,
			            y: 10,
			            w: 15,
			            h: 15,
			            门: [],
			        },
			    ];
			    房间列表 = 房间布局;
			    房间列表.forEach((房间配置) => 放置房间(房间配置));
			
			    const 获取房间 = (名称) =>
			        房间列表.find((r) => r.名称 === 名称);
			    let 已连接房间对 = new Set();
			    const 连接并生成走廊 = (房A, 房B) => {
			        const 房间A = 获取房间(房A);
			        const 房间B = 获取房间(房B);
			        if (!房间A || !房间B) return;
			        const 房间对ID = [房间A.id, 房间B.id].sort().join("-");
			        if (已连接房间对.has(房间对ID)) return;
			        const 路径 = 连接房间(房间A, 房间B);
			        if (路径) {
			            生成走廊(路径);
			            已连接房间对.add(房间对ID);
			        }
			    };
			
			    连接并生成走廊("中央大厅", "火焰之径");
			    连接并生成走廊("火焰之径", "火焰宝库");
			    连接并生成走廊("中央大厅", "冰霜书库");
			    连接并生成走廊("冰霜书库", "冰霜宝库");
			    连接并生成走廊("中央大厅", "奥术回廊");
			    连接并生成走廊("奥术回廊", "奥术宝库");
			    连接并生成走廊("中央大厅", "剧毒档案室");
			    连接并生成走廊("剧毒档案室", "剧毒宝库");
			    放置楼梯(
			        获取房间("中央大厅"),
			        楼梯图标.上楼,
			        单元格类型.楼梯上楼
			    );
			
			    for (let i = 0; i < 3; i++)
			        放置物品到房间(new 书架({}), 获取房间("中央大厅"));
			    for (let i = 0; i < 3; i++)
			        放置怪物到房间(
			            new 伪装怪物({ 伪装成: "书架" }),
			            获取房间("中央大厅")
			        );
			    for (let i = 0; i < 4; i++)
			        放置物品到房间(new 神秘商人({}), 获取房间("中央大厅"));
			
			    const 火焰房间 = 获取房间("火焰之径");
			    for (let i = 0; i < 15; i++)
			        放置物品到房间(new 火焰物品({ 倒计时: 99999 }), 火焰房间);
			    for (let i = 0; i < 3; i++)
			        放置怪物到房间(new 炸弹怪物({ 强化: true }), 火焰房间);
			    放置物品到房间(
			        new 魔法水晶({
			            水晶ID: "火焰",
			            颜色索引: 4,
			            管辖房间: ["火焰之径", "火焰宝库"],
			        }),
			        获取房间("火焰宝库")
			    );
			
			    const 冰霜房间 = 获取房间("冰霜书库");
			    let 冰霜连通 = false;
			    let 冰霜尝试 = 0;
			    do {
			        for (let y = 冰霜房间.y; y < 冰霜房间.y + 冰霜房间.h; y++) {
			            for (
			                let x = 冰霜房间.x;
			                x < 冰霜房间.x + 冰霜房间.w;
			                x++
			            ) {
			                地牢[y][x].背景类型 = 单元格类型.房间;
			            }
			        }
			        for (let y = 冰霜房间.y; y < 冰霜房间.y + 冰霜房间.h; y++) {
			            for (
			                let x = 冰霜房间.x;
			                x < 冰霜房间.x + 冰霜房间.w;
			                x++
			            ) {
			                if (prng() < 0.3)
			                    地牢[y][x].背景类型 = 单元格类型.墙壁;
			            }
			        }
			        冰霜连通 = 检查房间连通性(冰霜房间);
			        冰霜尝试++;
			    } while (!冰霜连通 && 冰霜尝试 < 1000);
			
			    for (let i = 0; i < 4; i++)
			        放置怪物到房间(new 冰冻怪物({ 强化: true }), 冰霜房间);
			    for (let i = 0; i < 3; i++)
			        放置怪物到房间(new 盗贼怪物({ 强化: true }), 冰霜房间);
			    放置物品到房间(
			        new 魔法水晶({
			            水晶ID: "冰霜",
			            颜色索引: 1,
			            管辖房间: ["冰霜书库", "冰霜宝库"],
			        }),
			        获取房间("冰霜宝库")
			    );
			
			    const 奥术房间 = 获取房间("奥术回廊");
			    放置怪物到房间(new 瞬移怪物({ 强化: true }), 奥术房间);
			    for (let i = 0; i < 3; i++)
			        放置怪物到房间(new 召唤师怪物({ 强化: true }), 奥术房间);
			    放置物品到房间(
			        new 魔法水晶({
			            水晶ID: "奥术",
			            颜色索引: 3,
			            管辖房间: ["奥术回廊", "奥术宝库"],
			        }),
			        获取房间("奥术宝库")
			    );
			
			    const 剧毒房间 = 获取房间("剧毒档案室");
			    for (let i = 0; i < 8; i++)
			        放置物品到房间(new 毒液物品({ 倒计时: 99999 }), 剧毒房间);
			    for (let i = 0; i < 5; i++)
			        放置怪物到房间(new 腐蚀怪物({ 强化: true }), 剧毒房间);
			    放置怪物到房间(new 剧毒云雾怪物({ 强化: true }), 剧毒房间);
			    放置物品到房间(
			        new 魔法水晶({
			            水晶ID: "剧毒",
			            颜色索引: 0,
			            管辖房间: ["剧毒档案室", "剧毒宝库"],
			        }),
			        获取房间("剧毒宝库")
			    );
			
			    const 最终房间 = 获取房间("最终秘室");
			    let boss房连通 = false;
			    let boss房尝试 = 0;
			    do {
			        for (let y = 最终房间.y; y < 最终房间.y + 最终房间.h; y++) {
			            for (
			                let x = 最终房间.x;
			                x < 最终房间.x + 最终房间.w;
			                x++
			            ) {
			                地牢[y][x].背景类型 = 单元格类型.房间;
			            }
			        }
			        const 墙体数量 = 4 + Math.round(prng() * 4);
			        for (let i = 0; i < 墙体数量; i++) {
			            const isHorizontal = prng() < 0.5;
			            const 墙体长度 =
			                2 + Math.floor(prng() * (最终房间.w - 3));
			            if (isHorizontal) {
			                const y =
			                    最终房间.y +
			                    Math.floor(prng() * 最终房间.h);
			                const xStart =
			                    最终房间.x +
			                    Math.floor(
			                        prng() * (最终房间.w - 墙体长度)
			                    );
			                for (let x = xStart; x < xStart + 墙体长度; x++) {
			                    if (地牢[y]?.[x])
			                        地牢[y][x].背景类型 = 单元格类型.墙壁;
			                }
			            } else {
			                const x =
			                    最终房间.x +
			                    Math.floor(prng() * 最终房间.w);
			                const yStart =
			                    最终房间.y +
			                    Math.floor(
			                        prng() * (最终房间.h - 墙体长度)
			                    );
			                for (let y = yStart; y < yStart + 墙体长度; y++) {
			                    if (地牢[y]?.[x])
			                        地牢[y][x].背景类型 = 单元格类型.墙壁;
			                }
			            }
			        }
			        boss房连通 = 检查房间连通性(最终房间);
			        boss房尝试++;
			    } while (!boss房连通 && boss房尝试 < 2000);
			
			    生成墙壁();
			    房间列表.forEach((房间) => 更新房间墙壁(房间));
			
			    生成符文圈群组(最终房间, 3);
			    放置怪物到房间(new 大魔法师({ 强化: true }), 最终房间);
			
			    const 起始房间 = 获取房间("中央大厅");
			    玩家初始位置.x = 起始房间.x + Math.floor(起始房间.w / 2);
			    玩家初始位置.y = 起始房间.y + Math.floor(起始房间.h / 2);
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			    已访问房间.add(起始房间.id);
			
			    更新视口();
			    更新界面状态();
			    绘制();
			}
			
			function 检查所有水晶状态() {
			    let 已摧毁数量 = 0;
			    for (const row of 地牢) {
			        for (const cell of row) {
			            if (
			                cell.关联物品 instanceof 魔法水晶 &&
			                cell.关联物品.自定义数据.get("已摧毁")
			            ) {
			                已摧毁数量++;
			            }
			        }
			    }
			    if (已摧毁数量 >= 4) {
			        生成最终传送门();
			    }
			}
			
			function 生成最终传送门() {
			    const 中心大厅 = 房间列表.find((r) => r.名称 === "中央大厅");
			    const 最终秘室 = 房间列表.find((r) => r.名称 === "最终秘室");
			    if (中心大厅 && 最终秘室) {
			        const 传送门 = new 折跃门({
			            目标房间: 最终秘室,
			            是否为隐藏物品: false,
			        });
			        放置物品到房间(
			            传送门,
			            中心大厅,
			            单元格类型.物品,
			            false,
			            true
			        );
			        显示通知(
			            "一股强大的魔法能量汇聚在中央大厅，开启了一道传送门！",
			            "成功"
			        );
			    }
			}
			function 显示自定义确认对话框(message, onConfirm) {
			    if (document.querySelector('.确认对话框遮罩')) return;
			
			    const 确认遮罩 = document.createElement("div");
			    确认遮罩.className = "确认对话框遮罩";
			    确认遮罩.innerHTML = `
			        <div class="确认对话框">
			            <h3>确认操作</h3>
			            <p>${message.replace(/\n/g, '<br>')}</p>
			            <div class="确认按钮容器">
			                <button class="确认按钮 确认按钮-确认">确认</button>
			                <button class="确认按钮 确认按钮-取消">取消</button>
			            </div>
			        </div>
			    `;
			    document.body.appendChild(确认遮罩);
			
			    const closeDialog = () => {
			        确认遮罩.style.opacity = '0';
			        setTimeout(() => 确认遮罩.remove(), 300);
			    };
			
			    确认遮罩.querySelector(".确认按钮-确认").onclick = () => {
			        closeDialog();
			        if (typeof onConfirm === 'function') {
			            onConfirm();
			        }
			    };
			    确认遮罩.querySelector(".确认按钮-取消").onclick = closeDialog;
			}
			            function 生成最终首领楼层() {
			    地牢 = Array(地牢大小).fill().map((_, y) => Array(地牢大小).fill().map((_, x) => new 单元格(x, y)));
			    房间列表 = [];
			    上锁房间列表 = [];
			    所有怪物 = [];
			    怪物状态表 = new WeakMap();
			    门实例列表 = new Map();
			    房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
			    已访问房间 = new Set();
			    所有计时器 = [];
			    当前天气效果 = [];
			
			    const 补给房配置 = [
			        { id: 0, x: 10, y: 48, w: 7, h: 7, 门: [] },
			        { id: 1, x: 20, y: 48, w: 7, h: 7, 门: [] },
			        { id: 2, x: 30, y: 48, w: 7, h: 7, 门: [] },
			    ];
			    补给房配置.forEach(config => {
			        房间列表.push(config);
			        放置房间(config);
			    });
			    房间列表.sort((a,b)=>a.id-b.id)
			
			    let 已连接房间对 = new Set();
			    const 连接并生成走廊 = (房间A, 房间B) => {
			        const 房间对ID = [房间A.id, 房间B.id].sort().join("-");
			        if (已连接房间对.has(房间对ID)) return;
			        const 路径 = 连接房间(房间A, 房间B);
			        if (路径) {
			            生成走廊(路径);
			            已连接房间对.add(房间对ID);
			        }
			    };
			
			    连接并生成走廊(房间列表[0], 房间列表[1]);
			    连接并生成走廊(房间列表[1], 房间列表[2]);
			
			    const 资源池 = [
			        new 嗜血战斧({ 强化: true }),
			        new 大师附魔卷轴({品质: 5}),
			        new 秘银锁甲({ 强化: true }),
			        new 重力锤({ 强化: true }),
			        new 陨石法杖({ 强化: true }),
			        new 充能魔杖({ 强化: true }),
			        new 守卫者盔甲({ 强化: true }),
			        
			        new 磨刀石({数据: {耐久: 10,原耐久:10}}),
			        new 能量药水({ 数量: 5, 强化: true }),
			        new 治疗药水({ 数量: 8, 强化: true }),
			        new 急救绷带({ 数量: 5, 强化: true }),
			        new 神龟药水({ 数量: 3, 强化: true }),
			        new 狂暴药水({ 数量: 3, 强化: true }),
			        new 时间卷轴({ 强化: true }),
			        new 潜行靴子({ 强化: true }),
			        new 金币({数量: 64}),
			    ];
			    资源池.sort(() => prng() - 0.5);
			    const 补给房列表 = [房间列表[0], 房间列表[1], 房间列表[2]];
			    const 放置物品数量 = 8; 
			    
			    for (let i = 0; i < 放置物品数量; i++) {
			        if (资源池.length === 0) break; 
			    
			        const 随机补给房 = 补给房列表[Math.floor(prng() * 补给房列表.length)];
			        const 待放置物品 = 资源池.pop();
			    
			        放置物品到房间(待放置物品, 随机补给房, 单元格类型.物品, false, true);
			    }
			    
			    const 小首领房坐标 = {x: 50, y: 80};
			    const 通往小首领的传送门 = new 传送门({ 数据: { 是否随机: false, 目标X: 小首领房坐标.x, 目标Y: 小首领房坐标.y-3 }});
			    放置物品到房间(通往小首领的传送门, 房间列表[Math.floor(prng()*3)]);
			
			    const 小首领房 = { id: 3, x: 45, y: 75, w: 11, h: 11, 门: [], 名称: "皇家卫队室" };
			    房间列表.push(小首领房);
			    放置房间(小首领房);
			    房间列表.sort((a,b)=>a.id-b.id)
			    const 小首领 = new 皇家守卫({ 强化: true, 基础生命值: 200, 独立:true, 掉落物:null,残血逃跑: false });
			    放置怪物到单元格(小首领, 50, 80);
			    小首领.状态 = 怪物状态.休眠;
			
			    小首领.受伤 = function(伤害, 来源 = null) {
			        const 原始方法 = 皇家守卫.prototype.受伤.bind(this);
			        原始方法(伤害, 来源);
			        if (this.当前生命值 <= 0) {
			            生成通往大首领的传送门(this.x, this.y);
			        }
			    };
			
			    const 大首领房坐标 = {x: 85, y: 50};
			    const 大首领房 = { id: 4, x: 80, y: 45, w: 17, h: 17, 门: [], 名称: "最终秘室" };
			    房间列表.push(大首领房);
			    放置房间(大首领房);
			    房间列表.sort((a,b)=>a.id-b.id)
			    const 大首领 = new 王座守护者({ });
			    放置怪物到单元格(大首领, 85, 50);
			    大首领.状态 = 怪物状态.休眠;
			    
			    
			
			    生成墙壁();
			    房间列表.forEach(房间 => 更新房间墙壁(房间));
			    
			    玩家初始位置.x = 房间列表[0].x + 3;
			    玩家初始位置.y = 房间列表[0].y + 3;
			    玩家.x = 玩家初始位置.x;
			    玩家.y = 玩家初始位置.y;
			    放置楼梯(
			        { x: 玩家初始位置.x, y: 玩家初始位置.y, w: 2, h: 2 },
			        楼梯图标.上楼,
			        单元格类型.楼梯上楼
			    );
			    已访问房间.add(0);
			
			    更新视口();
			    绘制();
			}
			
			function 生成通往大首领的传送门(x, y) {
			    const 传送门实例 = new 传送门({ 数据: { 是否随机: false, 目标X: 85, 目标Y: 47 }});
			    
			    let 放置成功 = false;
			    const 检查位置列表 = [
			        {dx: 0, dy: 0}, 
			        {dx: 0, dy: 1}, {dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: -1, dy: 0}, 
			        {dx: 1, dy: 1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: -1, dy: -1} 
			    ];
			
			    for(const 偏移 of 检查位置列表) {
			        const 目标X = x + 偏移.dx;
			        const 目标Y = y + 偏移.dy;
			        if (位置是否可用(目标X, 目标Y, false)) {
			            放置物品到单元格(传送门实例, 目标X, 目标Y);
			            显示通知("一个通往更深处的传送门出现了！", "成功");
			            放置成功 = true;
			            break;
			        }
			    }
			    
			    if (!放置成功) {
			         显示通知("无法生成传送门，周围没有合适的空间！", "错误");
			         玩家.x = 85
			         玩家.y = 47
			         
			    }
			}
			function 加载设置() {
			 const 已保存设置 = localStorage.getItem('ChineseDungeonSettings');
			 if (已保存设置) {
			     try {
			         const parsedSettings = JSON.parse(已保存设置);
			         for (const key in 游戏设置) {
			             if (parsedSettings.hasOwnProperty(key)) {
			                 if (typeof 游戏设置[key] === 'object' && !Array.isArray(游戏设置[key]) && 游戏设置[key] !== null) {
			                     Object.assign(游戏设置[key], parsedSettings[key]);
			                 } else {
			                     游戏设置[key] = parsedSettings[key];
			                 }
			             }
			         }
			     } catch(e) {
			         console.error("加载设置失败:", e);
			         localStorage.removeItem('ChineseDungeonSettings');
			     }
			 }
			 应用所有设置();
			}
			
			
			
			function 打开设置窗口() {
			 const 遮罩 = document.getElementById("设置窗口遮罩");
			 遮罩.style.display = "flex";
			 requestAnimationFrame(() => 遮罩.classList.add('显示'));
			
			 document.getElementById('方向键大小滑块').value = 游戏设置.方向键大小;
			 document.getElementById('方向键大小值').textContent = `${游戏设置.方向键大小}vmin`;
			 document.getElementById('显示方向键切换').classList.toggle('active', 游戏设置.显示方向键);
			 document.getElementById('手机模式切换').classList.toggle('active', 游戏设置.手机模式);
			 document.getElementById('移动速度滑块').value = 游戏设置.移动速度;
			 document.getElementById('移动速度值').textContent = `${游戏设置.移动速度}ms`;
			 document.getElementById('相机视野滑块').value = 相机显示边长;
			 document.getElementById('相机视野值').textContent = 相机显示边长;
			 document.getElementById('小地图大小滑块').value = 游戏设置.小地图大小;
			 document.getElementById('命令行风格切换').classList.toggle('active', 命令行模式开启);
			 document.getElementById('小地图大小值').textContent = 游戏设置.小地图大小 > 0 ? `${游戏设置.小地图大小}px` : '隐藏';
			 document.getElementById('动画模式切换').classList.toggle('active', 游戏设置.动画模式);
			 document.getElementById('文本模式切换').classList.toggle('active', 游戏设置.文本模式);
			 document.getElementById('禁用点击寻路切换').classList.toggle('active', 游戏设置.禁用点击移动);
			 document.getElementById('受伤击退切换').classList.toggle('active', 游戏设置.受伤时击退);
			 document.getElementById('emoji样式选择').value = 游戏设置.emoji风格;
			const 视野滑块 = document.getElementById('相机视野滑块');
			 const 受伤击退切换 = document.getElementById('受伤击退切换');
			 const 动画模式 = document.getElementById('动画模式切换');
			 
			 视野滑块.disabled = false;
			 受伤击退切换.disabled = false;
			 视野滑块.parentElement.style.opacity = '1';
			 受伤击退切换.parentElement.style.opacity = '1';
			
			 //if (是否是自定义关卡) {
				 if (自定义全局设置.作者设置_相机视野 !== undefined) {
					 视野滑块.disabled = true;
					 视野滑块.parentElement.style.opacity = '0.5';
				 }
				 if (自定义全局设置.作者设置_受伤击退 !== undefined) {
					 受伤击退切换.disabled = true;
					 受伤击退切换.parentElement.style.opacity = '0.5';
				 }
				 if (自定义全局设置.强制动画模式 !== undefined) {
					 动画模式.disabled = true;
					 动画模式.parentElement.style.opacity = '0.5';
				 }
			 //}
			 const 热键容器 = document.getElementById("热键绑定容器");
			 热键容器.innerHTML = '';
			
			 let capturingInput = null;
			 let originalKeybindings = { ...游戏设置.热键绑定 };
			
			 const captureHandler = (e) => {
			     e.preventDefault();
			     e.stopPropagation();
			     if (!capturingInput) return;
			
			     const newKey = e.key;
				 const displayKey = newKey === ' ' ? 'Space' : newKey;
			     const action = capturingInput.dataset.action;
			     const tempKeybindings = {};
			     热键容器.querySelectorAll('.热键输入').forEach(input => {
			         tempKeybindings[input.dataset.action] = input.value === 'Space' ? ' ' : input.value;
			     });
			
			     for (const [otherAction, assignedKey] of Object.entries(tempKeybindings)) {
			         if (otherAction !== action && assignedKey.toLowerCase() === newKey.toLowerCase()) {
			             显示通知(`按键 '${displayKey}' 已被 '${热键绑定描述[otherAction]}' 使用！`, "错误");
			             capturingInput.value = originalKeybindings[action] === ' ' ? 'Space' : originalKeybindings[action];
			             capturingInput.classList.remove('capturing');
			             capturingInput = null;
			             document.removeEventListener('keydown', captureHandler, true);
			             document.removeEventListener('mousedown', cancelCapture, true);
			             return;
			         }
			     }
			
			     capturingInput.value = displayKey;
			     capturingInput.classList.remove('capturing');
			     capturingInput = null;
			     document.removeEventListener('keydown', captureHandler, true);
			     document.removeEventListener('mousedown', cancelCapture, true);
			 };
			
			 const cancelCapture = (e) => {
			     if (capturingInput && !capturingInput.contains(e.target)) {
					 const originalKey = originalKeybindings[capturingInput.dataset.action];
			         capturingInput.value = originalKey === ' ' ? 'Space' : originalKey;
			         capturingInput.classList.remove('capturing');
			         capturingInput = null;
			         document.removeEventListener('keydown', captureHandler, true);
			         document.removeEventListener('mousedown', cancelCapture, true);
			     }
			 };
			
			 Object.entries(游戏设置.热键绑定).forEach(([action, key]) => {
			     const 条目 = document.createElement('div');
			     条目.className = '热键绑定条目';
			     const 标签 = document.createElement('span');
			     标签.textContent = 热键绑定描述[action] || action;
			     const 输入框 = document.createElement('input');
			     输入框.type = 'text';
			     输入框.className = '热键输入';
			     输入框.value = key === ' ' ? 'Space' : key;
			     输入框.dataset.action = action;
			     输入框.readOnly = true;
			
			     输入框.addEventListener('click', function(e) {
			         e.stopPropagation();
			         if (capturingInput && capturingInput !== this) {
						 const originalKey = originalKeybindings[capturingInput.dataset.action];
			             capturingInput.value = originalKey === ' ' ? 'Space' : originalKey;
			             capturingInput.classList.remove('capturing');
			         }
			         if (capturingInput === this) return;
			
			         this.value = '...';
			         this.classList.add('capturing');
			         capturingInput = this;
			         
			         document.removeEventListener('keydown', captureHandler, true);
			         document.removeEventListener('mousedown', cancelCapture, true);
			         document.addEventListener('keydown', captureHandler, true);
			         document.addEventListener('mousedown', cancelCapture, true);
			     });
			
			     条目.appendChild(标签);
			     条目.appendChild(输入框);
			     热键容器.appendChild(条目);
			 });
			
			 document.getElementById('方向键大小滑块').oninput = function() { document.getElementById('方向键大小值').textContent = `${this.value}vmin`; };
			 document.getElementById('移动速度滑块').oninput = function() { document.getElementById('移动速度值').textContent = `${this.value}ms`; };
			 document.getElementById('相机视野滑块').oninput = function() { document.getElementById('相机视野值').textContent = this.value; };
			 document.getElementById('小地图大小滑块').oninput = function() { document.getElementById('小地图大小值').textContent = this.value > 0 ? `${this.value}px` : '隐藏'; };
			 document.getElementById('显示方向键切换').onclick = function() { this.classList.toggle('active'); };
			 document.getElementById('手机模式切换').onclick = function() { this.classList.toggle('active'); };
			 document.getElementById('动画模式切换').onclick = function() { document.getElementById('受伤击退切换').classList.toggle('active',!this.classList.contains('active'));
			 this.classList.toggle('active'); }
			 document.getElementById('文本模式切换').onclick = function() { this.classList.toggle('active'); };
			 document.getElementById('受伤击退切换').onclick = function() { this.classList.toggle('active'); };
			 document.getElementById('禁用点击寻路切换').onclick = function() { this.classList.toggle('active'); };
			 document.getElementById('命令行风格切换').onclick = function() { this.classList.toggle('active'); };
			}
			async function 保存并应用设置() {
			 document.querySelectorAll('.热键输入').forEach(input => {
				 let valueToSave = input.value;
				 if (valueToSave.toLowerCase() === 'space') {
					 valueToSave = ' ';
				 }
			     游戏设置.热键绑定[input.dataset.action] = valueToSave;
			 });
			
			 游戏设置.方向键大小 = parseInt(document.getElementById('方向键大小滑块').value);
			 游戏设置.移动速度 = parseInt(document.getElementById('移动速度滑块').value);
			 游戏设置.相机视野大小 = parseInt(document.getElementById('相机视野滑块').value);
			 游戏设置.小地图大小 = parseInt(document.getElementById('小地图大小滑块').value);
			 
			 游戏设置.显示方向键 = document.getElementById('显示方向键切换').classList.contains('active');
			 游戏设置.禁用点击移动 = document.getElementById('禁用点击寻路切换').classList.contains('active');
			 游戏设置.手机模式 = document.getElementById('手机模式切换').classList.contains('active');
			 游戏设置.动画模式 = document.getElementById('动画模式切换').classList.contains('active');
			 游戏设置.文本模式 = document.getElementById('文本模式切换').classList.contains('active');
			 游戏设置.受伤时击退 = document.getElementById('受伤击退切换').classList.contains('active');
			游戏设置.命令行模式 = document.getElementById('命令行风格切换').classList.contains('active');
    //const 命令行模式改变 = 新命令行模式状态 !== 命令行模式开启;
			 const newemoji风格 = document.getElementById('emoji样式选择').value;
             const styleChanged = newemoji风格 !== 游戏设置.emoji风格;
             游戏设置.emoji风格 = newemoji风格;

			 localStorage.setItem('ChineseDungeonSettings', JSON.stringify(游戏设置));
			 
             if (styleChanged && 游戏设置.emoji风格 !== 'local') {
                const isAvailable = await checkCdnAvailability();
                if (!isAvailable) {
                    显示通知("Emoji CDN 不可用，已自动切换回本地字体。", "警告");
                    游戏设置.emoji风格 = 'local';
                    document.getElementById('emoji样式选择').value = 'local';
                } else {
                    emojiImageCache.clear();
                }
             }
             

			 应用所有设置();
			
			 显示通知("设置已保存！", "成功");
			 关闭设置窗口();
			}
			function 刷新UI中所有物品图标() {
				const 物品元素列表 = document.querySelectorAll('#背包物品栏 .物品条目, .装备栏 .物品条目');
				
				物品元素列表.forEach(元素 => {
					const 物品实例 = 元素.__物品实例;
					if (!物品实例) return;

					const 图标容器 = 元素.querySelector('.物品图标');
					if (!图标容器) return;
					
					const key = 物品实例.显示图标 || 物品实例.名称;
					图标容器.innerHTML = getIconHTML(key);

					if (!游戏设置.文本模式 && 游戏设置.emoji风格 !== 'local' && 游戏设置.emojiCDN是否可用) {
						const img = 图标容器.querySelector('img');
						if (img) {
							img.style.filter = `drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5)) drop-shadow(0 0 8px ${物品实例.颜色表[物品实例.颜色索引]})`;
						}
					} else {
						图标容器.style.color = 物品实例.颜色表[物品实例.颜色索引];
						图标容器.style.textShadow = `0 0 8px ${物品实例.颜色表[物品实例.颜色索引]}`;
					}
				});
			}
			function 应用所有设置() {
			 Object.keys(功能键映射).forEach(key => delete 功能键映射[key]);
			 Object.entries(游戏设置.热键绑定).forEach(([action, key]) => {
			     const actionMap = {
			         '装备槽1': () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 1),
			         '装备槽2': () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 2),
			         '装备槽3': () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 3),
			         '装备槽4': () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 4),
			         '装备槽5': () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 5),
			         '装备槽6': () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 6),
			         '装备槽7': () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 7),
			         '切换HUD': () => 处理HUD切换按钮点击(),
			         '背包': () => { 界面可见性.背包 = !界面可见性.背包; 切换背包显示(); },
			         '日志': 切换日志显示,
			         '互动': 尝试互动,
			         '导出存档': 导出存档,
			         '传送菜单': 打开传送菜单,
			         '装备页上一页': () => 切换装备页(-1),
			         '装备页下一页': () => 切换装备页(1),
			         '自杀': 玩家死亡,
			         '重置关卡': 重置创意关卡,
			         '配方书': 打开配方书,
			     };
			     if (actionMap[action]) {
			         功能键映射[key.toLowerCase()] = actionMap[action];
			     }
			 });
			document.body.classList.toggle('手机模式启用', 游戏设置.手机模式);
			document.body.classList.toggle('方向键隐藏', !游戏设置.显示方向键);
			 document.querySelectorAll('.directional-btn').forEach(btn => {
			 btn.style.width = `${游戏设置.方向键大小}vmin`;
			 btn.style.height = `${游戏设置.方向键大小}vmin`;
			 btn.style.borderRadius = `${游戏设置.方向键大小 / 4}vmin`;
			 btn.style.fontSize = `${游戏设置.方向键大小 / 3}vmin`;
			});
			 
			 const 小地图容器 = document.getElementById('小地图容器');
			 const 小地图 = document.getElementById('小地图');
			 if (游戏设置.小地图大小 > 0) {
			     小地图容器.style.display = 'block';
			     小地图.style.width = `${游戏设置.小地图大小}px`;
			     小地图.style.height = `${游戏设置.小地图大小}px`;
			 } else {
			     小地图容器.style.display = 'none';
			 }
			
			 切换动画 = 游戏设置.动画模式;
			 命令行模式开启=游戏设置.命令行模式
			
			 //if (中文模式 !== 游戏设置.文本模式) {
			 if (游戏设置.命令行模式) {
			 应用命令行风格()
			} else {
			document.body.classList.toggle('命令行风格', 命令行模式开启);
			更新界面元素以适应风格()
			     切换文本模式();
			     }
			 //} else {
			 const 按钮图标映射 = {
			        默认: 图标映射.HUD智能,
			        常显: 图标映射.HUD常显,
			        常隐: 图标映射.HUD常隐,
			    };
			    document.getElementById("hudToggle").textContent =
			        按钮图标映射[hud模式];
                刷新UI中所有物品图标();
                更新编辑器快速访问栏();
				
				document.querySelector("#背包按钮").innerHTML = getIconHTML(图标映射.背包按钮);
				document.querySelector("#互动按钮").innerHTML = getIconHTML(图标映射.互动按钮);
             //}
			 
			 相机显示边长 = 游戏设置.相机视野大小;
			 移动间隔 = 游戏设置.移动速度;
			
			 初始化canvas();
			 更新视口();
			 绘制小地图();
			 绘制();
			}
			function 关闭设置窗口() {
			 document.querySelectorAll('.热键输入.capturing').forEach(input => {
			     input.value = 游戏设置.热键绑定[input.dataset.action];
			     input.classList.remove('capturing');
			 });
			 const 遮罩 = document.getElementById("设置窗口遮罩");
			 遮罩.classList.remove('显示');
			 setTimeout(() => {
			     遮罩.style.display = "none";
			 }, 300);
			 if (游戏状态 === "游戏中" || 游戏状态 === "编辑器游玩" || 游戏状态 === "图鉴" || 游戏状态 === "地图编辑器") {
        玩家属性.允许移动--;
        玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
    }
			}
			
			
			const Q字形图案 = [
			 " XXXX ",
			 "X    X",
			 "X    X",
			 "X    X",
			 "X  XX ",
			 " XXX X"
			];
			
			function 检查Q字形彩蛋(丢弃X, 丢弃Y) {
			 if (彩蛋1触发) return;
			
			 for (let 模板行 = 0; 模板行 < Q字形图案.length; 模板行++) {
			     for (let 模板列 = 0; 模板列 < Q字形图案[模板行].length; 模板列++) {
			         if (Q字形图案[模板行][模板列] == 'X') {
			             const 左上角X = 丢弃X - 模板列;
			             const 左上角Y = 丢弃Y - 模板行;
			
			             let 完全匹配 = true;
			             const 匹配的格子 = [];
			
			             for (let r = 0; r < 6; r++) {
			                 for (let c = 0; c < 6; c++) {
			                     const 世界X = 左上角X + c;
			                     const 世界Y = 左上角Y + r;
			
			                     if (世界X < 0 || 世界X >= 地牢大小 || 世界Y < 0 || 世界Y >= 地牢大小) {
			                         完全匹配 = false;
			                         break;
			                     }
			
			                     const 单元格 = 地牢[世界Y]?.[世界X];
			                     const 模板字符 = Q字形图案[r][c];
			                     const 单元格有物品 = 单元格 && 单元格.关联物品 !== null && 单元格.关联物品.能否拾起 !== false;
			
			                     if ((模板字符 === 'X' && !单元格有物品) || (模板字符 === ' ' && 单元格有物品)) {
			                         完全匹配 = false;
			                         break;
			                     }
			                     if(单元格有物品) {
			                         匹配的格子.push({x: 世界X, y: 世界Y});
			                     }
			                 }
			                 if (!完全匹配) break;
			             }
			
			             if (完全匹配) {
			                 触发Q字形彩蛋(匹配的格子);
			                 return; 
			             }
			         }
			     }
			 }
			}
			
			function 触发Q字形彩蛋(格子列表) {
			 彩蛋1触发 = true;
			
			 setTimeout(() => {
			     
			     const 奖励物品 = new 时空罗盘({});
			     if (尝试收集物品(奖励物品, true)) {
			         计划显示格子特效(格子列表, "FFD700", 500);
			         显示通知("难道这是...'Q' for 'Quark'！？", "成功");
			     }
			     
			 }, 1000);
			}
			function 处理燃烧木质卷轴() {
			    const 待烧毁列表 = [];
			    [...玩家背包.values(), ...玩家装备.values()].forEach(物品 => {
			        if (物品 instanceof 卷轴类 && 物品.材质 === 材料.木质) {
			            待烧毁列表.push(物品.唯一标识);
			        }
			    });
			
			    if (待烧毁列表.length > 0) {
			        待烧毁列表.forEach(标识 => {
			            const 物品实例 = 玩家背包.get(标识);
			            if (物品实例) {
			                显示通知(`${物品实例.获取名称()} 被火焰烧毁了！`, "错误");
			                处理销毁物品(标识, true);
			            }
			        });
			        更新背包显示();
			        更新装备显示();
			        return true;
			    }
			    return false;
			}
			function 创建并播放物品移动动画(起始元素, 获取目标元素的函数) {
			if (typeof gsap === 'undefined'||命令行模式开启) return;
			    if (!起始元素 || typeof 获取目标元素的函数 !== 'function') return;
			
			    const 图标元素 = 起始元素.querySelector('.物品图标');
			    if (!图标元素) return;
			
			    const 起始位置 = 图标元素.getBoundingClientRect();
			
			    const 飞行图标 = 图标元素.cloneNode(true);
			    飞行图标.style.cssText = `
			        position: fixed;
			        left: ${起始位置.left}px;
			        top: ${起始位置.top}px;
			        width: ${起始位置.width}px;
			        height: ${起始位置.height}px;
			        color: ${图标元素.style.color};
			        margin: 0;
			        z-index: 10010;
			        pointer-events: none;
			        opacity: 1;
			        transform-origin: center center;
			    `;
			    document.body.appendChild(飞行图标);
			
			    const 目标元素 = 获取目标元素的函数();
			    if (!目标元素) {
			        飞行图标.remove();
			        return;
			    }
			    
			    const 目标位置 = 目标元素.getBoundingClientRect();
			    
			    let 最终缩放比例 = 0.65;
			    const 目标物品元素 = 目标元素.querySelector('.物品条目');
			    if (目标物品元素) {
			         const 样式 = window.getComputedStyle(目标物品元素);
			         const 矩阵 = new DOMMatrixReadOnly(样式.transform);
			         最终缩放比例 = 矩阵.a;
			    }
			
			    const 目标中心X = 目标位置.left + 目标位置.width / 2;
			    const 目标中心Y = 目标位置.top + 目标位置.height / 2;
			
			    const 最终X = 目标中心X - (起始位置.width / 2) + 3;
			    const 最终Y = 目标中心Y - (起始位置.height / 2) + 7;
			
			    gsap.to(飞行图标, {
			        left: 最终X,
			        top: 最终Y,
			        scale: 最终缩放比例,
			        duration: 0.25,
			        ease: "power2.inOut",
			        onComplete: () => {
			gsap.to(飞行图标, {
			    opacity: 0,
			    duration: 0.05,
			    onComplete: () => {
			        飞行图标.remove();
			    }
			});
			        }
			    });
			}
			function 初始化随机数生成器(种子) {
			    let 当前种子 = 哈希字符串(种子.toString());
			    // 什么？你说不安全？
			    prng = () => {
			        当前种子 = (当前种子 * 9301 + 49297) % 233280;
			        return 当前种子 / 233280;
			    };
			}
			function 应用职业效果(职业) {
			    if (!职业) return;
			
			    const 职业数据 = {
			        '战士': {
			            攻击加成: 2,
			            初始物品: new 钢制长剑({ 不可破坏: true }),
			        },
			        '法师': {
			            初始能量加成: 20,
			            初始物品: new 橡木法杖({ 不可破坏: true }),
			        },
			        '忍者': {
			            移动步数: 2,
			            初始物品: new 剧毒匕首({ 不可破坏: true }),
			        },
			        '游侠': {
			            初始物品: new 穿云箭({ 不可破坏: true }),
			            额外效果: () => 初始玩家属性.透视 = true
			        },
			        '骑士': {
			            防御加成: 2,
			            初始物品: new 钢制板甲({ 不可破坏: true }),
			        },
			        '死灵': {
			            初始物品: new 死灵法杖({ 不可破坏: true }),
			        },
			    };
			
			    const 选定职业 = 职业数据[职业];
			    if (选定职业) {
			        if (选定职业.攻击加成) 初始玩家属性.攻击加成 = (初始玩家属性.攻击加成 || 0) + 选定职业.攻击加成;
			        if (选定职业.防御加成) 初始玩家属性.防御加成 = (初始玩家属性.防御加成 || 0) + 选定职业.防御加成;
			        if (选定职业.移动步数) 初始玩家属性.移动步数 = (初始玩家属性.移动步数 || 1) + 选定职业.移动步数 - 1;
			        if (选定职业.初始能量加成) 初始玩家属性.初始能量加成 = (初始玩家属性.初始能量加成 || 0) + 选定职业.初始能量加成;
			
			        if (选定职业.初始物品) {
			            尝试收集物品(选定职业.初始物品, true);
			        }
			        if (typeof 选定职业.额外效果 === 'function') {
			            选定职业.额外效果();
			        }
			
			        玩家属性 = { ...初始玩家属性 };
			    }
			}

			function 显示职业选择界面() {
			    const 遮罩 = document.getElementById("职业选择遮罩");
			    const 窗口 = document.getElementById("职业选择窗口");
			    const 选项容器 = document.getElementById("职业选项容器");
			    const 种子输入 = document.getElementById("游戏种子输入");
			    const 开始按钮 = document.getElementById("开始游戏自定义按钮");
			    const 返回按钮 = document.getElementById("返回模式选择按钮");
			    const 每日挑战按钮 = document.getElementById("每日挑战按钮");
			
			    隐藏游戏模式选择();
			
			    种子输入.value = '';
			    let 已选职业 = '战士';
			
			    const 职业列表 = {
			        '战士': { 图标: 图标映射.战士, 描述: '攻守兼备，勇往直前' },
			        '法师': { 图标: 图标映射.法师, 描述: '掌控元素，智慧超群' },
			        '忍者': { 图标: 图标映射.忍者, 描述: '身法迅捷，一击致命' },
			        '游侠': { 图标: 图标映射.游侠, 描述: '百步穿杨，洞察先机' },
			        '骑士': { 图标: 图标映射.骑士, 描述: '信仰坚定，守护队友' },
			        '死灵': { 图标: 图标映射.死灵, 描述: '驱使亡灵，玩弄生死' }
			    };
			
			    选项容器.innerHTML = '';
			    Object.entries(职业列表).forEach(([名称, 数据]) => {
			        const 按钮 = document.createElement('button');
			        按钮.className = '职业按钮';
			        按钮.dataset.职业 = 名称;
			        按钮.innerHTML = `<span class="职业图标">${数据.图标}</span><span class="职业名称">${名称}</span><small style="display: block; color: #888; margin-top: 5px;">${数据.描述}</small>`;
			        选项容器.appendChild(按钮);
			    });
			
			    const 职业按钮们 = 选项容器.querySelectorAll('.职业按钮');
			    
			    function 更新选中状态() {
			        const 容器中心 = 选项容器.offsetWidth / 2;
			        let 最近的按钮 = null;
			        let 最小距离 = Infinity;
			
			        职业按钮们.forEach(按钮 => {
			            const 按钮中心 = 按钮.offsetLeft - 选项容器.scrollLeft + 按钮.offsetWidth / 2;
			            const 距离 = Math.abs(容器中心 - 按钮中心);
			
			            if (距离 < 最小距离) {
			                最小距离 = 距离;
			                最近的按钮 = 按钮;
			            }
			        });
			
			        if (最近的按钮) {
			            职业按钮们.forEach(btn => btn.classList.remove('active'));
			            最近的按钮.classList.add('active');
			            已选职业 = 最近的按钮.dataset.职业;
			        }
			    }
			    选项容器.addEventListener('scrollend', 更新选中状态);
				let scrollTimeout = null;

选项容器.addEventListener('scroll', () => {
    选项容器.style.pointerEvents = 'none';
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
        选项容器.style.pointerEvents = 'auto';
    }, 150);
}, { passive: true });

			
			    职业按钮们.forEach(按钮 => {
			        按钮.onclick = () => {
			            const 容器宽度 = 选项容器.offsetWidth;
			            const 按钮宽度 = 按钮.offsetWidth;
			            const 目标滚动位置 = 按钮.offsetLeft - (容器宽度 / 2) + (按钮宽度 / 2);

							选项容器.scrollTo({
			                left: 目标滚动位置,
							duration: 2,
			                behavior: 'smooth',
			            	});
							setTimeout(()=>{更新选中状态();},150)
						
						
			        };
			    });
			
			    每日挑战按钮.onclick = () => {
			        const 今天 = new Date();
			        const 年 = 今天.getFullYear();
			        const 月 = (今天.getMonth() + 1).toString().padStart(2, '0');
			        const 日 = 今天.getDate().toString().padStart(2, '0');
			        const 日期种子 = `${年}-${月}-${日}`;
			        种子输入.value = 日期种子;
			        if (typeof gsap !== 'undefined') {
			             gsap.fromTo(种子输入, { scale: 1.1, boxShadow: "0 0 15px rgba(76, 175, 80, 0.6)" }, { scale: 1, boxShadow: "0 0 0 rgba(76, 175, 80, 0)", duration: 0.5, ease: "elastic.out(1, 0.5)" });
			        }
			    };
			
			    开始按钮.onclick = () => {
			        const 种子 = 种子输入.value.trim();
			        隐藏职业选择界面(() => 启动游戏(null, false, 种子, 已选职业));
			    };
			
			    返回按钮.onclick = () => {
			        隐藏职业选择界面(显示游戏模式选择);
			    };
			
			    遮罩.style.display = 'flex';
			
			    if (typeof gsap !== 'undefined') {
			        gsap.fromTo(遮罩, {autoAlpha:0},{ autoAlpha: 1, duration: 0.3, ease: 'power2.out' });
			        
			        
			        gsap.fromTo(窗口, 
			            { 
			                y: '50vh', 
			                autoAlpha: 0, 
			                scale: 0.95,
			                duration: 0.1,
			            }, 
			            { 
			                y: '0vh', 
			                autoAlpha: 1, 
			                scale: 1,
			                duration: 0.5, 
			                ease: 'power2.out',
			                onStart: () => {
			                    遮罩.style.pointerEvents = 'auto';
			                    窗口.style.visibility = 'visible';
			                    窗口.style.transform = '';
			                    更新选中状态();
			                },
			                onComplete: () => {
			                    窗口.style.transform = '';
			                    
			                },
			            }
			        );
			    } else {
			        窗口.style.top = '50%';
			        窗口.style.left = '50%';
			        窗口.style.transform = 'translate(-50%, -50%) scale(1)';
			        窗口.style.opacity = '1';
			        窗口.style.visibility = 'visible';
			        遮罩.style.opacity = '1';
			        遮罩.style.pointerEvents = 'auto';
			        更新选中状态();
			    }
			}
			
			function 隐藏职业选择界面(回调函数) {
			    const 遮罩 = document.getElementById("职业选择遮罩");
			    const 窗口 = document.getElementById("职业选择窗口");
			    
			    遮罩.style.pointerEvents = 'none';
			
			    if (typeof gsap !== 'undefined') {
			        gsap.to(窗口, { 
			            y: '15vh', 
			            scale: 0.95, 
			            autoAlpha: 0,
			            duration: 0.3, 
			            ease: 'power2.in' 
			        });
			        gsap.to(遮罩, { 
			            autoAlpha: 0, 
			            duration: 0.2, 
			            ease: 'power2.in',
			            onComplete: () => {
			                遮罩.style.display = 'none';
			                if (typeof 回调函数 === 'function') {
			                    回调函数();
			                }
			            }
			        });
			    } else {
			        窗口.style.transform = 'translate(-50%, -50%) scale(0.95)';
			        窗口.style.opacity = '0';
			        窗口.style.visibility = 'hidden';
			        遮罩.style.opacity = '0';
			        setTimeout(() => {
			            遮罩.style.display = 'none';
			            if (typeof 回调函数 === 'function') {
			                回调函数();
			            }
			        }, 300);
			    }
			}

function 填充筛选器物品列表() {
    const a = 获取所有可用的定义();
    const allItems = a.items;
    const selectElement = document.getElementById('sifter-item-select');
    selectElement.innerHTML = ''; 

    const uniqueItems = new Map();
    allItems.forEach(itemDef => {
        try {
            const instance = new itemDef.类({});
            
            if (instance.是否正常物品 && !uniqueItems.has(instance.名称) && itemDef.最小层 !== undefined) {
                
                uniqueItems.set(instance.名称, itemDef);
            }
        } catch (e) {}
    });

    
    if (!uniqueItems.has('钥匙')) {
        
        uniqueItems.set('钥匙', { 最小层: 0 });
    }
    
    
    const sortedItems = Array.from(uniqueItems.entries()).sort((a, b) => a[0].localeCompare(b[0], 'zh-Hans-CN'));

    sortedItems.forEach(([name, itemDef]) => {
        const option = document.createElement('option');
        const minLevel = itemDef.最小层; 

        option.value = name;
        
        option.textContent = `${name} (层数 ≥ ${minLevel})`;
        selectElement.appendChild(option);
    });
}


function 打开种子筛选器窗口() {
    const 遮罩 = document.getElementById("种子筛选器遮罩");
    const 窗口 = document.getElementById("种子筛选器窗口");
    
    填充筛选器物品列表();

    document.getElementById('开始筛选按钮').style.display = 'block';
    document.getElementById('取消筛选按钮').style.display = 'none';
    document.getElementById('sifter-status').textContent = '准备就绪。';
    document.getElementById('sifter-level-input').disabled = false;
    document.getElementById('sifter-room-id-input').disabled = false;
    document.getElementById('sifter-item-select').disabled = false;

    遮罩.style.display = 'block';
    
}

function 关闭种子筛选器窗口() {
    isSifting = false; 
    const 遮罩 = document.getElementById("种子筛选器遮罩");
    const 窗口 = document.getElementById("种子筛选器窗口");

    if (!遮罩 || !窗口) return; 


        
        
        窗口.classList.add("关闭中");

        
        setTimeout(() => {
            遮罩.style.display = 'none';
            窗口.classList.remove("关闭中"); 
        }, 300); 
    
}

async function 开始筛选种子() {
    if (isSifting) return;

    const levelInput = document.getElementById('sifter-level-input');
    const roomInput = document.getElementById('sifter-room-id-input');
    const itemSelect = document.getElementById('sifter-item-select');
    const statusDisplay = document.getElementById('sifter-status');
    const startButton = document.getElementById('开始筛选按钮');
    const cancelButton = document.getElementById('取消筛选按钮');

    const criteria = {
        level: parseInt(levelInput.value),
        roomId: parseInt(roomInput.value),
        itemName: itemSelect.value,
    };

    if (isNaN(criteria.level) || isNaN(criteria.roomId) || !criteria.itemName) {
        statusDisplay.textContent = '错误：请输入有效的筛选条件。';
        return;
    }

    isSifting = true;
    let seedsChecked = 0;
    const maxChecks = 50000; 

    levelInput.disabled = true;
    roomInput.disabled = true;
    itemSelect.disabled = true;
    startButton.style.display = 'none';
    cancelButton.style.display = 'block';

    async function siftLoop() {
        if (!isSifting) {
            statusDisplay.textContent = '筛选已取消。';
            levelInput.disabled = false;
            roomInput.disabled = false;
            itemSelect.disabled = false;
            startButton.style.display = 'block';
            cancelButton.style.display = 'none';
            return;
        }

        if (seedsChecked >= maxChecks) {
            isSifting = false;
            statusDisplay.textContent = `已达到最大筛选次数 (${maxChecks})，未找到。`;
            levelInput.disabled = false;
            roomInput.disabled = false;
            itemSelect.disabled = false;
            startButton.style.display = 'block';
            cancelButton.style.display = 'none';
            return;
        }

        seedsChecked++;
        const currentSeed = Date.now().toString() + seedsChecked;
        
    statusDisplay.textContent = `筛选中... 已检查: ${seedsChecked} (种子: ${currentSeed})`;
        const found = await new Promise(resolve => {
            setTimeout(() => {
                resolve(虚拟生成并检查(currentSeed, criteria));
            }, 0);
        });

        if (found) {
            isSifting = false;
            document.getElementById('游戏种子输入').value = currentSeed;
            statusDisplay.innerHTML = `<b>找到种子: <span style="color:#4caf50">${currentSeed}</span></b><br>已自动填入种子输入框。`;
            levelInput.disabled = false;
            roomInput.disabled = false;
            itemSelect.disabled = false;
            startButton.style.display = 'block';
            cancelButton.style.display = 'none';
            setTimeout(关闭种子筛选器窗口, 2000);
        } else {
            siftLoop(); 
        }
    }
    siftLoop();
}

function 虚拟生成并检查(seed, criteria) {

    try {
        当前层数 = criteria.level
        初始化随机数生成器(seed);
        for (let i=0;i<当前层数;i++) prng()
        
        生成地牢();

        
        const targetRoom = 房间列表[criteria.roomId];
        if (!targetRoom) {
            return false; 
        }

        for (let y = targetRoom.y; y < targetRoom.y + targetRoom.h; y++) {
            for (let x = targetRoom.x; x < targetRoom.x + targetRoom.w; x++) {
                const cell = 地牢[y]?.[x];
                if (cell && cell.关联物品 instanceof window[criteria.itemName]) {
                    return true; 
                }
            }
        }
        
        return false; 

    } catch (e) {
        console.error(`Seed ${seed} generation failed:`, e);
        return false;
    } finally {
        
        地牢 = [];
        房间列表 = [];
        上锁房间列表 = [];
        所有怪物 = [];
        门实例列表 = new Map();
        房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
        已访问房间 = new Set();
        所有计时器 = [];
        当前天气效果 = [];
        
    }
}
canvas.addEventListener('mousedown', (事件) => {
    if (事件.button === 1) {
		if (玩家属性.允许移动 > 0 || 死亡界面已显示 || (游戏状态 !== "游戏中" && 游戏状态 !== "编辑器游玩" && 游戏状态 !== "图鉴")) {
        return;
    }
        事件.preventDefault();
        尝试互动();
    }
});
canvas.addEventListener('wheel', (事件) => {
    
    if (玩家属性.允许移动 > 0 || 死亡界面已显示 || (游戏状态 !== "游戏中" && 游戏状态 !== "编辑器游玩" && 游戏状态 !== "图鉴" && 游戏状态 !== "地图编辑器")) {
        return;
    }
    if (游戏状态 === '地图编辑器') {
        事件.preventDefault(); // 阻止页面滚动

        // 仅当笔刷工具激活时才调整大小
        if (编辑器状态.笔刷模式 === '笔刷') {
            const 尺寸滑块 = document.getElementById('笔刷尺寸滑块');
            if (尺寸滑块) {
                // Math.sign(事件.deltaY) 会根据滚轮方向返回 -1 (上) 或 1 (下)
                let newValue = parseInt(尺寸滑块.value) - Math.sign(事件.deltaY);
                
                // 确保新值在滑块的允许范围内
                const min = parseInt(尺寸滑块.min);
                const max = parseInt(尺寸滑块.max);
                newValue = Math.max(min, Math.min(newValue, max));
                
                // 更新滑块值并触发input事件以同步UI和状态
                尺寸滑块.value = newValue;
                尺寸滑块.dispatchEvent(new Event('input'));
            }
        }
        return; // 结束函数，不执行下面的玩家移动逻辑
    }
    事件.preventDefault(); 

    const 画布矩形 = canvas.getBoundingClientRect();
    const 鼠标横坐标 = 事件.clientX - 画布矩形.left;
    const 鼠标纵坐标 = 事件.clientY - 画布矩形.top;
    
    const 目标格子横坐标 = Math.floor(当前相机X + 鼠标横坐标 / 单元格大小);
    const 目标格子纵坐标 = Math.floor(当前相机Y + 鼠标纵坐标 / 单元格大小);
    
    if (目标格子横坐标 === 玩家.x && 目标格子纵坐标 === 玩家.y) {
        return;
    }
    const 目标向量横 = 目标格子横坐标 - 玩家.x;
    const 目标向量纵 = 目标格子纵坐标 - 玩家.y;

    let 移动向量横 = 0;
    let 移动向量纵 = 0;
    if (Math.abs(目标向量纵) > 0) { 
        移动向量纵 = Math.sign(目标向量纵);
        
        if (游戏状态 !== "地图编辑器" && !检查移动可行性(玩家.x, 玩家.y, 玩家.x, 玩家.y + 移动向量纵)) {
             
             if (Math.abs(目标向量横) > 0) {
                 移动向量横 = Math.sign(目标向量横);
                 移动向量纵 = 0; 
             } else {
                 移动向量纵 = 0; 
             }
        }
    } else if (Math.abs(目标向量横) > 0) { 
        移动向量横 = Math.sign(目标向量横);
    }
    
    
    if (事件.deltaY < 0) { 
        移动向量横 = -移动向量横;
        移动向量纵 = -移动向量纵;
    }

    if (移动向量横 !== 0 || 移动向量纵 !== 0) {
        移动玩家(移动向量横, 移动向量纵);
    }
}, { passive: false }); // 设置passive为false以允许preventDefault生效


    const sifterButton = document.getElementById('种子筛选器按钮');
    if (sifterButton) {
        sifterButton.addEventListener('click', 打开种子筛选器窗口);
    }

    const closeSifterButton = document.getElementById('关闭筛选器按钮');
    if (closeSifterButton) {
        closeSifterButton.addEventListener('click', 关闭种子筛选器窗口);
    }

    const startSiftingButton = document.getElementById('开始筛选按钮');
    if (startSiftingButton) {
        startSiftingButton.addEventListener('click', 开始筛选种子);
    }

    const cancelSiftingButton = document.getElementById('取消筛选按钮');
    if (cancelSiftingButton) {
        cancelSiftingButton.addEventListener('click', () => { isSifting = false; });
    }


function 生成洞穴地牢() {
    //console.log("开始生成洞穴地牢...");
    地牢大小 = 100 + 当前层数 * 2;
    地牢 = Array(地牢大小).fill().map((_, y) => Array(地牢大小).fill().map((_, x) => new 单元格(x, y)));
    房间列表 = [];
    上锁房间列表 = [];
    所有怪物 = [];
    门实例列表 = new Map();
    房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
    已访问房间 = new Set();
    所有计时器 = [];
    当前天气效果 = [];

    初始化洞穴地图(0.45+0.05*prng());
    for (let i = 0; i < 5; i++) {
        执行元细胞自动机迭代();
    }

    const { 主洞穴, 所有洞穴 } = 处理洞穴连通性();
    if (!主洞穴) {
        console.error("未能生成有效的洞穴区域，将退回默认生成器。");
        地牢生成方式 = 'default';
        return 生成地牢();
    }

    //console.log("生成评分图并放置出入口...");
    let 评分图 = 生成评分图('entry');
    const { 入口, 出口 } = 放置地牢出入口(评分图, 主洞穴);
    玩家初始位置.x = 入口.x;
		    玩家初始位置.y = 入口.y;
		
		    if (当前层数 > 0) {
		        const 上楼梯位置 = 寻找可放置位置(玩家初始位置.x, 玩家初始位置.y);
		        if (上楼梯位置) {
		            放置物品到单元格(创建楼梯实例('上楼'), 上楼梯位置.x, 上楼梯位置.y, 单元格类型.楼梯上楼);
		        } else {
		            放置物品到单元格(创建楼梯实例('上楼'), 玩家初始位置.x, 玩家初始位置.y, 单元格类型.楼梯上楼);
		        }
		    }
    放置物品到单元格(创建楼梯实例('下楼'), 出口.x, 出口.y, 单元格类型.楼梯下楼);

    //console.log("放置物品...");
    for (let i = 0; i < 10 + 当前层数 * 2; i++) {
        const x = 主洞穴[Math.floor(prng() * 主洞穴.length)].x;
        const y = 主洞穴[Math.floor(prng() * 主洞穴.length)].y;
        if (位置是否可用(x, y, false)) {
            放置物品到单元格(new 金币({ 数量: 1 + Math.floor(prng() * 10) }), x, y);
        }
    }
    评分图 = 生成评分图('corner', { 已放置点: [入口, 出口] });
    使用评分图放置物品(评分图, 主洞穴, '普通物品');
    评分图 = 生成评分图('entry', { 已放置点: [入口, 出口] });
    使用评分图放置物品(评分图, 主洞穴, '特殊物品');

    //console.log("放置怪物和陷阱...");
    评分图 = 生成评分图('monster', { 已放置点: [入口, 出口] });
    使用评分图放置物品(评分图, 主洞穴, '怪物');
    评分图 = 生成评分图('trap', { 已放置点: [入口, 出口, ...所有怪物.map(m => ({x: m.x, y: m.y}))] });
    使用评分图放置物品(评分图, 主洞穴, '陷阱');

    生成并放置洞穴配方卷轴(地牢,当前层数);
    
   
    const fakeRoomForTraps = { id: -1, x: 0, y: 0, w: 100 + 当前层数 * 2, h: 100 + 当前层数 * 2,类型:'房间' };
    let t = Math.ceil(prng()*(当前层数+1)*2)
    for (let i=0;i<t;i++) {
        生成毒气陷阱群(fakeRoomForTraps);
    }
    
    生成墙壁();
    更新视口();
    已访问房间.add(-1);
    更新界面状态();
    //console.log("洞穴地牢生成完毕。");
    return true;
}
function 生成并放置洞穴配方卷轴(洞穴区域, 层数) {
    if (层数 === null || 层数 < 0 || 是否为教程层) {
        return;
    }

    const 卷轴数量 = 1 + Math.floor(prng() * 层数);
    let 成功放置数量 = 0;

    for (let i = 0; i < 卷轴数量; i++) {
        const 新配方 = 生成单个随机融合配方(层数);

        if (新配方) {
            const 配方物品 = new 配方卷轴({
                recipeData: 新配方,
                层数: 层数,
            });

            let 放置成功 = false;
            for (let 尝试 = 0; 尝试 < 50; 尝试++) {
                const x=Math.floor(prng() * (100 + 层数 * 2));
                const y=Math.floor(prng() * (100 + 层数 * 2));

                if (位置是否可用(x, y, false)) {
                    if (放置物品到单元格(配方物品, x, y)) {
                        成功放置数量++;
                        放置成功 = true;
                        break;
                    }
                }
            }
        }
    }

    if (成功放置数量 > 0) {
        //console.log(`在洞穴中成功放置了 ${成功放置数量} 个配方卷轴。`);
    }
}

function 初始化洞穴地图(wallChance) {
    for (let y = 0; y < 地牢大小; y++) {
        for (let x = 0; x < 地牢大小; x++) {
            if (x === 0 || x === 地牢大小 - 1 || y === 0 || y === 地牢大小 - 1) {
                地牢[y][x].背景类型 = 单元格类型.墙壁; // 边界总是墙
            } else {
                地牢[y][x].背景类型 = (prng() < wallChance) ? 单元格类型.墙壁 : 单元格类型.走廊;
            }
        }
    }
}


function 执行元细胞自动机迭代() {
    const 新地牢 = 地牢.map(row => row.map(cell => new 单元格(cell.x, cell.y)));

    for (let y = 1; y < 地牢大小 - 1; y++) {
        for (let x = 1; x < 地牢大小 - 1; x++) {
            let 周围墙壁数 = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    if (地牢[y + dy][x + dx].背景类型 === 单元格类型.墙壁) {
                        周围墙壁数++;
                    }
                }
            }

            if (地牢[y][x].背景类型 === 单元格类型.墙壁) {
                
                新地牢[y][x].背景类型 = (周围墙壁数 < 4) ? 单元格类型.走廊 : 单元格类型.墙壁;
            } else {
                新地牢[y][x].背景类型 = (周围墙壁数 >= 5) ? 单元格类型.墙壁 : 单元格类型.走廊;
            }
        }
    }
    地牢 = 新地牢;
}

function 处理洞穴连通性() {
    const 所有洞穴 = 寻找所有连通区域(单元格类型.走廊);
    const 所有墙壁区域 = 寻找所有连通区域(单元格类型.墙壁);

    // 填充过小的空洞
    所有洞穴.forEach(洞穴 => {
        if (洞穴.length < 20) { // 小于20格的空洞直接填成墙
            洞穴.forEach(点 => {
                地牢[点.y][点.x].背景类型 = 单元格类型.墙壁;
            });
        }
    });
    
    // 重新寻找洞穴
    const 最终洞穴 = 寻找所有连通区域(单元格类型.走廊);
    if (最终洞穴.length === 0) return { 主洞穴: null, 所有洞穴: [] };

    最终洞穴.sort((a, b) => b.length - a.length);
    const 主洞穴 = 最终洞穴[0];

    // 连接次级洞穴到主洞穴
    for (let i = 1; i < 最终洞穴.length; i++) {
        连接两个洞穴(主洞穴, 最终洞穴[i]);
    }
    
    return { 主洞穴, 所有洞穴: 最终洞穴 };
}


function 寻找所有连通区域(目标类型) {
    const 区域列表 = [];
    const 已访问 = new Set();

    for (let y = 0; y < 地牢大小; y++) {
        for (let x = 0; x < 地牢大小; x++) {
            if (!已访问.has(`${x},${y}`) && 地牢[y][x].背景类型 === 目标类型) {
                const 新区域 = [];
                const 队列 = [{ x, y }];
                已访问.add(`${x},${y}`);

                while (队列.length > 0) {
                    const 当前 = 队列.shift();
                    新区域.push(当前);

                    const 方向 = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                    for (const [dx, dy] of 方向) {
                        const 邻居X = 当前.x + dx;
                        const 邻居Y = 当前.y + dy;
                        const 邻居键 = `${邻居X},${邻居Y}`;

                        if (邻居X >= 0 && 邻居X < 地牢大小 && 邻居Y >= 0 && 邻居Y < 地牢大小 &&
                            !已访问.has(邻居键) && 地牢[邻居Y][邻居X].背景类型 === 目标类型) {
                            已访问.add(邻居键);
                            队列.push({ x: 邻居X, y: 邻居Y });
                        }
                    }
                }
                区域列表.push(新区域);
            }
        }
    }
    return 区域列表;
}

function 连接两个洞穴(洞穴A, 洞穴B) {
    let 最近点A = null, 最近点B = null;
    let 最短距离 = Infinity;

    // 暴力查找，对于生成阶段性能足够
    for (const 点A of 洞穴A) {
        for (const 点B of 洞穴B) {
            const 距离 = Math.pow(点A.x - 点B.x, 2) + Math.pow(点A.y - 点B.y, 2);
            if (距离 < 最短距离) {
                最短距离 = 距离;
                最近点A = 点A;
                最近点B = 点B;
            }
        }
    }

    if (最近点A && 最近点B) {
        const 路径 = 获取直线格子(最近点A.x, 最近点A.y, 最近点B.x, 最近点B.y);
        路径.forEach(点 => {
            // 挖出一条较粗的通道
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const tunnelX = 点.x + dx;
                    const tunnelY = 点.y + dy;
                    if (tunnelX >= 0 && tunnelX < 地牢大小 && tunnelY >= 0 && tunnelY < 地牢大小) {
                        地牢[tunnelY][tunnelX].背景类型 = 单元格类型.走廊;
                    }
                }
            }
        });
    }
}

function 生成评分图(criteria, options = {}) {
    const 评分图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(0));
    const { 已放置点 = [] } = options;

    for (let y = 0; y < 地牢大小; y++) {
        for (let x = 0; x < 地牢大小; x++) {
            if (地牢[y][x].背景类型 === 单元格类型.墙壁) continue;

            let score = 0;
            if (criteria === 'entry') {
                const radius = 4;
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (地牢[y + dy]?.[x + dx]?.背景类型 === 单元格类型.墙壁) {
                            score++;
                        }
                    }
                }
            } else if (criteria === 'corner') {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        if (地牢[y + dy]?.[x + dx]?.背景类型 === 单元格类型.墙壁) {
                            score++;
                        }
                    }
                }
            } else if (criteria === 'monster') {
                score = 10; // 基础分
                let openSpace = 0;
                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        if (地牢[y + dy]?.[x + dx]?.背景类型 !== 单元格类型.墙壁) {
                            openSpace++;
                        }
                    }
                }
                score += openSpace; // 越开阔分数越高
            } else if (criteria === 'trap') {
                let wallCount = 0, floorCount = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (地牢[y + dy]?.[x + dx]?.背景类型 === 单元格类型.墙壁) wallCount++;
                        else floorCount++;
                    }
                }
                if (wallCount > 2 && wallCount < 7) score = 20; // 通道区域分数高
            }
            评分图[y][x] = score;
        }
    }

    // 降低已放置点周围的分数
    已放置点.forEach(点 => {
        for (let dy = -5; dy <= 5; dy++) {
            for (let dx = -5; dx <= 5; dx++) {
                if (评分图[点.y + dy]?.[点.x + dx]) {
                    评分图[点.y + dy][点.x + dx] = 0;
                }
            }
        }
    });
    return 评分图;
}

function 放置地牢出入口(评分图, 可用区域) {
    const 查找最高分点 = (图) => {
        let 最高分 = -1;
        let 候选点 = [];
        可用区域.forEach(点 => {
            const score = 图[点.y][点.x];
            if (score > 最高分) {
                最高分 = score;
                候选点 = [点];
            } else if (score === 最高分) {
                候选点.push(点);
            }
        });
        return 候选点[Math.floor(prng() * 候选点.length)];
    };

    const 入口 = 查找最高分点(评分图);
    
    // 清除入口周围分数
    for (let dy = -10; dy <= 10; dy++) {
        for (let dx = -10; dx <= 10; dx++) {
            if (评分图[入口.y + dy]?.[入口.x + dx]) {
                评分图[入口.y + dy][入口.x + dx] = 0;
            }
        }
    }

    // 寻找离入口最远的最高分点作为出口
    let 最高分 = -1;
    let 候选出口 = [];
    可用区域.forEach(点 => {
        const score = 评分图[点.y][点.x];
        if (score > 最高分) {
            最高分 = score;
            候选出口 = [点];
        } else if (score === 最高分) {
            候选出口.push(点);
        }
    });

    let 出口 = null;
    let 最大距离 = -1;
    候选出口.forEach(点 => {
        const 距离 = Math.pow(点.x - 入口.x, 2) + Math.pow(点.y - 入口.y, 2);
        if (距离 > 最大距离) {
            最大距离 = 距离;
            出口 = 点;
        }
    });

    return { 入口, 出口: 出口 || 候选出口[0] };
}
function 创建楼梯实例(类型) {
    const isDown = 类型 === '下楼';
    return {
        类型: "楼梯",
        图标: isDown ? 楼梯图标.下楼 : 楼梯图标.上楼,
        显示图标: isDown ? 楼梯图标.下楼 : 楼梯图标.上楼,
        颜色索引: 颜色表.length,
        使用: () => {
            切换楼层(当前层数 + (isDown ? 1 : -1), false, null, true);
        },
        唯一标识: Symbol(`楼梯_${类型}`),
        获取名称: () => isDown ? "下楼楼梯" : "上楼楼梯",
        自定义数据: new Map(),
        品质: 1, 能否拾起: false, 是否正常物品: false, 是否隐藏: false, 是否为隐藏物品: false,
        效果描述: null, 已装备: false, 装备槽位: null, 堆叠数量: 1, 最大堆叠数量: 1, 颜色表: 颜色表,
    };
}

function 使用评分图放置物品(评分图, 可用区域, 类型) {
    const 当前怪物池 = [];
    for (let i = 0; i <= 当前层数; i++) {
        if (怪物引入计划.has(i)) {
            怪物引入计划.get(i).forEach(怪物定义 => {
                if (!当前怪物池.some(m => m.类.name === 怪物定义.类.name)) {
                    当前怪物池.push(怪物定义);
                }
            });
        }
    }

    const 当前物品池 = Object.values(物品池).flat().filter(item => 当前层数 >= item.最小层);
    
    let 候选池 = [];
    let 放置数量 = 0;
    
    if (类型 === '特殊物品') {
        const 特殊物品池 = [物品祭坛, 耐久祭坛, 背包扩容祭坛, 神龛, 洗身砚, 重铸台, 神秘商人, 探险家];
        候选池 = 特殊物品池.map(cls => ({ 类: cls }));
        放置数量 = 3 + Math.floor(当前层数 / 3);
    } else if (类型 === '怪物') {
        候选池 = 当前怪物池.filter(m => m.类.name !== "大魔法师" && m.类.name !== "米诺陶");
        
        候选池.push({ 类: 巡逻怪物, 权重: 8 });
        
        放置数量 = 20 + 当前层数 * 3;
    } else if (类型 === '陷阱') {
         const 陷阱池 = [隐形落石陷阱, 隐形地刺陷阱, 召唤怪物陷阱, 隐形失明陷阱, 烈焰触发陷阱, 隐形虫洞陷阱];
         候选池 = 陷阱池.map(cls => ({ 类: cls }));
         放置数量 = 10 + 当前层数;
    } else if (类型 === '普通物品') {
        候选池 = 当前物品池.filter(item => {
            const temp = new item.类({});
            return temp.是否正常物品 && temp.类型 !== '工具' && temp.类型 !== 'NPC' && temp.类型 !== '祭坛';
        });
        放置数量 = 10 + Math.floor(当前层数 / 2);
    } else {
        return;
    }

    if (候选池.length === 0) return;

    for (let i = 0; i < 放置数量; i++) {
        let 最高分 = -1;
        let 候选点 = [];
        可用区域.forEach(点 => {
            const score = 评分图[点.y][点.x];
            if (score > 最高分) {
                最高分 = score;
                候选点 = [点];
            } else if (score === 最高分) {
                候选点.push(点);
            }
        });
        
        if (候选点.length === 0) break;

        const 放置点 = 候选点[Math.floor(prng() * 候选点.length)];
        
        const 选中配置 = 候选池[Math.floor(prng() * 候选池.length)];
        const 强化 = prng() < 0.1 + 当前层数 * 0.03;
        
        let 放置成功 = false;
        if (类型 === '怪物') {
            const 新怪物 = new 选中配置.类({ 强化:强化, 随机游走: (选中配置.类 === 巡逻怪物), x:放置点.x,y:放置点.y });
            if (当前层数 > 7 && prng() < 0.15 + (当前层数 - 7) * 0.1) {
                const 药水池 = [
                    { 类型: '一次性治疗', 值: 50 },
                    { 类型: '永久隐身'},
                    { 类型: '永久速度', 值: 1, 图标: 图标映射.飞毛腿 },
                    { 类型: '永久抗火', 图标: 图标映射.永久抗火 },
                    { 类型: '永久力量', 值: 5, 图标: 图标映射.永久力量 },
                    { 类型: '永久强化', 值: 10 },
                    { 类型: '永久抗毒', 图标: 图标映射.永久抗毒 },
                    { 类型: '永久解冻', 图标: 图标映射.永久解冻 },
                    { 类型: '自爆', 图标: 图标映射.炸弹 }
                ];
                新怪物.携带药水 = 药水池[Math.floor(prng() * 药水池.length)];
                if (新怪物.携带药水.类型 === '自爆') 新怪物.永久增益.push(新怪物.携带药水);
            }
            放置成功 = 放置怪物到单元格(新怪物, 放置点.x, 放置点.y);
            if(放置成功) 新怪物.状态 = 怪物状态.活跃;
        } else {
            const 实例 = new 选中配置.类({ 强化:强化, 随机游走: (选中配置.类 === 巡逻怪物), x:放置点.x,y:放置点.y });
            放置成功 = 放置物品到单元格(实例, 放置点.x, 放置点.y);
        }

        if (放置成功) {
            const 清除半径 = (类型 === '特殊物品' || 类型 === '陷阱') ? 8 : 4;
            for (let dy = -清除半径; dy <= 清除半径; dy++) {
                for (let dx = -清除半径; dx <= 清除半径; dx++) {
                    if (评分图[放置点.y + dy]?.[放置点.x + dx]) {
                        评分图[放置点.y + dy][放置点.x + dx] = 0;
                    }
                }
            }
        }
    }
}
			const 设置按钮_主菜单 = document.getElementById("设置按钮_主菜单");
			设置按钮_主菜单.addEventListener("click", 打开设置窗口);
			
			document.getElementById("关闭设置窗口按钮").addEventListener("click", 关闭设置窗口);
			document.getElementById("保存设置按钮").addEventListener("click", 保存并应用设置);
			加载设置();
			当前层数 = null;
			显示主菜单();
			注册全局类();
			游戏设置.emojiCDN是否可用=true
			setTimeout(() =>{初始化创意工坊()},500);
			
			//进入教程层();
			//切换楼层(0);
			//更新背包显示();
			//更新界面状态();
			//动画帧(); // 启动动画循环
		</script>
	</body>
</html>
<!-- 我来组成第50000行代码 刻舟求剑的来了 -->