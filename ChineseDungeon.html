<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=0.5"
        />
        <title>Dungeon Game</title>
        <style>
            /*或哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈*/
            /* General Styles */
            body {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                height: 100vh;
                margin: 0;
                padding-top: 5vh;
                background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%);
                background-color: #1a1a1a;
                overflow: hidden;
                justify-content: flex-start;
            }

            /*隐藏滚轮*/
            ::-webkit-scrollbar {
                display: none;
            }

            /* 不可选中 */
            .不可选中 {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }

            /* Dungeon Canvas */
            #dungeonCanvas {
                border: 2px solid #2e2e2e;
                border-radius: 8px;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
                margin-bottom: 5vh;
                transition: transform 0.15s ease-out;
                filter: contrast(1.1) brightness(1.1);
            }

            /* --- 主菜单 --- */
            #主菜单容器 {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 10005;
                opacity: 1;
                transition: opacity 0.5s ease-out;
                color: #e0e0e0;
                font-family: "HarmonyOS Sans SC", "MiSans", system-ui,
                    "color-emoji";
                overflow: scroll;
            }

            #游戏标题 {
                font-size: 5rem;
                margin-bottom: 3rem;
                color: #4caf50;
                text-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
                font-family: "Arial Black", Gadget, sans-serif;
                letter-spacing: 2px;
                animation: 标题浮动 3s ease-in-out infinite;
            }

            @keyframes 标题浮动 {
                0%,
                100% {
                    transform: translateY(0);
                }

                50% {
                    transform: translateY(-10px);
                }
            }

            #菜单选项 {
                display: flex;
                flex-direction: column;
                gap: 1.5rem;
            }

            .菜单按钮 {
                padding: 1rem 2.5rem;
                font-size: 1.4rem;
                border: 2px solid #4caf50;
                border-radius: 8px;
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.2),
                    rgba(67, 160, 71, 0.1)
                );
                color: #e0e0e0;
                cursor: pointer;
                transition: all 0.3s ease;
                min-width: 250px;
                text-align: center;
                font-family: inherit;
            }

            .菜单按钮:hover {
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.4),
                    rgba(67, 160, 71, 0.3)
                );
                transform: translateY(-3px);
                box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
                border-color: #66bb6a;
            }

            .菜单按钮:active {
                transform: translateY(1px);
                box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
            }

            .菜单按钮:disabled {
                background: rgba(100, 100, 100, 0.2);
                border-color: #666;
                color: #888;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }

            #版本信息 {
                position: absolute;
                bottom: 10px;
                right: 10px;
                font-size: 0.8rem;
                color: #555;
            }

            /* --- 游戏状态控制 --- */
            body:not(.游戏进行中) #dungeonCanvas,
        body:not(.游戏进行中) .hud,
        body:not(.游戏进行中) .control-pad,
        body:not(.游戏进行中) .装备栏,
        body:not(.游戏进行中) #小地图容器,
        body:not(.游戏进行中) .control-row,
        /* 隐藏设置和小地图切换按钮的父容器 */
        body:not(.游戏进行中) #怪物指示器容器,
        body:not(.游戏进行中) #浮动提示框,
        body:not(.游戏进行中) .背包弹窗,
        body:not(.游戏进行中) #日志面板,
        body:not(.游戏进行中) #交易窗口,
        body:not(.游戏进行中) .附魔弹窗,
        body:not(.游戏进行中) .宠物遮罩,
        body:not(.游戏进行中) .通知容器,
        body:not(.游戏进行中) #教程提示窗口,
        body:not(.游戏进行中) #跳过教程按钮,
        body:not(.游戏进行中) #回放教程按钮,
        body:not(.游戏进行中) #设置菜单 {
                display: none;
                opacity: 0;
                pointer-events: none;
            }

            body.游戏进行中 #主菜单容器 {
                opacity: 0;
                pointer-events: none;
            }

            /* --- HUD --- */
            .hud {
                position: absolute;
                top: 5px;
                left: 5px;
                color: white;
                background: rgba(0, 0, 0, 0.7);
                padding: 12px;
                border-radius: 8px;
                font-family: Arial;
                display: flex;
                opacity: 0;
                transition: opacity 0.3s ease;
                pointer-events: none;
                min-width: 180px;
                flex-direction: column;
            }

            .hud.可见 {
                opacity: 1;
                pointer-events: auto;
            }

            /* --- 地图实体 --- */
            .怪物图标 {
                position: absolute;
                font-size: 1.2em;
                text-shadow: 0 0 8px #ff0000;
                transition: transform 0.2s;
            }

            /* 扣血特效 */
            .扣血遮罩 {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(255, 0, 0, 0.3);
                opacity: 0;
                pointer-events: none;
                animation: 扣血脉冲 0.8s ease-out;
            }

            @keyframes 扣血脉冲 {
                0% {
                    opacity: 0.8;
                }

                100% {
                    opacity: 0;
                }
            }

            .怪物指示器 {
                position: fixed;
                left: 0;
                top: 0;
                width: 12px;
                height: 12px;
                background: #ff4444;
                border-radius: 50%;
                box-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
                pointer-events: none;
                transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
                z-index: 1000;
            }

            /* 调整触发按钮样式 */
            #hudToggle {
                width: 6vmin;
                height: 6vmin;
                font-size: 3vmin;
                background: #2196f3;
                position: absolute;
                left: 48%;
                transform: translateX(-50%);
                bottom: 120%;
                z-index: 1000;
            }

            .hud-item {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 12px;
                /* 增加条目间距 */
            }

            .hud-icon {
                font-family: "color-emoji";
                font-size: 1.2em;
                width: 24px;
                text-align: center;
            }

            .hud-bar-container {
                position: relative;
                flex-grow: 1;
                height: 14px;
                margin-top: 4px;
                /* 进度条与图标间距 */
                height: 18px;
                /* 增大容器高度 */
            }

            .health-bar {
                background: linear-gradient(to right, #ff4444, #ff7676);
            }

            .power-bar {
                background: linear-gradient(to right, #1554db, #2c73f7);
            }

            .hud-label {
                color: #4caf50;
                font-size: 0.9em;
            }

            .怪物数量警告 {
                color: #ff4444;
            }

            .界面文本行 {
                color: #4caf50;
                font-size: 0.9em;
                display: flex;
                justify-content: space-between;
            }

            .进度条标签 {
                position: absolute;
                left: 4px;
                /* 改为左侧定位 */
                white-space: nowrap;
                bottom: 1px;
                color: rgba(255, 255, 255, 0.9);
                font-size: 0.75em;
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                z-index: 2;
                /* 确保文字在上层 */
            }

            .hud-bar {
                position: relative;
                height: 100%;
                border-radius: 4px;
                transition: width 0.3s ease;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            }

            @keyframes 进度条呼吸 {
                0% {
                    opacity: 0.9;
                }

                50% {
                    opacity: 0.7;
                }

                100% {
                    opacity: 0.9;
                }
            }

            .低数值警告 {
                animation: 进度条呼吸 1.5s ease infinite;
            }

            /* --- Control Panel --- */
            .control-pad {
                position: fixed;
                pointer-events: none;
                left: 20px;
                bottom: 80px;
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            /* Directional Buttons Container */
            #方向键容器 {
                position: fixed;
                left: 20px;
                top: 50%;
                display: flex;
                /* Added for better button arrangement */
                gap: 1rem;
                /* Added for spacing between buttons */
            }

            .control-row {
                display: flex;
                justify-content: center;
                margin: 5px 0;
                gap: 1.2rem;
            }

            .control-btn {
                font-family: "color-emoji";
                pointer-events: auto;
                width: 15vmin;
                height: 15vmin;
                border-radius: 3vmin;
                margin: 0 2px;
                font-size: 4vmin;
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.9) 30%,
                    rgba(67, 160, 71, 0.9) 100%
                );
                transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
                color: white;
                border: 2px solid #fff;
                opacity: 0.95;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            }

            .control-btn:active {
                background: #45a049;
                transform: scale(0.9);
                box-shadow: 0 0 5px rgba(76, 175, 80, 0.8);
            }

            #upBtn {
                margin-bottom: -12px;
                z-index: 2;
            }

            #leftBtn,
            #rightBtn {
                margin-left: -64px;
                margin: 0 1rem;
            }

            #downBtn {
                margin-top: -12px;
                z-index: 1;
            }

            #背包按钮 {
                /* Backpack Button */
                background: #2196f3;
                box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
            }

            /* --- Inventory (背包) --- */
            .背包弹窗 {
                /* Inventory Popup */
                position: fixed;
                bottom: -700px;
                left: 50%;
                transform: translateX(-50%);
                width: 80vmin;
                background: rgba(0, 0, 0, 0.9);
                border-radius: 12px;
                padding: 15px;
                transition: bottom 0.3s ease;
                z-index: 1001;
                max-height: 50vh;
                display: flex;
                flex-direction: column;
            }

            .背包弹窗.显示中 {
                bottom: 17vh;
            }

            .弹窗头部 {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }

            .弹窗头部 h3 {
                color: #4caf50;
                margin: 0;
                font-size: 1.2em;
            }

            .关闭按钮 {
                background: transparent;
                border: none;
                color: white;
                font-size: 1.5em;
                cursor: pointer;
                padding: 8px;
            }

            .物品容器 {
                flex: 1;
                overflow-y: auto;
                padding: 5px;
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 8px;
            }

            .物品条目 {
                position: relative;
                border-radius: 8px;
                padding: 12px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .hover:hover {
                background: rgba(255, 255, 255, 0.2);
                transform: translateY(-2px);
            }

            .物品图标 {
                font-family: "color-emoji";
                font-size: 2em;
                text-align: center;
                margin-bottom: 8px;
                filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
                transition: transform 0.3s;
            }

            .汉字图标 {
                font-family: "Microsoft YaHei", sans-serif;
                font-weight: bold;
                font-size: 1.2em;
            }

            .hover:hover .物品图标 {
                transform: scale(1.2) rotate(-15deg);
            }

            .物品名称 {
                font-size: 0.9em;
                text-align: center;
                color: #fff;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .物品堆叠 {
                position: absolute;
                bottom: 5px;
                right: 5px;
                background: linear-gradient(
                    45deg,
                    rgba(0, 0, 0, 0.6),
                    rgba(50, 50, 50, 0.8)
                );
                color: #fff;
                padding: 2px 6px;
                border-radius: 10px;
                font-size: 0.7em;
                font-weight: bold;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }

            .装备按钮,
            .上屏按钮,
            .丢弃按钮,
            .使用按钮 {
                font-family: "color-emoji";
                position: absolute;
                width: 24px;
                height: 24px;
                border-radius: 50%;
                border: none;
                color: white;
                cursor: pointer;
                opacity: 0;
                transition: all 0.3s;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px;
                padding: 0;
                z-index: 1;
                pointer-events: none;
            }

            .物品条目:hover .装备按钮,
            .物品条目:hover .丢弃按钮,
            .物品条目:hover .上屏按钮,
            .物品条目:hover .使用按钮,
            .物品条目.active .装备按钮,
            .物品条目.active .丢弃按钮,
            .物品条目.active .上屏按钮,
            .物品条目.active .使用按钮 {
                opacity: 1;
                pointer-events: auto;
            }

            .装备按钮 {
                bottom: 3px;
                left: 3px;
                background: linear-gradient(145deg, #ffb74d, #ff9800);
                /* 橙色渐变 */
            }

            .装备按钮:hover {
                background: linear-gradient(145deg, #ffa726, #fb8c00);
                box-shadow: 0 2px 6px rgba(255, 152, 0, 0.4);
            }

            .上屏按钮 {
                bottom: 3px;
                right: 3px;
                background: linear-gradient(145deg, #4fc3f7, #29b6f6);
            }

            .丢弃按钮 {
                top: 3px;
                right: 3px;
                background: linear-gradient(145deg, #bdbdbd, #9e9e9e);
                /* 灰色渐变 */
            }

            .丢弃按钮:hover {
                background: linear-gradient(145deg, #aeaeae, #8e8e8e);
                box-shadow: 0 2px 6px rgba(158, 158, 158, 0.4);
            }

            .使用按钮 {
                top: 3px;
                left: 3px;
                background: linear-gradient(145deg, #81c784, #4caf50);
                /* 绿色渐变 */
            }

            .使用按钮:hover {
                background: linear-gradient(145deg, #66bb6a, #43a047);
                box-shadow: 0 2px 6px rgba(76, 175, 80, 0.4);
            }

            .物品条目:hover .装备按钮,
            .物品条目:hover .丢弃按钮,
            .物品条目:hover .上屏按钮,
            .物品条目:hover .使用按钮 {
                opacity: 1;
            }

            .物品条目.active .物品图标 {
                transform: scale(1.2) rotate(-15deg);
            }

            .冷却标签 {
                position: absolute;
                bottom: 2px;
                background: rgba(0, 0, 0, 0.7);
                color: #fff;
                padding: 2px 5px;
                border-radius: 3px;
                font-size: 0.8em;
            }

            .耐久标签 {
                position: absolute;
                bottom: 2px;
                background: rgba(0, 0, 0, 0.7);
                color: #fff;
                padding: 2px 5px;
                border-radius: 3px;
                font-size: 0.8em;
                z-index: 2;
            }

            /* 怪物血条 */
            .怪物血条 {
                position: fixed;
                height: 4px;
                background: rgba(0, 0, 0, 0.5);
                border-radius: 2px;
                pointer-events: none;
                z-index: 100;
            }

            .血条背景 {
                height: 100%;
                background: #444;
            }

            .当前血量 {
                height: 100%;
                background: #f00;
                transition: width 0.3s;
            }

            /* 死亡动画 */
            .骷髅图标 {
                font-family: "color-emoji";
                font-size: 80px;
                animation: 骷髅抖动 1s infinite;
            }

            .死亡文字 {
                color: white;
                font-size: 40px;
                text-shadow: 0 0 10px red;
                margin-top: 20px;
            }

            .重生选项 {
                margin-top: 20px;
                display: flex;
                flex-direction: column;
                gap: 15px;
            }

            .重生按钮 {
                font-family: "color-emoji";
                padding: 12px 24px;
                font-size: 18px;
                border: 2px solid #fff;
                border-radius: 8px;
                background: rgba(255, 255, 255, 0.1);
                color: white;
                cursor: pointer;
                transition: all 0.3s;
            }

            .重生按钮:hover {
                background: rgba(255, 255, 255, 0.3);
                transform: scale(1.05);
            }

            .死亡内容 {
                text-align: center;
                animation: 死亡浮现 1s ease-out;
            }

            #死亡遮罩 {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: linear-gradient(
                    45deg,
                    rgba(20, 0, 0, 0.9) 0%,
                    rgba(60, 0, 0, 0.95) 100%
                );
                backdrop-filter: blur(10px);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10001;
                animation: 界面浮现 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            }

            @keyframes 界面浮现 {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }

                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .死亡内容容器 {
                font-family: "color-emoji";
                background: rgba(10, 0, 0, 0.8);
                border: 2px solid #ff444480;
                border-radius: 16px;
                padding: 40px 60px;
                box-shadow: 0 0 40px rgba(255, 50, 50, 0.3);
                text-align: center;
            }

            .骷髅容器 {
                position: relative;
                margin-bottom: 30px;
            }

            .动态骷髅 {
                font-size: 6rem;
                text-shadow: 0 0 30px #ff0000;
                animation: 骷髅呼吸 2s ease-in-out infinite;
                display: inline-block;
            }

            @keyframes 骷髅呼吸 {
                0% {
                    transform: scale(1) rotate(-5deg);
                    opacity: 0.9;
                }

                50% {
                    transform: scale(1.1) rotate(5deg);
                    opacity: 1;
                }

                100% {
                    transform: scale(1) rotate(-5deg);
                    opacity: 0.9;
                }
            }

            .重生选项 {
                font-family: "color-emoji";
                display: grid;
                gap: 20px;
                margin-top: 30px;
            }

            .重生按钮 {
                font-family: "color-emoji";
                padding: 16px 32px;
                font-size: 1.2rem;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
                background: linear-gradient(
                    145deg,
                    rgba(100, 0, 0, 0.8),
                    rgba(150, 0, 0, 0.6)
                );
                color: #fff;
                position: relative;
                overflow: hidden;
                border: 1px solid #ff4444;
            }

            .重生按钮::before {
                content: "";
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(
                    90deg,
                    transparent,
                    rgba(255, 255, 255, 0.2),
                    transparent
                );
                transition: 0.5s;
            }

            .重生按钮:hover::before {
                left: 100%;
            }

            .重生按钮:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 20px rgba(255, 50, 50, 0.4);
            }

            .重生按钮:active {
                transform: translateY(1px);
            }

            #重新开始 {
                background: linear-gradient(
                    145deg,
                    rgba(50, 50, 50, 0.8),
                    rgba(30, 30, 30, 0.6)
                );
                border-color: #666;
            }

            @keyframes 粒子飘落 {
                0% {
                    transform: translate(0, 0) scale(1);
                    opacity: 0.8;
                }

                100% {
                    transform: translate(
                            calc(var(--random) * 100 - 50) px,
                            100vh
                        )
                        scale(0);
                    opacity: 0;
                }
            }

            /* 添加点击态样式 */
            .物品条目.active {
                background: rgba(255, 255, 255, 0.2) !important;
                transform: translateY(-2px) !important;
            }

            .物品条目.active .装备按钮,
            .物品条目.active .丢弃按钮,
            .物品条目.active .上屏按钮,
            .物品条目.active .使用按钮 {
                opacity: 1 !important;
            }

            .物品条目[data-quality="1"] {
                border: 1px solid #00ff00;
            }

            .物品条目[data-quality="2"] {
                border: 1px solid #0000ff;
            }

            .物品条目[data-quality="3"] {
                border: 1px solid #ffff00;
            }

            .物品条目[data-quality="4"] {
                animation: 紫光脉动 2s infinite;
            }

            @keyframes 紫光脉动 {
                0%,
                100% {
                    box-shadow: 0 0 12px rgba(224, 64, 251, 0.3);
                }

                50% {
                    box-shadow: 0 0 24px rgba(224, 64, 251, 0.6);
                }
            }

            .物品条目[data-quality="5"] {
                animation: 红光脉动 2s infinite;
            }

            @keyframes 红光脉动 {
                0%,
                100% {
                    box-shadow: 0 0 12px #ff0000;
                }

                50% {
                    box-shadow: 0 0 24px #ff0000;
                }
            }

            .装备栏 {
                position: fixed;
                bottom: 10px;
                width: 30%;
                min-width: 400px;
                background: rgba(0, 0, 0, 0.7);
                padding: 10px;
                border-radius: 12px;
                display: flex;
                justify-content: center;
                gap: 1vw;
                z-index: 1000;
                transition: opacity 0.3s ease;
            }

            .装备槽 {
                flex: 1;
                aspect-ratio: 1 / 1;
                max-width: 80px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                position: relative;
                overflow: hidden;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s;
            }

            .冷却遮罩 {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                clip-path: inset(0 0 100% 0);
                transition: clip-path 0.22s linear;
                pointer-events: none;
            }

            .装备槽 .物品条目 {
                transform: scale(0.65);
                margin: -5px 0;
            }

            .装备槽:hover {
                background: rgba(255, 255, 255, 0.2);
            }

            /* --- Staircase (楼梯) --- */
            .楼梯 {
                background-color: #4a4a4a;
                font-size: 1.5em;
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            }

            /* --- Tooltip (浮动提示框) --- */
            #浮动提示框 {
                /* Tooltip */
                position: absolute;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 10px;
                border-radius: 6px;
                font-family: Arial;
                font-size: 12px;
                max-width: 200px;
                pointer-events: none;
                z-index: 1002;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                display: none;
                line-height: 1.4;
            }

            #浮动提示框 br {
                margin: 4px 0;
                content: "";
                display: block;
            }

            /* --- Level Transition (楼层过渡遮罩) --- */
            .楼层过渡遮罩 {
                /* Level Transition Overlay */
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: black;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.5s ease;
                z-index: 10001;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .层数标题 {
                /* Level Number Title */
                color: #ffffff;
                font-size: 4em;
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
                opacity: 0;
                transform: scale(3);
                transition: all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55);
                font-family: "Arial Black", sans-serif;
                letter-spacing: 4px;
            }

            /* --- Notifications (通知) --- */
            .通知容器 {
                /* Notification Container */
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 99999;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 10px;
                font-family: Arial, "微软雅黑";
            }

            .通知条目 {
                /* Notification Item */
                background: rgba(40, 40, 40, 0.95);
                color: #e0e0e0;
                padding: 12px 24px;
                border-radius: 6px;
                min-width: 280px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                border-left: 4px solid;
                opacity: 0;
                transform: translateY(-30px);
                animation: 通知入场 0.3s ease-out forwards;
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    opacity 0.2s linear;
                display: flex;
                align-items: center;
                gap: 12px;
                backdrop-filter: blur(5px);
            }

            .通知条目.离场 {
                /* Leaving Notification */
                animation: 通知离场 0.3s ease-in forwards;
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                    opacity 0.2s linear;
            }

            @keyframes 通知入场 {
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            @keyframes 通知离场 {
                to {
                    opacity: 0;
                    transform: translateY(-20px) scale(0.95);
                }
            }

            .通知条目.成功 {
                border-color: #4caf50;
            }

            .通知条目.警告 {
                border-color: #ff9800;
            }

            .通知条目.错误 {
                border-color: #f44336;
            }

            .通知条目.信息 {
                border-color: #2196f3;
            }

            .通知图标 {
                font-family: "color-emoji";
                width: 24px;
                height: 24px;
                flex-shrink: 0;
            }

            .关闭按钮 {
                font-family: "color-emoji";
                background: none;
                border: none;
                color: #888;
                cursor: pointer;
                margin-left: auto;
                padding-left: 20px;
                transition: color 0.2s;
            }

            .关闭按钮:hover {
                color: #fff;
            }

            /* --- Responsive Design --- */
            #小地图容器 {
                position: fixed;
                bottom: 160px;
                right: 20px;
                mix-blend-mode: lighten;
                transition: opacity 0.3s ease;
            }

            #小地图容器:hover {
                mix-blend-mode: normal;
            }

            #跳过教程按钮 {
                font-size: 0.8em;
                display: block;
                position: fixed;
                top: 185px;
                right: 22px;
                height: 5vmin;
                width: 20vmin;
            }

            @media (min-width: 769px) {
                .control-pad {
                    display: none;
                }

                .control-btn {
                    display: none;
                }

                .control-row {
                    display: none;
                }

                #小地图容器 {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    bottom: auto;
                    transform: none;
                }

                #跳过教程按钮 {
                    top: 240px;
                }

                #回放教程按钮 {
                    top: 185px;
                }
            }

            @media (max-width: 768px) {
                .control-pad {
                    display: flex;
                }

                .control-btn {
                    display: flex;
                }

                .control-row {
                    display: flex;
                }

                #跳过教程按钮 {
                    top: 40px;
                }

                #回放教程按钮 {
                    top: 10px;
                }
            }

            canvas {
                mix-blend-mode: lighten;
            }

            /* 烟花动画 */
            @keyframes 烟花炸裂 {
                0% {
                    transform: translate(0, 0) scale(1);
                    opacity: 1;
                }

                100% {
                    transform: translate(
                            calc(var(--tx) * 100px),
                            calc(var(--ty) * 100px)
                        )
                        scale(0);
                    opacity: 0;
                }
            }

            .烟花粒子 {
                font-family: "color-emoji";
                position: fixed;
                z-index: 99999;
                font-size: 1.2em;
                animation: 烟花炸裂 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)
                    forwards;
                pointer-events: none;
            }

            @keyframes 收集脉冲 {
                0% {
                    transform: scale(0);
                    opacity: 0;
                }

                50% {
                    transform: scale(1.2);
                    opacity: 1;
                    text-shadow: 0 0 30px var(--辉光颜色),
                        0 0 40px var(--辉光颜色);
                }

                100% {
                    transform: scale(1);
                    opacity: 0;
                    text-shadow: 0 0 10px var(--辉光颜色),
                        0 0 20px var(--辉光颜色);
                }
            }

            .收集特效 {
                font-family: "color-emoji";
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                font-size: 3em;
                z-index: 99998;
                animation: 收集脉冲 1.1s ease-out forwards;
                text-shadow: 0 0 10px var(--辉光颜色);
            }

            /*卷轴类待点击动画*/
            .卷轴闪烁 {
                animation: 卷轴脉冲 0.8s ease-in-out infinite;
                position: relative;
            }

            @keyframes 卷轴脉冲 {
                0% {
                    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
                    background: rgba(255, 215, 0, 0.1);
                }

                50% {
                    box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
                    background: rgba(255, 215, 0, 0.3);
                }

                100% {
                    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
                    background: rgba(255, 215, 0, 0.1);
                }
            }

            .卷轴闪烁::after {
                content: "";
                position: absolute;
                top: -5px;
                left: -5px;
                right: -5px;
                bottom: -5px;
                border-radius: 8px;
                background: linear-gradient(
                    45deg,
                    rgba(255, 215, 0, 0.3) 0%,
                    rgba(255, 215, 0, 0.1) 50%,
                    rgba(255, 215, 0, 0.3) 100%
                );
                z-index: -1;
                animation: 光晕扩散 1.2s infinite;
            }

            @keyframes 光晕扩散 {
                0% {
                    opacity: 0.8;
                }

                100% {
                    opacity: 0;
                }
            }

            /* 日志容器 */
            .日志面板 {
                position: fixed;
                right: 20px;
                bottom: -600px;
                width: 250px;
                height: 200px;
                background: rgba(0, 0, 0, 0.9);
                border-radius: 8px;
                padding: 12px;
                transition: bottom 0.3s ease;
                color: #c0c0c0;
                display: flex;
                flex-direction: column;
            }

            .日志内容 {
                flex: 1;
                overflow-y: auto;
                font-size: 0.9em;
                line-height: 1.4;
                scrollbar-width: thin;
                scrollbar-color: #4caf50 #2a2a2a;
            }

            .日志面板.可见 {
                bottom: 135px;
            }

            .日志内容 .成功 {
                color: green;
            }

            .日志内容 .错误 {
                color: red;
            }

            .日志内容 .警告 {
                color: yellow;
            }

            /* 滚动条样式 */
            .日志内容::-webkit-scrollbar {
                width: 6px;
            }

            .日志内容::-webkit-scrollbar-track {
                background: #2a2a2a;
            }

            .日志内容::-webkit-scrollbar-thumb {
                background: #4caf50;
                border-radius: 3px;
            }

            @keyframes 爆炸闪烁 {
                0% {
                    transform: scale(0);
                    opacity: 1;
                }

                50% {
                    transform: scale(1.2);
                    opacity: 0.8;
                }

                100% {
                    transform: scale(1);
                    opacity: 0;
                }
            }

            /* --- NPC-------流浪奸商 --- */
            #交易窗口 {
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 85%;
                max-width: 500px;
                background: linear-gradient(
                    145deg,
                    rgba(20, 20, 20, 0.95),
                    rgba(40, 40, 40, 0.98)
                );
                border: 2px solid #4caf50;
                border-radius: 12px;
                box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
                color: #e0e0e0;
                z-index: 1001;
                backdrop-filter: blur(5px);
                animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                display: none;
                flex-direction: column;
                transition: all 0.7s cubic-bezier(0.4, 0, 0.2, 1);
                max-height: 80vh;
            }

            #交易窗口.关闭中 {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
                pointer-events: none;
            }

            .窗口标题 {
                padding: 15px 20px;
                font-size: 1.3em;
                color: #4caf50;
                border-bottom: 1px solid rgba(76, 175, 80, 0.3);
                text-shadow: 0 0 5px rgba(76, 175, 80, 0.4);
                text-align: center;
                font-weight: bold;
                flex-shrink: 0;
            }

            .库存列表 {
                display: grid;
                gap: 12px;
                padding: 20px;
                overflow-y: auto;
                flex-grow: 1;
            }

            .交易物品条目 {
                background: rgba(255, 255, 255, 0.05);
                padding: 15px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .交易物品条目 .物品头 {
                display: flex;
                justify-content: flex-start;
                align-items: center;
                font-weight: bold;
            }

            .交易物品条目 .物品描述 {
                font-size: 0.85em;
                color: #aaa;
                line-height: 1.4;
            }

            .交易物品条目:hover {
                border-color: #4caf50;
                background: rgba(76, 175, 80, 0.15);
                transform: translateY(-2px);
                box-shadow: 0 3px 10px rgba(76, 175, 80, 0.2);
            }

            .物品价格 {
                color: #ffd700;
                font-size: 0.9em;
                font-weight: bold;
                white-space: nowrap;
                margin-left: 10px;
            }

            .交易底部 {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 15px 20px;
                border-top: 1px solid rgba(76, 175, 80, 0.3);
                background: rgba(0, 0, 0, 0.2);
                flex-shrink: 0;
            }

            .玩家金币 {
                color: #ffd700;
                font-weight: bold;
            }

            #交易窗口 .按钮 {
                padding: 8px 20px;
                font-size: 1em;
                border: 2px solid #4caf50;
                border-radius: 6px;
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.4),
                    rgba(67, 160, 71, 0.3)
                );
                color: #e0e0e0;
                cursor: pointer;
                transition: all 0.3s ease;
                font-family: inherit;
            }

            #交易窗口 .按钮:hover {
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.6),
                    rgba(67, 160, 71, 0.5)
                );
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
                border-color: #66bb6a;
            }

            #交易窗口 .按钮:active {
                transform: translateY(0px);
                box-shadow: 0 2px 5px rgba(76, 175, 80, 0.2);
            }

            /* --- NPC-------探险家收购 --- */
            #收购窗口 {
                display: none;
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 700px;
                background: linear-gradient(
                    145deg,
                    rgba(20, 20, 20, 0.95),
                    rgba(40, 40, 40, 0.98)
                );
                border: 2px solid #ff9800;
                border-radius: 12px;
                box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
                color: #e0e0e0;
                z-index: 1001;
                backdrop-filter: blur(5px);
                animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                flex-direction: column;
                max-height: 85vh;
            }

            #收购窗口.关闭中 {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
                pointer-events: none;
            }

            #收购窗口 .窗口标题 {
                color: #ff9800;
                border-bottom: 1px solid rgba(255, 152, 0, 0.3);
                text-shadow: 0 0 5px rgba(255, 152, 0, 0.4);
                padding: 15px 20px;
                font-size: 1.3em;
                text-align: center;
                font-weight: bold;
                flex-shrink: 0;
            }

            .收购内容 {
                display: flex;
                flex-grow: 1;
                overflow: hidden;
                padding: 15px;
                gap: 15px;
            }

            .收购物品列表,
            .玩家背包预览 {
                flex: 1;
                display: flex;
                flex-direction: column;
                background: rgba(255, 255, 255, 0.03);
                border-radius: 8px;
                padding: 10px;
                overflow: hidden;
            }

            .收购物品列表 h4,
            .玩家背包预览 h4 {
                margin-bottom: 10px;
                text-align: center;
                color: #ffcc80;
                flex-shrink: 0;
                padding-bottom: 5px;
                border-bottom: 1px dashed rgba(255, 152, 0, 0.2);
            }

            #收购需求列表,
            #玩家可售列表 {
                align-content: start;
                padding: 10px 5px;
                overflow-y: auto;
                flex-grow: 1;
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 8px;
            }

            .收购需求条目,
            .玩家可售条目 {
                background: rgba(255, 255, 255, 0.05);
                padding: 10px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 6px;
                transition: all 0.2s ease;
                text-align: center;
            }

            .玩家可售条目 {
                cursor: pointer;
            }

            .收购需求条目 .需求图标,
            .玩家可售条目 .物品图标 {
                font-size: 1.8em;
                display: block;
                margin-bottom: 5px;
                font-family: "color-emoji";
            }

            .玩家可售条目 .物品图标 {
                text-shadow: 0 0 5px currentColor;
            }

            .收购需求条目 .需求名称,
            .玩家可售条目 .物品名称 {
                font-size: 0.85em;
                display: block;
                margin-bottom: 5px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .收购需求条目 .需求价格,
            .玩家可售条目 .出售价格 {
                font-size: 0.9em;
                color: #ffd700;
                font-weight: bold;
                display: block;
            }

            .玩家可售条目:hover {
                border-color: #ff9800;
                background: rgba(255, 152, 0, 0.15);
                transform: translateY(-2px);
                box-shadow: 0 3px 10px rgba(255, 152, 0, 0.2);
            }

            #收购窗口 .交易底部 {
                border-top: 1px solid rgba(255, 152, 0, 0.3);
            }

            #收购窗口 .玩家金币 {
                color: #ffd700;
                font-weight: bold;
            }

            #收购窗口 .按钮 {
                padding: 8px 20px;
                font-size: 1em;
                border: 2px solid #ff9800;
                border-radius: 6px;
                background: linear-gradient(
                    145deg,
                    rgba(255, 152, 0, 0.4),
                    rgba(245, 124, 0, 0.3)
                );
                color: #e0e0e0;
                cursor: pointer;
                transition: all 0.3s ease;
                font-family: inherit;
            }

            #收购窗口 .按钮:hover {
                background: linear-gradient(
                    145deg,
                    rgba(255, 152, 0, 0.6),
                    rgba(245, 124, 0, 0.5)
                );
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
                border-color: #ffb74d;
            }

            #收购窗口 .按钮:active {
                transform: translateY(0px);
                box-shadow: 0 2px 5px rgba(255, 152, 0, 0.2);
            }

            /* 附魔系统 */
            .附魔弹窗 {
                font-family: "color-emoji";
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #2a0a3a 0%, #1a1a2f 100%);
                border: 2px solid #634b7d;
                border-radius: 12px;
                padding: 20px;
                box-shadow: 0 0 40px #6b2fa070;
                z-index: 10000;
                min-width: 400px;
                max-width: 90vw;
                backdrop-filter: blur(5px);
                animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .附魔弹窗.关闭中 {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
                pointer-events: none;
            }

            @keyframes 弹窗浮现 {
                from {
                    opacity: 0;
                    transform: translate(-50%, -45%) scale(0.9);
                    /* 初始缩小并偏移 */
                }

                to {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1);
                    /* 恢复原大小和位置 */
                }
            }

            .附魔头 {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
                padding-bottom: 15px;
                border-bottom: 1px solid #4a3560;
            }

            .附魔标题 {
                color: #c792ea;
                font-size: 1.4em;
                text-shadow: 0 0 10px #c792ea80;
                font-family: "微软雅黑", sans-serif;
            }

            .附魔装备容器 {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 15px;
                max-height: 60vh;
                overflow-y: auto;
                padding: 10px;
                margin-bottom: 20px;
            }

            .可附魔 {
                cursor: pointer;
                transition: all 0.3s;
                position: relative;
                overflow: hidden;
                background: #2d1b3c;
                border-radius: 8px;
                padding: 15px;
                border: 1px solid #4a3560;
            }

            .可附魔:hover {
                transform: translateY(-3px);
                box-shadow: 0 0 25px #c792ea80;
                background: #3a254d;
            }

            .可附魔:hover .物品图标 {
                animation: 装备浮动 1.5s ease-in-out infinite;
            }

            @keyframes 装备浮动 {
                0% {
                    transform: translateY(0);
                }

                50% {
                    transform: translateY(-5px);
                }

                100% {
                    transform: translateY(0);
                }
            }

            .附魔特效 {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }

            .魔幻粒子 {
                will-change: transform, opacity;
                filter: blur(2px);
                mix-blend-mode: screen;
                position: absolute;
                width: var(--size);
                height: var(--size);
                border-radius: 50%;
                background: hsla(var(--hue), 80%, var(--lightness), 0.8);
                transition: all 0.3s;
                animation: 粒子脉动 1.2s var(--delay) both,
                    光晕闪烁 1.4s var(--delay) linear infinite;
            }

            @keyframes 粒子脉动 {
                0% {
                    opacity: 1;
                    transform: translate(0, 0) scale(0.3);
                }

                100% {
                    opacity: 0;
                    transform: translate(var(--target-x), var(--target-y))
                        scale(0.2);
                }
            }

            @keyframes 光晕闪烁 {
                0%,
                100% {
                    box-shadow: 0 0 15px 3px hsl(var(--hue), 100%, 60%);
                }

                50% {
                    box-shadow: 0 0 25px 6px hsl(var(--hue), 100%, 70%);
                }
            }

            .附魔确认按钮 {
                background: linear-gradient(145deg, #c792ea, #9c27b0);
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.3s;
                font-size: 1.1em;
                margin-top: 20px;
                display: block;
                width: 100%;
            }

            .附魔确认按钮:hover {
                transform: scale(1.05);
                box-shadow: 0 0 20px #c792ea80;
            }

            /* 关闭按钮优化 */
            .附魔弹窗 .关闭按钮 {
                background: none;
                border: none;
                color: #c792ea;
                font-size: 1.8em;
                cursor: pointer;
                transition: all 0.3s;
                padding: 5px;
                line-height: 1;
            }

            .附魔弹窗 .关闭按钮:hover {
                color: #ff4081;
                transform: rotate(90deg);
            }

            /* 移动端适配 */
            @media (max-width: 768px) {
                .附魔弹窗 {
                    min-width: 300px;
                    padding: 15px;
                }

                .附魔标题 {
                    font-size: 1.2em;
                }

                .附魔装备容器 {
                    grid-template-columns: repeat(2, 1fr);
                }
            }

            /* 状态提示动画 */
            @keyframes 成功闪光 {
                0% {
                    background-color: #4caf5050;
                }

                50% {
                    background-color: #4caf5020;
                }

                100% {
                    background-color: transparent;
                }
            }

            .附魔成功 {
                animation: 成功闪光 1.5s ease-out;
            }

            .重铸弹窗 {
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1ae6;
                border: 2px solid #4a4a4a;
                border-radius: 12px;
                padding: 20px;
                width: 80vmin;
                max-width: 600px;
                color: #e0e0e0;
                z-index: 10000;
                box-shadow: 0 0 30px #00000080;
                animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                transition: opacity 0.3s ease,
                    transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            }

            .重铸弹窗-header {
                display: flex;
                justify-content: space-between;
                margin-bottom: 15px;
                border-bottom: 1px solid #444;
                padding-bottom: 10px;
            }

            .重铸弹窗-column {
                flex: 1;
                padding: 10px;
            }

            .重铸弹窗-items {
                display: grid;
                grid-template-rows: repeat(auto-fill, minmax(100px, 1fr));
                max-height: 50vh;
                overflow-y: scroll;
                gap: 10px;
            }

            #传送点列表容器 {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            }

            .重铸物品 {
                border: 1px solid #444;
                padding: 10px;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
                transform-origin: center;
                position: relative;
            }

            .重铸物品.selected {
                border-color: #4caf50;
                background: #2b2b2b;
                transform: scale(1.1);
                z-index: 1;
            }

            .重铸台耐久标签 {
                font-size: 0.8em;
                color: #888;
            }

            .重铸物品:hover {
                transform: translateY(-3px) scale(1.05);
                box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
            }

            .重铸遮罩 {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(3px);
                z-index: 9999;
            }

            #repairCost {
                font-family: "Arial Black";
                text-shadow: 0 0 5px currentColor;
                transition: color 0.3s ease;
            }

            /* 强化标识 */
            .重铸台强化标识 {
                position: absolute;
                top: 2px;
                right: 2px;
                color: #ffd700;
                font-size: 0.8em;
                text-shadow: 0 0 3px #ffd700;
            }

            /*------小地图-------*/
            #小地图 {
                position: relative;
                right: 10px;
                width: 150px;
                height: 150px;
                border: 2px solid #4caf50;
                border-radius: 8px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
                background: rgba(0, 0, 0, 0.9);
                z-index: 999;
                image-rendering: pixelated;
            }

            #小地图:hover {
                mix-blend-mode: normal;
            }

            .宠物管理窗口 {
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1ae6;
                border: 2px solid #4a4a4a;
                border-radius: 12px;
                padding: 20px;
                width: 90%;
                max-width: 500px;
                color: #e0e0e0;
                z-index: 10000;
                box-shadow: 0 0 30px #00000080;
                transition: opacity 0.3s ease,
                    transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
                max-height: 80vh;
                overflow-y: auto;
            }

            .宠物遮罩 {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.75);
                z-index: 9999;
            }

            .宠物状态栏 {
                margin: 15px 0;
            }

            .条容器,
            .宠物经验条容器 {
                height: 20px;
                background: #333;
                border-radius: 10px;
                margin: 10px 0;
                position: relative;
            }

            .宠物血量条 {
                height: 100%;
                background: linear-gradient(90deg, #f44336, #ff7043);
                border-radius: 10px;
                transition: width 0.3s;
            }

            .宠物经验条 {
                height: 100%;
                background: linear-gradient(90deg, #2196f3, #4dabf5);
                border-radius: 10px;
                transition: width 0.3s;
            }

            .宠物血量文本,
            .宠物经验文本 {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: white;
                font-size: 0.9em;
            }

            .宠物属性 {
                display: flex;
                justify-content: space-between;
                margin-top: 10px;
                color: #ddd;
                font-size: 0.9em;
            }

            .宠物装备格子容器 {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                margin-top: 15px;
            }

            .宠物装备格子 {
                border: 1px solid #555;
                padding: 10px;
                border-radius: 5px;
                position: relative;
                min-height: 80px;
                background: #2b2b2b;
            }

            .宠物装备槽位名 {
                position: relative;
                top: 4px;
                left: 10px;
                padding: 0 5px;
                font-size: 0.8em;
                color: #aaa;
            }

            .宠物装备选择按钮,
            .宠物装备卸下按钮 {
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.9) 30%,
                    rgba(67, 160, 71, 0.9) 100%
                );
                box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
                color: #fff;
                border: 2px solid #fff;
                opacity: 0.95;
                border: none;
                border-radius: 5px;
                padding: 5px 10px;
                color: white;
                cursor: pointer;
                transition: background 0.2s;
                font-family: inherit;
            }

            .宠物装备卸下按钮 {
                background: linear-gradient(
                    145deg,
                    rgba(244, 67, 54, 0.9) 30%,
                    rgba(206, 61, 49, 0.9) 100%
                );
                box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
                position: absolute;
                bottom: 5px;
                right: 5px;
            }

            .宠物技能容器 {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                margin-top: 15px;
            }

            .宠物技能 {
                border: 1px solid #555;
                padding: 10px;
                border-radius: 5px;
                background-color: #333;
            }

            .宠物装备选择弹窗 {
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1ae6;
                border: 2px solid #4a4a4a;
                border-radius: 12px;
                padding: 20px;
                width: 80%;
                max-width: 400px;
                color: #e0e0e0;
                z-index: 10001;
                box-shadow: 0 0 30px #00000080;
                transition: opacity 0.3s ease,
                    transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
                max-height: 75vh;
                overflow: scroll;
            }

            .可装备物品容器 {
                max-height: 60vh;
                overflow-y: auto;
                /* 滚动 */
                padding: 10px;
            }

            /* 可选装备样式 */
            .宠物可选装备 {
                display: flex;
                align-items: center;
                padding: 8px;
                border: 1px solid #2c3e50;
                border-radius: 6px;
                margin-bottom: 5px;
                background-color: #41586b;
                transition: background-color 0.2s;
            }

            .宠物可选装备:hover {
                background-color: #546e7a;
            }

            .宠物装备名称 {
                position: relative;
                top: 4px;
                left: 2px;
                padding: 0 5px;
                font-size: 0.8em;
                color: #aaa;
            }

            .宠物可选装备图标 {
                font-family: "color-emoji";
                margin-right: 10px;
                font-size: 1.2em;
            }

            .宠物装备图标 {
                font-family: "color-emoji";
            }

            .宠物装备选择弹窗 .关闭按钮 {
                position: absolute;
                top: 10px;
                right: 10px;
                background: none;
                border: none;
                font-size: 1.5em;
                color: #e74c3c;
                cursor: pointer;
                padding: 5px;
                z-index: 1;
            }

            .宠物装备选择确认按钮 {
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.9) 30%,
                    rgba(67, 160, 71, 0.9) 100%
                );
                box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
                color: #fff;
                border: none;
                border-radius: 5px;
                padding: 6px 12px;
                font-size: 0.9em;
                cursor: pointer;
                transition: background-color 0.2s, transform 0.2s;
                font-family: inherit;
                margin-left: auto;
            }

            .宠物装备选择确认按钮:hover {
                background: linear-gradient(
                    145deg,
                    rgba(67, 160, 71, 0.9) 30%,
                    rgba(58, 140, 62, 0.9) 100%
                );
                transform: translateY(-2px);
                /* 上浮效果 */
                box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
            }

            .通用按钮:hover {
                background: linear-gradient(
                    145deg,
                    rgba(67, 160, 71, 0.9) 30%,
                    rgba(58, 140, 62, 0.9) 100%
                );
                transform: translateY(-2px);
                /* 上浮效果 */
                box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
            }

            .宠物装备选择确认按钮:active {
                transform: scale(0.95);
            }

            .宠物可选装备 {
                padding: 10px;
            }

            .可装备物品容器 {
                max-height: 65vh;
                overflow-y: auto;
                padding: 10px;
                margin-bottom: 10px;
            }

            .宠物管理窗口,
            .宠物装备选择弹窗 {
                animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .宠物可选装备 {
                justify-content: space-between;
            }

            .宠物基本信息面板 p,
            .宠物技能面板 p {
                line-height: 1.6;
            }

            .宠物已装备物品 {
                display: flex;
                align-items: center;
                justify-content: space-between;
                width: 100%;
            }

            /* 无装备提示 */
            .无装备提示,
            .无技能提示 {
                color: #aaa;
                text-align: center;
                padding: 20px;
            }

            .宠物管理窗口 .关闭按钮 {
                position: absolute;
                top: 10px;
                right: 10px;
                background: none;
                border: none;
                font-size: 1.5em;
                color: #e74c3c;
                cursor: pointer;
                transition: transform 0.3s;
                padding: 5px;
            }

            .宠物管理窗口 .关闭按钮:hover {
                color: #ff4081;
                transform: rotate(90deg);
                /* 旋转动画 */
            }

            .宠物管理窗口 .通用按钮 {
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.9) 30%,
                    rgba(67, 160, 71, 0.9) 100%
                );
                box-shadow: 0 4px 20px #4caf504d;
                color: #fff;
                border: 2px solid #fff;
                opacity: 0.95;
                border: none;
                border-radius: 5px;
                padding: 5px 10px;
                color: white;
                cursor: pointer;
                transition: background-color 0.2s, transform 0.2s;
                font-family: inherit;
                margin-top: 10px;
                width: 100%;
            }

            .宠物血量标签 {
                position: absolute;
                bottom: 5px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.7);
                color: #fff;
                padding: 2px 8px;
                border-radius: 4px;
                font-size: 0.75em;
                white-space: nowrap;
                z-index: 1;
            }

            /* --- 自定义确认对话框 --- */
            .确认对话框遮罩 {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(8px);
                z-index: 10002;
                /* 比死亡遮罩高一级 */
                display: flex;
                justify-content: center;
                align-items: center;
                animation: 界面浮现 0.3s ease;
            }

            .确认对话框 {
                background: linear-gradient(145deg, #1e0000, #3c0000);
                border: 2px solid #ff4444;
                border-radius: 12px;
                padding: 30px 40px;
                box-shadow: 0 0 30px rgba(255, 0, 0, 0.4);
                text-align: center;
                color: #e0e0e0;
                font-family: inherit;
                max-width: 80%;
                animation: 界面浮现 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .确认对话框 h3 {
                margin-top: 0;
                font-size: 1.4em;
                color: #ff8a80;
                text-shadow: 0 0 8px #ff0000;
            }

            .确认对话框 p {
                margin: 15px 0 25px 0;
                font-size: 1em;
                line-height: 1.6;
                color: #ccc;
            }

            .确认按钮容器 {
                display: flex;
                justify-content: center;
                gap: 20px;
            }

            .确认按钮 {
                padding: 12px 28px;
                font-size: 1.1em;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-family: inherit;
                min-width: 120px;
            }

            .确认按钮-确认 {
                background: linear-gradient(145deg, #c62828, #e53935);
                color: white;
            }

            .确认按钮-确认:hover {
                background: linear-gradient(145deg, #d32f2f, #f44336);
                transform: translateY(-2px);
                box-shadow: 0 4px 15px rgba(255, 82, 82, 0.4);
            }

            .确认按钮-取消 {
                background: linear-gradient(145deg, #424242, #616161);
                color: #e0e0e0;
            }

            .确认按钮-取消:hover {
                background: linear-gradient(145deg, #616161, #757575);
                transform: translateY(-2px);
                box-shadow: 0 4px 15px rgba(100, 100, 100, 0.3);
            }

            /* --------------教程---------------*/
            .教程提示窗口 {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #282828f2, #3a3a3af2);
                color: #e0e0e0;
                padding: 20px 30px;
                border-radius: 12px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
                z-index: 10002;
                width: 85%;
                text-align: center;
                border: 2px solid #4caf50;
                animation: 弹窗浮现 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                display: none;
                font-family: "HarmonyOS Sans SC", "MiSans", system-ui,
                    "color-emoji";
            }

            .教程提示窗口 p {
                font-size: 1.1em;
                line-height: 1.5;
                margin-bottom: 15px;
            }

            .教程提示窗口 .关闭按钮 {
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.9) 30%,
                    rgba(67, 160, 71, 0.9) 100%
                );
                box-shadow: 0 2px 8px #4caf5066;
                color: #fff;
                padding: 8px 16px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 1em;
                font-family: inherit;
            }

            .教程提示窗口 .关闭按钮:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px #4caf5080;
                background: linear-gradient(
                    145deg,
                    rgba(67, 160, 71, 0.9) 30%,
                    rgba(58, 140, 62, 0.9) 100%
                );
            }

            .教程提示窗口.关闭中 {
                animation: 弹窗消失 0.3s ease-out forwards;
            }

            @keyframes 弹窗消失 {
                to {
                    opacity: 0;
                    transform: translate(-50%, -50%) scale(0.9);
                }
            }

            #回放教程按钮 {
                position: fixed;
                right: 22px;
                width: 20vmin;
            }

            #教程回放窗口 {
                display: none;
                max-width: 90%;
            }

            .教程导航 {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin: 15px 0;
                color: #aaa;
            }

            .教程导航 button {
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.7) 30%,
                    rgba(67, 160, 71, 0.7) 100%
                ) !important;
                box-shadow: 0 2px 6px #4caf504d !important;
                padding: 6px 12px !important;
                font-size: 0.9em !important;
            }

            .教程导航 button:disabled {
                background: #555 !important;
                cursor: not-allowed;
                opacity: 0.6;
                box-shadow: none !important;
            }

            /* -----------设置----------*/
            .设置菜单 {
                position: fixed;
                bottom: -450px;
                right: 20px;
                background: #000000e5;
                border-radius: 12px;
                padding: 15px;
                transition: bottom 0.3s ease;
                z-index: 1003;
                text-align: center;
            }

            .设置菜单 button {
                display: block;
                width: 100%;
                margin: 10px 0;
                padding: 10px;
                background: linear-gradient(
                    145deg,
                    rgba(76, 175, 80, 0.9) 30%,
                    rgba(67, 160, 71, 0.9) 100%
                );
                box-shadow: 0 4px 20px #4caf504d;
                color: #fff;
                border: 2px solid #fff;
                opacity: 0.95;
                border-radius: 8px;
                cursor: pointer;
                font-family: inherit;
                font-size: 1em;
            }

            .设置菜单 button:active {
                background: #45a049;
                transform: scale(0.9);
                box-shadow: 0 0 5px #4caf50cc;
            }

            .设置菜单.显示 {
                bottom: 160px;
            }

            .设置菜单.隐藏 {
                animation: 弹窗消失 0.3s ease-out forwards;
            }

            @keyframes 扭曲 {
                0% {
                    transform: scale(1) skew(0deg);
                }

                25% {
                    transform: scale(1.1) skew(5deg);
                }

                50% {
                    transform: scale(0.9) skew(-5deg);
                }

                75% {
                    transform: scale(1.05) skew(2deg);
                }

                100% {
                    transform: scale(1) skew(0deg);
                    opacity: 0;
                }
            }

            /* --- 传送菜单按钮 --- */
            #传送点菜单 {
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1ae6;
                border: 2px solid #4a4a4a;
                border-radius: 12px;
                padding: 20px;
                width: 80vmin;
                max-width: 600px;
                color: #e0e0e0;
                z-index: 10000;
                box-shadow: 0 0 30px #00000080;
                animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                transition: opacity 0.3s ease,
                    transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            }

            #传送点菜单 .菜单操作按钮 {
                padding: 5px 10px;
                /* 统一基础内边距 */
                font-size: 0.9em;
                /* 统一基础字号 */
                border: 1px solid transparent;
                /* 初始透明边框 */
                border-radius: 5px;
                color: #e0e0e0;
                cursor: pointer;
                transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
                /* 平滑过渡 */
                font-family: inherit;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
                /* 基础阴影 */
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
                display: inline-flex;
                /* 保证图标和文字对齐 */
                align-items: center;
                gap: 4px;
                /* 图标和文字间距 */
            }

            #传送点菜单 .菜单操作按钮:hover {
                transform: translateY(-2px);
                /* 悬浮上移 */
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
                /* 更深的阴影 */
            }

            #传送点菜单 .菜单操作按钮:active {
                transform: translateY(0px) scale(0.95);
                /* 按下效果 */
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
                /* 内阴影 */
            }

            /* 传送按钮 (绿色系) */
            #传送点菜单 .传送菜单按钮-传送 {
                background: linear-gradient(145deg, #4caf50, #388e3c);
                border-color: #66bb6a;
                box-shadow: 0 2px 5px rgba(76, 175, 80, 0.3);
            }

            #传送点菜单 .传送菜单按钮-传送:hover {
                background: linear-gradient(145deg, #66bb6a, #4caf50);
                border-color: #81c784;
                box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
            }

            /* 删除按钮 (深红/灰红系) */
            #传送点菜单 .传送菜单按钮-删除 {
                background: linear-gradient(145deg, #7f0000, #9e2b25);
                /* 更深的红色 */
                border-color: #b71c1c;
                box-shadow: 0 2px 5px rgba(127, 0, 0, 0.3);
            }

            #传送点菜单 .传送菜单按钮-删除:hover {
                background: linear-gradient(145deg, #9e2b25, #b71c1c);
                border-color: #d32f2f;
                box-shadow: 0 4px 12px rgba(127, 0, 0, 0.4);
            }

            #传送点菜单 .传送菜单按钮-保存 {
                background: linear-gradient(145deg, #4caf50, #388e3c);
                /* 青色系 */
                border-color: #009688;
                box-shadow: 0 2px 5px rgba(0, 121, 107, 0.3);
                /* 微调标题栏内按钮的样式 */
                font-size: 0.9em;
                margin-left: 10px;
            }

            #传送点菜单 .传送菜单按钮-保存:hover {
                background: linear-gradient(145deg, #66bb6a, #4caf50);
                border-color: #81c784;
                box-shadow: 0 4px 12px rgba(0, 121, 107, 0.4);
            }

            #图鉴分区选择窗口 {
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1ae6;
                border: 2px solid #4a4a4a;
                border-radius: 12px;
                padding: 20px;
                width: 80vmin;
                max-width: 600px;
                color: #e0e0e0;
                z-index: 10000;
                box-shadow: 0 0 30px #00000080;
                animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                transition: opacity 0.3s ease,
                    transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            }

            #融合窗口 {
                position: absolute;
                bottom: 100%;
                /* 调整垂直位置，使其在背包上方或旁边 */
                right: 0%;
                /* 调整水平位置 */
                width: 330px;
                /* 根据需要调整宽度 */
                background: rgba(0, 0, 0, 0.9);
                padding: 15px;
                z-index: 1002;
                /* 比背包高一级 */
                display: flex;
                /* 改为 flex 布局 */
                flex-direction: column;
                /* 垂直排列 */
                align-items: center;
                /* 居中对齐 */
                gap: 10px;
                /* 元素间距 */
                box-shadow: 0 3px 15px rgba(0, 0, 0, 0.5);
                transition: opacity 0.3s ease, transform 0.3s ease;
                /* 添加过渡效果 */
                opacity: 0;
                /* 初始隐藏 */
                transform: translateX(20px);
                /* 初始向右偏移一点，用于动画 */
                pointer-events: none;
                /* 初始不可交互 */
            }

            #融合窗口.显示中 {
                opacity: 1;
                transform: translateX(0);
                pointer-events: auto;
            }

            .融合标题 {
                color: #4caf50;
                font-size: 1.1em;
                margin-bottom: 10px;
                text-align: center;
                width: 100%;
            }

            .融合区域 {
                display: grid;
                grid-template-columns: repeat(2, 60px);
                /* 2x2 网格 */
                grid-template-rows: repeat(2, 60px);
                gap: 8px;
                /* 格子间距 */
                margin-bottom: 10px;
                /* 与箭头间距 */
                justify-content: center;
                top: 5px;
                position: relative;
            }

            .融合区格子,
            .融合输出格子 {
                width: 60px;
                /* 格子大小 */
                height: 60px;
                background: rgba(255, 255, 255, 0.1);
                border: 1px dashed #555;
                /* 虚线边框 */
                border-radius: 6px;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
                /* 用于定位物品 */
                cursor: pointer;
                /* 添加指针手势 */
            }

            .融合区格子:hover,
            .融合输出格子:hover {
                background: rgba(255, 255, 255, 0.15);
                border-color: #888;
            }

            .融合箭头 {
                font-size: 1.8em;
                color: #888;
                margin: 0 10px;
            }

            #融合窗口 .物品条目 {
                transform: scale(0.65);
                /* 缩小物品显示 */
                padding: 0;
                margin: 0;
                border: none;
                /* 移除边框 */
                background: transparent;
                /* 透明背景 */
                box-shadow: none;
                width: 100%;
                height: 100%;
                cursor: pointer;
                /* 明确指针 */
            }

            #融合窗口 .物品条目 .物品图标 {
                font-size: 1.8em;
                /* 调整图标大小 */
                margin-bottom: 2px;
            }

            #融合窗口 .物品条目 .物品名称 {
                font-size: 0.7em;
                /* 调整名称大小 */
                display: none;
                /* 默认隐藏名称，空间太小 */
            }

            #融合窗口 .物品条目 .物品堆叠 {
                font-size: 0.6em;
                /* 调整堆叠数字大小 */
                bottom: 2px;
                right: 2px;
                padding: 1px 4px;
            }

            /* -----------优化字体适配------------- */
            body,
            .hud,
            .控制按钮 {
                font-family: "HarmonyOS Sans SC", "MiSans", system-ui,
                    "color-emoji";
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            }

            @font-face {
                font-family: "color-emoji";
                src: local("Apple Color Emoji"),
                    url("./AppleColorEmoji.woff") format("woff"),
                    local("Segoe UI Emoji"), local("Segoe UI Symbol"),
                    local("Noto Color Emoji"), local("Arial");
            }
        </style>
    </head>

    <body>
        <canvas id="dungeonCanvas"></canvas>
        <div
            id="图鉴分区选择遮罩"
            class="重铸遮罩"
            style="display: none; z-index: 10005"
        >
            <div id="图鉴分区选择窗口">
                <div class="重铸弹窗-header">
                    <h3>选择图鉴分区</h3>
                    <button class="关闭按钮" id="关闭图鉴选择按钮">×</button>
                </div>
                <div
                    id="图鉴分区列表容器"
                    class="重铸弹窗-items"
                    style="
                        max-height: 60vh;
                        grid-template-columns: repeat(
                            auto-fill,
                            minmax(150px, 1fr)
                        );
                    "
                ></div>
            </div>
        </div>
        <div id="主菜单容器">
            <h1 id="游戏标题">中文地牢</h1>
            <div id="菜单选项">
                <button id="新建游戏按钮" class="菜单按钮">开始新游戏</button>
                <button id="读取存档按钮" class="菜单按钮">读取存档</button>
                <button id="图鉴按钮" class="菜单按钮">图鉴</button>
                <button id="读凭证按钮" class="菜单按钮">读取凭证</button>
                <button
                    id="切换中文按钮"
                    class="菜单按钮"
                    onclick="切换中文模式()"
                >
                    切换显示语言
                </button>
                <button
                    id="切换动画按钮"
                    class="菜单按钮"
                    onclick="切换动画模式()"
                >
                    切换动画模式
                </button>
            </div>
            <div id="版本信息">v1419</div>
        </div>
        <div id="教程提示窗口" class="教程提示窗口">
            <p id="教程提示内容"></p>
            <button class="关闭按钮" onclick="关闭教程提示()">我知道了</button>
        </div>

        <button
            id="回放教程按钮"
            class="control-btn"
            onclick="打开教程回放窗口()"
            style="display: block; height: 5vmin; font-size: 0.8em"
        >
            回看教程
        </button>
        <button id="跳过教程按钮" class="control-btn" onclick="跳过教程()">
            跳过
        </button>
        <div id="教程回放窗口" class="教程提示窗口">
            <p id="教程回放内容"></p>
            <div class="教程导航">
                <button
                    id="上一页教程按钮"
                    class="关闭按钮"
                    style="margin-left: unset"
                >
                    上一页
                </button>
                <span id="教程页码" style="margin-left: auto">1 / 1</span>
                <button id="下一页教程按钮" class="关闭按钮">下一页</button>
            </div>
            <button class="关闭按钮" onclick="关闭教程回放窗口()">关闭</button>
        </div>
        <div id="扣血特效" class="扣血遮罩"></div>
        <div id="怪物指示器容器"></div>
        <div class="装备栏">
            <div class="装备槽" id="装备槽1"></div>
            <div class="装备槽" id="装备槽2"></div>
            <div class="装备槽" id="装备槽3"></div>
            <div class="装备槽" id="装备槽4"></div>
            <div class="装备槽" id="装备槽5"></div>
            <div class="装备槽" id="装备槽6"></div>
            <div class="装备槽" id="装备槽7"></div>
        </div>
        <div class="control-pad 不可选中" style="z-index: 1000">
            <!-- 日志浮窗Z:1002 大于 悬浮提示Z:1002 背包Z：1001 控制钮Z：1000 设置钮Z：999-->
            <div class="control-row">
                <div class="control-btn" id="upBtn">↑</div>
            </div>
            <div class="control-row">
                <div class="control-btn" id="leftBtn">←</div>
                <div class="control-btn" id="rightBtn">→</div>
            </div>
            <div class="control-row">
                <div class="control-btn" id="downBtn">↓</div>
            </div>
            <div class="control-row">
                <button
                    id="背包按钮"
                    onclick="切换背包显示()"
                    class="control-btn"
                >
                    🎒
                </button>
                <button class="control-btn" id="互动按钮" onclick="尝试互动()">
                    ⚡
                </button>

                <button
                    id="hudToggle"
                    class="control-btn"
                    style="position: absolute; bottom: 110%"
                    onclick="切换HUD模式()"
                >
                    👁️
                </button>
            </div>
        </div>
        <div
            class="control-row"
            style="right: 23px; position: fixed; bottom: 80px; z-index: 999"
        >
            <button
                id="设置按钮"
                class="control-btn"
                onclick="切换设置菜单()"
                style="font-size: 1em"
            >
                ⚙️
            </button>
        </div>
        <div id="浮动提示框"></div>
        <div
            id="配方书遮罩"
            class="重铸遮罩"
            style="display: none; z-index: 10005"
        >
            <div
                id="配方书窗口"
                style="
                    position: fixed;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    background: #1a1a1ae6;
                    border: 2px solid #4a4a4a;
                    border-radius: 12px;
                    padding: 20px;
                    width: 80vmin;
                    max-width: 700px;
                    color: #e0e0e0;
                    z-index: 10006;
                    box-shadow: 0 0 30px #00000080;
                    animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                    transition: opacity 0.3s ease,
                        transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
                    display: flex;
                    flex-direction: column;
                    max-height: 85vh;
                "
            >
                <div
                    class="重铸弹窗-header"
                    style="border-bottom: 1px solid #4caf50"
                >
                    <h3 style="color: #4caf50">配方书</h3>
                    <button
                        class="关闭按钮"
                        id="关闭配方书按钮"
                        style="color: #4caf50"
                    >
                        ×
                    </button>
                </div>
                <div
                    id="配方书内容容器"
                    class="重铸弹窗-items"
                    style="
                        max-height: calc(85vh - 100px);
                        overflow-y: auto;
                        padding: 15px;
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                    "
                ></div>
            </div>
        </div>

        <div id="设置菜单" class="设置菜单">
            <button onclick="切换日志显示()">打开日志菜单</button>
            <button onclick="收纳通知()">收纳通知</button>
            <button onclick="打开传送菜单()">打开传送菜单</button>
            <button onclick="打开配方书()">配方书</button>
            <button onclick="导出存档()">导出存档</button>
            <button id="自杀按钮" onclick="玩家死亡()">自杀</button>
        </div>
        <div
            id="传送点遮罩"
            class="重铸遮罩"
            style="display: none; z-index: 10001"
        >
            <div id="传送点菜单">
                <div class="重铸弹窗-header">
                    <h3>选择传送目标</h3>
                    <button class="关闭按钮" onclick="关闭传送菜单()">×</button>
                </div>
                <div
                    id="传送点列表容器"
                    class="重铸弹窗-items"
                    style="max-height: 60vh"
                ></div>
            </div>
        </div>
        <input
            type="file"
            id="存档文件输入"
            accept=".json"
            style="display: none"
        />
        <div id="小地图容器">
            <canvas id="小地图"></canvas>
        </div>
        <div class="hud">
            <div class="hud-item">
                <span class="hud-icon">♥️</span>
                <div class="hud-bar-container">
                    <div class="hud-bar health-bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="hud-item">
                <span class="hud-icon">⚡︎</span>
                <div class="hud-bar-container">
                    <div class="hud-bar power-bar" style="width: 100%"></div>
                </div>
            </div>
            <div class="hud-item">
                <div class="界面文本行">
                    <span class="hud-label"
                        >已探索房间：<span id="roomCount">0</span></span
                    >
                </div>
            </div>
        </div>
        <div class="背包弹窗">
            <div id="融合窗口" style="display: none">
                <div class="弹窗头部">
                    <h3>物品融合</h3>
                </div>
                <div class="融合区域">
                    <div class="融合区格子" id="融合区格子1"></div>
                    <div class="融合区格子" id="融合区格子2"></div>
                    <div class="融合区格子" id="融合区格子3"></div>
                    <div class="融合区格子" id="融合区格子4"></div>
                </div>
                <div class="融合箭头">➡️</div>
                <div class="融合输出格子" id="融合输出格子"></div>
            </div>
            <div class="弹窗头部">
                <h3>
                    背包 (容量：<span id="当前容量">0</span>/<span id="最大容量"
                        >12</span
                    >)
                </h3>
                <button onclick="切换背包显示()" class="关闭按钮">×</button>
            </div>
            <div id="背包物品栏" class="物品容器"></div>
        </div>
        <div id="transitionMask" class="楼层过渡遮罩">
            <div id="floorTitle" class="层数标题"></div>
        </div>
        <div class="日志面板" id="日志面板" style="z-index: 1002">
            <div class="日志内容" id="logContent"></div>
        </div>
        <div id="交易窗口">
            <div class="窗口标题">
                神秘商人（剩余交易次数：<span id="交易次数">3</span>）
            </div>
            <div class="库存列表"></div>
            <div class="交易底部">
                <div class="玩家金币">
                    持有金币：<span id="当前金币">0</span>
                </div>
                <button onclick="关闭交易窗口()" class="按钮">离开</button>
            </div>
        </div>
        <div id="收购窗口" class="游戏窗口">
            <div class="窗口标题">探险家收购</div>
            <div class="收购内容">
                <div class="收购物品列表">
                    <h4>探险家想收购的物品：</h4>
                    <div id="收购需求列表" class="库存列表"></div>
                </div>
                <div class="玩家背包预览">
                    <h4>你拥有的（点击出售）：</h4>
                    <div id="玩家可售列表" class="库存列表"></div>
                </div>
            </div>
            <div class="交易底部">
                <div class="玩家金币">
                    持有金币：<span id="收购窗口金币">0</span>
                </div>
                <button onclick="关闭收购窗口()" class="按钮">告辞</button>
            </div>
        </div>
        <script>
            const canvas = document.getElementById("dungeonCanvas");
            const ctx = canvas.getContext("2d");

            // 常量 好吧有些已经变成变量了
            let 单元格大小 = 30;
            let 画布宽度 = Math.min(
                window.innerWidth - 20,
                window.innerHeight - 20
            ); // 动态宽度
            let 画布高度 = 画布宽度; // 动态高度
            const 房间尺寸范围 = [7, 10];
            const 最大房间数 = 15;
            let 相机显示边长 = 15;
            const 最大堆叠数 = 64;
            let 地牢大小 = 100;
            const 存档版本 = "v1";
            const 所有天气列表 = [
                "雷暴",
                "诡魅",
                "大风",
                "严寒",
                "深夜",
                "深夜",
            ];
            const 大风吹动概率 = 0.3;
            let 互动冷却 = false;
            const 怪物移动动画时长 = 300;

            const 调试序列 = ["上", "上", "下", "下", "左", "右", "左", "右"];
            // 单元格类型枚举
            let 当前层数 = 0;
            let 所有地牢层 = new Map(); // 保存各层地牢数据

            let 图标映射 = {
                药水: "🧪",
                钢制长剑: "🗡️",
                橡木法杖: "🪄",
                吸血剑: "🗡️",
                喷火枪: "💥",
                冰霜法杖: "🪄",
                重力锤: "🔨",
                剧毒匕首: "🐍",
                卷轴: "📜",
                钥匙: "🔑",
                金币: "🪙",
                回旋镖: "🪃",
                闪电链法杖: "🌩️",
                大地猛击锤: "🔨",
                穿云箭: "🏹",
                荆棘鞭: "⛓️",
                秘银锁甲: "🥼",
                真言卷轴: "📖",
                钢制板甲: "🥋",
                金币手枪: "🔫",
                下楼楼梯: "⬇️",
                上楼楼梯: "⬆️",
                怪物: "👾",
                炸弹怪物: "💣",
                盔甲怪物: "💂",
                炸弹: "💣",
                罐子: "🏺",
                缓慢: "🐌",
                敏捷怪物: "🏃",
                远攻怪物: "👼",
                仙人掌怪物: "🌵",
                大魔法师: "🧙",
                寻宝戒指: "💍",
                装备按钮: "🛡",
                死亡图标: "💀",
                错误: "❌",
                成功: "✅",
                冰冻怪物: "🧊",
                冰盾: "❄",
                重铸台: "⚒️",
                斜方刀: "💠",
                神秘商人: "🧙",
                探险家: "👨‍🌾",
                祭坛: "🛐",
                互动按钮: "⚡",
                背包按钮: "🎒",
                卷轴按钮: "📜",
                HUD常显: "👀",
                HUD智能: "👁️",
                HUD常隐: "😑",
                宠物: "🐾",
                熊猫: "🐼",
                水母: "🪼",
                大史莱姆: "🦠",
                小史莱姆: "🦠",
                瞬移怪物: "💫",
                伪装怪物: "👿",
                腐蚀怪物: "👹",
                盗贼怪物: "🥷",
                萨满怪物: "⚕️",
                召唤师怪物: "🧿",
                幽灵仆从: "👻",
                吸能怪物: "😈",
                剧毒云雾怪物: "☁️",
                旋风怪物: "🌪️",
                米诺陶: "🐂",
                折跃门: "🍥",
                魔法师法杖: "🔱",
                符文圈: "⭕",
                水晶: "💎",
                毒液: "💧",
                能量草: "🌿",
                旋风: "🌀",
                旋风物品: "🍃",
                眩晕: "💫",
                火焰: "🔥",
                引雷针护符: "🗼",
                种子: "🌱",
                荆棘丛: "🌵",
                灵能盾牌: "🛡️",
                恐惧魔杖: "🔮",
                恐惧怪物: "😨",
                调试工具: "🛠️",
                恐惧: "😨",
                冲撞牛角: "🐂",
                护卫植物: "🛡️",
                远射植物: "🎯",
                泉水: "💧",
                书架: "📚",
                渔网: "🕸️",
                充能魔杖: "🔋",
                时间卷轴: "⏳",
                潜行靴子: "👟",
                钩索: "🪝",
                嗜血战斧: "🪓",
                渔网陷阱: "🕸️",
                磨刀石: "✨",
                急救绷带: "🩹",
                照明弹: "🚨",
                照明弹光源: "💡",
                挑战石碑: "🏛️",
                神龛: "⛩️",
                洗身砚: "🧼",
                毒气瓶: "⚗️",
                万能钥匙: "🗝️",
                陨石法杖: "☄️",
                毒气: "☣️",
                落石: "🪨",
            地刺: "뾰",
            失明: "🕶️",
            召唤陷阱: "🧿",
            烈焰陷阱: "♨️",
            虫洞: "🌀",
            障碍物: "🧱",
            远射陷阱: "🗼",
            };
            const 中文对照图标映射 = {
                药水: "药",
                钢制长剑: "剑",
                吸血剑: "吸",
                橡木法杖: "法",
                卷轴: "卷",
                钥匙: "钥",
                金币: "金",
                喷火枪: "喷",
                回旋镖: "回",
                闪电链法杖: "链",
                大地猛击锤: "震",
                穿云箭: "穿",
                荆棘鞭: "鞭",
                能量草: "草",
                秘银锁甲: "翈",
                真言卷轴: "视",
                钢制板甲: "甲",
                金币手枪: "枪",
                下楼楼梯: "下",
                上楼楼梯: "上",
                怪物: "怪",
                炸弹怪物: "爆",
                炸弹: "炸",
                罐子: "罐",
                盔甲怪物: "魁",
                敏捷怪物: "速",
                远攻怪物: "远",
                仙人掌怪物: "刺",
                大魔法师: "师",
                寻宝戒指: "戒",
                装备按钮: "装",
                死亡图标: "☠︎",
                错误: "✘",
                成功: "✔",
                缓慢: "慢",
                冰冻怪物: "㓕",
                冰盾: "栤",
                重铸台: "铸",
                斜方刀: "斜",
                神秘商人: "商",
                探险家: "探",
                祭坛: "坛",
                互动按钮: "互",
                背包按钮: "背",
                卷轴按钮: "卷",
                HUD常显: "显",
                HUD智能: "䚐",
                HUD常隐: "隐",
                魔法师法杖: "法",
                符文圈: "符",
                水晶: "晶",
                宠物: "宠",
                熊猫: "態",
                水母: "鲝",
                冰霜法杖: "霜",
                重力锤: "引",
                剧毒匕首: "毒",
                大史莱姆: "大",
                小史莱姆: "小",
                瞬移怪物: "瞬",
                伪装怪物: "伪",
                腐蚀怪物: "蚀",
                盗贼怪物: "盗",
                萨满怪物: "萨",
                召唤师怪物: "召",
                幽灵仆从: "仆",
                吸能怪物: "吸",
                剧毒云雾怪物: "雾",
                旋风怪物: "旋",
                旋风: "風",
                旋风物品: "风",
                米诺陶: "㸴",
                折跃门: "门",
                毒液: "毒",
                眩晕: "晕",
                火焰: "火",
                引雷针护符: "引",
                种子: "种",
                荆棘丛: "荆",
                灵能盾牌: "灵",
                恐惧魔杖: "惧",
                恐惧怪物: "恐",
                调试工具: "调",
                恐惧: "恐",
                冲撞牛角: "角",
                护卫植物: "卫",
                远射植物: "远",
                泉水: "泉",
                书架: "书",
                渔网: "网",
                充能魔杖: "充",
                时间卷轴: "时",
                潜行靴子: "潜",
                钩索: "钩",
                嗜血战斧: "斧",
                渔网陷阱: "网",
                磨刀石: "磨",
                急救绷带: "绷",
                照明弹: "照",
                照明弹光源: "光",
                挑战石碑: "碑",
                神龛: "龛",
                洗身砚: "砚",
                毒气瓶: "瓶",
                万能钥匙: "万",
                陨石法杖: "星",
                毒气: "毒",
                落石: "石",
            地刺: "刺",
            失明: "盲",
            召唤陷阱: "召",
            烈焰陷阱: "焰",
            虫洞: "洞",
            障碍物: "障",
            远射陷阱: "塔",
            };
            // 单元格类型枚举
            const 单元格类型 = {
                墙壁: 0,
                房间: 1,
                走廊: 2,
                门: 3,
                上锁的门: 4,
                物品: 5,
                楼梯下楼: 6,
                楼梯上楼: 7,
                怪物: 8,
            };
            const 怪物状态 = {
                休眠: 0,
                活跃: 1,
                攻击: 2,
            };
            const 颜色表 = [
                "#00FF00", // 绿色
                "#0000FF", // 蓝色
                "#FFFF00", // 黄色
                "#FF00FF", // 品红
                "#FF0000", // 红色
            ];
            const 效果颜色编号映射 = [
                "#ff0000",
                "#00ff00",
                "#2196F3",
                "#FF9800",
                "#808080",
                "#9C27B0",
                "#008000",
                "#888888",
                "#8FBC8F",
                "#FFEB3B",
                "#CC5500",
                "#FFD700",
                "#8A2BE2",
                "#A0522D",
            ];
            const 效果名称编号映射 = {
                治疗: 0,
                能量: 1,
                神龟: 2,
                狂暴: 3,
                隐身: 4,
                透视: 5,
                中毒: 6,
                缓慢: 7,
                腐蚀: 8,
                眩晕: 9,
                火焰: 10,
                充能: 11,
                恐惧: 12,
                牵制: 13,
            };
            const 颜色名表 = ["绿", "蓝", "黄", "品红", "红"];
            let 楼梯图标 = { 下楼: 图标映射.下楼楼梯, 上楼: 图标映射.上楼楼梯 };
            const 功能键映射 = {
                1: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 1),
                2: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 2),
                3: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 3),
                4: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 4),
                5: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 5),
                6: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 6),
                7: () => 使用装备槽物品(当前装备页 * 装备栏每页装备数 + 7),
                q: () => {
                    界面可见性.hud = !界面可见性.hud;
                    hud模式 = 界面可见性.hud ? "常显" : "常隐";
                    document
                        .querySelector(".hud")
                        .classList.toggle("可见", 界面可见性.hud);
                },
                f: () => {
                    if (NPC互动中) {
                        if (当前NPC.名称 === "神秘商人") {
                            关闭交易窗口();
                        }
                    } else {
                        尝试互动();
                    }
                },
                e: () => {
                    界面可见性.背包 = !界面可见性.背包;
                    切换背包显示();
                },
                "-": 切换中文模式,
                g: 切换日志显示,
                z: 导出存档,
                t: 打开传送菜单,
                j: () => {
                    切换装备页(-1);
                },
                k: () => {
                    切换装备页(1);
                },
                u: 玩家死亡,
                c: 打开配方书,
            };
            const 物品生成配置 = {
                基础概率: {
                    普通房间: 0.4,
                    上锁房间: 0.7,
                },
                品质权重: {
                    1: [60, 0], // 品质: [基础刷新概率,随层数增长的附加刷新概率]
                    2: [25, 20],
                    3: [10, 30],
                    4: [5, 40],
                    5: [0, 10],
                },
                类型分布: {
                    普通房间: [
                        { 类型: "武器", 权重: 40 },
                        { 类型: "防具", 权重: 30 },
                        { 类型: "药水", 权重: 20 },
                        { 类型: "卷轴", 权重: 10 },
                        { 类型: "工具", 权重: 25 },
                        { 类型: "宠物", 权重: 10 },
                    ],
                    上锁房间: [
                        { 类型: "卷轴", 权重: 30 },
                        { 类型: "武器", 权重: 30 },
                        { 类型: "药水", 权重: 25 },
                        { 类型: "防具", 权重: 15 },
                        { 类型: "工具", 权重: 25 },
                        { 类型: "宠物", 权重: 10 },
                    ],
                },
            };

            const 创建物品池 = () => ({
                武器: [
                    { 类: 荆棘种子, 品质: 1, 最小层: 1 },
                    { 类: 护卫种子, 品质: 2, 最小层: 1 },
                    { 类: 远射种子, 品质: 3, 最小层: 2 },
                    { 类: 吸能种子, 品质: 2, 最小层: 1 },
                    { 类: 橡木法杖, 品质: 2, 最小层: 3 },
                    { 类: 钢制长剑, 品质: 1, 最小层: 0 },
                    { 类: 吸血剑, 品质: 1, 最小层: 0 },
                    { 类: 喷火枪, 品质: 1, 最小层: 0 },
                    { 类: 炸弹, 品质: 2, 最小层: 1 },
                    { 类: 金币手枪, 品质: 3, 最小层: 2 },
                    { 类: 回旋镖, 品质: 2, 最小层: 1 },
                    { 类: 闪电链法杖, 品质: 3, 最小层: 3 },
                    { 类: 大地猛击锤, 品质: 3, 最小层: 3 },
                    { 类: 穿云箭, 品质: 2, 最小层: 2 },
                    { 类: 荆棘鞭, 品质: 1, 最小层: 1 },
                    { 类: 冰霜法杖, 品质: 3, 最小层: 2 },
                    { 类: 重力锤, 品质: 4, 最小层: 5 },
                    { 类: 剧毒匕首, 品质: 1, 最小层: 1 },
                    { 类: 神秘商人, 品质: 1, 最小层: 1 }, // 奸商武力值要高，所以在武器类（确信）
                    { 类: 恐惧魔杖, 品质: 3, 最小层: 4 },
                    { 类: 斜方刀, 品质: 2, 最小层: 1 },
                    { 类: 充能魔杖, 品质: 4, 最小层: 6 },
                    { 类: 嗜血战斧, 品质: 4, 最小层: 4 },
                    { 类: 陨石法杖, 品质: 4, 最小层: 6 },
                ],
                工具: [
                    { 类: 能量熔炉, 品质: 3, 最小层: 4 },
                    { 类: 物品祭坛, 品质: 1, 最小层: 0 },
                    { 类: 耐久祭坛, 品质: 2, 最小层: 0 },
                    { 类: 背包扩容祭坛, 品质: 2, 最小层: 0 },
                    { 类: 重铸台, 品质: 3, 最小层: 2 },
                    { 类: 探险家, 品质: 1, 最小层: 1 },
                    { 类: 火把, 品质: 1, 最小层: 2 },
                    { 类: 罐子, 品质: 1, 最小层: 0 },
                    { 类: 渔网, 品质: 2, 最小层: 1 },
                    { 类: 钩索, 品质: 3, 最小层: 2 },
                    { 类: 急救绷带, 品质: 2, 最小层: 1 },
                    { 类: 磨刀石, 品质: 3, 最小层: 2},
                    { 类: 照明弹, 品质: 2, 最小层: 2},
                    { 类: 挑战石碑, 品质: 4, 最小层: 3},
                    { 类: 神龛, 品质: 5, 最小层: 2},
                    { 类: 洗身砚, 品质: 4, 最小层: 3 },
                    { 类: 毒气瓶, 品质: 2, 最小层: 2 },
                    { 类: 万能钥匙, 品质: 3, 最小层: 3 },
                    { 类: 障碍物物品, 品质: 1, 最小层: 0 },
                ],
                防具: [
                    { 类: 引雷针护符, 品质: 3, 最小层: 2 },
                    { 类: 钢制板甲, 品质: 2, 最小层: 0 },
                    { 类: 秘银锁甲, 品质: 4, 最小层: 2 },
                    { 类: 冰盾, 品质: 1, 最小层: 1 },
                    { 类: 潜行靴子, 品质: 2, 最小层: 4 },
                ],
                药水: [
                    { 类: 治疗药水, 品质: 2, 最小层: 0 },
                    { 类: 狂暴药水, 品质: 2, 最小层: 0 },
                    { 类: 神龟药水, 品质: 3, 最小层: 1 },
                    { 类: 能量药水, 品质: 4, 最小层: 1 },
                    { 类: 隐身药水, 品质: 3, 最小层: 2 },
                    { 类: 透视药水, 品质: 3, 最小层: 1 },
                ],
                卷轴: [
                    { 类: 迅捷卷轴, 品质: 2, 最小层: 0 },
                    { 类: 清净卷轴, 品质: 2, 最小层: 0 },
                    { 类: 跃迁卷轴, 品质: 3, 最小层: 2 },
                    { 类: 真言卷轴, 品质: 4, 最小层: 4 },
                    { 类: 湮灭卷轴, 品质: 1, 最小层: 0 },
                    { 类: 贪婪卷轴, 品质: 3, 最小层: 3 },
                    { 类: 神秘卷轴, 品质: 1, 最小层: 0 },
                    { 类: 附魔卷轴, 品质: 1, 最小层: 1 },
                    { 类: 时间卷轴, 品质: 4, 最小层: 5 },
                ],
                宠物: [
                    { 类: 熊猫, 品质: 3, 最小层: 2 },
                    { 类: 水母, 品质: 4, 最小层: 2 },
                ],
            });

            const 创建怪物池 = () => ({
                普通房间: [
                    { 类: 怪物, 权重: 45, 最小层: 0 },
                    { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
                    { 类: 敏捷怪物, 权重: 15, 最小层: 2 },
                    { 类: 远攻怪物, 权重: 25, 最小层: 1 },
                    { 类: 炸弹怪物, 权重: 15, 最小层: 3 },
                    { 类: 冰冻怪物, 权重: 15, 最小层: 2 },
                    { 类: 仙人掌怪物, 权重: 25, 最小层: 1 },
                    { 类: 大史莱姆怪物, 权重: 15, 最小层: 2 },
                    { 类: 瞬移怪物, 权重: 10, 最小层: 3 },
                    { 类: 伪装怪物, 权重: 8, 最小层: 1 },
                    { 类: 腐蚀怪物, 权重: 12, 最小层: 2 },
                    { 类: 盗贼怪物, 权重: 10, 最小层: 1 },
                    { 类: 萨满怪物, 权重: 7, 最小层: 3 },
                    { 类: 召唤师怪物, 权重: 6, 最小层: 4 },
                    { 类: 吸能怪物, 权重: 11, 最小层: 1 },
                    { 类: 剧毒云雾怪物, 权重: 9, 最小层: 2 },
                    { 类: 旋风怪物, 权重: 10, 最小层: 4 },
                    { 类: 恐惧怪物, 权重: 10, 最小层: 3 },
                ],
                上锁房间: [
                    { 类: 炸弹怪物, 权重: 35, 最小层: 1 },
                    { 类: 远攻怪物, 权重: 30, 最小层: 3 },
                    { 类: 敏捷怪物, 权重: 35, 最小层: 2 },
                    { 类: 冰冻怪物, 权重: 15, 最小层: 0 },
                    { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
                    { 类: 仙人掌怪物, 权重: 30, 最小层: 1 },
                    { 类: 大史莱姆怪物, 权重: 20, 最小层: 2 },
                    { 类: 瞬移怪物, 权重: 15, 最小层: 3 },
                    { 类: 伪装怪物, 权重: 12, 最小层: 1 },
                    { 类: 腐蚀怪物, 权重: 18, 最小层: 2 },
                    { 类: 盗贼怪物, 权重: 18, 最小层: 1 },
                    { 类: 萨满怪物, 权重: 5, 最小层: 3 },
                    { 类: 召唤师怪物, 权重: 4, 最小层: 4 },
                    { 类: 吸能怪物, 权重: 9, 最小层: 1 },
                    { 类: 剧毒云雾怪物, 权重: 7, 最小层: 2 },
                    { 类: 旋风怪物, 权重: 12, 最小层: 3 },
                    { 类: 恐惧怪物, 权重: 15, 最小层: 3 },
                ],
            });
            const 融合Buff类型 = {
                攻击加成: "ATTACK_BONUS",
                攻击倍率: "ATTACK_MULTIPLIER",
                冷却缩减: "COOLDOWN_REDUCTION",
                冷却倍率: "COOLDOWN_MULTIPLIER",
                耐久加成: "DURABILITY_BONUS",
                耐久倍率: "DURABILITY_MULTIPLIER",
                范围加成: "RANGE_BONUS",
                中毒几率: "POISON_CHANCE",
                火焰伤害: "FIRE_DAMAGE_CHANCE",
                冰冻几率: "ICE_CHANCE",
                生命偷取: "LIFE_STEAL",
                防御加成: "DEFENSE_BONUS",
                防御倍率: "DEFENSE_MULTIPLIER",
                暴击几率: "CRITICAL_CHANCE",
                暴击伤害倍率: "CRITICAL_DAMAGE_MULTIPLIER",
                击退几率: "KNOCKBACK_CHANCE",
                攻击吸能: "ENERGY_STEAL_ON_HIT",
                闪避几率: "DODGE_CHANCE",
                固定伤害减免: "FLAT_DAMAGE_REDUCTION",
                受击回能: "ENERGY_ON_DAMAGE_TAKEN",
                幸运一击: "LUCKY_STRIKE",
                协同效应: "SYNERGY_EFFECT",
                磨刀石攻击加成: "SHARPEN_ATTACK_BONUS",
                磨刀石冷却缩减: "SHARPEN_COOLDOWN_REDUCTION",
            };
            const 神龛效果列表 = [
                {
                    id: '祝福_最大生命值',
                    名称: '生命祝福',
                    描述: '你的体魄变得更加强健，最大生命值永久提升了25点。',
                    类型: '祝福',
                    apply: () => { 
                        永久Buffs.最大生命值加成 = (永久Buffs.最大生命值加成 || 0) + 25; 
                        应用永久Buffs(); // 立即应用效果
                    }
                },
                {
                    id: '祝福_挖掘墙壁',
                    名称: '开山之力',
                    描述: '你获得了开山之力，现在可以挖掘墙壁了！',
                    类型: '祝福',
                    apply: () => { 
                        永久Buffs.能挖掘墙壁 = true; 
                        应用永久Buffs(); // 立即应用效果
                    }
                },
                {
                    id: '祝福_永久攻击',
                    名称: '战神之赐',
                    描述: '武运昌隆！你的基础攻击力永久提升了2点。',
                    类型: '祝福',
                    apply: () => { 
                        永久Buffs.攻击加成 = (永久Buffs.攻击加成 || 0) + 2;
                        应用永久Buffs(); // 立即应用效果
                    }
                },
                {
                    id: '诅咒_随机掉落',
                    名称: '失物之咒',
                    描述: '你的口袋似乎有个破洞，移动时偶尔会随机掉落背包中的物品！',
                    类型: '诅咒',
                    apply: () => { 
                        永久Buffs.随机掉落 = true; 
                        应用永久Buffs(); // 立即应用效果
                    }
                },
                {
                    id: '诅咒_挑战增加',
                    名称: '好战之血',
                    描述: '你变得更好战了，所有挑战房间的波数都将永久增加2波。',
                    类型: '诅咒',
                    apply: () => { 
                        永久Buffs.挑战波数增加 = (永久Buffs.挑战波数增加 || 0) + 2; 
                        应用永久Buffs(); // 立即应用效果
                    }
                },
                {
                    id: '诅咒_怪物反伤',
                    名称: '荆棘诅咒',
                    描述: '你的攻击似乎会激怒地牢的意志，所有怪物现在都会反弹少量伤害给你。',
                    类型: '诅咒',
                    apply: () => { 
                        永久Buffs.怪物反伤 = true; 
                        应用永久Buffs(); // 立即应用效果
                    }
                },
                {
                    id: '诅咒_耐久减半',
                    名称: '腐朽之触',
                    描述: '一股腐朽的力量侵蚀了你的装备，所有装备的耐久度立即减半！',
                    类型: '诅咒',
                    apply: () => {
                        [...玩家背包.values(), ...玩家装备.values()].forEach(item => {
                            if (item && item.自定义数据 && item.自定义数据.has('耐久') && !item.自定义数据.get('不可破坏')) {
                                const 当前耐久 = item.自定义数据.get('耐久');
                                item.自定义数据.set('耐久', Math.ceil(当前耐久 / 2));
                            }
                        });
                        更新装备显示();
                        更新背包显示();
                    }
                }
            ];


            // 全局变量
            let 地牢 = [];
            let 房间列表 = [];
            let 当前天气效果 = [];
            let 玩家装备 = new Map(); // 以装备槽位为索引，目前有 4 个槽位，索引从 1 开始
            let 玩家 = { x: 0, y: 0 };
            let 小地图Ctx;
            const 小地图缩放 = 3;
            const 小地图Offset = 10;
            let 视口偏移X = 0,
                视口偏移Y = 0;
            let 跟踪玩家怪物数 = 0;
            let 房间地图 = Array(地牢大小)
                .fill()
                .map(() => Array(地牢大小).fill(-1)); // 记录每个单元格所属房间ID
            let 上锁房间列表 = []; // 存储被锁定房间对象
            let 已访问房间 = new Set(); // 记录已访问过的房间
            let 显示HUD计时器 = null;
            let hud模式 = "默认";
            let 背包可见 = false;
            let 玩家背包 = new Map(); // 以物品唯一标识为索引
            let 最大背包容量 = 12;
            let 门实例列表 = new Map();
            const 通知队列 = [];
            let 移动历史 = [];
            let 传送点列表 = []; // 存储传送点 { id: string, 名称: string, 层数: number, x: number, y: number }
            const 最大传送点数量 = 5; // 限制最大保存数量
            let 上次移动 = 0;
            let 移动状态 = {
                up: false,
                down: false,
                left: false,
                right: false,
            };
            let hud显示 = false;
            let 界面可见性 = {
                hud: false,
                背包: false,
            };
            let 所有怪物 = [];
            const 怪物生成概率 = 0.7;
            const 最大怪物数 = 5; //一个房间内的怪物生成上限
            let 玩家初始位置 = { x: 0, y: 0 };
            let 死亡界面已显示 = false;
            let 单击移动定时器 = null;
            let 开始移动定时器 = null;
            let 长按移动 = false;
            let 当前激活卷轴列表 = new Set();
            let 移动间隔 = 100; // 长按连续移动间隔
            let 首次移动延迟 = 250; // 首次移动后的延迟
            let 最后移动时间 = 0;
            let 移动定时器 = null;
            let 教程阶段 = 0;
            let 教程提示已显示 = false;
            let 是否为教程层 = false;
            let 玩家属性 = {
                移动步数: 1,
                攻击加成: 0,
                防御加成: 0,
                掉落倍率: 1,
                透视: false,
                允许移动: 0,
                能挖掘墙壁: false, 
                最大生命值加成: 0,
                怪物反伤: false,
                挑战波数增加: 0,
                随机掉落: false,
                已获得神龛效果: [],
            };
            let 初始玩家属性 = {
                移动步数: 1,
                攻击加成: 0,
                防御加成: 0,
                掉落倍率: 1,
                透视: false,
                允许移动: 0,
                能挖掘墙壁: false, 
                最大生命值加成: 0,
                怪物反伤: false,
                挑战波数增加: 0,
                随机掉落: false,
                已获得神龛效果: [],
            };
            let 永久Buffs = {
                已获得效果: new Set(),
            };
            let 相机目标X = 视口偏移X;
            let 相机目标Y = 视口偏移Y;
            let 当前相机X = 视口偏移X;
            let 当前相机Y = 视口偏移Y;
            let 相机锁定 = false; // 防止中途更新目标
            const 相机移动速度 = 0.2;
            let 显示模式 = "装备"; // 默认显示装备槽
            let 日志历史 = [];
            let 是否显示通知 = true;
            let 日志面板可见 = false;
            let 所有计时器 = [];
            let 玩家状态 = [];
            let NPC互动中 = false;
            let 当前NPC = null;
            let 已击杀怪物数 = 0;
            let 怪物状态表 = new WeakMap(); //好耶！WeakMap！
            let 彩蛋1触发,
                彩蛋2触发,
                彩蛋3触发 = false; //卑鄙的人，彩蛋要靠自己寻找才有意义
            let 待显示格子特效队列 = [];
            let 活动DOM特效 = [];
            let 待显示爆炸范围 = [];
            let 物品池;
            let 怪物池;
            let 所有物品定义 = []; // 用于存储图鉴的物品定义
            let 所有怪物定义 = [];
            let 怪物动画状态 = new WeakMap();
            let 玩家正在放置障碍物 = false;

            let moveQueue = [];
            let isAutoMoving = false;
            let 最高教程阶段 = 0;
            let 当前回放阶段 = 0;
            let 中文模式 = false;
            let 游戏状态 = "主菜单"; // "主菜单", "游戏中"
            let 自动回合间隔 = 350;
            let 上次自动回合时间 = 0;
            let 玩家正在钩索 = false;
            let 钩索移动定时器 = null;
            let 生存挑战激活 = false;
            let 生存挑战备份单元格 = [];
            
            //装备栏相关
            let 当前装备页 = 0;
            let 最大装备页 = 6;
            let 最大装备槽数量 = 24;
            let 触摸起始X = 0;
            let 触摸移动X = 0;
            let 装备栏滑动中 = false;
            let 装备栏每页装备数 = 7;

            canvas.addEventListener("touchstart", 处理地图点击);
            canvas.addEventListener("click", 处理地图单击); // 兼容PC端点击
            function 注册全局类() {
                // --- 基础类 ---
                window.门 = 门;
                window.物品 = 物品;
                window.怪物 = 怪物;
                window.单元格 = 单元格;
                window.状态效果 = 状态效果;

                // --- 物品子类 ---
                window.钥匙 = 钥匙;
                window.金币 = 金币;
                window.武器类 = 武器类;
                window.卷轴类 = 卷轴类;
                window.防御装备类 = 防御装备类;
                window.棋子 = 棋子;
                window.药水类 = 药水类;
                window.宠物 = 宠物;
                window.重铸台 = 重铸台;
                window.神秘商人 = 神秘商人;
                window.探险家 = 探险家;
                window.祭坛类 = 祭坛类;
                window.物品祭坛 = 物品祭坛;
                window.耐久祭坛 = 耐久祭坛;
                window.背包扩容祭坛 = 背包扩容祭坛;
                window.寻宝戒指 = 寻宝戒指;
                window.折跃门 = 折跃门;
                window.炸弹 = 炸弹;
                window.旋风物品 = 旋风物品;
                window.火焰物品 = 火焰物品;
                window.火把 = 火把;
                window.毒液物品 = 毒液物品;
                window.罐子 = 罐子;
                window.空罐子 = 空罐子;
                window.泉水 = 泉水;
                window.书架 = 书架;
                window.神龛 = 神龛;
                window.照明弹光源 = 照明弹光源;
                window.挑战石碑 = 挑战石碑;
                window.洗身砚 = 洗身砚;
                window.陷阱基类 = 陷阱基类;
            window.隐形落石陷阱 = 隐形落石陷阱;
            window.隐形地刺陷阱 = 隐形地刺陷阱;
            window.隐形毒气陷阱 = 隐形毒气陷阱;
            window.远射陷阱 = 远射陷阱;
            window.隐形失明陷阱 = 隐形失明陷阱;
            window.召唤怪物陷阱 = 召唤怪物陷阱;
            window.烈焰触发陷阱 = 烈焰触发陷阱;
            window.隐形虫洞陷阱 = 隐形虫洞陷阱;
            window.障碍物物品 = 障碍物物品;
            window.已放置的障碍物 = 已放置的障碍物;

                // --- 武器具体子类 ---
                window.吸血剑 = 吸血剑;
                window.冰霜法杖 = 冰霜法杖;
                window.重力锤 = 重力锤;
                window.剧毒匕首 = 剧毒匕首;
                window.荆棘鞭 = 荆棘鞭;
                window.回旋镖 = 回旋镖;
                window.闪电链法杖 = 闪电链法杖;
                window.大地猛击锤 = 大地猛击锤;
                window.穿云箭 = 穿云箭;
                window.钢制长剑 = 钢制长剑;
                window.橡木法杖 = 橡木法杖;
                window.金币手枪 = 金币手枪;
                window.喷火枪 = 喷火枪;
                window.引雷针护符 = 引雷针护符;
                window.荆棘种子 = 荆棘种子;
                window.荆棘丛 = 荆棘丛;
                window.能量熔炉 = 能量熔炉;
                window.恐惧魔杖 = 恐惧魔杖;
                window.斜方刀 = 斜方刀;
                window.冲撞牛角 = 冲撞牛角;
                window.护卫种子 = 护卫种子;
                window.护卫植物 = 护卫植物;
                window.远射种子 = 远射种子;
                window.远射植物 = 远射植物;
                window.能量草 = 能量草;
                window.吸能种子 = 吸能种子;
                window.魔法师法杖 = 魔法师法杖;
                window.大师附魔卷轴 = 大师附魔卷轴;
                window.小书魔 = 小书魔;
                window.符文圈 = 符文圈;
                window.调试工具 = 调试工具;
                window.渔网 = 渔网;
                window.渔网陷阱 = 渔网陷阱;
                window.充能魔杖 = 充能魔杖;
                window.魔力远射植物 = 魔力远射植物;
                window.时间卷轴 = 时间卷轴;
                window.潜行靴子 = 潜行靴子;
                window.钩索 = 钩索;
                window.嗜血战斧 = 嗜血战斧;
                window.磨刀石 = 磨刀石;
                window.急救绷带 = 急救绷带;
                window.照明弹 = 照明弹;
                window.毒气瓶 = 毒气瓶;
                window.毒气 = 毒气;
                window.万能钥匙 = 万能钥匙;
                window.陨石法杖 = 陨石法杖;

                // --- 防御装具体子类 ---
                window.秘银锁甲 = 秘银锁甲;
                window.钢制板甲 = 钢制板甲;
                window.灵能盾牌 = 灵能盾牌;
                window.冰盾 = 冰盾;

                // --- 卷轴具体子类 ---
                window.迅捷卷轴 = 迅捷卷轴;
                window.神秘卷轴 = 神秘卷轴;
                window.贪婪卷轴 = 贪婪卷轴;
                window.清净卷轴 = 清净卷轴;
                window.附魔卷轴 = 附魔卷轴;
                window.跃迁卷轴 = 跃迁卷轴;
                window.真言卷轴 = 真言卷轴;
                window.湮灭卷轴 = 湮灭卷轴;
                window.配方卷轴 = 配方卷轴;

                // --- 药水具体子类 ---
                window.治疗药水 = 治疗药水;
                window.能量药水 = 能量药水;
                window.狂暴药水 = 狂暴药水;
                window.神龟药水 = 神龟药水;
                window.隐身药水 = 隐身药水;
                window.透视药水 = 透视药水;

                // --- 棋子具体子类 ---
                window.国际象棋车 = 国际象棋车;
                window.国际象棋马 = 国际象棋马;
                window.国际象棋象 = 国际象棋象;
                window.中国象棋炮 = 中国象棋炮;

                // --- 宠物具体子类 ---
                window.熊猫 = 熊猫;
                window.水母 = 水母;
                window.魔法水晶 = 魔法水晶;

                // --- 怪物子类 ---
                window.大魔法师 = 大魔法师;
                window.腐蚀怪物 = 腐蚀怪物;
                window.盗贼怪物 = 盗贼怪物;
                window.吸能怪物 = 吸能怪物;
                window.剧毒云雾怪物 = 剧毒云雾怪物;
                window.召唤师怪物 = 召唤师怪物;
                window.幽灵仆从 = 幽灵仆从;
                window.萨满怪物 = 萨满怪物;
                window.大史莱姆怪物 = 大史莱姆怪物;
                window.小史莱姆怪物 = 小史莱姆怪物;
                window.瞬移怪物 = 瞬移怪物;
                window.伪装怪物 = 伪装怪物;
                window.炸弹怪物 = 炸弹怪物;
                window.盔甲怪物 = 盔甲怪物;
                window.敏捷怪物 = 敏捷怪物;
                window.远攻怪物 = 远攻怪物;
                window.仙人掌怪物 = 仙人掌怪物;
                window.冰冻怪物 = 冰冻怪物;
                window.旋风怪物 = 旋风怪物;
                window.幽灵怪物 = 幽灵怪物;
                window.旋风 = 旋风;
                window.恐惧怪物 = 恐惧怪物;
                window.米诺陶 = 米诺陶;
            }
           function 获取所有可用的定义() {
                const 所有物品 = [];
                const 所有怪物 = [];
                const 已见物品名 = new Set();
                const 已见怪物类型 = new Set();
            
                const 物品池 = 创建物品池();
                for (const 物品类别 of Object.values(物品池)) {
                    for (const 配置 of 物品类别) {
                        try {
                            const 实例 = new 配置.类({});
                            if (实例.名称 && !已见物品名.has(实例.名称)) {
                                所有物品.push(配置);
                                已见物品名.add(实例.名称);
                            }
                        } catch (错误) {}
                    }
                }
            
                const 怪物池 = 创建怪物池();
                for (const 怪物类别 of Object.values(怪物池)) {
                    for (const 配置 of 怪物类别) {
                        try {
                            const 实例 = new 配置.类({});
                            if (实例.类型 && !已见怪物类型.has(实例.类型)) {
                                所有怪物.push(配置);
                                已见怪物类型.add(实例.类型);
                            }
                        } catch (错误) {}
                    }
                }
            
                const 特殊物品 = [
                    { 类: 渔网陷阱, 品质: 1 }, { 类: 荆棘丛, 品质: 1 },
                    { 类: 火焰物品, 品质: 1 }, { 类: 毒液物品, 品质: 1 },
                    { 类: 旋风物品, 品质: 1 }, { 类: 小书魔, 品质: 4 },
                    { 类: 空罐子, 品质: 1 }, { 类: 护卫植物, 品质: 2 },
                    { 类: 远射植物, 品质: 3 }, { 类: 能量草, 品质: 2 },
                    { 类: 大师附魔卷轴, 品质: 5 }, { 类: 魔力远射植物, 品质: 4 },
                    { 类: 泉水, 品质: 4 }, { 类: 书架, 品质: 2 },
                    { 类: 灵能盾牌, 品质: 3 }, { 类: 配方卷轴, 品质: 2 },
                    { 类: 国际象棋车, 品质: 1 }, { 类: 国际象棋马, 品质: 1 },
                    { 类: 国际象棋象, 品质: 1 }, { 类: 中国象棋炮, 品质: 1 },
                    { 类: 冲撞牛角, 品质: 5 }, { 类: 魔法师法杖, 品质: 5 },
                    { 类: 万能钥匙, 品质: 3 },{ 类: 障碍物物品, 品质: 1 },
            { 类: 已放置的障碍物, 品质: 1 },
            { 类: 隐形落石陷阱, 品质: 2 },
            { 类: 隐形地刺陷阱, 品质: 2 },
            { 类: 隐形毒气陷阱, 品质: 2 },
            { 类: 隐形失明陷阱, 品质: 3 },
            { 类: 召唤怪物陷阱, 品质: 3 },
            { 类: 烈焰触发陷阱, 品质: 4 },
            { 类: 隐形虫洞陷阱, 品质: 4 },
                ];
            
                for (const 配置 of 特殊物品) {
                    try {
                        const 实例 = new 配置.类({});
                        if (实例.名称 && !已见物品名.has(实例.名称)) {
                            所有物品.push(配置);
                            已见物品名.add(实例.名称);
                        }
                    } catch (错误) {}
                }
            
                const 特殊怪物 = [
                    { 类: 大魔法师, 品质: 5 }, { 类: 米诺陶, 品质: 5 },
                    { 类: 小史莱姆怪物, 品质: 1 }, { 类: 幽灵仆从, 品质: 1 },
                    { 类: 旋风, 品质: 1 }, { 类: 幽灵怪物, 品质: 2 }
                ];
            
                for (const 配置 of 特殊怪物) {
                    try {
                        const 实例 = new 配置.类({});
                        if (实例.类型 && !已见怪物类型.has(实例.类型)) {
                            所有怪物.push(配置);
                            已见怪物类型.add(实例.类型);
                        }
                    } catch (错误) {}
                }
            
                return { items: 所有物品, monsters: 所有怪物 };
            }

            function 处理地图点击(e) {
                e.preventDefault();
                const touch = e.touches[0];
                处理点击(touch.clientX, touch.clientY);
            }

            function 处理地图单击(e) {
                处理点击(e.clientX, e.clientY);
            }

            //来源对象需要提供应用效果与移除效果（可选）函数
            class 状态效果 {
                constructor(
                    类型,
                    颜色,
                    图标,
                    持续时间,
                    剩余回合 = null,
                    来源 = null,
                    关联怪物 = null,
                    强度 = 1
                ) {
                    this.类型 = 类型;
                    this.剩余回合 = 剩余回合 || 持续时间;
                    this.来源 = 来源;
                    this.持续时间 = 持续时间;
                    this.关联怪物 = 关联怪物;
                    this.颜色 = 颜色;
                    this.图标 = 图标;
                    this.强度 = 强度;

                    if (!this.关联怪物) {
                        const 现有效果 = 玩家状态.find(
                            (item) => item.类型 === this.类型
                        );
                        if (现有效果) {
                            现有效果.剩余回合 = Math.max(
                                现有效果.剩余回合,
                                this.剩余回合
                            );
                            现有效果.强度 = Math.min(
                                5,
                                (现有效果.强度 || 1) + (this.强度 || 1)
                            );
                            现有效果.持续时间 = Math.max(
                                现有效果.持续时间,
                                this.持续时间
                            );
                            现有效果.进度条实例?.更新({
                                数值:
                                    (现有效果.剩余回合 / 现有效果.持续时间) *
                                    100,
                                标签:
                                    `${现有效果.类型} ${现有效果.剩余回合}回合` +
                                    (现有效果.强度 > 1
                                        ? ` (强度 ${现有效果.强度})`
                                        : ""),
                            });
                            return;
                        }

                        玩家状态.push(this);
                        this.进度条实例 = new 进度条元素({
                            图标: 图标,
                            颜色: 颜色,
                            初始值: 100,
                            标签:
                                `${this.类型} ${this.剩余回合}回合` +
                                (this.强度 > 1 ? ` (强度 ${this.强度})` : ""),
                        });
                        this.来源?.应用效果();
                    } else {
                        const 现有怪物效果 = 怪物状态表.get(this.关联怪物);
                        if (现有怪物效果 && 现有怪物效果.类型 === this.类型) {
                            现有怪物效果.剩余回合 = Math.max(
                                现有怪物效果.剩余回合,
                                this.剩余回合
                            );
                            现有怪物效果.强度 = Math.min(
                                5,
                                (现有怪物效果.强度 || 1) + (this.强度 || 1)
                            );
                            this.关联怪物.获得效果(现有怪物效果);
                            this.更新状态();
                            this.剩余回合++;
                            return;
                        }
                        怪物状态表.set(this.关联怪物, this);
                        this.关联怪物.获得效果(this);
                    }
                }
                更新状态() {
                    let 剩余回合 = this.剩余回合;
                    剩余回合 = Math.max(0, 剩余回合 - 1);
                    this.剩余回合 = 剩余回合;

                    if (this.类型 === "中毒" && !this.关联怪物) {
                        伤害玩家(this.强度 || 1, "中毒");
                        添加日志(`你受到 ${this.强度 || 1} 点中毒伤害`, "错误");
                    }
                    if (this.类型 === "火焰" && !this.关联怪物) {
                        伤害玩家(this.强度 || 1, "火焰"); // 使用强度作为伤害
                        添加日志(
                            `你被火焰灼烧，受到 ${this.强度 || 1} 点伤害`,
                            "错误"
                        );
                    }
                    if (
                        this.类型 === "冻结" &&
                        玩家状态.some((s) => s.类型 === "火焰")
                    ) {
                        this.剩余回合--;
                    }
                    if (!this.关联怪物) {
                        const 百分比 = (剩余回合 / this.持续时间) * 100;
                        this.进度条实例?.更新({
                            数值: 百分比,
                            标签:
                                `${this.类型} ${剩余回合}回合` +
                                (this.强度 > 1 ? ` (强度 ${this.强度})` : ""),
                        });
                    }

                    if (剩余回合 === 0) {
                        this.移除状态();
                    } else {
                        this.来源?.应用效果();
                    }
                }
                移除状态() {
                    this.来源?.移除效果();

                    if (!this.关联怪物) {
                        玩家状态 = 玩家状态.filter((item) => item !== this);
                    } else {
                        if (怪物状态表.get(this.关联怪物) === this) {
                            怪物状态表.delete(this.关联怪物);
                        }
                    }
                    if (this.进度条实例) {
                        this.进度条实例.销毁();
                        this.进度条实例 = null;
                    }
                    return;
                }
            }

            //处理canvas的点击
            function 处理点击(clientX, clientY) {
                if (游戏状态 !== "游戏中" && 游戏状态 !== "图鉴") return;
                
                if (界面可见性.背包) {
                    切换背包显示();
                    document.getElementById("浮动提示框").style.display =
                        "none";
                    return;
                } else if (教程提示已显示) {
                    关闭教程提示();
                    return;
                } else if (
                    document
                        .getElementById("设置菜单")
                        .classList.contains("显示")
                ) {
                    切换设置菜单();
                    return;
                } else if (
                    document.getElementById("教程回放窗口").style.display ===
                    "block"
                ) {
                    关闭教程回放窗口();
                    return;
                }
                if (玩家正在放置障碍物) {
                    const rect = canvas.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const y = clientY - rect.top;
                    const gridX = 视口偏移X + Math.floor(x / 单元格大小);
                    const gridY = 视口偏移Y + Math.floor(y / 单元格大小);
                    
                    if (位置是否可用(gridX, gridY)) {
                        const 障碍物实例 = new 已放置的障碍物({});
                        if (放置物品到单元格(障碍物实例, gridX, gridY)) {
                            显示通知("成功放置障碍物！", "成功");
                            const 物品源 = [...玩家背包.values()].find(i => i instanceof 障碍物物品);
                            if (物品源) {
                                物品源.堆叠数量--;
                                if(物品源.堆叠数量 <= 0) {
                                    处理销毁物品(物品源.唯一标识, true);
                                }
                                更新背包显示();
                                更新装备显示();
                            }
                        } else {
                            显示通知("无法在此处放置障碍物！", "错误");
                        }
                    } else {
                        显示通知("无法在此处放置障碍物！", "错误");
                    }
                    玩家正在放置障碍物 = false;
                    return;
                }
                const rect = canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                const gridX = 视口偏移X + Math.floor(x / 单元格大小);
                const gridY = 视口偏移Y + Math.floor(y / 单元格大小);

                const 全路径 = 广度优先搜索路径(
                    玩家.x,
                    玩家.y,
                    gridX,
                    gridY,
                    30,
                    true
                );
                const 截断路径 = [];
                for (const 节点 of 全路径) {
                    const 房间ID = 房间地图[节点.y][节点.x];
                    // 记录进入未探索房间的第一个格子
                    if (房间ID !== -1 && !已访问房间.has(房间ID)) {
                        截断路径.push(节点);
                        break;
                    }
                    截断路径.push(节点);
                }
                截断路径.shift();
                if (截断路径.length > 0) {
                    moveQueue = 截断路径;
                    startAutoMove();
                }
            }

            class 门 {
                constructor(配置) {
                    this.唯一标识 = Symbol(
                        Date.now().toString() + Math.random().toString()
                    );
                    this.类型 = "门"; //常驻类型
                    this.是否上锁 = false;
                    this.房间ID = 配置.关联房间ID;
                    this.所在位置 = 配置.位置; // {x, y}

                    // 自动注册到全局列表
                    门实例列表.set(this.唯一标识, this); // 注册逻辑
                }

                尝试解锁(玩家背包) {
                    return [...玩家背包.values()].some((item) =>
                        item.可交互目标(this)
                    );
                }
            }

            class 怪物 {
                constructor(配置 = {}) {
                    this.房间ID =
                        配置.房间ID === undefined ? null : 配置.房间ID;
                    this.x = 配置.x === undefined ? null : 配置.x;
                    this.y = 配置.y === undefined ? null : 配置.y;
                    this.目标路径 = [];
                    this.状态 = 配置.状态 || 怪物状态.休眠;
                    this.基础生命值 = 配置.基础生命值 || 23;
                    this.基础攻击力 = 配置.基础攻击力 || 3;
                    this.移动率 = 配置.移动率 || 0.7;
                    this.图标 = 配置.图标 || 图标映射.怪物; //图标即名称
                    this.类型 = 配置.类型 || "怪物";
                    this.掉落物 =
                        配置.掉落物 ||
                        new 金币({ 数量: Math.floor(Math.random() * 5) + 1 });
                    (this.掉落概率 = 配置.掉落概率 ?? 1),
                        (this.血条元素 = null);
                    this.受击动画 = false;
                    this.基础攻击范围 = 配置.基础攻击范围 || 1;
                    this.受伤冻结回合 = 配置.受伤冻结回合 || 1;
                    this.基础移动距离 = 配置.基础移动距离 || 1;

                    this.跟踪距离 = 配置.跟踪距离 || 15;
                    this.基础颜色 = 配置.颜色 || "#FFFFFF";
                    this.强化 = 配置.强化 || false;

                    this.当前生命值 = 配置.当前生命值 || this.生命值; //我觉得没有人会想要生成一只残血的怪物 //冰冻怪物：你好，有的
                    this.攻击冷却 = 配置.攻击冷却 || 0;
                    this.受伤冻结回合剩余 = 0;
                    this.攻击冷却回合剩余 = 0;
                    this.当前格 = 配置.当前格 ?? null;
                    if (
                        this.房间ID === null &&
                        this.y !== null &&
                        this.x !== null
                    ) {
                        this.房间ID = 房间地图[this.y][this.x];
                    }
                    this.仇恨 = null;
                }
                尝试添加随机词条到掉落物(物品实例) {
                    if (
                        !(
                            物品实例 instanceof 武器类 ||
                            物品实例 instanceof 防御装备类
                        )
                    ) {
                        return;
                    }
                    if (!物品实例.自定义数据) {
                        物品实例.自定义数据 = new Map();
                    }
                    let 现有词条 = 物品实例.自定义数据.get("fusedBuffs") || [];
                    const 最大词条数 =
                        1 +
                        Math.floor(Math.random() * 2) *
                            (玩家属性.掉落倍率 > 1 ? 2 : 1);
                    let 添加词条数 = 0;

                    const 通用词条池 = [
                        融合Buff类型.耐久加成,
                        融合Buff类型.耐久倍率,
                    ];
                    const 武器词条池 = [
                        融合Buff类型.攻击加成,
                        融合Buff类型.攻击倍率,
                        融合Buff类型.冷却缩减,
                        融合Buff类型.冷却倍率,
                        融合Buff类型.范围加成,
                        融合Buff类型.中毒几率,
                        融合Buff类型.火焰伤害,
                        融合Buff类型.冰冻几率,
                        融合Buff类型.生命偷取,
                        融合Buff类型.暴击几率,
                        融合Buff类型.暴击伤害倍率,
                        融合Buff类型.击退几率,
                        融合Buff类型.攻击吸能,
                        融合Buff类型.幸运一击,
                    ];
                    const 防具词条池 = [
                        融合Buff类型.防御加成,
                        融合Buff类型.防御倍率,
                        融合Buff类型.闪避几率,
                        融合Buff类型.固定伤害减免,
                        融合Buff类型.受击回能,
                        融合Buff类型.中毒几率,
                    ];

                    let 适用的额外词条池 = [];
                    if (物品实例 instanceof 武器类) {
                        适用的额外词条池 = [...武器词条池];
                    } else if (物品实例 instanceof 防御装备类) {
                        适用的额外词条池 = [...防具词条池];
                    }

                    const 最终词条池 = [...通用词条池, ...适用的额外词条池];
                    if (最终词条池.length === 0) return;

                    for (let i = 0; i < 5 && 添加词条数 < 最大词条数; i++) {
                        if (最终词条池.length === 0) break;
                        const 随机词条类型 =
                            最终词条池[
                                Math.floor(Math.random() * 最终词条池.length)
                            ];
                        let 词条数值 = 0;
                        let 数值系数 = 0.2 + Math.random() * 0.4;
                        if (玩家属性.掉落倍率 > 1)
                            数值系数 *= 1 + (玩家属性.掉落倍率 - 1) * 0.5;

                        switch (随机词条类型) {
                            case 融合Buff类型.攻击加成:
                                词条数值 = Math.round(
                                    (1 + Math.random() * 1) * 数值系数
                                );
                                break;
                            case 融合Buff类型.攻击倍率:
                                词条数值 = Math.min(
                                    0.15,
                                    (0.02 + Math.random() * 0.05) * 数值系数
                                );
                                break;
                            case 融合Buff类型.耐久加成:
                                词条数值 = Math.round(
                                    (3 + Math.random() * 7) * 数值系数
                                );
                                break;
                            case 融合Buff类型.耐久倍率:
                                词条数值 = Math.min(
                                    0.3,
                                    (0.05 + Math.random() * 0.1) * 数值系数
                                );
                                break;
                            case 融合Buff类型.范围加成:
                                if (
                                    物品实例 instanceof 武器类 &&
                                    物品实例.自定义数据.has("攻击范围") &&
                                    物品实例.自定义数据.get("攻击范围") > 1 &&
                                    Math.random() < 0.5
                                )
                                    词条数值 = Math.round(1 * 数值系数);
                                break;
                            case 融合Buff类型.冷却缩减:
                                if (
                                    物品实例 instanceof 武器类 &&
                                    物品实例.自定义数据.has("冷却回合") &&
                                    物品实例.自定义数据.get("冷却回合") > 0 &&
                                    Math.random() < 0.5
                                )
                                    词条数值 = Math.round(1 * 数值系数);
                                break;
                            case 融合Buff类型.冷却倍率:
                                if (
                                    物品实例 instanceof 武器类 &&
                                    物品实例.自定义数据.has("冷却回合") &&
                                    物品实例.自定义数据.get("冷却回合") > 0 &&
                                    Math.random() < 0.5
                                )
                                    词条数值 = Math.min(
                                        0.25,
                                        (0.03 + Math.random() * 0.08) * 数值系数
                                    );
                                break;
                            case 融合Buff类型.防御加成:
                                词条数值 = Math.round(
                                    (1 + Math.random() * 0.5) * 数值系数
                                );
                                break;
                            case 融合Buff类型.防御倍率:
                                词条数值 = Math.min(
                                    0.15,
                                    (0.02 + Math.random() * 0.05) * 数值系数
                                );
                                break;
                            case 融合Buff类型.固定伤害减免:
                                词条数值 = Math.round(
                                    Math.random() * 1 * 数值系数
                                );
                                break;
                            case 融合Buff类型.受击回能:
                                词条数值 = Math.round(
                                    (1 + Math.random() * 3) * 数值系数
                                );
                                break;
                            case 融合Buff类型.中毒几率:
                            case 融合Buff类型.冰冻几率:
                            case 融合Buff类型.生命偷取:
                            case 融合Buff类型.击退几率:
                            case 融合Buff类型.攻击吸能:
                            case 融合Buff类型.火焰伤害:
                            case 融合Buff类型.闪避几率:
                                词条数值 = Math.min(
                                    0.2,
                                    (0.03 + Math.random() * 0.1) * 数值系数
                                );
                                break;
                            case 融合Buff类型.暴击几率:
                                词条数值 = Math.min(
                                    0.1,
                                    (0.01 + Math.random() * 0.05) * 数值系数
                                );
                                break;
                            case 融合Buff类型.暴击伤害倍率:
                                词条数值 = Math.min(
                                    0.5,
                                    (0.05 + Math.random() * 0.2) * 数值系数
                                );
                                break;
                            case 融合Buff类型.幸运一击:
                                词条数值 = Math.min(
                                    0.08,
                                    (0.01 + Math.random() * 0.03) * 数值系数
                                );
                                break;
                        }

                        if (词条数值 > 0 && 随机词条类型) {
                            const 已有同类词条 = 现有词条.find(
                                (b) => b.type === 随机词条类型
                            );
                            if (已有同类词条) {
                                if (
                                    typeof 已有同类词条.value === "number" &&
                                    typeof 词条数值 === "number"
                                ) {
                                    已有同类词条.value += 词条数值;

                                    let 上限 = 1.0;
                                    if (
                                        随机词条类型.includes("MULTIPLIER") ||
                                        随机词条类型.includes("CHANCE") ||
                                        随机词条类型.includes("STEAL") ||
                                        随机词条类型.includes("PERCENT")
                                    ) {
                                        上限 =
                                            {
                                                [融合Buff类型.攻击倍率]: 0.3,
                                                [融合Buff类型.冷却倍率]: 0.5,
                                                [融合Buff类型.耐久倍率]: 0.75,
                                                [融合Buff类型.防御倍率]: 0.3,
                                                [融合Buff类型.中毒几率]: 0.4,
                                                [融合Buff类型.冰冻几率]: 0.4,
                                                [融合Buff类型.生命偷取]: 0.3,
                                                [融合Buff类型.击退几率]: 0.4,
                                                [融合Buff类型.攻击吸能]: 0.3,
                                                [融合Buff类型.火焰伤害]: 0.4,
                                                [融合Buff类型.闪避几率]: 0.3,
                                                [融合Buff类型.暴击几率]: 0.2,
                                                [融合Buff类型.暴击伤害倍率]: 1.0,
                                                [融合Buff类型.幸运一击]: 0.15,
                                            }[随机词条类型] || 1.0;
                                        已有同类词条.value = Math.min(
                                            已有同类词条.value,
                                            上限
                                        );
                                    } else if (
                                        随机词条类型 === 融合Buff类型.冷却缩减
                                    ) {
                                        const 武器基础冷却 =
                                            物品实例.自定义数据.get(
                                                "冷却回合"
                                            ) || 1;
                                        上限 =
                                            武器基础冷却 > 0
                                                ? 武器基础冷却 - 1
                                                : 0;
                                        已有同类词条.value = Math.max(
                                            0,
                                            Math.min(已有同类词条.value, 上限)
                                        );
                                        上限 = 99999;
                                    } else if (
                                        随机词条类型 ===
                                        融合Buff类型.固定伤害减免
                                    ) {
                                        上限 = 3;
                                        已有同类词条.value = Math.min(
                                            已有同类词条.value,
                                            上限
                                        );
                                    } else if (
                                        随机词条类型 === 融合Buff类型.受击回能
                                    ) {
                                        上限 = 10;
                                        已有同类词条.value = Math.min(
                                            已有同类词条.value,
                                            上限
                                        );
                                    } else if (
                                        随机词条类型 ===
                                            融合Buff类型.范围加成 &&
                                        物品实例.自定义数据.has("攻击范围")
                                    ) {
                                        上限 = Math.floor(
                                            物品实例.自定义数据.get(
                                                "攻击范围"
                                            ) * 0.3
                                        );
                                        已有同类词条.value = Math.min(
                                            已有同类词条.value,
                                            上限
                                        );
                                    } else if (随机词条类型.includes("加成")) {
                                        已有同类词条.value = Math.min(
                                            已有同类词条.value,
                                            5
                                        );
                                    }
                                }
                            } else {
                                现有词条.push({
                                    type: 随机词条类型,
                                    value: 词条数值,
                                });
                            }
                            添加词条数++;

                            const 移除索引 = 最终词条池.indexOf(随机词条类型);
                            if (移除索引 > -1) {
                                最终词条池.splice(移除索引, 1);
                            }
                        }
                    }
                    if (现有词条.length > 0) {
                        物品实例.自定义数据.set("fusedBuffs", 现有词条);
                    }
                }
                计算路径(目标X, 目标Y) {
                    this.目标 = { x: 目标X, y: 目标Y };
                    const 目标距离 = Math.floor(this.攻击范围 / 2);
                    const 玩家距离图 = this.生成玩家距离图(目标X, 目标Y);

                    if (玩家距离图[this.y][this.x] === 目标距离) {
                        跟踪玩家怪物数++;
                        return [];
                    }

                    const 开放列表 = [];
                    const 关闭列表 = new Set();
                    const 方向映射表 = [
                        { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                        { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                        { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                        { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
                    ];

                    const 起点节点 = {
                        x: this.x,
                        y: this.y,
                        g: 0,
                        parent: null,
                    };
                    开放列表.push(起点节点);
                    关闭列表.add(`${起点节点.x},${起点节点.y}`);

                    while (开放列表.length > 0) {
                        let 当前节点 = 开放列表.shift();
                        if (玩家距离图[当前节点.y][当前节点.x] === 目标距离) {
                            const 路径 = [];
                            let 节点 = 当前节点;
                            while (节点.parent) {
                                路径.push(节点);
                                节点 = 节点.parent;
                            }
                            return 路径.reverse();
                        }

                        方向映射表.forEach((方向) => {
                            const 新X = 当前节点.x + 方向.dx;
                            const 新Y = 当前节点.y + 方向.dy;

                            if (
                                新X < 0 ||
                                新X >= 地牢大小 ||
                                新Y < 0 ||
                                新Y >= 地牢大小
                            )
                                return;

                            const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                            const 目标单元格 = 地牢[新Y][新X];

                            if (
                                当前单元格.墙壁[方向.当前墙] ||
                                目标单元格.墙壁[方向.目标墙] ||
                                目标单元格.背景类型 === 单元格类型.墙壁 ||
                                目标单元格.背景类型 === 单元格类型.上锁的门 ||
                                开放列表.length > this.跟踪距离
                            )
                                return;

                            const 移动方向 = getMoveDirection(
                                当前节点.x,
                                当前节点.y,
                                新X,
                                新Y
                            );
                            if (
                                目标单元格.isOneWay &&
                                移动方向 !== 目标单元格.oneWayAllowedDirection
                            )
                                return;

                            const 位置键 = `${新X},${新Y}`;
                            if (!关闭列表.has(位置键)) {
                                关闭列表.add(位置键);
                                开放列表.push({
                                    x: 新X,
                                    y: 新Y,
                                    g: 当前节点.g + 1,
                                    parent: 当前节点,
                                });
                            }
                        });
                    }
                    return [];
                }

                // 生成玩家实际路径距离图?什么是效率问题,我不懂
                生成玩家距离图(玩家X, 玩家Y) {
                    const 距离图 = Array.from({ length: 地牢大小 }, () =>
                        Array(地牢大小).fill(Infinity)
                    );
                    const 队列 = [];
                    const 方向映射表 = [
                        { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                        { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                        { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                        { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
                    ];

                    // 初始化玩家起始位置
                    距离图[玩家Y][玩家X] = 0;
                    队列.push({ x: 玩家X, y: 玩家Y });

                    while (队列.length > 0) {
                        const 当前 = 队列.shift();

                        方向映射表.forEach((方向) => {
                            const 新X = 当前.x + 方向.dx;
                            const 新Y = 当前.y + 方向.dy;

                            if (
                                新X < 0 ||
                                新X >= 地牢大小 ||
                                新Y < 0 ||
                                新Y >= 地牢大小
                            )
                                return;

                            const 当前单元格 = 地牢[当前.y][当前.x];
                            const 目标单元格 = 地牢[新Y][新X];

                            // 使用与怪物相同的移动规则
                            if (
                                当前单元格.墙壁[方向.当前墙] ||
                                目标单元格.墙壁[方向.目标墙] ||
                                目标单元格.背景类型 === 单元格类型.墙壁 ||
                                目标单元格.背景类型 === 单元格类型.上锁的门
                            )
                                return;

                            // 找到更短路径
                            if (距离图[新Y][新X] > 距离图[当前.y][当前.x] + 1) {
                                距离图[新Y][新X] = 距离图[当前.y][当前.x] + 1;
                                队列.push({ x: 新X, y: 新Y });
                            }
                        });
                    }

                    return 距离图;
                }
                计算目标路径(目标X, 目标Y) {
                    const 开放列表 = [];
                    const 关闭列表 = new Set();
                    const 方向映射表 = [
                        {
                            dx: 1,
                            dy: 0,
                            当前墙: "右",
                            目标墙: "左",
                        },
                        {
                            dx: -1,
                            dy: 0,
                            当前墙: "左",
                            目标墙: "右",
                        },
                        {
                            dx: 0,
                            dy: 1,
                            当前墙: "下",
                            目标墙: "上",
                        },
                        {
                            dx: 0,
                            dy: -1,
                            当前墙: "上",
                            目标墙: "下",
                        },
                    ];

                    const 起点节点 = {
                        x: this.x,
                        y: this.y,
                        g: 0,
                        parent: null,
                    };
                    开放列表.push(起点节点);

                    while (开放列表.length > 0) {
                        let 当前节点 = 开放列表.shift();

                        if (当前节点.x === 目标X && 当前节点.y === 目标Y) {
                            const 路径 = [];
                            while (当前节点.parent) {
                                路径.push(当前节点);
                                当前节点 = 当前节点.parent;
                            }
                            return 路径.reverse();
                        }

                        方向映射表.forEach((方向) => {
                            const 新X = 当前节点.x + 方向.dx;
                            const 新Y = 当前节点.y + 方向.dy;
                            if (
                                新X < 0 ||
                                新X >= 地牢大小 ||
                                新Y < 0 ||
                                新Y >= 地牢大小
                            )
                                return;
                            const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                            const 目标单元格 = 地牢[新Y][新X];
                            const 当前墙阻挡 = 当前单元格.墙壁[方向.当前墙];
                            const 目标墙阻挡 = 目标单元格.墙壁[方向.目标墙];
                            const 硬阻挡 =
                                目标单元格.背景类型 === 单元格类型.墙壁 ||
                                目标单元格.背景类型 === 单元格类型.上锁的门;

                            if (
                                当前墙阻挡 ||
                                目标墙阻挡 ||
                                硬阻挡 ||
                                开放列表.length > this.跟踪距离
                            )
                                return;

                            const 移动方向 = getMoveDirection(
                                当前节点.x,
                                当前节点.y,
                                新X,
                                新Y
                            );
                            if (
                                目标单元格.isOneWay &&
                                移动方向 !== 目标单元格.oneWayAllowedDirection
                            )
                                return;

                            const 位置键 = `${新X},${新Y}`;
                            if (!关闭列表.has(位置键)) {
                                开放列表.push({
                                    x: 新X,
                                    y: 新Y,
                                    g: 当前节点.g + 1,
                                    parent: 当前节点,
                                });
                                关闭列表.add(位置键);
                            }
                        });
                    }
                    return null;
                }
                选择目标() {
                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        return this.寻找最近怪物目标();
                    }
                    if (this.仇恨 instanceof 怪物) {
                        return { x: this.仇恨.x, y: this.仇恨.y };
                    }
                    return { x: 玩家.x, y: 玩家.y }; // 默认目标为玩家
                }

                寻找最近怪物目标() {
                    let 最近距离 = Infinity;
                    let 最近目标 = null;

                    所有怪物.forEach((其他怪物) => {
                        if (
                            其他怪物 === this ||
                            其他怪物.当前生命值 <= 0 ||
                            其他怪物.状态 === 怪物状态.休眠 ||
                            ["冻结", "魅惑"].includes(
                                怪物状态表.get(其他怪物)?.类型
                            ) ||
                            其他怪物 instanceof 大魔法师
                        )
                            return;

                        const 距离 =
                            Math.abs(this.x - 其他怪物.x) +
                            Math.abs(this.y - 其他怪物.y);
                        if (
                            距离 < 最近距离 &&
                            检查视线(this.x, this.y, 其他怪物.x, 其他怪物.y)
                        ) {
                            最近距离 = 距离;
                            最近目标 = 其他怪物;
                        }
                    });
                    this.魅惑目标怪物 = 最近目标;
                    return 最近目标
                        ? { x: 最近目标.x, y: 最近目标.y }
                        : { x: this.x, y: this.y };
                }

                尝试移动() {
                    let 移动率 = this.移动率;
                    const 我的状态 = 怪物状态表.get(this);
                    switch (我的状态?.类型) {
                        case "冻结":
                            if (!当前天气效果.includes("严寒")) return;
                        case "火焰":
                            this.受伤(3, "火焰");
                            this.受伤冻结回合剩余 = 0;
                            break;
                        case "魅惑":
                            移动率 = 1;
                            break;
                        case "缓慢":
                            移动率 = 0.5;
                            break;
                        case "中毒":
                            this.受伤(我的状态.强度 || 1, "中毒");
                            this.受伤冻结回合剩余 = 0;
                            break;
                        case "恐惧":
                            this.逃离目标 = { x: 玩家.x, y: 玩家.y };
                            const 逃离点 = this.选择逃离目标(
                                玩家.x,
                                玩家.y,
                                this.跟踪距离
                            );
                            if (逃离点) {
                                this.目标路径 = this.计算路径(
                                    逃离点.x,
                                    逃离点.y
                                );
                            } else {
                                this.目标路径 = [];
                            }
                            break;
                        case "牵制":
                            return;
                    }
                    if (this.当前生命值 <= 0) return;
                    if (房间地图[玩家.y][玩家.x] === 0) return;
                    if (this.受伤冻结回合剩余 > 0) {
                        this.受伤冻结回合剩余 -= 1;
                    } else {
                        if (
                            this.跟踪距离 >= this.目标路径.length &&
                            怪物状态表.get(this)?.类型 !== "魅惑"
                        ) {
                            跟踪玩家怪物数++;
                        }
                        if (
                            this.目标路径.length === 0 ||
                            (Math.random() > 移动率 && !切换动画) ||
                            this.跟踪距离 < this.目标路径.length
                        ) {
                            this.追击玩家中 = false;
                            return;
                        }
                        //this.目标路径 = this.计算路径(this.目标.x,this.目标.y);
                        // 获取下一个移动方向
                        const 旧X = this.x;
                        const 旧Y = this.y;
                        const 下一步 =
                            this.目标路径[
                                Math.min(
                                    this.移动距离 - 1,
                                    this.目标路径.length - 1
                                )
                            ];
                        let 最终位置 = null;
                        if (下一步) {
                            const dx = 下一步.x - this.x;
                            const dy = 下一步.y - this.y;
                            最终位置 = this.规划移动路径(dx, dy);
                        }

                        if (最终位置) {
                            const 目标单元格实例 =
                                地牢[最终位置.y]?.[最终位置.x];
                            if (
                                目标单元格实例 &&
                                目标单元格实例.关联物品 instanceof 罐子 &&
                                !目标单元格实例.关联物品.自定义数据.get(
                                    "已破碎"
                                )
                            ) {
                                const 罐子要碎了 = 目标单元格实例.关联物品;
                                罐子要碎了.破碎并释放内容(this);

                                if (
                                    地牢[最终位置.y]?.[最终位置.x]?.关联怪物 &&
                                    地牢[最终位置.y][最终位置.x].关联怪物 !==
                                        this
                                ) {
                                    if (this.接受萨满治疗) {
                                        计划显示格子特效(
                                            [{ x: this.x, y: this.y }],
                                            "00FF00",
                                            0
                                        );
                                        this.接受萨满治疗 = false;
                                    }
                                    this.绘制血条();
                                    return;
                                }
                            }
                            if (
                                this instanceof 大魔法师 &&
                                房间地图[最终位置.y][最终位置.x] === -1
                            ) {
                                if (this.接受萨满治疗) {
                                    计划显示格子特效(
                                        [{ x: this.x, y: this.y }],
                                        "00FF00",
                                        0
                                    );
                                    this.接受萨满治疗 = false;
                                }
                                this.绘制血条();
                                return;
                            }

                            this.恢复背景类型();
                            this.保存新位置类型(最终位置.x, 最终位置.y);
                            this.x = 最终位置.x;
                            this.y = 最终位置.y;
                            地牢[this.y][this.x].类型 = 单元格类型.怪物;
                            地牢[this.y][this.x].关联怪物 = this;
                            this.处理地形效果();
                            怪物动画状态.set(this, {
                                旧逻辑X: 旧X,
                                旧逻辑Y: 旧Y,
                                目标逻辑X: this.x,
                                目标逻辑Y: this.y,
                                视觉X: 旧X,
                                视觉Y: 旧Y,
                                动画开始时间: Date.now(),
                                正在动画: true,
                            });
                        }
                    }
                    if (this.接受萨满治疗) {
                        计划显示格子特效(
                            [{ x: this.x, y: this.y }],
                            "00FF00",
                            0
                        );
                        this.接受萨满治疗 = false;
                    }
                    this.绘制血条();
                }
                处理地形效果() {
                    if (地牢[this.y][this.x]?.关联物品 instanceof 火焰物品) {
                        const 火焰实例移动后 = 地牢[this.y][this.x].关联物品;
                        const 强度移动后 =
                            火焰实例移动后.自定义数据.get("火焰强度") ?? 1;
                        const 持续移动后 =
                            火焰实例移动后.自定义数据.get("火焰持续") ?? 3;
                        new 状态效果(
                            "火焰",
                            效果颜色编号映射[效果名称编号映射.火焰],
                            "火",
                            持续移动后,
                            null,
                            null,
                            this,
                            强度移动后
                        );
                        添加日志(`${this.类型} 踩到了火焰，着火了！`, "警告");
                    } else if (
                        地牢[this.y][this.x]?.关联物品 instanceof 荆棘丛
                    ) {
                        const 伤害量 =
                            地牢[this.y][this.x]?.关联物品?.自定义数据.get(
                                "伤害"
                            );
                        this.受伤(伤害量, "荆棘丛"); // 受到伤害
                        添加日志(
                            `${this.类型} 踩进了荆棘丛，受到 ${伤害量} 点伤害！`,
                            "警告"
                        );
                        地牢[this.y][this.x].关联物品.发挥效果 = true;
                        if (
                            Math.random() <
                            地牢[this.y][this.x]?.关联物品?.自定义数据.get(
                                "减速概率"
                            )
                        ) {
                            new 状态效果(
                                "缓慢",
                                效果颜色编号映射[效果名称编号映射.缓慢],
                                "慢",
                                地牢[this.y][this.x]?.关联物品?.自定义数据.get(
                                    "减速回合"
                                ),
                                null,
                                null,
                                this,
                                1
                            );
                            添加日志(
                                `${this.类型} 被荆棘缠绕，移动变慢了！`,
                                "警告"
                            );
                        }
                    } else if (地牢[this.y][this.x]?.关联物品) {
                        地牢[this.y][this.x]?.关联物品?.当被收集(this);
                    }
                }
                规划移动路径() {
                    let 当前位置 = { x: this.x, y: this.y };
                    let 有效位置 = null;
                    let 可行距离 = this.移动距离 + 1;
                    for (
                        let i = 0;
                        i < Math.min(this.目标路径.length, 可行距离);
                        i++
                    ) {
                        const 节点 = this.目标路径[i];

                        const nextX = 节点.x;
                        const nextY = 节点.y;
                        if (地牢[nextY][nextX].类型 === 单元格类型.怪物) {
                            可行距离 = this.移动距离 + 1; //防止怪物团结一心变身 Bolt
                        }
                        if (
                            this.检查移动可行性(
                                当前位置.x,
                                当前位置.y,
                                nextX,
                                nextY
                            )
                        ) {
                            if (this.位置合法(nextX, nextY)) {
                                有效位置 = { x: nextX, y: nextY };
                            }
                        } else {
                            this.目标路径 = this.目标路径.slice(i);
                            return 当前位置;
                        }
                        当前位置 = { x: nextX, y: nextY };

                        if (
                            有效位置 &&
                            i >=
                                Math.min(this.移动距离, this.目标路径.length) -
                                    1
                        ) {
                            this.目标路径 = this.目标路径.slice(i);
                            return 有效位置;
                        }
                    }
                    return 有效位置;
                }

                检查移动可行性(fromX, fromY, toX, toY) {
                    const dx = toX - fromX;
                    const dy = toY - fromY;
                    const steps = Math.max(Math.abs(dx), Math.abs(dy));
                    const xStep = dx / steps;
                    const yStep = dy / steps;

                    let currentX = fromX;
                    let currentY = fromY;

                    for (let i = 0; i <= steps; i++) {
                        const x = Math.round(currentX);
                        const y = Math.round(currentY);

                        if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
                            return false;

                        if (i > 0) {
                            const prevX = Math.round(currentX - xStep);
                            const prevY = Math.round(currentY - yStep);
                            const 移动方向 = 获取移动方向(prevX, prevY, x, y);

                            const 当前单元格 = 地牢[y][x];
                            const 前单元格 = 地牢[prevY][prevX];

                            if (
                                当前单元格.墙壁[移动方向.反方向墙] ||
                                前单元格.墙壁[移动方向.当前墙]
                            ) {
                                return false;
                            }
                        }

                        if (x === toX && y === toY) break;

                        currentX += xStep;
                        currentY += yStep;
                    }
                    return true;
                }
                位置合法(x, y) {
                    if (
                        地牢[y][x].类型 === 单元格类型.物品 &&
                        地牢[y][x].关联物品?.阻碍怪物
                    ) {
                        return false;
                    }
                    if (
                        房间地图[y][x] !== -1 &&
                        !已访问房间.has(房间地图[y][x])
                    ) {
                        return false;
                    }
                    const 怪物所在房间 =
                        房间地图[this.y]?.[this.x] !== -1
                            ? 房间列表[房间地图[this.y][this.x]]
                            : null;
                    if (
                        怪物所在房间 &&
                        怪物所在房间.类型 === "黑暗房间" &&
                        房间地图[y]?.[x] !== 怪物所在房间.id
                    ) {
                        return false;
                    }
                    return (
                        [
                            单元格类型.房间,
                            单元格类型.走廊,
                            单元格类型.门,
                        ].includes(地牢[y][x].背景类型) &&
                        ![
                            单元格类型.楼梯上楼,
                            单元格类型.楼梯下楼,
                            单元格类型.怪物,
                        ].includes(地牢[y][x].类型)
                    );
                }

                恢复背景类型() {
                    地牢[this.y][this.x].类型 = this.当前格;
                    if (
                        this.当前格 === 单元格类型.物品 &&
                        地牢[this.y][this.x].关联物品 === null
                    ) {
                        地牢[this.y][this.x].类型 = null;
                    }
                    地牢[this.y][this.x].关联怪物 = null;
                }

                保存新位置类型(x, y) {
                    this.当前格 = 地牢[y][x].类型;
                }
                选择逃离目标(目标X, 目标Y, 范围 = 10) {
                    const 可达点 = [];
                    const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
                    const 已访问 = new Set([`${this.x},${this.y}`]);
                    const 怪物所在房间ID = 房间地图[this.y][this.x];

                    while (队列.length > 0) {
                        const 当前 = 队列.shift();
                        const 距离目标 =
                            Math.abs(当前.x - 目标X) + Math.abs(当前.y - 目标Y);
                        const 距离自身 = 当前.距离;

                        if (
                            距离自身 <= 范围 &&
                            距离目标 >
                                Math.abs(this.x - 目标X) +
                                    Math.abs(this.y - 目标Y)
                        ) {
                            const 点所在房间ID = 房间地图[当前.y][当前.x];
                            if (
                                点所在房间ID === 怪物所在房间ID ||
                                点所在房间ID === -1 ||
                                (已访问房间.has(点所在房间ID) &&
                                    房间列表[点所在房间ID]?.类型?.slice(
                                        0,
                                        2
                                    ) !== "隐藏")
                            ) {
                                if (this.位置合法(当前.x, 当前.y)) {
                                    可达点.push({
                                        x: 当前.x,
                                        y: 当前.y,
                                        距离目标: 距离目标,
                                    });
                                }
                            }
                        }

                        if (当前.距离 >= 范围) continue;

                        const 方向 = [
                            { dx: 1, dy: 0 },
                            { dx: -1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: 0, dy: -1 },
                        ];
                        for (const { dx, dy } of 方向) {
                            const 新X = 当前.x + dx;
                            const 新Y = 当前.y + dy;
                            const 位置键 = `${新X},${新Y}`;

                            if (
                                新X >= 0 &&
                                新X < 地牢大小 &&
                                新Y >= 0 &&
                                新Y < 地牢大小 &&
                                !已访问.has(位置键)
                            ) {
                                const 当前单元格 = 地牢[当前.y]?.[当前.x];
                                const 目标单元格 = 地牢[新Y]?.[新X];
                                if (
                                    当前单元格 &&
                                    目标单元格 &&
                                    ![
                                        单元格类型.墙壁,
                                        单元格类型.上锁的门,
                                    ].includes(目标单元格.背景类型) &&
                                    检查移动可行性(当前.x, 当前.y, 新X, 新Y) &&
                                    this.位置合法(新X, 新Y)
                                ) {
                                    已访问.add(位置键);
                                    队列.push({
                                        x: 新X,
                                        y: 新Y,
                                        距离: 当前.距离 + 1,
                                    });
                                }
                            }
                        }
                    }

                    if (可达点.length > 0) {
                        可达点.sort((a, b) => b.距离目标 - a.距离目标);
                        return 可达点[0];
                    }
                    return null;
                }
                尝试攻击() {
                    if (怪物状态表.get(this)?.类型 === "冻结") return;
                    if (this.攻击冷却回合剩余 > 0) {
                        this.攻击冷却回合剩余 -= 1;
                        return false;
                    }
                    this.绘制血条();
                    if (this.通向目标路径.length > this.攻击范围) return false;

                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        if (
                            this.魅惑目标怪物 !== this &&
                            this.魅惑目标怪物 !== null
                        ) {
                            this.魅惑目标怪物?.受伤(this.攻击力, this);
                            this.攻击冷却回合剩余 = this.攻击冷却;
                            计划显示格子特效(this.通向目标路径);
                            return true;
                        } else {
                            return false;
                        }
                    }
                    if (this.仇恨 instanceof 怪物) {
                        if (this.仇恨 !== this && this.仇恨 !== null) {
                            if (this.仇恨.当前生命值 <= 0) {
                                this.仇恨 = null;
                                return false;
                            }
                            this.仇恨?.受伤(this.攻击力, this);
                            this.攻击冷却回合剩余 = this.攻击冷却;
                            计划显示格子特效(this.通向目标路径);
                            return true;
                        } else {
                            return false;
                        }
                    }
                    伤害玩家(this.攻击力, this);
                    this.攻击冷却回合剩余 = this.攻击冷却;
                    计划显示格子特效(this.通向目标路径);

                    return true;
                }
                get 攻击范围() {
                    return this.基础攻击范围 + (this.强化 ? 1 : 0); // + (this.远程武器 ? 3 : 0);
                }
                get 攻击力() {
                    return this.基础攻击力;
                    +(this.强化 ? this.基础攻击力 : 0); //+ (this.武器.攻击力 ? 3 : 0);
                }
                get 颜色() {
                    if (怪物状态表.get(this)) {
                        return 怪物状态表.get(this)?.颜色; // 药水颜色
                    }
                    return this.强化 ? "#ff0000" : this.基础颜色;
                }
                get 移动距离() {
                    return this.基础移动距离 + (this.强化 ? 1 : 0);
                }
                get 生命值() {
                    return this.基础生命值 + (this.强化 ? 30 : 0);
                }
                get 物品掉率() {
                    return this.掉落概率 + (this.强化 ? 0.1 : 0);
                }
                获得效果(状态效果) {
                    return true;
                }
                计算最大甩飞位置(起始X, 起始Y, 方向DX, 方向DY, 最大距离) {
                    let 最远有效位置 = { x: 起始X, y: 起始Y };

                    if (方向DX === 0 && 方向DY === 0) return 最远有效位置; // 没有方向

                    for (let i = 1; i <= 最大距离 + 1; i++) {
                        const 尝试X = 起始X + 方向DX * i;
                        const 尝试Y = 起始Y + 方向DY * i;

                        // 1. 检查边界
                        if (
                            尝试X < 0 ||
                            尝试X >= 地牢大小 ||
                            尝试Y < 0 ||
                            尝试Y >= 地牢大小
                        ) {
                            break; // 超出边界，停止查找
                        }

                        // 2. 检查从 *起始点* 到 *尝试点* 的直线路径是否可行（忽略怪物）
                        if (
                            !检查直线移动可行性(
                                起始X,
                                起始Y,
                                尝试X,
                                尝试Y,
                                true
                            )
                        ) {
                            break; // 路径被墙或门阻挡，停止查找
                        }

                        // 3. 检查 *尝试点* 本身是否是一个有效的 *着陆点* (不能是怪物、阻碍物品等)
                        if (this.位置合法(尝试X, 尝试Y, false)) {
                            // false表示检查落点时不考虑玩家位置
                            最远有效位置 = { x: 尝试X, y: 尝试Y }; // 更新最远有效位置
                        }
                    }
                    return 最远有效位置;
                }
                受伤(伤害, 来源 = null) {
                    if (this.当前生命值 > 0) {
                        this.当前生命值 -= 伤害;
                        let 触发击退 = false;
                        let 来源坐标 = null;
                        if (
                            来源 === "玩家" ||
                            来源 instanceof 武器类 ||
                            来源 instanceof 宠物
                        ) {
                            触发击退 = true;
                            来源坐标 = { x: 玩家.x, y: 玩家.y };
                            this.受伤冻结回合剩余 = this.受伤冻结回合;
                            if (玩家属性.怪物反伤) {
                                伤害玩家(1, '诅咒反伤');
                            }
                        } else if (来源 instanceof 怪物 && 来源 !== this) {
                            触发击退 = true;
                            来源坐标 = { x: 来源.x, y: 来源.y };
                            if (!(来源 instanceof 大魔法师)) this.仇恨 = 来源;
                        }
                        if (中文模式) this.触发受击动画();
                        if (this.当前生命值 <= 0) {
                            if (来源 === "玩家" ||
                            来源 instanceof 武器类 ||
                            来源 instanceof 宠物) {
                                //炸弹炸死不算数
                                已击杀怪物数++;
                                const 能量条 =
                                    document.querySelector(".power-bar");
                                const 当前能量 =
                                    parseFloat(能量条.style.width) || 100;
                                能量条.style.width = `${Math.min(
                                    100,
                                    当前能量 + 1.5
                                )}%`;
                                击杀提示.更新({
                                    内容: `已击杀怪物：${已击杀怪物数}`,
                                });
                                const 装备宠物列表 = Array.from(
                                    { length: 装备栏每页装备数 },
                                    (_, i) =>
                                        玩家装备.get(
                                            当前装备页 * 装备栏每页装备数 +
                                                i +
                                                1
                                        )
                                )
                                    .filter((v) => v != null)
                                    .filter((装备) => 装备 instanceof 宠物);
                                装备宠物列表.forEach((宠物) => {
                                    // 获得的经验与怪物基础生命值相关
                                    const 经验值 = Math.floor(
                                        this.基础生命值 / 10
                                    );
                                    宠物.获得经验(经验值);
                                });
                            }
                            if (来源 instanceof 宠物) {
                                const 经验值 = Math.floor(this.基础生命值 / 10);
                                来源.获得经验(经验值);
                            }
                            this.恢复背景类型();
                            
                            所有怪物 = 所有怪物.filter((m) => m !== this);
                            if (
                                当前天气效果.includes("诡魅") &&
                                !(this instanceof 幽灵怪物) &&
                                Math.random() < 0.3
                            ) {
                                const 新幽灵 = new 幽灵怪物({
                                    x: this.x,
                                    y: this.y,
                                    房间ID: this.房间ID,
                                    状态: 怪物状态.活跃,
                                    强化: this.强化, // 幽灵继承强化状态
                                });
                                if (放置怪物到单元格(新幽灵, this.x, this.y)) {
                                    添加日志(
                                        `一个${新幽灵.类型}从 ${this.类型} 的残骸中浮现！`,
                                        "警告"
                                    );
                                }
                            } else if (
                                Math.random() <=
                                this.物品掉率 * 玩家属性.掉落倍率
                            ) {
                                if (this.掉落物.自定义数据.get("耐久"))
                                    this.掉落物.自定义数据.set(
                                        "耐久",
                                        Math.floor(
                                            Math.min(
                                                this.掉落物.自定义数据.get(
                                                    "耐久"
                                                ),
                                                this.掉落物.自定义数据.get(
                                                    "耐久"
                                                ) *
                                                    玩家属性.掉落倍率 *
                                                    Math.random() *
                                                    Math.random()
                                            )
                                        )
                                    );
                                放置物品到单元格(this.掉落物, this.x, this.y);
                            }
                            const 玩家单元格 = 地牢[玩家.y][玩家.x];
                            if (
                                玩家单元格.关联物品 &&
                                玩家单元格.类型 === 单元格类型.物品
                            ) {
                                if (尝试收集物品(玩家单元格.关联物品)) {
                                    玩家单元格.类型 = null;
                                    玩家单元格.关联物品 = null;
                                }
                            }
                            if (是否为教程层 && this.房间ID === 2) {
                                教程阶段 = 2.5; // 推进到2.5
                                教程提示已显示 = false;
                                setTimeout(() => {
                                    显示教程提示();
                                }, 200);
                            }
                            //绘制应该由调用者处理
                            return;
                        }

                        const 甩飞基础距离 = 1;
                        if (触发击退 && 来源坐标) {
                            let 来源X, 来源Y;
                            来源X = 来源坐标.x;
                            来源Y = 来源坐标.y;
                            let 距离来源 =
                                Math.abs(this.x - 来源坐标.x) +
                                Math.abs(this.y - 来源坐标.y);
                            const 最大击退触发距离 = this.基础攻击范围 * 2;
                            if (距离来源 <= 最大击退触发距离) {
                                // 计算大致方向
                                let dx = this.x - 来源X;
                                let dy = this.y - 来源Y;

                                // 归一化或确定主方向（避免纯斜向）
                                let 方向DX = 0;
                                let 方向DY = 0;
                                if (Math.abs(dx) > Math.abs(dy)) {
                                    方向DX = Math.sign(dx);
                                } else if (Math.abs(dy) > Math.abs(dx)) {
                                    方向DY = Math.sign(dy);
                                } else if (dx !== 0) {
                                    // 对角线情况，随机选一个轴向
                                    if (Math.random() < 0.5)
                                        方向DX = Math.sign(dx);
                                    else 方向DY = Math.sign(dy);
                                }
                                // 如果在同一点（不太可能，但做个保护）
                                if (
                                    方向DX === 0 &&
                                    方向DY === 0 &&
                                    (dx !== 0 || dy !== 0)
                                ) {
                                    方向DX = Math.sign(dx);
                                    方向DY = Math.sign(dy);
                                    if (Math.abs(dx) > Math.abs(dy)) 方向DY = 0;
                                    else 方向DX = 0;
                                }

                                if (方向DX !== 0 || 方向DY !== 0) {
                                    // 必须有方向才能甩飞
                                    const { x: 最终X, y: 最终Y } =
                                        this.计算最大甩飞位置(
                                            this.x,
                                            this.y,
                                            方向DX,
                                            方向DY,
                                            甩飞基础距离
                                        );

                                    if (最终X !== this.x || 最终Y !== this.y) {
                                        const 旧X = this.x;
                                        const 旧Y = this.y; // 记录旧位置
                                        this.恢复背景类型();
                                        this.x = 最终X;
                                        this.y = 最终Y;
                                        this.保存新位置类型(最终X, 最终Y);
                                        地牢[最终Y][最终X].类型 =
                                            单元格类型.怪物;
                                        地牢[最终Y][最终X].关联怪物 = this;
                                        this.处理地形效果(); // 应用新位置效果
                                        this.绘制血条(); // 更新血条位置
                                        添加日志(
                                            `${this.类型} 被击退了！`,
                                            "信息"
                                        );
                                    }
                                }
                            }
                        }
                        this.绘制血条();
                    }
                }
                绘制血条(隐藏血条 = false) {
                    if (隐藏血条) {
                        return;
                    }

                    const 怪物所在房间 =
                        房间地图[this.y]?.[this.x] !== -1
                            ? 房间列表[房间地图[this.y][this.x]]
                            : null;
                    if (
                        (当前天气效果.includes("深夜") &&
                            !是否在光源范围内(this.x, this.y)) ||
                        (怪物所在房间?.类型 === "黑暗房间" &&
                            !是否在光源范围内(this.x, this.y))
                    ) {
                        return;
                    }
                    const 动画状态 = 怪物动画状态.get(this);
                    let 绘制逻辑X = this.x;
                    let 绘制逻辑Y = this.y;
                    const 正在动画 = 动画状态?.正在动画;

                    if (正在动画) {
                        绘制逻辑X =
                            动画状态.视觉X !== undefined
                                ? 动画状态.视觉X
                                : this.x;
                        绘制逻辑Y =
                            动画状态.视觉Y !== undefined
                                ? 动画状态.视觉Y
                                : this.y;
                    }

                    const 屏幕X = (绘制逻辑X - 当前相机X) * 单元格大小;
                    const 屏幕Y = (绘制逻辑Y - 当前相机Y) * 单元格大小;
                    const 宽度 = 单元格大小;

                    const 活跃且区域可见 =
                        this.状态 === 怪物状态.活跃 &&
                        (房间地图[this.y][this.x] === -1 ||
                            已访问房间.has(房间地图[this.y][this.x]));

                    if (活跃且区域可见) {
                        const 血条高度 = 4;
                        const 血条Y = 屏幕Y - 12;
                        const 血条背景色 = "#444";
                        const 血条前景色 = "#f00";

                        ctx.save();
                        ctx.fillStyle = 血条背景色;
                        ctx.fillRect(屏幕X, 血条Y, 宽度, 血条高度);

                        const 血量百分比 = Math.max(
                            0,
                            (this.当前生命值 / this.生命值) * 100
                        );
                        ctx.fillStyle = 血条前景色;
                        ctx.fillRect(
                            屏幕X,
                            血条Y,
                            宽度 * (血量百分比 / 100),
                            血条高度
                        );
                        ctx.restore();
                    }
                }
                触发受击动画() {
                    this.受击动画 = true;
                    绘制();
                    setTimeout(() => {
                        this.受击动画 = false;
                        绘制();
                    }, 200);
                }
            }
            class 幽灵怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.幽灵仆从,
                        基础生命值: 15 + (配置.强化 ? 10 : 0),
                        基础攻击力: 4 + (配置.强化 ? 2 : 0),
                        移动率: 0.8,
                        掉落概率: 0.1,
                        掉落物: new 灵能盾牌({}),
                        基础攻击范围: 1,
                        跟踪距离: 30,
                        受伤冻结回合: 1,
                        ...配置,
                    });
                    if (this.掉落物) {
                        this.尝试添加随机词条到掉落物(this.掉落物);
                    }
                }

                检查移动可行性(fromX, fromY, toX, toY) {
                    if (
                        toX < 0 ||
                        toX >= 地牢大小 ||
                        toY < 0 ||
                        toY >= 地牢大小
                    )
                        return false;

                    const 目标单元格 = 地牢[toY][toX];

                    if (目标单元格.背景类型 === 单元格类型.上锁的门) {
                        return false;
                    }

                    if (目标单元格.关联怪物 && 目标单元格.关联怪物 !== this) {
                        return false;
                    }

                    return true;
                }

                规划移动路径() {
                    let 当前位置 = { x: this.x, y: this.y };
                    let 有效位置 = null;
                    let 可行距离 = this.移动距离 + 1;

                    for (
                        let i = 0;
                        i < Math.min(this.目标路径.length, 可行距离);
                        i++
                    ) {
                        const 节点 = this.目标路径[i];
                        const nextX = 节点.x;
                        const nextY = 节点.y;

                        if (
                            this.检查移动可行性(
                                当前位置.x,
                                当前位置.y,
                                nextX,
                                nextY
                            )
                        ) {
                            if (this.位置合法(nextX, nextY)) {
                                有效位置 = { x: nextX, y: nextY };
                            }
                        } else {
                            this.目标路径 = this.目标路径.slice(i);
                            return 当前位置;
                        }

                        当前位置 = { x: nextX, y: nextY };

                        if (
                            有效位置 &&
                            i >=
                                Math.min(this.移动距离, this.目标路径.length) -
                                    1
                        ) {
                            this.目标路径 = this.目标路径.slice(i + 1);
                            return 有效位置;
                        }
                    }

                    if (有效位置) this.目标路径 = [];
                    return 有效位置;
                }

                位置合法(x, y) {
                    const 单元格 = 地牢[y]?.[x];
                    if (!单元格) return false;

                    if ([单元格类型.上锁的门].includes(单元格.背景类型))
                        return false;

                    if (
                        (单元格.关联怪物 && 单元格.关联怪物 !== this) ||
                        (单元格.关联物品 && 单元格.关联物品.阻碍怪物)
                    ) {
                        return false;
                    }

                    return true;
                }

                计算目标路径(目标X, 目标Y) {
                    this.目标 = { x: 目标X, y: 目标Y };
                    const 开放列表 = [];
                    const 关闭列表 = new Set();
                    const 方向映射表 = [
                        { dx: 1, dy: 0 },
                        { dx: -1, dy: 0 },
                        { dx: 0, dy: 1 },
                        { dx: 0, dy: -1 },
                    ];

                    const 起点节点 = {
                        x: this.x,
                        y: this.y,
                        g: 0,
                        parent: null,
                    };
                    开放列表.push(起点节点);
                    关闭列表.add(`${起点节点.x},${起点节点.y}`);

                    while (开放列表.length > 0) {
                        let 当前节点 = 开放列表.shift();

                        if (当前节点.x === 目标X && 当前节点.y === 目标Y) {
                            const 路径 = [];
                            while (当前节点.parent) {
                                路径.push(当前节点);
                                当前节点 = 当前节点.parent;
                            }
                            return 路径.reverse();
                        }

                        方向映射表.forEach((方向) => {
                            const 新X = 当前节点.x + 方向.dx;
                            const 新Y = 当前节点.y + 方向.dy;
                            if (
                                新X < 0 ||
                                新X >= 地牢大小 ||
                                新Y < 0 ||
                                新Y >= 地牢大小
                            )
                                return;

                            const 目标单元格 = 地牢[新Y][新X];
                            if (目标单元格.背景类型 === 单元格类型.上锁的门)
                                return;

                            const 位置键 = `${新X},${新Y}`;
                            if (!关闭列表.has(位置键)) {
                                开放列表.push({
                                    x: 新X,
                                    y: 新Y,
                                    g: 当前节点.g + 1,
                                    parent: 当前节点,
                                });
                                关闭列表.add(位置键);
                            }
                        });
                    }
                    return null;
                }

                计算路径(目标X, 目标Y) {
                    return this.计算目标路径(目标X, 目标Y);
                }
            }
            class 大魔法师 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.大魔法师,
                        类型: "大魔法师",
                        房间ID: 配置.房间ID || null,
                        x: 配置.x || null,
                        y: 配置.y || null,
                        状态: 配置.状态 || 怪物状态.活跃,
                        基础生命值: 配置.基础生命值 || 80,
                        基础攻击力: 配置.基础攻击力 || 8,
                        强化: 配置.强化 || false,
                        移动率: 配置.移动率 || 0.8,
                        基础攻击范围: 4,
                        跟踪距离: 20,
                        攻击冷却: 3,
                        受伤冻结回合: 1,
                        掉落物: new 真言卷轴({
                            品质: 4,
                            已解锁: true,
                            强化: true,
                        }),
                        掉落概率: 1,
                        ...配置,
                    });
                    this.当前生命值 = 配置.当前生命值 || this.生命值;
                    this.技能冷却 = {
                        隐身术: 0,
                        分身术: 0,
                        火球术: 0,
                        冰冻术: 0,
                        传送术: 0,
                        召唤术: 0,
                    };
                    this.每回合恢复量 = 2;
                    this.隐身中 = false;
                    this.逃离目标 = null;
                    this.原始移动距离 = this.基础移动距离;
                    this.isClone = false;
                    this.隐身提示间隔 = 2;
                    this.隐身提示计数 = 0;
                }

                尝试移动() {
                    if (this.隐身中) {
                        this.隐身移动();
                        return;
                    }

                    if (this.当前生命值 <= 0) return;
                    super.尝试移动();

                    this.绘制血条();
                }

                选择逃离目标() {
                    const 最大距离 = this.跟踪距离; // 最大逃离距离
                    const 可达点 = [];

                    const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0 }];
                    const 已访问 = new Set([`${this.x},${this.y}`]);
                    const 已在房间中 = 房间地图[this.y][this.x] !== -1;
                    const 已在房间 = 房间地图[this.y][this.x];

                    while (队列.length > 0) {
                        const 当前 = 队列.shift();

                        const 房间ID = 房间地图[当前.y][当前.x];
                        if (已访问房间.has(房间ID)) {
                            if (!已在房间中) {
                                可达点.push({
                                    x: 当前.x,
                                    y: 当前.y,
                                    距离: 当前.距离,
                                }); // 记录距离
                            } else {
                                if (房间ID === 已在房间)
                                    可达点.push({
                                        x: 当前.x,
                                        y: 当前.y,
                                        距离: 当前.距离,
                                    });
                            }
                        }

                        if (当前.距离 > 最大距离) continue;

                        const 方向 = [
                            { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                            { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                            { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                            { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
                        ];

                        for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
                            const 新X = 当前.x + dx;
                            const 新Y = 当前.y + dy;
                            const 位置键 = `${新X},${新Y}`;

                            if (
                                新X < 0 ||
                                新X >= 地牢大小 ||
                                新Y < 0 ||
                                新Y >= 地牢大小
                            )
                                continue;
                            const 当前单元格 = 地牢[当前.y][当前.x];
                            const 目标单元格 = 地牢[新Y][新X];
                            if (
                                当前单元格.墙壁[当前墙] ||
                                目标单元格.墙壁[目标墙]
                            )
                                continue;
                            if (
                                [单元格类型.墙壁, 单元格类型.上锁的门].includes(
                                    目标单元格.背景类型
                                )
                            )
                                continue;

                            if (
                                !已访问.has(位置键) &&
                                this.位置合法(新X, 新Y)
                            ) {
                                已访问.add(位置键);
                                队列.push({
                                    x: 新X,
                                    y: 新Y,
                                    距离: 当前.距离 + 1,
                                });
                            }
                        }
                    }

                    let 最远点 = null;
                    let 最大自身距离 = -1;

                    for (const 点 of 可达点) {
                        if (点.距离 > 最大自身距离) {
                            最大自身距离 = 点.距离;
                            最远点 = 点;
                        }
                    }

                    return 最远点;
                }

                隐身移动() {
                    if (this.当前生命值 < this.生命值) {
                        this.当前生命值 = Math.min(
                            this.生命值,
                            this.当前生命值 + this.每回合恢复量
                        );
                        this.绘制血条();
                    } else {
                        this.隐身中 = false;
                        this.基础移动距离 = this.原始移动距离;
                        添加日志(`${this.类型} 现形了!`, "信息");
                        显示通知(
                            "使用分身迷惑你后，隐身的大魔法师缓缓现出真身..."
                        );
                        this.绘制血条();
                        return;
                    }
                    if (
                        this.目标路径.length === 0 ||
                        (Math.random() > this.移动率 && !切换动画) ||
                        this.跟踪距离 < this.目标路径.length
                    ) {
                        this.追击玩家中 = false;
                        return;
                    }
                    if (!this.逃离目标) {
                        this.逃离目标 = this.选择逃离目标();
                    }
                    this.目标路径 = this.计算目标路径(
                        this.逃离目标.x,
                        this.逃离目标.y
                    );
                    if (this.目标路径) {
                        const 下一步 =
                            this.目标路径[
                                Math.min(
                                    this.移动距离 - 1,
                                    this.目标路径.length - 1
                                )
                            ];
                        const 最终位置 = this.规划移动路径();
                        if (
                            !最终位置 ||
                            (this.y === this.逃离目标.y &&
                                this.x === this.逃离目标.x)
                        ) {
                            this.逃离目标 = null;
                            return;
                        }
                        this.恢复背景类型();
                        this.保存新位置类型(最终位置.x, 最终位置.y);
                        this.x = 最终位置.x;
                        this.y = 最终位置.y;
                        地牢[this.y][this.x].类型 = 单元格类型.怪物;
                        地牢[this.y][this.x].关联怪物 = this;
                    } else {
                        this.逃离目标 = null;
                    }

                    this.绘制血条();
                    this.隐身提示计数++;
                    if (this.隐身提示计数 >= this.隐身提示间隔) {
                        this.隐身提示计数 = 0;

                        const 画布Rect = canvas.getBoundingClientRect();
                        let 屏幕X = (this.x - 相机目标X) * 单元格大小;
                        let 屏幕Y = (this.y - 相机目标Y) * 单元格大小;
                        if (
                            屏幕X + 单元格大小 < 0 ||
                            屏幕X > 画布Rect.width ||
                            屏幕Y + 单元格大小 < 0 ||
                            屏幕Y > 画布Rect.height
                        ) {
                            return;
                        }
                        计划显示格子特效([{ x: this.x, y: this.y }], "000000");
                    }
                }

                尝试攻击() {
                    if (怪物状态表.get(this)?.类型 === "冻结") return;

                    if (this.攻击冷却回合剩余 > 0) {
                        this.攻击冷却回合剩余 -= 1;
                        return false;
                    }
                    if (this.通向目标路径.length > this.攻击范围) return false;
                    if (!this.isClone) {
                        if (
                            this.当前生命值 < this.生命值 * 0.3 &&
                            !this.隐身中
                        ) {
                            this.隐身术();
                            this.分身术();
                            添加日志(`${this.类型} 负伤逃跑了!`, "信息");

                            return true;
                        } else if (this.隐身中) {
                            return true;
                        }
                    }

                    if (Math.random() < 0.5) {
                        const 技能列表 = [
                            "火球术",
                            "冰冻术",
                            "传送术",
                            "召唤术",
                        ];
                        const 随机技能 =
                            技能列表[
                                Math.floor(Math.random() * 技能列表.length)
                            ];

                        switch (随机技能) {
                            case "火球术":
                                if (!this.火球术()) {
                                    this.普通攻击();
                                    this.攻击冷却回合剩余 = this.攻击冷却;
                                }
                                break;
                            case "冰冻术":
                                if (!this.冰冻术()) {
                                    this.普通攻击();
                                    this.攻击冷却回合剩余 = this.攻击冷却;
                                }
                                break;
                            case "传送术":
                                this.传送术();
                                break;
                            case "召唤术":
                                if (!this.召唤术()) {
                                    this.普通攻击();
                                    this.攻击冷却回合剩余 = this.攻击冷却;
                                }
                                break;
                        }
                        return true;
                    } else {
                        this.普通攻击();
                        this.攻击冷却回合剩余 = this.攻击冷却;
                        return true;
                    }
                }
                普通攻击() {
                    const 攻击模式 = Math.floor(Math.random() * 4);
                    let 方向列表 = [];

                    switch (攻击模式) {
                        case 0:
                            方向列表 = [
                                { dx: 0, dy: -1 },
                                { dx: 0, dy: 1 },
                                { dx: -1, dy: 0 },
                                { dx: 1, dy: 0 },
                            ];
                            break;
                        case 1:
                            方向列表 = [
                                { dx: -1, dy: -1 },
                                { dx: 1, dy: -1 },
                                { dx: -1, dy: 1 },
                                { dx: 1, dy: 1 },
                            ];
                            break;
                        case 2:
                        case 3:
                            const 基本方向 = [
                                { dx: 0, dy: -1 },
                                { dx: 1, dy: 0 },
                                { dx: 0, dy: 1 },
                                { dx: -1, dy: 0 },
                            ];

                            const 顺时针方向变化 = [
                                { dx: 1, dy: 0 },
                                { dx: 0, dy: 1 },
                                { dx: -1, dy: 0 },
                                { dx: 0, dy: -1 },
                            ];

                            const 逆时针方向变化 = [
                                { dx: 0, dy: -1 },
                                { dx: -1, dy: 0 },
                                { dx: 0, dy: 1 },
                                { dx: 1, dy: 0 },
                            ];

                            基本方向.forEach((起始方向) => {
                                let 当前方向 = 起始方向;
                                let 当前X = this.x;
                                let 当前Y = this.y;
                                let 路径 = [];

                                let 层数 = 0;
                                while (
                                    Math.abs(当前X - this.x) +
                                        Math.abs(当前Y - this.y) <=
                                    this.攻击范围
                                ) {
                                    层数++;
                                    let 步数 = 层数 * 2 - 1;

                                    if (层数 > 1) {
                                        const 方向变化 =
                                            攻击模式 === 2
                                                ? 顺时针方向变化
                                                : 逆时针方向变化;
                                        let 方向索引 = 方向变化.findIndex(
                                            (d) =>
                                                d.dx === 当前方向.dx &&
                                                d.dy === 当前方向.dy
                                        );

                                        方向索引 = (方向索引 + 1) % 4;
                                        当前方向 = 方向变化[方向索引];

                                        当前X += 当前方向.dx;
                                        当前Y += 当前方向.dy;
                                        if (
                                            !检查移动可行性(
                                                当前X - 当前方向.dx,
                                                当前Y - 当前方向.dy,
                                                当前X,
                                                当前Y
                                            )
                                        )
                                            break;

                                        const 单元格 = 地牢[当前Y]?.[当前X];
                                        if (
                                            单元格?.关联怪物 &&
                                            单元格.类型 === 单元格类型.怪物 &&
                                            单元格.关联怪物?.状态 ===
                                                怪物状态.活跃 &&
                                            !(
                                                单元格.关联怪物 instanceof
                                                大魔法师
                                            )
                                        ) {
                                            单元格.关联怪物.受伤(
                                                this.攻击力,
                                                this
                                            );
                                        } else if (
                                            当前X === 玩家.x &&
                                            当前Y === 玩家.y
                                        ) {
                                            伤害玩家(this.攻击力, this);
                                        }

                                        路径.push({ x: 当前X, y: 当前Y });
                                        步数--;
                                    }

                                    for (let i = 0; i < 步数; i++) {
                                        当前X += 当前方向.dx;
                                        当前Y += 当前方向.dy;

                                        if (
                                            !检查移动可行性(
                                                当前X - 当前方向.dx,
                                                当前Y - 当前方向.dy,
                                                当前X,
                                                当前Y
                                            )
                                        )
                                            break;

                                        const 单元格 = 地牢[当前Y]?.[当前X];

                                        if (
                                            单元格?.关联怪物 &&
                                            单元格.类型 === 单元格类型.怪物 &&
                                            单元格.关联怪物?.状态 ===
                                                怪物状态.活跃
                                        ) {
                                            单元格.关联怪物.受伤(
                                                this.攻击力,
                                                this
                                            );
                                        } else if (
                                            当前X === 玩家.x &&
                                            当前Y === 玩家.y
                                        ) {
                                            伤害玩家(this.攻击力, this);
                                        }
                                        路径.push({ x: 当前X, y: 当前Y });
                                    }
                                    if (
                                        Math.abs(当前X - this.x) +
                                            Math.abs(当前Y - this.y) >
                                        this.攻击范围
                                    )
                                        break;
                                }

                                计划显示格子特效(路径);
                            });
                            return;
                    }

                    方向列表.forEach((方向) => {
                        let 当前X = this.x + 方向.dx;
                        let 当前Y = this.y + 方向.dy;
                        let 路径 = [];

                        while (
                            Math.abs(当前X - this.x) +
                                Math.abs(当前Y - this.y) <=
                            this.攻击范围
                        ) {
                            if (
                                !检查移动可行性(
                                    当前X - 方向.dx,
                                    当前Y - 方向.dy,
                                    当前X,
                                    当前Y
                                )
                            )
                                break;

                            const 单元格 = 地牢[当前Y]?.[当前X];

                            if (
                                单元格?.关联怪物 &&
                                单元格.类型 === 单元格类型.怪物 &&
                                单元格.关联怪物?.状态 === 怪物状态.活跃
                            ) {
                                单元格.关联怪物.受伤(this.攻击力, this);
                                break;
                            } else if (当前X === 玩家.x && 当前Y === 玩家.y) {
                                伤害玩家(this.攻击力, this);
                                break;
                            }

                            路径.push({ x: 当前X, y: 当前Y });
                            当前X += 方向.dx;
                            当前Y += 方向.dy;
                        }
                        计划显示格子特效(路径);
                    });
                }

                召唤术() {
                    if (this.技能冷却.召唤术 > 0) return false;
                    const 方向 = [
                        { dx: -1, dy: -1 },
                        { dx: 1, dy: -1 },
                        { dx: -1, dy: 1 },
                        { dx: 1, dy: 1 },
                    ];
                    let 召唤位置 = null;
                    for (const { dx, dy } of 方向) {
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (
                            this.位置合法(x, y) &&
                            !地牢[y][x].关联怪物 &&
                            !地牢[y][x].关联物品
                        ) {
                            召唤位置 = { x, y };
                            break;
                        }
                    }
                    if (!召唤位置) {
                        添加日志(
                            `${this.类型} 尝试召唤，但周围没有可用空间！`,
                            "信息"
                        );
                        return false;
                    }
                    const 追踪数 = 跟踪玩家怪物数;
                    let 召唤数量 = 2;
                    if (追踪数 >= 5) {
                        return false;
                    } else if (追踪数 >= 3) {
                        召唤数量 = 1;
                    }
                    const 可召唤怪物 = [];
                    for (let 房间类型 in 怪物池) {
                        怪物池[房间类型].forEach((怪物配置) => {
                            if (怪物配置.类 !== 大魔法师) {
                                可召唤怪物.push(怪物配置);
                            }
                        });
                    }
                    for (let i = 0; i < 召唤数量; i++) {
                        const 总权重 = 可召唤怪物.reduce(
                            (sum, m) => sum + m.权重,
                            0
                        );
                        let 随机值 = Math.random() * 总权重;
                        let 选中配置 = null;

                        for (const m of 可召唤怪物) {
                            if (随机值 <= m.权重) {
                                选中配置 = m;
                                break;
                            }
                            随机值 -= m.权重;
                        }
                        if (召唤位置) {
                            if (!this.位置合法(召唤位置.x, 召唤位置.y)) break;
                        }
                        const 新怪物 = new 选中配置.类({
                            x: 召唤位置.x,
                            y: 召唤位置.y,
                            房间ID: 房间地图[召唤位置.y][召唤位置.x],
                            状态: 怪物状态.活跃,
                            强化: Math.random() < 0.3,
                        });
                        放置怪物到单元格(新怪物, 召唤位置.x, 召唤位置.y);
                        新怪物.处理地形效果();

                        计划显示格子特效(
                            [{ x: 召唤位置.x, y: 召唤位置.y }],
                            "800080"
                        );
                        for (const { dx, dy } of 方向) {
                            const x = this.x + dx;
                            const y = this.y + dy;
                            if (
                                this.位置合法(x, y) &&
                                !地牢[y][x].关联怪物 &&
                                !地牢[y][x].关联物品
                            ) {
                                召唤位置 = { x, y };
                                break;
                            }
                        }
                    }
                    显示通知(`${this.类型} 使用了召唤术！`, "信息");
                    this.技能冷却.召唤术 = 8;
                    return true;
                }

                隐身术() {
                    if (this.隐身中) return;

                    this.逃离目标 = this.选择逃离目标();
                    this.隐身中 = true;
                    this.基础移动距离 = 2;
                    this.绘制血条(true);
                    添加日志(`${this.类型} 使用了隐身术!`, "信息");
                }

                分身术() {
                    if (
                        this.技能冷却.分身术 > 0 ||
                        this.分身?.当前生命值 > 0 ||
                        this.isClone
                    )
                        return;
                    if (this.分身?.当前生命值 > 0) {
                        this.分身.恢复背景类型();
                        this.分身.血条元素.remove();
                        所有怪物 = 所有怪物.filter((m) => m !== this.分身);
                    }
                    let x = this.x;
                    let y = this.y;
                    const 分身 = new 大魔法师({
                        x: x,
                        y: y,
                        当前生命值: this.当前生命值,
                        房间ID: this.房间ID,
                    });
                    this.分身 = 分身;
                    分身.isClone = true;
                    let 放置 = 怪物放置物品(分身, x, y);
                    if (放置.x === null) {
                        this.分身.当前生命值 = 0;
                    }
                    this.尝试移动();
                    添加日志(`${this.类型} 使用了分身术!`, "信息");
                    this.技能冷却.分身术 = 10;
                }

                火球术() {
                    if (this.技能冷却.火球术 > 0) return false;

                    const 最大距离 = 8;
                    const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;

                    if (玩家距离 > 0 && 玩家距离 <= 最大距离) {
                        const 攻击路径 = this.计算目标路径(玩家.x, 玩家.y);
                        if (攻击路径) {
                            计划显示格子特效(攻击路径);

                            const 扔出炸弹 = new 炸弹({
                                能否拾起: false,
                                颜色索引: 4,
                            });
                            let 目标 = {};
                            目标 = 玩家放置物品(扔出炸弹);
                            if (目标.x !== null || 目标.y !== null) {
                                扔出炸弹.使用(false, 目标.x, 目标.y);
                            }
                            添加日志(`${this.类型} 使用了火球术!`, "信息");
                            this.技能冷却.火球术 = 4;
                            return true;
                        } else {
                            return false;
                        }
                    }
                }

                冰冻术() {
                    if (this.技能冷却.冰冻术 > 0) return false;
                    const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;
                    const 范围 = 2;
                    if (玩家距离 > 范围) return false;
                    for (let dx = -范围; dx <= 范围; dx++) {
                        for (let dy = -范围; dy <= 范围; dy++) {
                            const x = this.x + dx;
                            const y = this.y + dy;
                            if (
                                x >= 0 &&
                                x < 地牢大小 &&
                                y >= 0 &&
                                y < 地牢大小
                            ) {
                                const 单元格 = 地牢[y][x];

                                if (
                                    单元格.关联怪物 &&
                                    单元格.关联怪物.类型 !== "冰冻怪物" &&
                                    单元格.关联怪物.类型 !== "大魔法师"
                                ) {
                                    new 状态效果(
                                        "冻结",
                                        "#2196F3",
                                        "冻",
                                        3,
                                        null,
                                        null,
                                        单元格.关联怪物
                                    );
                                }
                                if (
                                    x === 玩家.x &&
                                    y === 玩家.y &&
                                    !Array.from(
                                        { length: 装备栏每页装备数 },
                                        (_, i) =>
                                            玩家装备.get(
                                                当前装备页 * 装备栏每页装备数 +
                                                    i +
                                                    1
                                            )
                                    )
                                        .filter((v) => v != null)
                                        .some((item) => item.名称 === "冰盾")
                                ) {
                                    伤害玩家(this.攻击力, this);
                                    new 状态效果(
                                        "冻结",
                                        "#2196F3",
                                        图标映射.冰冻怪物,
                                        3,
                                        3
                                    );
                                }
                                if (单元格.关联物品 instanceof 炸弹) {
                                    if (!单元格.关联物品.能否拾起) {
                                        单元格.关联物品.自定义数据.set(
                                            "倒计时",
                                            单元格.关联物品.自定义数据.get(
                                                "爆炸时间"
                                            )
                                        );
                                        单元格.关联物品.能否拾起 = true;
                                        所有计时器 = 所有计时器.filter(
                                            (item) => item !== 单元格.关联物品
                                        );
                                        单元格.关联物品.x = null;
                                        单元格.关联物品.y = null;
                                        添加日志("炸弹已被熄灭！", "信息");
                                        绘制();
                                    }
                                }
                                if (单元格.关联物品 instanceof 火焰物品) {
                                    单元格.关联物品 = null;
                                    if (单元格.类型 === 单元格类型.物品)
                                        单元格.类型 = null;
                                    单元格.颜色索引 = 颜色表.length;
                                }
                            }
                            if (单元格.关联怪物?.类型 !== "大魔法师") {
                                计划显示格子特效([{ x: x, y: y }], "0000DD");
                            }
                        }
                    }
                    添加日志(`${this.类型} 使用了冰冻术!`, "信息");
                    this.技能冷却.冰冻术 = 6;
                    return true;
                }
                传送术() {
                    if (this.技能冷却.传送术 > 0) return;

                    const 最小距离 = 5;
                    const 最大距离 = 10;

                    const 可达点 = [];
                    const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
                    const 已访问 = new Set([`${this.x},${this.y} `]);

                    const 方向 = [
                        { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                        { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                        { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                        { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
                    ];

                    while (队列.length > 0) {
                        const 当前 = 队列.shift();

                        if (
                            当前.距离 >= 最小距离 &&
                            当前.距离 <= 最大距离 &&
                            已访问房间.has(房间地图[当前.y][当前.x])
                        ) {
                            可达点.push({ x: 当前.x, y: 当前.y });
                        }

                        if (当前.距离 > 最大距离) continue;

                        for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
                            const 新X = 当前.x + dx;
                            const 新Y = 当前.y + dy;
                            const 位置键 = `${新X},${新Y} `;

                            if (
                                新X < 0 ||
                                新X >= 地牢大小 ||
                                新Y < 0 ||
                                新Y >= 地牢大小
                            )
                                continue;
                            const 当前单元格 = 地牢[当前.y][当前.x];
                            const 目标单元格 = 地牢[新Y][新X];
                            if (
                                当前单元格.墙壁[当前墙] ||
                                目标单元格.墙壁[目标墙]
                            )
                                continue;
                            if (
                                [单元格类型.墙壁, 单元格类型.上锁的门].includes(
                                    目标单元格.背景类型
                                )
                            )
                                continue;

                            if (
                                !已访问.has(位置键) &&
                                this.位置合法(新X, 新Y)
                            ) {
                                已访问.add(位置键);
                                队列.push({
                                    x: 新X,
                                    y: 新Y,
                                    距离: 当前.距离 + 1,
                                });
                            }
                        }
                    }

                    const 旧X = this.x;
                    const 旧Y = this.y;
                    if (可达点.length > 0) {
                        const 目标点 =
                            可达点[Math.floor(Math.random() * 可达点.length)];
                        this.恢复背景类型();
                        this.保存新位置类型(目标点.x, 目标点.y);
                        this.x = 目标点.x;
                        this.y = 目标点.y;
                        地牢[this.y][this.x].类型 = 单元格类型.怪物;
                        地牢[this.y][this.x].关联怪物 = this;
                        添加日志(`${this.类型} 使用了传送术!`, "信息");
                        this.技能冷却.传送术 = 7;
                        this.处理地形效果();
                        怪物动画状态.set(this, {
                            旧逻辑X: 旧X,
                            旧逻辑Y: 旧Y,
                            目标逻辑X: this.x,
                            目标逻辑Y: this.y,
                            视觉X: 旧X,
                            视觉Y: 旧Y,
                            动画开始时间: Date.now(),
                            正在动画: true,
                        });
                    }
                }
                受伤(伤害, 来源 = null) {
                    const 获取房间 = (名称) =>
                        房间列表.find((r) => r.名称 === 名称);
                    if (来源 !== "玩家") return false;
                    if (this.当前生命值 > 0) {
                        this.当前生命值 -= 伤害;
                        if (中文模式) this.触发受击动画();

                        if (this.当前生命值 <= 0) {
                            已击杀怪物数++;
                            const 能量条 = document.querySelector(".power-bar");
                            const 当前能量 =
                                parseFloat(能量条.style.width) || 100;
                            能量条.style.width = `${Math.min(
                                100,
                                当前能量 + 7
                            )}%`;
                            击杀提示.更新({
                                内容: `已击杀怪物：${已击杀怪物数} `,
                            });
                            const 装备宠物列表 = Array.from(
                                { length: 装备栏每页装备数 },
                                (_, i) =>
                                    玩家装备.get(
                                        当前装备页 * 装备栏每页装备数 + i + 1
                                    )
                            )
                                .filter((v) => v != null)
                                .filter((装备) => 装备 instanceof 宠物);
                            装备宠物列表.forEach((宠物) => {
                                const 经验值 = Math.floor(this.基础生命值 / 10);
                                宠物.获得经验(经验值);
                            });

                            this.恢复背景类型();
                            
                            所有怪物 = 所有怪物.filter((m) => m !== this);

                            if (
                                this.isClone !== true &&
                                Math.random() <=
                                    this.物品掉率 * 玩家属性.掉落倍率
                            ) {
                                if (this.掉落物.自定义数据.get("耐久"))
                                    this.掉落物.自定义数据.set(
                                        "耐久",
                                        Math.floor(
                                            Math.min(
                                                this.掉落物.自定义数据.get(
                                                    "耐久"
                                                ),
                                                this.掉落物.自定义数据.get(
                                                    "耐久"
                                                ) *
                                                    玩家属性.掉落倍率 *
                                                    Math.random() *
                                                    Math.random()
                                            )
                                        )
                                    );
                                if (房间列表[房间地图[this.y][this.x]]) {
                                    放置物品到单元格(
                                        this.掉落物,
                                        this.x,
                                        this.y
                                    );
                                    生成奖励(
                                        房间列表[房间地图[this.y][this.x]]
                                    );
                                    放置物品到房间(
                                        new 魔法师法杖({}),
                                        获取房间("最终秘室")
                                    );
                                    放置物品到房间(
                                        new 大师附魔卷轴({}),
                                        获取房间("最终秘室")
                                    );
                                    放置物品到房间(
                                        new 小书魔({}),
                                        获取房间("最终秘室")
                                    );
                                    放置楼梯(
                                        获取房间("最终秘室"),
                                        楼梯图标.下楼,
                                        单元格类型.楼梯下楼
                                    );
                                    显示通知("大魔法师被彻底抹除了...");
                                }
                            }

                            const 玩家单元格 = 地牢[玩家.y][玩家.x];
                            if (
                                玩家单元格.关联物品 &&
                                玩家单元格.类型 === 单元格类型.物品
                            ) {
                                if (尝试收集物品(玩家单元格.关联物品)) {
                                    玩家单元格.类型 = null;
                                    玩家单元格.关联物品 = null;
                                }
                            }
                            return;
                        }
                        this.绘制血条();
                    }
                }

                更新技能冷却() {
                    for (const 技能 in this.技能冷却) {
                        if (this.技能冷却[技能] > 0) {
                            this.技能冷却[技能]--;
                        }
                    }
                }
                绘制血条(隐藏血条 = false) {
                    if (this.隐身中) {
                        
                        return;
                    }
                    super.绘制血条(隐藏血条);
                }
            }
            class 腐蚀怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.腐蚀怪物,
                        类型: "腐蚀怪物",
                        基础生命值: 35 + (配置.强化 ? 15 : 0),
                        基础攻击力: 4 + (配置.强化 ? 2 : 0),
                        掉落物: new 重铸台({}),
                        掉落概率: 0.1,
                        攻击冷却: 1,
                        ...配置,
                    });
                    this.腐蚀强度 = 1 + (配置.强化 ? 1 : 0);
                    this.腐蚀持续 = 4 + (配置.强化 ? 2 : 0);
                }

                尝试攻击() {
                    if (super.尝试攻击()) {
                        if (怪物状态表.get(this)?.类型 === "魅惑") {
                        } else {
                            new 状态效果(
                                "腐蚀",
                                "#8FBC8F",
                                "☠️",
                                this.腐蚀持续,
                                null,
                                this,
                                null,
                                this.腐蚀强度
                            );
                            添加日志("你的装备被腐蚀了！", "错误");
                        }
                        return true;
                    }
                    return false;
                }

                应用效果() {
                    const 腐蚀量 = 1 + Math.floor(this.腐蚀强度 / 2);
                    let 实际腐蚀 = false;
                    Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                        玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                    )
                        .filter((v) => v != null)
                        .forEach((装备) => {
                            if (
                                装备.自定义数据?.has("耐久") &&
                                !装备.自定义数据.get("不可破坏")
                            ) {
                                const 原耐久 = 装备.自定义数据.get("耐久");
                                装备.自定义数据.set(
                                    "耐久",
                                    Math.max(0, 原耐久 - 腐蚀量)
                                );
                                if (
                                    原耐久 > 0 &&
                                    装备.自定义数据.get("耐久") === 0
                                ) {
                                    添加日志(
                                        `${装备.名称} 被腐蚀损坏了！`,
                                        "错误"
                                    );
                                    处理销毁物品(装备.唯一标识, true);
                                    实际腐蚀 = true;
                                } else if (
                                    装备.自定义数据.get("耐久") < 原耐久
                                ) {
                                    添加日志(
                                        `${装备.名称} 被腐蚀了！损失 ${腐蚀量} 点耐久。`,
                                        "错误"
                                    );
                                    实际腐蚀 = true;
                                }
                            }
                        });
                    if (实际腐蚀) {
                        更新装备显示();
                    }
                }
                移除效果() {
                    return true;
                }
            }
            class 盗贼怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.盗贼怪物,
                        类型: "盗贼怪物",
                        基础生命值: 25 + (配置.强化 ? 10 : 0),
                        基础攻击力: 4 + (配置.强化 ? 1 : 0),
                        移动率: 0.8,
                        基础移动距离: 2,
                        掉落物: new 金币({ 数量: 1 }),
                        掉落概率: 0.3,
                        跟踪距离: 20,
                        ...配置,
                    });
                    this.偷窃几率 = 0.5 + (配置.强化 ? 0.2 : 0);
                    this.偷窃武器几率 = 0.15 + (配置.强化 ? 0.1 : 0);
                    this.偷到的金币 = 0;
                    this.偷到的武器列表 = [];
                }

                尝试攻击() {
                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        return super.尝试攻击();
                    }

                    const 攻击成功 = super.尝试攻击();
                    if (攻击成功) {
                        if (Math.random() < this.偷窃几率) {
                            const 玩家金币 = [...玩家背包.values()]
                                .filter((i) => i instanceof 金币)
                                .reduce((sum, i) => sum + i.堆叠数量, 0);
                            if (玩家金币 > 0) {
                                const 偷窃数量 = Math.min(
                                    玩家金币,
                                    Math.floor(
                                        Math.random() * (5 + this.攻击力)
                                    ) + 1
                                );
                                if (扣除金币(偷窃数量)) {
                                    this.偷到的金币 += 偷窃数量;
                                    显示通知(
                                        `${this.类型} 偷走了你的 ${偷窃数量} 金币！`,
                                        "错误"
                                    );
                                    添加日志(
                                        `${this.类型} 偷走了 ${偷窃数量} 金币！`,
                                        "错误"
                                    );
                                }
                            }
                        }

                        if (Math.random() < this.偷窃武器几率) {
                            let 玩家装备武器 = Array.from(
                                { length: 装备栏每页装备数 },
                                (_, i) =>
                                    玩家装备.get(
                                        当前装备页 * 装备栏每页装备数 + i + 1
                                    )
                            )
                                .filter((v) => v != null)
                                .filter((item) => item instanceof 武器类);

                            if (玩家装备武器.length > 1) {
                                const 目标武器索引 = Math.floor(
                                    Math.random() * 玩家装备武器.length
                                );
                                const 被偷武器 = 玩家装备武器[目标武器索引];

                                玩家装备.delete(被偷武器.装备槽位);
                                被偷武器.已装备 = false;
                                const 原槽位 = 被偷武器.装备槽位;
                                被偷武器.装备槽位 = null;

                                this.偷到的武器列表.push(被偷武器);
                                玩家背包.delete(被偷武器.唯一标识);
                                被偷武器.已装备 = false;
                                被偷武器.装备槽位 = null;

                                显示通知(
                                    `${
                                        this.类型
                                    } 偷走了你的 ${被偷武器.获取名称()}！`,
                                    "错误"
                                );
                                添加日志(
                                    `${
                                        this.类型
                                    } 偷走了 ${被偷武器.获取名称()}！`,
                                    "错误"
                                );

                                更新装备显示();
                                更新背包显示();
                            }
                            let 玩家装备装甲 = Array.from(
                                { length: 装备栏每页装备数 },
                                (_, i) =>
                                    玩家装备.get(
                                        当前装备页 * 装备栏每页装备数 + i + 1
                                    )
                            )
                                .filter((v) => v != null)
                                .filter((item) => item instanceof 防御装备类);

                            const 目标武器索引 = Math.floor(
                                Math.random() * 玩家装备装甲.length
                            );
                            const 被偷装甲 = 玩家装备装甲[目标武器索引];

                            if (被偷装甲) {
                                玩家装备.delete(被偷装甲.装备槽位);
                                被偷装甲.已装备 = false;
                                const 原槽位 = 被偷装甲.装备槽位;
                                被偷装甲.装备槽位 = null;

                                this.偷到的武器列表.push(被偷装甲);
                                玩家背包.delete(被偷装甲.唯一标识);
                                被偷装甲.已装备 = false;
                                被偷装甲.装备槽位 = null;

                                显示通知(
                                    `${
                                        this.类型
                                    } 偷走了你的 ${被偷装甲.获取名称()}！`,
                                    "错误"
                                );
                                添加日志(
                                    `${
                                        this.类型
                                    } 偷走了 ${被偷装甲.获取名称()}！`,
                                    "错误"
                                );

                                更新装备显示();
                                更新背包显示();
                            }
                        }
                    }
                    return 攻击成功;
                }

                受伤(伤害, 来源 = null) {
                    const 原始血量 = this.当前生命值;
                    super.受伤(伤害, 来源);

                    if (原始血量 > 0 && this.当前生命值 <= 0) {
                        let 掉落成功 = false;

                        if (this.偷到的金币 > 0) {
                            const 掉落金币 = new 金币({
                                数量: this.偷到的金币,
                            });
                            if (放置物品到单元格(掉落金币, this.x, this.y)) {
                                添加日志(
                                    `${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`,
                                    "成功"
                                );
                                掉落成功 = true;
                            } else {
                                let 方向 = [
                                    [0, -1],
                                    [0, 1],
                                    [-1, 0],
                                    [1, 0],
                                ];
                                for (const [dx, dy] of 方向) {
                                    if (
                                        放置物品到单元格(
                                            掉落金币,
                                            this.x + dx,
                                            this.y + dy
                                        )
                                    ) {
                                        添加日志(
                                            `${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`,
                                            "成功"
                                        );
                                        掉落成功 = true;
                                        break;
                                    }
                                }
                                if (!掉落成功) {
                                    方向 = [
                                        [1, -1],
                                        [1, 1],
                                        [-1, -1],
                                        [1, -1],
                                    ];
                                    for (const [dx, dy] of 方向) {
                                        if (
                                            放置物品到单元格(
                                                掉落金币,
                                                this.x + dx,
                                                this.y + dy
                                            )
                                        ) {
                                            添加日志(
                                                `${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`,
                                                "成功"
                                            );
                                            掉落成功 = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!掉落成功)
                                添加日志(
                                    `${this.类型} 死亡，但未能掉落金币（周围无空间）`,
                                    "警告"
                                );
                        }

                        this.偷到的武器列表.forEach((武器) => {
                            掉落成功 = false;
                            if (放置物品到单元格(武器, this.x, this.y)) {
                                添加日志(
                                    `${
                                        this.类型
                                    } 死亡，掉落了 ${武器.获取名称()}！`,
                                    "成功"
                                );
                                掉落成功 = true;
                            } else {
                                let 方向 = [
                                    [0, -1],
                                    [0, 1],
                                    [-1, 0],
                                    [1, 0],
                                ];
                                for (const [dx, dy] of 方向) {
                                    if (
                                        放置物品到单元格(
                                            武器,
                                            this.x + dx,
                                            this.y + dy
                                        )
                                    ) {
                                        添加日志(
                                            `${
                                                this.类型
                                            } 死亡，掉落了 ${武器.获取名称()}！`,
                                            "成功"
                                        );
                                        掉落成功 = true;
                                        break;
                                    }
                                }
                                if (!掉落成功) {
                                    方向 = [
                                        [1, -1],
                                        [1, 1],
                                        [-1, -1],
                                        [1, -1],
                                    ];
                                    for (const [dx, dy] of 方向) {
                                        if (
                                            放置物品到单元格(
                                                掉落金币,
                                                this.x + dx,
                                                this.y + dy
                                            )
                                        ) {
                                            添加日志(
                                                `${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`,
                                                "成功"
                                            );
                                            掉落成功 = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (!掉落成功) {
                                添加日志(
                                    `${
                                        this.类型
                                    } 死亡，但未能掉落 ${武器.获取名称()}（周围无空间）`,
                                    "警告"
                                );

                                if (尝试收集物品(武器, true)) {
                                    添加日志(
                                        `${武器.获取名称()} 已返回你的背包！`,
                                        "成功"
                                    );
                                } else {
                                    添加日志(
                                        `背包已满，无法返还 ${武器.获取名称()}！`,
                                        "错误"
                                    );
                                }
                            }
                        });
                        this.偷到的武器列表 = [];
                        更新背包显示();
                    }
                }
            }
            class 吸能怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.吸能怪物,
                        类型: "吸能怪物",
                        基础生命值: 28 + (配置.强化 ? 12 : 0),
                        基础攻击力: 4 + (配置.强化 ? 2 : 0),
                        掉落物: new 能量药水({ 数量: 1 }),
                        掉落概率: 0.4,
                        基础攻击范围: 2, // 增加攻击范围以便吸附
                        ...配置,
                    });
                    this.吸能比例 = 0.3 + (配置.强化 ? 0.15 : 0);
                    this.最小吸能 = 5 + (配置.强化 ? 10 : 0);
                    this.吸附距离 = 2 + (配置.强化 ? 1 : 0);
                    this.吸附冷却 = 3 - (配置.强化 ? 1 : 0); // 吸附技能冷却时间
                    this.吸附冷却剩余 = 0;
                }

                尝试移动() {
                    if (this.吸附冷却剩余 > 0) {
                        this.吸附冷却剩余--;
                    }
                    const 玩家距离 =
                        Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);

                    if (玩家距离 <= this.吸附距离 && this.吸附冷却剩余 <= 0) {
                        const 路径 = 获取直线路径(
                            玩家.x,
                            玩家.y,
                            this.x,
                            this.y
                        );
                        if (路径 && 路径.length > 1) {
                            计划显示格子特效(路径.slice(1, -1), "8A2BE2");
                            const { 成功吸附, 新玩家X, 新玩家Y } =
                                this.尝试吸附玩家();
                            if (成功吸附) {
                                const 旧吸附X = 玩家.x,
                                    旧吸附Y = 玩家.y;
                                玩家.x = 新玩家X;
                                玩家.y = 新玩家Y;
                                添加日志("你被吸能怪物拉近了！", "警告");
                                处理玩家着陆效果(
                                    旧吸附X,
                                    旧吸附Y,
                                    玩家.x,
                                    玩家.y
                                );
                                更新视口();
                                绘制();
                                this.吸附冷却剩余 = this.吸附冷却;
                            }
                        }
                    }
                    super.尝试移动();
                }

                尝试攻击() {
                    if (怪物状态表.get(this)?.类型 === "冻结") return false;
                    if (this.攻击冷却回合剩余 > 0) {
                        this.攻击冷却回合剩余 -= 1;
                        return false;
                    }
                    this.绘制血条();

                    if (this.通向目标路径.length > this.攻击范围) return false;

                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        if (
                            this.魅惑目标怪物 !== this &&
                            this.魅惑目标怪物 !== null
                        ) {
                            this.魅惑目标怪物?.受伤(this.攻击力, this);
                            this.攻击冷却回合剩余 = this.攻击冷却;
                            计划显示格子特效(this.通向目标路径);
                            return true;
                        } else {
                            return false;
                        }
                    }

                    const 攻击成功 = super.尝试攻击();
                    if (攻击成功) {
                        const 造成伤害 = this.攻击力;
                        const 吸取量 = Math.max(
                            this.最小吸能,
                            Math.ceil(造成伤害 * this.吸能比例)
                        );
                        if (扣除能量(吸取量)) {
                            const 能量条 = document.querySelector(".power-bar");
                            const 当前能量 =
                                parseFloat(能量条.style.width) || 0;
                            添加日志(
                                `${this.类型} 吸取了你 ${吸取量.toFixed(
                                    0
                                )} 点能量！`,
                                "错误"
                            );
                            触发HUD显示();
                        }
                    }
                    return 攻击成功;
                }

                尝试吸附玩家() {
                    let 成功吸附 = false;
                    let 当前玩家X = 玩家.x;
                    let 当前玩家Y = 玩家.y;
                    let 新玩家X = 玩家.x;
                    let 新玩家Y = 玩家.y;

                    for (let i = 0; i < this.吸附距离; i++) {
                        const dx = this.x - 当前玩家X;
                        const dy = this.y - 当前玩家Y;
                        if (dx === 0 && dy === 0) break; // 已经到达怪物位置

                        let 移动X = 当前玩家X;
                        let 移动Y = 当前玩家Y;

                        if (Math.abs(dx) > Math.abs(dy)) {
                            移动X += Math.sign(dx);
                        } else if (Math.abs(dy) > Math.abs(dx)) {
                            移动Y += Math.sign(dy);
                        } else {
                            if (Math.random() < 0.5) {
                                移动X += Math.sign(dx);
                            } else {
                                移动Y += Math.sign(dy);
                            }
                        }

                        if (移动X === this.x && 移动Y === this.y) break; // 不吸入到怪物自身格

                        if (
                            检查移动可行性(当前玩家X, 当前玩家Y, 移动X, 移动Y)
                        ) {
                            const 目标单元格 = 地牢[移动Y]?.[移动X];
                            if (
                                目标单元格 &&
                                ![
                                    单元格类型.墙壁,
                                    单元格类型.上锁的门,
                                ].includes(目标单元格.背景类型) &&
                                !目标单元格.关联怪物
                            ) {
                                新玩家X = 移动X;
                                新玩家Y = 移动Y;
                                当前玩家X = 移动X;
                                当前玩家Y = 移动Y;
                                成功吸附 = true;
                            } else {
                                break; // 遇到障碍
                            }
                        } else {
                            break; // 路径不可行
                        }
                    }
                    return { 成功吸附, 新玩家X, 新玩家Y };
                }
            }

            class 剧毒云雾怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.剧毒云雾怪物,
                        类型: "剧毒云雾怪物",
                        基础生命值: 25 + (配置.强化 ? 15 : 0),
                        基础攻击力: 5 + (配置.强化 ? 2 : 0),
                        移动率: 0.8,
                        掉落物: new 治疗药水({ 数量: 1 }),
                        掉落概率: 0.3,
                        基础攻击范围: 1,
                        ...配置,
                    });
                    this.毒云范围 = 1 + (配置.强化 ? 1 : 0);
                    this.毒云持续 = 3 + (配置.强化 ? 1 : 0);
                    this.毒云强度 = 2 + (配置.强化 ? 1 : 0);
                }

                受伤(伤害, 来源 = null) {
                    const 原始血量 = this.当前生命值;
                    super.受伤(伤害, 来源);

                    if (原始血量 > 0 && this.当前生命值 <= 0) {
                        this.释放毒云();
                    }
                }

                释放毒云() {
                    添加日志(`${this.类型} 死亡时释放了剧毒云雾！`, "警告");
                    const 范围 = this.毒云范围;
                    const 中心X = this.x;
                    const 中心Y = this.y;

                    for (let dx = -范围; dx <= 范围; dx++) {
                        for (let dy = -范围; dy <= 范围; dy++) {
                            const x = 中心X + dx;
                            const y = 中心Y + dy;

                            if (
                                x >= 0 &&
                                x < 地牢大小 &&
                                y >= 0 &&
                                y < 地牢大小
                            ) {
                                const 单元格 = 地牢[y][x];

                                if (
                                    单元格.背景类型 !== 单元格类型.墙壁 &&
                                    单元格.背景类型 !== 单元格类型.上锁的门
                                ) {
                                    if (玩家.x === x && 玩家.y === y) {
                                        new 状态效果(
                                            "中毒",
                                            "#008000",
                                            "☠️",
                                            this.毒云持续,
                                            null,
                                            null,
                                            null,
                                            this.毒云强度
                                        );
                                        添加日志("你吸入了剧毒云雾！", "错误");
                                    }

                                    if (
                                        单元格.关联怪物 &&
                                        单元格.关联怪物 !== this &&
                                        怪物状态表.get(单元格.关联怪物)
                                            ?.类型 !== "魅惑"
                                    ) {
                                        new 状态效果(
                                            "中毒",
                                            "#008000",
                                            "☠️",
                                            this.毒云持续,
                                            null,
                                            null,
                                            单元格.关联怪物,
                                            this.毒云强度
                                        );
                                        添加日志(
                                            `${单元格.关联怪物.类型} 吸入了剧毒云雾！`,
                                            "信息"
                                        );
                                    }

                                    Array.from(
                                        { length: 装备栏每页装备数 },
                                        (_, i) =>
                                            玩家装备.get(
                                                当前装备页 * 装备栏每页装备数 +
                                                    i +
                                                    1
                                            )
                                    )
                                        .filter((v) => v != null)
                                        .forEach((装备) => {
                                            if (
                                                装备 instanceof 宠物 &&
                                                装备.x === x &&
                                                装备.y === y &&
                                                !装备.自定义数据.get("休眠中")
                                            ) {
                                                装备.受伤(this.毒云强度);
                                                添加日志(
                                                    `${装备.名称} 吸入了剧毒云雾！`,
                                                    "错误"
                                                );
                                            }
                                        });

                                    计划显示格子特效(
                                        [{ x: x, y: y }],
                                        "90EE90",
                                        150
                                    );
                                }
                            }
                        }
                    }
                }
            }
            class 召唤师怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.召唤师怪物,
                        类型: "召唤师怪物",
                        基础生命值: 30 + (配置.强化 ? 15 : 0),
                        基础攻击力: 3 + (配置.强化 ? 1 : 0),
                        移动率: 0.8,
                        掉落物: new 能量药水({ 数量: 1 }),
                        掉落概率: 0.3,
                        基础攻击范围: 4,
                        跟踪距离: 15,
                        ...配置,
                    });
                    this.召唤冷却 = 3 + (配置.强化 ? -1 : 0);
                    this.召唤冷却剩余 = Math.floor(
                        Math.random() * this.召唤冷却
                    );
                    this.最大召唤物数量 = 2 + (配置.强化 ? 1 : 0);
                    this.当前召唤物列表 = [];
                    this.召唤物类 = 幽灵仆从;
                }

                尝试移动() {
                    const 我的状态 = 怪物状态表.get(this);
                    if (我的状态?.类型 === "冻结") return;

                    if (this.当前生命值 <= 0) return;

                    this.当前召唤物列表 = this.当前召唤物列表.filter(
                        (仆从) => 仆从 && 仆从.当前生命值 > 0
                    );

                    if (this.受伤冻结回合剩余 > 0) {
                        this.受伤冻结回合剩余--;
                        this.绘制血条();
                        return;
                    }

                    if (this.召唤冷却剩余 > 0) {
                        this.召唤冷却剩余--;
                    }

                    if (我的状态?.类型 === "魅惑") {
                        const 目标 = this.寻找最近怪物目标();
                        if (目标) {
                            const 逃离点 = this.选择逃离目标(目标.x, 目标.y, 5);
                            if (逃离点) {
                                this.目标路径 = this.计算路径(
                                    逃离点.x,
                                    逃离点.y
                                );
                                if (this.目标路径) super.尝试移动();
                            }
                        }
                        this.绘制血条();
                        return;
                    }

                    if (
                        this.召唤冷却剩余 <= 0 &&
                        this.当前召唤物列表.length < this.最大召唤物数量
                    ) {
                        if (this.尝试召唤()) {
                            this.召唤冷却剩余 = this.召唤冷却;

                            this.绘制血条();
                            return;
                        }
                    }

                    const 玩家距离 =
                        Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
                    if (玩家距离 < this.基础攻击范围 - 1) {
                        const 逃离点 = this.选择逃离目标(玩家.x, 玩家.y, 15);
                        if (逃离点) {
                            this.目标路径 = this.计算路径(逃离点.x, 逃离点.y);
                            if (this.目标路径) super.尝试移动();
                            else {
                            }
                        } else {
                        }
                    } else {
                        const 旧X = this.x;
                        const 旧Y = this.y;
                        if (Math.random() < 0.3) {
                            const 方向 = [
                                [0, -1],
                                [0, 1],
                                [-1, 0],
                                [1, 0],
                            ];
                            const [dx, dy] =
                                方向[Math.floor(Math.random() * 4)];
                            const 新X = this.x + dx;
                            const 新Y = this.y + dy;
                            if (
                                检查移动可行性(this.x, this.y, 新X, 新Y) &&
                                位置是否可用(新X, 新Y, false)
                            ) {
                                this.恢复背景类型();
                                this.保存新位置类型(新X, 新Y);
                                this.x = 新X;
                                this.y = 新Y;
                                地牢[新Y][新X].类型 = 单元格类型.怪物;
                                地牢[新Y][新X].关联怪物 = this;
                                怪物动画状态.set(this, {
                                    旧逻辑X: 旧X,
                                    旧逻辑Y: 旧Y,
                                    目标逻辑X: this.x,
                                    目标逻辑Y: this.y,
                                    视觉X: 旧X,
                                    视觉Y: 旧Y,
                                    动画开始时间: Date.now(),
                                    正在动画: true,
                                });
                            }
                        }
                    }
                    this.绘制血条();
                }

                选择逃离目标(目标X, 目标Y, 范围) {
                    const 可达点 = [];
                    const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
                    const 已访问 = new Set([`${this.x},${this.y}`]);

                    while (队列.length > 0) {
                        const 当前 = 队列.shift();
                        const 距离目标 =
                            Math.abs(当前.x - 目标X) + Math.abs(当前.y - 目标Y);
                        const 距离自身 = 当前.距离;

                        if (
                            距离自身 <= 范围 &&
                            距离目标 >
                                Math.abs(this.x - 目标X) +
                                    Math.abs(this.y - 目标Y)
                        ) {
                            可达点.push({
                                x: 当前.x,
                                y: 当前.y,
                                距离目标: 距离目标,
                            });
                        }

                        if (当前.距离 >= 范围) continue;

                        const 方向 = [
                            { dx: 1, dy: 0 },
                            { dx: -1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: 0, dy: -1 },
                        ];
                        for (const { dx, dy } of 方向) {
                            const 新X = 当前.x + dx;
                            const 新Y = 当前.y + dy;
                            const 位置键 = `${新X},${新Y}`;

                            if (
                                新X >= 0 &&
                                新X < 地牢大小 &&
                                新Y >= 0 &&
                                新Y < 地牢大小 &&
                                !已访问.has(位置键) &&
                                位置是否可用(新X, 新Y, false)
                            ) {
                                if (检查移动可行性(当前.x, 当前.y, 新X, 新Y)) {
                                    已访问.add(位置键);
                                    队列.push({
                                        x: 新X,
                                        y: 新Y,
                                        距离: 当前.距离 + 1,
                                    });
                                }
                            }
                        }
                    }

                    if (可达点.length > 0) {
                        可达点.sort((a, b) => b.距离目标 - a.距离目标);
                        return 可达点[0];
                    }
                    return null;
                }

                尝试召唤() {
                    const 方向 = [
                        [-1, 0],
                        [1, 0],
                        [0, -1],
                        [0, 1],
                        [-1, -1],
                        [1, -1],
                        [-1, 1],
                        [1, 1],
                    ];
                    let 召唤成功数 = 0;
                    const 需要召唤数 =
                        1 + (this.强化 ? Math.floor(Math.random() * 2) : 0);

                    for (let i = 0; i < 需要召唤数; i++) {
                        let 放置成功 = false;
                        方向.sort(() => Math.random() - 0.5);
                        for (const [dx, dy] of 方向) {
                            const 召唤X = this.x + dx;
                            const 召唤Y = this.y + dy;
                            if (
                                召唤X >= 0 &&
                                召唤X < 地牢大小 &&
                                召唤Y >= 0 &&
                                召唤Y < 地牢大小 &&
                                位置是否可用(召唤X, 召唤Y, false) &&
                                检查直线移动可行性(
                                    this.x,
                                    this.y,
                                    召唤X,
                                    召唤Y,
                                    true
                                )
                            ) {
                                const 新召唤物 = new this.召唤物类({
                                    x: 召唤X,
                                    y: 召唤Y,
                                    房间ID: this.房间ID,
                                    状态: 怪物状态.活跃,
                                    召唤者: this,
                                    强化: this.强化,
                                });
                                放置怪物到单元格(新召唤物, 召唤X, 召唤Y);
                                新召唤物.处理地形效果();
                                this.当前召唤物列表.push(新召唤物);
                                召唤成功数++;
                                放置成功 = true;
                                break;
                            }
                        }
                        if (!放置成功 && i === 0) return false;
                        if (!放置成功 && i > 0) break;
                    }

                    if (召唤成功数 > 0) {
                        添加日志(
                            `${this.类型} 召唤了 ${召唤成功数} 个 幽灵奴仆！`,
                            "信息"
                        );
                        计划显示格子特效(
                            this.当前召唤物列表
                                .slice(-召唤成功数)
                                .map((s) => ({ x: s.x, y: s.y })),
                            "8A2BE2",
                            0
                        );
                        return true;
                    }
                    return false;
                }

                尝试攻击() {
                    if (
                        this.召唤冷却剩余 <= 0 ||
                        this.当前召唤物列表.length < this.最大召唤物数量
                    ) {
                        return false;
                    }

                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        return super.尝试攻击();
                    } else {
                        return super.尝试攻击();
                    }
                }

                受伤(伤害, 来源 = null) {
                    const 原始血量 = this.当前生命值;
                    super.受伤(伤害, 来源);
                    if (原始血量 > 0 && this.当前生命值 <= 0) {
                        this.当前召唤物列表.forEach((仆从) => {
                            if (
                                仆从 &&
                                仆从.当前生命值 > 0 &&
                                Math.random() < 0.7
                            ) {
                                仆从.受伤(仆从.生命值 * 2, "召唤者死亡");
                                添加日志(
                                    `${仆从.类型} 随着 ${this.类型} 的死亡而消散了。`,
                                    "信息"
                                );
                            }
                        });
                        this.当前召唤物列表 = [];
                    }
                }
            }

            class 幽灵仆从 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.幽灵仆从,
                        类型: "幽灵仆从",
                        基础生命值: 10 + (配置.强化 ? 3 : 0),
                        基础攻击力: 2 + (配置.强化 ? 1 : 0),
                        移动率: 1.0,
                        掉落物: null,
                        掉落概率: 0,
                        基础攻击范围: 1,
                        跟踪距离: 10,
                        ...配置,
                    });
                    this.生命周期 = 8 + (配置.强化 ? 4 : 0);
                    this.召唤者 = 配置.召唤者;
                }

                尝试移动() {
                    if (this.当前生命值 <= 0) return;

                    this.生命周期--;
                    if (this.生命周期 <= 0) {
                        this.受伤(this.生命值 * 2, "生命周期结束");
                        添加日志(`${this.类型} 消散了。`, "信息");
                        return;
                    }

                    if (
                        (!this.召唤者 || this.召唤者.当前生命值 <= 0) &&
                        Math.random() < 0.1
                    ) {
                        this.受伤(this.生命值 * 2, "召唤者死亡");
                        return;
                    }

                    this.目标路径 = this.计算路径(玩家.x, 玩家.y);
                    super.尝试移动();
                    this.绘制血条();
                }

                选择目标() {
                    return { x: 玩家.x, y: 玩家.y };
                }
            }

            class 萨满怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.萨满怪物,
                        类型: "萨满怪物",
                        基础生命值: 35 + (配置.强化 ? 10 : 0),
                        基础攻击力: 2 + (配置.强化 ? 1 : 0),
                        移动率: 0.9,
                        掉落物: new 治疗药水({
                            数量: Math.ceil(Math.random() * 3),
                        }),
                        掉落概率: 0.5,
                        基础攻击范围: 1,
                        跟踪距离: 12,
                        ...配置,
                    });
                    this.治疗范围 = 3 + (配置.强化 ? 2 : 0);
                    this.治疗量 = 8 + (配置.强化 ? 4 : 0);
                    this.治疗冷却 = 1 - (配置.强化 ? 1 : 0);
                    this.治疗冷却剩余 = Math.floor(
                        Math.random() * (this.治疗冷却 + 1)
                    );
                    this.优先治疗阈值 = 0.7;
                }

                尝试移动() {
                    const 我的状态 = 怪物状态表.get(this);
                    if (
                        我的状态?.类型 === "冻结" ||
                        我的状态?.类型 === "魅惑"
                    ) {
                        super.尝试移动();
                        this.绘制血条();
                        return;
                    }
                    if (this.当前生命值 <= 0) return;
                    if (this.受伤冻结回合剩余 > 0) {
                        this.受伤冻结回合剩余--;
                        this.绘制血条();
                        return;
                    }

                    if (this.治疗冷却剩余 > 0) {
                        this.治疗冷却剩余--;
                    }

                    const 待治疗友军 = this.寻找待治疗友军();

                    if (待治疗友军 && this.治疗冷却剩余 <= 0) {
                        const 距离 =
                            Math.abs(this.x - 待治疗友军.x) +
                            Math.abs(this.y - 待治疗友军.y);
                        if (距离 <= this.治疗范围) {
                            this.执行治疗(待治疗友军);
                        }
                        this.目标路径 = this.计算目标路径(
                            待治疗友军.x,
                            待治疗友军.y
                        );
                        if (this.目标路径) {
                            super.尝试移动();
                        }

                        this.绘制血条();
                        return;
                    }

                    this.目标路径 = this.计算路径(玩家.x, 玩家.y);
                    super.尝试移动();
                    this.绘制血条();
                }

                尝试攻击() {
                    if (
                        怪物状态表.get(this)?.类型 === "魅惑" ||
                        怪物状态表.get(this)?.类型 === "冻结"
                    )
                        return false;
                    if (this.治疗冷却剩余 > 0) {
                        return;
                    }

                    const 待治疗友军 = this.寻找待治疗友军();
                    if (待治疗友军 && this.治疗冷却剩余 <= 0) {
                        const 距离 =
                            Math.abs(this.x - 待治疗友军.x) +
                            Math.abs(this.y - 待治疗友军.y);
                        if (距离 <= this.治疗范围) {
                            return false;
                        }
                    }

                    return super.尝试攻击();
                }

                寻找待治疗友军() {
                    let 最优先目标 = null;
                    let 最低血量百分比 = this.优先治疗阈值;

                    所有怪物.forEach((友军) => {
                        if (
                            友军 === this ||
                            友军.当前生命值 <= 0 ||
                            友军.当前生命值 >= 友军.生命值 ||
                            怪物状态表.get(友军)?.类型 === "魅惑"
                        )
                            return;
                        const 距离 =
                            Math.abs(this.x - 友军.x) +
                            Math.abs(this.y - 友军.y);

                        if (距离 <= this.治疗范围 + 3) {
                            const 血量百分比 = 友军.当前生命值 / 友军.生命值;
                            if (血量百分比 < 最低血量百分比) {
                                最低血量百分比 = 血量百分比;
                                最优先目标 = 友军;
                            }
                        }
                    });
                    return 最优先目标;
                }

                执行治疗(目标) {
                    const 治疗量 = this.治疗量;
                    目标.当前生命值 = Math.min(
                        目标.生命值,
                        目标.当前生命值 + 治疗量
                    );
                    this.治疗冷却剩余 = this.治疗冷却;
                    添加日志(
                        `${this.类型} 治疗了 ${目标.类型}，恢复了 ${治疗量} 点生命！`,
                        "信息"
                    );
                    目标.绘制血条();
                    目标.接受萨满治疗 = true;
                }
            }

            class 大史莱姆怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.大史莱姆,
                        类型: "大史莱姆",
                        基础生命值: 40 + (配置.强化 ? 20 : 0),
                        基础攻击力: 5 + (配置.强化 ? 2 : 0),
                        移动率: 0.6, // 移动较慢
                        掉落物: new 金币({
                            数量: Math.floor(Math.random() * 8) + 3,
                        }),
                        掉落概率: 0.8,
                        攻击冷却: 1,
                        ...配置,
                    });
                    this.分裂数量 = 2 + (配置.强化 ? 2 : 0);
                }

                尝试攻击() {
                    if (super.尝试攻击()) {
                        // 攻击成功后施加缓慢效果
                        if (怪物状态表.get(this)?.类型 === "魅惑") {
                            if (this.魅惑目标怪物) {
                                new 状态效果(
                                    "缓慢",
                                    "#888888",
                                    "慢",
                                    5,
                                    null,
                                    null,
                                    this.魅惑目标怪物
                                );
                            }
                        } else {
                            new 状态效果(
                                "缓慢",
                                "#888888",
                                图标映射.缓慢,
                                5,
                                5
                            ); // 假设缓慢持续5回合
                        }
                        return true;
                    }
                    return false;
                }

                受伤(伤害, 来源 = null) {
                    const 原始血量 = this.当前生命值;
                    super.受伤(伤害, 来源);
                    // 如果死亡，则分裂
                    if (原始血量 > 0 && this.当前生命值 <= 0) {
                        this.分裂();
                    }
                }

                分裂() {
                    let 成功分裂数 = 0;
                    const 方向 = [
                        { dx: -1, dy: 0 },
                        { dx: 1, dy: 0 },
                        { dx: 0, dy: -1 },
                        { dx: 0, dy: 1 },
                        { dx: -1, dy: -1 },
                        { dx: 1, dy: -1 },
                        { dx: -1, dy: 1 },
                        { dx: 1, dy: 1 },
                    ];

                    for (let i = 0; i < this.分裂数量; i++) {
                        let 放置成功 = false;
                        for (const { dx, dy } of 方向) {
                            const 新X = this.x + dx;
                            const 新Y = this.y + dy;
                            if (位置是否可用(新X, 新Y)) {
                                let 史莱姆;
                                if (Math.random() < 0.15) {
                                    史莱姆 = new 大史莱姆怪物({
                                        x: 新X,
                                        y: 新Y,
                                        房间ID: this.房间ID,
                                        状态: 怪物状态.活跃, // 出生即活跃
                                        强化: this.强化, // 继承强化状态
                                    });
                                } else {
                                    史莱姆 = new 小史莱姆怪物({
                                        x: 新X,
                                        y: 新Y,
                                        房间ID: this.房间ID,
                                        状态: 怪物状态.活跃, // 出生即活跃
                                        强化: this.强化, // 继承强化状态
                                    });
                                }
                                放置怪物到单元格(史莱姆, 新X, 新Y);
                                成功分裂数++;
                                放置成功 = true;
                                // 移除已用方向，避免重复放置
                                方向.splice(
                                    方向.findIndex(
                                        (d) => d.dx === dx && d.dy === dy
                                    ),
                                    1
                                );
                                break;
                            }
                        }
                        // 如果所有方向都试过还失败，就不再尝试分裂更多
                        if (!放置成功) break;
                    }
                    if (成功分裂数 > 0) {
                        添加日志(
                            `${this.类型} 分裂成了 ${成功分裂数} 个小史莱姆！`,
                            "警告"
                        );
                    }
                }
            }

            class 小史莱姆怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.小史莱姆,
                        类型: "小史莱姆",
                        基础生命值: 15 + (配置.强化 ? 10 : 0),
                        基础攻击力: 3 + (配置.强化 ? 1 : 0),
                        移动率: 1, // 移动较快
                        掉落物: new 金币({
                            数量: Math.floor(Math.random() * 3) + 1,
                        }),
                        掉落概率: 0.5,
                        攻击冷却: 0, // 攻击更快
                        基础攻击范围: 1,
                        基础移动距离: 2, // 可以移动两格
                        ...配置,
                    });
                }

                尝试攻击() {
                    if (super.尝试攻击()) {
                        if (怪物状态表.get(this)?.类型 === "魅惑") {
                            if (this.魅惑目标怪物) {
                                new 状态效果(
                                    "缓慢",
                                    "#888888",
                                    图标映射.缓慢,
                                    3,
                                    null,
                                    null,
                                    this.魅惑目标怪物
                                );
                            }
                        } else {
                            new 状态效果(
                                "缓慢",
                                "#888888",
                                图标映射.缓慢,
                                3,
                                3
                            ); // 缓慢持续3回合
                        }
                        return true;
                    }
                    return false;
                }
            }

            class 瞬移怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.瞬移怪物,
                        类型: "瞬移怪物",
                        基础生命值: 25 + (配置.强化 ? 15 : 0),
                        基础攻击力: 2 + (配置.强化 ? 3 : 0),
                        移动率: 0.85,
                        掉落物: new 跃迁卷轴({
                            数量: 1,
                            强化: 配置.强化 ?? false,
                        }),
                        掉落概率: 0.4,
                        基础攻击范围: 2,
                        受伤冻结回合: 0, // 受伤不冻结，可能直接瞬移走
                        ...配置,
                    });
                    this.瞬移几率 = 0.6 + (配置.强化 ? 0.2 : 0);
                    this.受击瞬移几率 = 0.4 + (配置.强化 ? 0.2 : 0);
                }

                尝试移动() {
                    const 我的状态 = 怪物状态表.get(this);
                    if (我的状态?.类型 === "冻结") return;

                    if (this.当前生命值 <= 0) return;
                    if (房间地图[玩家.y][玩家.x] === 0) return; // 教程层不动

                    // 魅惑状态下的移动
                    if (我的状态?.类型 === "魅惑") {
                        const 目标 = this.寻找最近怪物目标();
                        if (目标 && Math.random() < this.瞬移几率) {
                            this.瞬移到(目标.x, 目标.y, 5); // 尝试瞬移到目标怪物附近
                        } else if (目标) {
                            // 不瞬移则正常寻路移动
                            this.目标路径 = this.计算路径(目标.x, 目标.y);
                            super.尝试移动(); // 调用基类移动
                        }
                        this.绘制血条();
                        return; // 处理完魅惑移动后返回
                    }

                    // 正常状态下的移动
                    const 玩家距离 =
                        Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
                    if (
                        玩家距离 <= this.跟踪距离 &&
                        Math.random() < this.瞬移几率
                    ) {
                        this.瞬移到(玩家.x, 玩家.y, 3); // 尝试瞬移到玩家附近
                    } else {
                        // 不瞬移则正常寻路移动
                        if (this.目标路径.length > 0 && this.追击玩家中) {
                            super.尝试移动(); // 调用基类移动
                        }
                    }
                    this.绘制血条();
                }

                尝试攻击() {
                    if (怪物状态表.get(this)?.类型 === "冻结") return false;
                    if (this.攻击冷却回合剩余 > 0) {
                        this.攻击冷却回合剩余 -= 1;
                        return false;
                    }

                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        const { x: 目标X, y: 目标Y } = this.寻找最近怪物目标();
                        this.通向目标路径 = this.计算目标路径(目标X, 目标Y);
                        if (this.通向目标路径 === null) return false;
                        if (this.通向目标路径.length <= this.攻击范围) {
                            if (this.魅惑目标怪物) {
                                this.魅惑目标怪物.受伤(this.攻击力, this);
                                this.攻击冷却回合剩余 = this.攻击冷却;
                                计划显示格子特效(this.通向目标路径);
                                return true;
                            }
                        }
                    } else {
                        this.通向目标路径 = this.计算目标路径(玩家.x, 玩家.y);
                        if (this.通向目标路径 === null) return false;
                        if (this.通向目标路径.length <= this.攻击范围) {
                            伤害玩家(this.攻击力, this);
                            this.攻击冷却回合剩余 = this.攻击冷却;
                            计划显示格子特效(this.通向目标路径);
                            return true;
                        }
                    }
                    return false;
                }

                瞬移到(目标X, 目标Y, 范围) {
                    const 候选位置 = [];
                    const 搜索范围 = 范围 + 2; // 稍微扩大搜索范围以找到更多候选点

                    // 1. 查找目标点周围的可用格子
                    for (let dx = -范围; dx <= 范围; dx++) {
                        for (let dy = -范围; dy <= 范围; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const 新X = 目标X + dx;
                            const 新Y = 目标Y + dy;
                            if (
                                新X >= 0 &&
                                新X < 地牢大小 &&
                                新Y >= 0 &&
                                新Y < 地牢大小 &&
                                位置是否可用(新X, 新Y, false)
                            ) {
                                候选位置.push({ x: 新X, y: 新Y });
                            }
                        }
                    }

                    // 2. 筛选出 BFS 可达的格子
                    const 可达位置 = 候选位置.filter((pos) =>
                        检查直线移动可行性(this.x, this.y, pos.x, pos.y, true)
                    );

                    if (可达位置.length > 0) {
                        const 目标位置 =
                            可达位置[
                                Math.floor(Math.random() * 可达位置.length)
                            ];
                        // 保存旧位置用于恢复单元格类型
                        const 旧X = this.x;
                        const 旧Y = this.y;

                        this.恢复背景类型(); // 恢复旧位置单元格
                        this.保存新位置类型(目标位置.x, 目标位置.y); // 保存新位置背景类型
                        this.x = 目标位置.x;
                        this.y = 目标位置.y;
                        地牢[this.y][this.x].类型 = 单元格类型.怪物;
                        地牢[this.y][this.x].关联怪物 = this;
                        this.处理地形效果();
                        怪物动画状态.set(this, {
                            旧逻辑X: 旧X,
                            旧逻辑Y: 旧Y,
                            目标逻辑X: this.x,
                            目标逻辑Y: this.y,
                            视觉X: 旧X,
                            视觉Y: 旧Y,
                            动画开始时间: Date.now(),
                            正在动画: true,
                        });
                        添加日志(`${this.类型} 瞬移了！`, "信息");
                    }
                }
                瞬移逃跑() {
                    const 范围 = 8; // 逃跑瞬移范围更大
                    const 候选位置 = [];
                    // 1. 查找自身周围的可用格子作为逃跑候选
                    for (let dx = -范围; dx <= 范围; dx++) {
                        for (let dy = -范围; dy <= 范围; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const 新X = this.x + dx;
                            const 新Y = this.y + dy;
                            if (
                                新X >= 0 &&
                                新X < 地牢大小 &&
                                新Y >= 0 &&
                                新Y < 地牢大小 &&
                                位置是否可用(新X, 新Y, false)
                            ) {
                                const 距离玩家 =
                                    Math.abs(新X - 玩家.x) +
                                    Math.abs(新Y - 玩家.y);
                                const 距离自身 = Math.abs(dx) + Math.abs(dy);
                                // 优先选择远离玩家的位置
                                if (
                                    距离玩家 >
                                    Math.abs(this.x - 玩家.x) +
                                        Math.abs(this.y - 玩家.y)
                                ) {
                                    候选位置.push({
                                        x: 新X,
                                        y: 新Y,
                                        距离玩家: 距离玩家,
                                        距离自身: 距离自身,
                                    });
                                }
                            }
                        }
                    }

                    // 2. 筛选出 BFS 可达的逃跑位置
                    const 可达逃跑位置 = 候选位置.filter(
                        (pos) =>
                            检查直线移动可行性(
                                this.x,
                                this.y,
                                pos.x,
                                pos.y,
                                true
                            ) // 允许较长路径
                    );

                    if (可达逃跑位置.length > 0) {
                        // 3. 从可达位置中选择最优（最远）
                        可达逃跑位置.sort((a, b) => b.距离玩家 - a.距离玩家); // 按距离玩家远近排序
                        const 目标位置 = 可达逃跑位置[0]; // 选择最远的

                        // 保存旧位置
                        const 旧X = this.x;
                        const 旧Y = this.y;

                        this.恢复背景类型(); // 恢复旧位置
                        this.保存新位置类型(目标位置.x, 目标位置.y); // 保存新位置
                        this.x = 目标位置.x;
                        this.y = 目标位置.y;
                        地牢[this.y][this.x].类型 = 单元格类型.怪物;
                        地牢[this.y][this.x].关联怪物 = this;
                        添加日志(`${this.类型} 瞬移逃跑了！`, "信息");
                        this.处理地形效果();
                        怪物动画状态.set(this, {
                            旧逻辑X: 旧X,
                            旧逻辑Y: 旧Y,
                            目标逻辑X: this.x,
                            目标逻辑Y: this.y,
                            视觉X: 旧X,
                            视觉Y: 旧Y,
                            动画开始时间: Date.now(),
                            正在动画: true,
                        });
                    }
                    // 如果没有可达的逃跑位置，则不瞬移
                }

                受伤(伤害, 来源 = null) {
                    const 原始血量 = this.当前生命值;

                    // 有几率瞬移逃跑
                    if (
                        原始血量 > 0 &&
                        this.当前生命值 > 0 &&
                        Math.random() < this.受击瞬移几率
                    ) {
                        this.瞬移逃跑();
                        return;
                    }
                    super.受伤(伤害, 来源);
                }
            }

            class 伪装怪物 extends 怪物 {
                constructor(配置 = {}) {
                    const 伪装物品列表 = [
                        { 图标: 图标映射.药水, 名称: "药水" },
                        { 图标: 图标映射.卷轴, 名称: "卷轴" },
                        { 图标: 图标映射.金币, 名称: "金币" },
                    ];
                    let 伪装 =
                        伪装物品列表[
                            Math.floor(Math.random() * 伪装物品列表.length)
                        ];

                    if (配置.伪装成) {
                        伪装 = {
                            图标: 图标映射[配置.伪装成],
                            名称: 配置.伪装成,
                        };
                    }

                    super({
                        类型: "伪装怪物",
                        图标: 图标映射.伪装怪物,
                        基础生命值: 30 + (配置.强化 ? 10 : 0),
                        基础攻击力: 7 + (配置.强化 ? 3 : 0),
                        移动率: 0, // 初始不动
                        掉落物: new 隐身药水({}),
                        掉落概率: 0.9,
                        基础攻击范围: 1,
                        ...配置,
                    });
                    this.伪装状态 = true;
                    this.图标 = 伪装.图标;
                    this.触发距离 = 1;
                    this.偷袭伤害 = 12 + (配置.强化 ? 8 : 0);
                }
                尝试移动() {
                    if (this.当前生命值 <= 0) return;

                    if (this.伪装状态) {
                        const 玩家距离 =
                            Math.abs(this.x - 玩家.x) +
                            Math.abs(this.y - 玩家.y);
                        if (玩家距离 <= this.触发距离) {
                            this.解除伪装();
                        } else {
                            return;
                        }
                    }

                    if (!this.伪装状态) {
                        super.尝试移动();
                    }
                    this.绘制血条();
                }

                解除伪装() {
                    if (!this.伪装状态) return;
                    显示通知(`一个${this.类型}显现了！`, "警告");
                    添加日志(
                        `伪装的 ${this.图标} 原来是 ${this.类型}！`,
                        "警告"
                    );
                    this.伪装状态 = false;
                    this.图标 = 图标映射.伪装怪物;
                    this.移动率 = 0.7;
                    this.状态 = 怪物状态.活跃;

                    const 玩家距离 =
                        Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
                    if (玩家距离 <= 2) {
                    伤害玩家(this.偷袭伤害, this);
                    显示通知(`它对你发动了突然袭击！`, "错误");
                    }

                    this.绘制血条();
                    绘制();
                }

                绘制血条(隐藏血条 = false) {
                    if (!this.伪装状态) {
                        super.绘制血条(隐藏血条);
                    } else if (this.血条元素) {
                        this.血条元素.style.display = "none";
                    }
                }

                尝试攻击() {
                    if (!this.伪装状态) {
                        return super.尝试攻击();
                    }
                    return false;
                }

                受伤(伤害, 来源 = null) {
                    if (this.伪装状态) {
                        this.解除伪装();
                    }
                    super.受伤(伤害, 来源);
                }
            }

            class 炸弹怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        基础移动距离: 2,
                        图标: 图标映射.炸弹怪物,
                        类型: "炸弹怪物",
                        掉落物: new 炸弹({
                            数量: Math.floor(Math.random() * 5) + 1,
                            强化: 配置.强化 || false,
                        }),
                        房间ID: 配置.房间ID || null,
                        强化: 配置.强化 || false,
                        x: 配置.x || null,
                        y: 配置.y || null,
                        状态: 配置.状态 || 怪物状态.休眠,
                        生命值: 配置.基础生命值 || 45,
                        基础攻击力: 配置.基础攻击力 || 3,
                    });
                    this.携带炸弹 = true;
                }

                尝试移动() {
                    super.尝试移动();
                    if (this.携带炸弹) {
                        const 距离 =
                            Math.abs(this.x - 玩家.x) +
                            Math.abs(this.y - 玩家.y); //不想增加魅惑逻辑了...
                        if (距离 <= this.攻击范围) {
                            this.放置炸弹();

                            this.基础移动距离 = 1; // 恢复普通怪物
                            if (当前层数 != 8) {
                                this.携带炸弹 = false;
                                this.图标 = 图标映射.怪物;
                            }
                        }
                    }
                }

                放置炸弹() {
                    if (当前天气效果.includes("严寒")) {
                    const 扔出炸弹 = new 炸弹({ 能否拾起: true, 颜色索引: 4 });
                    let 目标 = {};
                    目标 = 玩家放置物品(扔出炸弹,true);
                    return;
                    }
                    const 扔出炸弹 = new 炸弹({ 能否拾起: false, 颜色索引: 4 });
                    let 目标 = {};
                    目标 = 玩家放置物品(扔出炸弹);
                    if (目标.x !== null && 目标.y !== null) {
                        扔出炸弹.使用(false, 目标.x, 目标.y);
                    }
                }
            }
            class 旋风怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.旋风怪物,
                        类型: "旋风怪物",
                        基础生命值: 38 + (配置.强化 ? 18 : 0),
                        基础攻击力: 3 + (配置.强化 ? 1 : 0), // 直接攻击力不高
                        移动率: 0.75,
                        掉落物: new 金币({
                            数量: Math.floor(Math.random() * 10) + 5,
                        }),
                        掉落概率: 0.6,
                        基础攻击范围: 1, // 主要靠旋风
                        跟踪距离: 15,
                        ...配置,
                    });
                    this.召唤冷却 = 4 + (配置.强化 ? -1 : 0); // 召唤间隔
                    this.召唤冷却剩余 = Math.floor(
                        Math.random() * (this.召唤冷却 + 1)
                    );
                    this.最大召唤物数量 = 1 + (配置.强化 ? 1 : 0); // 同时存在的旋风数量
                    this.当前召唤物列表 = [];
                    this.召唤物类 = 旋风; // 召唤旋风怪物
                }

                尝试移动() {
                    const 我的状态 = 怪物状态表.get(this);
                    if (我的状态?.类型 === "冻结") return;

                    if (this.当前生命值 <= 0) return;

                    // 清理已消失的召唤物
                    this.当前召唤物列表 = this.当前召唤物列表.filter(
                        (旋) => 旋 && 旋.当前生命值 > 0
                    );

                    if (this.受伤冻结回合剩余 > 0) {
                        this.受伤冻结回合剩余--;
                        this.绘制血条();
                        return;
                    }

                    // 冷却处理
                    if (this.召唤冷却剩余 > 0) {
                        this.召唤冷却剩余--;
                    }

                    // 尝试召唤
                    if (
                        this.召唤冷却剩余 <= 0 &&
                        this.当前召唤物列表.length < this.最大召唤物数量
                    ) {
                        if (this.尝试召唤()) {
                            this.召唤冷却剩余 = this.召唤冷却;
                            this.绘制血条();
                            return; // 召唤成功后本回合可能不再移动或攻击
                        }
                    }

                    super.尝试移动();
                    this.绘制血条();
                }

                尝试召唤() {
                    const 方向 = [
                        [-1, 0],
                        [1, 0],
                        [0, -1],
                        [0, 1],
                        [-1, -1],
                        [1, -1],
                        [-1, 1],
                        [1, 1],
                    ];
                    let 召唤成功数 = 0;
                    const 需要召唤数 = 1; // 一次只召唤一个

                    for (let i = 0; i < 需要召唤数; i++) {
                        let 放置成功 = false;
                        方向.sort(() => Math.random() - 0.5); // 随机方向
                        for (const [dx, dy] of 方向) {
                            const 召唤X = this.x + dx;
                            const 召唤Y = this.y + dy;
                            if (
                                召唤X >= 0 &&
                                召唤X < 地牢大小 &&
                                召唤Y >= 0 &&
                                召唤Y < 地牢大小 &&
                                位置是否可用(召唤X, 召唤Y, false)
                            ) {
                                const 新召唤物 = new this.召唤物类({
                                    x: 召唤X,
                                    y: 召唤Y,
                                    房间ID: this.房间ID,
                                    状态: 怪物状态.活跃,
                                    强化: this.强化,
                                });
                                放置怪物到单元格(新召唤物, 召唤X, 召唤Y);
                                this.当前召唤物列表.push(新召唤物);
                                召唤成功数++;
                                放置成功 = true;
                                break;
                            }
                        }
                        if (!放置成功) return false; // 无法放置则召唤失败
                    }

                    if (召唤成功数 > 0) {
                        添加日志(`${this.类型} 释放了一个旋风！`, "信息");
                        计划显示格子特效(
                            this.当前召唤物列表
                                .slice(-召唤成功数)
                                .map((s) => ({ x: s.x, y: s.y })),
                            "ADD8E6",
                            0
                        ); // 淡蓝色特效
                        return true;
                    }
                    return false;
                }

                // 可以保留基础攻击，或者让它完全依赖旋风
                尝试攻击() {
                    super.尝试攻击();
                    return true; // 目前主要靠旋风
                }

                受伤(伤害, 来源 = null) {
                    const 原始血量 = this.当前生命值;
                    super.受伤(伤害, 来源);
                    // 死亡时驱散场上所有由它召唤的旋风（可选）
                    if (原始血量 > 0 && this.当前生命值 <= 0) {
                        this.当前召唤物列表.forEach((旋) => {
                            if (旋 && 旋.当前生命值 > 0) {
                                旋.受伤(旋.生命值 * 2, "召唤者死亡"); // 强制移除
                            }
                        });
                        this.当前召唤物列表 = [];
                    }
                }
            }
            class 旋风 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.旋风,
                        类型: "旋风",
                        基础生命值: 5 + (配置.强化 ? 5 : 0), // 很脆弱
                        基础攻击力: 0, // 不直接攻击
                        移动率: 1.0, // 移动较快
                        掉落概率: 0,
                        基础攻击范围: 0, // 接触触发
                        跟踪距离: 30, // 追踪范围大
                        受伤冻结回合: 0, // 不受冻结影响移动
                        基础移动距离: 2, // 移动快
                        ...配置,
                    });
                    this.生命周期 = 10 + (配置.强化 ? 5 : 0); // 存在时间
                }

                尝试移动() {
                    if (this.当前生命值 <= 0) return;

                    // 生命周期处理
                    this.生命周期--;
                    if (this.生命周期 <= 0) {
                        this.受伤(this.生命值 * 2, "生命周期结束"); // 时间到了消失
                        添加日志(`${this.类型} 消散了。`, "信息");
                        this.移除自身();
                        return;
                    }
                    let { x, y } = this.选择目标();
                    // 碰撞检测与效果触发
                    if (this.x === x && this.y === y) {
                        this.触发效果();
                    }
                    this.目标路径 = this.计算目标路径(x, y);
                    if (this.当前生命值 <= 0) return;
                    if (房间地图[玩家.y][玩家.x] === 0) return;
                    if (
                        this.目标路径.length === 0 ||
                        (Math.random() > this.移动率 && !切换动画) ||
                        this.跟踪距离 < this.目标路径.length
                    ) {
                        this.追击玩家中 = false;
                        return;
                    }

                    const 旧X = this.x;
                    const 旧Y = this.y;
                    const 下一步 =
                        this.目标路径[
                            Math.min(
                                this.移动距离 - 1,
                                this.目标路径.length - 1
                            )
                        ];
                    if (下一步) {
                        const dx = 下一步.x - this.x;
                        const dy = 下一步.y - this.y;

                        // 规划实际可移动位置
                        const 最终位置 = this.规划移动路径(dx, dy);
                        if (!最终位置) return;
                        this.恢复背景类型();
                        this.保存新位置类型(最终位置.x, 最终位置.y);
                        this.x = 最终位置.x;
                        this.y = 最终位置.y;
                        地牢[this.y][this.x].类型 = 单元格类型.怪物;
                        地牢[this.y][this.x].关联怪物 = this;
                        怪物动画状态.set(this, {
                            旧逻辑X: 旧X,
                            旧逻辑Y: 旧Y,
                            目标逻辑X: this.x,
                            目标逻辑Y: this.y,
                            视觉X: 旧X,
                            视觉Y: 旧Y,
                            动画开始时间: Date.now(),
                            正在动画: true,
                        });
                    }
                    if (this.x === x && this.y === y) {
                        this.触发效果();
                        return;
                    }
                    this.绘制血条(true); // 强制不显示血条
                }

                绘制血条(隐藏血条 = true) {
                    // 旋风不显示血条
                    if (this.血条元素) {
                        this.血条元素.style.display = "none";
                    }
                }

                尝试攻击() {
                    let { x, y } = this.选择目标();
                    if (this.x === x && this.y === y) {
                        this.触发效果();
                    }
                    return false;
                }
                获得效果(状态效果) {
                    状态效果.移除状态();
                    return false;
                }
                触发效果() {
                    添加日志(`${this.类型} 撞到了你，释放了气流！`, "警告");
                    this.受伤(this.生命值 * 2, "效果触发");
                    this.移除自身();
                    const 中心X = this.x;
                    const 中心Y = this.y;

                    // 在3x3区域生成旋风物品
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            // if (dx === 0 && dy === 0) continue; // 不在中心生成
                            const x = 中心X + dx;
                            const y = 中心Y + dy;

                            if (
                                x >= 0 &&
                                x < 地牢大小 &&
                                y >= 0 &&
                                y < 地牢大小
                            ) {
                                // 检查目标格子是否可放置（非墙、非上锁门）
                                const 单元格 = 地牢[y][x];
                                if (
                                    单元格 &&
                                    ![
                                        单元格类型.墙壁,
                                        单元格类型.上锁的门,
                                    ].includes(单元格.背景类型) &&
                                    !单元格.关联物品
                                ) {
                                    const 旋风物品实例 = new 旋风物品({});
                                    // 使用放置物品到单元格，并将其添加到所有计时器列表
                                    if (放置物品到单元格(旋风物品实例, x, y)) {
                                        旋风物品实例.x = x;
                                        旋风物品实例.y = y;
                                        所有计时器.push(旋风物品实例); // 添加到计时器列表
                                        计划显示格子特效(
                                            [{ x: x, y: y }],
                                            "90EE90"
                                        ); // 显示生成特效
                                    }
                                }
                            }
                        }
                    }
                    new 状态效果(
                        "眩晕",
                        效果颜色编号映射[效果名称编号映射.眩晕],
                        图标映射.眩晕,
                        2
                    );
                }

                移除自身() {
                    this.恢复背景类型();
                    if (this.血条元素) this.血条元素.remove();
                    所有怪物 = 所有怪物.filter((m) => m !== this);
                    绘制(); // 更新画面
                }
            }
            class 盔甲怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.盔甲怪物,
                        类型: "盔甲怪物",
                        强化: 配置.强化 || false,
                        掉落物: new 钢制板甲({
                            数量: 1,
                        }),
                        掉落概率: 0.5,
                        房间ID: 配置.房间ID || null,
                        x: 配置.x || null,
                        y: 配置.y || null,
                        状态: 配置.状态 || 怪物状态.休眠,
                        基础生命值: 配置.基础生命值 || 35,
                    });
                    if (this.掉落物) {
                        this.尝试添加随机词条到掉落物(this.掉落物);
                    }
                }
            }
            class 敏捷怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        基础移动距离: 3,
                        跟踪距离: 40,
                        图标: 图标映射.敏捷怪物,
                        类型: "敏捷怪物",
                        强化: 配置.强化 || false,
                        掉落物: new 迅捷卷轴({
                            数量: 1,
                        }),
                        掉落概率: 0.3,
                        房间ID: 配置.房间ID || null,
                        x: 配置.x || null,
                        y: 配置.y || null,
                        状态: 配置.状态 || 怪物状态.休眠,
                        基础生命值: 配置.基础生命值 || 28,
                        基础攻击力: 配置.基础攻击力 || 4,
                        移动率: 配置.移动率 || 0.85,
                    });
                }
            }
            class 远攻怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.远攻怪物,
                        类型: "远攻怪物",
                        掉落物: new 橡木法杖({
                            数量: 1,
                        }),
                        掉落概率: 0.3,
                        房间ID: 配置.房间ID || null,
                        x: 配置.x || null,
                        y: 配置.y || null,
                        状态: 配置.状态 || 怪物状态.休眠,
                        强化: 配置.强化 || false,
                        基础生命值: 配置.基础生命值 || 35,
                        基础攻击力: 配置.基础攻击力 || 3,
                        移动率: 配置.移动率 || 0.7,
                        基础攻击范围: 3,
                        跟踪距离: 25,
                    });
                    if (this.掉落物) {
                        this.尝试添加随机词条到掉落物(this.掉落物);
                    }
                }
            }
            class 仙人掌怪物 extends 怪物 {
                constructor(配置 = {}) {
                    const 随机品质 =
                        1 + Math.floor(Math.random() * Math.random() * 4);
                    const 荆棘卷轴实例 = new 附魔卷轴({
                        品质: 随机品质, // 使用随机品质
                        已解锁: true, // 默认掉落已鉴定
                        强化: 配置.强化 || false, // 可选：继承强化状态
                    });

                    // 手动设置附魔效果为荆棘
                    const 效果名 = "荆棘附魔";
                    const 效果索引 = 荆棘卷轴实例.效果名.indexOf(效果名);

                    if (效果索引 !== -1) {
                        荆棘卷轴实例.附魔效果 = 荆棘卷轴实例.附魔池[效果索引]; // 设置效果函数
                        荆棘卷轴实例.效果描述 = `为防御装备附加${效果名} ${"I".repeat(
                            随机品质
                        )}级`; // 更新描述
                        荆棘卷轴实例.名称 = `${效果名}卷轴`; // 可以考虑更新名称
                        荆棘卷轴实例.颜色索引 = 随机品质 - 1; // 根据品质更新颜色
                    }
                    super({
                        图标: 图标映射.仙人掌怪物,
                        类型: "仙人掌怪物",
                        掉落物: 荆棘卷轴实例,
                        掉落概率: 0.3 + (配置.强化 ? 0.15 : 0),
                        房间ID: 配置.房间ID || null,
                        x: 配置.x || null,
                        y: 配置.y || null,
                        状态: 配置.状态 || 怪物状态.休眠,
                        强化: 配置.强化 || false,
                        生命值: 配置.基础生命值 || 30,
                        基础攻击力: 配置.基础攻击力 || 3,
                        移动率: 配置.移动率 || 0.7,
                    });
                }
                受伤(伤害, 来源 = null) {
                    if (来源 === "玩家") {
                        伤害玩家(this.攻击力, this);
                    }
                    super.受伤(伤害, 来源);
                }
            }
            class 冰冻怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.冰冻怪物,
                        类型: "冰冻怪物",
                        掉落物: new 冰盾({
                            数量: 1,
                        }),
                        掉落概率: 配置.掉落概率 || 0.3,
                        房间ID: 配置.房间ID || null,
                        x: 配置.x || null,
                        y: 配置.y || null,
                        状态: 配置.状态 || 怪物状态.休眠,
                        强化: 配置.强化 || false,
                        基础生命值: 配置.基础生命值 || 23,
                        基础攻击力: 配置.基础攻击力 || 3,
                        移动率: 配置.移动率 || 0.7,
                        基础攻击范围: 1,
                        跟踪距离: 25,
                        攻击冷却: 4,
                    });
                    if (this.掉落物) {
                        this.尝试添加随机词条到掉落物(this.掉落物);
                    }
                }
                尝试攻击() {
                    if (
                        玩家状态.some((s) => s.类型 === "冻结") &&
                        this.攻击冷却回合剩余 === 0
                    ) {
                        //倘若已有效果则不攻击，缓冲攻击冷却给其它怪物起辅助作用
                        return false;
                    }
                    if (super.尝试攻击()) {
                        if (怪物状态表.get(this)?.类型 === "魅惑") {
                            new 状态效果(
                                "冻结",
                                "#2196F3",
                                "冻",
                                3,
                                null,
                                null,
                                this.魅惑目标怪物
                            );
                        } else if (
                            !Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                                玩家装备.get(
                                    当前装备页 * 装备栏每页装备数 + i + 1
                                )
                            )
                                .filter((v) => v != null)
                                .some((item) => item.名称 === "冰盾")
                        ) {
                            new 状态效果(
                                "冻结",
                                "#2196F3",
                                图标映射.冰冻怪物,
                                3,
                                3
                            ); // 添加冻结效果
                        }
                    }
                }
                获得效果(状态效果) {
                    if (状态效果.类型 === "冻结") {
                        状态效果.移除状态();
                        return false;
                    }
                    if (状态效果.类型 === "火焰") {
                        this.恢复背景类型();
                        
                        所有怪物 = 所有怪物.filter((m) => m !== this);
                        const 新怪物 = new 怪物({
                            x: this.x,
                            y: this.y,
                            当前生命值: this.当前生命值,
                            基础生命值: this.生命值,
                        });
                        放置怪物到单元格(新怪物, this.x, this.y);
                        新怪物.绘制血条();
                    }
                    return true;
                }
            }
            class 米诺陶 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.米诺陶,
                        类型: "米诺陶",
                        基础生命值: 100 + (配置.强化 ? 150 : 0),
                        基础攻击力: 6 + (配置.强化 ? 5 : 0),
                        移动率: 0.9,
                        掉落概率: 1.0,
                        基础攻击范围: 1,
                        跟踪距离: 1000,
                        基础移动距离: 1,
                        攻击冷却: 1,
                        ...配置,
                    });
                    this.技能冷却 = {
                        高速冲撞: 12,
                        喷火: 5,
                        喷射毒液: 10,
                        战争践踏: 8,
                        异墙凸起: 12,
                    };
                    this.技能冷却剩余 = {
                        高速冲撞: 0,
                        喷火: Math.floor(Math.random() * 3),
                        喷射毒液: Math.floor(Math.random() * 4),
                        战争践踏: Math.floor(Math.random() * 5),
                        异墙凸起: Math.floor(Math.random() * 8),
                    };
                }
                计算路径(目标X, 目标Y) {
                    const 路径 = [];
                    const dx = 目标X - this.x;
                    const dy = 目标Y - this.y;

                    if (dx === 0 && dy === 0) {
                        return 路径;
                    }

                    const 步数 = Math.max(Math.abs(dx), Math.abs(dy));
                    const x增量 = dx / 步数;
                    const y增量 = dy / 步数;

                    let 当前X = this.x;
                    let 当前Y = this.y;

                    for (let i = 0; i < 步数; i++) {
                        当前X += x增量;
                        当前Y += y增量;
                        const 下一个点X = Math.round(当前X);
                        const 下一个点Y = Math.round(当前Y);

                        if (路径.length > 0) {
                            const 上一个点 = 路径[路径.length - 1];
                            if (
                                上一个点.x === 下一个点X &&
                                上一个点.y === 下一个点Y
                            ) {
                                continue;
                            }
                        }
                        路径.push({ x: 下一个点X, y: 下一个点Y });
                    }

                    return 路径;
                }

                计算目标路径(x, y) {
                    return this.计算路径(x, y);
                }

                更新技能冷却() {
                    for (const 技能 in this.技能冷却剩余) {
                        if (
                            this.技能冷却剩余[技能] > 0 &&
                            Math.random() < 0.5
                        ) {
                            this.技能冷却剩余[技能]--;
                        }
                    }
                }

                受伤(伤害, 来源 = null) {
                    if (来源 === "火焰" || 来源 === "中毒") {
                        return;
                    }

                    if (this.当前生命值 > 0) {
                        this.当前生命值 -= 伤害;
                        if (中文模式) this.触发受击动画();

                        if (this.当前生命值 <= 0) {
                            const deathX = this.x,
                                deathY = this.y;
                            this.恢复背景类型();
                            if (this.血条元素) this.血条元素.remove();
                            所有怪物 = 所有怪物.filter((m) => m !== this);

                            const 附近位置 = [
                                [0, 0],
                                [0, 1],
                                [0, -1],
                                [1, 0],
                                [-1, 0],
                                [1, 1],
                                [1, -1],
                                [-1, 1],
                                [-1, -1],
                            ];
                            const 可用位置列表 = [];

                            for (const [dx, dy] of 附近位置) {
                                const 检查X = deathX + dx;
                                const 检查Y = deathY + dy;
                                if (位置是否可用(检查X, 检查Y, false)) {
                                    可用位置列表.push({ x: 检查X, y: 检查Y });
                                }
                            }

                            if (可用位置列表.length > 0) {
                                const 牛角位置 = 可用位置列表.shift();
                                const 冲撞牛角掉落 = new 冲撞牛角({});
                                放置物品到单元格(冲撞牛角掉落, 牛角位置.x, 牛角位置.y);
                            }
                            if (可用位置列表.length > 0) {
                                const 战斧位置 = 可用位置列表.shift();
                                const 战斧掉落 = new 嗜血战斧({ 强化: true });
                                放置物品到单元格(战斧掉落, 战斧位置.x, 战斧位置.y);
                            }
            
                            if (可用位置列表.length > 0) {
                                const 出口位置 = 可用位置列表.shift();
                                生成迷宫出口(出口位置.x, 出口位置.y);
                            } else {
                                生成迷宫出口(deathX, deathY);
                            }

                            显示通知("米诺陶发出一声哀嚎，倒下了...", "成功");
                            return;
                        }
                        this.绘制血条();
                    }
                }

                选择目标() {
                    if (this.当前生命值 < this.生命值 * 0.7) {
                        let 最近药水位置 = null;
                        let 最小距离 = Infinity;
                        for (let y = 0; y < 地牢大小; y++) {
                            for (let x = 0; x < 地牢大小; x++) {
                                const 物品 = 地牢[y]?.[x]?.关联物品;
                                if (物品 instanceof 治疗药水) {
                                    const 方向 = [
                                        [0, -1],
                                        [0, 1],
                                        [-1, 0],
                                        [1, 0],
                                    ];
                                    for (const [dx, dy] of 方向) {
                                        const 邻近X = x + dx;
                                        const 邻近Y = y + dy;
                                        if (
                                            邻近X >= 0 &&
                                            邻近X < 地牢大小 &&
                                            邻近Y >= 0 &&
                                            邻近Y < 地牢大小 &&
                                            位置是否可用(邻近X, 邻近Y, false)
                                        ) {
                                            const 距离 =
                                                Math.abs(this.x - 邻近X) +
                                                Math.abs(this.y - 邻近Y);
                                            if (距离 < 最小距离) {
                                                最小距离 = 距离;
                                                最近药水位置 = {
                                                    x: 邻近X,
                                                    y: 邻近Y,
                                                    药水本体X: x,
                                                    药水本体Y: y,
                                                };
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (最近药水位置) {
                            this.目标 = 最近药水位置;
                            return 最近药水位置;
                        }
                    }
                    this.目标 = 玩家;
                    return { x: 玩家.x, y: 玩家.y };
                }

                尝试移动() {
                    this.更新技能冷却();
                    const 目标 = this.选择目标();

                    if (目标.药水本体X !== undefined) {
                        this.目标路径 = this.计算路径(目标.x, 目标.y);
                        if (this.目标路径) {
                            super.尝试移动();
                            const 距离药水 =
                                Math.abs(this.x - 目标.药水本体X) +
                                Math.abs(this.y - 目标.药水本体Y);
                            if (距离药水 === 1) {
                                const 药水单元格 =
                                    地牢[目标.药水本体Y]?.[目标.药水本体X];
                                if (
                                    药水单元格 &&
                                    药水单元格.关联物品 instanceof 治疗药水
                                ) {
                                    this.当前生命值 = Math.min(
                                        this.生命值,
                                        this.当前生命值 + 50
                                    );
                                    药水单元格.关联物品 = null;
                                    if (药水单元格.类型 === 单元格类型.物品)
                                        药水单元格.类型 = null;
                                    添加日志(
                                        `${this.类型} 喝下了治疗药水，恢复了生命！`,
                                        "信息"
                                    );
                                    this.绘制血条();
                                    绘制();
                                }
                            }
                        }
                    } else {
                        this.目标路径 = this.计算路径(目标.x, 目标.y);
                        super.尝试移动();
                    }
                }

                尝试攻击() {
                    const 玩家距离 =
                        Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
                    const 技能列表 = [];

                    if (玩家距离 >= 8 && this.技能冷却剩余.高速冲撞 <= 0)
                        技能列表.push("高速冲撞");
                    if (玩家距离 <= 4 && this.技能冷却剩余.喷火 <= 0)
                        技能列表.push("喷火");
                    if (玩家距离 <= 5 && this.技能冷却剩余.喷射毒液 <= 0)
                        技能列表.push("喷射毒液");
                    if (玩家距离 <= 3 && this.技能冷却剩余.战争践踏 <= 0)
                        技能列表.push("战争践踏");
                    if (
                        玩家距离 > 2 &&
                        玩家距离 < 7 &&
                        this.技能冷却剩余.异墙凸起 <= 0
                    )
                        技能列表.push("异墙凸起");

                    if (技能列表.length > 0) {
                        const 选用技能 =
                            技能列表[
                                Math.floor(Math.random() * 技能列表.length)
                            ];
                        switch (选用技能) {
                            case "高速冲撞":
                                return this.高速冲撞();
                            case "喷火":
                                return this.喷火();
                            case "喷射毒液":
                                return this.喷射毒液();
                            case "战争践踏":
                                return this.战争践踏();
                            case "异墙凸起":
                                return this.异墙凸起();
                        }
                    } else if (玩家距离 <= this.攻击范围) {
                        return super.尝试攻击();
                    }

                    return false;
                }

                高速冲撞() {
                    if (
                        this.技能冷却剩余.高速冲撞 > 0 ||
                        this.选择目标().药水本体X !== undefined
                    )
                        return false;

                    const 伤害 = this.攻击力 * 1.5;
                    const 冲撞距离 = 10;
                    const 落点距离 = 4;
                    const dx = 玩家.x - this.x;
                    const dy = 玩家.y - this.y;

                    if (dx === 0 && dy === 0) return false;

                    let dirX, dirY;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        dirX = Math.sign(dx);
                        dirY = 0;
                    } else {
                        dirX = 0;
                        dirY = Math.sign(dy);
                    }

                    const 冲撞路径 = [];
                    let 撞到玩家 = false;

                    for (let i = 1; i <= 冲撞距离; i++) {
                        const 路径X = this.x + i * dirX;
                        const 路径Y = this.y + i * dirY;
                        冲撞路径.push({ x: 路径X, y: 路径Y });
                        if (路径X === 玩家.x && 路径Y === 玩家.y) {
                            伤害玩家(伤害, this);
                            撞到玩家 = true;
                            break;
                        }
                    }

                    if (撞到玩家) {
                        for (let i = 1; i <= 落点距离; i++) {
                            const 路径X = 玩家.x + i * dirX;
                            const 路径Y = 玩家.y + i * dirY;
                            if (
                                路径X < 0 ||
                                路径X >= 地牢大小 ||
                                路径Y < 0 ||
                                路径Y >= 地牢大小
                            )
                                break;
                            冲撞路径.push({ x: 路径X, y: 路径Y });
                        }
                    }

                    let 最终落点 = { x: this.x, y: this.y };
                    for (const 节点 of 冲撞路径) {
                        const 当前单元格 = 地牢[节点.y]?.[节点.x];

                        if (this.位置合法(节点.x, 节点.y, true)) {
                            最终落点 = { x: 节点.x, y: 节点.y };
                        } else {
                            break;
                        }
                        当前单元格.背景类型 = 单元格类型.走廊;
                    }

                    if (冲撞路径.length === 0) return false;

                    const 旧X = this.x,
                        旧Y = this.y;
                    this.恢复背景类型();
                    this.x = 最终落点.x;
                    this.y = 最终落点.y;
                    this.保存新位置类型(this.x, this.y);
                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
                    地牢[this.y][this.x].关联怪物 = this;
                    生成墙壁();
                    怪物动画状态.set(this, {
                        旧逻辑X: 旧X,
                        旧逻辑Y: 旧Y,
                        目标逻辑X: this.x,
                        目标逻辑Y: this.y,
                        视觉X: 旧X,
                        视觉Y: 旧Y,
                        动画开始时间: Date.now(),
                        正在动画: true,
                    });

                    计划显示格子特效(冲撞路径, "FF4500");
                    添加日志("米诺陶发动了高速冲撞！", "警告");
                    this.技能冷却剩余.高速冲撞 = this.技能冷却.高速冲撞;
                    return true;
                }

                喷火() {
                    if (this.技能冷却剩余.喷火 > 0) return false;
                    const 范围 = 4;
                    const 方向 = [
                        [-1, 0],
                        [1, 0],
                        [0, -1],
                        [0, 1],
                    ];
                    const 火焰区域 = [];
                    for (const [dx, dy] of 方向) {
                        let lastX = this.x,
                            lastY = this.y;
                        for (let i = 0; i <= 范围; i++) {
                            const x = this.x + i * dx,
                                y = this.y + i * dy;
                            if (
                                x < 0 ||
                                x >= 地牢大小 ||
                                y < 0 ||
                                y >= 地牢大小
                            )
                                break;

                            const 前一单元格 = 地牢[lastY]?.[lastX];
                            const 当前单元格 = 地牢[y]?.[x];
                            if (!前一单元格 || !当前单元格) break;
                            const 移动方向 = 获取移动方向(lastX, lastY, x, y);
                            if (
                                前一单元格.墙壁[移动方向.当前墙] ||
                                当前单元格.墙壁[移动方向.反方向墙]
                            )
                                break;

                            火焰区域.push({ x, y });
                            lastX = x;
                            lastY = y;
                        }
                    }
                    火焰区域.forEach(({ x, y }) => {
                        计划显示格子特效([{ x, y }], "FFA500");
                        if (玩家.x === x && 玩家.y === y)
                            伤害玩家(this.攻击力, this);
                    });
                    添加日志(`${this.类型} 喷出了火焰！`, "警告");
                    this.技能冷却剩余.喷火 = this.技能冷却.喷火;
                    return true;
                }

                喷射毒液() {
                    if (this.技能冷却剩余.喷射毒液 > 0) return false;
                    const 范围 = 3;
                    const 毒液数量 = 5;
                    const 可选位置 = [];
                    for (let dx = -范围; dx <= 范围; dx++) {
                        for (let dy = -范围; dy <= 范围; dy++) {
                            const x = this.x + dx,
                                y = this.y + dy;
                            if (
                                x >= 0 &&
                                x < 地牢大小 &&
                                y >= 0 &&
                                y < 地牢大小 &&
                                位置是否可用(x, y, false)
                            ) {
                                可选位置.push({ x, y });
                            }
                        }
                    }
                    for (
                        let i = 0;
                        i < Math.min(毒液数量, 可选位置.length);
                        i++
                    ) {
                        const 位置 =
                            可选位置[
                                Math.floor(Math.random() * 可选位置.length)
                            ];
                        const 毒液 = new 毒液物品({ 强化: this.强化 });
                        放置物品到单元格(毒液, 位置.x, 位置.y);
                        可选位置.splice(可选位置.indexOf(位置), 1);
                    }
                    添加日志(`${this.类型} 喷射了毒液！`, "警告");
                    this.技能冷却剩余.喷射毒液 = this.技能冷却.喷射毒液;
                    return true;
                }

                战争践踏() {
                    if (this.技能冷却剩余.战争践踏 > 0) return false;
                    const 范围 = 3;
                    const 影响格子 = [];
                    const 击中列表 = new Set();

                    for (let dx = -范围; dx <= 范围; dx++) {
                        for (let dy = -范围; dy <= 范围; dy++) {
                            if (Math.abs(dx) + Math.abs(dy) > 范围) continue;
                            const x = this.x + dx;
                            const y = this.y + dy;
                            if (
                                x >= 0 &&
                                x < 地牢大小 &&
                                y >= 0 &&
                                y < 地牢大小
                            ) {
                                计划显示格子特效([{ x, y }], "A52A2A");

                                if (玩家.x === x && 玩家.y === y) {
                                    击中列表.add(玩家);
                                }
                                const 单元格 = 地牢[y]?.[x];
                                if (
                                    单元格?.关联怪物 &&
                                    单元格.关联怪物 !== this
                                ) {
                                    击中列表.add(单元格.关联怪物);
                                }
                            }
                        }
                    }

                    击中列表.forEach((目标) => {
                        if (目标 === 玩家) {
                            伤害玩家(this.攻击力, this);
                            new 状态效果(
                                "眩晕",
                                效果颜色编号映射[效果名称编号映射.眩晕],
                                图标映射.眩晕,
                                3
                            );
                        } else if (目标 instanceof 怪物) {
                            new 状态效果(
                                "眩晕",
                                效果颜色编号映射[效果名称编号映射.眩晕],
                                图标映射.眩晕,
                                2,
                                null,
                                null,
                                目标
                            );
                        }
                    });

                    添加日志(`${this.类型} 发动了战争践踏！`, "警告");
                    this.技能冷却剩余.战争践踏 = this.技能冷却.战争践踏;
                    return true;
                }

                异墙凸起() {
                    if (this.技能冷却剩余.异墙凸起 > 0) return false;

                    const 尝试次数 = 15;
                    for (let i = 0; i < 尝试次数; i++) {
                        const 角度 = Math.random() * Math.PI * 2;
                        const 距离 = 2.5 + Math.random() * 2;
                        const 墙壁半长 = 4 + Math.random() * 8;
                        const 墙壁中心X = 玩家.x + Math.cos(角度) * 距离;
                        const 墙壁中心Y = 玩家.y + Math.sin(角度) * 距离;
                        const 墙壁方向X = -Math.sin(角度);
                        const 墙壁方向Y = Math.cos(角度);
                        const 起点X = 墙壁中心X - 墙壁方向X * 墙壁半长;
                        const 起点Y = 墙壁中心Y - 墙壁方向Y * 墙壁半长;
                        const 终点X = 墙壁中心X + 墙壁方向X * 墙壁半长;
                        const 终点Y = 墙壁中心Y + 墙壁方向Y * 墙壁半长;

                        const 格子列表 = 获取直线格子(
                            起点X,
                            起点Y,
                            终点X,
                            终点Y
                        );

                        if (
                            格子列表.some(
                                (p) => p.x === 玩家.x && p.y === 玩家.y
                            )
                        )
                            continue;

                        const 有效墙壁格子 = 格子列表.filter(({ x, y }) => {
                            if (
                                x < 0 ||
                                x >= 地牢大小 ||
                                y < 0 ||
                                y >= 地牢大小
                            )
                                return false;
                            const 单元格 = 地牢[y]?.[x];
                            return (
                                单元格 &&
                                (单元格.背景类型 === 单元格类型.走廊 ||
                                    单元格.背景类型 === 单元格类型.房间) &&
                                !单元格.关联物品 &&
                                !单元格.关联怪物
                            );
                        });

                        if (有效墙壁格子.length >= 4) {
                            有效墙壁格子.forEach(({ x, y }) => {
                                地牢[y][x].背景类型 = 单元格类型.墙壁;
                            });
                            生成墙壁();
                            计划显示格子特效(有效墙壁格子, "8B4513");
                            添加日志(`${this.类型} 发动了异墙凸起！`, "警告");
                            this.技能冷却剩余.异墙凸起 = this.技能冷却.异墙凸起;
                            return true;
                        }
                    }
                    return false;
                }

                规划移动路径() {
                    let 当前位置 = { x: this.x, y: this.y };
                    let 有效位置 = null;
                    for (
                        let i = 0;
                        i < Math.min(this.目标路径.length, this.移动距离);
                        i++
                    ) {
                        const 节点 = this.目标路径[i];
                        const nextX = 节点.x,
                            nextY = 节点.y;

                        const 目标单元格 = 地牢[nextY]?.[nextX];

                        if (目标单元格.背景类型 === 单元格类型.墙壁) {
                            目标单元格.背景类型 = 单元格类型.走廊;
                            生成墙壁();
                            有效位置 = { x: nextX, y: nextY };
                            break;
                        }

                        if (this.位置合法(nextX, nextY)) {
                            有效位置 = { x: nextX, y: nextY };
                        }

                        当前位置 = { x: nextX, y: nextY };
                    }
                    if (有效位置) this.目标路径 = [];
                    return 有效位置;
                }

                位置合法(x, y, 忽略怪物 = false) {
                    if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
                        return false;
                    const 单元格 = 地牢[y]?.[x];
                    if (!单元格) return false;
                    if (单元格.关联物品 && 单元格.关联物品.阻碍怪物)
                        return false;
                    if (
                        !忽略怪物 &&
                        单元格.关联怪物 &&
                        单元格.关联怪物 !== this
                    )
                        return false;
                    return true;
                }
            }

            class 恐惧怪物 extends 怪物 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.恐惧怪物,
                        类型: "恐惧怪物",
                        基础生命值: 30 + (配置.强化 ? 15 : 0),
                        基础攻击力: 5 + (配置.强化 ? 2 : 0),
                        移动率: 0.6,
                        掉落物: new 恐惧魔杖({ 强化: 配置.强化 ?? false }),
                        掉落概率: 0.8,
                        基础攻击范围: 2,
                        跟踪距离: 10,
                        数据: {
                            恐惧持续时间: 3 + (配置?.强化 ? 2 : 0),
                            ...配置.数据,
                        },
                        ...配置,
                    });
                    this.击退距离 = 2 + (配置.强化 ? 1 : 0);
                }

                尝试攻击() {
                    const 我的状态 = 怪物状态表.get(this);
                    if (我的状态?.类型 === "冻结") return false;
                    if (this.攻击冷却回合剩余 > 0) {
                        this.攻击冷却回合剩余 -= 1;
                        return false;
                    }

                    if (我的状态?.类型 === "魅惑") {
                        if (
                            this.魅惑目标怪物 &&
                            this.魅惑目标怪物 !== this &&
                            this.魅惑目标怪物.当前生命值 > 0
                        ) {
                            // this.通向目标路径 应该由 处理怪物回合 中的 计算目标路径 更新
                            if (
                                this.通向目标路径 &&
                                this.通向目标路径.length <= this.攻击范围
                            ) {
                                this.魅惑目标怪物.受伤(this.攻击力, this);
                                this.攻击冷却回合剩余 = this.攻击冷却;
                                计划显示格子特效(
                                    this.通向目标路径,
                                    效果颜色编号映射[
                                        效果名称编号映射.恐惧
                                    ].slice(1)
                                );

                                if (this.魅惑目标怪物.当前生命值 > 0) {
                                    new 状态效果(
                                        "恐惧",
                                        效果颜色编号映射[效果名称编号映射.恐惧],
                                        图标映射.恐惧,
                                        this.自定义数据.get("恐惧持续时间") ||
                                            3,
                                        null,
                                        null,
                                        this.魅惑目标怪物,
                                        1
                                    );
                                    添加日志(
                                        `${this.类型} 使 ${this.魅惑目标怪物.类型} 陷入了恐惧！`,
                                        "信息"
                                    );
                                }
                                return true;
                            }
                        }
                        return false;
                    } else {
                        const 玩家距离 =
                            Math.abs(this.x - 玩家.x) +
                            Math.abs(this.y - 玩家.y);

                        if (
                            玩家距离 <= this.攻击范围 &&
                            检查视线(
                                this.x,
                                this.y,
                                玩家.x,
                                玩家.y,
                                this.攻击范围
                            )
                        ) {
                            伤害玩家(this.攻击力, this);
                            this.攻击冷却回合剩余 = this.攻击冷却;

                            let dx = 玩家.x - this.x;
                            let dy = 玩家.y - this.y;
                            let 方向DX = 0,
                                方向DY = 0;

                            if (Math.abs(dx) > Math.abs(dy))
                                方向DX =
                                    Math.sign(dx) ||
                                    (dy === 0
                                        ? Math.random() < 0.5
                                            ? 1
                                            : -1
                                        : 0);
                            else if (Math.abs(dy) > Math.abs(dx))
                                方向DY =
                                    Math.sign(dy) ||
                                    (dx === 0
                                        ? Math.random() < 0.5
                                            ? 1
                                            : -1
                                        : 0);
                            else if (dx !== 0 && dy !== 0) {
                                if (Math.random() < 0.5) 方向DX = Math.sign(dx);
                                else 方向DY = Math.sign(dy);
                            }
                            if (方向DX === 0 && 方向DY === 0) {
                                if (Math.random() < 0.5)
                                    方向DX = Math.random() < 0.5 ? 1 : -1;
                                else 方向DY = Math.random() < 0.5 ? 1 : -1;
                            }

                            if (方向DX !== 0 || 方向DY !== 0) {
                                let 最终X = 玩家.x;
                                let 最终Y = 玩家.y;
                                for (let i = 1; i <= this.击退距离; i++) {
                                    const 尝试X = 玩家.x + 方向DX * i;
                                    const 尝试Y = 玩家.y + 方向DY * i;

                                    if (
                                        尝试X < 0 ||
                                        尝试X >= 地牢大小 ||
                                        尝试Y < 0 ||
                                        尝试Y >= 地牢大小
                                    )
                                        break;
                                    if (
                                        !检查移动可行性(
                                            最终X,
                                            最终Y,
                                            尝试X,
                                            尝试Y,
                                            true
                                        )
                                    )
                                        break;
                                    const 目标单元格 = 地牢[尝试Y]?.[尝试X];
                                    if (
                                        !目标单元格 ||
                                        [
                                            单元格类型.墙壁,
                                            单元格类型.上锁的门,
                                        ].includes(目标单元格.背景类型)
                                    )
                                        break;
                                    if (
                                        目标单元格.关联怪物 ||
                                        (目标单元格.关联物品 &&
                                            目标单元格.关联物品.阻碍怪物)
                                    )
                                        break;

                                    最终X = 尝试X;
                                    最终Y = 尝试Y;
                                }

                                if (最终X !== 玩家.x || 最终Y !== 玩家.y) {
                                    const 旧恐惧X = 玩家.x,
                                        旧恐惧Y = 玩家.y;
                                    玩家.x = 最终X;
                                    玩家.y = 最终Y;
                                    处理玩家着陆效果(
                                        旧恐惧X,
                                        旧恐惧Y,
                                        玩家.x,
                                        玩家.y
                                    );
                                    更新视口();
                                    添加日志(
                                        `你被 ${this.类型} 击退了！`,
                                        "警告"
                                    );
                                    this.攻击冷却回合剩余++;
                                    绘制();
                                }
                            }
                            计划显示格子特效(
                                [{ x: 玩家.x, y: 玩家.y }],
                                效果颜色编号映射[效果名称编号映射.恐惧].slice(1)
                            );
                            return true;
                        }
                        return false;
                    }
                }
            }

            class 物品 {
                constructor(配置 = {}) {
                    this.类型 = 配置.类型 || "其他物品";
                    this.名称 = 配置.名称 || "未命名物品";
                    this.图标 = 配置.图标 || "◎";
                    this.品质 = 配置.品质 || 1;
                    this.堆叠数量 = 配置.堆叠数量 || 1;
                    this.最大堆叠数量 = 配置.最大堆叠数量 || 最大堆叠数;
                    this.颜色索引 = 配置.颜色索引 || 0;
                    this.自定义数据 = new Map(Object.entries(配置.数据 || {}));
                    const date = new Date();
                    this.唯一标识 =
                        配置.唯一标识 ||
                        Symbol(
                            Date.now().toString() + Math.random().toString()
                        );
                    this.已装备 = 配置.已装备 || false;
                    this.装备槽位 = 配置.已装备 || null;
                    this.x = 配置.x || null;
                    this.y = 配置.y || null;
                    this.显示元素 = null;
                    this.isActive = false; //屎山莫动
                    this.强化 = 配置.强化 || false;
                    this.能否拾起 =
                        配置.能否拾起 === undefined ? true : 配置.能否拾起;
                    this.是否正常物品 =
                        配置.是否正常物品 === undefined
                            ? true
                            : 配置.是否正常物品; // 用于配置是否是只能存在于地图上被玩家使用的物品
                    this.效果描述 = 配置.效果描述 || null;
                    this.是否隐藏 = 配置.是否隐藏 || false; //是否在背包中显示
                    this.是否为隐藏物品 = 配置.是否为隐藏物品 || false; //是否在地图上显示
                    this.阻碍怪物 =
                        配置.阻碍怪物 !== undefined ? 配置.阻碍怪物 : true;
                    this.是否被丢弃 = 配置.是否被丢弃 ?? false;
                }
                装备() {
                    if (this.已装备) return false;
                    const 空槽 =
                        Array.from(
                            { length: 装备栏每页装备数 },
                            (_, i) => i + 1
                        ).find(
                            (id) =>
                                !玩家装备.has(
                                    id + 当前装备页 * 装备栏每页装备数
                                )
                        ) +
                        当前装备页 * 装备栏每页装备数;

                    if (空槽) {
                        this.已装备 = true;
                        this.装备槽位 = 空槽;
                        玩家装备.set(this.装备槽位, this);
                        更新装备显示();
                        return true;
                    }
                    return false;
                }

                取消装备() {
                    if (!this.已装备) return false;
                    玩家装备.delete(this.装备槽位);
                    this.已装备 = false;
                    this.装备槽位 = null;
                    更新装备显示();
                    return true;
                }
                获取名称() {
                    return (
                        `${this.名称} [${this.品质} 级]` +
                        (this.强化 ? ` [强化]` : ``)
                    );
                }

                使用() {
                    this.堆叠数量 -= 1;
                    return true;
                }
                当被收集(进入者) {
                    return true;
                }
                当被丢弃(x, y) {
                    return true;
                }
                可交互目标(目标) {
                    return false;
                }
                刷新显示() {
                    this.显示元素.innerHTML = `
            < div class="物品图标" > ${this.图标}</div >
            <div class="物品名称">${this.获取名称()}</div>
                                                                        ${
                                                                            this
                                                                                .堆叠数量 >
                                                                            1
                                                                                ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
                                                                                : ""
                                                                        }
        `;
                }

                获取提示() {
                    const lines = [];
                    lines.push(`${this.获取名称()} `);
                    lines.push(`类型：${this.类型} `);
                    lines.push(`品质：${"★".repeat(this.品质)} `);

                    if (this.最大堆叠数量 > 1) {
                        lines.push(
                            `堆叠：${this.堆叠数量} / ${this.最大堆叠数量}`
                        );
                    }
                    if (this.效果描述) {
                        lines.push(`效果描述：${this.效果描述} `);
                    }

                    const 融合Buffs = this.自定义数据?.get("fusedBuffs");
                    if (融合Buffs && 融合Buffs.length > 0) {
                        lines.push("--- 强化效果 ---");
                        融合Buffs.forEach((buff) => {
                            lines.push(格式化Buff提示(buff));
                        });
                    }

                    if (
                        this.自定义数据?.has("附魔") &&
                        this.自定义数据.get("附魔").length > 0
                    ) {
                        const 附魔描述 = 获取附魔描述(
                            this.自定义数据.get("附魔")
                        );
                        if (附魔描述) lines.push(附魔描述);
                    }

                    if (
                        this.自定义数据?.has("耐久") &&
                        this.自定义数据?.has("原耐久")
                    ) {
                        lines.push(
                            `耐久：${this.自定义数据.get(
                                "耐久"
                            )} / ${this.自定义数据.get("原耐久")}`
                        );
                    }

                    if (
                        this.自定义数据?.has("冷却剩余") &&
                        this.自定义数据?.has("冷却回合")
                    ) {
                        if (this.自定义数据.get("冷却回合") > 0) {
                            lines.push(
                                `冷却：${this.自定义数据.get(
                                    "冷却剩余"
                                )} / ${this.自定义数据.get("冷却回合")}回合`
                            );
                        }
                    }
                    if (this.自定义数据?.get("不可破坏")) {
                        lines.push("[不可破坏]");
                    }

                    return lines
                        .filter((line) => line && line.trim() !== "")
                        .join("\n");
                }
                安全销毁() {
                    this.取消装备();
                    this.自定义数据.clear();
                    this.唯一标识 = null;
                    return true;
                }
                get 显示图标() {
                    return this.图标;
                }
                get 显示名称() {
                    return this.名称;
                }
                get 颜色表() {
                    return 颜色表;
                }
                生成显示元素(用途 = "背包") {
                    const 元素 = document.createElement("div");
                    元素.className = "物品条目 hover";
                    元素.setAttribute("data-quality", this.品质);
                    if (用途 === "背包") {
                        元素.innerHTML = `
                                                                        <div class="物品图标">${
                                                                            this
                                                                                .显示图标
                                                                        }</div>
                                                                        <div class="物品名称">${this.获取名称()}</div>
                                                                        ${
                                                                            this
                                                                                .堆叠数量 >
                                                                            1
                                                                                ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
                                                                                : ""
                                                                        }
                                                                    `;
                        this.显示元素 = 元素;
                    } else if (用途 === "装备") {
                        元素.className = "物品条目";
                        元素.innerHTML = `
                                                                        <div class="物品图标">${
                                                                            this
                                                                                .显示图标
                                                                        }</div>
                                                                        <div class="物品名称">${
                                                                            this
                                                                                .显示名称
                                                                        }</div>
                                                                        ${
                                                                            this
                                                                                .堆叠数量 >
                                                                            1
                                                                                ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
                                                                                : ""
                                                                        }
                                                                    `;
                    } else if (用途 === "融合") {
                        元素.className = "物品条目";
                        元素.innerHTML = `
                                                                        <div class="物品图标">${this.显示图标}</div>
                                                                        <div class="物品名称">${this.显示名称}</div>
                                                                    `;
                    }

                    元素.__物品实例 = this;
                    const 图标元素 = 元素.querySelector(".物品图标");
                    图标元素.style = `
                                                                        color: ${
                                                                            this
                                                                                .颜色表[
                                                                                this
                                                                                    .颜色索引
                                                                            ]
                                                                        };
                                                                        font-size: 2.5em;
                                                                        text-shadow: 0 0 8px ${
                                                                            this
                                                                                .颜色表[
                                                                                this
                                                                                    .颜色索引
                                                                            ]
                                                                        };
                                                                    `;

                    if (用途 === "背包") {
                        元素.addEventListener("click", (事件) => {
                            事件.stopPropagation();
                            const 当前是否已激活 =
                                元素.classList.contains("active");
                            const 提示框 =
                                document.getElementById("浮动提示框");

                            document
                                .querySelectorAll(".物品容器 .物品条目.active")
                                .forEach((旧激活元素) => {
                                    if (旧激活元素 !== 元素) {
                                        旧激活元素.classList.remove("active");
                                        if (旧激活元素.__物品实例)
                                            旧激活元素.__物品实例.isActive = false;
                                    }
                                });

                            if (当前是否已激活) {
                                if (提示框.style.display === "none") {
                                    提示框.style.display = "block";
                                } else {
                                    提示框.style.display = "none";
                                }
                            } else {
                                元素.classList.add("active");
                                if (this.__物品实例)
                                    this.__物品实例.isActive = true;

                                提示框.innerHTML = this.获取提示().replace(
                                    /\n/g,
                                    "<br>"
                                );
                                const 提示框宽度 = 提示框.offsetWidth;
                                const 提示框高度 = 提示框.offsetHeight;
                                const 视口宽度 = window.innerWidth;
                                const 视口高度 = window.innerHeight;

                                let left = 事件.pageX + 15;
                                let top = 事件.pageY + 15;

                                if (left + 提示框宽度 > 视口宽度 - 10) {
                                    left = 事件.pageX - 提示框宽度 - 15;
                                }
                                if (top + 提示框高度 > 视口高度 - 10) {
                                    top = 视口高度 - 提示框高度 - 10;
                                }

                                left = Math.max(
                                    5,
                                    Math.min(left, 视口宽度 - 提示框宽度 - 5)
                                );
                                top = Math.max(
                                    5,
                                    Math.min(top, 视口高度 - 提示框高度 - 5)
                                );

                                提示框.style.left = `${left}px`;
                                提示框.style.top = `${top}px`;
                                提示框.style.display = "block";
                            }
                        });

                        元素.addEventListener("mousemove", (e) => {
                            const 提示框 =
                                document.getElementById("浮动提示框");
                            if ("ontouchstart" in window) {
                                提示框.innerHTML = this.获取提示().replace(
                                    /\n/g,
                                    "<br>"
                                );
                                const 提示框宽度 = 提示框.offsetWidth;
                                const 提示框高度 = 提示框.offsetHeight;
                                const 视口宽度 = window.innerWidth;
                                const 视口高度 = window.innerHeight;

                                let left = e.pageX + 15;
                                let top = e.pageY + 15;

                                if (left + 提示框宽度 > 视口宽度 - 10) {
                                    left = e.pageX - 提示框宽度 - 15;
                                }
                                if (top + 提示框高度 > 视口高度 - 10) {
                                    top = 视口高度 - 提示框高度 - 10;
                                }

                                left = Math.max(
                                    5,
                                    Math.min(left, 视口宽度 - 提示框宽度 - 5)
                                );
                                top = Math.max(
                                    5,
                                    Math.min(top, 视口高度 - 提示框高度 - 5)
                                );

                                提示框.style.left = `${left}px`;
                                提示框.style.top = `${top}px`;
                                提示框.style.display = "block";
                                return;
                            }
                            this.isActive = true;
                            元素.classList.add("active");

                            提示框.innerHTML = this.获取提示().replace(
                                /\n/g,
                                "<br>"
                            );
                            提示框.style.display = "block";

                            const 提示框宽度 = 提示框.offsetWidth;
                            const 提示框高度 = 提示框.offsetHeight;
                            const 视口宽度 = window.innerWidth;
                            const 视口高度 = window.innerHeight;
                            let left = e.pageX + 15;
                            let top = e.pageY + 15;

                            if (left + 提示框宽度 > 视口宽度 - 10) {
                                left = e.pageX - 提示框宽度 - 15;
                            }
                            if (top + 提示框高度 > 视口高度 - 10) {
                                top = 视口高度 - 提示框高度 - 10;
                            }

                            left = Math.max(
                                5,
                                Math.min(left, 视口宽度 - 提示框宽度 - 5)
                            );
                            top = Math.max(
                                5,
                                Math.min(top, 视口高度 - 提示框高度 - 5)
                            );

                            提示框.style.left = `${left}px`;
                            提示框.style.top = `${top}px`;
                        });

                        元素.addEventListener("mouseleave", () => {
                            if (
                                "ontouchstart" in window &&
                                元素.classList.contains("active")
                            )
                                return;
                            document.getElementById(
                                "浮动提示框"
                            ).style.display = "none";
                            if (
                                元素.__物品实例 &&
                                !(
                                    "ontouchstart" in window &&
                                    元素.classList.contains("active")
                                )
                            ) {
                                元素.classList.remove("active");
                                元素.__物品实例.isActive = false;
                            }
                        });

                        const 上屏按钮 = document.createElement("button");
                        上屏按钮.className = "上屏按钮";
                        上屏按钮.innerHTML = "↑";
                        上屏按钮.onclick = (e) => {
                            e.stopPropagation();
                            const 父物品条目 = e.target.closest(".物品条目");
                            this.isActive = true;
                            元素.classList.add("active");
                            if (
                                !父物品条目 ||
                                !父物品条目.classList.contains("active")
                            )
                                return;
                            添加到融合区(this.唯一标识);
                        };
                        元素.appendChild(上屏按钮);
                        const 丢弃按钮 = document.createElement("button");
                        丢弃按钮.className = "丢弃按钮";
                        丢弃按钮.innerHTML = "↓";
                        丢弃按钮.addEventListener("click", (e) => {
                            e.stopPropagation();
                            const 父物品条目 = e.target.closest(".物品条目");
                            if (
                                !父物品条目 ||
                                !父物品条目.classList.contains("active")
                            )
                                return;
                            this.isActive = true;
                            元素.classList.add("active");
                            document
                                .querySelectorAll(".物品条目")
                                .forEach((el) => {
                                    if (el !== 元素 && el.__物品实例) {
                                        el.classList.remove("active");
                                        el.__物品实例.isActive = false;
                                    }
                                });
                            处理丢弃物品(this.唯一标识);
                        });
                        元素.prepend(丢弃按钮);

                        const 使用按钮 = document.createElement("button");
                        使用按钮.className = "使用按钮";
                        使用按钮.innerHTML = "⚡";
                        使用按钮.onclick = (e) => {
                            e.stopPropagation();
                            const 父物品条目 = e.target.closest(".物品条目");
                            if (
                                !父物品条目 ||
                                !父物品条目.classList.contains("active")
                            )
                                return;
                            this.isActive = true;
                            元素.classList.add("active");
                            document
                                .querySelectorAll(".物品条目")
                                .forEach((el) => {
                                    if (el !== 元素 && el.__物品实例) {
                                        el.classList.remove("active");
                                        el.__物品实例.isActive = false;
                                    }
                                });
                            使用背包物品(this.唯一标识);
                        };
                        元素.prepend(使用按钮);

                        this.装备按钮 = null;
                        this.装备按钮 = document.createElement("button");
                        this.装备按钮.className = "装备按钮";
                        this.装备按钮.innerHTML = 图标映射.装备按钮;
                        this.装备按钮.onclick = (e) => {
                            e.stopPropagation();
                            const 父物品条目 = e.target.closest(".物品条目");
                            if (
                                !父物品条目 ||
                                !父物品条目.classList.contains("active")
                            )
                                return;
                            this.isActive = true;
                            元素.classList.add("active");
                            document
                                .querySelectorAll(".物品条目")
                                .forEach((el) => {
                                    if (el !== 元素 && el.__物品实例) {
                                        el.classList.remove("active");
                                        el.__物品实例.isActive = false;
                                    }
                                });
                            if (this.已装备) {
                                this.取消装备();
                                显示通知("已卸下", "成功");
                            } else {
                                if (this.装备()) {
                                    显示通知("已装备", "成功");
                                } else {
                                    显示通知("槽位已满", "错误");
                                }
                            }
                            this.装备按钮.style.background = this.已装备
                                ? "#f44336"
                                : "#FF9800";
                            更新装备显示();
                            this.isActive = true;
                            元素.classList.add("active");
                            document.getElementById(
                                "浮动提示框"
                            ).style.display = "none";
                        };
                        this.装备按钮.style.background = this.已装备
                            ? "#f44336"
                            : "#FF9800";
                        元素.prepend(this.装备按钮);
                    }
                    return 元素;
                }
                可堆叠于(其他物品) {
                    if (
                        this.堆叠数量 >= this.最大堆叠数量 ||
                        this.堆叠数量 >= 最大堆叠数
                    )
                        return false;
                    const 基础相同 =
                        this.类型 === 其他物品.类型 &&
                        this.名称 === 其他物品.名称 &&
                        this.图标 === 其他物品.图标 &&
                        this.品质 === 其他物品.品质 &&
                        this.强化 === 其他物品.强化 &&
                        this.获取名称() === 其他物品.获取名称();

                    const 数据相同 = this.比较自定义数据(其他物品.自定义数据);

                    return 基础相同 && 数据相同;
                }
                比较自定义数据(其他数据) {
                    if (this.自定义数据.size !== 其他数据.size) return false;

                    for (const [键, 值] of this.自定义数据) {
                        if (!其他数据.has(键)) return false;

                        const 其他值 = 其他数据.get(键);
                        if (typeof 值 === "object" && 值 !== null) {
                            if (!深度比较(值, 其他值)) return false;
                        } else if (值 !== 其他值) {
                            return false;
                        }
                    }
                    return true;
                }
            }

            class 武器类 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "武器",
                        名称: 配置.名称 || "铁剑",
                        图标: 配置.图标 || "⚔️",
                        品质: 配置.品质 || 1,
                        颜色索引: 配置.品质 - 1 || 0,
                        堆叠数量: 配置.堆叠数量 || 1,
                        最大堆叠数量: 1,
                        效果描述: 配置.效果描述 || null,
                        强化: 配置.强化 || false,
                        数据: {
                            基础攻击力: 配置.基础攻击力 ?? 3,
                            冷却回合: 配置.冷却回合 || 1,
                            冷却剩余: 0,
                            攻击范围: 配置.攻击范围 ?? 1,
                            耐久: 配置.耐久 || 30,
                            原耐久: 配置.耐久 || 30,
                            不可破坏: 配置.不可破坏 || false,
                            攻击目标数: 配置.攻击目标数 ?? 1,
                            附魔: 配置.附魔 || [],
                            fusedBuffs: 配置.fusedBuffs || [], // 确保存在
                            ...配置.数据,
                        },
                    });
                }
                get 最终攻击范围() {
                    let 范围 = this.自定义数据.get("攻击范围") || 1;
                    const buffs = this.自定义数据.get("fusedBuffs") || [];
                    const 范围加成Buff = buffs.find(
                        (b) => b.type === 融合Buff类型.范围加成
                    );
                    if (
                        范围加成Buff &&
                        typeof 范围加成Buff.value === "number"
                    ) {
                        范围 += 范围加成Buff.value;
                    }
                    return Math.max(1, Math.round(范围));
                }
                get 最终冷却回合() {
                    let effectiveCooldown =
                        this.自定义数据.get("冷却回合") || 0;

                    if (this.强化) {
                        effectiveCooldown = Math.max(0, effectiveCooldown - 1);
                    }

                    const buffs = this.自定义数据.get("fusedBuffs") || [];
                    
                    const sharpenedCooldownBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石冷却缩减);
                    if (sharpenedCooldownBuff) {
                        effectiveCooldown -= sharpenedCooldownBuff.value;
                    }

                    buffs.forEach((buff) => {
                        if (buff.type === 融合Buff类型.冷却缩减) {
                            effectiveCooldown -= buff.value;
                        } else if (buff.type === 融合Buff类型.冷却倍率) {
                            effectiveCooldown *=
                                1 - Math.min(1, Math.max(0, buff.value));
                        }
                    });

                    return Math.max(0, Math.round(effectiveCooldown));
                }

                使用(目标怪物列表, 目标路径) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;
                    if (!目标怪物列表) return 0;
                    const buffs = this.自定义数据.get("fusedBuffs") || [];
                    const sharpenedAttackBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石攻击加成);
                    const sharpenedCooldownBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石冷却缩减);
                    let sharpenedAttackBonus = 0;
                    if (sharpenedAttackBuff) {
                        sharpenedAttackBonus = sharpenedAttackBuff.value;
                    }
                    
                    let 总伤害 = this.攻击力 + sharpenedAttackBonus;
                    let 总有效伤害 = 0;
                    let isCriticalHit = false;

                    
                    const critChanceBuff = buffs.find(
                        (b) => b.type === 融合Buff类型.暴击几率
                    );
                    if (
                        critChanceBuff &&
                        Math.random() < critChanceBuff.value
                    ) {
                        isCriticalHit = true;
                        const critDamageBuff = buffs.find(
                            (b) => b.type === 融合Buff类型.暴击伤害倍率
                        );
                        const critMultiplier =
                            1.5 + (critDamageBuff ? critDamageBuff.value : 0);
                        总伤害 *= critMultiplier;
                        添加日志(`${this.获取名称()} 打出了暴击！`, "成功");
                    }

                    目标怪物列表.forEach((怪物) => {
                        if (怪物.当前生命值 > 0) {
                            const 原始血量 = 怪物.当前生命值;
                            怪物.受伤(Math.round(总伤害), "玩家");
                            const 实际伤害 = 原始血量 - 怪物.当前生命值;
                            if (实际伤害 > 0) 总有效伤害 += 实际伤害;

                            const luckyStrikeBuff = buffs.find(
                                (b) => b.type === 融合Buff类型.幸运一击
                            );
                            if (
                                luckyStrikeBuff &&
                                Math.random() < luckyStrikeBuff.value &&
                                怪物.当前生命值 > 0
                            ) {
                                const luckyDamageMultiplier = 1.2;
                                const bonusDamage = Math.round(
                                    总伤害 * (luckyDamageMultiplier - 1)
                                );
                                const originalMonsterHealthForLucky =
                                    怪物.当前生命值;
                                怪物.受伤(bonusDamage, "幸运一击");
                                const actualBonusDamage =
                                    originalMonsterHealthForLucky -
                                    怪物.当前生命值;
                                if (actualBonusDamage > 0)
                                    总有效伤害 += actualBonusDamage;
                                添加日志(
                                    `${this.获取名称()} 触发幸运一击！额外造成 ${bonusDamage} 伤害！`,
                                    "成功"
                                );
                            }

                            const knockbackBuff = buffs.find(
                                (b) => b.type === 融合Buff类型.击退几率
                            );
                            if (
                                knockbackBuff &&
                                Math.random() < knockbackBuff.value &&
                                怪物.当前生命值 > 0
                            ) {
                                let dx = 怪物.x - 玩家.x;
                                let dy = 怪物.y - 玩家.y;
                                let 方向DX = 0,
                                    方向DY = 0;
                                if (Math.abs(dx) > Math.abs(dy))
                                    方向DX = Math.sign(dx);
                                else if (Math.abs(dy) > Math.abs(dx))
                                    方向DY = Math.sign(dy);
                                else if (dx !== 0) 方向DX = Math.sign(dx);
                                else if (dy !== 0) 方向DY = Math.sign(dy);

                                if (方向DX !== 0 || 方向DY !== 0) {
                                    const { x: 最终X, y: 最终Y } =
                                        怪物.计算最大甩飞位置(
                                            怪物.x,
                                            怪物.y,
                                            方向DX,
                                            方向DY,
                                            1
                                        );
                                    if (最终X !== 怪物.x || 最终Y !== 怪物.y) {
                                        怪物.恢复背景类型();
                                        怪物.x = 最终X;
                                        怪物.y = 最终Y;
                                        怪物.保存新位置类型(最终X, 最终Y);
                                        地牢[最终Y][最终X].类型 =
                                            单元格类型.怪物;
                                        地牢[最终Y][最终X].关联怪物 = 怪物;
                                        怪物.处理地形效果();
                                        怪物.绘制血条();
                                        添加日志(
                                            `${this.获取名称()} 将 ${
                                                怪物.类型
                                            } 击退了！`,
                                            "信息"
                                        );
                                    }
                                }
                            }
                            const fireChanceBuff = buffs.find(
                                (b) => b.type === 融合Buff类型.火焰伤害
                            );
                            if (
                                fireChanceBuff &&
                                Math.random() < fireChanceBuff.value &&
                                怪物.当前生命值 > 0
                            ) {
                                new 状态效果(
                                    "火焰",
                                    效果颜色编号映射[效果名称编号映射.火焰],
                                    "火",
                                    3,
                                    null,
                                    null,
                                    怪物,
                                    2
                                );
                                添加日志(
                                    `${this.获取名称()} 点燃了 ${怪物.类型}！`,
                                    "成功"
                                );
                            }
                            const poisonChanceBuff = buffs.find(
                                (b) => b.type === 融合Buff类型.中毒几率
                            );
                            if (
                                poisonChanceBuff &&
                                Math.random() < poisonChanceBuff.value &&
                                怪物.当前生命值 > 0
                            ) {
                                new 状态效果(
                                    "中毒",
                                    效果颜色编号映射[效果名称编号映射.中毒],
                                    "☠️",
                                    3,
                                    null,
                                    null,
                                    怪物,
                                    1 + Math.floor(this.品质 / 2)
                                );
                                添加日志(
                                    `${this.获取名称()} 使 ${
                                        怪物.类型
                                    } 中毒了！`,
                                    "成功"
                                );
                            }
                            const iceChanceBuff = buffs.find(
                                (b) => b.type === 融合Buff类型.冰冻几率
                            );
                            if (
                                iceChanceBuff &&
                                Math.random() < iceChanceBuff.value &&
                                怪物.当前生命值 > 0
                            ) {
                                new 状态效果(
                                    "冻结",
                                    "#2196F3",
                                    "冻",
                                    2,
                                    null,
                                    null,
                                    怪物
                                );
                                添加日志(
                                    `${this.获取名称()} 冻结了 ${怪物.类型}！`,
                                    "成功"
                                );
                            }
                        }
                    });

                    const lifeStealBuff = buffs.find(
                        (b) => b.type === 融合Buff类型.生命偷取
                    );
                    if (lifeStealBuff && 总有效伤害 > 0) {
                        const 吸血量 = Math.ceil(
                            总有效伤害 * lifeStealBuff.value
                        );
                        const 生命条 = document.querySelector(".health-bar");
                        const 当前宽度 = parseFloat(生命条.style.width) || 0;
                        const 新宽度 = Math.min(100, 当前宽度 + 吸血量);
                        if (新宽度 > 当前宽度) {
                            生命条.style.width = `${新宽度}%`;
                            添加日志(
                                `${this.获取名称()} 吸取了 ${吸血量.toFixed(
                                    0
                                )} 点生命！`,
                                "成功"
                            );
                            触发HUD显示();
                        }
                    }

                    const energyStealBuff = buffs.find(
                        (b) => b.type === 融合Buff类型.攻击吸能
                    );
                    if (energyStealBuff && 总有效伤害 > 0) {
                        const 吸能量 = Math.ceil(
                            总有效伤害 * energyStealBuff.value * 0.5
                        );
                        const 能量条 = document.querySelector(".power-bar");
                        const 当前能量 = parseFloat(能量条.style.width) || 0;
                        能量条.style.width = `${Math.min(
                            100,
                            当前能量 + 吸能量
                        )}%`;
                        添加日志(
                            `${this.获取名称()} 吸取了 ${吸能量.toFixed(
                                0
                            )} 点能量！`,
                            "成功"
                        );
                        触发HUD显示();
                    }

                    if (sharpenedAttackBuff) {
                        sharpenedAttackBuff.usesLeft--;
                        if (sharpenedAttackBuff.usesLeft <= 0) {
                            const index = buffs.indexOf(sharpenedAttackBuff);
                            if (index > -1) buffs.splice(index, 1);
                        }
                    }
                    if (sharpenedCooldownBuff) {
                        sharpenedCooldownBuff.usesLeft--;
                         if (sharpenedCooldownBuff.usesLeft <= 0) {
                            const index = buffs.indexOf(sharpenedCooldownBuff);
                            if (index > -1) buffs.splice(index, 1);
                        }
                    }
                    this.自定义数据.set("fusedBuffs", buffs);

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }

                    this.自定义数据.set("冷却剩余", this.最终冷却回合);

                    if (总有效伤害 > 0) {
                        if (目标怪物列表.length > 1) {
                            显示通知(
                                `${this.名称} 对 ${
                                    目标怪物列表.length
                                } 个目标造成共 ${总有效伤害.toFixed(
                                    1
                                )} 点伤害！`,
                                "成功"
                            );
                        } else {
                            显示通知(
                                `${this.名称} 造成 ${总有效伤害.toFixed(
                                    1
                                )} 点伤害！`,
                                "成功"
                            );
                        }
                    }
                    this.触发通用附魔(目标怪物列表);

                    if (总有效伤害 > 0 && 目标路径) {
                        目标路径.forEach((攻击路径) => {
                            计划显示格子特效(攻击路径);
                        });
                    }
                    return 总有效伤害;
                }

                触发通用附魔(目标怪物列表) {
                    if (!当前天气效果.includes("严寒")) {
                        if (
                            this.自定义数据
                                .get("附魔")
                                ?.find((item) => item.种类 === "火焰附魔")?.等级
                        ) {
                            const 火焰等级 = this.自定义数据
                                .get("附魔")
                                .find((item) => item.种类 === "火焰附魔").等级;
                            目标怪物列表.forEach((怪物) => {
                                if (怪物.当前生命值 > 0) {
                                    new 状态效果(
                                        "火焰",
                                        "#CC5500",
                                        "火",
                                        火焰等级,
                                        null,
                                        null,
                                        怪物
                                    );
                                }
                            });
                        }
                    }

                    const 连锁附魔 = this.自定义数据
                        .get("附魔")
                        ?.find((item) => item.种类 === "连锁附魔");
                    if (连锁附魔) {
                        const 连锁距离 = 连锁附魔.等级;
                        目标怪物列表.forEach((初始目标) => {
                            if (初始目标.当前生命值 > 0) {
                                this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                            }
                        });
                    }
                }
                触发连锁(当前目标, 连锁距离, 已攻击过的怪物 = []) {
                    let 第一层 = false;
                    if (this.访问过 === undefined) {
                        this.访问过 = [];
                        第一层 = true;
                    }
                    if (this.访问过.includes(当前目标)) return;
                    this.访问过.push(当前目标);
                    if (连锁距离 <= 0) return;
                    const 可连锁目标 = this.寻找连锁目标(
                        当前目标,
                        连锁距离,
                        this.访问过
                    );
                    for (const 新目标 of 可连锁目标) {
                        计划显示格子特效(新目标.路径);
                        this.使用([新目标.怪物]);
                        添加日志(
                            `连锁附魔击中了 ${新目标.怪物.类型}！`,
                            "成功"
                        );
                    }
                    if (第一层) this.访问过 = undefined;
                }
                寻找连锁目标(中心怪物, 连锁距离, 已攻击过的怪物) {
                    const 开放列表 = [
                        { x: 中心怪物.x, y: 中心怪物.y, 距离: 0, 路径: [] },
                    ];
                    const 已访问 = new Set([`${中心怪物.x},${中心怪物.y} `]);
                    const 可连锁目标 = [];

                    for (const 怪物 of 已攻击过的怪物) {
                        已访问.add(`${怪物.x},${怪物.y} `);
                    }

                    const 方向 = [
                        { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                        { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                        { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                        { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
                    ];

                    while (开放列表.length > 0) {
                        const 当前 = 开放列表.shift();

                        if (当前.距离 >= 连锁距离) continue;

                        for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
                            const 新X = 当前.x + dx;
                            const 新Y = 当前.y + dy;

                            if (
                                新X < 0 ||
                                新X >= 地牢大小 ||
                                新Y < 0 ||
                                新Y >= 地牢大小
                            )
                                continue;

                            const 位置键 = `${新X},${新Y} `;
                            if (已访问.has(位置键)) continue;

                            const 当前单元格 = 地牢[当前.y][当前.x];
                            const 目标单元格 = 地牢[新Y][新X];

                            if (
                                当前单元格.墙壁[当前墙] ||
                                目标单元格.墙壁[目标墙] ||
                                目标单元格.背景类型 === 单元格类型.墙壁 ||
                                目标单元格.背景类型 === 单元格类型.上锁的门
                            )
                                continue;

                            const 新路径 = [...当前.路径, { x: 新X, y: 新Y }];

                            if (
                                目标单元格.类型 === 单元格类型.怪物 &&
                                目标单元格.关联怪物?.状态 === 怪物状态.活跃
                            ) {
                                可连锁目标.push({
                                    怪物: 目标单元格.关联怪物,
                                    路径: 新路径,
                                });
                                已访问.add(位置键);
                            }
                            已访问.add(位置键);
                            开放列表.push({
                                x: 新X,
                                y: 新Y,
                                距离: 当前.距离 + 1,
                                路径: 新路径,
                            });
                        }
                    }
                    return 可连锁目标;
                }

                获取提示() {
                    const lines = super.获取提示().split("\n");
                    const weaponStats = [];
                    weaponStats.push(`攻击力：${this.攻击力.toFixed(1)}`);

                    weaponStats.push(`攻击范围：${this.最终攻击范围} 格`); // 修改点

                    if (
                        this.自定义数据.has("攻击目标数") &&
                        this.自定义数据.get("攻击目标数") > 1
                    ) {
                        weaponStats.push(
                            `穿透数量：${this.自定义数据.get("攻击目标数")} 个`
                        );
                    }

                    let insertIndex = lines.findIndex((line) =>
                        line.startsWith("品质：")
                    );
                    if (insertIndex === -1) {
                        insertIndex = lines.findIndex((line) =>
                            line.startsWith("类型：")
                        );
                    }
                    if (insertIndex === -1) {
                        insertIndex = lines.findIndex((line) =>
                            line.startsWith(this.获取名称())
                        );
                    }

                    if (insertIndex !== -1) {
                        lines.splice(insertIndex + 1, 0, ...weaponStats);
                    } else {
                        lines.unshift(...weaponStats);
                    }
                    return lines.filter(Boolean).join("\n");
                }

                获取名称() {
                    return (
                        物品.prototype.获取名称.call(this) +
                        (this.自定义数据.get("攻击目标数") > 1
                            ? " [范围武器]"
                            : "")
                    );
                }

                get 攻击力() {
                    let 基础攻击 =
                        (this.自定义数据.get("基础攻击力") || 0) +
                        (this.强化 ? 2 : 0) +
                        (玩家属性.攻击加成 || 0);
                    const buffs = this.自定义数据.get("fusedBuffs") || [];

                    buffs.forEach((buff) => {
                        if (buff.type === 融合Buff类型.攻击加成) {
                            基础攻击 += buff.value;
                        } else if (buff.type === 融合Buff类型.攻击倍率) {
                            基础攻击 *= 1 + buff.value;
                        }
                    });
                    const synergyBuffWeapon = buffs.find(
                        (b) => b.type === 融合Buff类型.协同效应
                    );
                    if (synergyBuffWeapon) {
                        基础攻击 += synergyBuffWeapon.value;
                    }

                    基础攻击 +=
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "锋利附魔")?.等级 *
                            2 || 0;

                    return Math.max(1, 基础攻击);
                }
                get 耐久消耗() {
                    if (this.自定义数据.get("不可破坏")) return 0;
                    const 耐久附魔等级 =
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "耐久附魔")?.等级 ||
                        0;
                    let 消耗系数 = 1;
                    if (耐久附魔等级 > 0) {
                        消耗系数 = 1 / (耐久附魔等级 + 1);
                    }
                    if (this.强化) {
                        消耗系数 *= 0.5;
                    }
                    return Math.max(0.1, 消耗系数); // 至少消耗0.1
                }
            }
            class 钥匙 extends 物品 {
                constructor(配置) {
                    let 钥匙唯一标识 = undefined;
                    if (配置.地牢层数 && 配置.对应门ID) {
                        钥匙唯一标识 = Symbol.for(
                            配置.地牢层数.toString() +
                                "层" +
                                配置.对应门ID.toString()
                        );
                    }
                    super({
                        类型: "钥匙",
                        名称: "钥匙",
                        图标: 图标映射.钥匙,
                        品质: 2,
                        颜色索引: 配置.颜色索引,
                        唯一标识: 钥匙唯一标识,
                        数据: {
                            对应门ID: 配置.对应门ID,
                            地牢层数: 配置.地牢层数,
                        },
                    });
                }

                获取名称() {
                    const 颜色名 = 颜色名表[this.颜色索引] || "未知";
                    return `${颜色名} 铜钥匙`;
                }

                可交互目标(门实例) {
                    if (
                        门实例.类型 == "上锁的门" &&
                        (this.自定义数据.get("地牢层数") == 当前层数 ||
                            this.自定义数据.get("地牢层数") == -1)
                    ) {
                        return (
                            this.自定义数据.get("对应门ID") === 门实例.房间ID
                        );
                    }
                }
                获取提示() {
                    return [
                        `类型：${this.类型} `,
                        `品质：${"★".repeat(this.品质)} `,
                        `房间 ID：${this.自定义数据.get("对应门ID")} `,
                        `层数：${this.自定义数据.get("地牢层数")} `,
                    ].join("\n");
                }
                使用() {
                    显示通知("请使用互动键来使用钥匙", "错误");
                    return false;
                }
            }
            class 金币 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "金币",
                        名称: "金币",
                        图标: 图标映射.金币,
                        品质: 1,
                        颜色索引: 2,
                        堆叠数量: 配置.数量 || 1,
                        是否隐藏: 配置.是否隐藏 || false,
                    });
                }

                获取名称() {
                    return `${this.名称} `;
                }
                使用() {
                    return false;
                }
            }

            class 卷轴类 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "卷轴",
                        名称: 配置.名称 || "魔法卷轴",
                        效果描述: 配置.效果描述 || "未知效果",
                        图标: 配置.图标 || 图标映射.卷轴,
                        品质: 配置.品质 || 3,
                        颜色索引: 配置.品质 - 1 || 2,
                        堆叠数量: 配置.堆叠数量 || 1,
                        强化: 配置.强化 || false,
                        最大堆叠数量: 1,
                        数据: {
                            能量消耗: 配置.能量消耗 ?? 2,
                            已解锁: 配置.已解锁 || false,
                            ...配置.数据,
                        },
                    });
                }
                安全销毁() {
                    if (当前激活卷轴列表.has(this))
                        当前激活卷轴列表.delete(this);
                    let ret = super.安全销毁();

                    return ret;
                }
                使用() {
                    // 具体效果由子类实现
                    return false;
                }
                获取名称() {
                    return this.自定义数据.get("已解锁")
                        ? `${this.名称} [${this.品质} 级]` +
                              (this.强化 ? " [强化]" : "")
                        : "卷轴";
                }
                消耗能量() {
                    if (当前天气效果.includes("诡魅")) {
                        显示通知("不论如何念咒，卷轴依然无法启用...");
                        当前激活卷轴列表.delete(this);
                        return false;
                    }
                    return 扣除能量(this.最终能量消耗, true);
                }
                get 最终能量消耗() {
                    return Math.max(
                        this.自定义数据.get("能量消耗") - (this.强化 ? 2 : 0),
                        0
                    );
                }
                get 显示图标() {
                    return this.自定义数据.get("已解锁")
                        ? this.图标
                        : 图标映射.卷轴;
                }
                get 显示名称() {
                    return this.自定义数据.get("已解锁") ? this.名称 : "卷轴";
                }
                生成显示元素(用途 = "背包") {
                    let 元素 = super.生成显示元素(用途);
                    this.装备按钮.onclick = (e) => {
                        e.stopPropagation();
                        this.isActive = true;
                        元素.classList.add("active");
                        document.querySelectorAll(".物品条目").forEach((el) => {
                            if (el !== 元素 && el.__物品实例) {
                                el.classList.remove("active");
                                el.__物品实例.isActive = false;
                            }
                        });
                        if (this.已装备) {
                            this.取消装备();
                            显示通知("已卸下", "成功");
                        } else {
                            if (this.装备()) {
                                显示通知("已装备", "成功");
                            } else {
                                显示通知("装备槽已满！", "错误");
                            }
                        }
                        this.装备按钮.style.background = this.已装备
                            ? "#f44336"
                            : "#FF9800";
                        更新装备显示();
                        更新背包显示();

                        document.getElementById("浮动提示框").style.display =
                            "none";
                    };

                    return 元素;
                }
                取消装备() {
                    if (!this.已装备) return false;
                    if (当前激活卷轴列表.has(this)) {
                        当前激活卷轴列表.delete(this);
                        this.卸下();
                    }
                    let ret = super.取消装备();
                    return ret;
                }
                卸下() {
                    return true;
                }
                获取提示() {
                    if (this.自定义数据.get("已解锁")) {
                        return [
                            `${this.获取名称()} `,
                            `品质：${"★".repeat(this.品质)} `,
                            `能量消耗：${this.最终能量消耗} `,
                            `效果描述：${this.效果描述} `,
                        ].join("\n");
                    } else {
                        return "古老的卷轴，似乎透露着什么秘密...";
                    }
                }
            }
            class 防御装备类 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "防御装备",
                        名称: 配置.名称 || "护甲模板",
                        图标: 配置.图标 || "🛡️",
                        品质: 配置.品质 || 2,
                        颜色索引: 配置.品质 - 1 || 1,
                        最大堆叠数量: 1,
                        堆叠数量: 配置.堆叠数量 || 1,
                        效果描述: 配置.效果描述 || null,
                        强化: 配置.强化 || false,
                        数据: {
                            防御力: 配置.防御力 || 1,
                            耐久: 配置.耐久 || 100,
                            原耐久: 配置.耐久 || 100,
                            不可破坏: 配置.不可破坏 || false,
                            附魔: 配置.附魔 || [],
                            fusedBuffs: 配置.fusedBuffs || [],
                            ...配置.数据,
                        },
                    });
                }
                get 最终防御力() {
                    let 基础防御 =
                        (this.自定义数据.get("防御力") || 0) +
                        (this.强化 ? 2 : 0);
                    const buffs = this.自定义数据.get("fusedBuffs") || [];

                    buffs.forEach((buff) => {
                        if (buff.type === 融合Buff类型.防御加成) {
                            基础防御 += buff.value;
                        } else if (buff.type === 融合Buff类型.防御倍率) {
                            基础防御 *= 1 + buff.value;
                        }
                    });

                    const synergyBuffArmor = buffs.find(
                        (b) => b.type === 融合Buff类型.协同效应
                    );
                    if (synergyBuffArmor) {
                        基础防御 += synergyBuffArmor.value;
                    }

                    基础防御 +=
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "保护附魔")?.等级 ||
                        0;
                    return Math.max(0, 基础防御);
                }
                get 耐久消耗() {
                    if (this.自定义数据.get("不可破坏")) return 0;
                    const 耐久附魔等级 =
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "耐久附魔")?.等级 ||
                        0;
                    let 消耗系数 = 1;
                    if (耐久附魔等级 > 0) {
                        消耗系数 = 1 / (耐久附魔等级 + 1);
                    }
                    if (this.强化) {
                        消耗系数 *= 0.5;
                    }
                    return Math.max(0.1, 消耗系数);
                }
                get 反伤() {
                    const 荆棘附魔等级 =
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "荆棘附魔")?.等级 ||
                        0;
                    if (荆棘附魔等级 > 0) {
                        return 荆棘附魔等级 * 1.5;
                    }
                    return 0;
                }

                当被攻击(原始攻击力, 来源 = null) {
                    let 最终伤害 = 原始攻击力;
                    const buffs = this.自定义数据.get("fusedBuffs") || [];

                    const flatReductionBuff = buffs.find(
                        (b) => b.type === 融合Buff类型.固定伤害减免
                    );
                    if (flatReductionBuff) {
                        最终伤害 = Math.max(
                            0,
                            最终伤害 - flatReductionBuff.value
                        );
                    }

                    最终伤害 = Math.max(0, 最终伤害 - this.最终防御力);

                    if (
                        来源 === "炸弹" &&
                        this.自定义数据
                            .get("附魔")
                            .some(
                                (item) =>
                                    item.种类 === "爆炸保护附魔" &&
                                    item.等级 > 0
                            )
                    ) {
                        最终伤害 = Math.max(
                            0,
                            最终伤害 -
                                this.自定义数据
                                    .get("附魔")
                                    .find(
                                        (item) => item.种类 === "爆炸保护附魔"
                                    )?.等级 *
                                    5
                        );
                    }

                    if (
                        来源 instanceof 怪物 &&
                        this.自定义数据
                            .get("附魔")
                            .some(
                                (item) =>
                                    item.种类 === "火焰附魔" && item.等级 > 0
                            )
                    ) {
                        const 火焰等级 = this.自定义数据
                            .get("附魔")
                            .find((item) => item.种类 === "火焰附魔").等级;
                        new 状态效果(
                            "火焰",
                            "#CC5500",
                            "火",
                            火焰等级,
                            null,
                            null,
                            来源
                        );
                    }

                    const dodgeBuff = buffs.find(
                        (b) => b.type === 融合Buff类型.闪避几率
                    );
                    if (dodgeBuff && Math.random() < dodgeBuff.value) {
                        添加日志(`${this.获取名称()} 触发闪避！`, "成功");
                        最终伤害 = 0;
                    }

                    const poisonChanceBuff = buffs.find(
                        (b) => b.type === 融合Buff类型.中毒几率
                    );
                    if (
                        poisonChanceBuff &&
                        来源 instanceof 怪物 &&
                        来源.当前生命值 > 0 &&
                        Math.random() < poisonChanceBuff.value
                    ) {
                        new 状态效果(
                            "中毒",
                            效果颜色编号映射[效果名称编号映射.中毒],
                            "☠️",
                            3,
                            null,
                            null,
                            来源,
                            1 + Math.floor(this.品质 / 2)
                        );
                        添加日志(
                            `${this.获取名称()} 使 ${来源.类型} 中毒了！`,
                            "成功"
                        );
                    }

                    if (最终伤害 <= 0 && 原始攻击力 > 0)
                        最终伤害 = Math.round(Math.random() * 100) / 100;

                    if (最终伤害 > 0) {
                        this.自定义数据.set(
                            "耐久",
                            this.自定义数据.get("耐久") - this.耐久消耗
                        );
                        if (
                            this.反伤 > 0 &&
                            来源 instanceof 怪物 &&
                            !(来源 instanceof 仙人掌怪物)
                        ) {
                            来源.受伤(this.反伤, "荆棘");
                            添加日志(
                                `${this.名称} 因荆棘造成了 ${this.反伤} 点伤害！`,
                                "成功"
                            );
                        }

                        const energyOnHitBuff = buffs.find(
                            (b) => b.type === 融合Buff类型.受击回能
                        );
                        if (energyOnHitBuff) {
                            const 恢复能量 = Math.ceil(energyOnHitBuff.value);
                            const 能量条 = document.querySelector(".power-bar");
                            const 当前能量 =
                                parseFloat(能量条.style.width) || 0;
                            能量条.style.width = `${Math.min(
                                100,
                                当前能量 + 恢复能量
                            )}%`;
                            添加日志(
                                `${this.获取名称()} 受到攻击，恢复了 ${恢复能量} 点能量！`,
                                "信息"
                            );
                            触发HUD显示();
                        }
                    }

                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }

                    return 最终伤害;
                }

                获取提示() {
                    const lines = super.获取提示().split("\n");
                    const armorStats = [
                        `防御力：${this.最终防御力.toFixed(1)}`,
                    ];

                    let insertIndex = lines.findIndex((line) =>
                        line.startsWith("品质：")
                    );
                    if (insertIndex === -1) {
                        insertIndex = lines.findIndex((line) =>
                            line.startsWith("类型：")
                        );
                    }
                    if (insertIndex === -1) {
                        insertIndex = lines.findIndex((line) =>
                            line.startsWith(this.获取名称())
                        );
                    }

                    if (insertIndex !== -1) {
                        lines.splice(insertIndex + 1, 0, ...armorStats);
                    } else {
                        lines.unshift(...armorStats);
                    }
                    return lines.filter(Boolean).join("\n");
                }
                使用() {
                    显示通知("装备不能被主动使用！", "错误");
                    return false;
                }
            }
            class 吸血剑 extends 武器类 {
                constructor(配置) {
                    super({
                        名称: "吸血剑",
                        图标: 图标映射.吸血剑,
                        品质: 2,
                        基础攻击力: 6,
                        冷却回合: 3,
                        攻击范围: 1,
                        耐久: 配置?.耐久 || 80,
                        强化: 配置?.强化 || false,
                        效果描述: `${(0.7 * 100).toFixed(0)}%概率吸取造成伤害${(
                            0.25 * 100
                        ).toFixed(0)}%的生命。`,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        fusedBuffs: 配置?.数据?.fusedBuffs || [],
                        数据: {
                            吸血概率: 0.7,
                            吸血比例: 0.25,
                            ...(配置?.数据 || {}),
                        },
                    });
                }

                使用(目标怪物列表, 目标路径) {
                    const 总有效伤害 = super.使用(目标怪物列表, 目标路径); // 调用父类，它会处理暴击、击退等
                    if (总有效伤害 > 0) {
                        let 吸血概率 = this.自定义数据.get("吸血概率");
                        let 吸血比例 = this.自定义数据.get("吸血比例");

                        // 检查是否有生命偷取buff，如果有，则优先使用buff的几率和比例
                        const lifeStealBuff = (
                            this.自定义数据.get("fusedBuffs") || []
                        ).find((b) => b.type === 融合Buff类型.生命偷取);
                        if (lifeStealBuff) {
                            吸血概率 = lifeStealBuff.value; // 直接使用buff的value作为几率
                            吸血比例 = lifeStealBuff.value; // 假设buff的value同时代表比例，或者需要单独定义比例
                        }

                        if (Math.random() < 吸血概率) {
                            const 吸血量 = Math.ceil(总有效伤害 * 吸血比例);
                            const 生命条 =
                                document.querySelector(".health-bar");
                            const 当前宽度 =
                                parseFloat(生命条.style.width) || 0;
                            const 新宽度 = Math.min(100, 当前宽度 + 吸血量);
                            if (新宽度 > 当前宽度) {
                                生命条.style.width = `${新宽度}%`;
                                添加日志(
                                    `${this.获取名称()} 吸取了 ${吸血量.toFixed(
                                        0
                                    )} 点生命！`,
                                    "成功"
                                );
                                触发HUD显示();
                            }
                        }
                        return true;
                    }
                    return false;
                }
            }
            class 棋子 extends 物品 {
                constructor(配置) {
                    super({
                        类型: "棋子",
                        名称: 配置.名称 || "棋子",
                        图标: 配置.图标,
                        品质: 1,
                        颜色索引: 2,
                        最大堆叠数量: 8,
                        效果描述: "使用可以在玩家位置落子，按互动键可以提子",
                        ...配置,
                    });
                    this.能否拾起 = true;
                }

                可攻击位置(x, y, 棋盘) {
                    return [];
                }
                使用(玩家使用 = true, x0 = 0, y0 = 0) {
                    if (this.堆叠数量 <= 0) return false; // 检查是否有棋子可用

                    let 放置成功 = false;
                    if (玩家使用) {
                        const 当前房间ID = 房间地图[玩家.y][玩家.x];
                        const 当前房间 = 房间列表[当前房间ID];
                        if (当前房间?.类型 === "隐藏解谜棋盘") {
                            // 检查房间类型
                            let ret = 玩家放置物品(this, false); // 放置棋子逻辑不变
                            if (ret.x !== null) {
                                // 检查放置是否成功
                                放置成功 = true;
                                检查解谜是否成功(当前房间.棋子数量);
                                显示通知("落子成功", "成功");
                            } else {
                                显示通知("无法在此处落子", "错误");
                                return false; // 放置失败，不消耗棋子
                            }
                        } else {
                            显示通知("只能在解谜棋盘上落子", "错误");
                            return false; // 不在棋盘上，不消耗
                        }
                    } else {
                        // 非玩家使用（例如编辑器放置）的逻辑 - 可能不需要修改消耗
                        放置成功 = true; // 假设非玩家使用总是“成功”放置，不涉及消耗
                    }

                    if (放置成功 && 玩家使用) {
                        // 只有玩家成功放置才消耗
                        this.堆叠数量 -= 1; // 消耗一个棋子
                        if (this.堆叠数量 <= 0) {
                            // 如果是最后一个棋子，从背包或装备中移除
                            if (this.已装备) {
                                玩家装备.delete(this.装备槽位);
                                this.已装备 = false;
                                this.装备槽位 = null;
                                更新装备显示();
                            }
                            玩家背包.delete(this.唯一标识);
                            更新背包显示(); // 更新UI显示数量或移除条目
                        } else {
                            // 如果还有棋子，仅更新UI显示数量
                            更新背包显示();
                            更新装备显示();
                        }
                        return true; // 返回放置结果（放置逻辑已处理）
                    } else if (!玩家使用 && 放置成功) {
                        // 非玩家使用，可能不需要消耗或UI更新，直接返回true
                        return true;
                    }

                    return false; // 放置失败或其他情况
                }
            }

            class 国际象棋车 extends 棋子 {
                constructor(配置 = {}) {
                    super({
                        名称: "国际象棋车",
                        图标: "♜",
                        ...配置,
                    });
                }
                可攻击位置(x, y, 棋盘) {
                    const 攻击位置 = [];
                    const 棋盘大小 = 棋盘.length;

                    for (let i = 0; i < 棋盘大小; i++) {
                        if (i !== x) 攻击位置.push({ x: i, y: y });
                    }

                    for (let j = 0; j < 棋盘大小; j++) {
                        if (j !== y) 攻击位置.push({ x: x, y: j });
                    }

                    return 攻击位置;
                }
            }

            class 国际象棋马 extends 棋子 {
                constructor(配置 = {}) {
                    super({
                        名称: "国际象棋马",
                        图标: "♞",
                        ...配置,
                    });
                }

                可攻击位置(x, y, 棋盘) {
                    const 攻击位置 = [];
                    const 棋盘大小 = 棋盘.length;
                    const dx = [-2, -2, -1, -1, 1, 1, 2, 2];
                    const dy = [-1, 1, -2, 2, -2, 2, -1, 1];
                    for (let i = 0; i < 8; i++) {
                        const 新x = x + dx[i];
                        const 新y = y + dy[i];
                        if (
                            新x >= 0 &&
                            新x < 棋盘大小 &&
                            新y >= 0 &&
                            新y < 棋盘大小
                        ) {
                            攻击位置.push({ x: 新x, y: 新y });
                        }
                    }
                    return 攻击位置;
                }
            }

            class 国际象棋象 extends 棋子 {
                constructor(配置 = {}) {
                    super({
                        名称: "国际象棋象",
                        图标: "♝",
                        ...配置,
                    });
                }

                可攻击位置(x, y, 棋盘) {
                    const 攻击位置 = [];
                    const 棋盘大小 = 棋盘.length;

                    const directions = [
                        [1, 1],
                        [1, -1],
                        [-1, 1],
                        [-1, -1],
                    ];
                    for (const [dx, dy] of directions) {
                        for (let i = 1; i < 棋盘大小; i++) {
                            const 新x = x + i * dx;
                            const 新y = y + i * dy;

                            if (
                                新x >= 0 &&
                                新x < 棋盘大小 &&
                                新y >= 0 &&
                                新y < 棋盘大小
                            ) {
                                攻击位置.push({ x: 新x, y: 新y });
                            } else {
                                break;
                            }
                        }
                    }

                    return 攻击位置;
                }
            }

            class 中国象棋炮 extends 棋子 {
                constructor(配置 = {}) {
                    super({
                        名称: "中国象棋炮",
                        图标: "♚",
                        ...配置,
                    });
                }

                可攻击位置(x, y, 棋盘) {
                    const 攻击位置 = [];
                    const 棋盘大小 = 棋盘.length;

                    const directions = [
                        [1, 0],
                        [-1, 0],
                        [0, 1],
                        [0, -1],
                    ];
                    for (const [dx, dy] of directions) {
                        let 隔子 = false;
                        for (let i = 1; i < 棋盘大小; i++) {
                            const 新x = x + i * dx;
                            const 新y = y + i * dy;

                            if (
                                新x >= 0 &&
                                新x < 棋盘大小 &&
                                新y >= 0 &&
                                新y < 棋盘大小
                            ) {
                                if (棋盘[新y][新x] !== 0) {
                                    if (!隔子) {
                                        隔子 = true;
                                    } else {
                                        攻击位置.push({ x: 新x, y: 新y });
                                        break;
                                    }
                                } else if (!隔子) {
                                    攻击位置.push({ x: 新x, y: 新y });
                                }
                            } else {
                                break;
                            }
                        }
                    }

                    return 攻击位置;
                }
            }
            class 药水类 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "药水",
                        名称: 配置.名称 || "基础药水",
                        图标: 配置.图标 || 图标映射.药水,
                        品质: 配置.品质 || 3,
                        颜色索引: 效果名称编号映射[配置.效果类型] || 0,
                        堆叠数量: 配置.堆叠数量 || 1,
                        最大堆叠数量: 16,
                        效果描述: 配置.效果描述 || null,
                        强化: 配置.强化 || false,
                        数据: {
                            是否冻结: 配置.是否冻结 || false,
                            基础持续时间: 配置.持续时间 || 3,
                            效果强度: 配置.效果强度 || 1,
                            效果类型: 配置.效果类型 || null,
                            ...配置.数据,
                        },
                    });
                    this.激活中 = false;
                    this.状态效果 = null;
                }
                获取名称() {
                    let 基础名称 = super.获取名称();
                    if (this.自定义数据?.get("是否冻结")) {
                        基础名称 += " [冻]";
                    }
                    return 基础名称;
                }

                使用() {
                    if (this.自定义数据?.get("是否冻结")) {
                        显示通知("药水被冻住了，无法使用！", "警告");
                        return false;
                    }
                    if (this.激活中) {
                        显示通知(
                            `${this.自定义数据.get("效果类型")} 效果已存在`,
                            "错误"
                        );
                        return false;
                    }

                    // 应用效果
                    this.激活中 = true;
                    this.状态效果 = new 状态效果(
                        this.自定义数据.get("效果类型"),
                        this.获取药水颜色(),
                        this.图标,
                        this.持续时间,
                        this.持续时间,
                        this
                    );
                    this.应用效果();

                    // 关键修复：在这里直接调用父类的使用方法来消耗一个单位
                    super.使用();

                    绘制();
                    显示通知(`${this.名称} 效果生效！`, "成功");
                    return true;
                }

                获取药水颜色() {
                    return 效果颜色编号映射[this.颜色索引] || "#FFFFFF";
                }

                应用效果() {
                    // 子类在这实现自定义效果...
                    return;
                }

                // [已修正]
                移除效果() {
                    this.激活中 = false;
                    // 关键修复：移除这里的 super.使用() 调用，因为消耗已经在“使用”时完成。
                    // 子类在这还原效果...
                    return;
                }

                获取提示() {
                    return [
                        super.获取提示(),
                        `效果类型: ${this.自定义数据.get("效果类型")} `,
                        `持续时间: ${this.持续时间} 回合`,
                        `强度: +${this.强度} `,
                    ].join("\n");
                }
                get 强度() {
                    return (
                        this.自定义数据.get("效果强度") + (this.强化 ? 2 : 0)
                    );
                }
                get 持续时间() {
                    return (
                        this.自定义数据.get("基础持续时间") +
                        (this.强化 ? 2 : 0)
                    );
                }
                get 颜色表() {
                    return 效果颜色编号映射;
                }
            }

            class 治疗药水 extends 药水类 {
                constructor(配置) {
                    super({
                        名称: "治疗药水",
                        效果类型: "治疗",
                        持续时间: 5,
                        效果强度: 2,
                        堆叠数量: 配置.数量 || 1,
                        强化: 配置.强化 || false,
                    });
                }
                应用效果() {
                    const 当前生命 =
                        parseFloat(
                            document.querySelector(".health-bar").style.width
                        ) || 0;
                    document.querySelector(
                        ".health-bar"
                    ).style.width = `${Math.min(
                        100,
                        当前生命 + 4 * this.强度 //实际强度由getter决定
                    )}% `;
                    return;
                }
                移除效果() {
                    super.移除效果();
                    return;
                }
            }

            class 能量药水 extends 药水类 {
                constructor(配置) {
                    super({
                        名称: "能量药水",
                        效果类型: "能量",
                        持续时间: 5,
                        效果强度: 2,
                        堆叠数量: 配置.数量 || 1,
                        强化: 配置.强化 || false,
                    });
                }
                应用效果() {
                    const 当前能量 =
                        parseFloat(
                            document.querySelector(".power-bar").style.width
                        ) || 0;
                    document.querySelector(
                        ".power-bar"
                    ).style.width = `${Math.min(
                        100,
                        当前能量 + 3 * this.强度
                    )}% `;
                    return;
                }
                移除效果() {
                    super.移除效果();
                    return;
                }
            }
            class 狂暴药水 extends 药水类 {
                constructor(配置) {
                    super({
                        名称: "狂暴药水",
                        效果类型: "狂暴",
                        持续时间: 10,
                        效果强度: 1,
                        堆叠数量: 配置.数量 || 1,
                        强化: 配置.强化 || false,
                    });
                }
                应用效果() {
                    玩家属性.攻击加成 = 2 + 5 * this.强度;
                    return;
                }
                移除效果() {
                    玩家属性.攻击加成 = 0;
                    super.移除效果();
                    return;
                }
            }
            class 神龟药水 extends 药水类 {
                constructor(配置) {
                    super({
                        名称: "神龟药水",
                        效果类型: "神龟",
                        持续时间: 20,
                        效果强度: 1,
                        效果描述: "给予你赛尔达飞艇级别的防御",
                        堆叠数量: 配置.数量 || 1,
                        强化: 配置.强化 || false,
                    });
                }
                应用效果() {
                    玩家属性.防御加成 = 2 + 5 * this.强度;
                    return;
                }
                移除效果() {
                    玩家属性.防御加成 = 0;
                    super.移除效果();
                    return;
                }
            }
            class 隐身药水 extends 药水类 {
                constructor(配置) {
                    super({
                        名称: "隐身药水",
                        效果类型: "隐身",
                        持续时间: 35,
                        效果强度: 1,
                        效果描述: "悄悄滴进村，打枪滴不要。怪物视距全部变为 1",
                        堆叠数量: 配置.数量 || 1,
                        强化: 配置.强化 || false,
                    });
                }
                应用效果() {
                    处理怪物回合();
                    return; // 在 处理怪物回合 中检测了 玩家状态 来实现
                }
                移除效果() {
                    super.移除效果();
                    return;
                }
            }
            class 透视药水 extends 药水类 {
                constructor(配置) {
                    super({
                        名称: "透视药水",
                        效果类型: "透视",
                        持续时间: 50,
                        效果强度: 1,
                        效果描述: "透过迷雾，看清房内的陷阱",
                        堆叠数量: 配置.数量 || 1,
                        强化: 配置.强化 || false,
                    });
                }
                应用效果() {
                    玩家属性.透视 = true;
                    绘制();
                    return;
                }
                移除效果() {
                    玩家属性.透视 = false;
                    super.移除效果();
                    return;
                }
            }
            class 冰霜法杖 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "冰霜法杖",
                        图标: 图标映射.冰霜法杖,
                        品质: 3,
                        基础攻击力: 6,
                        冷却回合: 7,
                        攻击范围: 3,
                        耐久: 配置?.耐久 || 45,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "释放一圈冰霜能量，对范围内的敌人造成伤害并有几率冻结。",
                        攻击目标数: 99,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            冻结几率: 0.75 + (配置?.强化 ? 0.15 : 0),
                            冻结回合: 2,
                            ...配置.数据,
                        },
                    });
                }

                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;

                    const 范围 = this.最终攻击范围;
                    const 击中怪物 = new Set();
                    let 总有效伤害 = 0;
                    const 影响格子分层 = Array.from(
                        { length: 范围 + 1 },
                        () => []
                    );

                    const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0 }];
                    const 已访问 = new Set();
                    影响格子分层[0].push();

                    while (队列.length > 0) {
                        const 当前 = 队列.shift();
                        if (当前.距离 >= 范围) continue;

                        const 方向 = [
                            { dx: 1, dy: 0 },
                            { dx: -1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: 0, dy: -1 },
                        ];

                        for (const { dx, dy } of 方向) {
                            const 新X = 当前.x + dx;
                            const 新Y = 当前.y + dy;
                            const 位置键 = `${新X},${新Y}`;

                            if (
                                新X >= 0 &&
                                新X < 地牢大小 &&
                                新Y >= 0 &&
                                新Y < 地牢大小 &&
                                !已访问.has(位置键)
                            ) {
                                if (
                                    检查视线(玩家.x, 玩家.y, 新X, 新Y, 范围 + 1)
                                ) {
                                    已访问.add(位置键);
                                    const 新距离 = 当前.距离 + 1;
                                    影响格子分层[新距离].push({
                                        x: 新X,
                                        y: 新Y,
                                    });
                                    队列.push({ x: 新X, y: 新Y, 距离: 新距离 });

                                    const 单元格 = 地牢[新Y][新X];

                                    if (
                                        单元格?.关联物品 instanceof 祭坛类 &&
                                        单元格.关联物品.自定义数据.get(
                                            "激活条件"
                                        ) === "冰霜封印" &&
                                        !单元格.关联物品.自定义数据.get(
                                            "已激活"
                                        )
                                    ) {
                                        单元格.关联物品.激活();
                                    }

                                    if (
                                        单元格?.关联怪物 instanceof 怪物 &&
                                        单元格.关联怪物.当前生命值 > 0
                                    ) {
                                        const 怪物 = 单元格.关联怪物;
                                        if (!击中怪物.has(怪物)) {
                                            击中怪物.add(怪物);
                                            const 原始血量 = 怪物.当前生命值;
                                            怪物.受伤(this.攻击力, "玩家");
                                            const 实际伤害 =
                                                原始血量 - 怪物.当前生命值;
                                            if (实际伤害 > 0)
                                                总有效伤害 += 实际伤害;

                                            if (
                                                怪物.当前生命值 > 0 &&
                                                Math.random() <
                                                    this.自定义数据.get(
                                                        "冻结几率"
                                                    )
                                            ) {
                                                new 状态效果(
                                                    "冻结",
                                                    "#2196F3",
                                                    "冻",
                                                    this.自定义数据.get(
                                                        "冻结回合"
                                                    ),
                                                    null,
                                                    null,
                                                    怪物
                                                );
                                                添加日志(
                                                    `${怪物.类型} 被冰霜法杖冻结了！`,
                                                    "警告"
                                                );
                                            }
                                        }
                                    } else if (
                                        单元格.关联物品 instanceof 炸弹
                                    ) {
                                        if (!单元格.关联物品.能否拾起) {
                                            单元格.关联物品.自定义数据.set(
                                                "倒计时",
                                                单元格.关联物品.自定义数据.get(
                                                    "爆炸时间"
                                                )
                                            );
                                            单元格.关联物品.能否拾起 = true;
                                            所有计时器 = 所有计时器.filter(
                                                (item) =>
                                                    item !== 单元格.关联物品
                                            );
                                            单元格.关联物品.x = null;
                                            单元格.关联物品.y = null;
                                            添加日志("炸弹已被熄灭！", "信息");
                                        }
                                    } else if (
                                        单元格.关联物品 instanceof 火焰物品
                                    ) {
                                        单元格.关联物品 = null;
                                        if (单元格.类型 === 单元格类型.物品)
                                            单元格.类型 = null;
                                        单元格.颜色索引 = 颜色表.length;
                                    }
                                }
                            }
                        }
                    }

                    影响格子分层.forEach((层内格子, 层级) => {
                        if (层内格子.length > 0) {
                            setTimeout(() => {
                                计划显示格子特效(层内格子, "ADD8E6", 0);
                            }, 层级 * 80);
                        }
                    });

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set(
                        "冷却剩余",
                        this.自定义数据.get("冷却回合")
                    );

                    if (击中怪物.size > 0) {
                        显示通知(
                            `${this.名称} 释放了冰霜！击中 ${
                                击中怪物.size
                            } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
                            "成功"
                        );
                        const 所有击中怪物 = Array.from(击中怪物);

                        if (总有效伤害 > 0) {
                            this.触发通用附魔(所有击中怪物);
                        }
                    } else {
                        显示通知(`${this.名称} 释放了冰霜！`, "信息");
                    }
                    绘制();
                    更新装备显示();
                    return 总有效伤害;
                }

                触发通用附魔(目标怪物列表) {
                    if (
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "火焰附魔")?.等级
                    ) {
                        const 火焰等级 = this.自定义数据
                            .get("附魔")
                            .find((item) => item.种类 === "火焰附魔").等级;
                        目标怪物列表.forEach((怪物) => {
                            if (怪物.当前生命值 > 0) {
                                new 状态效果(
                                    "火焰",
                                    "#CC5500",
                                    "火",
                                    火焰等级,
                                    null,
                                    null,
                                    怪物
                                );
                            }
                        });
                    }
                    const 连锁附魔 = this.自定义数据
                        .get("附魔")
                        ?.find((item) => item.种类 === "连锁附魔");
                    if (连锁附魔) {
                        const 连锁距离 = 连锁附魔.等级;
                        目标怪物列表.forEach((初始目标) => {
                            if (初始目标.当前生命值 > 0) {
                                this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                            }
                        });
                    }
                }

                获取提示() {
                    let lines = super.获取提示().split("\n");
                    const specificEffectLines = [
                        `冻结几率：${(
                            this.自定义数据.get("冻结几率") * 100
                        ).toFixed(0)}% (${this.自定义数据.get(
                            "冻结回合"
                        )}回合)`,
                    ];

                    const effectDescIndex = lines.findIndex((line) =>
                        line.startsWith("效果描述：")
                    );
                    let insertAtIndex =
                        effectDescIndex !== -1
                            ? effectDescIndex + 1
                            : lines.findIndex((line) =>
                                  line.startsWith("--- 强化效果 ---")
                              );
                    if (insertAtIndex === -1) insertAtIndex = lines.length;

                    lines.splice(insertAtIndex, 0, ...specificEffectLines);
                    return lines.filter(Boolean).join("\n");
                }
            }
            class 荆棘种子 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "种子",
                        名称: "荆棘种子",
                        图标: 图标映射.种子,
                        品质: 1,
                        颜色索引: 0, // 绿色系
                        堆叠数量: 配置.数量 || Math.ceil(Math.random() * 5),
                        最大堆叠数量: 16,
                        效果描述:
                            "在相邻空格子播种，生成持续数回合的荆棘丛，可以用互动键收回。",
                        强化: 配置.强化 || false, // 强化可能增加荆棘伤害或持续时间
                        数据: {
                            荆棘持续时间: 5 + (配置.强化 ? 3 : 0),
                            荆棘伤害: 3 + (配置.强化 ? 2 : 0),
                            减速概率: 0.6 + (配置.强化 ? 0.1 : 0),
                            减速回合: 7,
                            ...配置.数据,
                        },
                        ...配置,
                    });
                }

                使用() {
                    if (this.堆叠数量 <= 0) return false;

                    const 方向数组 = [
                        { dx: 0, dy: 0 },
                        { dx: 0, dy: -1 },
                        { dx: 1, dy: 0 },
                        { dx: 0, dy: 1 },
                        { dx: -1, dy: 0 },
                    ];
                    let 放置成功 = false;
                    let 目标X = -1,
                        目标Y = -1;

                    // 查找玩家周围可放置的格子
                    for (const { dx, dy } of 方向数组) {
                        const 检查X = 玩家.x + dx;
                        const 检查Y = 玩家.y + dy;
                        if (
                            (检查X >= 0 &&
                                检查X < 地牢大小 &&
                                检查Y >= 0 &&
                                检查Y < 地牢大小 &&
                                位置是否可用(检查X, 检查Y, false)) ||
                            !检查直线移动可行性(
                                玩家.x,
                                玩家.y,
                                检查X,
                                检查Y,
                                true
                            )
                        ) {
                            // 检查格子是否为空地
                            目标X = 检查X;
                            目标Y = 检查Y;
                            放置成功 = true;
                            break; // 找到第一个可用格子就放置
                        }
                    }

                    if (!放置成功) {
                        显示通知("周围没有合适的地方播种！", "错误");
                        return false;
                    }

                    // 创建荆棘丛实例
                    const 荆棘丛实例 = new 荆棘丛({
                        倒计时: this.自定义数据.get("荆棘持续时间"),
                        爆炸时间: this.自定义数据.get("荆棘持续时间"), // 复用
                        伤害: this.自定义数据.get("荆棘伤害"),
                        减速概率: this.自定义数据.get("减速概率"),
                        减速回合: this.自定义数据.get("减速回合"),
                        强化: this.强化, // 传递强化状态给荆棘丛
                    });

                    // 放置荆棘丛到地牢
                    if (放置物品到单元格(荆棘丛实例, 目标X, 目标Y)) {
                        荆棘丛实例.x = 目标X; // 确保实例有坐标
                        荆棘丛实例.y = 目标Y;
                        所有计时器.push(荆棘丛实例); // 加入计时器列表使其能自动消失
                        显示通知(
                            `在 (${目标X}, ${目标Y}) 种下了荆棘丛！`,
                            "成功"
                        );

                        // 消耗种子
                        this.堆叠数量 -= 1;

                        计划显示格子特效([{ x: 目标X, y: 目标Y }], "228B22"); // 深绿色特效
                        return true;
                    } else {
                        显示通知("无法放置荆棘丛！", "错误");
                        return false;
                    }
                }

                获取提示() {
                    return [
                        `${this.获取名称()} `,
                        `类型：${this.类型}`,
                        `品质：${"★".repeat(this.品质)}`,
                        `堆叠：${this.堆叠数量} / ${this.最大堆叠数量}`,
                        `效果：${this.效果描述}`,
                        `荆棘持续：${this.自定义数据.get("荆棘持续时间")} 回合`,
                        `进入伤害：${this.自定义数据.get("荆棘伤害")} 点`,
                        `减速几率：${(
                            this.自定义数据.get("减速概率") * 100
                        ).toFixed(0)}% (${this.自定义数据.get(
                            "减速回合"
                        )}回合)`,
                    ].join("\n");
                }
            }

            class 荆棘丛 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形", // 标记为地形，不可交互
                        名称: "荆棘丛",
                        图标: 图标映射.荆棘丛, // 仙人掌图标
                        品质: 1,
                        颜色索引: 0,
                        最大堆叠数量: 1,
                        能否拾起: false,
                        阻碍怪物: false, // 不阻挡移动
                        是否正常物品: false,
                        是否为隐藏物品: false, // 地图上可见
                        效果描述: "进入时会受到伤害并可能减速。",
                        数据: {
                            倒计时: 配置.倒计时 ?? 7,
                            爆炸时间: 配置.倒计时 ?? 7, // 复用计时器接口
                            伤害: 配置.伤害 ?? 3,
                            减速概率: 配置.减速概率 ?? 0.3,
                            减速回合: 配置.减速回合 ?? 2,
                            // 可以添加一个 '来源玩家' 标记，避免玩家自己被自己的荆棘伤害？
                        },
                        ...配置,
                    });
                    this.发挥效果 = false;
                }
                尝试互动() {
                    if (玩家.x !== this.x || 玩家.y !== this.y) {
                        return false;
                    }
                    if (尝试收集物品(new 荆棘种子({}), true)) {
                        this.移除自身();
                        显示通知("成功回收了荆棘种子！", "成功");
                        return true;
                    } else {
                        显示通知("背包已满，无法回收种子！", "错误");
                        return false;
                    }
                }
                使用() {
                    return false;
                }
                
                当被收集(进入者) {
                    const 伤害量 = this.自定义数据.get("伤害");
                    if (进入者 === "玩家" && false) { //废除。
                        伤害玩家(伤害量, this.名称);
                        添加日志("你踩进了荆棘丛！", "错误");
                        // 概率触发减速
                        if (Math.random() < this.自定义数据.get("减速概率")) {
                            new 状态效果(
                                "缓慢",
                                效果颜色编号映射[效果名称编号映射.缓慢],
                                图标映射.缓慢,
                                this.自定义数据.get("减速回合"),
                                null,
                                null,
                                null,
                                1
                            );
                            this.发挥效果 = true;
                            添加日志("你被荆棘缠绕，移动变慢了！", "错误");
                        }
                    }
                    // 注意：怪物的效果在 怪物.处理地形效果 中处理

                    return false; // 不可被收集
                }

                更新倒计时() {
                    const 剩余回合 = this.自定义数据.get("倒计时");
                    if (剩余回合 <= 0 && this.发挥效果) {
                        this.移除自身();
                    } else {
                        this.自定义数据.set("倒计时", 剩余回合 - 1);
                    }
                }

                移除自身() {
                    if (
                        this.x !== null &&
                        this.y !== null &&
                        地牢[this.y]?.[this.x]?.关联物品 === this
                    ) {
                        地牢[this.y][this.x].关联物品 = null;
                        if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品)
                            地牢[this.y][this.x].类型 = null;
                        地牢[this.y][this.x].颜色索引 = 颜色表.length; // 重置颜色
                    }
                    所有计时器 = 所有计时器.filter((item) => item !== this);
                }

                获取提示() {
                    return [
                        `${this.获取名称()}`,
                        `类型：${this.类型}`,
                        `剩余时间：${this.自定义数据.get("倒计时")} 回合`,
                        `进入伤害：${this.自定义数据.get("伤害")} 点`,
                        `减速几率：${(
                            this.自定义数据.get("减速概率") * 100
                        ).toFixed(0)}% (${this.自定义数据.get(
                            "减速回合"
                        )}回合)`,
                        `${this.效果描述}`,
                    ].join("\n");
                }
            }

            class 能量熔炉 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "能量熔炉",
                        图标: "⚙️",
                        品质: 3,
                        颜色索引: 4,
                        最大堆叠数量: 1,
                        效果描述: "消耗能量，少量修复所有已装备物品的耐久。",
                        强化: 配置.强化 || false, // 强化降低消耗或增加修复量
                        数据: {
                            能量消耗: 90 - (配置.强化 ? 15 : 0),
                            修复比例: 0.1 + (配置.强化 ? 0.05 : 0), // 修复最大耐久的10%，强化+5%
                            固定修复量: 5 + (配置.强化 ? 3 : 0), // 或至少修复5点，强化+3
                        },
                        ...配置,
                    });
                }

                使用() {
                    if (!扣除能量(this.自定义数据.get("能量消耗"))) {
                        // 调用基类卷轴的能量消耗方法
                        显示通知("能量不足！", "错误");
                        return false;
                    }

                    let 修复发生 = false;
                    玩家装备.forEach((装备) => {
                        if (
                            装备.自定义数据?.has("耐久") &&
                            装备.自定义数据?.has("原耐久")
                        ) {
                            const 当前耐久 = 装备.自定义数据.get("耐久");
                            const 最大耐久 = 装备.自定义数据.get("原耐久");
                            if (当前耐久 < 最大耐久) {
                                const 按比例修复 = Math.ceil(
                                    最大耐久 * this.自定义数据.get("修复比例")
                                );
                                const 实际修复量 = Math.max(
                                    this.自定义数据.get("固定修复量"),
                                    按比例修复
                                );
                                const 新耐久 = Math.min(
                                    最大耐久,
                                    当前耐久 + 实际修复量
                                );
                                if (新耐久 > 当前耐久) {
                                    装备.自定义数据.set("耐久", 新耐久);
                                    修复发生 = true;
                                    添加日志(
                                        `${装备.获取名称()} 被修复了 ${
                                            新耐久 - 当前耐久
                                        } 点耐久。`,
                                        "成功"
                                    );
                                }
                            }
                        }
                    });

                    if (修复发生) {
                        显示通知(`${this.获取名称()} 修复了装备！`, "成功");
                        更新装备显示(); // 更新UI
                    } else {
                        显示通知(
                            `${this.获取名称()} 发动了，但没有装备需要修复。`,
                            "信息"
                        );
                    }

                    更新装备显示(); // 更新冷却显示（如果装备栏显示冷却）
                    return true;
                }

                获取提示() {
                    let 基础提示 = super.获取提示();
                    基础提示 = 基础提示.replace(/堆叠：.*\n/, ""); // 移除堆叠信息
                    const 能量消耗 = this.自定义数据.get("能量消耗");
                    const 修复比例 = (
                        this.自定义数据.get("修复比例") * 100
                    ).toFixed(0);
                    const 固定修复 = this.自定义数据.get("固定修复量");

                    return [
                        基础提示,
                        `---`,
                        `能量消耗：${能量消耗}`,
                        `修复效果：恢复最大耐久${修复比例}% (至少${固定修复}点)`,
                    ].join("\n");
                }
            }
            class 引雷针护符 extends 防御装备类 {
                constructor(配置 = {}) {
                    super({
                        名称: "引雷针护符",
                        图标: 图标映射.引雷针护符,
                        品质: 2,
                        颜色索引: 3,
                        防御力: 1,
                        耐久: 配置.耐久 || 35 + (配置.强化 ? 10 : 0),
                        原耐久: 配置.原耐久 || 35 + (配置.强化 ? 10 : 0),
                        强化: 配置.强化 || false,
                        不可破坏: false,
                        效果描述: "拦截落雷，可能获得充能或恢复能量。",
                        数据: {
                            充能概率: 0.6 + (配置.强化 ? 0.15 : 0),
                            充能持续时间: 3 + (配置.强化 ? 2 : 0),
                            充能攻击加成值: 2 + (配置.强化 ? 2 : 0),
                            能量恢复量: 15 + (配置.强化 ? 15 : 0),
                        },
                        ...配置,
                    });
                }

                当被攻击(原始攻击力, 来源 = null) {
                    if (来源 === "雷暴" && this.自定义数据.get("耐久") > 0) {
                        super.当被攻击(原始攻击力, 来源);
                        添加日志(`${this.名称} 吸收了落雷！`, "成功");
                        const 现有效果 = 玩家状态.find(
                            (s) => s.来源 === this && s.类型 === "充能"
                        );
                        if (
                            Math.random() < this.自定义数据.get("充能概率") &&
                            !现有效果
                        ) {
                            const 持续时间 =
                                this.自定义数据.get("充能持续时间");
                            const 加成值 =
                                this.自定义数据.get("充能攻击加成值");
                            const 新效果 = new 状态效果(
                                "充能",
                                效果颜色编号映射[效果名称编号映射.充能],
                                "⚡",
                                持续时间,
                                null,
                                this,
                                null,
                                加成值
                            );
                            玩家属性.攻击加成 += 加成值;
                            显示通知(
                                "你感到了电流的涌动，攻击力提升！",
                                "成功"
                            );
                        } else {
                            const 恢复量 = this.自定义数据.get("能量恢复量");
                            const 能量条 = document.querySelector(".power-bar");
                            const 当前能量 =
                                parseFloat(能量条.style.width) || 0;
                            能量条.style.width = `${Math.min(
                                100,
                                当前能量 + 恢复量
                            )}%`;
                            显示通知(
                                `护符转化雷电，恢复了 ${恢复量} 点能量！`,
                                "成功"
                            );
                            触发HUD显示();
                        }
                        return 0;
                    }
                    return super.当被攻击(原始攻击力, 来源);
                }
                应用效果() {
                    return;
                }
                移除效果() {
                    const 加成值 = this.自定义数据.get("充能攻击加成值");
                    const 对应效果 = 玩家状态.find(
                        (s) => s.来源 === this && s.类型 === "充能"
                    );
                    if (对应效果 && 加成值 > 0) {
                        玩家属性.攻击加成 -= 加成值;
                    }
                }

                获取提示() {
                    let lines = super.获取提示().split("\n");
                    const effectDescIndex = lines.findIndex((line) =>
                        line.startsWith("效果描述：")
                    );
                    if (effectDescIndex !== -1) {
                        lines.splice(effectDescIndex, 1); // Remove the generic description
                    }

                    const 充能概率 = (
                        this.自定义数据.get("充能概率") * 100
                    ).toFixed(0);
                    const 攻击加成 = this.自定义数据.get("充能攻击加成值");
                    const 持续 = this.自定义数据.get("充能持续时间");
                    const 能量恢复 = this.自定义数据.get("能量恢复量");
                    const 当前效果 = 玩家状态.find(
                        (s) => s.来源 === this && s.类型 === "充能"
                    );
                    const 剩余 = 当前效果 ? 当前效果.剩余回合 : 0;

                    let 效果详情 = `效果：拦截落雷消耗 1 耐久。\n`;
                    效果详情 += ` ${充能概率}%几率获得[充能](${持续}回合, +${攻击加成}攻击力)。\n`;
                    效果详情 += ` 否则恢复 ${能量恢复} 能量。`;
                    if (剩余 > 0) {
                        效果详情 += `\n 充能剩余：${剩余}回合`;
                    }

                    let insertIndex = lines.findIndex((line) =>
                        line.startsWith("--- 强化效果 ---")
                    );
                    if (insertIndex === -1) {
                        insertIndex = lines.findIndex((line) =>
                            line.startsWith("耐久：")
                        );
                    }
                    if (insertIndex === -1) {
                        insertIndex = lines.length;
                    }
                    lines.splice(insertIndex, 0, 效果详情);

                    return lines.filter(Boolean).join("\n");
                }
            }
            class 重力锤 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "重力锤",
                        图标: 图标映射.重力锤,
                        品质: 4,
                        基础攻击力: 12,
                        冷却回合: 11,
                        攻击范围: 3 + (配置.强化 ? 2 : 0),
                        耐久: 配置?.耐久 || 60,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "猛击地面，将范围内的敌人拉向自己，然后造成范围伤害。",
                        攻击目标数: 99,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            伤害范围: 1 + (配置.强化 ? 2 : 0),
                            ...配置.数据,
                        },
                    });
                }

                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;

                    const 拉取范围 = this.最终攻击范围;
                    const 伤害范围 = this.自定义数据.get("伤害范围");
                    const 被拉取怪物 = new Set();
                    const 拉取路径可视化 = [];

                    for (let dx = -拉取范围; dx <= 拉取范围; dx++) {
                        for (let dy = -拉取范围; dy <= 拉取范围; dy++) {
                            const x = 玩家.x + dx;
                            const y = 玩家.y + dy;

                            if (
                                x >= 0 &&
                                x < 地牢大小 &&
                                y >= 0 &&
                                y < 地牢大小
                            ) {
                                const 单元格 = 地牢[y][x];
                                const 怪物 = 单元格?.关联怪物;
                                if (
                                    怪物 &&
                                    怪物.当前生命值 > 0 &&
                                    怪物.状态 === 怪物状态.活跃
                                ) {
                                    let 拉到X = 玩家.x;
                                    let 拉到Y = 玩家.y;
                                    let 最近距离 = Infinity;
                                    let 找到位置 = false;
                                    let 移动路径 = null;

                                    for (let pdx = -1; pdx <= 1; pdx++) {
                                        for (let pdy = -1; pdy <= 1; pdy++) {
                                            if (pdx === 0 && pdy === 0)
                                                continue;
                                            const 目标X = 玩家.x + pdx;
                                            const 目标Y = 玩家.y + pdy;
                                            if (
                                                目标X >= 0 &&
                                                目标X < 地牢大小 &&
                                                目标Y >= 0 &&
                                                目标Y < 地牢大小 &&
                                                位置是否可用(
                                                    目标X,
                                                    目标Y,
                                                    true
                                                ) &&
                                                检查视线(
                                                    怪物.x,
                                                    怪物.y,
                                                    目标X,
                                                    目标Y,
                                                    拉取范围 + 2
                                                )
                                            ) {
                                                const 距离 =
                                                    Math.abs(目标X - 怪物.x) +
                                                    Math.abs(目标Y - 怪物.y);
                                                if (距离 < 最近距离) {
                                                    const 路径 =
                                                        广度优先搜索路径(
                                                            怪物.x,
                                                            怪物.y,
                                                            目标X,
                                                            目标Y,
                                                            拉取范围 + 2,
                                                            true
                                                        );
                                                    if (
                                                        路径 &&
                                                        路径.length > 1
                                                    ) {
                                                        最近距离 = 距离;
                                                        拉到X = 目标X;
                                                        拉到Y = 目标Y;
                                                        移动路径 = 路径;
                                                        找到位置 = true;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    if (
                                        找到位置 &&
                                        !(怪物.x === 拉到X && 怪物.y === 拉到Y)
                                    ) {
                                        被拉取怪物.add(怪物);
                                        拉取路径可视化.push(移动路径.slice(1));

                                        怪物.恢复背景类型();
                                        怪物.x = 拉到X;
                                        怪物.y = 拉到Y;
                                        怪物.保存新位置类型(拉到X, 拉到Y);
                                        地牢[拉到Y][拉到X].类型 =
                                            单元格类型.怪物;
                                        地牢[拉到Y][拉到X].关联怪物 = 怪物;
                                    }
                                }
                            }
                        }
                    }
                    if (拉取路径可视化.length <= 0) return 0;
                    拉取路径可视化.forEach((路径, index) => {
                        setTimeout(() => {
                            计划显示格子特效(路径.slice().reverse(), "9400D3");
                        }, index * 50);
                    });

                    let 总有效伤害 = 0;
                    const 击中怪物 = new Set();
                    const 伤害格子 = [];

                    setTimeout(() => {
                        for (let ddx = -伤害范围; ddx <= 伤害范围; ddx++) {
                            for (let ddy = -伤害范围; ddy <= 伤害范围; ddy++) {
                                const dmgX = 玩家.x + ddx;
                                const dmgY = 玩家.y + ddy;
                                if (
                                    dmgX >= 0 &&
                                    dmgX < 地牢大小 &&
                                    dmgY >= 0 &&
                                    dmgY < 地牢大小
                                ) {
                                    if (
                                        检查视线(
                                            玩家.x,
                                            玩家.y,
                                            dmgX,
                                            dmgY,
                                            伤害范围 + 1
                                        )
                                    ) {
                                        伤害格子.push({ x: dmgX, y: dmgY });
                                        const 单元格 = 地牢[dmgY][dmgX];
                                        if (
                                            单元格?.关联怪物 &&
                                            单元格.关联怪物.当前生命值 > 0
                                        ) {
                                            const 怪物 = 单元格.关联怪物;
                                            if (!击中怪物.has(怪物)) {
                                                击中怪物.add(怪物);
                                                const 原始血量 =
                                                    怪物.当前生命值;
                                                怪物.受伤(this.攻击力, "玩家");
                                                const 实际伤害 =
                                                    原始血量 - 怪物.当前生命值;
                                                if (实际伤害 > 0)
                                                    总有效伤害 += 实际伤害;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        setTimeout(() => {
                            计划显示格子特效(伤害格子, "FFA500", 0);
                        }, 拉取路径可视化[0].length * 50);

                        this.自定义数据.set(
                            "耐久",
                            (
                                this.自定义数据.get("耐久") -
                                this.耐久消耗 * (被拉取怪物.size > 0 ? 1.2 : 1)
                            ).toFixed(1)
                        );
                        if (this.自定义数据.get("耐久") <= 0) {
                            处理销毁物品(this.唯一标识, true);
                            显示通知(`${this.名称} 已损坏！`, "警告");
                        }
                        this.自定义数据.set(
                            "冷却剩余",
                            this.自定义数据.get("冷却回合")
                        );

                        if (被拉取怪物.size > 0 || 击中怪物.size > 0) {
                            let 消息 = `${this.名称} 发动！`;
                            if (被拉取怪物.size > 0)
                                消息 += ` 拉近了 ${被拉取怪物.size} 个目标。`;
                            if (击中怪物.size > 0)
                                消息 += ` 震击了 ${
                                    击中怪物.size
                                } 个目标，共造成 ${总有效伤害.toFixed(
                                    1
                                )} 点伤害！`;
                            显示通知(消息, "成功");

                            const 所有影响怪物 = Array.from(
                                new Set([...被拉取怪物, ...击中怪物])
                            );

                            if (总有效伤害 > 0) {
                                this.触发通用附魔(所有影响怪物);
                            }
                        } else {
                            显示通知(
                                `${this.名称} 发动了，但未影响任何目标。`,
                                "信息"
                            );
                        }

                        更新装备显示();
                        绘制();
                    }, 拉取路径可视化.length * 50 + 100);

                    return 1;
                }

                触发通用附魔(目标怪物列表) {
                    if (
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "火焰附魔")?.等级
                    ) {
                        const 火焰等级 = this.自定义数据
                            .get("附魔")
                            .find((item) => item.种类 === "火焰附魔").等级;
                        目标怪物列表.forEach((怪物) => {
                            if (怪物.当前生命值 > 0) {
                                new 状态效果(
                                    "火焰",
                                    "#CC5500",
                                    "火",
                                    火焰等级,
                                    null,
                                    null,
                                    怪物
                                );
                            }
                        });
                    }
                    const 连锁附魔 = this.自定义数据
                        .get("附魔")
                        ?.find((item) => item.种类 === "连锁附魔");
                    if (连锁附魔) {
                        const 连锁距离 = 连锁附魔.等级;
                        目标怪物列表.forEach((初始目标) => {
                            if (初始目标.当前生命值 > 0) {
                                this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                            }
                        });
                    }
                }

                获取提示() {
                    let lines = super.获取提示().split("\n");
                    const specificEffectLines = [
                        `震击范围：周围 ${this.自定义数据.get("伤害范围")} 格`,
                    ];
                    const effectDescIndex = lines.findIndex((line) =>
                        line.startsWith("效果描述：")
                    );
                    let insertAtIndex =
                        effectDescIndex !== -1
                            ? effectDescIndex + 1
                            : lines.findIndex((line) =>
                                  line.startsWith("--- 强化效果 ---")
                              );
                    if (insertAtIndex === -1) insertAtIndex = lines.length;

                    lines.splice(insertAtIndex, 0, ...specificEffectLines);
                    return lines.filter(Boolean).join("\n");
                }
            }
            class 旋风物品 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: "旋风气流",
                        图标: 图标映射.旋风物品,
                        品质: 1,
                        颜色索引: 1,
                        最大堆叠数量: 1,
                        能否拾起: false, // 不能主动拾取
                        阻碍怪物: false, // 怪物可以穿过
                        效果描述: "不稳定的气流，接触会头晕。",
                        数据: {
                            倒计时: 5, // 存在5回合
                            爆炸时间: 5, // 同上，用于计时器
                            眩晕回合: 2,
                        },
                        ...配置, // 允许覆盖默认配置
                    });
                }

                使用() {
                    return false;
                }

                触发爆炸() {
                    this.移除自身();
                }

                当被收集(进入者) {
                    if (进入者 !== "玩家") return;
                    new 状态效果(
                        "眩晕",
                        效果颜色编号映射[效果名称编号映射.眩晕],
                        图标映射.眩晕,
                        this.自定义数据.get("眩晕回合")
                    );
                    return false;
                }

                移除自身() {
                    // 从地牢格子中移除
                    if (
                        this.x !== null &&
                        this.y !== null &&
                        地牢[this.y]?.[this.x]?.关联物品 === this
                    ) {
                        地牢[this.y][this.x].关联物品 = null;
                        if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品)
                            地牢[this.y][this.x].类型 = null; // 恢复原始格子类型
                    }
                    所有计时器 = 所有计时器.filter((item) => item !== this);
                    绘制(); // 更新画面
                }

                更新倒计时() {
                    const 剩余回合 = this.自定义数据.get("倒计时");
                    if (剩余回合 <= 0) {
                        // 用 <= 0 更安全
                        this.触发爆炸(); // 时间到，移除物品
                    } else {
                        this.自定义数据.set("倒计时", 剩余回合 - 1);
                    }
                }
            }
            class 磨刀石 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "磨刀石",
                        图标: 图标映射.磨刀石,
                        品质: 3,
                        颜色索引: 4, 
                        最大堆叠数量: 1,
                        效果描述: "用于融合，可强化武器。先放磨刀石，再放武器。",
                        数据: {
                            耐久: 5 + (配置.强化 ? 3 : 0),
                            原耐久: 5 + (配置.强化 ? 3 : 0),
                        },
                        ...配置,
                    });
                }

                获取提示() {
                    return `${this.获取名称()}\n类型：${
            this.类型
        }\n品质：${"★".repeat(
            this.品质
        )}\n效果：${this.效果描述}\n剩余使用次数：${this.自定义数据.get("耐久")}`;
                }
            }
            class 急救绷带 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "消耗品",
                        名称: "急救绷带",
                        图标: 图标映射.急救绷带,
                        品质: 2,
                        颜色索引: 0, 
                        堆叠数量: 配置.数量 || 1,
                        最大堆叠数量: 16,
                        效果描述: "恢复大量生命值，并移除中毒和火焰效果。",
                        数据: {
                            恢复量: 40 + (配置.强化 ? 20 : 0),
                        },
                        ...配置,
                    });
                }

                使用() {
                    if (this.堆叠数量 <= 0) return false;

                    const 生命条 = document.querySelector(".health-bar");
                    const 当前宽度 = parseFloat(生命条.style.width) || 0;
                    const 新宽度 = Math.min(100, 当前宽度 + this.自定义数据.get("恢复量"));
                    if (新宽度 > 当前宽度) {
                        生命条.style.width = `${新宽度}%`;
                    }
                    
                    const 待移除状态 = [];
                    玩家状态.forEach(状态 => {
                        if (状态.类型 === '中毒' || 状态.类型 === '火焰') {
                            待移除状态.push(状态);
                        }
                    });

                    待移除状态.forEach(状态 => {
                        状态.移除状态();
                    });

                    this.堆叠数量--;
                    if (this.堆叠数量 <= 0) {
                        处理销毁物品(this.唯一标识, true);
                    }

                    显示通知("你使用了急救绷带！感觉好多了。", "成功");
                    更新背包显示();
                    更新装备显示();
                    触发HUD显示();

                    return true;
                }

                获取提示() {
                    return `${this.获取名称()}\n类型：${this.类型}\n品质：${"★".repeat(
            this.品质
        )}\n效果：${this.效果描述}\n恢复量：${this.自定义数据.get("恢复量")}点`;
                }
            }

             class 照明弹光源 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: "照明弹光源",
                        图标: 图标映射.照明弹光源,
                        能否拾起: false,
                        是否正常物品: false,
                        是否为隐藏物品: true,
                        阻碍怪物: false,
                        数据: {
                            倒计时: 配置.耐久 || 15,
                            爆炸时间: 配置.耐久 || 15, 
                            光照范围: 6 + (配置.强化 ? 2 : 0),
                        },
                        ...配置,
                    });
                }
                更新倒计时() {
                    const 剩余回合 = this.自定义数据.get("倒计时");
                    if (剩余回合 <= 0) {
                        this.移除自身();
                    } else {
                        this.自定义数据.set("倒计时", 剩余回合 - 1);
                    }
                }
                移除自身() {
                    if (
                        this.x !== null &&
                        this.y !== null &&
                        地牢[this.y]?.[this.x]?.关联物品 === this
                    ) {
                        地牢[this.y][this.x].关联物品 = null;
                        地牢[this.y][this.x].类型 = null;
                    }
                    所有计时器 = 所有计时器.filter((item) => item !== this);
                    绘制();
                }
            }

            class 照明弹 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "照明弹",
                        图标: 图标映射.照明弹,
                        品质: 2,
                        颜色索引: 2,
                        最大堆叠数量: 1,
                        效果描述: "使用后点亮大片区域，持续15回合。",
                        数据: {
                            耐久: 3 + (配置.强化 ? 2 : 0), 
                            原耐久: 3 + (配置.强化 ? 2 : 0),
                        },
                        ...配置,
                    });
                }

                使用() {
                    if (this.自定义数据.get("耐久") <= 0) return false;

                    const lightSource = new 照明弹光源({强化: this.强化});
                    lightSource.x = 玩家.x;
                    lightSource.y = 玩家.y;
                    if (!放置物品到单元格(lightSource,玩家.x,玩家.y)) return false;
                    所有计时器.push(lightSource);

                    this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                    }
                    更新背包显示();
                    更新装备显示();
                    显示通知("照明弹升空，照亮了周围！", "成功");
                    绘制(); 
                    return true;
                }
            }

            class 挑战石碑 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: "挑战石碑",
                        图标: 图标映射.挑战石碑,
                        品质: 4,
                        颜色索引: 3,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: true,
                        效果描述: "一座古老的石碑，散发着不祥的气息。互动以开始生存挑战。",
                        数据: {
                            已激活: false,
                            当前波数: 0,
                        },
                        ...配置,
                    });
                }

                尝试互动() {
                    if (this.自定义数据.get("已激活")) {
                        显示通知("石碑上的能量已经平息。", "信息");
                        return false;
                    }

                    显示自定义确认对话框(
                        "你确定要激活石碑，开始无尽的生存挑战吗？挑战将在你倒下时结束。",
                        () => this.开始生存挑战()
                    );

                    return true;
                }

                开始生存挑战() {
                    if (生存挑战激活) return; 

                    const 当前房间ID = 房间地图[this.y]?.[this.x];
                    if (当前房间ID === -1 || 当前房间ID === undefined) {
                        显示通知("石碑未在有效房间内，无法开始挑战。", "错误");
                        return;
                    }
                    const 房间实例 = 房间列表[当前房间ID];

                    生存挑战激活 = true;
                    生存挑战备份单元格 = [];
                    this.自定义数据.set("已激活", true);
                    this.自定义数据.set("当前波数", 0);
                    房间实例.isSurvivalChallenge = true; 
                    房间实例.survivalWave = 0; 

                    const 挑战半径 = 25;
                    const 中心X = this.x;
                    const 中心Y = this.y;

                    for (let y = 中心Y - 挑战半径; y <= 中心Y + 挑战半径; y++) {
                        for (let x = 中心X - 挑战半径; x <= 中心X + 挑战半径; x++) {
                            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
                            
                            const 距离 = Math.sqrt(Math.pow(x - 中心X, 2) + Math.pow(y - 中心Y, 2));

                            if (Math.abs(距离 - 挑战半径) < 1) { 
                                const 原始单元格 = 地牢[y][x];
                                生存挑战备份单元格.push({
                                    x: x,
                                    y: y,
                                    类型: 原始单元格.类型,
                                    背景类型: 原始单元格.背景类型,
                                    墙壁: { ...原始单元格.墙壁 },
                                    关联物品: 原始单元格.关联物品,
                                    关联怪物: 原始单元格.关联怪物,
                                    颜色索引: 原始单元格.颜色索引,
                                    标识: 原始单元格.标识,
                                });

                                原始单元格.类型 = 单元格类型.墙壁;
                                原始单元格.背景类型 = 单元格类型.墙壁;
                                原始单元格.关联物品 = null;
                                原始单元格.关联怪物 = null;
                            }
                        }
                    }

                    生成墙壁();
                    绘制();
                    
                    显示通知("挑战结界已升起！", "警告", true);
                    this.刷新生存挑战下一波(房间实例);
                }
                
                刷新生存挑战下一波(房间实例) {
                    if (!this.自定义数据.get("已激活")) return;

                    this.自定义数据.set("当前波数", this.自定义数据.get("当前波数") + 1);
                    房间实例.survivalWave = this.自定义数据.get("当前波数");

                    const 波数 = this.自定义数据.get("当前波数");
                    显示通知(`第 ${波数} 波开始！`, "警告");
                    
                    const 怪物数量 = Math.min(8, 1 + Math.floor(波数 / 2));
                    const 强化概率 = Math.min(0.8, 0.1 + 波数 * 0.05);

                    for(let i=0; i<怪物数量; i++) {
                        let 候选怪物Pool = 怪物池["上锁房间"]; 
                        const 候选怪物 = 候选怪物Pool.filter(m => m.最小层 <= 当前层数);
                        if(候选怪物.length === 0) continue;

                        const 选中配置 = 候选怪物[Math.floor(Math.random() * 候选怪物.length)];
                        const 新怪物 = new 选中配置.类({强化: Math.random() < 强化概率, 状态: 怪物状态.活跃});
                        
                        
                                放置怪物到房间(新怪物, 房间实例);
                                
                        
                    }
                }

                发放奖励(波数) {
                    const 房间实例 = 房间列表[房间地图[this.y][this.x]];
                    if (!房间实例) return;

                    const 奖励等级 = Math.floor(波数 / 5);
                    const 奖励数量 = 1 + 奖励等级;

                    for (let i = 0; i < 奖励数量; i++) {
                        const 品质 = Math.min(5, 2 + 奖励等级);
                        const 可用物品 = Object.values(物品池).flat().filter(item => item.品质 >= 品质-1 && item.品质 <= 品质 && new item.类({}).是否正常物品);
                        if (可用物品.length > 0) {
                                const 选中配置 = 可用物品[Math.floor(Math.random() * 可用物品.length)];
                                const 新物品 = new 选中配置.类({强化: true, 已解锁: true});
                                放置物品到房间(新物品, 房间实例, 单元格类型.物品, false, true);
                        }
                    }
                    显示通知(`挑战结束！你坚持了 ${波数} 波，获得了奖励！`, "成功");
                }
            }
            class 剧毒匕首 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "剧毒匕首",
                        图标: 图标映射.剧毒匕首,
                        品质: 1,
                        基础攻击力: 3,
                        冷却回合: 2,
                        攻击范围: 1,
                        耐久: 配置?.耐久 || 90,
                        强化: 配置?.强化 || false,
                        效果描述: "攻击附加可叠加的中毒效果，持续造成伤害。",
                        攻击目标数: 1,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            中毒强度: 2 + (配置?.强化 ? 1 : 0),
                            中毒持续时间: 5,
                            ...配置.数据,
                        },
                    });
                }

                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;

                    const 目标怪物 = 目标怪物列表[0];
                    if (!目标怪物 || 目标怪物.当前生命值 <= 0) return 0;

                    let 总有效伤害 = 0;
                    const 原始血量 = 目标怪物.当前生命值;
                    目标怪物.受伤(this.攻击力, "玩家");
                    const 实际伤害 = 原始血量 - 目标怪物.当前生命值;
                    if (实际伤害 > 0) 总有效伤害 += 实际伤害;

                    if (目标怪物.当前生命值 > 0) {
                        new 状态效果(
                            "中毒",
                            效果颜色编号映射[效果名称编号映射.中毒],
                            "☠️",
                            this.自定义数据.get("中毒持续时间"),
                            null,
                            null,
                            目标怪物,
                            this.自定义数据.get("中毒强度")
                        );
                        添加日志(`${目标怪物.类型} 中毒了！`, "警告");
                    }

                    const 攻击路径 = 广度优先搜索路径(
                        玩家.x,
                        玩家.y,
                        目标怪物.x,
                        目标怪物.y,
                        this.最终攻击范围,
                        true
                    );
                    if (攻击路径 && 攻击路径.length > 1) {
                        计划显示格子特效(攻击路径.slice(1), "008000");
                    }

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set(
                        "冷却剩余",
                        this.自定义数据.get("冷却回合")
                    );

                    let 消息 = `${this.名称} 造成 ${总有效伤害.toFixed(
                        1
                    )} 点伤害`;
                    if (
                        目标怪物.当前生命值 > 0 &&
                        怪物状态表.get(目标怪物)?.类型 === "中毒"
                    ) {
                        消息 += ` 并附加了中毒效果！`;
                    } else {
                        消息 += `！`;
                    }
                    显示通知(消息, "成功");

                    if (总有效伤害 > 0) {
                        this.触发通用附魔([目标怪物]);
                    }

                    更新装备显示();
                    return 总有效伤害;
                }

                触发通用附魔(目标怪物列表) {
                    if (
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "火焰附魔")?.等级
                    ) {
                        const 火焰等级 = this.自定义数据
                            .get("附魔")
                            .find((item) => item.种类 === "火焰附魔").等级;
                        目标怪物列表.forEach((怪物) => {
                            if (怪物.当前生命值 > 0) {
                                new 状态效果(
                                    "火焰",
                                    "#CC5500",
                                    "火",
                                    火焰等级,
                                    null,
                                    null,
                                    怪物
                                );
                            }
                        });
                    }
                    const 连锁附魔 = this.自定义数据
                        .get("附魔")
                        ?.find((item) => item.种类 === "连锁附魔");
                    if (连锁附魔) {
                        const 连锁距离 = 连锁附魔.等级;
                        目标怪物列表.forEach((初始目标) => {
                            if (初始目标.当前生命值 > 0) {
                                this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                            }
                        });
                    }
                }

                获取提示() {
                    let lines = super.获取提示().split("\n");
                    const specificEffectLines = [
                        `毒性：${this.自定义数据.get("中毒强度")}点/回合`,
                        `持续：${this.自定义数据.get("中毒持续时间")}回合`,
                    ];
                    const effectDescIndex = lines.findIndex((line) =>
                        line.startsWith("效果描述：")
                    );
                    let insertAtIndex =
                        effectDescIndex !== -1
                            ? effectDescIndex + 1
                            : lines.findIndex((line) =>
                                  line.startsWith("--- 强化效果 ---")
                              );
                    if (insertAtIndex === -1) insertAtIndex = lines.length;

                    lines.splice(insertAtIndex, 0, ...specificEffectLines);
                    return lines.filter(Boolean).join("\n");
                }
            }

            class 荆棘鞭 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "荆棘鞭",
                        图标: 图标映射.荆棘鞭,
                        品质: 1,
                        基础攻击力: 2,
                        冷却回合: 3,
                        攻击范围: 2,
                        耐久: 配置?.耐久 || 70,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "甩出长鞭，将近处的单个敌人直线甩飞并造成少量伤害。",
                        攻击目标数: 1,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            甩飞距离: 3 + (配置?.强化 ? 1 : 0),
                            ...配置.数据,
                        },
                    });
                }

                计算最大甩飞距离(起始X, 起始Y, 方向DX, 方向DY, 最大距离) {
                    let 可行终点 = { x: 起始X, y: 起始Y };
                    for (let i = 1; i <= 最大距离; i++) {
                        const 尝试X = 起始X + 方向DX * i;
                        const 尝试Y = 起始Y + 方向DY * i;

                        if (
                            尝试X < 0 ||
                            尝试X >= 地牢大小 ||
                            尝试Y < 0 ||
                            尝试Y >= 地牢大小
                        )
                            break;
                        if (!快速直线检查(起始X, 起始Y, 尝试X, 尝试Y, i)) break;
                        if (位置是否可用(尝试X, 尝试Y, true)) {
                            可行终点 = { x: 尝试X, y: 尝试Y };
                        }
                    }
                    return 可行终点;
                }

                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;

                    if (!目标怪物列表 || 目标怪物列表.length === 0) {
                        显示通知("附近没有可甩飞的目标！", "警告");
                        return 0;
                    }

                    const 目标怪物 = 目标怪物列表[0];
                    if (目标怪物.当前生命值 <= 0) return 0;

                    const 路径 = 获取直线路径(
                        玩家.x,
                        玩家.y,
                        目标怪物.x,
                        目标怪物.y
                    );
                    if (
                        路径.length === 0 ||
                        路径.length > this.最终攻击范围 + 1
                    ) {
                        显示通知("目标太远或路径被阻挡！", "警告");
                        return 0;
                    }

                    const dx = 目标怪物.x - 玩家.x;
                    const dy = 目标怪物.y - 玩家.y;
                    const 甩飞距离 = this.自定义数据.get("甩飞距离");
                    let 最终X = 目标怪物.x;
                    let 最终Y = 目标怪物.y;
                    let 选择方向DX = 0;
                    let 选择方向DY = 0;

                    if (dx === 0) {
                        选择方向DY = dy > 0 ? 1 : -1;
                    } else if (dy === 0) {
                        选择方向DX = dx > 0 ? 1 : -1;
                    } else {
                        const 水平方向DX = dx > 0 ? 1 : -1;
                        const 水平终点 = this.计算最大甩飞距离(
                            目标怪物.x,
                            目标怪物.y,
                            水平方向DX,
                            0,
                            甩飞距离
                        );
                        const 水平距离玩家 =
                            Math.abs(水平终点.x - 玩家.x) +
                            Math.abs(水平终点.y - 玩家.y);

                        const 垂直方向DY = dy > 0 ? 1 : -1;
                        const 垂直终点 = this.计算最大甩飞距离(
                            目标怪物.x,
                            目标怪物.y,
                            0,
                            垂直方向DY,
                            甩飞距离
                        );
                        const 垂直距离玩家 =
                            Math.abs(垂直终点.x - 玩家.x) +
                            Math.abs(垂直终点.y - 玩家.y);

                        if (水平距离玩家 >= 垂直距离玩家) {
                            选择方向DX = 水平方向DX;
                            选择方向DY = 0;
                        } else {
                            选择方向DX = 0;
                            选择方向DY = 垂直方向DY;
                        }
                    }

                    const 最终落点 = this.计算最大甩飞距离(
                        目标怪物.x,
                        目标怪物.y,
                        选择方向DX,
                        选择方向DY,
                        甩飞距离
                    );
                    最终X = 最终落点.x;
                    最终Y = 最终落点.y;

                    let 总有效伤害 = 0;
                    const 原始血量 = 目标怪物.当前生命值;
                    目标怪物.受伤(this.攻击力, "玩家");

                    const 实际伤害 = 原始血量 - 目标怪物.当前生命值;
                    if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                    if (目标怪物.当前生命值 <= 0) return 总有效伤害;

                    if (最终X !== 目标怪物.x || 最终Y !== 目标怪物.y) {
                        目标怪物.恢复背景类型();
                        目标怪物.x = 最终X;
                        目标怪物.y = 最终Y;
                        目标怪物.保存新位置类型(最终X, 最终Y);
                        地牢[最终Y][最终X].类型 = 单元格类型.怪物;
                        地牢[最终Y][最终X].关联怪物 = 目标怪物;
                        目标怪物.处理地形效果();
                        目标怪物.绘制血条();
                        绘制();
                        显示通知(
                            `${this.名称} 将 ${
                                目标怪物.类型
                            } 甩飞了，造成 ${总有效伤害.toFixed(1)} 点伤害！`,
                            "成功"
                        );
                    } else {
                        显示通知(
                            `${this.名称} 击中了 ${
                                目标怪物.类型
                            } 但未能将其甩飞，造成 ${总有效伤害.toFixed(
                                1
                            )} 点伤害！`,
                            "信息"
                        );
                    }

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set(
                        "冷却剩余",
                        this.自定义数据.get("冷却回合")
                    );

                    if (总有效伤害 > 0) {
                        this.触发通用附魔([目标怪物]);
                    }

                    更新装备显示();
                    return 总有效伤害;
                }

                触发通用附魔(目标怪物列表) {
                    if (
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "火焰附魔")?.等级
                    ) {
                        const 火焰等级 = this.自定义数据
                            .get("附魔")
                            .find((item) => item.种类 === "火焰附魔").等级;
                        目标怪物列表.forEach((怪物) => {
                            if (怪物.当前生命值 > 0) {
                                new 状态效果(
                                    "火焰",
                                    "#CC5500",
                                    "火",
                                    火焰等级,
                                    null,
                                    null,
                                    怪物
                                );
                            }
                        });
                    }
                    const 连锁附魔 = this.自定义数据
                        .get("附魔")
                        ?.find((item) => item.种类 === "连锁附魔");
                    if (连锁附魔) {
                        const 连锁距离 = 连锁附魔.等级;
                        目标怪物列表.forEach((初始目标) => {
                            if (初始目标.当前生命值 > 0) {
                                this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                            }
                        });
                    }
                }

                获取提示() {
                    let lines = super.获取提示().split("\n");
                    const specificEffectLines = [
                        `甩飞距离：${this.自定义数据.get("甩飞距离")} 格`,
                    ];
                    const effectDescIndex = lines.findIndex((line) =>
                        line.startsWith("效果描述：")
                    );
                    let insertAtIndex =
                        effectDescIndex !== -1
                            ? effectDescIndex + 1
                            : lines.findIndex((line) =>
                                  line.startsWith("--- 强化效果 ---")
                              );
                    if (insertAtIndex === -1) insertAtIndex = lines.length;
                    lines.splice(insertAtIndex, 0, ...specificEffectLines);
                    return lines.filter(Boolean).join("\n");
                }
            }
            class 回旋镖 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "回旋镖",
                        图标: 图标映射.回旋镖,
                        品质: 2,
                        基础攻击力: 4,
                        冷却回合: 2,
                        攻击范围: 5 + (配置?.强化 ? 2 : 0),
                        耐久: 配置?.耐久 || 60,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "沿直线投掷固定距离后返回，对路径上的敌人造成两次伤害。会被墙壁阻挡。",
                        攻击目标数: 5,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            ...配置.数据,
                        },
                    });
                }
                获取固定距离轴向路径(startX, startY, targetX, targetY) {
                    const path = [];
                    const fixedDistance = this.最终攻击范围;
                    const dxTotal = targetX - startX;
                    const dyTotal = targetY - startY;

                    let currentX = startX;
                    let currentY = startY;
                    let dirX = 0;
                    let dirY = 0;

                    if (Math.abs(dxTotal) >= Math.abs(dyTotal)) {
                        dirX =
                            Math.sign(dxTotal) ||
                            (Math.random() < 0.5 ? 1 : -1);
                        dirY = 0;
                    } else {
                        dirX = 0;
                        dirY =
                            Math.sign(dyTotal) ||
                            (Math.random() < 0.5 ? 1 : -1);
                    }

                    if (dirX === 0 && dirY === 0) return [];

                    for (let i = 0; i < fixedDistance; i++) {
                        const nextX = currentX + dirX;
                        const nextY = currentY + dirY;

                        if (
                            nextX < 0 ||
                            nextX >= 地牢大小 ||
                            nextY < 0 ||
                            nextY >= 地牢大小
                        ) {
                            break;
                        }
                        if (!检查移动可行性(currentX, currentY, nextX, nextY)) {
                            break;
                        }
                        if (地牢[nextY][nextX].背景类型 === 单元格类型.墙壁) {
                            break;
                        }
                        path.push({ x: nextX, y: nextY });
                        currentX = nextX;
                        currentY = nextY;
                    }
                    return path;
                }

                寻找直线方向目标() {
                    const 方向列表 = [
                        { dx: 0, dy: -1, 名称: "上" },
                        { dx: 0, dy: 1, 名称: "下" },
                        { dx: -1, dy: 0, 名称: "左" },
                        { dx: 1, dy: 0, 名称: "右" },
                    ];
                    let 最近目标坐标 = null;
                    let 最小距离 = Infinity;
                    const 搜索距离 = 20;

                    for (const 方向 of 方向列表) {
                        let 当前X = 玩家.x;
                        let 当前Y = 玩家.y;

                        for (let i = 1; i <= 搜索距离; i++) {
                            const 检查X = 玩家.x + 方向.dx * i;
                            const 检查Y = 玩家.y + 方向.dy * i;

                            if (
                                检查X < 0 ||
                                检查X >= 地牢大小 ||
                                检查Y < 0 ||
                                检查Y >= 地牢大小
                            )
                                break;
                            if (!检查移动可行性(当前X, 当前Y, 检查X, 检查Y))
                                break;
                            if (地牢[检查Y][检查X].背景类型 === 单元格类型.墙壁)
                                break;

                            const 单元格 = 地牢[检查Y][检查X];
                            if (
                                单元格?.关联怪物 &&
                                单元格.关联怪物.状态 === 怪物状态.活跃
                            ) {
                                const 距离 = i;
                                if (距离 < 最小距离) {
                                    最小距离 = 距离;
                                    最近目标坐标 = { x: 检查X, y: 检查Y };
                                }
                            }
                            当前X = 检查X;
                            当前Y = 检查Y;
                        }
                    }
                    return 最近目标坐标;
                }
                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;

                    const 目标坐标 = this.寻找直线方向目标();
                    let targetDirX, targetDirY;
                    if (目标坐标) {
                        targetDirX = 目标坐标.x;
                        targetDirY = 目标坐标.y;
                    } else {
                        显示通知("攻击范围内无可攻击怪物", "错误");
                        return 0;
                    }
                    const 实际飞出路径 = this.获取固定距离轴向路径(
                        玩家.x,
                        玩家.y,
                        targetDirX,
                        targetDirY
                    );

                    if (实际飞出路径.length === 0) {
                        显示通知("回旋镖无法掷出（前方有障碍）！", "警告");
                        this.自定义数据.set(
                            "耐久",
                            this.自定义数据.get("耐久") - this.耐久消耗 * 0.5
                        );
                        if (this.自定义数据.get("耐久") <= 0)
                            处理销毁物品(this.唯一标识, true);
                        this.自定义数据.set(
                            "冷却剩余",
                            this.自定义数据.get("冷却回合")
                        );
                        更新装备显示();
                        return 0;
                    }

                    let 总有效伤害 = 0;
                    const 击中怪物_去程 = new Set();
                    const 击中怪物_回程 = new Set();

                    for (const 节点 of 实际飞出路径) {
                        const 单元格 = 地牢[节点.y]?.[节点.x];
                        if (
                            单元格?.关联怪物 &&
                            单元格.关联怪物.当前生命值 > 0 &&
                            !击中怪物_去程.has(单元格.关联怪物)
                        ) {
                            const 怪物实例 = 单元格.关联怪物;
                            const 原始血量 = 怪物实例.当前生命值;
                            怪物实例.受伤(this.攻击力, "玩家");
                            const 实际伤害 = 原始血量 - 怪物实例.当前生命值;
                            if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                            击中怪物_去程.add(怪物实例);
                            if (
                                击中怪物_去程.size >=
                                this.自定义数据.get("攻击目标数")
                            )
                                break;
                        }
                    }

                    const 实际返回路径 = [];
                    let 回程当前X =
                        实际飞出路径.length > 0
                            ? 实际飞出路径[实际飞出路径.length - 1].x
                            : 玩家.x;
                    let 回程当前Y =
                        实际飞出路径.length > 0
                            ? 实际飞出路径[实际飞出路径.length - 1].y
                            : 玩家.y;

                    for (let i = 实际飞出路径.length - 1; i >= 0; i--) {
                        const 目标节点 = 实际飞出路径[i];
                        const 回程步X = 目标节点.x;
                        const 回程步Y = 目标节点.y;

                        if (
                            !检查移动可行性(
                                回程当前X,
                                回程当前Y,
                                回程步X,
                                回程步Y
                            )
                        ) {
                            break;
                        }
                        if (地牢[回程步Y][回程步X].类型 === 单元格类型.墙壁) {
                            break;
                        }

                        实际返回路径.push({ x: 回程步X, y: 回程步Y });

                        const 单元格 = 地牢[回程步Y]?.[回程步X];
                        if (
                            单元格?.关联怪物 &&
                            单元格.关联怪物.当前生命值 > 0 &&
                            !击中怪物_回程.has(单元格.关联怪物)
                        ) {
                            const 怪物实例 = 单元格.关联怪物;
                            const 伤害系数 = 击中怪物_去程.has(怪物实例)
                                ? 0.8
                                : 1;
                            const 原始血量 = 怪物实例.当前生命值;
                            怪物实例.受伤(this.攻击力 * 伤害系数, "玩家");
                            const 实际伤害 = 原始血量 - 怪物实例.当前生命值;
                            if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                            击中怪物_回程.add(怪物实例);
                            if (
                                击中怪物_回程.size >=
                                this.自定义数据.get("攻击目标数")
                            )
                                break;
                        }
                        回程当前X = 回程步X;
                        回程当前Y = 回程步Y;
                    }

                    计划显示格子特效(实际飞出路径, "00FF00");
                    if (实际返回路径.length > 0) {
                        setTimeout(() => {
                            计划显示格子特效(实际返回路径.slice(), "FFFF00");
                        }, 450);
                    }

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set(
                        "冷却剩余",
                        this.自定义数据.get("冷却回合")
                    );

                    const 总击中数 = new Set([
                        ...击中怪物_去程,
                        ...击中怪物_回程,
                    ]).size;
                    if (总击中数 > 0) {
                        显示通知(
                            `${
                                this.名称
                            } 击中了 ${总击中数} 个目标，共造成 ${总有效伤害.toFixed(
                                1
                            )} 点伤害！`,
                            "成功"
                        );

                        if (总有效伤害 > 0) {
                            const 所有击中怪物 = Array.from(击中怪物_去程);

                            this.触发通用附魔(所有击中怪物);
                        }
                    } else if (实际飞出路径.length > 0) {
                        显示通知(`${this.名称} 未击中任何目标。`, "信息");
                    }

                    更新装备显示();
                    return 总有效伤害;
                }

                触发通用附魔(目标怪物列表) {
                    if (
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "火焰附魔")?.等级
                    ) {
                        const 火焰等级 = this.自定义数据
                            .get("附魔")
                            .find((item) => item.种类 === "火焰附魔").等级;
                        目标怪物列表.forEach((怪物) => {
                            if (怪物.当前生命值 > 0) {
                                new 状态效果(
                                    "火焰",
                                    "#CC5500",
                                    "火",
                                    火焰等级,
                                    null,
                                    null,
                                    怪物
                                );
                            }
                        });
                    }
                    const 连锁附魔 = this.自定义数据
                        .get("附魔")
                        ?.find((item) => item.种类 === "连锁附魔");
                    if (连锁附魔) {
                        const 连锁距离 = 连锁附魔.等级;
                        目标怪物列表.forEach((初始目标) => {
                            if (初始目标.当前生命值 > 0) {
                                this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                            }
                        });
                    }
                }

                获取提示() {
                    return super.获取提示();
                }
            }

            class 闪电链法杖 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "闪电链法杖",
                        图标: 图标映射.闪电链法杖,
                        品质: 3,
                        基础攻击力: 7,
                        冷却回合: 3,
                        攻击范围: 3,
                        耐久: 配置?.耐久 || 35,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "释放一道闪电链，攻击一个目标后弹射到附近其他敌人，每次弹射伤害递减。",
                        攻击目标数: 1,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            最大弹射次数: 3 + (配置?.强化 ? 1 : 0),
                            弹射范围: 3,
                            伤害衰减系数: 0.7,
                            ...配置.数据,
                        },
                    });
                }

                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;
                    if (!目标怪物列表?.length) return 0;
                    const 初始目标 = 目标怪物列表[0];
                    if (!初始目标 || 初始目标.当前生命值 <= 0) return 0;

                    let 总有效伤害 = 0;
                    const 已攻击怪物 = new Set([初始目标]);
                    let 当前目标 = 初始目标;
                    let 当前伤害 = this.攻击力;
                    const 弹射路径可视化 = [];

                    const 初始攻击路径 = 获取直线路径(
                        玩家.x,
                        玩家.y,
                        初始目标.x,
                        初始目标.y
                    );
                    初始攻击路径.shift();
                    计划显示格子特效(初始攻击路径, "00FFFF");

                    const 初始原始血量 = 初始目标.当前生命值;
                    初始目标.受伤(当前伤害, "玩家");
                    const 初始实际伤害 = 初始原始血量 - 初始目标.当前生命值;
                    if (初始实际伤害 > 0) 总有效伤害 += 初始实际伤害;

                    let 剩余弹射次数 = this.自定义数据.get("最大弹射次数");
                    while (剩余弹射次数 > 0 && 当前目标.当前生命值 > 0) {
                        const 下一个目标信息 = this.寻找下一个弹射目标(
                            当前目标,
                            已攻击怪物
                        );
                        if (!下一个目标信息) break;

                        const { 目标: 下一个目标, 路径: 弹射路径 } =
                            下一个目标信息;

                        当前伤害 *= this.自定义数据.get("伤害衰减系数");
                        if (当前伤害 < 1) break;

                        弹射路径可视化.push(弹射路径);

                        const 原始血量 = 下一个目标.当前生命值;
                        下一个目标.受伤(Math.round(当前伤害), "玩家");
                        const 实际伤害 = 原始血量 - 下一个目标.当前生命值;
                        if (实际伤害 > 0) 总有效伤害 += 实际伤害;

                        已攻击怪物.add(下一个目标);
                        当前目标 = 下一个目标;
                        剩余弹射次数--;
                    }

                    弹射路径可视化.forEach((路径段, index) => {
                        setTimeout(() => {
                            计划显示格子特效(路径段, "FFFF00");
                        }, 100 + index * 100);
                    });

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") -
                            this.耐久消耗 * (已攻击怪物.size > 1 ? 1.5 : 1)
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set(
                        "冷却剩余",
                        this.自定义数据.get("冷却回合")
                    );

                    if (已攻击怪物.size > 0) {
                        显示通知(
                            `${this.名称} 攻击了 ${
                                已攻击怪物.size
                            } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
                            "成功"
                        );
                        if (总有效伤害 > 0) {
                            const 所有击中怪物 = Array.from(已攻击怪物);
                            this.触发通用附魔(所有击中怪物);
                        }
                    }
                    更新装备显示();
                    return 总有效伤害;
                }

                寻找下一个弹射目标(当前怪物, 已攻击集合) {
                    const 范围 = this.自定义数据.get("弹射范围");
                    let 最近目标 = null;
                    let 最短路径 = null;
                    let 最小距离 = Infinity;

                    for (let dx = -范围; dx <= 范围; dx++) {
                        for (let dy = -范围; dy <= 范围; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const x = 当前怪物.x + dx;
                            const y = 当前怪物.y + dy;

                            if (
                                x >= 0 &&
                                x < 地牢大小 &&
                                y >= 0 &&
                                y < 地牢大小
                            ) {
                                const 单元格 = 地牢[y][x];
                                const 潜在目标 = 单元格?.关联怪物;
                                if (
                                    潜在目标 &&
                                    潜在目标.当前生命值 > 0 &&
                                    !已攻击集合.has(潜在目标) &&
                                    潜在目标.状态 === 怪物状态.活跃
                                ) {
                                    const 路径 = 广度优先搜索路径(
                                        当前怪物.x,
                                        当前怪物.y,
                                        x,
                                        y,
                                        范围,
                                        true
                                    );
                                    if (
                                        路径 &&
                                        路径.length > 1 &&
                                        路径.length <= 范围 + 1
                                    ) {
                                        const 距离 = 路径.length - 1;
                                        if (距离 < 最小距离) {
                                            最小距离 = 距离;
                                            最近目标 = 潜在目标;
                                            最短路径 = 路径.slice(1);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return 最近目标 ? { 目标: 最近目标, 路径: 最短路径 } : null;
                }

                获取提示() {
                    let lines = super.获取提示().split("\n");
                    const specificEffectLines = [
                        `最大弹射：${this.自定义数据.get("最大弹射次数")} 次`,
                        `弹射范围：${this.自定义数据.get("弹射范围")} 格`,
                        `伤害衰减：x${this.自定义数据
                            .get("伤害衰减系数")
                            .toFixed(2)} /次`,
                    ];
                    const effectDescIndex = lines.findIndex((line) =>
                        line.startsWith("效果描述：")
                    );
                    let insertAtIndex =
                        effectDescIndex !== -1
                            ? effectDescIndex + 1
                            : lines.findIndex((line) =>
                                  line.startsWith("--- 强化效果 ---")
                              );
                    if (insertAtIndex === -1) insertAtIndex = lines.length;

                    lines.splice(insertAtIndex, 0, ...specificEffectLines);
                    return lines.filter(Boolean).join("\n");
                }
            }

            class 大地猛击锤 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "大地猛击锤",
                        图标: 图标映射.大地猛击锤,
                        品质: 3,
                        基础攻击力: 10,
                        冷却回合: 5,
                        攻击范围: 2 + (配置?.强化 ? 2 : 0),
                        耐久: 配置?.耐久 || 80,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "猛击地面，对自身周围小范围内的所有敌人造成伤害并有几率眩晕。",
                        攻击目标数: 99,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            眩晕几率: 0.3,
                            眩晕回合: 2,
                            ...配置.数据,
                        },
                    });
                }
                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;

                    const 范围 = this.最终攻击范围 - 1;
                    const 影响格子 = [];
                    const 击中怪物 = new Set();
                    let 总有效伤害 = 0;

                    for (let dx = -范围; dx <= 范围; dx++) {
                        for (let dy = -范围; dy <= 范围; dy++) {
                            const x = 玩家.x + dx;
                            const y = 玩家.y + dy;

                            if (
                                x >= 0 &&
                                x < 地牢大小 &&
                                y >= 0 &&
                                y < 地牢大小
                            ) {
                                if (检查视线(玩家.x, 玩家.y, x, y, 范围 + 1)) {
                                    影响格子.push({ x, y });
                                    const 单元格 = 地牢[y][x];
                                    if (
                                        单元格?.关联怪物 &&
                                        单元格.关联怪物.当前生命值 > 0
                                    ) {
                                        const 怪物 = 单元格.关联怪物;
                                        击中怪物.add(怪物);
                                        const 原始血量 = 怪物.当前生命值;
                                        怪物.受伤(this.攻击力, "玩家");
                                        const 实际伤害 =
                                            原始血量 - 怪物.当前生命值;
                                        if (实际伤害 > 0)
                                            总有效伤害 += 实际伤害;

                                        if (
                                            怪物.当前生命值 > 0 &&
                                            Math.random() < this.眩晕几率
                                        ) {
                                            new 状态效果(
                                                "冻结",
                                                "#FFA500",
                                                "晕",
                                                this.自定义数据.get("眩晕回合"),
                                                null,
                                                null,
                                                怪物
                                            );
                                            添加日志(
                                                `${怪物.类型} 被大地猛击锤眩晕了！`,
                                                "警告"
                                            );
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (影响格子.length > 0) {
                        影响格子.forEach((格, index) => {
                            const dist =
                                Math.abs(格.x - 玩家.x) +
                                Math.abs(格.y - 玩家.y);
                            setTimeout(
                                () => 计划显示格子特效([格], "A0522D"),
                                dist * 50
                            );
                        });
                    }

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") -
                            this.耐久消耗 * (击中怪物.size > 2 ? 1.5 : 1)
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set(
                        "冷却剩余",
                        this.自定义数据.get("冷却回合")
                    );

                    if (击中怪物.size > 0) {
                        显示通知(
                            `${this.名称} 震击了 ${
                                击中怪物.size
                            } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
                            "成功"
                        );
                        const 所有击中怪物 = Array.from(击中怪物);

                        if (总有效伤害 > 0) {
                            this.触发通用附魔(所有击中怪物);
                        }
                    } else {
                        显示通知(`${this.名称} 发动了震击！`, "信息");
                    }

                    更新装备显示();
                    return 总有效伤害;
                }
                get 眩晕几率() {
                    return (
                        this.自定义数据.get("眩晕几率") + (this.强化 ? 0.15 : 0)
                    );
                }
                获取提示() {
                    let lines = super.获取提示().split("\n");
                    const specificEffectLines = [
                        `眩晕几率：${(this.眩晕几率 * 100).toFixed(0)}%`,
                    ];
                    const effectDescIndex = lines.findIndex((line) =>
                        line.startsWith("效果描述：")
                    );
                    let insertAtIndex =
                        effectDescIndex !== -1
                            ? effectDescIndex + 1
                            : lines.findIndex((line) =>
                                  line.startsWith("--- 强化效果 ---")
                              );
                    if (insertAtIndex === -1) insertAtIndex = lines.length;

                    lines.splice(insertAtIndex, 0, ...specificEffectLines);
                    return lines.filter(Boolean).join("\n");
                }
            }

            class 穿云箭 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "穿云箭",
                        图标: 图标映射.穿云箭,
                        品质: 2,
                        基础攻击力: 5,
                        冷却回合: 3,
                        攻击范围: 8 + (配置?.强化 ? 2 : 0),
                        耐久: 配置?.耐久 || 50,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "射出一支能够穿透多个敌人的箭矢，飞行固定距离。",
                        攻击目标数: 3 + (配置?.强化 ? 1 : 0),
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            ...配置.数据,
                        },
                    });
                }

                寻找直线方向目标() {
                    const 方向列表 = [
                        { dx: 0, dy: -1, 名称: "上" },
                        { dx: 0, dy: 1, 名称: "下" },
                        { dx: -1, dy: 0, 名称: "左" },
                        { dx: 1, dy: 0, 名称: "右" },
                    ];
                    let 最近目标坐标 = null;
                    let 最小距离 = Infinity;
                    const 搜索距离 = 20;

                    for (const 方向 of 方向列表) {
                        let 当前X = 玩家.x;
                        let 当前Y = 玩家.y;

                        for (let i = 1; i <= 搜索距离; i++) {
                            const 检查X = 玩家.x + 方向.dx * i;
                            const 检查Y = 玩家.y + 方向.dy * i;

                            if (
                                检查X < 0 ||
                                检查X >= 地牢大小 ||
                                检查Y < 0 ||
                                检查Y >= 地牢大小
                            )
                                break;
                            if (!检查移动可行性(当前X, 当前Y, 检查X, 检查Y))
                                break;
                            if (地牢[检查Y][检查X].背景类型 === 单元格类型.墙壁)
                                break;

                            const 单元格 = 地牢[检查Y][检查X];
                            if (
                                单元格?.关联怪物 &&
                                单元格.关联怪物.状态 === 怪物状态.活跃
                            ) {
                                const 距离 = i;
                                if (距离 < 最小距离) {
                                    最小距离 = 距离;
                                    最近目标坐标 = { x: 检查X, y: 检查Y };
                                }
                            }
                            当前X = 检查X;
                            当前Y = 检查Y;
                        }
                    }
                    return 最近目标坐标;
                }

                获取固定距离直线路径(startX, startY, targetX, targetY) {
                    const path = [];
                    const fixedDistance = this.最终攻击范围;
                    const dxTotal = targetX - startX;
                    const dyTotal = targetY - startY;

                    let currentX = startX;
                    let currentY = startY;
                    let dirX = 0;
                    let dirY = 0;

                    if (
                        Math.abs(dxTotal) >= Math.abs(dyTotal) &&
                        dxTotal !== 0
                    ) {
                        dirX = Math.sign(dxTotal);
                        dirY = 0;
                    } else if (
                        Math.abs(dyTotal) > Math.abs(dxTotal) &&
                        dyTotal !== 0
                    ) {
                        dirX = 0;
                        dirY = Math.sign(dyTotal);
                    } else {
                        const lastMove = 移动历史[移动历史.length - 1];
                        if (lastMove === "右") {
                            dirX = 1;
                            dirY = 0;
                        } else if (lastMove === "左") {
                            dirX = -1;
                            dirY = 0;
                        } else if (lastMove === "下") {
                            dirX = 0;
                            dirY = 1;
                        } else if (lastMove === "上") {
                            dirX = 0;
                            dirY = -1;
                        } else {
                            if (Math.random() < 0.5) {
                                dirX = Math.random() < 0.5 ? 1 : -1;
                                dirY = 0;
                            } else {
                                dirX = 0;
                                dirY = Math.random() < 0.5 ? 1 : -1;
                            }
                        }
                    }
                    if (dirX === 0 && dirY === 0) return [];

                    for (let i = 0; i < fixedDistance; i++) {
                        const nextX = currentX + dirX;
                        const nextY = currentY + dirY;

                        if (
                            nextX < 0 ||
                            nextX >= 地牢大小 ||
                            nextY < 0 ||
                            nextY >= 地牢大小
                        )
                            break;
                        if (!检查移动可行性(currentX, currentY, nextX, nextY))
                            break;
                        if (地牢[nextY][nextX].背景类型 === 单元格类型.墙壁)
                            break;

                        path.push({ x: nextX, y: nextY });
                        currentX = nextX;
                        currentY = nextY;
                    }
                    return path;
                }
                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;

                    let targetX, targetY;
                    const 方向目标坐标 = this.寻找直线方向目标();

                    if (方向目标坐标) {
                        targetX = 方向目标坐标.x;
                        targetY = 方向目标坐标.y;
                    } else {
                        显示通知("攻击范围内无可攻击怪物", "错误");
                        return 0;
                    }

                    const 实际飞行路径 = this.获取固定距离直线路径(
                        玩家.x,
                        玩家.y,
                        targetX,
                        targetY
                    );

                    if (实际飞行路径.length === 0) {
                        显示通知("箭矢无法射出（前方有障碍）！", "警告");
                        this.自定义数据.set(
                            "耐久",
                            this.自定义数据.get("耐久") - this.耐久消耗 * 0.5
                        );
                        if (this.自定义数据.get("耐久") <= 0)
                            处理销毁物品(this.唯一标识, true);
                        this.自定义数据.set(
                            "冷却剩余",
                            this.自定义数据.get("冷却回合")
                        );
                        更新装备显示();
                        return 0;
                    }

                    let 总有效伤害 = 0;
                    const 击中怪物 = new Set();
                    let 穿透计数 = 0;

                    for (const 节点 of 实际飞行路径) {
                        if (穿透计数 >= this.自定义数据.get("攻击目标数"))
                            break;

                        const 单元格 = 地牢[节点.y]?.[节点.x];
                        if (
                            单元格?.关联怪物 &&
                            单元格.关联怪物.当前生命值 > 0 &&
                            !击中怪物.has(单元格.关联怪物)
                        ) {
                            const 怪物 = 单元格.关联怪物;
                            击中怪物.add(怪物);
                            穿透计数++;

                            const 原始血量 = 怪物.当前生命值;
                            怪物.受伤(this.攻击力, "玩家");
                            const 实际伤害 = 原始血量 - 怪物.当前生命值;
                            if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                        }
                    }

                    计划显示格子特效(实际飞行路径, "C0C0C0");

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set(
                        "冷却剩余",
                        this.自定义数据.get("冷却回合")
                    );

                    if (击中怪物.size > 0) {
                        显示通知(
                            `${this.名称} 穿透了 ${
                                击中怪物.size
                            } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
                            "成功"
                        );
                        const 所有击中怪物 = Array.from(击中怪物);

                        if (总有效伤害 > 0) {
                            this.触发通用附魔(所有击中怪物);
                        }
                    } else if (实际飞行路径.length > 0) {
                        显示通知(`${this.名称} 未击中任何目标。`, "信息");
                    }

                    更新装备显示();
                    return 总有效伤害;
                }

                触发通用附魔(目标怪物列表) {
                    if (
                        this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "火焰附魔")?.等级
                    ) {
                        const 火焰等级 = this.自定义数据
                            .get("附魔")
                            .find((item) => item.种类 === "火焰附魔").等级;
                        目标怪物列表.forEach((怪物) => {
                            if (怪物.当前生命值 > 0) {
                                new 状态效果(
                                    "火焰",
                                    "#CC5500",
                                    "火",
                                    火焰等级,
                                    null,
                                    null,
                                    怪物
                                );
                            }
                        });
                    }
                    const 连锁附魔 = this.自定义数据
                        .get("附魔")
                        ?.find((item) => item.种类 === "连锁附魔");
                    if (连锁附魔) {
                        const 连锁距离 = 连锁附魔.等级;
                        目标怪物列表.forEach((初始目标) => {
                            if (初始目标.当前生命值 > 0) {
                                this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                            }
                        });
                    }
                }

                获取提示() {
                    return super.获取提示();
                }
            }
            class 钢制长剑 extends 武器类 {
                constructor(配置) {
                    super({
                        名称: "钢制长剑",
                        图标: 图标映射.钢制长剑,
                        基础攻击力: 6,
                        冷却回合: 2,
                        攻击范围: 2,
                        效果描述: "一把标准的钢剑。",
                        耐久: 配置.耐久 || 50,
                        强化: 配置.强化 || false,
                        不可破坏: 配置.不可破坏 || false,
                    });
                }
                获取提示() {
                    return super.获取提示();
                }
            }

            class 橡木法杖 extends 武器类 {
                constructor(配置) {
                    super({
                        名称: "橡木法杖",
                        图标: 图标映射.橡木法杖,
                        品质: 3,
                        基础攻击力: 8,
                        攻击范围: 5,
                        冷却回合: 3,
                        攻击目标数: 5,
                        效果描述: "发射魔法弹攻击多个目标。",
                        耐久: 配置.耐久 || 40,
                        强化: 配置.强化 || false,
                        不可破坏: 配置.不可破坏 || false,
                    });
                }
                获取提示() {
                    return super.获取提示();
                }
            }
            class 冲撞牛角 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "冲撞牛角",
                        图标: 图标映射.冲撞牛角,
                        品质: 5,
                        基础攻击力: 15,
                        冷却回合: 12,
                        攻击范围: 10,
                        耐久: 配置?.耐久 || 50,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "消耗能量，朝怪物最多的方向冲锋，对路径上的敌人造成伤害。",
                        攻击目标数: 99,
                        不可破坏: 配置?.不可破坏 || false,
                        数据: {
                            能量消耗: 40,
                            ...配置.数据,
                        },
                    });
                }

                使用() {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return false;
                    if (!扣除能量(this.自定义数据.get("能量消耗"))) {
                        显示通知("能量不足！", "错误");
                        return false;
                    }

                    const 方向列表 = [
                        { dx: 0, dy: -1, 名称: "上" },
                        { dx: 0, dy: 1, 名称: "下" },
                        { dx: -1, dy: 0, 名称: "左" },
                        { dx: 1, dy: 0, 名称: "右" },
                    ];
                    let 最佳方向 = null;
                    let 最大怪物数 = -1;

                    方向列表.forEach((方向) => {
                        let 怪物计数 = 0;
                        for (let i = 1; i <= this.最终攻击范围; i++) {
                            const 检查X = 玩家.x + 方向.dx * i;
                            const 检查Y = 玩家.y + 方向.dy * i;
                            if (
                                !检查直线移动可行性(
                                    玩家.x,
                                    玩家.y,
                                    检查X,
                                    检查Y,
                                    true
                                )
                            )
                                break;
                            if (地牢[检查Y]?.[检查X]?.关联怪物) {
                                怪物计数++;
                            }
                        }
                        if (怪物计数 > 最大怪物数) {
                            最大怪物数 = 怪物计数;
                            最佳方向 = 方向;
                        }
                    });

                    if (最大怪物数 <= 0) {
                        显示通知("没有可冲锋的目标方向！", "信息");
                        const 能量条 = document.querySelector(".power-bar");
                        const 当前能量 = parseFloat(能量条.style.width) || 0;
                        能量条.style.width = `${Math.min(
                            100,
                            当前能量 + this.自定义数据.get("能量消耗")
                        )}%`;
                        return false;
                    }

                    const 冲锋路径 = [];
                    let 最终X = 玩家.x;
                    let 最终Y = 玩家.y;
                    let 总有效伤害 = 0;

                    for (let i = 1; i <= this.最终攻击范围; i++) {
                        const 新X = 玩家.x + 最佳方向.dx * i;
                        const 新Y = 玩家.y + 最佳方向.dy * i;
                        if (!检查直线移动可行性(最终X, 最终Y, 新X, 新Y)) break;

                        冲锋路径.push({ x: 新X, y: 新Y });
                        最终X = 新X;
                        最终Y = 新Y;

                        const 单元格 = 地牢[新Y]?.[新X];
                        if (单元格?.关联怪物) {
                            const 原始血量 = 单元格.关联怪物.当前生命值;
                            单元格.关联怪物.受伤(this.攻击力, "玩家");
                            let 实际伤害 =
                                原始血量 - 单元格.关联怪物?.当前生命值;
                            if (!单元格.关联怪物?.当前生命值) 实际伤害 = 原始血量;
                            if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                        }
                    }

                    if (冲锋路径.length > 0) {
                        计划显示格子特效(冲锋路径, "FFA500");
                        const 旧玩家X = 玩家.x;
                        const 旧玩家Y = 玩家.y;
                        玩家.x = 最终X;
                        玩家.y = 最终Y;
                        处理玩家着陆效果(旧玩家X, 旧玩家Y, 玩家.x, 玩家.y);
                        更新视口();
                        显示通知(
                            `发动冲锋！对路径上的敌人造成了 ${总有效伤害.toFixed(
                                1
                            )} 点伤害！`,
                            "成功"
                        );
                    }

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                    }
                    this.自定义数据.set("冷却剩余", this.最终冷却回合);
                    更新装备显示();
                    return true;
                }
            }
            class 护卫种子 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "种子",
                        名称: "护卫种子",
                        图标: 图标映射.种子,
                        品质: 2,
                        颜色索引: 1,
                        堆叠数量: 配置.数量 || 1,
                        最大堆叠数量: 16,
                        效果描述:
                            "种下一株永久存在的护卫植物，它会自动攻击周围的敌人，可以用互动键收回。",
                        数据: {
                            耐久: 配置.耐久,
                        },
                        ...配置,
                    });
                }

                使用() {
                    if (this.堆叠数量 <= 0) return false;
                    const 放置位置 = 寻找可放置位置(玩家.x, 玩家.y);
                    if (!放置位置) {
                        显示通知("周围没有合适的地方播种！", "错误");
                        return false;
                    }
                    const 护卫植物实例 = new 护卫植物({
                        强化: this.强化,
                        耐久: this.自定义数据.get("耐久"),
                    });
                    if (
                        放置物品到单元格(护卫植物实例, 放置位置.x, 放置位置.y)
                    ) {
                        所有计时器.push(护卫植物实例);
                        this.堆叠数量--;
                        显示通知("种下了护卫植物！", "成功");
                        return true;
                    }
                    return false;
                }
                获取提示() {
                    let 提示 = super.获取提示();
                    const 耐久 = this.自定义数据.get("耐久");
                    if (耐久 !== undefined && 耐久 !== null) {
                        const 临时植物 = new 护卫植物({ 强化: this.强化 });
                        const 原耐久 = 临时植物.自定义数据.get("原耐久");
                        提示 += `\n剩余攻击次数: ${耐久}/${原耐久}`;
                    }
                    return 提示;
                }
            }

            class 护卫植物 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "植物",
                        名称: "护卫植物",
                        图标: 图标映射.护卫植物,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: false,
                        效果描述: "攻击周围的敌人。",
                        数据: {
                            倒计时: -1,
                            爆炸时间: -1,
                            攻击力: 5 + (配置.强化 ? 3 : 0),
                            耐久: 配置.耐久 ?? (30 + (配置.强化 ? 20 : 0)),
                            冷却: 2,
                            冷却剩余: 0,
                        },
                        ...配置,
                    });
                }

                尝试互动() {
                    if (玩家.x !== this.x || 玩家.y !== this.y) {
                        return false;
                    }
                    if (
                        尝试收集物品(
                            new 护卫种子({ 耐久: this.自定义数据.get("耐久") }),
                            true
                        )
                    ) {
                        this.移除自身();
                        显示通知("成功回收了护卫种子！", "成功");
                        return true;
                    } else {
                        显示通知("背包已满，无法回收种子！", "错误");
                        return false;
                    }
                }

                移除自身() {
                    if (
                        this.x !== null &&
                        this.y !== null &&
                        地牢[this.y]?.[this.x]?.关联物品 === this
                    ) {
                        地牢[this.y][this.x].关联物品 = null;
                        地牢[this.y][this.x].类型 = null;
                    }
                    所有计时器 = 所有计时器.filter((item) => item !== this);
                    绘制();
                }

                更新倒计时() {
                    let 冷却剩余 = this.自定义数据.get("冷却剩余");
                    if (冷却剩余 > 0) {
                        this.自定义数据.set("冷却剩余", 冷却剩余 - 1);
                        return;
                    }
                    let 耐久 = this.自定义数据.get("耐久");
                    if (耐久 <= 0) {
                        this.移除自身();
                        显示通知(`${this.名称} 枯萎了。`, "信息");
                        return;
                    }

                    const 攻击范围 = 1;
                    for (let dy = -攻击范围; dy <= 攻击范围; dy++) {
                        for (let dx = -攻击范围; dx <= 攻击范围; dx++) {
                            const 目标X = this.x + dx;
                            const 目标Y = this.y + dy;
                            if (
                                目标X >= 0 &&
                                目标X < 地牢大小 &&
                                目标Y >= 0 &&
                                目标Y < 地牢大小
                            ) {
                                const 单元格 = 地牢[目标Y]?.[目标X];
                                if (
                                    单元格?.关联怪物 &&
                                    单元格.关联怪物.当前生命值 > 0
                                ) {
                                    单元格.关联怪物.受伤(
                                        this.自定义数据.get("攻击力"),
                                        this
                                    );
                                    this.自定义数据.set("耐久", 耐久 - 1);
                                    this.自定义数据.set(
                                        "冷却剩余",
                                        this.自定义数据.get("冷却")
                                    );
                                    计划显示格子特效(
                                        [{ x: 目标X, y: 目标Y }],
                                        "00FF00"
                                    );
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            class 远射种子 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "种子",
                        名称: "远射种子",
                        图标: 图标映射.种子,
                        品质: 3,
                        颜色索引: 2,
                        堆叠数量: 配置.数量 || 1,
                        最大堆叠数量: 16,
                        效果描述:
                            "种下一株永久存在的远射植物，它会远程攻击并击退敌人，可以用互动键收回。",
                        数据: {
                            耐久: 配置.耐久,
                        },
                        ...配置,
                    });
                }

                使用() {
                    if (this.堆叠数量 <= 0) return false;
                    const 放置位置 = 寻找可放置位置(玩家.x, 玩家.y);
                    if (!放置位置) {
                        显示通知("周围没有合适的地方播种！", "错误");
                        return false;
                    }
                    const 远射植物实例 = new 远射植物({
                        强化: this.强化,
                        耐久: this.自定义数据.get("耐久"),
                    });
                    if (
                        放置物品到单元格(远射植物实例, 放置位置.x, 放置位置.y)
                    ) {
                        所有计时器.push(远射植物实例);
                        this.堆叠数量--;
                        显示通知("种下了远射植物！", "成功");
                        return true;
                    }
                    return false;
                }
                获取提示() {
                    let 提示 = super.获取提示();
                    const 耐久 = this.自定义数据.get("耐久");
                    if (耐久 !== undefined && 耐久 !== null) {
                         const 临时植物 = new 远射植物({ 强化: this.强化 });
                         const 原耐久 = 临时植物.自定义数据.get("原耐久");
                         提示 += `\n剩余攻击次数: ${耐久}/${原耐久}`;
                    }
                    return 提示;
                }
            }

            class 远射植物 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "植物",
                        名称: "远射植物",
                        图标: 图标映射.远射植物,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: false,
                        效果描述: "远程攻击敌人。",
                        数据: {
                            倒计时: -1,
                            爆炸时间: -1,
                            攻击力: 4 + (配置.强化 ? 2 : 0),
                            攻击范围: 6,
                            冷却: 3,
                            冷却剩余: 0,
                            耐久: 配置.耐久 ?? (25 + (配置.强化 ? 15 : 0)),
                            
                        },
                        ...配置,
                    });
                }

                尝试互动() {
                    if (玩家.x !== this.x || 玩家.y !== this.y) {
                        return false;
                    }
                    if (
                        尝试收集物品(
                            new 远射种子({ 耐久: this.自定义数据.get("耐久") }),
                            true
                        )
                    ) {
                        this.移除自身();
                        显示通知("成功回收了远射种子！", "成功");
                        return true;
                    } else {
                        显示通知("背包已满，无法回收种子！", "错误");
                        return false;
                    }
                }

                移除自身() {
                    if (
                        this.x !== null &&
                        this.y !== null &&
                        地牢[this.y]?.[this.x]?.关联物品 === this
                    ) {
                        地牢[this.y][this.x].关联物品 = null;
                        地牢[this.y][this.x].类型 = null;
                    }
                    所有计时器 = 所有计时器.filter((item) => item !== this);
                    绘制();
                }

                更新倒计时() {
                    let 冷却剩余 = this.自定义数据.get("冷却剩余");
                    if (冷却剩余 > 0) {
                        this.自定义数据.set("冷却剩余", 冷却剩余 - 1);
                        return;
                    }
                    let 耐久 = this.自定义数据.get("耐久");
                    if (耐久 <= 0) {
                        this.移除自身();
                        显示通知(`${this.名称} 枯萎了。`, "信息");
                        return;
                    }

                    let 最近怪物 = null;
                    let 最小距离 = Infinity;

                    所有怪物.forEach((怪物) => {
                        if (怪物.状态 === 怪物状态.活跃) {
                            const 距离 =
                                Math.abs(this.x - 怪物.x) +
                                Math.abs(this.y - 怪物.y);
                            if (
                                距离 < 最小距离 &&
                                距离 <= this.自定义数据.get("攻击范围")
                            ) {
                                if (
                                    检查视线(
                                        this.x,
                                        this.y,
                                        怪物.x,
                                        怪物.y,
                                        this.自定义数据.get("攻击范围")
                                    )
                                ) {
                                    最小距离 = 距离;
                                    最近怪物 = 怪物;
                                }
                            }
                        }
                    });

                    if (最近怪物) {
                        最近怪物.受伤(this.自定义数据.get("攻击力"), this);
                        const 路径 = 获取直线路径(
                            this.x,
                            this.y,
                            最近怪物.x,
                            最近怪物.y
                        );
                        计划显示格子特效(路径, "FFA500");

                        const dx = 最近怪物.x - this.x;
                        const dy = 最近怪物.y - this.y;
                        let 方向DX = dx === 0 ? 0 : Math.sign(dx);
                        let 方向DY = dy === 0 ? 0 : Math.sign(dy);
                        if (Math.abs(dx) > Math.abs(dy)) {
                            方向DY = 0;
                        } else {
                            方向DX = 0;
                        }

                        const { x: 最终X, y: 最终Y } =
                            最近怪物.计算最大甩飞位置(
                                最近怪物.x,
                                最近怪物.y,
                                方向DX,
                                方向DY,
                                1
                            );
                        if (最终X !== 最近怪物.x || 最终Y !== 最近怪物.y) {
                            const oldX = 最近怪物.x,
                                oldY = 最近怪物.y;
                            最近怪物.恢复背景类型();
                            最近怪物.x = 最终X;
                            最近怪物.y = 最终Y;
                            最近怪物.保存新位置类型(最终X, 最终Y);
                            地牢[最终Y][最终X].类型 = 单元格类型.怪物;
                            地牢[最终Y][最终X].关联怪物 = 最近怪物;
                            最近怪物.处理地形效果();
                            最近怪物.绘制血条();
                            怪物动画状态.set(最近怪物, {
                                旧逻辑X: oldX,
                                旧逻辑Y: oldY,
                                目标逻辑X: 最终X,
                                目标逻辑Y: 最终Y,
                                视觉X: oldX,
                                视觉Y: oldY,
                                动画开始时间: Date.now(),
                                正在动画: true,
                            });
                        }

                        this.自定义数据.set("耐久", 耐久 - 1);
                        this.自定义数据.set(
                            "冷却剩余",
                            this.自定义数据.get("冷却")
                        );
                    }
                }
            }
            class 泉水 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: "生命之泉",
                        图标: 图标映射.泉水,
                        品质: 4,
                        颜色索引: 1,
                        能否拾起: false,
                        阻碍怪物: false,
                        是否正常物品: false,
                        效果描述: "互动一次即可完全恢复生命和能量。",
                        数据: {
                            已使用: false,
                            ...配置.数据,
                        },
                        ...配置,
                    });
                }

                使用() {
                    if (this.自定义数据.get("已使用")) {
                        显示通知("泉水已经干涸了。", "信息");
                        return false;
                    }
                    const 生命条 = document.querySelector(".health-bar");
                    const 能量条 = document.querySelector(".power-bar");
                    生命条.style.width = "100%";
                    能量条.style.width = "100%";
                    this.自定义数据.set("已使用", true);

                    this.效果描述 = "泉水已经干涸了。";
                    显示通知("你感到一股清流涌遍全身，焕然一新！", "成功");
                    绘制();
                    return true;
                }

                尝试互动() {
                    return this.使用();
                }
            }

            class 书架 extends 物品 {
                constructor(配置 = {}) {
                    const hasContent =
                        配置.有内容 !== undefined
                            ? 配置.有内容
                            : Math.random() < 0.2;
                    super({
                        类型: "地形",
                        名称: hasContent ? "古老的书架" : "空书架",
                        图标: 图标映射.书架,
                        品质: 3,
                        颜色索引: 2,
                        能否拾起: false,
                        阻碍怪物: false,
                        是否正常物品: false,
                        效果描述: hasContent
                            ? "互动一次可以随机获得一个已解锁的卷轴或融合配方。"
                            : "这个书架上空空如也，积满了灰尘。",
                        数据: {
                            已使用: !hasContent,
                            ...配置.数据,
                        },
                        ...配置,
                    });
                }

                使用() {
                    if (this.自定义数据.get("已使用")) {
                        显示通知("书架上已经没有可读的书了。", "信息");
                        return false;
                    }

                    if (Math.random() < 0.7) {
                        const 可用卷轴 = 物品池["卷轴"].filter((item) => {
                            const 实例 = new item.类({});
                            return 实例.是否正常物品;
                        });
                        if (可用卷轴.length > 0) {
                            const 选中卷轴配置 =
                                可用卷轴[
                                    Math.floor(Math.random() * 可用卷轴.length)
                                ];
                            const 新卷轴 = new 选中卷轴配置.类({
                                已解锁: true,
                            });
                            if (尝试收集物品(新卷轴, true)) {
                                显示通知(
                                    `你从书中习得了《${新卷轴.名称}》！`,
                                    "成功"
                                );
                            } else {
                                显示通知(
                                    `你发现了一本《${新卷轴.名称}》，但背包满了！`,
                                    "错误"
                                );
                                return false;
                            }
                        }
                    } else {
                        const 可用配方 = [...程序生成配方列表];
                        if (可用配方.length > 0) {
                            const 选中配方 =
                                可用配方[
                                    Math.floor(Math.random() * 可用配方.length)
                                ];
                            if (
                                !已发现的程序生成配方.some(
                                    (r) => r.说明 === 选中配方.说明
                                )
                            ) {
                                已发现的程序生成配方.push(选中配方);
                                显示通知(
                                    `你发现了一张配方：${选中配方.说明}！`,
                                    "成功"
                                );
                            } else {
                                显示通知(
                                    "你又读了一遍熟悉的配方，温故而知新。",
                                    "信息"
                                );
                            }
                        } else {
                            显示通知(
                                "书架上落满了灰尘，什么也没找到。",
                                "信息"
                            );
                        }
                    }

                    this.自定义数据.set("已使用", true);
                    this.名称 = "空书架";
                    this.效果描述 = "这个书架上空空如也，积满了灰尘。";

                    return true;
                }

                尝试互动() {
                    return this.使用();
                }
            }

            class 迅捷卷轴 extends 卷轴类 {
                constructor(配置) {
                    super({
                        名称: "迅捷卷轴",
                        品质: 3,
                        效果描述: "激活后增加移动步数，效果可叠加，消耗能量",
                        能量消耗: 配置.能量消耗 ?? 4,
                        强化: 配置.强化 || false,
                        已解锁: 配置.已解锁 || false,
                    });
                    this.速度加成值 = 2;
                }

                计算总迅捷加成() {
                    let 激活的迅捷卷轴数量 = 0;
                    if (
                        typeof 当前激活卷轴列表 !== "undefined" &&
                        当前激活卷轴列表 instanceof Set
                    ) {
                        当前激活卷轴列表.forEach((卷轴) => {
                            if (卷轴 instanceof 迅捷卷轴) {
                                激活的迅捷卷轴数量++;
                            }
                        });
                    } else {
                        console.warn(
                            "迅捷卷轴：无法访问或类型错误的 当前激活卷轴列表，无法计算加成。"
                        );
                        return 0;
                    }
                    return 激活的迅捷卷轴数量 * this.速度加成值;
                }

                使用() {
                    const 总加成 = this.计算总迅捷加成();
                    玩家属性.移动步数 = 初始玩家属性.移动步数 + 总加成;
                    return true;
                }

                卸下() {
                    const 总加成 = this.计算总迅捷加成();
                    const 计算后的步数 = 初始玩家属性.移动步数 + 总加成;
                    玩家属性.移动步数 = Math.max(
                        初始玩家属性.移动步数,
                        计算后的步数
                    );
                    return true;
                }
            }
            class 神秘卷轴 extends 卷轴类 {
                constructor(配置) {
                    super({
                        名称: "神秘卷轴",
                        品质: 3,
                        效果描述: "浪费能量的空白卷轴",
                        能量消耗: 15,
                        强化: 配置.强化 || false,
                        已解锁: 配置.已解锁 || false,
                    });
                }
                //使用时不卸下即视为每回合消耗能量，消耗能量在卷轴基类处理
                使用() {
                    return true;
                }
                卸下() {
                    return true;
                }
            }
            class 贪婪卷轴 extends 卷轴类 {
                constructor(配置) {
                    super({
                        名称: "贪婪卷轴",
                        品质: 3,
                        效果描述: "赌狗！将怪物掉落率/装备耐久提高一倍吧！",
                        能量消耗: 15,
                        强化: 配置.强化 || false,
                        已解锁: 配置.已解锁 || false,
                    });
                }

                使用() {
                    if (!this.消耗能量()) return false;
                    玩家属性.掉落倍率 = 2;
                    return true;
                }
                卸下() {
                    玩家属性.掉落倍率 = 1;
                    return true;
                }
            }
            class 清净卷轴 extends 卷轴类 {
                constructor(配置) {
                    super({
                        名称: "清净卷轴",
                        品质: 3,
                        效果描述: "消耗大量能量，激活后去除自身所有效果",
                        能量消耗: 40,
                        强化: 配置.强化 || false,
                        已解锁: 配置.已解锁 || false,
                    });
                }

                使用() {
                    if (!this.消耗能量()) return false;
                    玩家状态.forEach((item) => {
                        item.移除状态();
                    });
                    当前激活卷轴列表.delete(this);

                    显示通知("卷轴成功发挥作用", "成功");
                    绘制();
                    return true;
                }
            }
            class 金币手枪 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "金币手枪",
                        图标: 图标映射.金币手枪,
                        品质: 3,
                        颜色索引: 2,
                        效果描述:
                            "发射直线子弹，中弹怪物会麻木，每发消耗2金币。",
                        基础攻击力: 1,
                        冷却回合: 1,
                        攻击范围: 40,
                        耐久: 配置.耐久 || 75,
                        强化: 配置.强化 || false,
                        不可破坏: 配置.不可破坏 || false,
                        数据: {
                            金币消耗: 2,
                        },
                    });
                }
                使用() {
                    const 金币列表 = [...玩家背包.values()].filter(
                        (i) => i instanceof 金币
                    );
                    const 总金币 = 金币列表.reduce(
                        (sum, i) => sum + i.堆叠数量,
                        0
                    );
                    if (总金币 < this.自定义数据.get("金币消耗")) {
                        显示通知("金币不足！", "错误");
                        return false;
                    }
                    const 攻击结果 = this.寻找直线目标();
                    if (!攻击结果) {
                        return false;
                    }

                    if (!扣除金币(this.自定义数据.get("金币消耗")))
                        return false;

                    super.使用([攻击结果.怪物]);
                    更新背包显示();
                    攻击结果.怪物.受伤冻结回合剩余 = 2;
                    计划显示格子特效(攻击结果.路径);
                    return true;
                }
                寻找直线目标() {
                    const 方向列表 = [
                        {
                            dx: 0,
                            dy: -1,
                            名称: "上",
                        },
                        {
                            dx: 0,
                            dy: 1,
                            名称: "下",
                        },
                        {
                            dx: -1,
                            dy: 0,
                            名称: "左",
                        },
                        {
                            dx: 1,
                            dy: 0,
                            名称: "右",
                        },
                    ];
                    let 最近目标 = null;
                    let 最小距离 = Infinity;
                    if (地牢[玩家.y][玩家.x].类型 === 单元格类型.怪物) {
                        return {
                            怪物: 地牢[玩家.y][玩家.x].关联怪物,
                            路径: [{ x: 玩家.x, y: 玩家.y }],
                        };
                    }
                    方向列表.forEach((方向) => {
                        let 当前X = 玩家.x + 方向.dx;
                        let 当前Y = 玩家.y + 方向.dy;
                        let 路径 = [];
                        for (let i = 0; i < 9999; i++) {
                            if (
                                !检查移动可行性(
                                    当前X - 方向.dx,
                                    当前Y - 方向.dy,
                                    当前X,
                                    当前Y
                                )
                            )
                                break;
                            const 单元格 = 地牢[当前Y]?.[当前X];
                            if (
                                单元格?.关联怪物 &&
                                单元格.类型 === 单元格类型.怪物 &&
                                单元格.关联怪物?.状态 === 怪物状态.活跃
                            ) {
                                const 距离 =
                                    Math.abs(当前X - 玩家.x) +
                                    Math.abs(当前Y - 玩家.y);
                                if (距离 < 最小距离) {
                                    最近目标 = {
                                        怪物: 单元格.关联怪物,
                                        路径: 获取直线路径(
                                            玩家.x,
                                            玩家.y,
                                            当前X,
                                            当前Y
                                        ),
                                    };
                                    最小距离 = 距离;
                                }
                                break;
                            }
                            路径.push({
                                x: 当前X,
                                y: 当前Y,
                            });
                            当前X += 方向.dx;
                            当前Y += 方向.dy;
                        }
                    });
                    return 最近目标;
                }
                获取提示() {
                    return super.获取提示();
                }
            }

            class 附魔卷轴 extends 卷轴类 {
                constructor(配置) {
                    super({
                        名称: "附魔卷轴",
                        品质: 配置.品质 || 1,
                        效果描述: "为装备附加附魔",
                        能量消耗: 30,
                        已解锁: 配置.已解锁 || false,
                        强化: 配置.强化 || false,
                    });
                    this.可用次数 = 配置.可用次数 || 1;
                    this.附魔池 = [
                        this.火焰附魔,
                        this.保护附魔,
                        this.耐久附魔,
                        this.锋利附魔,
                        this.爆炸保护附魔,
                        this.连锁附魔,
                        this.荆棘附魔,
                    ];
                    this.效果名 = [
                        "火焰附魔",
                        "保护附魔",
                        "耐久附魔",
                        "锋利附魔",
                        "爆炸保护附魔",
                        "连锁附魔",
                        "荆棘附魔",
                    ];
                    const 效果索引 = Math.floor(
                        Math.random() * this.附魔池.length
                    );
                    this.附魔效果 = this.附魔池[效果索引];
                    this.当前附魔效果名 = this.效果名[效果索引];
                    if (!配置.品质) {
                        this.品质 = Math.floor(Math.random() * 6) || 1;
                        this.颜色索引 = this.品质 - 1;
                    }
                    this.效果描述 =
                        "为装备附加" +
                        this.当前附魔效果名 +
                        "(附魔等级由品质决定)";
                }

                使用() {
                    this.显示附魔界面();
                    return true;
                }

                显示附魔界面() {
                    玩家属性.允许移动 += 1;
                    const 弹窗 = this.创建附魔弹窗();
                    this.添加装备到弹窗(弹窗);
                    this.添加确认按钮(弹窗);
                }

                添加确认按钮(弹窗) {
                    const 确认按钮 = document.createElement("button");
                    确认按钮.className = "附魔确认按钮";
                    确认按钮.innerHTML = "开始附魔";
                    确认按钮.addEventListener("click", () => {
                        const 选中装备 = 弹窗.querySelector(".可附魔.active");
                        if (选中装备) {
                            this.执行附魔(选中装备.__物品实例, 弹窗, 选中装备);
                        } else {
                            显示通知("请选择要附魔物品", "错误");
                        }
                    });
                    弹窗.querySelector(".附魔装备容器").after(确认按钮);
                }

                创建附魔弹窗() {
                    const 弹窗 = document.createElement("div");
                    弹窗.className = "附魔弹窗";
                    弹窗.innerHTML = `
            <div class="附魔头" >
                <span class="附魔标题">选择要附魔的装备</span>
                <button class="关闭按钮" click>×</button>
            </div >
            <div class="附魔装备容器"></div>
            <div class="附魔特效"></div>
        `;
                    弹窗.querySelector(".关闭按钮").addEventListener(
                        "click",
                        () => {
                            弹窗.classList.add("关闭中");
                            setTimeout(() => {
                                玩家属性.允许移动 -= 1;
                                弹窗.remove();
                                当前激活卷轴列表.delete(this);
                            }, 300);
                        }
                    );
                    document.body.appendChild(弹窗);
                    return 弹窗;
                }

                添加装备到弹窗(弹窗) {
                    const 容器 = 弹窗.querySelector(".附魔装备容器");
                    Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                        玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                    )
                        .filter((v) => v != null)
                        .forEach((装备) => {
                            const 克隆元素 = 装备
                                .生成显示元素("装备")
                                .cloneNode(true);
                            克隆元素.style.margin = "-5px 0";
                            克隆元素.classList.remove("active");
                            克隆元素.classList.remove("hover");
                            克隆元素.removeAttribute("data-quality");
                            克隆元素.__物品实例 = 装备;
                            克隆元素.classList.add("可附魔");
                            克隆元素.addEventListener("click", (e) => {
                                克隆元素.classList.add("active");
                                容器.querySelectorAll(".物品条目").forEach(
                                    (el) => {
                                        if (el !== 克隆元素) {
                                            el.classList.remove("active");
                                        }
                                    }
                                );
                            });
                            ["丢弃按钮", "使用按钮", "装备按钮"].forEach(
                                (className) => {
                                    克隆元素.querySelector(
                                        `.${className} `
                                    )?.remove();
                                }
                            );
                            容器.appendChild(克隆元素);
                        });
                }

                执行附魔(装备, 弹窗, 元素) {
                    const 成功 = this.附魔效果.call(this, 装备);

                    if (成功) {
                        元素.classList.add("附魔成功");
                        setTimeout(
                            () => 元素.classList.remove("附魔成功"),
                            1500
                        );

                        this.播放附魔特效(装备, 弹窗, 元素);
                        this.可用次数--;
                        if (this.可用次数 <= 0) {
                            处理销毁物品(this.唯一标识, true);
                        }
                        显示通知("附魔成功！装备绽放出神秘光芒", "成功");
                        弹窗.classList.add("关闭中");
                        当前激活卷轴列表.delete(this);
                        更新装备显示();

                        setTimeout(() => {
                            弹窗.remove();
                            玩家属性.允许移动 -= 1;
                        }, 2000);
                        return true;
                    } else {
                        显示通知("无法应用附魔！", "错误");
                        return false;
                    }
                }

                火焰附魔(装备) {
                    return this.添加附魔(装备, "火焰附魔", [
                        "武器",
                        "防御装备",
                    ]);
                }
                耐久附魔(装备) {
                    return this.添加附魔(装备, "耐久附魔", [
                        "武器",
                        "防御装备",
                    ]);
                }
                保护附魔(装备) {
                    return this.添加附魔(装备, "保护附魔", ["防御装备"]);
                }
                锋利附魔(装备) {
                    return this.添加附魔(装备, "锋利附魔", ["武器"]);
                }
                连锁附魔(装备) {
                    return this.添加附魔(装备, "连锁附魔", ["武器"]);
                }
                爆炸保护附魔(装备) {
                    return this.添加附魔(装备, "爆炸保护附魔", ["防御装备"]);
                }
                荆棘附魔(装备) {
                    return this.添加附魔(装备, "荆棘附魔", ["防御装备"]);
                }
                添加附魔(装备, 附魔种类, 允许装备列表) {
                    if (装备.自定义数据.get("附魔")) {
                        if (
                            !装备.自定义数据
                                .get("附魔")
                                .some(
                                    (附魔) =>
                                        附魔.种类 === 附魔种类 &&
                                        附魔.等级 >= this.品质
                                ) &&
                            允许装备列表.includes(装备.类型)
                        ) {
                            if (!this.消耗能量()) {
                                显示通知("能量不足！", "错误");
                                return false;
                            }
                            let 成功附魔 = false;
                            装备.自定义数据
                                .get("附魔")
                                .forEach((item, index, arr) => {
                                    if (
                                        item.种类 === 附魔种类 &&
                                        item.等级 < this.品质
                                    ) {
                                        arr[index] = {
                                            种类: 附魔种类,
                                            等级: this.品质,
                                        };
                                        成功附魔 = true;
                                    }
                                });
                            if (!成功附魔) {
                                装备.自定义数据
                                    .get("附魔")
                                    .push({ 种类: 附魔种类, 等级: this.品质 });
                            }
                            return true;
                        }
                    }
                    return false;
                }
                播放附魔特效(装备, 弹窗, 装备元素) {
                    const 装备位置 = 装备元素.getBoundingClientRect();
                    const 中心X = 装备位置.left + 装备位置.width / 2;
                    const 中心Y = 装备位置.top + 装备位置.height / 2;

                    const 特效容器 = document.createElement("div");
                    特效容器.style = `
        position: fixed;
        left: ${中心X}px;
        top: ${中心Y}px;
        pointer-events: none;
        z-index: 10001;
        `;

                    document.body.appendChild(特效容器);

                    const 粒子数 = 12;

                    const 基础色相 = 260;

                    for (let i = 0; i < 粒子数; i++) {
                        const 粒子 = document.createElement("div");
                        粒子.className = "魔幻粒子";

                        const 角度 = Math.random() * Math.PI * 2;
                        const 距离 = 120 + Math.random() * 80;
                        const 目标X = Math.cos(角度) * 距离;
                        const 目标Y = Math.sin(角度) * 距离;
                        const 大小 = 12 + Math.random() * 16;
                        const 旋转 = Math.random() * 720;
                        const 色相偏移 = (Math.random() - 0.5) * 40;
                        const 亮度曲线 = 60 + Math.random() * 30;

                        粒子.style = `
        --target-x: ${目标X}px;
        --target-y: ${目标Y}px;
        --size: ${大小}px;
        --hue: ${基础色相 + 色相偏移};
        transform: translateZ(0);
        --lightness: ${亮度曲线}%;
        --rotate: ${旋转}deg;
        --delay: ${Math.random() * 0.4}s;
        `;

                        特效容器.appendChild(粒子);
                    }

                    setTimeout(() => 特效容器.remove(), 2000);
                }
            }

            class 跃迁卷轴 extends 卷轴类 {
                constructor(配置) {
                    super({
                        名称: "跃迁卷轴",
                        品质: 3,
                        效果描述: "随机传送到未访问房间，并解锁目标房间所有门",
                        强化: 配置.强化 || false,
                        能量消耗: 70,
                        已解锁: 配置.已解锁 || false,
                    });
                }

                使用() {
                    if (!this.消耗能量()) return false;

                    const 当前玩家房间ID = 房间地图[玩家.y][玩家.x];
                    if (当前玩家房间ID !== -1) {
                        const 当前玩家所在房间 = 房间列表[当前玩家房间ID];
                        if (
                            当前玩家所在房间 &&
                            当前玩家所在房间.类型 === "挑战房间" &&
                            当前玩家所在房间.挑战状态 &&
                            当前玩家所在房间.挑战状态.进行中
                        ) {
                            处理挑战失败(当前玩家所在房间);
                        }
                    }
                    if (生存挑战激活) {
                        显示通知("强大的结界阻止了空间传送！", "错误");
                        return false;
                    }
                    const 有效房间 = 房间列表.filter(
                        (r) =>
                            r.id !== 房间地图[玩家.y][玩家.x] &&
                            !已访问房间.has(r.id)
                    );

                    let 目标房间;
                    if (有效房间.length > 0) {
                        目标房间 =
                            有效房间[
                                Math.floor(Math.random() * 有效房间.length)
                            ];
                    } else {
                        const 所有可选房间 = 房间列表.filter(
                            (r) => r.id !== 房间地图[玩家.y][玩家.x]
                        );
                        if (所有可选房间.length > 0) {
                            目标房间 =
                                所有可选房间[
                                    Math.floor(
                                        Math.random() * 所有可选房间.length
                                    )
                                ];
                            显示通知(
                                "没有可传送的未访问房间，随机传送。",
                                "警告"
                            );
                        } else {
                            显示通知("没有可传送的房间。", "错误");
                            return false;
                        }
                    }

                    门实例列表.forEach((门) => {
                        if (门.房间ID === 目标房间.id) {
                            地牢[门.所在位置.y][门.所在位置.x].背景类型 =
                                单元格类型.门;
                        }
                    });

                    玩家.x = 目标房间.x + Math.floor(目标房间.w / 2);
                    玩家.y = 目标房间.y + Math.floor(目标房间.h / 2);
                    已访问房间.add(目标房间.id);
                    更新视口();
                    绘制();
                    处理怪物回合();
                    显示通知(
                        `一阵风刮来，被传送到了 ${目标房间.id} 号房间`,
                        "成功"
                    );
                    当前激活卷轴列表.delete(this);

                    return true;
                }
            }

            class 真言卷轴 extends 卷轴类 {
                constructor(配置) {
                    super({
                        名称: "真言卷轴",
                        图标: 图标映射.真言卷轴,
                        品质: 4,
                        强化: 配置.强化 || false,
                        效果描述: "揭示装备中所有卷轴的奥秘，每个卷轴 30 能量",
                        能量消耗: 30,
                        已解锁: 配置.已解锁 || false,
                    });
                }

                使用() {
                    const 能量条 = document.querySelector(".power-bar");
                    let 当前能量 = Math.max(
                        Math.min(parseFloat(能量条.style.width), 100),
                        0
                    );

                    let 解密数量 = 0;
                    const 每次解密消耗 = 30;

                    // 遍历玩家装备，尝试解锁卷轴
                    Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                        玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                    )
                        .filter((v) => v != null)
                        .forEach((item) => {
                            if (
                                item instanceof 卷轴类 &&
                                !item.自定义数据.get("已解锁")
                            ) {
                                if (当前能量 >= 每次解密消耗) {
                                    当前能量 -= 每次解密消耗; // 扣除能量
                                    item.自定义数据.set("已解锁", true); // 解锁卷轴
                                    解密数量++;
                                }
                            }
                        });
                    扣除能量(
                        Math.max(
                            Math.min(parseFloat(能量条.style.width), 100),
                            0
                        ) - 当前能量
                    );
                    更新装备显示();
                    更新背包显示();
                    if (解密数量 > 0) {
                        显示通知(`解密了 ${解密数量} 个神秘卷轴`, "成功");
                    } else {
                        显示通知(`没有可解密的卷轴`, "信息");
                    }

                    当前激活卷轴列表.delete(this);

                    return 解密数量 > 0;
                }

                获取提示() {
                    return this.自定义数据.get("已解锁")
                        ? super.获取提示()
                        : "布满古老符文的卷轴，散发着神秘能量...";
                }
            }
            class 恐惧魔杖 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "恐惧魔杖",
                        图标: 图标映射.恐惧魔杖,
                        品质: 3,
                        基础攻击力: 1,
                        冷却回合: 5,
                        攻击范围: 4,
                        耐久: 配置?.耐久 || 40,
                        强化: 配置?.强化 || false,
                        效果描述: "使周围的非首领怪物陷入恐惧，远离施法者。",
                        攻击目标数: 99,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            恐惧持续时间: 3 + (配置?.强化 ? 2 : 0),
                            ...配置.数据,
                        },
                    });
                }

                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;

                    let 影响怪物数量 = 0;
                    const 范围 = this.最终攻击范围;
                    const 恐惧持续 = this.自定义数据.get("恐惧持续时间");
                    const 影响格子特效 = [];

                    for (let dx = -范围; dx <= 范围; dx++) {
                        for (let dy = -范围; dy <= 范围; dy++) {
                            const x = 玩家.x + dx;
                            const y = 玩家.y + dy;

                            if (
                                x >= 0 &&
                                x < 地牢大小 &&
                                y >= 0 &&
                                y < 地牢大小
                            ) {
                                const 单元格 = 地牢[y][x];
                                if (
                                    单元格?.关联怪物 &&
                                    单元格.关联怪物.当前生命值 > 0 &&
                                    !(单元格.关联怪物 instanceof 大魔法师) &&
                                    单元格.关联怪物.状态 === 怪物状态.活跃
                                ) {
                                    if (检查视线(玩家.x, 玩家.y, x, y, 范围)) {
                                        const 怪物 = 单元格.关联怪物;
                                        new 状态效果(
                                            "恐惧",
                                            效果颜色编号映射[
                                                效果名称编号映射.恐惧
                                            ],
                                            图标映射.恐惧,
                                            恐惧持续,
                                            null,
                                            null,
                                            怪物,
                                            1
                                        );
                                        影响怪物数量++;
                                        影响格子特效.push({ x, y });
                                    }
                                }
                            }
                        }
                    }

                    if (影响格子特效.length > 0) {
                        计划显示格子特效(
                            影响格子特效,
                            效果颜色编号映射[效果名称编号映射.恐惧].slice(1),
                            50
                        );
                    }

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set("冷却剩余", this.最终冷却回合);

                    if (影响怪物数量 > 0) {
                        显示通知(
                            `${this.名称} 使 ${影响怪物数量} 个怪物陷入恐惧！`,
                            "成功"
                        );
                    } else {
                        显示通知(`${this.名称} 未影响任何目标。`, "信息");
                    }
                    更新装备显示();
                    return 影响怪物数量 > 0 ? 1 : 0;
                }

                获取提示() {
                    let lines = super.获取提示().split("\n");
                    const specificEffectLines = [
                        `恐惧范围：周围 ${this.最终攻击范围} 格`,
                        `恐惧持续：${this.自定义数据.get("恐惧持续时间")} 回合`,
                    ];
                    const effectDescIndex = lines.findIndex((line) =>
                        line.startsWith("效果描述：")
                    );
                    let insertAtIndex =
                        effectDescIndex !== -1
                            ? effectDescIndex + 1
                            : lines.findIndex((line) =>
                                  line.startsWith("--- 强化效果 ---")
                              );
                    if (insertAtIndex === -1) insertAtIndex = lines.length;

                    lines.splice(insertAtIndex, 0, ...specificEffectLines);
                    return lines.filter(Boolean).join("\n");
                }
            }
            let 调试输入数据 = null;
            let 调试无限生命 = false;
            let 调试无限能量 = false;
                        class 调试工具 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "调试工具",
                        图标: 图标映射.调试工具,
                        品质: 5,
                        颜色索引: 4,
                        最大堆叠数量: 1,
                        效果描述: "打开调试命令输入界面。",
                        数据: {},
                        ...配置,
                    });
                }
            
                使用() {
                    this.打开调试输入界面();
                    return true;
                }
            
                打开调试输入界面() {
                    if (界面可见性.背包) 切换背包显示();
                    玩家属性.允许移动++;
            
                    const 现有遮罩 = document.getElementById("调试输入遮罩");
                    if (现有遮罩) 现有遮罩.remove();
            
                    const 遮罩 = document.createElement("div");
                    遮罩.id = "调试输入遮罩";
                    遮罩.style.cssText = `
                        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
                        background: rgba(0,0,0,0.75); z-index: 20000; display: flex;
                        align-items: center; justify-content: center; backdrop-filter: blur(5px);
                    `;
            
                    const 弹窗 = document.createElement("div");
                    弹窗.id = "调试输入弹窗";
                    弹窗.style.cssText = `
                        background: #2a2a2a; color: #e0e0e0; padding: 25px; border-radius: 12px;
                        box-shadow: 0 5px 25px rgba(0,0,0,0.6); display: flex; flex-direction: column;
                        gap: 15px; width: 90%; max-width: 600px; border: 1px solid #4caf50; max-height: 90vh; overflow-y: auto;
                    `;
            
                    const 标题 = document.createElement("h3");
                    标题.textContent = "调试工具";
                    标题.style.cssText = "color: #4caf50; text-align: center; margin: 0; padding-bottom: 15px; border-bottom: 1px solid #444;";
            
                    const 功能按钮容器 = document.createElement("div");
                    功能按钮容器.style.cssText = "display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; padding-bottom: 10px; border-bottom: 1px dashed #444;";
            
                    const 无限生命按钮 = document.createElement("button");
                    无限生命按钮.id = "debug-godmode-btn";
                    无限生命按钮.className = "菜单按钮";
                    无限生命按钮.textContent = 调试无限生命 ? "无限生命: 开" : "无限生命: 关";
                    if (调试无限生命) 无限生命按钮.style.borderColor = "#FFD700";
            
                    const 无限能量按钮 = document.createElement("button");
                    无限能量按钮.id = "debug-infenergy-btn";
                    无限能量按钮.className = "菜单按钮";
                    无限能量按钮.textContent = 调试无限能量 ? "无限能量: 开" : "无限能量: 关";
                    if (调试无限能量) 无限能量按钮.style.borderColor = "#2196F3";
                    
                    [无限生命按钮, 无限能量按钮].forEach(btn => {
                        btn.style.padding = "8px 15px";
                        btn.style.fontSize = "0.9em";
                        btn.style.minWidth = "auto";
                        btn.style.margin = "0";
                    });
            
                    功能按钮容器.appendChild(无限生命按钮);
                    功能按钮容器.appendChild(无限能量按钮);
            
                    const GUI容器 = document.createElement("div");
                    GUI容器.style.cssText = "display: flex; flex-direction: column; gap: 15px;";
            
                    const 创建选择器区域 = (标签文本, selectId, propEditorId, ...buttons) => {
                        const 区域 = document.createElement("div");
                        区域.style.cssText = "display: flex; flex-direction: column; gap: 10px;";
            
                        const 顶行 = document.createElement("div");
                        顶行.style.cssText = "display: flex; align-items: center; gap: 10px;";
            
                        const 标签 = document.createElement("label");
                        标签.textContent = 标签文本;
                        标签.style.flexShrink = "0";
            
                        const 选择框 = document.createElement("select");
                        选择框.id = selectId;
                        选择框.style.cssText = `
                            flex-grow: 1; background: #1e1e1e; color: #e0e0e0; 
                            border: 1px solid #444; border-radius: 5px; padding: 8px;
                        `;
            
                        顶行.appendChild(标签);
                        顶行.appendChild(选择框);
                        区域.appendChild(顶行);
                        
                        const 属性编辑器容器 = document.createElement("div");
                        属性编辑器容器.id = propEditorId;
                        属性编辑器容器.style.cssText = `
                            display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;
                            background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-top: -5px;
                        `;
                        区域.appendChild(属性编辑器容器);

                        const 按钮行 = document.createElement("div");
                        按钮行.style.cssText = "display: flex; gap: 10px; flex-wrap: wrap; justify-content: flex-start;";
            
                        buttons.forEach(btnConfig => {
                            const 按钮 = document.createElement("button");
                            按钮.id = btnConfig.id;
                            按钮.textContent = btnConfig.text;
                            按钮.className = "菜单按钮";
                            按钮.style.cssText = "padding: 8px 15px; font-size: 0.9em; min-width: auto; margin: 0;";
                            按钮行.appendChild(按钮);
                        });
                        区域.appendChild(按钮行);
                        return 区域;
                    };
            
                    const 物品选择区 = 创建选择器区域("物品:", "debug-item-select", "debug-item-prop-editor",
                        {id: "debug-give-item-btn", text: "给予"},
                        {id: "debug-spawn-item-btn", text: "在脚下生成"}
                    );
                    const 怪物选择区 = 创建选择器区域("怪物:", "debug-monster-select", "debug-monster-prop-editor",
                        {id: "debug-spawn-monster-btn", text: "在脚下生成"}
                    );
            
                    GUI容器.appendChild(物品选择区);
                    GUI容器.appendChild(怪物选择区);
            
                    const 分隔符 = document.createElement("div");
                    分隔符.textContent = "手动输入命令";
                    分隔符.style.cssText = "text-align: center; color: #888; margin: -5px 0;";
            
                    const 命令容器 = document.createElement("div");
                    命令容器.style.cssText = "display: flex; align-items: stretch; gap: 10px;";
            
                    const 命令输入框 = document.createElement("textarea");
                    命令输入框.id = "调试命令输入框";
                    命令输入框.placeholder = '放置物品:{"类名":"钢制长剑"}';
                    命令输入框.style.cssText = `
                        flex-grow: 1; min-height: 60px; background: #1e1e1e; color: #e0e0e0;
                        border: 1px solid #444; border-radius: 5px; padding: 10px; font-family: monospace;
                        resize: vertical;
                    `;
            
                    const 执行命令按钮 = document.createElement("button");
                    执行命令按钮.textContent = "执行";
                    执行命令按钮.className = "菜单按钮";
                    执行命令按钮.style.flexShrink = "0";

                    命令容器.appendChild(命令输入框);
                    命令容器.appendChild(执行命令按钮);
                    
                    const 关闭按钮 = document.createElement("button");
                    关闭按钮.textContent = "关闭";
                    关闭按钮.className = "菜单按钮";
                    关闭按钮.style.cssText = `
                        background: linear-gradient(145deg, rgba(180, 0, 0, 0.7), rgba(150, 0, 0, 0.5));
                        width: 50%; margin: 10px auto 0 auto;
                    `;

                    弹窗.appendChild(标题);
                    弹窗.appendChild(功能按钮容器);
                    弹窗.appendChild(GUI容器);
                    弹窗.appendChild(分隔符);
                    弹窗.appendChild(命令容器);
                    弹窗.appendChild(关闭按钮);
            
                    遮罩.appendChild(弹窗);
                    document.body.appendChild(遮罩);
                    
                    const { items: allItems, monsters: allMonsters } = 获取所有可用的定义();

                    const 填充选择框 = (selectId, definitions, isMonster = false) => {
                        const 选择框 = document.getElementById(selectId);
                        const 选项 = [];
                        definitions.forEach(cfg => {
                            try {
                                const 实例 = new cfg.类({});
                                const text = isMonster ? 实例.类型 : 实例.名称;
                                if (实例 && text) { 
                                    选项.push({ text: text, value: cfg.类.name });
                                }
                            } catch (e) {}
                        });
                        
                        [...new Map(选项.map(item => [item.value, item])).values()]
                            .sort((a,b) => a.text.localeCompare(b.text, 'zh-Hans-CN'))
                            .forEach(opt => {
                                const optionElement = document.createElement("option");
                                optionElement.value = opt.value;
                                optionElement.textContent = opt.text;
                                选择框.appendChild(optionElement);
                            });
                    };
            
                    填充选择框("debug-item-select", allItems, false);
                    填充选择框("debug-monster-select", allMonsters, true);
            
                    const 创建字段 = (key, value, type = 'text') => {
                        const fieldWrapper = document.createElement('div');
                        fieldWrapper.style.cssText = `display: flex; align-items: center; gap: 5px; justify-content: space-between;`;
                        
                        const label = document.createElement('label');
                        label.textContent = key;
                        label.style.cssText = 'font-size: 0.8em; color: #aaa; flex-shrink: 0;';
                        
                        let input;
                        if (type === 'checkbox') {
                            input = document.createElement('input');
                            input.type = 'checkbox';
                            input.checked = !!value;
                            input.style.cssText = 'margin: 0; transform: scale(0.9);';
                        } else {
                            input = document.createElement('input');
                            input.type = type;
                            input.value = value;
                            input.style.cssText = 'background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 5px; width: 60%;';
                        }
                        input.id = `debug-prop-${key}`;
                        
                        fieldWrapper.appendChild(label);
                        fieldWrapper.appendChild(input);
                        return fieldWrapper;
                    };

                    const 生成属性编辑器 = (itemClass, editorContainerId) => {
                        const editorContainer = document.getElementById(editorContainerId);
                        editorContainer.innerHTML = '';
                        if (!itemClass) return;
            
                        const tempInstance = new itemClass({});
                        editorContainer.appendChild(创建字段('强化', tempInstance.强化, 'checkbox'));

                        if (tempInstance instanceof 物品 && !(tempInstance instanceof 怪物)) {
                            editorContainer.appendChild(创建字段('品质', tempInstance.品质, 'number'));
                        }
                        if (tempInstance instanceof 武器类 || tempInstance instanceof 防御装备类) {
                            editorContainer.appendChild(创建字段('耐久', tempInstance.自定义数据.get('耐久'), 'number'));
                            editorContainer.appendChild(创建字段('不可破坏', tempInstance.自定义数据.get('不可破坏'), 'checkbox'));
                        }
                        if (tempInstance instanceof 武器类) {
                           editorContainer.appendChild(创建字段('基础攻击力', tempInstance.自定义数据.get('基础攻击力'), 'number'));
                           editorContainer.appendChild(创建字段('冷却回合', tempInstance.自定义数据.get('冷却回合'), 'number'));
                        }
                         if (tempInstance instanceof 防御装备类) {
                           editorContainer.appendChild(创建字段('防御力', tempInstance.自定义数据.get('防御力'), 'number'));
                        }
                        if (tempInstance instanceof 药水类) {
                            editorContainer.appendChild(创建字段('效果强度', tempInstance.自定义数据.get('效果强度'), 'number'));
                            editorContainer.appendChild(创建字段('基础持续时间', tempInstance.自定义数据.get('基础持续时间'), 'number'));
                        }
                         if (tempInstance instanceof 卷轴类) {
                           editorContainer.appendChild(创建字段('已解锁', tempInstance.自定义数据.get('已解锁'), 'checkbox'));
                        }
                        if (tempInstance instanceof 怪物) {
                            editorContainer.appendChild(创建字段('基础生命值', tempInstance.基础生命值, 'number'));
                            editorContainer.appendChild(创建字段('基础攻击力', tempInstance.基础攻击力, 'number'));
                        }
                    };
            
                    const itemSelect = document.getElementById('debug-item-select');
                    itemSelect.onchange = () => {
                        const className = itemSelect.value;
                        const ItemClass = window[className];
                        生成属性编辑器(ItemClass, 'debug-item-prop-editor');
                    };
                    生成属性编辑器(window[itemSelect.value], 'debug-item-prop-editor'); 

                    const monsterSelect = document.getElementById('debug-monster-select');
                    monsterSelect.onchange = () => {
                        const className = monsterSelect.value;
                        const MonsterClass = window[className];
                        生成属性编辑器(MonsterClass, 'debug-monster-prop-editor');
                    };
                    生成属性编辑器(window[monsterSelect.value], 'debug-monster-prop-editor');
                    
                    const 获取编辑器配置 = (editorId) => {
                        const config = {};
                        const dataConfig = {};
                        const propInputs = document.querySelectorAll(`#${editorId} input`);
                        propInputs.forEach(input => {
                            const key = input.id.replace('debug-prop-', '');
                            const value = input.type === 'checkbox' ? input.checked : (isNaN(parseFloat(input.value)) ? input.value : parseFloat(input.value));
            
                            const dataKeys = ['耐久', '基础攻击力', '防御力', '冷却回合', '效果强度', '基础持续时间', '不可破坏', '已解锁', '基础生命值'];
                            if (dataKeys.includes(key)) {
                                dataConfig[key] = value;
                            } else {
                                config[key] = value;
                            }
                        });
                        if (Object.keys(dataConfig).length > 0) {
                            config.数据 = dataConfig;
                        }
                        return config;
                    };
            
                    const 关闭调试界面 = () => {
                        遮罩.remove();
                        玩家属性.允许移动--;
                        玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
                    };
                    
                    无限生命按钮.onclick = () => {
                        调试无限生命 = !调试无限生命;
                        无限生命按钮.textContent = 调试无限生命 ? "无限生命: 开" : "无限生命: 关";
                        无限生命按钮.style.borderColor = 调试无限生命 ? "#FFD700" : "";
                        if(调试无限生命) document.querySelector(".health-bar").style.width = "100%";
                    };
            
                    无限能量按钮.onclick = () => {
                        调试无限能量 = !调试无限能量;
                        无限能量按钮.textContent = 调试无限能量 ? "无限能量: 开" : "无限能量: 关";
                        无限能量按钮.style.borderColor = 调试无限能量 ? "#2196F3" : "";
                         if(调试无限能量) document.querySelector(".power-bar").style.width = "100%";
                    };
            
                    document.getElementById("debug-give-item-btn").onclick = () => {
                        const 类名 = document.getElementById("debug-item-select").value;
                        const 属性 = 获取编辑器配置('debug-item-prop-editor');
                        const 命令 = `给予物品:{"类名":"${类名}", "属性": ${JSON.stringify(属性)}}`;
                        命令输入框.value = 命令;
                        this.解析并执行命令(命令);
                    };
            
                    document.getElementById("debug-spawn-item-btn").onclick = () => {
                        const 类名 = document.getElementById("debug-item-select").value;
                        const 属性 = 获取编辑器配置('debug-item-prop-editor');
                        const 命令 = `放置物品:{"类名":"${类名}", "属性": ${JSON.stringify(属性)}}`;
                        命令输入框.value = 命令;
                        this.解析并执行命令(命令);
                    };
            
                    document.getElementById("debug-spawn-monster-btn").onclick = () => {
                        const 类名 = document.getElementById("debug-monster-select").value;
                        const 属性 = 获取编辑器配置('debug-monster-prop-editor');
                        const 命令 = `放置怪物:{"类名":"${类名}", "属性": ${JSON.stringify(属性)}}`;
                        命令输入框.value = 命令;
                        this.解析并执行命令(命令);
                    };
            
                    执行命令按钮.onclick = () => {
                        const 命令文本 = 命令输入框.value.trim();
                        if (命令文本) {
                            this.解析并执行命令(命令文本);
                        }
                    };
            
                    关闭按钮.onclick = 关闭调试界面;
            
                    命令输入框.focus();
                }

                解析并执行命令(命令文本) {
                    const [命令类型, ...参数部分] = 命令文本.split(":");
                    const 参数字符串 = 参数部分.join(":").trim();
            
                    try {
                        const 配置JSON = JSON.parse(参数字符串);
                        const 类名 = 配置JSON.类名;
                        const 属性 = 配置JSON.属性 || {};
                        const 类构造器 = window[类名];
            
                        if (!类构造器 || typeof 类构造器 !== 'function') {
                            显示通知(`未知的类名: ${类名}`, "错误");
                            return;
                        }
            
                        const 新实例 = new 类构造器({});
            
                        if (!新实例.自定义数据) {
                            新实例.自定义数据 = new Map();
                        }
            
                        for (const [键, 值] of Object.entries(属性)) {
                            if (键 === '数据' && typeof 值 === 'object' && 值 !== null) {
                                for (const [数据键, 数据值] of Object.entries(值)) {
                                    新实例.自定义数据.set(数据键, 数据值);
                                    if(数据键 === '基础生命值' && 新实例 instanceof 怪物) 新实例.当前生命值 = 数据值;
                                }
                            } else {
                                新实例[键] = 值;
                                if(键 === '基础生命值' && 新实例 instanceof 怪物) 新实例.当前生命值 = 值;
                            }
                        }
            
                        switch (命令类型.trim().toLowerCase()) {
                            case "给予物品":
                                if (尝试收集物品(新实例, true)) {
                                    显示通知(`已给予 ${新实例.获取名称()}`, "成功");
                                }
                                break;
                            case "放置物品":
                                if (放置物品到单元格(新实例, 玩家.x, 玩家.y)) {
                                    显示通知(`成功放置 ${新实例.获取名称()}`, "成功");
                                } else {
                                    显示通知(`无法在当前位置放置 ${类名}`, "错误");
                                }
                                break;
                            case "放置怪物":
                                新实例.状态 = 怪物状态.活跃;
                                if (放置怪物到单元格(新实例, 玩家.x, 玩家.y)) {
                                    显示通知(`成功放置 ${新实例.类型}`, "成功");
                                } else {
                                    显示通知(`无法在当前位置放置 ${类名}`, "错误");
                                }
                                break;
                            case "切换楼层":
                                const 目标层数 = parseInt(参数字符串);
                                if (!isNaN(目标层数)) {
                                    切换楼层(目标层数);
                                    显示通知(`已切换到楼层 ${目标层数}`, "成功");
                                } else {
                                    显示通知("无效的楼层号", "错误");
                                }
                                break;
                            default:
                                显示通知("未知的调试命令", "错误");
                        }
                    } catch (错误) {
                        console.error("调试命令解析或执行错误:", 错误);
                        显示通知(`命令错误: ${错误.message}`, "错误");
                    }
                }
            
                获取提示() {
                    return `${this.获取名称()}\n类型：${
                        this.类型
                    }\n品质：${"★".repeat(this.品质)}\n效果：${this.效果描述}`;
                }
            }
            class 陷阱基类 extends 物品 {
                constructor(配置 = {}) {
                    // 先准备好数据
                    const 基础数据 = {
                        已触发: false,
                        冷却回合: 3 + Math.floor(Math.random() * 2),
                        冷却剩余: 0,
                        ...配置.数据,
                    };

                    super({
                        类型: "陷阱",
                        能否拾起: true,
                        是否正常物品: false,
                        阻碍怪物: false,
                        // 核心修改：在父类构造时就根据数据决定图标
                        是否为隐藏物品: true,
                        颜色索引:4,
                        图标: 基础数据.已触发 ? (配置.激活后图标 || "V") : " ",
                        ...配置,
                        数据: 基础数据,
                    });
                    
                    // 将激活后的图标也存入自定义数据，以便后续使用
                    this.自定义数据.set('激活后图标', 配置.激活后图标 || "V");

                    if(!所有计时器.some(t => t.唯一标识 === this.唯一标识)) {
                        所有计时器.push(this);
                    }
                }

                当被收集(进入者) {
                    if (进入者 !== "玩家" || this.自定义数据.get("冷却剩余") > 0) return false;

                    const 首次触发 = !this.自定义数据.get("已触发");
                    if (首次触发) {
                        this.自定义数据.set("已触发", true);
                        this.是否为隐藏物品 = false;
                        this.图标 = this.自定义数据.get('激活后图标'); // 从数据中读取激活后的图标
                        显示通知("你触发了一个陷阱！", "警告");
                    }
                    
                    this.触发效果(进入者);
                    
                    this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));
                    计划显示格子特效([{ x: this.x, y: this.y }], "FF0000");
                    绘制();

                    return false; 
                }
                
                更新倒计时() {
                    let 冷却 = this.自定义数据.get("冷却剩余");
                    if (冷却 > 0) {
                        this.自定义数据.set("冷却剩余", 冷却 - 1);
                    }
                }
                
                触发效果(触发者) {
                }

                使用() { return false; }
            }
            
            class 隐形落石陷阱 extends 陷阱基类 {
                constructor(配置 = {}) {
                    super({
                        名称: "落石陷阱",
                        激活后图标: 图标映射.落石,
                        原图标: 图标映射.落石,
                        品质: 2,
                        效果描述: "从上方落下巨石造成伤害。",
                        数据: {
                            伤害: 15 + (配置.强化 ? 10 : 0),
                        },
                        ...配置,
                    });
                }
                触发效果(触发者) {
                    伤害玩家(this.自定义数据.get("伤害"), this.名称);
                }
            }

            class 隐形地刺陷阱 extends 陷阱基类 {
                constructor(配置 = {}) {
                    super({
                        名称: "地刺陷阱",
                        激活后图标: 图标映射.地刺,
                        原图标: 图标映射.地刺,
                        品质: 2,
                        效果描述: "锋利的地刺从地面穿出，造成伤害并使你减速。",
                         数据: {
                            伤害: 10 + (配置.强化 ? 5 : 0),
                            减速回合: 3 + (配置.强化 ? 2 : 0),
                        },
                        ...配置,
                    });
                }
                触发效果(触发者) {
                    伤害玩家(this.自定义数据.get("伤害"), this.名称);
                    new 状态效果("缓慢", 效果颜色编号映射[效果名称编号映射.缓慢], "慢", this.自定义数据.get("减速回合"));
                }
            }
            
            class 隐形毒气陷阱 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "陷阱",
                        名称: "隐形毒气陷阱",
                        图标: " ",
                        品质: 2,
                        能否拾起: true,
                        是否正常物品: false,
                        阻碍怪物: false,
                        是否为隐藏物品: true, 
                        效果描述: "一个被巧妙的毒气陷阱。",
                        数据: {
                            关联陷阱ID: 配置.关联陷阱ID || null,
                            中毒强度: 2 + (配置.强化 ? 1 : 0),
                            中毒持续: 5,
                            毒气持续: 8 + (配置.强化 ? 4 : 0),
                            强化: 配置.强化 || false,
                        },
                        
                    });
                }

                当被收集(进入者) {
                    if (进入者 !== "玩家") return false;
                    
                    this.自定义数据.set('已触发', true);

                    const 强度 = this.自定义数据.get('中毒强度');
                    const 持续 = this.自定义数据.get('中毒持续');
                    new 状态效果("中毒", 效果颜色编号映射[效果名称编号映射.中毒], "☠️", 持续, null, null, null, 强度);
                    添加日志("你踩中了隐藏的毒气陷阱！", "错误");
                    
                    const 陷阱ID = this.自定义数据.get('关联陷阱ID');
                    if (陷阱ID) {
                        揭示并激活陷阱群(陷阱ID, this.自定义数据.get('毒气持续'), this.自定义数据.get('强化'));
                    }

                    return false;
                }

                使用() { return false; }
            }

            class 隐形失明陷阱 extends 陷阱基类 {
                constructor(配置 = {}) {
                    super({
                        名称: "失明陷阱",
                        激活后图标: 图标映射.失明,
                        原图标: 图标映射.失明,
                        品质: 3,
                        效果描述: "触发后会暂时剥夺你的视野。",
                         数据: {
                            失明持续: 15 + (配置.强化 ? 10 : 0),
                        },
                        ...配置,
                    });
                }
                触发效果(触发者) {
                    new 状态效果("失明", "#333333", "👁️‍🗨️", this.自定义数据.get("失明持续"));
                }
            }

            class 召唤怪物陷阱 extends 陷阱基类 {
                constructor(配置 = {}) {
                    super({
                        名称: "召唤陷阱",
                        激活后图标: 图标映射.召唤陷阱,
                        原图标: 图标映射.召唤陷阱,
                        品质: 3,
                        效果描述: "一个不稳定的魔法阵，会召唤出地牢生物。",
                        数据: {
                           召唤数量: 3 + (配置.强化 ? 3 : 0),
                        },
                        ...配置,
                    });
                }
                触发效果(触发者) {
                    let 已召唤数量 = 0;
                     for (let i = 0; i < this.自定义数据.get('召唤数量'); i++) {
                        
                        if (房间地图[this.y][this.x] && 房间地图[this.y][this.x] !== -1) {
                            const 候选怪物 = 怪物池["普通房间"].filter(m => 当前层数 >= m.最小层 && m.类.name !== "大魔法师");
                            if(候选怪物.length > 0) {
                               const 选中配置 = 候选怪物[Math.floor(Math.random() * 候选怪物.length)];
                               const 新怪物 = new 选中配置.类({强化: Math.random() < 0.2 + 当前层数 * 0.03, 状态: 怪物状态.活跃});
                               if(放置怪物到房间(新怪物, 房间列表[房间地图[this.y][this.x]])) {
                                   已召唤数量++;
                               }
                            }
                        }
                    }
                     if (已召唤数量 > 0) {
                        显示通知(`陷阱召唤了 ${已召唤数量} 只怪物！`, "警告");
                    }
                }
            }
            
            class 烈焰触发陷阱 extends 陷阱基类 {
                constructor(配置 = {}) {
                    super({
                        名称: "烈焰陷阱",
                        激活后图标: 图标映射.烈焰陷阱,
                        原图标: 图标映射.烈焰陷阱,
                        品质: 4,
                        效果描述: "一个高温的符文，触发后会引燃整个房间。",
                         数据: {
                            引燃比例: 0.6 + (配置.强化 ? 0.2 : 0),
                        },
                        ...配置,
                    });
                }
                触发效果(触发者) {
                    const 房间ID = 房间地图[this.y]?.[this.x];
                    if (房间ID === -1) return;
                    const 房间 = 房间列表[房间ID];
                    const 地板格子 = [];
                    for(let y = 房间.y; y < 房间.y + 房间.h; y++){
                        for(let x = 房间.x; x < 房间.x + 房间.w; x++){
                            if(位置是否可用(x, y, false)) {
                                地板格子.push({x, y});
                            }
                        }
                    }
                    
                    const 燃烧数量 = Math.floor(地板格子.length * this.自定义数据.get('引燃比例'));
                    地板格子.sort(() => Math.random() - 0.5);
                    
                    for(let i=0; i < Math.min(燃烧数量, 地板格子.length); i++){
                        const {x, y} = 地板格子[i];
                        const 火焰 = new 火焰物品({强化: this.自定义数据.get('强化'),倒计时:9999});
                        放置物品到单元格(火焰, x, y);
                    }
                    显示通知("整个房间燃起了熊熊大火！", "错误");
                }
            }
            
            class 隐形虫洞陷阱 extends 陷阱基类 {
                constructor(配置 = {}) {
                    super({
                        名称: "虫洞陷阱",
                        激活后图标: 图标映射.虫洞,
                        原图标: 图标映射.虫洞,
                        品质: 4,
                        效果描述: "不稳定的空间裂隙，会将你传送到一个固定的未知时空。",
                        ...配置,
                    });
                }
                
                触发效果(触发者) {
                    // 检查陷阱是否已经决定了传送目标
                    if (!this.自定义数据.has('目标层数')) {
                        // 第一次触发：决定目标楼层并保存
                        let 可选层数 = [当前层数 + 1]; 
                        for (let i = 0; i < 当前层数; i++) {
                            if (所有地牢层.has(i)) {
                                可选层数.push(i);
                            }
                        }
                        const 目标层 = 可选层数[Math.floor(Math.random() * 可选层数.length)];
                        this.自定义数据.set('目标层数', 目标层);
                        // 此时不决定坐标，坐标将在楼层切换后决定
                    }

                    const 目标层数 = this.自定义数据.get('目标层数');
                    let 目标坐标 = this.自定义数据.get('目标坐标'); // 可能是 null 或已保存的坐标

                    if (目标层数 === undefined) {
                        显示通知("虫洞的目标不稳定，传送失败！", "错误");
                        this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));
                        return;
                    }

                    显示通知(`你被吸入了不稳定的虫洞！即将前往第 ${目标层数} 层...`, "警告", true);
                    
                    const 传送回调 = () => {
                        let 最终目标坐标 = this.自定义数据.get('目标坐标');
                        if (!最终目标坐标) {
                            // 如果坐标未定（说明是第一次传送到新层）
                            最终目标坐标 = this.寻找随机合法坐标(目标层数);
                            this.自定义数据.set('目标坐标', 最终目标坐标);
                        }
                        // 手动修改玩家坐标
                        玩家.x = 最终目标坐标.x;
                        玩家.y = 最终目标坐标.y;

                        // 更新视觉和逻辑
                        更新视口();
                        绘制();
                        处理玩家着陆效果(玩家.x, 玩家.y, 玩家.x, 玩家.y);
                    };
                    
                    setTimeout(() => {
                        切换楼层(目标层数, false, null, false, 传送回调);
                    }, 500);
                }

                寻找随机合法坐标(目标层数) {
                    
                    const 可用房间 = 房间列表.filter(r => r.类型 === '房间');
                    
                    if (可用房间.length > 0) {
                        for (let 尝试 = 0; 尝试 < 50; 尝试++) {
                            const 随机房间 = 可用房间[Math.floor(Math.random() * 可用房间.length)];
                            if(!随机房间 || 上锁房间列表.some(r => r.id === 随机房间?.id)) continue;
                            const x = 随机房间.x + Math.floor(Math.random() * 随机房间.w);
                            const y = 随机房间.y + Math.floor(Math.random() * 随机房间.h);
                            if (地牢[y]?.[x] && [单元格类型.房间, 单元格类型.走廊].includes(地牢[y][x].背景类型)) {
                                return { x, y };
                            }
                        }
                    }

                    for (let 尝试 = 0; 尝试 < 200; 尝试++) {
                        const x = Math.floor(Math.random() * 地牢大小);
                        const y = Math.floor(Math.random() * 地牢大小);
                        if (地牢[y]?.[x] && [单元格类型.房间, 单元格类型.走廊].includes(地牢[y][x].背景类型)) {
                            return {x, y};
                        }
                    }
                    
                    return { x: 玩家初始位置.x, y: 玩家初始位置.y };
                }

                获取提示() {
                    let baseTip = super.获取提示();
                    if (this.自定义数据.get("已触发")) {
                         if (this.自定义数据.has('目标层数')) {
                            const targetFloor = this.自定义数据.get('目标层数');
                            baseTip += `\n它似乎连接着第 ${targetFloor} 层。`;
                        } else {
                            baseTip += `\n一个未知的空间连接。`;
                        }
                    }
                    return baseTip;
                }
            }
            
            class 远射陷阱 extends 怪物 {
                 constructor(配置 = {}) {
                    if (Math.random()<0.15) 配置.强化 = true;
                    super({
                        图标: 图标映射.远射陷阱,
                        类型: "远射陷阱",
                        基础生命值: 80 + (配置.强化 ? 40 : 0),
                        基础攻击力: 6 + (配置.强化 ? 3 : 0),
                        移动率: 0, 
                        掉落概率: 0,
                        基础攻击范围: 8,
                        跟踪距离: 12,
                        攻击冷却: 3 - (配置.强化 ? 1 : 0),
                        ...配置,
                    });
                    this.状态 = 怪物状态.活跃; 
                }
                
                尝试移动() { return; }

                            
                尝试攻击() {
                    if (this.攻击冷却回合剩余 > 0) {
                        this.攻击冷却回合剩余--;
                        return false;
                    }
                    if(检查视线(this.x, this.y, 玩家.x, 玩家.y, this.攻击范围)) {
                        const 路径 = 获取直线路径(this.x, this.y, 玩家.x, 玩家.y);
                        if(路径 && 路径.length > 1) {
                            计划显示格子特效(路径.slice(1), "FF8C00");
                            伤害玩家(this.攻击力, this.类型);
                            this.攻击冷却回合剩余 = this.攻击冷却;

                            
                            const 击退距离 = 1 + (this.强化 ? 1 : 0);
                            const dx = 玩家.x - this.x;
                            const dy = 玩家.y - this.y;
                            let 方向DX = 0, 方向DY = 0;
                            
                            if(Math.abs(dx) > Math.abs(dy)){
                                方向DX = Math.sign(dx);
                            } else {
                                方向DY = Math.sign(dy);
                            }

                            if (方向DX !== 0 || 方向DY !== 0) {
                                let 最终X = 玩家.x;
                                let 最终Y = 玩家.y;

                                for(let i=1; i <= 击退距离; i++) {
                                    const 尝试X = 玩家.x + 方向DX * i;
                                    const 尝试Y = 玩家.y + 方向DY * i;
                                    if(检查移动可行性(最终X, 最终Y, 尝试X, 尝试Y, true)) {
                                        最终X = 尝试X;
                                        最终Y = 尝试Y;
                                    } else {
                                        break;
                                    }
                                }

                                if(最终X !== 玩家.x || 最终Y !== 玩家.y) {
                                    const 旧玩家X = 玩家.x;
                                    const 旧玩家Y = 玩家.y;
                                    玩家.x = 最终X;
                                    玩家.y = 最终Y;
                                    处理玩家着陆效果(旧玩家X, 旧玩家Y, 玩家.x, 玩家.y);
                                    
                                    添加日志(`你被 ${this.类型} 击退了！`, "警告");
                                    绘制();
                                }
                            }
                            

                            return true;
                        }
                    }
                    return false;
                }
            }
            
            class 障碍物物品 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "便携障碍物",
                        图标: 图标映射.障碍物,
                        品质: 1,
                        颜色索引: 4,
                        堆叠数量: 配置.数量 || Math.ceil(Math.random()*10),
                        效果描述: "点击使用后，在地图上点击一次以放置。只能在障碍物本格回收。",
                        ...配置,
                    });
                }
                
                使用() {
                     if (玩家正在放置障碍物) {
                        玩家正在放置障碍物 = false;
                        显示通知("已取消放置障碍物。", "信息");
                        return false;
                    }
                    玩家正在放置障碍物 = true;
                    显示通知("请在地图上选择一个位置放置障碍物。", "信息", true);
                    return true;
                }
            }
            
            class 已放置的障碍物 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: "障碍物",
                        图标: 图标映射.障碍物,
                        品质: 1,
                        颜色索引: 4,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: true,
                        效果描述: "一个坚固的障碍物。",
                        ...配置,
                    });
                }

                尝试互动() {
                    if (玩家.x !== this.x || 玩家.y !== this.y) return false;
                    
                    if (尝试收集物品(new 障碍物物品({数量: 1}), true)) {
                        if (地牢[this.y]?.[this.x]?.关联物品 === this) {
                            地牢[this.y][this.x].关联物品 = null;
                            if (地牢[this.y][this.x].类型 === 单元格类型.物品) {
                               地牢[this.y][this.x].类型 = null;
                            }
                        }
                        显示通知("成功回收了障碍物！", "成功");
                        绘制();
                        return true;
                    } else {
                        显示通知("背包已满，无法回收！", "错误");
                        return false;
                    }
                }
            }
            class 洗身砚 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: "洗身砚",
                        图标: 图标映射.洗身砚,
                        品质: 4,
                        颜色索引: 1,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: true,
                        效果描述: "一座古朴的石砚，似乎能洗净尘世间的因果。",
                        数据: {
                            已使用: false,
                        },
                        ...配置,
                    });
                }

                尝试互动() {
                    if (this.自定义数据.get("已使用")) {
                        显示通知("石砚中的清水已经浑浊，失去了力量。", "信息");
                        return false;
                    }

                    显示自定义确认对话框(
                        "你确定要用这方石砚洗涤自身吗？<br>这会移除所有神龛带来的永久效果（无论好坏）以及当前所有的药水效果。",
                        () => this.使用()
                    );

                    return true;
                }

                使用() {
                    if (this.自定义数据.get("已使用")) return false;

                    this.自定义数据.set("已使用", true);

                    永久Buffs = { 已获得效果: new Set() };
                    应用永久Buffs();

                    [...玩家状态].forEach(状态 => 状态.移除状态());

                    this.效果描述 = "石砚中的清水已经浑浊，失去了力量。";
                    
                    this.颜色索引 = 颜色表.length; 

                    显示通知("一阵清明流过全身，你感到所有的祝福与诅咒都已离你而去。", "成功", true);
                    绘制();
                    return true;
                }

                获取提示() {
                    return `${this.获取名称()}\n品质：${"★".repeat(this.品质)}\n${this.效果描述}`;
                }
            }
            
            class 毒气 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: "毒气",
                        图标: 图标映射.毒气,
                        品质: 1,
                        颜色索引: 效果名称编号映射.中毒,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: false,
                        效果描述: "一片弥漫的毒气，接触的生物会中毒。",
                        数据: {
                            倒计时: 配置.倒计时 || (8 + (配置.强化 ? 4 : 0)),
                            爆炸时间: 配置.爆炸时间 || (8 + (配置.强化 ? 4 : 0)),
                            中毒强度: 2 + (配置.强化 ? 1 : 0),
                            中毒持续: 5,
                        },
                        ...配置,
                    });
                }

                当被收集(进入者) {
                    if (进入者 instanceof 怪物 && !(进入者 instanceof 幽灵怪物)) {
                        new 状态效果("中毒", this.获取毒气颜色(), "☠️", this.自定义数据.get("中毒持续"), null, null, 进入者, this.自定义数据.get("中毒强度"));
                        添加日志(`${进入者.类型} 进入了毒气！`, "警告");
                    }
                    return false; 
                }

                更新倒计时() {
                    const 剩余回合 = this.自定义数据.get("倒计时") - 1;
                    this.自定义数据.set("倒计时", 剩余回合);
                    if (剩余回合 <= 0) {
                        this.移除自身();
                    }
                }

                移除自身() {
                    if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
                        地牢[this.y][this.x].关联物品 = null;
                        if (地牢[this.y][this.x].类型 === 单元格类型.物品) {
                            地牢[this.y][this.x].类型 = null;
                        }
                    }
                    所有计时器 = 所有计时器.filter(item => item !== this);
                    绘制();
                }
                
                获取毒气颜色() {
                    return 效果颜色编号映射[this.颜色索引] || "#008000";
                }

                get 颜色表() {
                    return 效果颜色编号映射;
                }
            }

            class 毒气瓶 extends 物品 {
                 constructor(配置 = {}) {
                    super({
                        类型: "消耗品",
                        名称: "毒气瓶",
                        图标: 图标映射.毒气瓶,
                        品质: 2,
                        颜色索引: 效果名称编号映射.中毒,
                        堆叠数量: 配置.数量 || 1,
                        最大堆叠数量: 8,
                        效果描述: "在玩家周围3x3区域释放一片毒气云。",
                        强化: 配置.强化 || false,
                        ...配置,
                    });
                }

                使用() {
                    if (this.堆叠数量 <= 0) return false;

                    let 放置成功计数 = 0;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const 目标X = 玩家.x + dx;
                            const 目标Y = 玩家.y + dy;

                            if (位置是否可用(目标X, 目标Y, false)) {
                                const 毒气实例 = new 毒气({ 强化: this.强化 });
                                if (放置物品到单元格(毒气实例, 目标X, 目标Y)) {
                                     所有计时器.push(毒气实例);
                                     放置成功计数++;
                                }
                            }
                        }
                    }

                    if (放置成功计数 > 0) {
                        this.堆叠数量--;
                        if (this.堆叠数量 <= 0) {
                            处理销毁物品(this.唯一标识, true);
                        }
                        显示通知(`释放了毒气云！`, "成功");
                        更新背包显示();
                        更新装备显示();
                        绘制();
                        return true;
                    } else {
                        显示通知("周围没有空间释放毒气！", "错误");
                        return false;
                    }
                }
                get 颜色表() {
                    return 效果颜色编号映射;
                }
            }
            
            class 万能钥匙 extends 钥匙 {
                constructor(配置 = {}) {
                    super({
                        ...配置,
                        名称: "万能钥匙",
                        图标: 图标映射.万能钥匙,
                        品质: 3,
                        颜色索引: 2,
                        效果描述: "这把钥匙似乎能打开任何锁。",
                        地牢层数: -1,
                        对应门ID: -1,
                    });
                }
                
                可交互目标(门实例) {
                    if (门实例.类型 === "上锁的门") {
                        return true;
                    }
                    return false;
                }
                
                获取名称() {
                    return `万能钥匙`;
                }
            }

            class 陨石法杖 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "陨石法杖",
                        图标: 图标映射.陨石法杖,
                        品质: 4,
                        基础攻击力: 15 + (配置.强化 ? 10 : 0),
                        冷却回合: 14 - (配置.强化 ? 2 : 0),
                        攻击范围: 4,
                        耐久: 配置?.耐久 || 40,
                        强化: 配置?.强化 || false,
                        效果描述: "召唤数颗小型陨石轰击附近的敌人。",
                        数据: {
                            陨石数量: 3 + (配置.强化 ? 2 : 0),
                            爆炸范围: 2,
                        },
                        ...配置,
                    });
                }

                            // 位于 陨石法杖 class 中
                使用() {
                    if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return false;

                    const 范围 = this.最终攻击范围;
                    const 陨石数量 = this.自定义数据.get("陨石数量");
                    const 爆炸范围 = this.自定义数据.get("爆炸范围");
                    
                    const 候选怪物列表 = [];
                    const 怪物位置集合 = new Set();
                    
                    for (let y = 玩家.y - 范围; y <= 玩家.y + 范围; y++) {
                        for (let x = 玩家.x - 范围; x <= 玩家.x + 范围; x++) {
                            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) continue;
                            const 距离 = Math.abs(x-玩家.x) + Math.abs(y-玩家.y);
                            if (距离 > 范围) continue;
                            
                            const 单元格 = 地牢[y]?.[x];
                            if (单元格 && 单元格.关联怪物 && 单元格.关联怪物.状态 === 怪物状态.活跃) {
                                if (检查视线(玩家.x, 玩家.y, x, y, 范围)) {
                                     if (!怪物位置集合.has(`${x},${y}`)) {
                                        候选怪物列表.push(单元格.关联怪物);
                                        怪物位置集合.add(`${x},${y}`);
                                     }
                                }
                            }
                        }
                    }

                    if (候选怪物列表.length === 0) {
                        显示通知("附近没有目标可供轰炸！", "错误");
                        return false;
                    }

                    const 目标点列表 = [];
                    if (候选怪物列表.length <= 陨石数量) {
                        // 如果怪物数量不多，直接以每个怪物为目标
                        候选怪物列表.forEach(m => 目标点列表.push({ x: m.x, y: m.y, 权重: 5 }));
                    } else {
                        // 怪物太多，需要聚类选择最优轰炸点
                        const 潜在轰炸点 = new Map();
                        候选怪物列表.forEach(怪物 => {
                             for (let dy = -爆炸范围; dy <= 爆炸范围; dy++) {
                                for (let dx = -爆炸范围; dx <= 爆炸范围; dx++) {
                                    const 落点X = 怪物.x + dx;
                                    const 落点Y = 怪物.y + dy;
                                    if (落点X < 0 || 落点X >= 地牢大小 || 落点Y < 0 || 落点Y >= 地牢大小) continue;
                                    
                                    const 单元格 = 地牢[落点Y]?.[落点X];
                                    if(单元格 && [单元格类型.房间, 单元格类型.走廊].includes(单元格.背景类型) && !单元格.关联物品?.阻碍怪物) {
                                        const key = `${落点X},${落点Y}`;
                                        if(!潜在轰炸点.has(key)){
                                            潜在轰炸点.set(key, {x: 落点X, y: 落点Y, 权重: 0});
                                        }
                                    }
                                }
                            }
                        });

                        潜在轰炸点.forEach(落点 => {
                           let 覆盖怪物数 = 0;
                           候选怪物列表.forEach(怪物 => {
                               if (Math.abs(怪物.x - 落点.x) <= 爆炸范围 && Math.abs(怪物.y - 落点.y) <= 爆炸范围) {
                                   覆盖怪物数++;
                               }
                           });
                           落点.权重 = 覆盖怪物数;
                        });
                        
                        const 排序后的落点 = Array.from(潜在轰炸点.values()).sort((a, b) => b.权重 - a.权重);
                        for(let i = 0; i < Math.min(陨石数量, 排序后的落点.length); i++){
                            目标点列表.push(排序后的落点[i]);
                        }
                    }

                    if (目标点列表.length === 0) {
                         显示通知("没有合适的位置召唤陨石！", "错误");
                         return false;
                    }

                    目标点列表.forEach((目标点, index) => {
                       setTimeout(() => {
                           const 临时炸弹 = new 炸弹({ 强化: true }); 
                            临时炸弹.x = 目标点.x;
                            临时炸弹.y = 目标点.y;
                            临时炸弹.自定义数据.set("爆炸范围", 爆炸范围);
                            临时炸弹.自定义数据.set("伤害", 17);
                            
                            临时炸弹.触发爆炸();
                       }, index * 120); // 陨石依次落下
                    });
                    
                    this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                    }
                    this.自定义数据.set("冷却剩余", this.最终冷却回合);
                    更新装备显示();
                    显示通知("陨石从天而降！", "成功");
                    return true;
                }
            }
            class 配方卷轴 extends 物品 {
                constructor(配置 = {}) {
                    const recipe = 配置.recipeData || {
                        输入: ["未知物品A", "未知物品B"],
                        输出类: "未知物品C",
                        输出类名称: "未知物品C",
                        说明: "一个神秘的配方",
                    };
                    super({
                        类型: "其他",
                        名称: `配方: ${recipe.输出类名称 || recipe.输出类}`,
                        图标: 图标映射.卷轴,
                        品质: 2,
                        颜色索引: 1,
                        效果描述: `学习一个物品融合配方！`,
                        是否正常物品: true,
                        能否拾起: true,
                        数据: {
                            recipe: recipe,
                            层数: 配置.层数,
                            已解锁: true, // Recipe scrolls are always "readable"
                        },
                        ...配置,
                    });
                }

                使用() {
                    const recipe = this.自定义数据.get("recipe");
                    if (recipe) {
                        const recipeString = recipe.说明;
                        if (
                            !已发现的程序生成配方.some(
                                (r) => r.说明 === recipeString
                            )
                        ) {
                            已发现的程序生成配方.push(recipe);
                            // Also add to the main 融合配方列表 so it can be used immediately
                            if (
                                !融合配方列表.some(
                                    (r) => r.说明 === recipeString
                                )
                            ) {
                                融合配方列表.push(recipe);
                            }
                            显示通知(`学会了新配方: ${recipe.说明}`, "成功");

                            处理销毁物品(this, true);
                            return true;
                        } else {
                            显示通知("你已经知道这个配方了。", "信息");

                            return true;
                        }
                    }
                    return false;
                }

                获取提示() {
                    const recipe = this.自定义数据.get("recipe");
                    let desc = super.获取提示();
                    if (recipe && recipe.说明) {
                        desc += `\n配方内容: ${recipe.说明}`;
                    }
                    return desc;
                }
            }
            class 湮灭卷轴 extends 卷轴类 {
                constructor(配置) {
                    super({
                        名称: "湮灭卷轴",
                        品质: 3,
                        效果描述: "销毁所有已装备物品",
                        能量消耗: 0,
                        强化: 配置.强化 || false,
                        已解锁: 配置.已解锁 || false,
                    });
                }

                使用() {
                    if (!this.消耗能量()) return false;
                    let 销毁列表 = Array.from(
                        { length: 装备栏每页装备数 },
                        (_, i) =>
                            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                    ).filter((v) => v != null);

                    销毁列表.forEach((item) => {
                        const 槽位元素 = document.getElementById(
                            `装备槽${
                                ((item.装备槽位 - 1) % 装备栏每页装备数) + 1
                            }`
                        ); // 修正槽位ID获取
                        if (槽位元素) {
                            // 确保槽位元素存在
                            const 烟花容器 = document.createElement("div");
                            烟花容器.style.position = "fixed";
                            const rect = 槽位元素.getBoundingClientRect();
                            烟花容器.style.left = `${
                                rect.left + rect.width / 2
                            }px`;
                            烟花容器.style.top = `${
                                rect.top + rect.height / 2
                            }px`;
                            烟花容器.style.zIndex = 99999;
                            document.body.appendChild(烟花容器);

                            for (let i = 0; i < 12; i++) {
                                const 粒子 = document.createElement("div");
                                粒子.className = "烟花粒子";
                                粒子.innerHTML = [
                                    "✨",
                                    "❄️",
                                    "⚡",
                                    "⭐",
                                    "💥",
                                    "🔥",
                                ][i % 6];
                                粒子.style.color = "#fff";
                                粒子.style.setProperty(
                                    "--tx",
                                    Math.cos((i * 30 * Math.PI) / 180)
                                );
                                粒子.style.setProperty(
                                    "--ty",
                                    Math.sin((i * 30 * Math.PI) / 180)
                                );
                                烟花容器.appendChild(粒子);
                            }
                            setTimeout(() => 烟花容器.remove(), 800);
                        }
                        item.取消装备();
                        处理销毁物品(item.唯一标识, true);
                    });
                    处理销毁物品(this.唯一标识, true);
                    更新背包显示();
                    更新装备显示();
                    显示通知(`湮灭了${销毁列表.length} 件装备`, "错误");
                    return true;
                }
            }

            class 秘银锁甲 extends 防御装备类 {
                constructor(配置) {
                    super({
                        名称: "秘银锁甲",
                        图标: 图标映射.秘银锁甲,
                        品质: 3,
                        防御力: 3,
                        效果描述: "轻盈而坚固的锁甲。",
                        耐久: 配置.耐久 || 150,
                        强化: 配置.强化 || false,
                        不可破坏: 配置.不可破坏 || false,
                    });
                }
                获取提示() {
                    return super.获取提示();
                }
            }

            class 钢制板甲 extends 防御装备类 {
                constructor(配置) {
                    super({
                        名称: "钢制板甲",
                        图标: 图标映射.钢制板甲,
                        品质: 2,
                        强化: 配置.强化 || false,
                        防御力: 1,
                        效果描述: "沉重的钢制板甲，提供基础防护。",
                        耐久: 配置.耐久 || 200,
                        不可破坏: 配置.不可破坏 || false,
                    });
                }
                获取提示() {
                    return super.获取提示();
                }
            }

            class 冰盾 extends 防御装备类 {
                constructor(配置) {
                    super({
                        名称: "冰盾",
                        图标: 图标映射.冰盾,
                        效果描述: `受击时有 ${(0.8 * 100).toFixed(
                            0
                        )}% 概率冻结攻击者 ${3} 回合。`,
                        品质: 3,
                        强化: 配置.强化 || false,
                        防御力: 2,
                        耐久: 配置.耐久 || 100,
                        不可破坏: 配置.不可破坏 || false,
                        数据: {
                            冻结概率: 0.8,
                            冻结回合: 3,
                        },
                    });
                }

                当被攻击(原始攻击力, 来源 = null) {
                    const 最终伤害 = super.当被攻击(原始攻击力, 来源);
                    if (
                        Math.random() < this.自定义数据.get("冻结概率") &&
                        来源 instanceof 怪物
                    ) {
                        const 攻击者 = 来源;
                        if (攻击者) {
                            const 冻结状态 = new 状态效果(
                                "冻结",
                                "#2196F3",
                                "冻",
                                this.自定义数据.get("冻结回合"),
                                null,
                                null,
                                攻击者
                            );
                        }
                    }
                    return 最终伤害;
                }
                获取提示() {
                    return super.获取提示();
                }
            }

            class 重铸台 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "重铸台",
                        图标: 图标映射.重铸台,
                        品质: 4,
                        颜色索引: 3,
                        最大堆叠数量: 1,
                        效果描述: `将同名装备的耐久融合\n耐久：${
                            配置.耐久 || 5
                        } /${配置.耐久 || 5}`,
                        数据: {
                            耐久: 配置.耐久 || 5,
                            最大耐久: 5,
                            基础消耗: 30,
                            强化折扣: -0.2,
                        },
                    });
                }

                使用() {
                    if (this.自定义数据.get("耐久") < 0) {
                        显示通知("重铸台已损坏！", "错误");
                        return false;
                    }
                    this.显示重铸界面();
                    return true;
                }

                显示重铸界面() {
                    if (界面可见性.背包) 切换背包显示();
                    玩家属性.允许移动 += 1;
                    const 遮罩 = document.createElement("div");
                    遮罩.className = "重铸遮罩";
                    const 弹窗 = document.createElement("div");
                    弹窗.className = "重铸弹窗";
                    弹窗.innerHTML = `
      <div class="重铸弹窗-header">
        <h3>重铸台（耐久：${this.自定义数据.get("耐久")}/${this.自定义数据.get(
                        "最大耐久"
                    )} | 金币：<span id="repairCost">0</span>）</h3>
        <button class="关闭按钮" onclick="关闭重铸界面()">×</button>
      </div>
      <div style="display: flex; gap: 20px;">
        <div class="重铸弹窗-column">
          <h4>待修复装备</h4>
          <div class="重铸弹窗-items" id="sourceItems"></div>
        </div>
        <div class="重铸弹窗-column">
          <h4>材料装备</h4>
          <div class="重铸弹窗-items" id="materialItems"></div>
        </div>
      </div>
      <button class="附魔确认按钮" style="margin-top:15px;" onclick="执行重铸()">开始重铸</button>
    `;

                    遮罩.appendChild(弹窗);
                    document.body.appendChild(遮罩);

                    // 添加进场动画
                    setTimeout(() => {
                        弹窗.style.transform = "translate(-50%, -50%) scale(1)";
                    }, 10);

                    this.填充可选物品(
                        弹窗.querySelector("#sourceItems"),
                        "source"
                    );
                    this.填充可选物品(
                        弹窗.querySelector("#materialItems"),
                        "material"
                    );
                    window.当前重铸台 = this;
                    window.当前重铸遮罩 = 遮罩; //懒得写进全局变量了...
                    弹窗.querySelectorAll(".重铸弹窗-items").forEach((容器) => {
                        容器.addEventListener("click", () =>
                            this.更新消耗显示()
                        );
                    });
                }
                计算消耗(源物品, 材料物品) {
                    if (!源物品 || !材料物品) {
                        return "-";
                    }
                    if (源物品 === 材料物品) {
                        return "-";
                    }
                    if (源物品.名称 !== 材料物品.名称) {
                        return "-";
                    }
                    let 基础消耗 = this.自定义数据.get("基础消耗");
                    const 折扣率 = this.自定义数据.get("强化折扣");
                    const 当前耐久 = 源物品.自定义数据.get("耐久");
                    const 最大耐久 = 源物品.自定义数据.get("原耐久");
                    const 可用空间 = 最大耐久 - 当前耐久;
                    const 可转移量 = Math.min(
                        材料物品.自定义数据.get("耐久"),
                        可用空间
                    );
                    基础消耗 += Math.floor((可转移量 / 最大耐久) * 基础消耗);
                    // 任一物品强化即打折（虽然是负折扣
                    const 有强化 = 源物品.强化 || 材料物品?.强化;
                    if (有强化) 基础消耗 *= 1 - 折扣率;

                    return Math.floor(基础消耗);
                }
                更新消耗显示() {
                    const 源物品 = document.querySelector(
                        "#sourceItems .selected"
                    )?.__物品实例;
                    const 材料物品 = document.querySelector(
                        "#materialItems .selected"
                    )?.__物品实例;

                    if (!源物品 || !材料物品) {
                        document.getElementById("repairCost").textContent = "0";
                        return;
                    }

                    let 消耗 = this.计算消耗(源物品, 材料物品);
                    document.getElementById("repairCost").textContent = 消耗;
                    if (消耗 === "-") 消耗 = 10000;
                    // 根据玩家金币改变颜色
                    const 玩家金币 = [...玩家背包.values()]
                        .filter((i) => i instanceof 金币)
                        .reduce((sum, i) => sum + i.堆叠数量, 0);

                    document.getElementById("repairCost").style.color =
                        玩家金币 >= 消耗 ? "#4CAF50" : "#F44336";
                }

                填充可选物品(容器, 类型) {
                    容器.innerHTML = "";
                    const 有效物品 = [...玩家背包.values()].filter(
                        (item) =>
                            (item instanceof 武器类 ||
                                item instanceof 防御装备类) &&
                            item.自定义数据?.has("耐久") &&
                            item !== this
                    );

                    有效物品.forEach((item) => {
                        const 元素 = document.createElement("div");
                        元素.className = "重铸物品";
                        元素.innerHTML = `
      ${item.强化 ? '<div class="重铸台强化标识">★</div>' : ""}
        <div class="物品图标">${item.图标}</div>
        <div class="物品名称">${item.名称}</div>
        <div class="重铸台耐久标签">耐久 ${item.自定义数据.get(
            "耐久"
        )}/${item.自定义数据.get("原耐久")}</div>
      `;

                        // 直接绑定实例引用
                        元素.__物品实例 = item;
                        元素.addEventListener("click", () =>
                            this.选择物品(元素, 类型)
                        );
                        容器.appendChild(元素);
                    });
                }

                选择物品(元素, 类型) {
                    document
                        .querySelectorAll(`.重铸物品[data-type="${类型}"]`)
                        .forEach((el) => {
                            el.classList.remove("selected");
                            el.style.transform = "scale(1)";
                        });
                    元素.classList.add("selected");
                    元素.style.transform = "scale(1.05)";
                    元素.dataset.type = 类型;
                }
            }
            class 火把 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "火把",
                        图标: 图标映射.火焰,
                        品质: 1,
                        颜色索引: 2,
                        堆叠数量: 配置.数量 || 1,
                        最大堆叠数量: 1,
                        效果描述: `装备后视野+${
                            2 + (配置.强化 ? 1 : 0)
                        }，丢地上光照${
                            3 + (配置.强化 ? 1 : 0)
                        }格。每回合消耗耐久。`,
                        强化: 配置.强化 || false,
                        数据: {
                            耐久: 配置.耐久 || 400 + (配置.强化 ? 400 : 0),
                            原耐久: 400 + (配置.强化 ? 400 : 0),
                            光照范围: 3 + (配置.强化 ? 1 : 0),
                            视野加成: 2 + (配置.强化 ? 1 : 0),
                            倒计时: 配置.耐久 || 400 + (配置.强化 ? 400 : 0),
                            爆炸时间: 配置.耐久 || 400 + (配置.强化 ? 400 : 0),
                            不可破坏: false,
                            ...配置.数据,
                        },
                    });
                }
                生成显示元素(用途 = "背包") {
                    const 元素 = super.生成显示元素(用途);

                    if (
                        this.自定义数据.has("耐久") &&
                        this.自定义数据.has("原耐久") &&
                        用途 === "装备"
                    ) {
                        let 耐久标签 = 元素.querySelector(".耐久标签");
                        if (!耐久标签) {
                            耐久标签 = document.createElement("div");
                            耐久标签.className = "耐久标签";
                            元素.appendChild(耐久标签);
                        }

                        耐久标签.textContent = `耐久:${this.自定义数据.get(
                            "耐久"
                        )}`;
                    }
                    return 元素;
                }

                装备() {
                    const 装备成功 = super.装备();
                    if (装备成功) {
                        if (
                            !所有计时器.some(
                                (t) => t.唯一标识 === this.唯一标识
                            )
                        ) {
                            所有计时器.push(this);
                        }
                        解冻药水();
                    }
                    return 装备成功;
                }

                取消装备() {
                    const 卸下成功 = super.取消装备();
                    if (卸下成功) {
                        所有计时器 = 所有计时器.filter(
                            (t) => t.唯一标识 !== this.唯一标识
                        );
                    }
                    return 卸下成功;
                }

                更新倒计时() {
                    let 当前耐久 = this.自定义数据.get("倒计时");
                    当前耐久--;
                    if (当前天气效果.includes("严寒")) {
                        当前耐久--;
                    }
                    this.自定义数据.set("倒计时", 当前耐久);
                    this.自定义数据.set("耐久", 当前耐久);

                    if (当前耐久 <= 0) {
                        this.触发爆炸();
                    }

                    if (this.已装备) {
                        更新装备显示();
                    }
                }

                触发爆炸() {
                    显示通知(`${this.名称} 燃尽熄灭了。`, "信息");

                    if (
                        this.x !== null &&
                        this.y !== null &&
                        地牢[this.y]?.[this.x]?.关联物品 === this
                    ) {
                        地牢[this.y][this.x].关联物品 = null;
                        地牢[this.y][this.x].类型 =
                            地牢[this.y][this.x].背景类型;
                    }
                    所有计时器 = 所有计时器.filter(
                        (t) => t.唯一标识 !== this.唯一标识
                    );

                    if (玩家背包.has(this.唯一标识)) {
                        处理销毁物品(this.唯一标识, true);
                    }
                    绘制();
                }

                使用() {
                    if (!this.已装备) {
                        if (this.装备()) {
                            显示通知(`装备了 ${this.名称}`, "成功");
                            更新背包显示();
                            更新装备显示();
                            return true;
                        } else {
                            显示通知("装备槽已满！", "错误");
                            return false;
                        }
                    } else {
                        显示通知("火把已装备", "信息");
                        return false;
                    }
                }

                获取提示() {
                    return super.获取提示();
                }

                当被丢弃(x, y) {
                    this.x = x;
                    this.y = y;
                    if (
                        this.自定义数据.get("耐久") > 0 &&
                        !所有计时器.some((t) => t.唯一标识 === this.唯一标识)
                    ) {
                        所有计时器.push(this);
                    }
                    return true;
                }
                当被收集(进入者) {
                    if (进入者 !== "玩家") return;
                    所有计时器 = 所有计时器.filter(
                        (t) => t.唯一标识 !== this.唯一标识
                    );
                    return true;
                }
            }

            class 喷火枪 extends 武器类 {
                constructor(配置) {
                    super({
                        名称: "喷火枪",
                        图标: 图标映射.喷火枪,
                        品质: 2,
                        基础攻击力: 4,
                        冷却回合: 4,
                        攻击范围: 3,
                        耐久: 配置?.耐久 || 100,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "向四个方向喷射火焰，对距离3格的直线敌人造成范围伤害。",
                        攻击目标数: 1,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            火焰范围: 2,
                        },
                    });
                }

                使用(目标怪物) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;
                    if (当前天气效果.includes("严寒")) {
                        if (目标怪物)
                            显示通知("温度过低，武器打不着火了！", "警告");
                        return 0;
                    }
                    const 总攻击力 = this.攻击力;
                    let 总有效伤害 = 0;
                    const 击中怪物列表 = new Set();
                    const 火焰影响区域 = [];

                    const 火焰范围 = this.自定义数据.get("火焰范围");
                    const 目标X = 玩家.x;
                    const 目标Y = 玩家.y;

                    if (
                        目标X < 0 ||
                        目标X >= 地牢大小 ||
                        目标Y < 0 ||
                        目标Y >= 地牢大小
                    )
                        return;

                    const 当前方向火焰区 = [];
                    for (let 偏移 = -火焰范围; 偏移 <= 火焰范围; 偏移++) {
                        const 格子Y = 目标Y + 偏移;
                        if (格子Y >= 0 && 格子Y < 地牢大小) {
                            if (
                                快速直线检查(
                                    玩家.x,
                                    玩家.y,
                                    目标X,
                                    格子Y,
                                    Math.abs(偏移)
                                )
                            ) {
                                当前方向火焰区.push({ x: 目标X, y: 格子Y });
                            }
                        }
                    }
                    for (let 偏移 = -火焰范围; 偏移 <= 火焰范围; 偏移++) {
                        const 格子X = 目标X + 偏移;
                        if (格子X >= 0 && 格子X < 地牢大小) {
                            if (
                                快速直线检查(
                                    玩家.x,
                                    玩家.y,
                                    格子X,
                                    目标Y,
                                    Math.abs(偏移)
                                )
                            ) {
                                当前方向火焰区.push({ x: 格子X, y: 目标Y });
                            }
                        }
                    }

                    当前方向火焰区.forEach(({ x, y }) => {
                        火焰影响区域.push({ x, y });
                        const 单元格 = 地牢[y][x];
                        if (
                            单元格 &&
                            单元格.关联物品 instanceof 祭坛类 &&
                            单元格.关联物品.自定义数据.get("激活条件") ===
                                "火焰净化" &&
                            !单元格.关联物品.自定义数据.get("已激活")
                        ) {
                            单元格.关联物品.激活();
                        } else if (
                            单元格 &&
                            单元格.关联怪物 &&
                            单元格.关联怪物.当前生命值 > 0 &&
                            !击中怪物列表.has(单元格.关联怪物)
                        ) {
                            const 怪物 = 单元格.关联怪物;
                            const 原始血量 = 怪物.当前生命值;
                            怪物.受伤(总攻击力, "玩家");
                            const 实际伤害 = 原始血量 - 怪物.当前生命值;
                            if (实际伤害 > 0) {
                                总有效伤害 += 实际伤害;
                                击中怪物列表.add(怪物);
                            }
                        }
                    });

                    火焰影响区域.forEach((格子) =>
                        计划显示格子特效([格子], "FFA500")
                    );

                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set(
                        "冷却剩余",
                        Math.max(
                            this.自定义数据.get("冷却回合") -
                                (this.强化 ? 1 : 0),
                            0
                        )
                    );

                    if (总有效伤害 > 0) {
                        显示通知(
                            `${this.名称} 对 ${
                                击中怪物列表.size
                            } 个目标造成共 ${总有效伤害.toFixed(1)} 点伤害！`,
                            "成功"
                        );
                    } else if (火焰影响区域.length > 0) {
                        显示通知(`${this.名称} 喷射了火焰！`, "信息");
                    } else {
                        显示通知(`${this.名称} 未能喷射火焰！`, "警告");
                        return 0;
                    }

                    if (总有效伤害 > 0) {
                        const 受击怪物数组 = Array.from(击中怪物列表);
                        const 火焰等级 =
                            (this.自定义数据
                                .get("附魔")
                                ?.find((item) => item.种类 === "火焰附魔")
                                ?.等级 || 0) + 2;
                        受击怪物数组.forEach((怪物) => {
                            if (怪物.当前生命值 > 0) {
                                new 状态效果(
                                    "火焰",
                                    "#CC5500",
                                    "火",
                                    火焰等级,
                                    null,
                                    null,
                                    怪物
                                );
                            }
                        });

                        const 连锁附魔 = this.自定义数据
                            .get("附魔")
                            ?.find((item) => item.种类 === "连锁附魔");
                        if (连锁附魔) {
                            const 连锁距离 = 连锁附魔.等级;
                            受击怪物数组.forEach((初始目标) => {
                                if (初始目标.当前生命值 > 0) {
                                    this.触发连锁(
                                        初始目标,
                                        连锁距离,
                                        受击怪物数组
                                    );
                                }
                            });
                        }
                    }
                    return 总有效伤害;
                }

                获取提示() {
                    return super.获取提示();
                }
            }
            class 斜方刀 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "斜方刀",
                        图标: 图标映射.斜方刀,
                        品质: 2,
                        基础攻击力: 5,
                        冷却回合: 3,
                        攻击范围: 4,
                        耐久: 配置?.耐久 || 60,
                        强化: 配置?.强化 || false,
                        效果描述:
                            "向四个斜向挥出刀光，对路径上2格内的敌人造成伤害。",
                        攻击目标数: 8,
                        不可破坏: 配置?.不可破坏 || false,
                        附魔: 配置?.数据?.附魔 || [],
                        数据: {
                            ...配置.数据,
                        },
                    });
                }

                使用(目标怪物列表) {
                    if (
                        this.堆叠数量 <= 0 ||
                        this.自定义数据.get("冷却剩余") > 0
                    )
                        return 0;

                    const 总攻击力 = this.攻击力;
                    let 总有效伤害 = 0;
                    const 击中怪物列表 = new Set();
                    const 影响格子 = [];

                    // 定义四个斜向的方向向量
                    const 斜向列表 = [
                        { dx: -1, dy: -1 }, // 左上
                        { dx: 1, dy: -1 }, // 右上
                        { dx: -1, dy: 1 }, // 左下
                        { dx: 1, dy: 1 }, // 右下
                    ];

                    // 遍历每个斜向
                    斜向列表.forEach((方向) => {
                        // 每个方向延伸2格
                        for (let 距离 = 0; 距离 <= 2; 距离++) {
                            const 目标X = 玩家.x + 方向.dx * 距离;
                            const 目标Y = 玩家.y + 方向.dy * 距离;

                            const 上一步X = 玩家.x + 方向.dx * (距离 - 1);
                            const 上一步Y = 玩家.y + 方向.dy * (距离 - 1);

                            // 检查路径是否被阻挡
                            if (
                                !检查移动可行性(上一步X, 上一步Y, 目标X, 目标Y)
                            ) {
                                break; // 如果路径被墙壁阻挡，则停止在这个方向上继续延伸
                            }

                            if (
                                目标X >= 0 &&
                                目标X < 地牢大小 &&
                                目标Y >= 0 &&
                                目标Y < 地牢大小
                            ) {
                                影响格子.push({ x: 目标X, y: 目标Y });
                                const 单元格 = 地牢[目标Y]?.[目标X];

                                if (
                                    单元格?.关联怪物 &&
                                    单元格.关联怪物.当前生命值 > 0 &&
                                    !击中怪物列表.has(单元格.关联怪物)
                                ) {
                                    const 怪物 = 单元格.关联怪物;
                                    const 原始血量 = 怪物.当前生命值;
                                    怪物.受伤(总攻击力, "玩家");
                                    const 实际伤害 = 原始血量 - 怪物.当前生命值;

                                    if (实际伤害 > 0) {
                                        总有效伤害 += 实际伤害;
                                        击中怪物列表.add(怪物);
                                    }
                                }
                            } else {
                                break; // 超出边界，停止延伸
                            }
                        }
                    });

                    // 显示攻击特效
                    计划显示格子特效(影响格子, "C0C0C0"); // 银色刀光

                    // 处理武器消耗和冷却
                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set("冷却剩余", this.最终冷却回合);

                    if (击中怪物列表.size > 0) {
                        显示通知(
                            `${this.名称} 击中了 ${
                                击中怪物列表.size
                            } 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`,
                            "成功"
                        );
                        const 所有击中怪物 = Array.from(击中怪物列表);
                        this.触发通用附魔(所有击中怪物);
                    } else {
                        显示通知(`${this.名称} 挥了个空！`, "信息");
                    }

                    更新装备显示();
                    return 总有效伤害;
                }
            }
            class 神龛 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: "神龛",
                        图标: 图标映射.神龛,
                        品质: 5,
                        颜色索引: 4,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: true,
                        效果描述: "一座散发着因果气息的古老神龛，许下你的愿望吧...",
                        数据: {
                            已许愿: false,
                        },
                        ...配置,
                    });
                }
            
                尝试互动() {
                    if (this.自定义数据.get("已许愿")) {
                        显示通知("神龛的回应已经结束，它陷入了沉寂。", "信息");
                        return false;
                    }

                    
                    

                    显示自定义确认对话框(
                        "你感觉到神龛正在呼唤你。你是否愿意献上你的一部分命运，来换取一个永久的祝福...或诅咒？",
                        () => this.执行许愿(神龛效果列表)
                    );

                    return true;
                }
            
                执行许愿(效果池) {
                    const 随机效果 = 效果池[Math.floor(Math.random() * 效果池.length)];
                    
                    随机效果.apply(); 
                    
                    
                    永久Buffs.已获得效果.add(随机效果.id);
                    应用永久Buffs();
                    this.自定义数据.set("已许愿", true);
                    
                    this.效果描述 = "神龛的力量已经与你的命运交织在了一起。";

                    const 提示类型 = 随机效果.类型 === '祝福' ? '成功' : '错误';
                    显示通知(`你的命运改变了！获得了${随机效果.类型}：【${随机效果.名称}】`, 提示类型, true, 4000);
                    添加日志(`【神龛】${随机效果.描述}`, 提示类型);
                    
                    绘制();
                }

                获取提示() {
                     if (this.自定义数据.get("已许愿")) {
                        return `${this.名称}\n${this.效果描述}`;
                    }
                    return `${this.名称}\n品质：${"★".repeat(this.品质)}\n${this.效果描述}`;
                }
            }
            
            
            class 神秘商人 extends 物品 {
                constructor(配置) {
                    super({
                        类型: "NPC",
                        名称: "神秘商人",
                        图标: 图标映射.神秘商人,
                        品质: 4,
                        颜色索引: 3,
                        能否拾起: false, // 不可拾取
                        效果描述: "毫无卵用的奸商",
                        数据: {
                            库存: 配置.库存 || [],
                            刷新次数: 3, // 可交易次数
                        },
                    });
                    this.能否拾起 = false;
                    if (!配置.库存物品) {
                        this.生成库存(Math.max(当前层数, 0));
                    }
                }
                使用() {
                    打开交易窗口(this);
                    return true;
                }
                生成库存(层数) {
                    this.自定义数据.set("库存", []);
                    const 品质权重 = [
                        { 品质: 1, 权重: 50 - 层数 * 5 },
                        { 品质: 2, 权重: 30 + 层数 * 3 },
                        { 品质: 3, 权重: 15 + 层数 * 2 },
                        { 品质: 4, 权重: 5 + 层数 * 1 },
                    ].filter((w) => w.权重 > 0);
                    let 已选中 = false;
                    let 尝试次数 = 0;
                    for (let i = 0; i < 3; i++) {
                        while (!已选中 && 尝试次数 < 100) {
                            let 选中品质 = 加权随机选择(品质权重);
                            if (选中品质) {
                                const 候选物品 = Object.values(物品池)
                                    .flat()
                                    .filter((item) => {
                                        const 临时实例 = new item.类({
                                            库存物品: true,
                                        });
                                        return (
                                            item.品质 == 选中品质.品质 &&
                                            层数 >= item.最小层 &&
                                            临时实例.类型 !== "工具"
                                        );
                                    });

                                if (候选物品.length > 0) {
                                    const 模板 =
                                        候选物品[
                                            Math.floor(
                                                Math.random() * 候选物品.length
                                            )
                                        ];
                                    const 物品实例 = new 模板.类({
                                        数量: 1,
                                        强化:
                                            Math.random() <
                                            Math.min(0.85, 层数 * 0.15),
                                        已解锁: true,
                                        品质: 2 + Math.floor(Math.random() * 4),
                                    });
                                    if (
                                        !this.自定义数据
                                            .get("库存")
                                            .some(
                                                (item) =>
                                                    item.名称 === 物品实例.名称
                                            ) &&
                                        物品实例.是否正常物品
                                    ) {
                                        this.自定义数据
                                            .get("库存")
                                            .push(物品实例);
                                        已选中 = true;
                                    }
                                }
                            }
                            尝试次数++;
                        }
                        已选中 = false;
                        尝试次数 = 0;
                    }
                }

                获取价格(物品) {
                    return Math.max(
                        物品.品质 * 20 +
                            (物品.强化 ? 20 : 0) +
                            Math.floor(Math.random() * 15) -
                            当前层数 * 2,
                        30
                    );
                }
            }
            class 探险家 extends 物品 {
                constructor(配置) {
                    super({
                        类型: "NPC",
                        名称: "探险家",
                        图标: 图标映射.探险家,
                        品质: 3,
                        颜色索引: 3,
                        能否拾起: false,
                        是否正常物品: false, // 不直接出现在掉落池
                        效果描述:
                            "一位经验丰富的探险家，愿意用金币换取你的发现。",
                        数据: {
                            收购需求: [], // { 名称: "钢制长剑", 品质下限: 1, 强化需求: false, 数量: 1 }
                            交易次数: 5 + Math.floor(Math.random() * 6), // 随机交易次数
                        },
                    });
                    if (!配置.库存物品) {
                        this.生成收购需求(当前层数);
                    }
                }

                生成收购需求(层数) {
                    this.自定义数据.set("收购需求", []);
                    const 需求数量 = 9 + Math.floor(Math.random() * 4);

                    const 可选物品池 = Object.values(物品池)
                        .flat()
                        // 排除非卖品
                        .filter((itemTmpl) => {
                            if (itemTmpl.类.name !== "探险家") {
                                const tempInstance = new itemTmpl.类({
                                    库存物品: true,
                                });
                                return (
                                    tempInstance.是否正常物品 &&
                                    tempInstance.类型 !== "钥匙" &&
                                    tempInstance.类型 !== "金币" &&
                                    tempInstance.类型 !== "NPC" &&
                                    tempInstance.类型 !== "祭坛" &&
                                    tempInstance.类型 !== "工具" &&
                                    tempInstance.类型 !== "折跃门"
                                );
                            }
                        });

                    if (可选物品池.length === 0) return;

                    const 已选名称 = new Set();

                    for (let i = 0; i < 需求数量; i++) {
                        let 尝试次数 = 0;
                        while (尝试次数 < 50) {
                            const 随机物品模板 =
                                可选物品池[
                                    Math.floor(
                                        Math.random() * 可选物品池.length
                                    )
                                ];
                            const 临时实例 = new 随机物品模板.类({});

                            if (已选名称.has(临时实例.名称)) {
                                尝试次数++;
                                continue;
                            }

                            const 强化需求 =
                                随机物品模板.品质 >= 3 &&
                                Math.random() < 0.3 + 当前层数 * 0.05;

                            this.自定义数据.get("收购需求").push({
                                名称: 临时实例.名称,
                                强化需求: 强化需求,
                                图标: 临时实例.图标,
                                颜色索引: 临时实例.颜色索引,
                                类名: 随机物品模板.类.name,
                            });
                            已选名称.add(临时实例.名称);
                            break;
                        }
                    }
                }

                计算收购价格(物品实例, 需求) {
                    let 基础价格 =
                        (物品实例.品质 * 20 + (需求.强化需求 ? 15 : 0)) * 0.8; // 比商人售价低一些

                    if (物品实例.强化 && (!需求.强化需求 || 需求.强化需求)) {
                        基础价格 += 10;
                    } else if (!物品实例.强化 && 需求.强化需求) {
                        return 0;
                    }

                    if (
                        物品实例.自定义数据?.has("耐久") &&
                        物品实例.自定义数据?.has("原耐久")
                    ) {
                        const 耐久比例 =
                            物品实例.自定义数据.get("耐久") /
                            物品实例.自定义数据.get("原耐久");
                        基础价格 *= 0.5 + 耐久比例 * 0.5;
                    }

                    if (物品实例.自定义数据?.has("附魔")) {
                        const 附魔数量 = (物品实例.自定义数据.get("附魔") || [])
                            .length;
                        const 附魔等级总和 = (
                            物品实例.自定义数据.get("附魔") || []
                        ).reduce((sum, e) => sum + e.等级, 0);
                        基础价格 += 附魔数量 * 2 + 附魔等级总和 * 1.5;
                    }

                    if (
                        物品实例 instanceof 卷轴类 &&
                        物品实例.自定义数据?.get("已解锁")
                    ) {
                        基础价格 *= 1.3;
                    }

                    if (
                        物品实例 instanceof 宠物 &&
                        物品实例.自定义数据?.has("等级")
                    ) {
                        基础价格 += 物品实例.自定义数据.get("等级") * 3;
                    }

                    return Math.max(
                        1,
                        Math.floor(基础价格 * (0.9 + Math.random() * 0.2))
                    ); // 90%-110% 浮动，最低1金币
                }

                使用() {
                    if (this.自定义数据.get("交易次数") <= 0) {
                        显示通知(
                            "我已经收够今天想要的东西了，下次再见！",
                            "信息"
                        );
                        return false;
                    }
                    打开收购窗口(this);
                    return true;
                }
            }
            class 渔网陷阱 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "陷阱",
                        名称: "渔网陷阱",
                        图标: 图标映射.渔网陷阱,
                        品质: 2,
                        颜色索引: 3,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: false,
                        效果描述: "黏糊糊的渔网，能缠住敌人。",
                        数据: {
                            倒计时: 999,
                            爆炸时间: 999,
                            牵制回合: 5,
                        },
                        ...配置,
                    });
                }
                当被收集(进入者) {
                    if (进入者 instanceof 怪物 && !(进入者 instanceof 幽灵怪物)) {
                        new 状态效果("牵制", "#FFFFFF", "🕸️", this.自定义数据.get("牵制回合"), null, null, 进入者);
                        添加日志(`${进入者.类型} 被渔网缠住了！`, "信息");
                        this.移除自身();
                    }
                    return false;
                }
                更新倒计时() {
                }
                移除自身() {
                    if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
                        地牢[this.y][this.x].关联物品 = null;
                        if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品) {
                            地牢[this.y][this.x].类型 = null;
                        }
                    }
                    所有计时器 = 所有计时器.filter(item => item !== this);
                }
            }

            class 渔网 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "渔网",
                        图标: 图标映射.渔网,
                        品质: 2,
                        颜色索引: 3,
                        堆叠数量: 配置.数量 || 1,
                        最大堆叠数量: 16,
                        效果描述: "在脚下2x2的区域放置一张大网。",
                        ...配置,
                    });
                }
                使用() {
                    if (this.堆叠数量 <= 0) return false;
                    const 格子偏移 = [
                        { dx: 0, dy: 0 },
                        { dx: 1, dy: 0 },
                        { dx: 0, dy: 1 },
                        { dx: 1, dy: 1 },
                    ];
                    let 放置成功计数 = 0;
                    for (const 偏移 of 格子偏移) {
                        const 目标X = 玩家.x + 偏移.dx;
                        const 目标Y = 玩家.y + 偏移.dy;
                        if (位置是否可用(目标X, 目标Y, false)) {
                            const 网格陷阱实例 = new 渔网陷阱({});
                            if (放置物品到单元格(网格陷阱实例, 目标X, 目标Y)) {
                                放置成功计数++;
                            }
                        }
                    }
                    if (放置成功计数 > 0) {
                        this.堆叠数量--;
                        if (this.堆叠数量 <= 0) {
                            处理销毁物品(this.唯一标识, true);
                        }
                        显示通知(`成功放置了 ${放置成功计数} 格渔网！`, "成功");
                        更新背包显示();
                        更新装备显示();
                        绘制();
                        return true;
                    } else {
                        显示通知("无法在此处放置渔网。", "错误");
                        return false;
                    }
                }
            }

            class 充能魔杖 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "充能魔杖",
                        图标: 图标映射.充能魔杖,
                        品质: 4,
                        基础攻击力: 0,
                        冷却回合: 10,
                        攻击范围: 1,
                        耐久: 配置?.耐久 || 30,
                        强化: 配置?.强化 || false,
                        效果描述: "消耗大量能量释放强大的魔法。",
                        数据: {
                            能量消耗: 80 - (配置.强化 ? 20 : 0),
                        },
                        ...配置,
                    });
                }
                使用() {
                    if (this.自定义数据.get("冷却剩余") > 0) {
                        显示通知("魔杖还在充能！", "警告");
                        return false;
                    }
                    if (!扣除能量(this.自定义数据.get("能量消耗"))) {
                        显示通知("能量不足！", "错误");
                        return false;
                    }
                    const 效果池 = ["不伤玩家爆炸", "召唤植物"];
                    const 选中效果 = 效果池[Math.floor(Math.random() * 效果池.length)];
                    switch (选中效果) {
                        case "不伤玩家爆炸":
                            this.执行爆炸();
                            break;
                        case "召唤植物":
                            this.召唤植物();
                            break;
                    }
                    this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                    }
                    this.自定义数据.set("冷却剩余", this.最终冷却回合);
                    更新装备显示();
                    return true;
                }
                                执行爆炸() {
                    const 爆炸范围 = 4;
                    const 爆炸坐标 = [];
                    for (let dy = -爆炸范围; dy <= 爆炸范围; dy++) {
                        for (let dx = -爆炸范围; dx <= 爆炸范围; dx++) {
                            if (Math.sqrt(dx*dx + dy*dy) <= 爆炸范围) {
                                爆炸坐标.push({x: 玩家.x + dx, y: 玩家.y + dy});
                            }
                        }
                    }
                    计划显示格子特效(爆炸坐标, "8A2BE2", 20);
                    爆炸坐标.forEach(({x, y}) => {
                        if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
                            const 单元格 = 地牢[y]?.[x];
                            if (单元格?.关联怪物) {
                                单元格.关联怪物.受伤(25, this.名称);
                                let 怪物 = 单元格.关联怪物;
                                if (!怪物) return;
                                if (怪物.当前生命值 > 0) {
                                    const dx = x - 玩家.x;
                                    const dy = y - 玩家.y;
                                    let dirX = 0;
                                    let dirY = 0;

                                    if (Math.abs(dx) > Math.abs(dy)) {
                                        dirX = Math.sign(dx);
                                    } else if (Math.abs(dy) > Math.abs(dx)) {
                                        dirY = Math.sign(dy);
                                    } else if (dx !== 0) {
                                        dirX = Math.sign(dx);
                                    } else if (dy !== 0) {
                                        dirY = Math.sign(dy);
                                    }

                                    if (dirX !== 0 || dirY !== 0) {
                                        const { x: 最终X, y: 最终Y } = 怪物.计算最大甩飞位置(x, y, dirX, dirY, 1);
                                        if(最终X !== x || 最终Y !== y) {
                                            const oldX = 怪物.x;
                                            const oldY = 怪物.y;
                                            怪物.恢复背景类型();
                                            怪物.x = 最终X;
                                            怪物.y = 最终Y;
                                            怪物.保存新位置类型(最终X, 最终Y);
                                            地牢[最终Y][最终X].类型 = 单元格类型.怪物;
                                            地牢[最终Y][最终X].关联怪物 = 怪物;
                                            怪物.处理地形效果();
                                            怪物动画状态.set(怪物, {
                                                旧逻辑X: oldX,
                                                旧逻辑Y: oldY,
                                                目标逻辑X: 最终X,
                                                目标逻辑Y: 最终Y,
                                                视觉X: oldX,
                                                视觉Y: oldY,
                                                动画开始时间: Date.now(),
                                                正在动画: true,
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    });
                    显示通知("魔杖释放了一股强大的能量波！", "成功");
                }
                召唤植物() {
                    const 召唤数量 = 5 + (this.强化 ? 2 : 0);
                    let 已召唤 = 0;
                    const 方向 = [[0,-2],[2,0],[0,2],[-2,0],[-1,-1],[1,-1],[1,1],[-1,1]];
                    方向.sort(() => Math.random() - 0.5);
                    for(const [dx, dy] of 方向) {
                        if (已召唤 >= 召唤数量) break;
                        const 目标X = 玩家.x + dx;
                        const 目标Y = 玩家.y + dy;
                        if (位置是否可用(目标X, 目标Y, false)) {
                            const 新植物 = new 魔力远射植物({强化: this.强化});
                            if(放置物品到单元格(新植物, 目标X, 目标Y)) {
                                所有计时器.push(新植物);
                                已召唤++;
                            }
                        }
                    }
                    显示通知(`魔杖召唤了 ${已召唤} 株魔力植物！`, "成功");
                }
            }

            class 魔力远射植物 extends 远射植物 {
                constructor(配置 = {}) {
                    super({
                        名称: "魔力远射植物",
                        能否拾起: false,
                        
                        ...配置,
                    });
                    this.自定义数据.set('倒计时',15 + (配置.强化 ? 10 : 0))
                    this.自定义数据.set('攻击力',7 + (配置.强化 ? 7 : 0))
                }
                尝试互动() {
                    return false;
                }
                更新倒计时() {
                    if(this.自定义数据.get("耐久") <= 0) {
                        this.移除自身();
                        
                        return;
                    }
                    super.更新倒计时();
                    let 倒计时 = this.自定义数据.get("倒计时");
                    if(倒计时 > 0) {
                        this.自定义数据.set("倒计时", 倒计时 - 1);
                    } else {
                        this.移除自身();
                        
                    }
                }
            }
            
            class 时间卷轴 extends 卷轴类 {
                constructor(配置) {
                    super({
                        名称: "时间卷轴",
                        图标: 图标映射.时间卷轴,
                        品质: 4,
                        效果描述: "激活后，装备冷却和宠物恢复速度加快。持续消耗能量。",
                        能量消耗: 10,
                        强化: 配置.强化 || false,
                        已解锁: 配置.已解锁 || false,
                    });
                }
                使用() {
                    return true;
                }
                卸下() {
                    return true;
                }
            }

            class 潜行靴子 extends 防御装备类 {
                constructor(配置 = {}) {
                    super({
                        名称: "潜行靴子",
                        图标: 图标映射.潜行靴子,
                        品质: 3,
                        防御力: 1,
                        效果描述: "装备后，只有在敌人视线内才会被追踪。",
                        耐久: 配置.耐久 || 120,
                        强化: 配置.强化 || false,
                    });
                }
            }

            class 钩索 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "钩索",
                        图标: 图标映射.钩索,
                        品质: 3,
                        基础攻击力: 0,
                        最大堆叠数量: 1,
                        效果描述: "向你上次移动的方向发射钩索，将你拉向墙壁。",
                        强化: 配置?.强化 || false,
                        攻击范围: 0,
                        攻击目标数: 0,
                        数据: {
                            冷却回合: 5 - (配置.强化 ? 2 : 0),
                            攻击范围: 30 + (配置.强化 ? 20 : 0),
                            耐久: 50 + (配置.强化 ? 25 : 0),
                            原耐久: 50 + (配置.强化 ? 25 : 0),
                            冷却剩余: 0,
                        },
                        ...配置,
                    });
                }
                使用() {
                    if (玩家正在钩索) {
                        显示通知("正在使用钩索！", "警告");
                        return false;
                    }
                    if (this.自定义数据.get("冷却剩余") > 0) {
                        显示通知("钩索还未准备好！", "错误");
                        return false;
                    }
                    const 上次方向 = 移动历史[移动历史.length - 1];
                    if (!上次方向) {
                        显示通知("没有移动方向！", "错误");
                        return false;
                    }
                    let dx = 0, dy = 0;
                    if (上次方向 === "上") dy = -1;
                    else if (上次方向 === "下") dy = 1;
                    else if (上次方向 === "左") dx = -1;
                    else if (上次方向 === "右") dx = 1;
                    let 钩中点 = null;
                    for (let i = 1; i <= this.最终攻击范围; i++) {
                        const 检查X = 玩家.x + dx * i;
                        const 检查Y = 玩家.y + dy * i;
                        if (检查X < 0 || 检查X >= 地牢大小 || 检查Y < 0 || 检查Y >= 地牢大小) break;
                        const 单元格 = 地牢[检查Y]?.[检查X];
                        if (!单元格) break;
                        const 前一单元格 = 地牢[玩家.y + dy * (i-1)]?.[玩家.x + dx * (i-1)];
                        if(前一单元格 && !检查移动可行性(玩家.x, 玩家.y, 检查X, 检查Y, true)) {
                           钩中点 = { x: 玩家.x + dx * (i-1), y: 玩家.y + dy * (i-1) };
                           break;
                        }
                        const 目标房间ID = 房间地图[检查Y]?.[检查X];
                        const 目标房间已访问 = 目标房间ID === -1 || 已访问房间.has(目标房间ID);
                        if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) || (前一单元格.背景类型 === 单元格类型.门 && !目标房间已访问)) {
                            钩中点 = { x: 玩家.x + dx * (i-1), y: 玩家.y + dy * (i-1) };
                            break;
                        }
                    }
                    if (钩中点) {
                        
                        const 路径 = 广度优先搜索路径(玩家.x, 玩家.y, 钩中点.x, 钩中点.y, this.最终攻击范围, true);
                        if (路径.length > 1) {
                            this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));
                        this.自定义数据.set("耐久", this.自定义数据.get("耐久") - 1);
                        if(this.自定义数据.get("耐久") <= 0) 处理销毁物品(this.唯一标识, true);
                        更新装备显示();
                            this.开始高速移动(路径.slice(1));
                            return true;
                        }
                    }
                    显示通知("钩索没有勾住任何东西！", "错误");
                    return false;
                }
                开始高速移动(路径) {
                    玩家正在钩索 = true;
                    计划显示格子特效(路径, "778899", 5);
                    const 移动逻辑 = () => {
                        if (!玩家正在钩索 || 路径.length === 0) {
                            玩家正在钩索 = false;
                            clearTimeout(钩索移动定时器);
                            return;
                        }
                        const 步数 = Math.min(5, 路径.length);
                        const 目标节点 = 路径[步数 - 1];
                        if (检查移动可行性(玩家.x, 玩家.y, 目标节点.x, 目标节点.y)) {
                            const 旧X = 玩家.x;
                            const 旧Y = 玩家.y;
                            玩家.x = 目标节点.x;
                            玩家.y = 目标节点.y;
                            路径.splice(0, 步数);
                            const 触发中断 = 处理玩家着陆效果(旧X, 旧Y, 玩家.x, 玩家.y);
                            更新视口();
                            绘制();
                            if(触发中断) {
                                 玩家正在钩索 = false;
                                 clearTimeout(钩索移动定时器);
                                 return;
                            }
                        } else {
                            玩家正在钩索 = false;
                            clearTimeout(钩索移动定时器);
                            return;
                        }
                        钩索移动定时器 = setTimeout(移动逻辑, 80);
                    };
                    移动逻辑();
                }
                get 最终攻击范围() {
                    return this.自定义数据.get("攻击范围");
                }
            }

            class 嗜血战斧 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "嗜血战斧",
                        图标: 图标映射.嗜血战斧,
                        品质: 4,
                        基础攻击力: 12 + (配置.强化 ? 8 : 0),
                        冷却回合: 4,
                        攻击范围: 2,
                        耐久: 配置?.耐久 || 80,
                        强化: 配置?.强化 || false,
                        效果描述: "一把沉重而锋利的战斧，可以劈开坚固的护甲。",
                        ...配置,
                    });
                }
            }
            class 祭坛类 extends 物品 {
                constructor(配置) {
                    super({
                        类型: "祭坛",
                        图标: 图标映射.祭坛,
                        是否正常物品: false,
                        品质: 4,
                        颜色索引: 3,
                        能否拾起: false,
                        数据: {
                            已激活: 配置?.数据?.已激活 || false,
                            激活条件: 配置?.数据?.激活条件 || null,
                            ...配置.数据,
                        },
                        ...配置,
                    });

                    if (!this.自定义数据.get("激活条件")) {
                        const 条件列表 = [
                            { 类型: "献祭生命", 权重: 25 },
                            { 类型: "火焰净化", 权重: 15 },
                            {
                                类型: "力量考验",
                                权重: 20,
                                需求伤害: 50 + Math.floor(Math.random() * 21),
                            },
                            { 类型: "爆炸冲击", 权重: 15 },
                            { 类型: "物品献祭", 权重: 15 },
                            {
                                类型: "能量灌注",
                                权重: 10,
                                能量消耗: 80 + Math.floor(Math.random() * 21),
                            },
                            { 类型: "冰霜封印", 权重: 10 },
                        ];
                        const 选中的条件 = 加权随机选择(条件列表);
                        this.自定义数据.set("激活条件", 选中的条件.类型);
                        if (选中的条件.需求伤害) {
                            this.自定义数据.set(
                                "需求伤害",
                                选中的条件.需求伤害
                            );
                            this.自定义数据.set("当前承受伤害", 0);
                        }
                        if (选中的条件.能量消耗) {
                            this.自定义数据.set(
                                "能量消耗",
                                选中的条件.能量消耗
                            );
                        }
                    }
                }

                尝试互动() {
                    if (this.自定义数据.get("已激活")) {
                        显示通知("这个祭坛的力量已经耗尽。", "信息");

                        return false;
                    }

                    const 条件 = this.自定义数据.get("激活条件");
                    let 提示信息 = `一个古老的祭坛，上面刻着奇怪的符号：`;

                    switch (条件) {
                        case "献祭生命":
                            提示信息 += `\n“以汝之血，换汝新生。”<br>提示：需要献祭大量生命`;
                            if (confirm(提示信息.replace(/<br>/g, "\n"))) {
                                this.激活();
                            }
                            break;
                        case "火焰净化":
                            提示信息 += `\n“烈焰红火，洗褪尘埃。”<br>提示：需要用火焰灼烧`;
                            显示通知(提示信息, "信息", true, 3000);
                            break;
                        case "冰霜封印":
                            提示信息 += `\n“寒冰凝结，封印之力。”<br>提示：需要用冰霜武器冲击`;
                            显示通知(提示信息, "信息", true, 3000);
                            break;
                        case "力量考验":
                            const 需求伤害 = this.自定义数据.get("需求伤害");
                            const 当前伤害 =
                                this.自定义数据.get("当前承受伤害") || 0;
                            提示信息 += `\n“力量击破障碍，火力带来胜利。”<br>提示：需要对祭坛造成足够伤害 (${当前伤害}/${需求伤害})。`;
                            显示通知(提示信息, "信息", true, 3000);
                            break;
                        case "爆炸冲击":
                            提示信息 += `\n“破碎带来重组，毁灭孕育机遇。”<br>提示：需要用剧烈的爆炸冲击`;
                            显示通知(提示信息, "信息", true, 3000);
                            break;
                        case "物品献祭":
                            提示信息 += `\n“等价交换，世间真理。”<br>提示：需要扣除背包中的物品`;
                            if (confirm(提示信息.replace(/<br>/g, "\n"))) {
                                this.激活();
                            }
                            break;
                        case "能量灌注":
                            const 能量消耗 = this.自定义数据.get("能量消耗");
                            提示信息 += `\n“以意志之能量，闯浩瀚之云天。”<br>提示：需要灌注 ${能量消耗} 点能量`;
                            if (confirm(提示信息.replace(/<br>/g, "\n"))) {
                                this.激活();
                            }
                            break;
                        default:
                            显示通知(提示信息, "信息", true, 3000);
                    }
                    return false;
                }

                当被攻击(伤害, 来源) {
                    if (this.自定义数据.get("已激活")) return;
                    const 条件 = this.自定义数据.get("激活条件");

                    if (条件 === "力量考验") {
                        let 当前伤害 = this.自定义数据.get("当前承受伤害") || 0;
                        当前伤害 += 伤害;
                        this.自定义数据.set("当前承受伤害", 当前伤害);

                        计划显示格子特效(
                            [{ x: this.x, y: this.y }],
                            "FFD700",
                            50
                        );

                        const 需求伤害 = this.自定义数据.get("需求伤害");
                        if (当前伤害 >= 需求伤害) {
                            this.激活();
                        } else {
                            显示通知(
                                `祭坛吸收了你的力量... (${Math.floor(
                                    当前伤害
                                )}/${需求伤害})`,
                                "信息"
                            );
                        }
                    }
                }

                激活() {
                    if (this.自定义数据.get("已激活")) return false;

                    const 条件 = this.自定义数据.get("激活条件");
                    switch (条件) {
                        case "献祭生命":
                            const 当前生命 =
                                parseFloat(
                                    document.querySelector(".health-bar").style
                                        .width
                                ) || 0;
                            if (当前生命 > 75) {
                                伤害玩家(75, this.名称);
                            } else {
                                显示通知("血量不足，无法献祭！", "错误");
                                return false;
                            }
                            break;
                        case "物品献祭":
                            const 可献祭物品 = [...玩家背包.values()].filter(
                                (item) =>
                                    item.是否正常物品 &&
                                    !item.是否隐藏 &&
                                    item.类型 !== "钥匙" &&
                                    item.类型 !== "金币"
                            );
                            if (可献祭物品.length === 0) {
                                显示通知("背包中没有可献祭的物品！", "错误");
                                return false;
                            }
                            const 随机物品 =
                                可献祭物品[
                                    Math.floor(
                                        Math.random() * 可献祭物品.length
                                    )
                                ];
                            显示通知(
                                `你献祭了 ${随机物品.获取名称()}...`,
                                "信息"
                            );
                            处理销毁物品(随机物品.唯一标识, true);
                            break;
                        case "能量灌注":
                            if (!扣除能量(this.自定义数据.get("能量消耗"))) {
                                显示通知("能量不足，无法激活祭坛！", "错误");
                                return false;
                            }
                            break;
                    }

                    this.自定义数据.set("已激活", true);
                    this.图标 = "◎";
                    this.颜色索引 = 颜色表.length;
                    this.效果描述 = "祭坛的力量已经耗尽。";
                    计划显示格子特效([{ x: this.x, y: this.y }], "00FF00", 0);
                    显示通知(`${this.名称}被激活了！`, "成功");

                    this.给予奖励();

                    return true;
                }

                给予奖励() {}

                获取提示() {
                    if (this.自定义数据.get("已激活")) {
                        return `${this.名称}\n力量已经耗尽。`;
                    }
                    const 条件 = this.自定义数据.get("激活条件");
                    let 提示 = `${this.名称}\n一个散发着微光的古老祭坛。\n激活条件：`;
                    switch (条件) {
                        case "献祭生命":
                            提示 += "献祭生命";
                            break;
                        case "火焰净化":
                            提示 += "火焰净化";
                            break;
                        case "冰霜封印":
                            提示 += "冰霜封印";
                            break;
                        case "力量考验":
                            提示 += `力量考验 (${
                                this.自定义数据.get("当前承受伤害") || 0
                            }/${this.自定义数据.get("需求伤害")})`;
                            break;
                        case "爆炸冲击":
                            提示 += "爆炸冲击";
                            break;
                        case "物品献祭":
                            提示 += "物品献祭";
                            break;
                        case "能量灌注":
                            提示 += `能量灌注 (${this.自定义数据.get(
                                "能量消耗"
                            )})`;
                            break;
                        default:
                            提示 += "未知";
                    }
                    return 提示;
                }
            }
            class 物品祭坛 extends 祭坛类 {
                constructor(配置) {
                    super({
                        名称: "物品祭坛",
                        效果描述: "激活后获得一件强大的物品！",
                        数据: {
                            库存: 配置?.数据?.库存 || [],
                            ...配置.数据,
                        },
                    });

                    if (
                        !this.自定义数据.get("已激活") &&
                        this.自定义数据.get("库存").length === 0
                    ) {
                        let 已选中 = false;
                        let 尝试次数 = 0;
                        if (!配置.库存物品) {
                            while (!已选中 && 尝试次数 < 100) {
                                已选中 = this.生成库存();
                                尝试次数++;
                            }
                        }
                    }
                }

                给予奖励() {
                    const 库存 = this.自定义数据.get("库存");
                    if (库存.length > 0) {
                        const 奖励物品 = 库存.shift();
                        if (尝试收集物品(奖励物品, false)) {
                            显示通知("你从祭坛获得了奖励！", "成功");
                        } else {
                            this.自定义数据.get("库存").unshift(奖励物品);
                            显示通知("背包已满，奖励无法领取！", "错误");
                        }
                    } else {
                        显示通知("祭坛中空空如也...", "信息");
                    }
                }

                生成库存() {
                    this.自定义数据.set("库存", []);
                    const 候选物品 = Object.values(物品池)
                        .flat()
                        .filter((itemCfg) => {
                            const 临时实例 = new itemCfg.类({ 库存物品: true });
                            return 临时实例.类型 !== "工具";
                        });
                    if (候选物品.length === 0) return false;
                    const 物品实例 = new 候选物品[
                        Math.floor(Math.random() * 候选物品.length)
                    ].类({ 强化: true, 已解锁: true });
                    if (
                        物品实例.是否正常物品 &&
                        !(物品实例 instanceof 神秘商人) &&
                        物品实例.类型 !== "工具"
                    ) {
                        this.自定义数据.get("库存").push(物品实例);
                        return true;
                    }
                    return false;
                }
            }

            class 耐久祭坛 extends 祭坛类 {
                constructor(配置) {
                    super({
                        名称: "耐久祭坛",
                        效果描述: "激活后修复所有已装备物品的耐久。",
                        ...配置,
                    });
                }

                给予奖励() {
                    let 修复发生 = false;
                    Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                        玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                    )
                        .filter((v) => v != null)
                        .forEach((装备) => {
                            if (装备.自定义数据.get("原耐久")) {
                                装备.自定义数据.set(
                                    "耐久",
                                    装备.自定义数据.get("原耐久")
                                );
                                修复发生 = true;
                            }
                        });

                    if (修复发生) {
                        显示通知("所有装备的耐久都已完全恢复！", "成功");
                        更新装备显示();
                    } else {
                        显示通知("你没有需要修复的装备。", "信息");
                    }
                }
            }

            class 背包扩容祭坛 extends 祭坛类 {
                constructor(配置) {
                    super({
                        名称: "背包扩容祭坛",
                        效果描述: "激活后永久扩展你的背包容量！",
                        数据: {
                            扩容量: 2,
                            最大扩展至: 24,
                            ...配置.数据,
                        },
                    });
                }

                给予奖励() {
                    if (最大背包容量 >= this.自定义数据.get("最大扩展至")) {
                        显示通知("你的背包已经足够大了，无法再扩展。", "信息");
                        return;
                    }
                    最大背包容量 = Math.min(
                        this.自定义数据.get("最大扩展至"),
                        最大背包容量 + this.自定义数据.get("扩容量")
                    );
                    document.getElementById("最大容量").textContent =
                        最大背包容量;
                    更新背包显示();
                    显示通知(`背包容量已扩展至 ${最大背包容量}！`, "成功");
                }
            }
            class 灵能盾牌 extends 防御装备类 {
                constructor(配置 = {}) {
                    super({
                        名称: "灵能盾牌",
                        图标: 图标映射.灵能盾牌,
                        品质: 3,
                        颜色索引: 4,
                        防御力: 1 + (配置.强化 ? 1 : 0),
                        耐久: 配置.耐久 || 80 + (配置.强化 ? 40 : 0),
                        原耐久: 配置.原耐久 || 80 + (配置.强化 ? 40 : 0),
                        强化: 配置.强化 || false,
                        效果描述: "受击时概率恢复能量或闪避攻击。",
                        不可破坏: 配置.不可破坏 || false,
                        附魔: 配置.附魔 || [],
                        数据: {
                            能量恢复概率: 0.25 + (配置.强化 ? 0.1 : 0),
                            能量恢复量: 10 + (配置.强化 ? 5 : 0),
                            闪避触发概率: 0.15 + (配置.强化 ? 0.1 : 0),
                        },
                        ...配置,
                    });
                }

                当被攻击(原始攻击力, 来源 = null) {
                    let 剩余伤害 = super.当被攻击(原始攻击力, 来源);
                    if (Math.random() < this.自定义数据.get("能量恢复概率")) {
                        const 恢复量 = this.自定义数据.get("能量恢复量");
                        const 能量条 = document.querySelector(".power-bar");
                        const 当前能量 = parseFloat(能量条.style.width) || 0;
                        能量条.style.width = `${Math.min(
                            100,
                            当前能量 + 恢复量
                        )}%`;
                        触发HUD显示();
                    }

                    if (Math.random() < this.自定义数据.get("闪避触发概率")) {
                        显示通知("灵能盾牌闪避！", "成功");
                        添加日志(
                            `成功闪避了来自 ${
                                来源 instanceof 怪物
                                    ? 来源.类型
                                    : 来源 || "未知来源"
                            } 的攻击！`,
                            "成功"
                        );
                        触发HUD显示();
                        return 0;
                    }
                    return 剩余伤害;
                }

                获取提示() {
                    let lines = super.获取提示().split("\n");
                    const effectDescIndex = lines.findIndex((line) =>
                        line.startsWith("效果描述：")
                    );
                    if (effectDescIndex !== -1) {
                        lines.splice(effectDescIndex, 1); // Remove the generic description
                    }

                    const 能量概率 = (
                        this.自定义数据.get("能量恢复概率") * 100
                    ).toFixed(0);
                    const 能量恢复 = this.自定义数据.get("能量恢复量");
                    const 闪避概率 = (
                        this.自定义数据.get("闪避触发概率") * 100
                    ).toFixed(0);

                    const specificEffectLines = [
                        `--- 特殊效果 ---`,
                        `能量恢复：${能量概率}%几率恢复 ${能量恢复} 点`,
                        `灵体闪避：${闪避概率}%几率完全闪避攻击`,
                    ];

                    let insertIndex = lines.findIndex((line) =>
                        line.startsWith("--- 强化效果 ---")
                    );
                    if (insertIndex === -1) {
                        insertIndex = lines.findIndex((line) =>
                            line.startsWith("耐久：")
                        );
                    }
                    if (insertIndex === -1) {
                        insertIndex = lines.length;
                    }
                    lines.splice(insertIndex, 0, ...specificEffectLines);

                    return lines.filter(Boolean).join("\n");
                }
            }
            class 毒液物品 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: "毒液",
                        图标: 图标映射.毒液,
                        品质: 1,
                        颜色索引: 效果名称编号映射.中毒,
                        最大堆叠数量: 1,
                        能否拾起: true,
                        阻碍怪物: false,
                        是否正常物品: false,
                        是否为隐藏物品: false,
                        效果描述: "一滩剧毒的液体，接触会中毒。",
                        数据: {
                            倒计时: 配置.倒计时 || 5 + (配置.强化 ? 3 : 0),
                            爆炸时间: 5 + (配置.强化 ? 3 : 0),
                            中毒强度: 1 + (配置.强化 ? 2 : 0),
                            中毒持续: 4,
                            ...配置.数据,
                        },
                        ...配置,
                    });
                    if (!所有计时器.some((t) => t.唯一标识 === this.唯一标识)) {
                        所有计时器.push(this);
                    }
                }

                使用() {
                    return false;
                }

                当被收集(进入者) {
                    if (进入者 !== "玩家") return;
                    new 状态效果(
                        "中毒",
                        this.获取毒液颜色(),
                        "☠️",
                        this.自定义数据.get("中毒持续"),
                        null,
                        null,
                        null,
                        this.自定义数据.get("中毒强度")
                    );
                    添加日志("你踩到了毒液，中毒了！", "错误");
                    this.移除自身();
                    return false;
                }

                更新倒计时() {
                    const 剩余回合 = this.自定义数据.get("倒计时");
                    if (剩余回合 <= 0) {
                        this.移除自身();
                    } else {
                        this.自定义数据.set("倒计时", 剩余回合 - 1);
                    }
                }

                移除自身() {
                    if (
                        this.x !== null &&
                        this.y !== null &&
                        地牢[this.y]?.[this.x]?.关联物品 === this
                    ) {
                        地牢[this.y][this.x].关联物品 = null;
                        if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品)
                            地牢[this.y][this.x].类型 = null;
                    }
                    所有计时器 = 所有计时器.filter((item) => item !== this);
                    绘制();
                }

                获取提示() {
                    return `【毒液】\n剩余: ${this.自定义数据.get(
                        "倒计时"
                    )}回合\n接触会中毒(${this.自定义数据.get(
                        "中毒强度"
                    )}伤害/回合)`;
                }

                获取毒液颜色() {
                    return 效果颜色编号映射[this.颜色索引] || "#008000";
                }

                get 颜色表() {
                    return 效果颜色编号映射;
                }
            }
            class 宠物 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "宠物",
                        名称: 配置.名称 || "宠物",
                        图标: 配置.图标 || 图标映射.宠物,
                        品质: 配置.品质 || 3,
                        颜色索引: 配置.颜色索引 || 2,
                        最大堆叠数量: 1,
                        堆叠数量: 配置.堆叠数量 || 1,
                        效果描述: 配置.效果描述 || "一只忠诚的伙伴。",
                        强化: 配置.强化 || false,
                        数据: {
                            等级: 配置.等级 || 1,
                            当前生命值:
                                配置.当前生命值 || 配置.最大生命值 || 100,
                            最大生命值: 配置.最大生命值 || 100,
                            基础攻击力: 配置.基础攻击力 || 5,
                            基础防御力: 配置.基础防御力 || 2,
                            经验值: 配置.经验值 || 0,
                            升级所需经验: 配置.升级所需经验 || 20,
                            升级所需金币: 配置.升级所需金币 || 30,
                            技能: 配置.技能 || [], // { 名称: "", 等级: 1, 描述: "" }
                            装备: {}, // "武器": 物品实例, "防具": 物品实例
                            休眠中: false,
                            每移动恢复量: 配置.每移动恢复量 || 1,
                            ...配置.数据,
                        },
                    });
                    if (this.强化) {
                        this.自定义数据.set(
                            "升级所需金币",
                            Math.round(
                                this.自定义数据.get("升级所需金币") * 0.5
                            )
                        );
                        this.自定义数据.set(
                            "升级所需经验",
                            Math.round(
                                this.自定义数据.get("升级所需经验") * 0.5
                            )
                        );
                    }
                }

                当玩家攻击(目标怪物列表) {
                    if (this.自定义数据.get("休眠中")) return;

                    this.攻击(目标怪物列表);

                    const 武器 = this.自定义数据.get("装备")?.武器;
                    if (
                        武器 &&
                        武器.堆叠数量 > 0 &&
                        武器.自定义数据.get("冷却剩余") == 0
                    ) {
                        const { 怪物, 路径 } = 获取周围怪物(
                            武器.自定义数据.get("攻击目标数"),
                            武器.最终攻击范围
                        );
                        if (怪物 !== null) {
                            if (武器.使用(怪物, 路径)) {
                                路径.forEach((攻击路径) =>
                                    计划显示格子特效(攻击路径)
                                );
                            }
                        }
                    }
                    this.触发技能("攻击", 目标怪物列表);
                }

                攻击(目标怪物列表) {
                    const 总伤害 = this.自定义数据.get("基础攻击力");
                    目标怪物列表.forEach((怪物) => {
                        if (怪物.当前生命值 > 0) 怪物.受伤(总伤害, this); // 伤害来源改为宠物实例
                    });
                    显示通知(
                        `${this.名称}发起攻击，造成了${总伤害}点伤害`,
                        "成功"
                    );
                }

                // 当玩家被攻击时触发 (需要传入攻击力和攻击来源)
                当玩家被攻击(原始攻击力, 来源) {
                    if (this.自定义数据.get("休眠中")) return 原始攻击力;

                    let 最终攻击力 = 原始攻击力;

                    // 宠物装备的防具效果
                    const 防具 = this.自定义数据.get("装备")?.防具;
                    if (防具) {
                        最终攻击力 = 防具.当被攻击(最终攻击力, 来源);
                    }

                    // 宠物自身防御
                    最终攻击力 = Math.max(
                        0,
                        最终攻击力 - this.自定义数据.get("基础防御力")
                    );
                    if (最终攻击力 <= 0)
                        最终攻击力 = Math.round(Math.random() * 100) / 100;

                    const 承担比例 = 0.3;
                    const 宠物承担伤害 = Math.ceil(最终攻击力 * 承担比例);
                    this.受伤(宠物承担伤害);

                    // 触发宠物技能 (被攻击时)
                    this.触发技能("被攻击", 来源);
                    return 最终攻击力 * (1 - 承担比例);
                }

                受伤(伤害值) {
                    let 当前生命值 = this.自定义数据.get("当前生命值");
                    当前生命值 = Math.max(0, 当前生命值 - 伤害值);
                    this.自定义数据.set("当前生命值", 当前生命值);
                    this.更新宠物管理窗口();
                    if (当前生命值 <= 0) {
                        this.进入休眠();
                    }
                }

                进入休眠() {
                    this.自定义数据.set("休眠中", true);
                    显示通知(`${this.名称}生命值过低，进入休眠！`, "警告");
                }

                // 移动玩家调用
                恢复生命值() {
                    if (!this.自定义数据.get("休眠中")) return;

                    let 当前生命值 = this.自定义数据.get("当前生命值");
                    const 最大生命值 = this.自定义数据.get("最大生命值");
                    const 时间加速 = 当前激活卷轴列表.has(Array.from(当前激活卷轴列表).find(item => item instanceof 时间卷轴));
                    const 基础恢复量 = this.自定义数据.get("每移动恢复量");
                    const 恢复量 = 时间加速 ? 基础恢复量 * 2 : 基础恢复量;
                    当前生命值 = Math.min(最大生命值, 当前生命值 + 恢复量);
                    this.自定义数据.set("当前生命值", 当前生命值);
                    this.更新宠物管理窗口();
                    if (
                        当前生命值 >= 最大生命值 &&
                        this.自定义数据.get("休眠中")
                    ) {
                        this.自定义数据.set("休眠中", false);
                        显示通知(`${this.名称}已恢复，退出休眠！`, "成功");
                    }
                }
                //子类自行升级技能
                升级() {
                    const 当前等级 = this.自定义数据.get("等级");
                    const 升级所需金币 = this.自定义数据.get("升级所需金币");
                    if (
                        this.自定义数据.get("升级所需经验") <=
                        this.自定义数据.get("经验值")
                    ) {
                        if (扣除金币(升级所需金币)) {
                            this.自定义数据.set("等级", 当前等级 + 1);
                            this.自定义数据.set(
                                "最大生命值",
                                this.自定义数据.get("最大生命值") + 20
                            );
                            this.自定义数据.set(
                                "当前生命值",
                                this.自定义数据.get("最大生命值")
                            ); // 升级后回满血
                            this.自定义数据.set(
                                "基础攻击力",
                                this.自定义数据.get("基础攻击力") + 2
                            );
                            this.自定义数据.set(
                                "基础防御力",
                                this.自定义数据.get("基础防御力") + 1
                            );

                            // 增加升级所需经验和金币
                            this.自定义数据.set(
                                "升级所需经验",
                                Math.floor(
                                    this.自定义数据.get("升级所需经验") * 1.5
                                )
                            );
                            this.自定义数据.set(
                                "升级所需金币",
                                Math.floor(
                                    this.自定义数据.get("升级所需金币") * 1.2
                                )
                            );
                            显示通知(`${this.名称}升级成功！`, "成功");
                            this.更新宠物管理窗口();
                            return true;
                        } else {
                            显示通知("金币不足，无法升级！", "错误");
                            return false;
                        }
                    } else {
                        显示通知("经验不足，无法升级！", "错误");
                        return false;
                    }
                }

                获得经验(经验值) {
                    let 当前经验 = this.自定义数据.get("经验值") + 经验值;
                    this.自定义数据.set("经验值", 当前经验);
                }

                装备物品(物品, 槽位) {
                    if (槽位 !== "武器" && 槽位 !== "防具") {
                        显示通知("无效的宠物装备槽位", "错误");
                        return;
                    }
                    if (
                        (槽位 === "武器" && !(物品 instanceof 武器类)) ||
                        (槽位 === "防具" && !(物品 instanceof 防御装备类))
                    ) {
                        显示通知("该物品不能装备到此槽位", "错误");
                        return;
                    }

                    // 该槽位已有装备，先卸下
                    if (this.自定义数据.get("装备")[槽位]) {
                        this.卸下装备(槽位);
                    }
                    物品.是否隐藏 = true;
                    卸下装备槽物品(物品.装备槽位); //内部会调用 更新背包显示

                    this.自定义数据.get("装备")[槽位] = 物品;
                    显示通知(`${this.名称}装备了${物品.获取名称()}`, "成功");
                    this.更新宠物管理窗口();
                }

                卸下装备(槽位) {
                    const 装备 = this.自定义数据.get("装备");
                    if (
                        装备 &&
                        装备[槽位] &&
                        [...玩家背包.values()].reduce(
                            (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
                            0
                        ) < 最大背包容量
                    ) {
                        const 卸下物品 = 装备[槽位];
                        装备[槽位] = null;
                        卸下物品.是否隐藏 = false;
                        显示通知(
                            `${this.名称}卸下了${卸下物品.获取名称()}`,
                            "成功"
                        );
                        this.自定义数据.set("装备", 装备);
                        this.更新宠物管理窗口();
                        更新背包显示();
                    } else {
                        显示通知("背包已满！", "错误");
                    }
                }

                // (时机: "攻击" 或 "被攻击")
                触发技能(时机, 额外参数) {
                    const 技能列表 = this.自定义数据.get("技能");
                    if (!技能列表) return;

                    技能列表.forEach((技能) => {
                        if (技能.时机 === 时机 && Math.random() > 0.5) {
                            this.技能效果[技能.索引](this, 额外参数);
                        }
                    });
                }

                使用() {
                    this.打开宠物管理窗口();
                    return true;
                }

                打开宠物管理窗口() {
                    if (界面可见性.背包) 切换背包显示();
                    玩家属性.允许移动 += 1;
                    if (window.宠物管理窗口) {
                        显示通知("一次只能打开一个宠物管理窗口", "错误");
                        玩家属性.允许移动 -= 1;
                        return;
                    }
                    const 窗口 = document.createElement("div");
                    窗口.className = "宠物管理窗口";
                    window.宠物管理窗口 = 窗口;

                    const 基本信息面板 = this.创建基本信息面板();
                    const 装备面板 = this.创建装备面板();
                    const 技能面板 = this.创建技能面板();

                    const 升级按钮 = document.createElement("button");
                    升级按钮.className = "通用按钮"; // 使用通用按钮样式
                    升级按钮.textContent = `升级宠物（${this.自定义数据.get(
                        "升级所需金币"
                    )} 金币 ${this.自定义数据.get("升级所需经验")} EXP）`;
                    升级按钮.addEventListener("click", () => {
                        this.升级();
                        this.更新基本信息面板(基本信息面板); // 更新信息
                        升级按钮.textContent = `升级宠物（${this.自定义数据.get(
                            "升级所需金币"
                        )} 金币 ${this.自定义数据.get("升级所需经验")} EXP）`;
                    });

                    const 关闭按钮 = document.createElement("button");
                    关闭按钮.className = "关闭按钮";
                    关闭按钮.textContent = "×";
                    关闭按钮.onclick = () => {
                        // 添加关闭动画
                        窗口.style.transform =
                            "translate(-50%, -50%) scale(0.9)";
                        窗口.style.opacity = 0;
                        setTimeout(() => {
                            玩家属性.允许移动 -= 1;
                            窗口.remove();
                        }, 300);
                        window.宠物管理窗口 = null;
                    };

                    窗口.appendChild(关闭按钮);
                    窗口.appendChild(基本信息面板);
                    窗口.appendChild(装备面板);
                    窗口.appendChild(技能面板);
                    窗口.appendChild(升级按钮);

                    document.body.appendChild(窗口);
                }

                更新宠物管理窗口() {
                    if (!window.宠物管理窗口) return;
                    const 基本信息面板 =
                        window.宠物管理窗口.querySelector(".宠物基本信息面板");
                    if (基本信息面板) this.更新基本信息面板(基本信息面板);
                    const 装备面板 =
                        window.宠物管理窗口.querySelector(".宠物装备面板");
                    if (装备面板) {
                        装备面板.innerHTML = "";
                        装备面板.appendChild(this.创建装备面板());
                    }
                }

                创建基本信息面板() {
                    const 面板 = document.createElement("div");
                    面板.className = "宠物基本信息面板";
                    this.更新基本信息面板(面板);
                    return 面板;
                }

                更新基本信息面板(面板) {
                    const data = this.自定义数据;
                    面板.innerHTML = `
            <h3>${this.名称} (等级 ${data.get("等级")})</h3>
            <p>生命值: ${data.get("当前生命值")} / ${data.get("最大生命值")}</p>
            <p>攻击力: ${this.自定义数据.get("基础攻击力")}</p>
            <p>防御力: ${this.自定义数据.get("基础防御力")}</p>
            <p>经验值: ${data.get("经验值")} / ${data.get("升级所需经验")}</p>
            <P>升级所需金币：${data.get("升级所需金币")}</P>
            <p>状态: ${data.get("休眠中") ? "休眠中" : "活跃"}</p>
        `;
                }

                创建装备面板() {
                    const 面板 = document.createElement("div");
                    面板.className = "宠物装备面板";
                    面板.innerHTML = "<h4>装备</h4>";

                    const 武器槽 = this.创建装备槽("武器");
                    const 防具槽 = this.创建装备槽("防具");

                    面板.appendChild(武器槽);
                    面板.appendChild(防具槽);
                    return 面板;
                }

                创建装备槽(槽位类型) {
                    const 槽 = document.createElement("div");
                    槽.className = "宠物装备槽";
                    槽.dataset.槽位 = 槽位类型;

                    const 槽位名 = document.createElement("span");
                    槽位名.className = "宠物装备槽位名";
                    槽位名.textContent = 槽位类型;
                    槽.appendChild(槽位名);

                    const 已装备物品 = this.自定义数据.get("装备")[槽位类型];
                    if (已装备物品) {
                        const 物品元素 = this.创建装备物品元素(已装备物品);
                        槽.appendChild(物品元素);
                    } else {
                        const 选择按钮 = document.createElement("button");
                        选择按钮.className = "通用按钮";
                        选择按钮.textContent = `选择${槽位类型}`;
                        选择按钮.addEventListener("click", () =>
                            this.显示装备选择(槽位类型)
                        );
                        槽.appendChild(选择按钮);
                    }
                    return 槽;
                }

                创建装备物品元素(物品) {
                    const 元素 = document.createElement("div");
                    元素.className = "宠物已装备物品";

                    const 图标 = document.createElement("span");
                    图标.className = "宠物装备图标";
                    图标.textContent = 物品.图标;
                    图标.style.color = 物品.颜色表[物品.颜色索引];

                    const 名称 = document.createElement("span");
                    名称.className = "宠物装备名称";
                    名称.textContent = 物品.获取名称();

                    const 卸下按钮 = document.createElement("button");
                    卸下按钮.className = "通用按钮";
                    卸下按钮.textContent = "卸下";
                    卸下按钮.addEventListener("click", () => {
                        this.卸下装备(物品.类型 === "武器" ? "武器" : "防具"); // 卸下装备
                        this.更新宠物管理窗口();
                    });

                    元素.appendChild(图标);
                    元素.appendChild(名称);
                    元素.appendChild(卸下按钮);
                    return 元素;
                }

                显示装备选择(槽位类型) {
                    const 遮罩 = document.createElement("div");
                    遮罩.className = "宠物装备选择遮罩";

                    const 弹窗 = document.createElement("div");
                    弹窗.className = "宠物装备选择弹窗";

                    const 标题 = document.createElement("h4");
                    标题.textContent = `选择${槽位类型}`;
                    弹窗.appendChild(标题);

                    const 物品列表 = document.createElement("div");
                    物品列表.className = "宠物装备选择列表";

                    const 可用装备 = [...玩家背包.values()].filter(
                        (物品) =>
                            (槽位类型 === "武器" && 物品 instanceof 武器类) ||
                            (槽位类型 === "防具" && 物品 instanceof 防御装备类)
                    );

                    if (可用装备.length === 0) {
                        const 提示 = document.createElement("div");
                        提示.className = "无装备提示";
                        提示.textContent = `无可用${槽位类型}装备`;
                        物品列表.appendChild(提示);
                    } else {
                        可用装备.forEach((物品) => {
                            const 物品元素 = this.创建可选装备元素(
                                物品,
                                槽位类型
                            );
                            物品列表.appendChild(物品元素);
                        });
                    }

                    弹窗.appendChild(物品列表);

                    const 关闭按钮 = document.createElement("button");
                    关闭按钮.className = "关闭按钮";
                    关闭按钮.textContent = "×";
                    关闭按钮.onclick = () => {
                        弹窗.style.transform =
                            "translate(-50%, -50%) scale(0.9)";
                        弹窗.style.opacity = 0;
                        setTimeout(() => {
                            遮罩.remove();
                        }, 300);
                    };
                    弹窗.appendChild(关闭按钮);

                    遮罩.appendChild(弹窗);
                    document.querySelector(".宠物管理窗口").appendChild(遮罩);
                }

                创建可选装备元素(物品, 槽位类型) {
                    const 元素 = document.createElement("div");
                    元素.className = "宠物可选装备";

                    const 图标 = document.createElement("span");
                    图标.className = "宠物可选装备图标";
                    图标.textContent = 物品.图标;
                    图标.style.color = 物品.颜色表[物品.颜色索引];

                    const 名称 = document.createElement("span");
                    名称.className = "宠物可选装备名称";
                    名称.textContent = 物品.获取名称();

                    const 选择按钮 = document.createElement("button");
                    选择按钮.className = "宠物装备选择确认按钮";
                    选择按钮.textContent = "选择";
                    选择按钮.addEventListener("click", () => {
                        this.装备物品(物品, 槽位类型);
                        let 弹窗 = document.querySelector(".宠物装备选择弹窗");
                        弹窗.style.transform =
                            "translate(-50%, -50%) scale(0.9)";
                        弹窗.style.opacity = 0;
                        setTimeout(() => {
                            document
                                .querySelector(".宠物装备选择遮罩")
                                .remove();
                        }, 300);
                        更新装备显示();
                        更新背包显示();
                    });

                    元素.appendChild(图标);
                    元素.appendChild(名称);
                    元素.appendChild(选择按钮);
                    return 元素;
                }

                创建技能面板() {
                    const 面板 = document.createElement("div");
                    面板.className = "宠物技能面板";
                    面板.innerHTML = "<h4>技能</h4>";

                    const 技能列表 = this.自定义数据.get("技能");
                    if (技能列表 && 技能列表.length > 0) {
                        技能列表.forEach((技能) => {
                            const 技能元素 = document.createElement("div");
                            技能元素.className = "宠物技能";
                            技能元素.innerHTML = `
                    <p><strong>${技能.名称}</strong> (等级 ${技能.等级})</p>
                    <p>${技能.描述}</p>
                `;
                            面板.appendChild(技能元素);
                        });
                    } else {
                        面板.innerHTML += "<p>暂无技能</p>";
                    }
                    return 面板;
                }

                获取提示() {
                    const data = this.自定义数据;
                    const 装备 = data.get("装备");
                    const 武器 = 装备?.武器 ? 装备.武器.获取名称() : "无";
                    const 防具 = 装备?.防具 ? 装备.防具.获取名称() : "无";

                    return [
                        `${this.获取名称()} (等级 ${data.get("等级")})`,
                        `类型：${this.类型}`,
                        `品质：${"★".repeat(this.品质)}`,
                        `生命值: ${data.get("当前生命值")} / ${data.get(
                            "最大生命值"
                        )}`,
                        `武器: ${武器}`,
                        `防具: ${防具}`,
                        `${this.效果描述}`,
                    ].join("\n");
                }
            }
            class 熊猫 extends 宠物 {
                constructor(配置 = {}) {
                    super({
                        名称: "熊猫",
                        图标: 图标映射.熊猫,
                        品质: 3,
                        颜色索引: 2,
                        效果描述:
                            "来自神秘竹林的守护者，擅长竹叶飞刀和强力防御。",
                        基础攻击力: 1,
                        基础防御力: 2,
                        最大生命值: 30,
                        强化: 配置.强化 || false,
                        技能: [
                            {
                                名称: "竹叶飞刀",
                                等级: 1,
                                描述: "投掷锋利的竹叶，对单个敌人造成伤害。伤害随技能等级提升。",
                                时机: "攻击",
                                索引: 0,
                            },
                            {
                                名称: "金钟罩",
                                等级: 1,
                                描述: "受到攻击时有几率触发金钟罩，使攻击来源攻击力下降。抵挡比例随技能等级提升。",
                                时机: "被攻击",
                                索引: 1,
                            },
                        ],
                    });
                    this.技能效果 = [
                        function (宠物, 目标怪物列表) {
                            if (!目标怪物列表 || 目标怪物列表.length === 0)
                                return;
                            const 技能等级 =
                                宠物.自定义数据.get("技能")[0].等级; // 获取第一个技能的等级
                            const 基础伤害 = 1;
                            const 伤害 = 基础伤害 + 技能等级 * 3;

                            // 随机选择一个目标
                            const 目标 =
                                目标怪物列表[
                                    Math.floor(
                                        Math.random() * 目标怪物列表.length
                                    )
                                ];
                            目标.受伤(伤害, 宠物);
                            添加日志(
                                `${宠物.名称}使用了竹叶飞刀！造成了 ${伤害} 点伤害`,
                                "成功"
                            );
                        },
                        function (宠物, 来源) {
                            const 技能等级 =
                                宠物.自定义数据.get("技能")[1].等级; // 获取第二个技能的等级
                            const 基础格挡率 = 0.15;
                            const 格挡率 = Math.min(
                                0.85,
                                基础格挡率 + (技能等级 - 1) * 0.05
                            );

                            if (
                                Math.random() < 格挡率 &&
                                来源 instanceof 怪物
                            ) {
                                // 触发格挡
                                const 基础减伤 = 0.8;
                                const 减伤比例 = Math.min(
                                    0,
                                    基础减伤 - 技能等级 * 0.05
                                );
                                来源.基础攻击力 = Math.floor(
                                    来源.基础攻击力 * 减伤比例
                                ); //修改攻击者的基础攻击力
                                添加日志(`${宠物.名称}触发了金钟罩！`, "成功");
                            }
                        },
                    ];
                }

                升级() {
                    const 升级成功 = super.升级();
                    if (升级成功) {
                        const 技能列表 = this.自定义数据.get("技能");
                        if (技能列表) {
                            // 随机升级一个技能
                            const 随机技能索引 = Math.floor(
                                Math.random() * 技能列表.length
                            );
                            技能列表[随机技能索引].等级 += 1;
                            显示通知(
                                `${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`,
                                "成功"
                            );
                            window.宠物管理窗口.querySelector(
                                ".宠物技能面板"
                            ).innerHTML = "";
                            window.宠物管理窗口
                                .querySelector(".宠物技能面板")
                                .appendChild(this.创建技能面板());
                        }
                    }
                    return 升级成功;
                }

                当玩家被攻击(原始攻击力, 来源) {
                    if (this.自定义数据.get("休眠中")) return 原始攻击力;

                    let 最终攻击力 = 原始攻击力;

                    // 宠物装备的防具效果
                    const 防具 = this.自定义数据.get("装备")?.防具;
                    if (防具) {
                        最终攻击力 = 防具.当被攻击(最终攻击力, 来源);
                    }

                    最终攻击力 = Math.max(
                        0,
                        最终攻击力 - this.自定义数据.get("基础防御力")
                    );
                    if (最终攻击力 <= 0)
                        最终攻击力 = Math.round(Math.random() * 100) / 100;
                    const 承担比例 = 0.3;
                    const 宠物承担伤害 = Math.floor(最终攻击力 * 承担比例);
                    this.受伤(宠物承担伤害);
                    最终攻击力 -= 宠物承担伤害;

                    this.触发技能("被攻击", 来源);
                    return 最终攻击力;
                }
            }
            class 水母 extends 宠物 {
                constructor(配置 = {}) {
                    super({
                        名称: "水母",
                        图标: 图标映射.水母,
                        品质: 4,
                        颜色索引: 3,
                        效果描述:
                            "来自虚空的神秘生物，可以扭曲空间，并拥有强大的精神控制力。",
                        基础攻击力: 2,
                        基础防御力: 2,
                        最大生命值: 10,
                        强化: 配置.强化 || false,
                        技能: [
                            {
                                名称: "空间扭曲",
                                等级: 1,
                                描述: "被攻击时有几率扭曲空间，使攻击者传送回其原始位置。",
                                时机: "被攻击",
                                索引: 0,
                            },
                            {
                                名称: "精神控制",
                                等级: 1,
                                描述: "攻击时有几率魅惑一个敌人，使其在短时间内为你作战。",
                                时机: "攻击",
                                索引: 1,
                            },
                        ],
                    });
                    this.技能效果 = [
                        function (宠物, 来源) {
                            if (!(来源 instanceof 怪物)) return;
                            const 技能等级 =
                                宠物.自定义数据.get("技能")[0].等级;
                            const 触发几率 = Math.min(
                                0.85,
                                0.1 + (技能等级 - 1) * 0.05
                            ); // 初始10%几率, 每级增加5%

                            if (Math.random() < 触发几率) {
                                // 记录原始位置
                                if (!来源.原始位置) {
                                    来源.原始位置 = { x: 来源.x, y: 来源.y };
                                    return;
                                }
                                if (
                                    来源.原始位置 &&
                                    来源.原始位置.x >= 0 &&
                                    来源.原始位置.x < 地牢大小 &&
                                    来源.原始位置.y >= 0 &&
                                    来源.原始位置.y < 地牢大小
                                ) {
                                    来源.恢复背景类型();
                                    来源.x = 来源.原始位置.x;
                                    来源.y = 来源.原始位置.y;
                                    地牢[来源.y][来源.x].类型 = 单元格类型.怪物;
                                    地牢[来源.y][来源.x].关联怪物 = 来源;
                                    显示通知(
                                        `${宠物.名称}发动了空间扭曲！`,
                                        "成功"
                                    );
                                    绘制();
                                }
                            }
                        },
                        function (宠物, 目标怪物列表) {
                            if (!目标怪物列表 || 目标怪物列表.length === 0)
                                return;
                            const 技能等级 =
                                宠物.自定义数据.get("技能")[1].等级;
                            let 触发几率 = Math.min(
                                0.85,
                                0.1 + (技能等级 - 1) * 0.05
                            );
                            //触发几率 = 1;
                            if (Math.random() < 触发几率) {
                                const 目标 =
                                    目标怪物列表[
                                        Math.floor(
                                            Math.random() * 目标怪物列表.length
                                        )
                                    ];

                                if (
                                    怪物状态表.get(目标)?.类型 !== "魅惑" &&
                                    !(目标 instanceof 炸弹怪物) &&
                                    !(目标 instanceof 大魔法师)
                                ) {
                                    const 持续回合 = 2 + 技能等级; // 基础2回合，每级+1回合
                                    const 控制状态 = new 状态效果(
                                        "魅惑",
                                        "#8e44ad",
                                        "魅",
                                        持续回合,
                                        null,
                                        null,
                                        目标
                                    );

                                    添加日志(
                                        `${宠物.名称}控制了${目标.类型}!`,
                                        "成功"
                                    );
                                }
                            }
                        },
                    ];
                }
                升级() {
                    const 升级成功 = super.升级();
                    if (升级成功) {
                        const 技能列表 = this.自定义数据.get("技能");
                        if (技能列表) {
                            // 随机升级
                            const 随机技能索引 = Math.floor(
                                Math.random() * 技能列表.length
                            );
                            技能列表[随机技能索引].等级 += 1;
                            显示通知(
                                `${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`,
                                "成功"
                            );
                            window.宠物管理窗口.querySelector(
                                ".宠物技能面板"
                            ).innerHTML = "";
                            window.宠物管理窗口
                                .querySelector(".宠物技能面板")
                                .appendChild(this.创建技能面板());
                        }
                    }
                    return 升级成功;
                }
            }
            class 魔法水晶 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: `${配置.水晶ID}水晶`,
                        图标: 图标映射.水晶,
                        品质: 5,
                        颜色索引: 配置.颜色索引 || 0,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: true,
                        效果描述:
                            "一个蕴含着强大魔法能量的水晶，似乎是某种封印的核心。",
                        数据: {
                            水晶ID: 配置.水晶ID || "未知",
                            已摧毁: false,
                            管辖房间: 配置.管辖房间 || [],
                        },
                        ...配置,
                    });
                }

                尝试互动() {
                    if (this.自定义数据.get("已摧毁")) return false;

                    const 管辖房间名称列表 = this.自定义数据.get("管辖房间");
                    if (管辖房间名称列表 && 管辖房间名称列表.length > 0) {
                        for (const 房间名称 of 管辖房间名称列表) {
                            const 房间 = 房间列表.find(
                                (r) => r.名称 === 房间名称
                            );
                            if (房间) {
                                for (const 怪物 of 所有怪物) {
                                    if (
                                        怪物.房间ID === 房间.id &&
                                        怪物.当前生命值 > 0
                                    ) {
                                        显示通知(
                                            `水晶受到保护，必须先清除 ${房间名称} 内的所有怪物！`,
                                            "警告"
                                        );
                                        return false;
                                    }
                                }
                            }
                        }
                    }

                    this.自定义数据.set("已摧毁", true);
                    显示通知(
                        `${this.名称}被摧毁了，发出了一声清脆的碎裂声！`,
                        "成功"
                    );

                    if (
                        this.x !== null &&
                        this.y !== null &&
                        地牢[this.y]?.[this.x]?.关联物品 === this
                    ) {
                        地牢[this.y][this.x].关联物品 = null;
                        if (地牢[this.y][this.x].类型 === 单元格类型.物品) {
                            地牢[this.y][this.x].类型 = null;
                        }
                    }
                    绘制();
                    检查所有水晶状态();
                    return true;
                }

                get 颜色表() {
                    return 颜色表;
                }
            }

            class 符文圈 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形",
                        名称: `${配置.效果类型}符文圈`,
                        图标: 图标映射.符文圈,
                        品质: 5,
                        颜色索引: 效果名称编号映射[配置.效果类型] || 0,
                        能否拾起: false,
                        是否正常物品: false,
                        阻碍怪物: false,

                        效果描述: "周期性激活的魔法符文。",
                        数据: {
                            周期: 配置.周期 || 10,
                            剩余周期:
                                配置.剩余周期 ??
                                Math.floor(Math.random() * (配置.周期 || 10)),
                            持续时间: 配置.持续时间 || 3,
                            效果类型: 配置.效果类型 || "狂暴",
                            强度: 配置.强度 || 2,
                            ...配置.数据,
                        },
                        ...配置,
                    });
                    所有计时器.push(this);
                }

                更新倒计时() {
                    let 剩余 = this.自定义数据.get("剩余周期") - 1;
                    if (剩余 <= 0) {
                        const 效果列表 = ["狂暴", "神龟", "缓慢", "中毒"];
                        const 当前效果 = this.自定义数据.get("效果类型");
                        const 当前索引 = 效果列表.indexOf(当前效果);
                        const 下一个索引 = (当前索引 + 1) % 效果列表.length;
                        const 新效果类型 = 效果列表[下一个索引];

                        this.自定义数据.set("效果类型", 新效果类型);
                        this.名称 = `${新效果类型}符文圈`;
                        this.颜色索引 = 效果名称编号映射[新效果类型] || 0;
                        this.自定义数据.set(
                            "剩余周期",
                            this.自定义数据.get("周期")
                        );
                    } else {
                        this.自定义数据.set("剩余周期", 剩余);
                    }

                    this.应用效果();
                }

                应用效果() {
                    const 效果类型 = this.自定义数据.get("效果类型");
                    const 颜色 = 效果颜色编号映射[this.颜色索引];
                    const 图标 = this.图标;
                    const 持续时间 = this.自定义数据.get("持续时间");
                    const 强度 = this.自定义数据.get("强度");

                    if (玩家.x === this.x && 玩家.y === this.y) {
                        new 状态效果(
                            效果类型,
                            颜色,
                            图标,
                            持续时间,
                            null,
                            null,
                            null,
                            强度
                        );
                    }
                    所有怪物.forEach((怪物) => {
                        if (怪物.x === this.x && 怪物.y === this.y) {
                            new 状态效果(
                                效果类型,
                                颜色,
                                图标,
                                持续时间,
                                null,
                                null,
                                怪物,
                                强度
                            );
                        }
                    });
                }

                get 颜色表() {
                    return 效果颜色编号映射;
                }
            }

            class 魔法师法杖 extends 武器类 {
                constructor(配置 = {}) {
                    super({
                        名称: "魔法师法杖",
                        图标: 图标映射.魔法师法杖,
                        品质: 5,
                        基础攻击力: 10,
                        冷却回合: 6,
                        攻击范围: 5,
                        耐久: 120,
                        效果描述: "释放大魔法师的经典法术，攻击模式随机。",
                        不可破坏: false,
                        ...配置,
                    });
                }
                使用() {
                    if (this.自定义数据.get("冷却剩余") > 0) return false;
                    this.普通攻击();
                    this.自定义数据.set("冷却剩余", this.最终冷却回合);
                    this.自定义数据.set(
                        "耐久",
                        this.自定义数据.get("耐久") - this.耐久消耗
                    );
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    更新装备显示();
                    return true;
                }

                普通攻击() {
                    const 攻击模式 = Math.floor(Math.random() * 4);
                    let 方向列表 = [];

                    switch (攻击模式) {
                        case 0:
                            方向列表 = [
                                { dx: 0, dy: -1 },
                                { dx: 0, dy: 1 },
                                { dx: -1, dy: 0 },
                                { dx: 1, dy: 0 },
                            ];
                            break;
                        case 1:
                            方向列表 = [
                                { dx: -1, dy: -1 },
                                { dx: 1, dy: -1 },
                                { dx: -1, dy: 1 },
                                { dx: 1, dy: 1 },
                            ];
                            break;
                        case 2:
                        case 3:
                            const 基本方向 = [
                                { dx: 0, dy: -1 },
                                { dx: 1, dy: 0 },
                                { dx: 0, dy: 1 },
                                { dx: -1, dy: 0 },
                            ];
                            const 顺时针方向变化 = [
                                { dx: 1, dy: 0 },
                                { dx: 0, dy: 1 },
                                { dx: -1, dy: 0 },
                                { dx: 0, dy: -1 },
                            ];
                            const 逆时针方向变化 = [
                                { dx: 0, dy: -1 },
                                { dx: -1, dy: 0 },
                                { dx: 0, dy: 1 },
                                { dx: 1, dy: 0 },
                            ];

                            基本方向.forEach((起始方向) => {
                                let 当前方向 = 起始方向;
                                let 当前X = 玩家.x;
                                let 当前Y = 玩家.y;
                                let 路径 = [];
                                let 层数 = 0;
                                while (
                                    Math.abs(当前X - 玩家.x) +
                                        Math.abs(当前Y - 玩家.y) <=
                                    this.最终攻击范围
                                ) {
                                    层数++;
                                    let 步数 = 层数 * 2 - 1;
                                    if (层数 > 1) {
                                        const 方向变化 =
                                            攻击模式 === 2
                                                ? 顺时针方向变化
                                                : 逆时针方向变化;
                                        let 方向索引 = 方向变化.findIndex(
                                            (d) =>
                                                d.dx === 当前方向.dx &&
                                                d.dy === 当前方向.dy
                                        );
                                        方向索引 = (方向索引 + 1) % 4;
                                        当前方向 = 方向变化[方向索引];
                                        当前X += 当前方向.dx;
                                        当前Y += 当前方向.dy;
                                        if (
                                            !检查移动可行性(
                                                当前X - 当前方向.dx,
                                                当前Y - 当前方向.dy,
                                                当前X,
                                                当前Y
                                            )
                                        )
                                            break;
                                        const 单元格 = 地牢[当前Y]?.[当前X];
                                        if (
                                            单元格?.关联怪物 &&
                                            单元格.类型 === 单元格类型.怪物 &&
                                            单元格.关联怪物?.状态 ===
                                                怪物状态.活跃
                                        ) {
                                            单元格.关联怪物.受伤(
                                                this.攻击力,
                                                this
                                            );
                                        }
                                        路径.push({ x: 当前X, y: 当前Y });
                                        步数--;
                                    }
                                    for (let i = 0; i < 步数; i++) {
                                        当前X += 当前方向.dx;
                                        当前Y += 当前方向.dy;
                                        if (
                                            !检查移动可行性(
                                                当前X - 当前方向.dx,
                                                当前Y - 当前方向.dy,
                                                当前X,
                                                当前Y
                                            )
                                        )
                                            break;
                                        const 单元格 = 地牢[当前Y]?.[当前X];
                                        if (
                                            单元格?.关联怪物 &&
                                            单元格.类型 === 单元格类型.怪物 &&
                                            单元格.关联怪物?.状态 ===
                                                怪物状态.活跃
                                        ) {
                                            单元格.关联怪物.受伤(
                                                this.攻击力,
                                                this
                                            );
                                        }
                                        路径.push({ x: 当前X, y: 当前Y });
                                    }
                                    if (
                                        Math.abs(当前X - 玩家.x) +
                                            Math.abs(当前Y - 玩家.y) >
                                        this.最终攻击范围
                                    )
                                        break;
                                }
                                计划显示格子特效(路径);
                            });
                            return;
                    }

                    方向列表.forEach((方向) => {
                        let 当前X = 玩家.x + 方向.dx;
                        let 当前Y = 玩家.y + 方向.dy;
                        let 路径 = [];
                        while (
                            Math.abs(当前X - 玩家.x) +
                                Math.abs(当前Y - 玩家.y) <=
                            this.最终攻击范围
                        ) {
                            if (
                                !检查移动可行性(
                                    当前X - 方向.dx,
                                    当前Y - 方向.dy,
                                    当前X,
                                    当前Y
                                )
                            )
                                break;
                            const 单元格 = 地牢[当前Y]?.[当前X];
                            if (
                                单元格?.关联怪物 &&
                                单元格.类型 === 单元格类型.怪物 &&
                                单元格.关联怪物?.状态 === 怪物状态.活跃
                            ) {
                                单元格.关联怪物.受伤(this.攻击力, this);
                                break;
                            }
                            路径.push({ x: 当前X, y: 当前Y });
                            当前X += 方向.dx;
                            当前Y += 方向.dy;
                        }
                        计划显示格子特效(路径);
                    });
                }
            }

            class 大师附魔卷轴 extends 卷轴类 {
                constructor(配置 = {}) {
                    super({
                        名称: "大师附魔卷轴",
                        品质: 5,
                        效果描述:
                            "从三个随机的高级附魔中选择一个，为装备附加。",
                        能量消耗: 50,
                        ...配置,
                    });
                }

                使用() {
                    const 附魔池 = new 附魔卷轴({}).附魔池;
                    const 效果名池 = new 附魔卷轴({}).效果名;
                    if (附魔池.length < 3) {
                        显示通知("附魔池不足，无法生成选项！", "错误");
                        return false;
                    }
                    if (!this.消耗能量()) return false;

                    const 随机效果 = [];
                    const 已选索引 = new Set();
                    while (随机效果.length < 3) {
                        const 索引 = Math.floor(Math.random() * 附魔池.length);
                        if (!已选索引.has(索引)) {
                            已选索引.add(索引);
                            随机效果.push({
                                效果函数: 附魔池[索引],
                                效果名: 效果名池[索引],
                            });
                        }
                    }
                    this.显示选择界面(随机效果);
                    当前激活卷轴列表.delete(this);
                    return true;
                }

                显示选择界面(效果列表) {
                    玩家属性.允许移动++;
                    const 遮罩 = document.createElement("div");
                    遮罩.className = "重铸遮罩";
                    const 弹窗 = document.createElement("div");
                    弹窗.className = "重铸弹窗";
                    弹窗.innerHTML = `<div class="重铸弹窗-header"><h3>选择一个附魔</h3><button class="关闭按钮" id="三选一关闭按钮">×</button></div><div id="附魔选项容器" class="重铸弹窗-items"></div>`;
                    const 容器 = 弹窗.querySelector("#附魔选项容器");

                    const 关闭选择界面 = () => {
                        遮罩.remove();
                        玩家属性.允许移动--;
                        const 能量条 = document.querySelector(".power-bar");
                        const 当前能量 = parseFloat(能量条.style.width) || 0;
                        if (能量条)
                            能量条.style.width = `${Math.min(
                                100,
                                当前能量 + this.自定义数据.get("能量消耗")
                            )}%`;
                        触发HUD显示();
                    };

                    弹窗.querySelector("#三选一关闭按钮").onclick =
                        关闭选择界面;

                    效果列表.forEach((效果) => {
                        const 按钮 = document.createElement("button");
                        按钮.className = "菜单按钮";
                        按钮.textContent = 效果.效果名;
                        按钮.onclick = () => {
                            遮罩.remove();
                            玩家属性.允许移动 -= 1;
                            const 临时附魔卷轴 = new 附魔卷轴({
                                品质: 4,
                                已解锁: true,
                            });
                            临时附魔卷轴.附魔效果 = 效果.效果函数;
                            临时附魔卷轴.当前附魔效果名 = 效果.效果名;
                            临时附魔卷轴.能量消耗 = 0;

                            const 原创建附魔弹窗 = 临时附魔卷轴.创建附魔弹窗;
                            临时附魔卷轴.创建附魔弹窗 = () => {
                                const 附魔弹窗实例 =
                                    原创建附魔弹窗.call(临时附魔卷轴);
                                const 原关闭按钮 =
                                    附魔弹窗实例.querySelector(".关闭按钮");
                                if (原关闭按钮) {
                                    原关闭按钮.onclick = () => {
                                        附魔弹窗实例.classList.add("关闭中");
                                        setTimeout(() => {
                                            附魔弹窗实例.remove();
                                            当前激活卷轴列表.delete(
                                                临时附魔卷轴
                                            );
                                            // 附魔取消，返还能量
                                            const 能量条 =
                                                document.querySelector(
                                                    ".power-bar"
                                                );
                                            const 当前能量 =
                                                parseFloat(
                                                    能量条.style.width
                                                ) || 0;
                                            if (能量条)
                                                能量条.style.width = `${Math.min(
                                                    100,
                                                    当前能量 +
                                                        this.自定义数据.get(
                                                            "能量消耗"
                                                        )
                                                )}%`;
                                            触发HUD显示();
                                        }, 300);
                                    };
                                }
                                return 附魔弹窗实例;
                            };

                            const 原执行附魔 = 临时附魔卷轴.执行附魔;
                            临时附魔卷轴.执行附魔 = (装备, 弹窗, 元素) => {
                                const 附魔成功 = 原执行附魔.call(
                                    临时附魔卷轴,
                                    装备,
                                    弹窗,
                                    元素
                                );
                                if (附魔成功) {
                                    处理销毁物品(this.唯一标识, true);
                                }
                            };

                            临时附魔卷轴.使用();
                        };
                        容器.appendChild(按钮);
                    });
                    遮罩.appendChild(弹窗);
                    document.body.appendChild(遮罩);
                }
            }
            class 小书魔 extends 宠物 {
                constructor(配置 = {}) {
                    super({
                        名称: "小书魔",
                        图标: "📖",
                        品质: 4,
                        效果描述: "它似乎对魔法卷轴有着天生的亲和力。",
                        基础攻击力: 3,
                        基础防御力: 1,
                        最大生命值: 25,
                        技能: [
                            {
                                名称: "奥术飞弹",
                                等级: 1,
                                描述: "攻击时有几率发射奥术飞弹，造成额外伤害。",
                                时机: "攻击",
                                索引: 0,
                            },
                            {
                                名称: "法力汲取",
                                等级: 1,
                                描述: "受击时有几率从攻击者身上汲取法力，为主人恢复能量。",
                                时机: "被攻击",
                                索引: 1,
                            },
                        ],
                        ...配置,
                    });

                    this.技能效果 = [
                        (宠物, 目标怪物列表) => {
                            const 技能 = 宠物.自定义数据.get("技能")[0];
                            if (Math.random() < 0.3) {
                                const 伤害 = 2 + 技能.等级;
                                const 目标 = 目标怪物列表[0];
                                if (目标 && 目标.当前生命值 > 0) {
                                    目标.受伤(伤害, 宠物);
                                    添加日志(
                                        `${宠物.名称}发射了奥术飞弹！`,
                                        "成功"
                                    );
                                }
                            }
                        },
                        (宠物, 来源) => {
                            const 技能 = 宠物.自定义数据.get("技能")[1];
                            if (Math.random() < 0.4 && 来源 instanceof 怪物) {
                                const 恢复量 = 5 + 技能.等级 * 2;
                                const 能量条 =
                                    document.querySelector(".power-bar");
                                const 当前能量 =
                                    parseFloat(能量条.style.width) || 0;
                                能量条.style.width = `${Math.min(
                                    100,
                                    当前能量 + 恢复量
                                )}%`;
                                添加日志(`${宠物.名称}汲取了能量！`, "成功");
                            }
                        },
                    ];
                }

                升级() {
                    if (super.升级()) {
                        const 技能列表 = this.自定义数据.get("技能");
                        const 随机技能索引 = Math.floor(
                            Math.random() * 技能列表.length
                        );
                        技能列表[随机技能索引].等级 += 1;
                        显示通知(
                            `${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`,
                            "成功"
                        );
                    }
                }
            }
            class 罐子 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "工具",
                        名称: "神秘的罐子",
                        图标: 图标映射.罐子,
                        品质: 2,
                        颜色索引: 3,
                        最大堆叠数量: 1,
                        能否拾起: true,
                        是否正常物品: false,
                        阻碍怪物: false,
                        效果描述:
                            "一个看起来很脆弱的罐子，里面似乎装着什么东西。",
                        数据: {
                            内容物类型: null,
                            内容物类名: null,
                            内容物配置: {},
                            已破碎: false,
                            ...(配置.数据 || {}),
                        },
                        ...配置,
                    });
                    if (
                        !this.自定义数据.get("已破碎") &&
                        !this.自定义数据.get("内容物类名")
                    ) {
                        this.决定罐子内容();
                    }
                }

                决定罐子内容() {
                    const 当前层 = 当前层数 !== null ? 当前层数 : 0;
                    if (Math.random() < 0.65) {
                        this.自定义数据.set("内容物类型", "怪物");
                        const 怪物池选择 = 怪物池.普通房间.filter(
                            (m) =>
                                m.最小层 <= 当前层 && m.类.name !== "大魔法师"
                        );
                        if (怪物池选择.length > 0) {
                            const 怪物配置 = 加权随机选择(
                                怪物池选择.map((cfg) => ({ 值: cfg, 权重: 1 }))
                            );
                            this.自定义数据.set("内容物类名", 怪物配置.类.name);
                            this.自定义数据.set("内容物配置", {
                                强化: Math.random() < 0.2 + 当前层 * 0.02,
                            });
                        } else {
                            this.转为物品内容("金币", {
                                数量: Math.floor(Math.random() * 10) + 5,
                            });
                        }
                    } else {
                        this.自定义数据.set("内容物类型", "物品");
                        const 物品池选择 = Object.values(物品池)
                            .flat()
                            .filter(
                                (i) =>
                                    i.最小层 <= 当前层 &&
                                    i.类.name !== "罐子" &&
                                    i.类.name !== "神秘商人" &&
                                    i.类.name !== "探险家" &&
                                    i.类.name !== "物品祭坛" &&
                                    i.类.name !== "耐久祭坛" &&
                                    i.类.name !== "背包扩容祭坛" &&
                                    i.类.name !== "重铸台" &&
                                    i.类.name !== "折跃门" &&
                                    i.类.name !== "寻宝戒指" &&
                                    i.类.name !== "配方卷轴" &&
                                    i.类.name !== "钥匙" &&
                                    i.类.name !== "调试工具"
                            );
                        if (物品池选择.length > 0) {
                            const 物品配置 =
                                物品池选择[
                                    Math.floor(
                                        Math.random() * 物品池选择.length
                                    )
                                ];
                            this.自定义数据.set("内容物类名", 物品配置.类.name);
                            this.自定义数据.set("内容物配置", {
                                强化: Math.random() < 0.1 + 当前层 * 0.02,
                            });
                        } else {
                            this.转为物品内容("金币", {
                                数量: Math.floor(Math.random() * 10) + 5,
                            });
                        }
                    }
                }

                转为物品内容(类名, 配置) {
                    this.自定义数据.set("内容物类型", "物品");
                    this.自定义数据.set("内容物类名", 类名);
                    this.自定义数据.set("内容物配置", 配置);
                }

                当被收集(进入者) {
                    
                    if (this.自定义数据.get("已破碎")) return false;
                    this.破碎并释放内容();
                    return false;
                }

                破碎并释放内容(触发怪物 = null) {
                    if (this.自定义数据.get("已破碎")) return;
                    this.自定义数据.set("已破碎", true);

                    const 原罐子X = this.x;
                    const 原罐子Y = this.y;

                    if (
                        原罐子X !== null &&
                        原罐子Y !== null &&
                        地牢[原罐子Y]?.[原罐子X]?.关联物品 === this
                    ) {
                        地牢[原罐子Y][原罐子X].关联物品 = null;
                        地牢[原罐子Y][原罐子X].类型 = null;
                        地牢[原罐子Y][原罐子X].颜色索引 = 颜色表.length;
                    }
                    if (玩家背包.has(this.唯一标识)) {
                        玩家背包.delete(this.唯一标识);
                        更新背包显示();
                    }

                    显示通知("罐子破碎了！", "警告");
                    计划显示格子特效([{ x: 原罐子X, y: 原罐子Y }], "A52A2A");

                    const 内容物类型 = this.自定义数据.get("内容物类型");
                    const 内容物类名 = this.自定义数据.get("内容物类名");
                    const 内容物配置 = this.自定义数据.get("内容物配置") || {};

                    if (!内容物类名) {
                        添加日志("罐子是空的...", "信息");
                        绘制();
                        return;
                    }

                    const 构造器 = window[内容物类名];
                    if (!构造器) {
                        添加日志(
                            `罐子里的东西不见了 (未知类型: ${内容物类名})`,
                            "错误"
                        );
                        绘制();
                        return;
                    }

                    let 释放物实例;
                    try {
                        释放物实例 = new 构造器({
                            ...内容物配置,
                            x: null,
                            y: null,
                        });
                    } catch (e) {
                        添加日志(
                            `无法创建罐子内容物 ${内容物类名}: ${e.message}`,
                            "错误"
                        );
                        绘制();
                        return;
                    }

                    let 放置X = 原罐子X;
                    let 放置Y = 原罐子Y;
                    let 放置成功 = false;

                    const 怪物正在此格 =
                        触发怪物 &&
                        触发怪物.x === 放置X &&
                        触发怪物.y === 放置Y;

                    if (!怪物正在此格 && 位置是否可用(放置X, 放置Y, false)) {
                        if (内容物类型 === "怪物") {
                            放置成功 = 放置怪物到单元格(
                                释放物实例,
                                放置X,
                                放置Y
                            );
                        } else {
                            放置成功 = 放置物品到单元格(
                                释放物实例,
                                放置X,
                                放置Y
                            );
                        }
                    }

                    if (!放置成功) {
                        const 方向 = [
                            [0, -1],
                            [0, 1],
                            [-1, 0],
                            [1, 0],
                            [-1, -1],
                            [1, -1],
                            [-1, 1],
                            [1, 1],
                        ];
                        方向.sort(() => Math.random() - 0.5);
                        for (const [dx, dy] of 方向) {
                            const 新X = 原罐子X + dx;
                            const 新Y = 原罐子Y + dy;

                            if (
                                新X >= 0 &&
                                新X < 地牢大小 &&
                                新Y >= 0 &&
                                新Y < 地牢大小 &&
                                位置是否可用(新X, 新Y, false)
                            ) {
                                if (内容物类型 === "怪物") {
                                    放置成功 = 放置怪物到单元格(
                                        释放物实例,
                                        新X,
                                        新Y
                                    );
                                } else {
                                    放置成功 = 放置物品到单元格(
                                        释放物实例,
                                        新X,
                                        新Y
                                    );
                                }
                                if (放置成功) {
                                    放置X = 新X;
                                    放置Y = 新Y;
                                    break;
                                }
                            }
                        }
                    }

                    if (放置成功) {
                        添加日志(
                            `从罐子中出现了: ${
                                释放物实例.获取名称
                                    ? 释放物实例.获取名称()
                                    : 释放物实例.类型 || 内容物类名
                            }!`,
                            "成功"
                        );
                        if (内容物类型 === "怪物") {
                            释放物实例.状态 = 怪物状态.活跃;
                            释放物实例.绘制血条();
                        }
                    } else {
                        添加日志("罐子里的东西无处安放，消失了...", "信息");
                    }
                    绘制();
                }

                获取提示() {
                    if (this.自定义数据.get("已破碎")) {
                        return "破碎的罐子";
                    }
                    let 提示 = `${this.名称}\n品质：${"★".repeat(this.品质)}\n${
                        this.效果描述
                    }`;
                    return 提示;
                }
            }
            class 空罐子 extends 罐子 {
                constructor(配置 = {}) {
                    super({
                        名称: "空罐子",
                        数据: {
                            已破碎: false,
                            内容物类型: null,
                            内容物类名: null,
                        },
                        ...配置,
                    });
                }
                决定罐子内容() {}
            }
            class 吸能种子 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "消耗品",
                        名称: "吸能种子",
                        图标: 图标映射.种子,
                        品质: 2,
                        颜色索引: 1,
                        堆叠数量: 配置.数量 || 1,
                        最大堆叠数量: 16,
                        效果描述:
                            "消耗至多50点能量，将其转化为能量草存入背包。",
                        ...配置,
                    });
                }

                使用() {
                    if (this.堆叠数量 <= 0) return false;

                    const 能量条 = document.querySelector(".power-bar");
                    const 当前能量百分比 = parseFloat(能量条.style.width) || 0;
                    const 当前能量值 = 当前能量百分比;

                    if (当前能量值 <= 0) {
                        显示通知("没有能量可以吸取！", "错误");
                        return false;
                    }

                    const 能量草实例 = new 能量草({});
                    if (
                        [...玩家背包.values()].reduce(
                            (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
                            0
                        ) >= 最大背包容量 &&
                        ![...玩家背包.values()].find((i) =>
                            i.可堆叠于(能量草实例)
                        )
                    ) {
                        显示通知("背包已满，无法生成能量草！", "错误");
                        return false;
                    }

                    const 吸收量 = Math.min(50, 当前能量值);
                    if (!扣除能量(吸收量)) {
                        显示通知("未知错误，无法吸取能量。", "错误");
                        return false;
                    }

                    if (尝试收集物品(能量草实例, true)) {
                        this.堆叠数量--;
                        显示通知(
                            `成功吸取 ${吸收量.toFixed(
                                0
                            )} 点能量，获得了能量草！`,
                            "成功"
                        );
                        return true;
                    } else {
                        能量条.style.width = `${当前能量百分比}%`;
                        显示通知("背包空间不足，无法获得能量草！", "错误");
                        return false;
                    }
                }
            }
            class 能量草 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "消耗品",
                        名称: "能量草",
                        图标: 图标映射.能量草,
                        品质: 2,
                        颜色索引: 1,
                        堆叠数量: 配置.数量 || 1,
                        最大堆叠数量: 16,
                        效果描述: "使用后恢复50点能量。",
                        ...配置,
                    });
                }

                使用() {
                    if (this.堆叠数量 <= 0) return false;

                    const 能量条 = document.querySelector(".power-bar");
                    const 当前能量 = parseFloat(能量条.style.width) || 0;
                    能量条.style.width = `${Math.min(100, 当前能量 + 50)}%`;

                    this.堆叠数量--;
                    if (this.堆叠数量 <= 0) {
                        处理销毁物品(this.唯一标识, true);
                    }

                    显示通知("你感到了能量的充盈！", "成功");
                    更新背包显示();
                    更新装备显示();
                    return true;
                }
            }
            class 火焰物品 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "地形", // 特殊类型，非普通物品
                        名称: "火焰",
                        图标: 图标映射.火焰,
                        品质: 1, // 品质意义不大
                        颜色索引: 效果名称编号映射.火焰, // 使用火焰效果的颜色索引
                        最大堆叠数量: 1,
                        能否拾起: true, // 必须为true 才能触发 当被收集 函数
                        阻碍怪物: false, // 关键：不阻碍怪物
                        是否正常物品: false, // 不参与常规掉落/交易
                        是否为隐藏物品: false, // 在地图上可见
                        效果描述: "灼热的火焰，触碰会被点燃。",
                        数据: {
                            倒计时: 配置.倒计时 ?? 10, // 默认存在10回合
                            爆炸时间: 配置.倒计时 ?? 10, // 复用计时器接口
                            火焰强度: 配置.火焰强度 ?? 3, // 每回合伤害
                            火焰持续: 配置.火焰持续 ?? 3, // 施加给玩家的燃烧效果持续回合数
                            光照范围: 配置.光照范围 ?? 2, // 照亮范围
                            ...配置.数据, // 允许覆盖
                        },
                        ...配置, // 允许覆盖父类属性
                    });
                    // 火焰物品创建时自动加入计时器
                    if (!所有计时器.some((t) => t.唯一标识 === this.唯一标识)) {
                        所有计时器.push(this);
                    }
                    if (当前天气效果.includes("严寒") && !配置.倒计时) {
                        this.自定义数据.set("爆炸时间", 5);
                        this.自定义数据.set("倒计时", 5);
                    }
                }

                // 火焰不能被主动使用
                使用() {
                    return false;
                }

                // 玩家接触火焰时触发 (不能被收集，但会触发效果)
                当被收集(进入者) {
                    if (进入者 !== "玩家") return;
                    const 效果 = new 状态效果(
                        "火焰", // 效果类型
                        this.获取火焰颜色(), // 颜色
                        图标映射.火焰, // 图标
                        this.自定义数据.get("火焰持续"), // 效果持续回合数
                        null, // 剩余回合（从持续时间开始）
                        null, // 来源（火焰本身，或null）
                        null, // 关联怪物 (null代表玩家)
                        this.自定义数据.get("火焰强度") // 效果强度（每回合伤害）
                    );
                    添加日志("你接触了火焰，被点燃了！", "错误");
                    return false; // 返回 false 表示无法被收集（移除）
                }

                // 更新倒计时 (每回合调用)
                更新倒计时() {
                    const 剩余回合 = this.自定义数据.get("倒计时");
                    if (剩余回合 <= 0) {
                        this.熄灭(); // 时间到，火焰熄灭
                    } else {
                        this.自定义数据.set("倒计时", 剩余回合 - 1);
                    }
                }

                // 火焰熄灭 (代替原来的触发爆炸)
                熄灭() {
                    // 从地牢格子中移除
                    if (
                        this.x !== null &&
                        this.y !== null &&
                        地牢[this.y]?.[this.x]?.关联物品 === this
                    ) {
                        地牢[this.y][this.x].关联物品 = null;

                        if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品)
                            地牢[this.y][this.x].类型 = null;
                    }
                    // 从计时器列表中移除
                    所有计时器 = 所有计时器.filter((item) => item !== this);
                    绘制(); // 更新画面，移除火焰图标
                }

                获取提示() {
                    return [
                        `${this.获取名称()}`,
                        `类型：${this.类型}`,
                        `剩余时间：${this.自定义数据.get("倒计时")} 回合`,
                        `${this.效果描述}`,
                    ].join("\n");
                }

                获取火焰颜色() {
                    return 效果颜色编号映射[this.颜色索引] || "#CC5500";
                }

                get 颜色表() {
                    return 效果颜色编号映射;
                }
            }
            class 寻宝戒指 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        类型: "戒指",
                        名称: "寻宝戒指",
                        图标: 图标映射.寻宝戒指,
                        品质: 3,
                        颜色索引: 2,
                        最大堆叠数量: 1,
                        效果描述: "装备后，会为你指出隐藏大门的位置",
                        数据: {
                            生效层数: 配置.生效层数 || 当前层数, // 指定生效的层数
                            已生成折跃门: false,
                            ...配置.数据,
                        },
                    });
                }
                生成显示元素(用途 = "背包") {
                    const 元素 = super.生成显示元素(用途);
                    if (用途 === "装备") {
                        const 标签 = document.createElement("div");
                        标签.className = "耐久标签";
                        标签.textContent = `当前层:${当前层数}`;
                        元素.appendChild(标签);
                    }
                    return 元素;
                }
                使用() {
                    显示通知("装备不能被使用！", "错误");
                    return false;
                }
                装备() {
                    if (!super.装备()) return false;
                    // 触发检查和生成折跃门逻辑
                    if (
                        this.自定义数据.get("生效层数") === 当前层数 &&
                        !this.自定义数据.get("已生成折跃门")
                    ) {
                        this.尝试生成折跃门();
                    }

                    更新装备显示();
                    return true;
                }

                取消装备() {
                    if (!this.已装备) return false;
                    // 移除折跃门指示器（如果存在）
                    const 指示器 = document.querySelector(".折跃门指示器");
                    if (指示器) {
                        指示器.remove();
                    }
                    玩家装备.delete(this.装备槽位);
                    this.已装备 = false;
                    this.装备槽位 = null;
                    更新装备显示();
                    return true;
                }

                尝试生成折跃门() {
                    const 可用房间 = 房间列表.filter(
                        (房间) => 房间.类型?.slice(0, 2) === "房间"
                    );
                    if (可用房间.length === 0) return; // 没有可用房间
                    const 随机房间 =
                        可用房间[Math.floor(Math.random() * 房间列表.length)];
                    const 放置折跃门 = new 折跃门({
                        目标房间: 房间列表.find(
                            (item) => item.类型?.slice(0, 2) === "隐藏"
                        ),
                    }); // 假设目标房间是起始房间
                    if (
                        放置物品到房间(
                            放置折跃门,
                            随机房间,
                            单元格类型.物品,
                            false,
                            true
                        )
                    ) {
                        this.自定义数据.set("已生成折跃门", true);
                        this.自定义数据.set("折跃门位置", {
                            x: 放置折跃门.x,
                            y: 放置折跃门.y,
                        });
                        更新物体指示器();
                    }
                }

                获取提示() {
                    return [
                        `${this.获取名称()}`,
                        `类型：${this.类型}`,
                        `生效层数：${this.自定义数据.get("生效层数")}`,
                        `效果描述：${this.效果描述}`,
                    ].join("\n");
                }
            }

            class 折跃门 extends 物品 {
                constructor(配置 = {}) {
                    super({
                        图标: 图标映射.折跃门,
                        类型: "地形",
                        名称: "折跃门",
                        品质: 1,
                        颜色索引: 2,
                        能否拾起: false,
                        是否正常物品: false,
                        是否为隐藏物品:
                            配置.是否为隐藏物品 !== undefined
                                ? 配置.是否为隐藏物品
                                : true, // 默认为隐藏
                        数据: {
                            目标房间: 配置.目标房间 || null, // 目标房间的配置
                        },
                    });
                }

                使用() {
                    const 目标房间 = this.自定义数据.get("目标房间");
                    if (!confirm("你发现了一个折跃门，是否传送？")) return false;
                    const 当前玩家房间ID = 房间地图[玩家.y][玩家.x];
                    if (当前玩家房间ID !== -1) {
                        const 当前玩家所在房间 = 房间列表[当前玩家房间ID];
                        if (
                            当前玩家所在房间 &&
                            当前玩家所在房间.类型 === "挑战房间" &&
                            当前玩家所在房间.挑战状态 &&
                            当前玩家所在房间.挑战状态.进行中
                        ) {
                            处理挑战失败(当前玩家所在房间);
                        }
                    }
                    if (生存挑战激活) {
                        显示通知("强大的结界阻止了空间传送！", "错误");
                        return false;
                    }
                    if (目标房间) {
                        let 目标X, 目标Y;
                        let 尝试次数 = 0;
                        do {
                            目标X =
                                目标房间.x +
                                Math.floor(Math.random() * 目标房间.w);
                            目标Y =
                                目标房间.y +
                                Math.floor(Math.random() * 目标房间.h);
                            尝试次数++;
                        } while (
                            地牢[目标Y]?.[目标X]?.背景类型 ===
                                单元格类型.墙壁 &&
                            尝试次数 < 50
                        );

                        if (
                            地牢[目标Y]?.[目标X]?.背景类型 === 单元格类型.墙壁
                        ) {
                            目标X = 目标房间.x + Math.floor(目标房间.w / 2);
                            目标Y = 目标房间.y + Math.floor(目标房间.h / 2);
                        }

                        玩家.x = 目标X;
                        玩家.y = 目标Y;
                        const 目标房间ID = 房间地图[玩家.y][玩家.x];
                        if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
                            moveQueue = [];
                            isAutoMoving = false;
                            已访问房间.add(目标房间ID);
                        }

                        更新视口();
                        绘制();
                        显示通知("你被传送到了一个神秘的房间！", "成功");
                        return true;
                    }
                    return false;
                }
            }
            //下面这个物品！！！闪亮登场！
            class 炸弹 extends 物品 {
                constructor(配置) {
                    super({
                        类型: "炸弹",
                        名称: "炸弹",
                        图标: 图标映射.炸弹,
                        品质: 3,
                        强化: 配置.强化 || false,
                        颜色索引:
                            配置.颜色索引 === undefined ? 2 : 配置.颜色索引,
                        堆叠数量: 配置.数量 || 1,
                        能否拾起:
                            配置.能否拾起 === undefined ? true : 配置.能否拾起,
                        数据: {
                            效果描述: "无法对爆炸怪物造成伤害",
                            倒计时: 配置.倒计时 || 2,
                            爆炸时间: 配置.爆炸时间 || 2,
                            爆炸范围: 配置.爆炸范围 || 3,
                            伤害: 配置.伤害 || 30,
                        },
                    });
                }
                获取提示() {
                    return [
                        super.获取提示(),
                        `效果描述：${this.自定义数据.get("效果描述")}`,
                    ].join("\n");
                }
                使用(玩家使用 = true, x0 = 0, y0 = 0) {
                    if (当前天气效果.includes("严寒")) {
                        if (!玩家使用) {
                            this.能否拾起 = true;
                        }
                        显示通知("温度过低，炸弹打不着火了！", "警告");
                        return 0;
                    }
                    super.使用();
                    if (玩家使用) {
                        this.自定义数据.set(
                            "倒计时",
                            this.自定义数据.get("爆炸时间")
                        );
                        const { x, y, 新物品 } = 玩家放置物品(this, false);
                        if (x === null || y === null || 新物品 === null)
                            return false;
                        新物品.x = x;
                        新物品.y = y;
                        所有计时器.push(新物品);
                        return true;
                    }
                    this.x = x0;
                    this.y = y0;
                    所有计时器.push(this);
                    return true;
                }
                更新倒计时() {
                    const 剩余回合 = this.自定义数据.get("倒计时");

                    if (剩余回合 <= 0) {
                        this.触发爆炸();
                        所有计时器 = 所有计时器.filter((item) => item !== this);
                    }
                    this.自定义数据.set("倒计时", 剩余回合 - 1);
                }

                触发爆炸() {
                    const 爆炸范围 = this.计算爆炸范围();
                    this.显示爆炸效果(爆炸范围);
                    this.处理爆炸效果(爆炸范围);
                }

                计算爆炸范围() {
                    const 可到达格子 = [];
                    const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
                    const 已访问 = new Set([`${this.x},${this.y}`]);

                    while (队列.length > 0) {
                        const 当前 = 队列.shift();
                        可到达格子.push(当前);

                        if (当前.距离 >= this.自定义数据.get("爆炸范围"))
                            continue;

                        const 方向 = [
                            { dx: 1, dy: 0 },
                            { dx: -1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: 0, dy: -1 },
                        ];

                        方向.forEach(({ dx, dy }) => {
                            const 新X = 当前.x + dx;
                            const 新Y = 当前.y + dy;
                            const 位置键 = `${新X},${新Y}`;

                            if (
                                新X >= 0 &&
                                新X < 地牢大小 &&
                                新Y >= 0 &&
                                新Y < 地牢大小 &&
                                !已访问.has(位置键)
                            ) {
                                if (
                                    this.检查路径可行性(
                                        当前.x,
                                        当前.y,
                                        新X,
                                        新Y
                                    )
                                ) {
                                    已访问.add(位置键);
                                    队列.push({
                                        x: 新X,
                                        y: 新Y,
                                        距离: 当前.距离 + 1,
                                    });
                                }
                            }
                        });
                    }
                    return 可到达格子;
                }

                检查路径可行性(fromX, fromY, toX, toY) {
                    const 移动方向 = 获取移动方向(fromX, fromY, toX, toY);

                    const 当前单元格 = 地牢[fromY][fromX];
                    const 目标单元格 = 地牢[toY][toX];

                    if (
                        当前单元格.墙壁[移动方向.当前墙] ||
                        目标单元格.墙壁[移动方向.反方向墙]
                    ) {
                        return false;
                    }

                    return [
                        单元格类型.房间,
                        单元格类型.走廊,
                        单元格类型.门,
                        单元格类型.上锁的门,
                    ].includes(目标单元格.背景类型);
                }

                显示爆炸效果(爆炸范围) {
                    爆炸范围.sort((a, b) => a.距离 - b.距离);
                待显示爆炸范围.push({
                    爆炸范围: 爆炸范围,
                    范围: this.自定义数据.get("爆炸范围"),
                });
                }

                处理爆炸效果(爆炸范围) {
                    const 是否强化炸弹 = this.强化;

                    爆炸范围.forEach(({ x, y }) => {
                        const 当前单元格 = 地牢[y]?.[x];
                        if (!当前单元格) return;
                        if (当前单元格.关联物品 instanceof 符文圈) return;
                        if (当前单元格.关联物品 instanceof 挑战石碑) return;

                        if (
                            当前单元格.关联物品 instanceof 祭坛类 &&
                            当前单元格.关联物品.自定义数据.get("激活条件") ===
                                "爆炸冲击" &&
                            !当前单元格.关联物品.自定义数据.get("已激活")
                        ) {
                            当前单元格.关联物品.激活();
                        }

                        if (!是否强化炸弹 && 玩家.x === x && 玩家.y === y) {
                            伤害玩家(this.自定义数据?.get("伤害"), this.名称);
                            const 火焰强度玩家 = 5;
                            const 火焰持续玩家 = 4;
                            new 状态效果(
                                "火焰",
                                效果颜色编号映射[效果名称编号映射.火焰],
                                图标映射.火焰,
                                火焰持续玩家,
                                null,
                                null,
                                null,
                                火焰强度玩家
                            );
                        }

                        if (当前单元格.关联怪物) {
                            if (
                                当前单元格.关联怪物.类型 !== "炸弹怪物" &&
                                当前单元格.关联怪物.类型 !== "大魔法师"
                            ) {
                                当前单元格.关联怪物.受伤(this.自定义数据?.get("伤害"), "炸弹");
                                if (当前单元格.关联怪物) {
                                const 火焰强度怪物 = 5;
                                const 火焰持续怪物 = 4;
                                new 状态效果(
                                    "火焰",
                                    效果颜色编号映射[效果名称编号映射.火焰],
                                    "火",
                                    火焰持续怪物,
                                    null,
                                    null,
                                    当前单元格.关联怪物,
                                    火焰强度怪物
                                );
                                添加日志(
                                    `${当前单元格.关联怪物?.类型} 被爆炸点燃了！`,
                                    "警告"
                                );
                                }
                            }
                        }

                        if (当前单元格.关联物品) {
                            if (
                                当前单元格.关联物品 instanceof 罐子 &&
                                !当前单元格.关联物品.自定义数据.get("已破碎")
                            ) {
                                当前单元格.关联物品.破碎并释放内容();
                            } else if (
                                !是否强化炸弹 &&
                                !(当前单元格.关联物品 instanceof 罐子) &&
                                !(当前单元格.关联物品 instanceof 祭坛类) &&
                                !(当前单元格.关联物品.类型 === "楼梯")
                                
                            ) {
                                const 被毁物品 = 当前单元格.关联物品;
                                const 计时器索引 = 所有计时器.findIndex(
                                    (t) => t.唯一标识 === 被毁物品.唯一标识
                                );
                                if (计时器索引 !== -1) {
                                    所有计时器.splice(计时器索引, 1);
                                }
                                添加日志(`${被毁物品.名称} 被炸毁了！`, "警告");
                                当前单元格.关联物品 = null;
                                当前单元格.类型 = 当前单元格.背景类型;
                            } else if (x === this.x && y === this.y) {
                                const 被毁物品 = 当前单元格.关联物品;
                                const 计时器索引 = 所有计时器.findIndex(
                                    (t) => t.唯一标识 === 被毁物品.唯一标识
                                );
                                if (计时器索引 !== -1) {
                                    所有计时器.splice(计时器索引, 1);
                                }
                                添加日志(`${被毁物品.名称} 被炸毁了！`, "警告");
                                当前单元格.关联物品 = null;
                                当前单元格.类型 = 当前单元格.背景类型;
                            }
                        }

                        if (当前单元格.背景类型 === 单元格类型.上锁的门) {
                            当前单元格.背景类型 = 单元格类型.门;
                        }
                    });

                   

                    const 爆炸半径 = this.自定义数据.get("爆炸范围") ?? 3;
                    const 火焰数量 =
                        Math.floor(Math.random() * (爆炸半径 * 2)) + 1;
                    const 可放火焰格子 = 爆炸范围.filter(
                        ({ x, y, 距离 }) =>
                            距离 > 0 &&
                            地牢[y]?.[x] &&
                            !地牢[y][x].关联物品 &&
                            !地牢[y][x].关联怪物 &&
                            [
                                单元格类型.房间,
                                单元格类型.走廊,
                                单元格类型.门,
                            ].includes(地牢[y][x].背景类型)
                    );

                    可放火焰格子.sort(() => Math.random() - 0.5);
                    const 实际放置火焰数 = Math.min(
                        火焰数量,
                        可放火焰格子.length
                    );

                    for (let i = 0; i < 实际放置火焰数; i++) {
                        const { x, y } = 可放火焰格子[i];
                        const 火焰 = new 火焰物品({ 强化: 是否强化炸弹 });
                        放置物品到单元格(火焰, x, y);
                    }
                    if (实际放置火焰数 > 0) {
                        添加日志(
                            `爆炸产生了 ${实际放置火焰数} 处火焰！`,
                            "信息"
                        );
                    }
                    绘制();
                }
            }

            // 基类：界面元素
            class 界面元素基类 {
                constructor() {
                    this.元素标识 = `元素_${Date.now()}_${Math.random()
                        .toString(36)
                        .substr(2, 9)}`;
                    this.容器元素 = document.createElement("div");
                    this.容器元素.className = "hud-item";
                    this.容器元素.dataset.元素标识 = this.元素标识;
                    document.querySelector(".hud").appendChild(this.容器元素);
                }

                销毁() {
                    this.容器元素.remove();
                    this.容器元素 = null;
                }

                更新(参数) {
                    throw new Error("必须实现更新方法");
                }
            }

            // 文本行元素
            class 文本元素 extends 界面元素基类 {
                constructor(配置) {
                    super();
                    this.图标元素 = null;
                    this.文本元素 = null;
                    this.初始化(配置);
                }

                初始化({ 图标, 内容 }) {
                    const 行容器 = document.createElement("div");
                    行容器.className = "界面文本行";

                    if (图标) {
                        this.图标元素 = document.createElement("span");
                        this.图标元素.className = "hud-icon";
                        this.图标元素.textContent = 图标;
                        行容器.appendChild(this.图标元素);
                    }

                    this.文本元素 = document.createElement("span");
                    this.文本元素.className = "hud-label";
                    this.文本元素.textContent = 内容;
                    行容器.appendChild(this.文本元素);

                    this.容器元素.appendChild(行容器);
                    触发HUD显示();
                }

                更新({ 内容, 图标 }) {
                    if (this.文本元素.textContent == 内容) return;
                    if (内容) this.文本元素.textContent = 内容;
                    if (图标) this.图标元素.textContent = 图标;
                    触发HUD显示();
                }
            }

            // 进度条元素
            class 进度条元素 extends 界面元素基类 {
                constructor(配置) {
                    super();
                    this.进度条元素 = null;
                    this.标签元素 = null;
                    this.初始化(配置);
                }

                初始化({ 图标, 颜色, 初始值, 标签 }) {
                    this.容器元素.innerHTML = `
                                                                        <span class="hud-icon">${
                                                                            图标 ||
                                                                            "⚡"
                                                                        }</span>
                                                                        <div class="hud-bar-container">
                                                                            <div class="hud-bar" style="width: ${
                                                                                初始值 ||
                                                                                100
                                                                            }%">
                                                                                <div class="进度条标签">${
                                                                                    标签 ||
                                                                                    ""
                                                                                }</div>
                                                                            </div>
                                                                        </div>
                                                                    `;

                    this.进度条元素 = this.容器元素.querySelector(".hud-bar");
                    this.标签元素 =
                        this.进度条元素.querySelector(".进度条标签");

                    if (颜色) {
                        this.进度条元素.style.background = 颜色;
                    }
                    触发HUD显示();
                }

                更新({ 数值, 标签, 颜色 }) {
                    if (
                        this.标签元素.textContent == 标签 &&
                        this.进度条元素.style.width == `${数值}%`
                    )
                        return;
                    if (数值 !== undefined) {
                        this.进度条元素.style.width = `${数值}%`;

                        // 自动添加低数值警告
                        if (数值 <= 20) {
                            this.进度条元素.classList.add("低数值警告");
                        } else {
                            this.进度条元素.classList.remove("低数值警告");
                        }
                    }

                    // 动态调整标签位置
                    if (标签) {
                        this.标签元素.textContent = 标签;
                    }

                    if (颜色) {
                        this.进度条元素.style.background = 颜色;
                    }
                    触发HUD显示();
                }
            }

            // 使用示例：
            //const 药水条 = new 进度条元素({
            //图标: '🧪',
            //颜色: 'linear-gradient(to right, #00ff88, #00ccff)',
            //初始值: 80,
            //标签: '强化药水 80%'
            //});

            //const 任务提示 = new 文本元素({
            //    图标: '📜',
            //    内容: '主线任务：寻找古代遗物'
            //});

            // 更新元素示例
            //药水条.更新({ 数值: 15, 标签: '药水剩余 15%' });
            //任务提示.更新({ 内容: '紧急任务：击败守护者' });

            const 怪物追踪提示 = new 文本元素({
                内容: `追踪怪物：0`,
            });
            const 击杀提示 = new 文本元素({
                内容: `已击杀怪物：${已击杀怪物数}`,
            });

            // 单元格类
            class 单元格 {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.类型 = 单元格类型.墙壁;
                    this.墙壁 = { 上: false, 右: false, 下: false, 左: false };
                    this.钥匙ID = null;
                    this.颜色索引 = 颜色表.length;
                    this.关联物品 = null;
                    this.关联怪物 = null;
                    this.背景类型 = 单元格类型.墙壁;
                    this.isOneWay = false;
                    this.oneWayAllowedDirection = null;
                    this.doorOrientation = null;
                }

                绘制() {
                    // 绘制战争迷雾
                    // 计算带小数偏移的屏幕坐标
                    const 小数偏移X = (当前相机X % 1) * 单元格大小;
                    const 小数偏移Y = (当前相机Y % 1) * 单元格大小;
                    const 屏幕X = (this.x - 视口偏移X) * 单元格大小 - 小数偏移X;
                    const 屏幕Y = (this.y - 视口偏移Y) * 单元格大小 - 小数偏移Y;
                    const 房间ID = 房间地图[this.y][this.x];

                    // 单元格属于某个房间且该房间未被访问过，没有特殊效果，则绘制迷雾
                    if (
                        当前天气效果.includes("深夜") ||
                        房间列表[房间ID]?.类型 === "黑暗房间" ||
                        玩家状态.some(s => s.类型 === '失明')
                    ) {
                        if (!是否在光源范围内(this.x, this.y)) {
                            ctx.fillStyle = "#000000"; // 深夜的纯黑
                            ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
                            return;
                        }
                    }
                    if (
                        房间ID !== -1 &&
                        !已访问房间.has(房间ID) &&
                        !玩家属性.透视 &&
                        !(游戏状态 === "图鉴")
                    ) {
                        ctx.fillStyle = "rgba(0, 0, 0)";
                        ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
                    } else {
                        switch (this.背景类型) {
                            case 单元格类型.房间:
                                ctx.fillStyle = "#3a506b";
                                break;
                            case 单元格类型.走廊:
                                ctx.fillStyle = "#2b2d42";
                                break;
                            case 单元格类型.门:
                                ctx.fillStyle = "#8b4513";
                                break;
                            case 单元格类型.上锁的门:
                                ctx.fillStyle = 颜色表[this.颜色索引]; // 使用颜色索引
                                break;
                            case 单元格类型.楼梯下楼:
                            case 单元格类型.楼梯上楼:
                                ctx.fillStyle = "#3a506b";
                                ctx.fillRect(
                                    屏幕X,
                                    屏幕Y,
                                    单元格大小,
                                    单元格大小
                                );
                                this.绘制物品(屏幕X, 屏幕Y);
                                break;
                            default:
                                ctx.fillStyle = "#1a1a1a";
                        }
                        if (
                            this.背景类型 !== 单元格类型.物品 &&
                            this.背景类型 !== 单元格类型.楼梯下楼 &&
                            this.背景类型 !== 单元格类型.楼梯上楼
                        ) {
                            ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
                        }
                        ctx.strokeStyle =
                            this.背景类型 === 单元格类型.上锁的门
                                ? "#ffd700"
                                : "#e0e0e0";
                        ctx.lineWidth = 2;

                        // 绘制门（水平方向）
                        if (
                            this.墙壁.上 &&
                            (this.背景类型 === 单元格类型.门 ||
                                this.背景类型 === 单元格类型.上锁的门)
                        ) {
                            ctx.beginPath();
                            ctx.moveTo(屏幕X + 单元格大小 / 3, 屏幕Y);
                            ctx.lineTo(屏幕X + (单元格大小 * 2) / 3, 屏幕Y);
                            ctx.stroke();
                        } else if (this.墙壁.上) {
                            ctx.beginPath();
                            ctx.moveTo(屏幕X, 屏幕Y);
                            ctx.lineTo(屏幕X + 单元格大小, 屏幕Y);
                            ctx.stroke();
                        }
                        if (
                            this.isOneWay &&
                            this.oneWayAllowedDirection &&
                            [单元格类型.门, 单元格类型.上锁的门].includes(
                                this.背景类型
                            )
                        ) {
                            ctx.font = `${单元格大小 * 0.7}px Arial`; // Slightly smaller arrow
                            ctx.fillStyle = "rgba(255, 255, 255, 0.85)"; // Brighter white arrow
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            let arrow = "";

                            // Arrow should point in the direction of allowed travel
                            if (this.oneWayAllowedDirection === "N")
                                arrow = "↑";
                            else if (this.oneWayAllowedDirection === "S")
                                arrow = "↓";
                            else if (this.oneWayAllowedDirection === "E")
                                arrow = "→";
                            else if (this.oneWayAllowedDirection === "W")
                                arrow = "←";

                            // Center the arrow in the cell
                            const arrowX = 屏幕X + 单元格大小 / 2;
                            const arrowY = 屏幕Y + 单元格大小 / 2;

                            // Optional: Add a small shadow for better visibility
                            ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
                            ctx.shadowBlur = 3;
                            ctx.shadowOffsetX = 1;
                            ctx.shadowOffsetY = 1;

                            ctx.fillText(arrow, arrowX, arrowY);

                            ctx.shadowColor = "transparent"; // Reset shadow
                            ctx.shadowBlur = 0;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                        }

                        // 绘制普通墙壁
                        ctx.strokeStyle = "#e0e0e0";
                        if (this.墙壁.右) {
                            ctx.beginPath();
                            ctx.moveTo(屏幕X + 单元格大小, 屏幕Y);
                            ctx.lineTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小);
                            ctx.stroke();
                        }
                        if (this.墙壁.下) {
                            ctx.beginPath();
                            ctx.moveTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小);
                            ctx.lineTo(屏幕X, 屏幕Y + 单元格大小);
                            ctx.stroke();
                        }
                        if (this.墙壁.左) {
                            ctx.beginPath();
                            ctx.moveTo(屏幕X, 屏幕Y + 单元格大小);
                            ctx.lineTo(屏幕X, 屏幕Y);
                            ctx.stroke();
                        }

                        if (this.关联物品) {
                            this.绘制物品(屏幕X, 屏幕Y);
                        }
                    }
                }
                绘制物品(屏幕X, 屏幕Y) {
                    if (this.关联物品) {
                        if (this.关联物品.是否为隐藏物品) {
                            return;
                        }
                        ctx.font = `${单元格大小 * 0.8}px color-emoji`;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";

                        if (this.获取物品颜色() !== "#FFFFFF") {
                            ctx.fillStyle = this.获取物品颜色();
                        } else {
                            ctx.fillStyle = "#000";
                        }
                        if (this.关联物品.类型 === "药水") {
                            ctx.fillStyle = this.关联物品.获取药水颜色();
                        }
                        if (this.关联物品.类型 === "金币") {
                            ctx.fillStyle = 颜色表[2];
                        }
                        ctx.fillText(
                            this.关联物品.显示图标,
                            屏幕X + 单元格大小 / 2,
                            屏幕Y + 单元格大小 / 2
                        );

                        if (this.颜色索引 < 颜色表.length) {
                            ctx.shadowColor = this.获取物品颜色();
                            if (this.关联物品.类型 === "药水") {
                                ctx.shadowColor = this.关联物品.获取药水颜色();
                            }
                            if (this.关联物品.类型 === "金币") {
                                ctx.shadowColor = 颜色表[2];
                            }
                            ctx.shadowBlur = 15;
                        }
                        if (
                            this.关联物品 instanceof 火把 &&
                            this.关联物品.自定义数据.get("耐久") > 0
                        ) {
                            const 闪烁强度 = Math.abs(
                                Math.sin(Date.now() / 200)
                            );
                            ctx.shadowColor = `rgba(255, 165, 0, ${
                                0.5 + 闪烁强度 * 0.4
                            })`;
                            ctx.shadowBlur = 8 + 闪烁强度 * 5;
                        }
                        ctx.fillText(
                            this.关联物品.显示图标,
                            屏幕X + 单元格大小 / 2,
                            屏幕Y + 单元格大小 / 2
                        );
                        ctx.shadowBlur = 0;
                        if (this.关联物品.堆叠数量 > 1) {
                            ctx.font = `${单元格大小 * 0.4}px Arial`;
                            ctx.fillStyle = "#FFFFFF";
                            ctx.strokeStyle = "#000000";
                            ctx.lineWidth = 2;
                            ctx.textAlign = "right";
                            ctx.textBaseline = "bottom";

                            ctx.strokeText(
                                this.关联物品.堆叠数量,
                                屏幕X + 单元格大小 - 4,
                                屏幕Y + 单元格大小 - 4
                            );
                            ctx.fillText(
                                this.关联物品.堆叠数量,
                                屏幕X + 单元格大小 - 4,
                                屏幕Y + 单元格大小 - 4
                            );
                        }
                        if (this.关联物品.是否被丢弃) {
                            ctx.save();
                            ctx.font = `${单元格大小 * 0.4}px Arial`;
                            ctx.fillStyle = "#AAAAAA";
                            ctx.textAlign = "right";
                            ctx.textBaseline = "top";
                            ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                            ctx.shadowBlur = 2;
                            ctx.shadowOffsetX = 1;
                            ctx.shadowOffsetY = 1;
                            ctx.fillText(
                                "丢",
                                屏幕X + 单元格大小 - 3,
                                屏幕Y + 3
                            );
                            ctx.restore();
                        }
                        if (
                            (this.关联物品 instanceof 火把 ||
                                this.关联物品 instanceof 护卫植物 ||
                                this.关联物品 instanceof 远射植物) &&
                            this.关联物品.自定义数据.has("耐久")
                        ) {
                            const 耐久百分比 =
                                this.关联物品.自定义数据.get("耐久") /
                                this.关联物品.自定义数据.get("原耐久");
                            ctx.fillStyle = "rgba(0,0,0,0.6)";
                            ctx.fillRect(
                                屏幕X + 单元格大小 * 0.1,
                                屏幕Y + 单元格大小 * 0.85,
                                单元格大小 * 0.8,
                                单元格大小 * 0.1
                            );
                            ctx.fillStyle =
                                耐久百分比 > 0.5
                                    ? "#4CAF50"
                                    : 耐久百分比 > 0.2
                                    ? "#FFC107"
                                    : "#F44336";
                            ctx.fillRect(
                                屏幕X + 单元格大小 * 0.1,
                                屏幕Y + 单元格大小 * 0.85,
                                单元格大小 * 0.8 * 耐久百分比,
                                单元格大小 * 0.1
                            );
                        }
                    }
                }

                获取物品颜色() {
                    // 根据物品类型返回颜色
                    if (
                        this.类型 === 单元格类型.楼梯下楼 ||
                        this.类型 === 单元格类型.楼梯上楼
                    )
                        return "#000";
                    return this.关联物品
                        ? this.关联物品.颜色表[this.关联物品.颜色索引] ||
                              "#FFFFFF"
                        : "#FFFFFF";
                }
            }

            function drawPath(path) {
                if (path.length < 2) return;

                ctx.save();
                ctx.beginPath();

                // 设置线条样式
                ctx.strokeStyle = "rgba(255, 50, 50, 0.5)";
                ctx.lineWidth = 2 * window.devicePixelRatio; // 适应高清屏
                ctx.setLineDash([5, 15]);
                ctx.lineJoin = "round";
                ctx.lineCap = "round";

                const startX = (玩家.x - 当前相机X + 0.5) * 单元格大小;
                const startY = (玩家.y - 当前相机Y + 0.5) * 单元格大小;
                ctx.moveTo(startX, startY);

                // 连接后续点
                for (let i = 1; i < path.length; i++) {
                    const { x, y } = path[i];
                    const pointX = (x - 当前相机X + 0.5) * 单元格大小;
                    const pointY = (y - 当前相机Y + 0.5) * 单元格大小;
                    ctx.lineTo(pointX, pointY);
                }

                ctx.stroke();
                ctx.restore();
            }
            物品池 = 创建物品池();
            怪物池 = 创建怪物池();

            // 屏幕方向检测
            let resizeTimer;
            function handleResize() {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    初始化canvas();
                    更新物体指示器();
                    绘制();
                }, 200);
            }

            window.addEventListener("resize", handleResize);
            handleResize();

            function 开始移动() {
                控制键处理移动(true);
            }

            function 控制键处理移动(PC = false) {
                clearTimeout(移动定时器);
                clearTimeout(单击移动定时器); // 清除之前的 单击移动定时器

                const 立即移动 = () => {
                    const dx = 移动状态.left
                        ? -玩家属性.移动步数
                        : 移动状态.right
                        ? 玩家属性.移动步数
                        : 0;
                    const dy = 移动状态.up
                        ? -玩家属性.移动步数
                        : 移动状态.down
                        ? 玩家属性.移动步数
                        : 0;

                    if (dx !== 0 || dy !== 0) {
                        移动玩家(dx, dy);
                    }
                };

                const 持续移动 = () => {
                    if (
                        !移动状态.left &&
                        !移动状态.right &&
                        !移动状态.up &&
                        !移动状态.down
                    )
                        return;

                    const now = Date.now();
                    if (now - 最后移动时间 >= 移动间隔) {
                        长按移动 = true;
                        立即移动();
                        最后移动时间 = now;
                    }
                    移动定时器 = requestAnimationFrame(持续移动);
                };

                立即移动();
                if (PC) {
                    长按移动 = true;
                    最后移动时间 = Date.now();
                    移动定时器 = setTimeout(() => {
                        cancelAnimationFrame(移动定时器);
                        移动定时器 = requestAnimationFrame(持续移动);
                    }, 0);
                } else {
                    最后移动时间 = Date.now();

                    // 如果是长按，则在 首次移动延迟 后开始持续移动
                    移动定时器 = setTimeout(() => {
                        cancelAnimationFrame(移动定时器);
                        移动定时器 = requestAnimationFrame(持续移动);
                    }, 首次移动延迟);
                }
            }
            function 停止移动() {
                clearTimeout(移动定时器);
                clearTimeout(单击移动定时器);
                clearTimeout(开始移动定时器);
                移动状态 = {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                };
                长按移动 = false;
            }
            function 显示HUD() {
                if (hud模式 === "常隐") return;
                if (hud模式 === "默认") {
                    if (显示HUD计时器) clearTimeout(显示HUD计时器);
                    document.querySelector(".hud").classList.add("可见");
                    显示HUD计时器 = setTimeout(() => {
                        隐藏HUD();
                    }, 700);
                } else {
                    document.querySelector(".hud").classList.add("可见");
                }
            }

            function 隐藏HUD() {
                if (hud模式 !== "默认") return;
                document.querySelector(".hud").classList.remove("可见");
            }

            function 切换HUD模式() {
                const 模式顺序 = ["默认", "常显", "常隐"];
                const 当前索引 = 模式顺序.indexOf(hud模式);
                hud模式 = 模式顺序[(当前索引 + 1) % 3];

                // 更新按钮图标
                const 按钮图标映射 = {
                    默认: 图标映射.HUD智能,
                    常显: 图标映射.HUD常显,
                    常隐: 图标映射.HUD常隐,
                };
                document.getElementById("hudToggle").textContent =
                    按钮图标映射[hud模式];

                // 立即应用新模式
                if (hud模式 === "常显") {
                    document.querySelector(".hud").classList.add("可见");
                } else if (hud模式 === "常隐") {
                    document.querySelector(".hud").classList.remove("可见");
                } else {
                    隐藏HUD(); // 恢复默认模式隐藏
                }
            }
            function 触发HUD显示() {
                if (hud模式 === "默认") {
                    if (显示HUD计时器) clearTimeout(显示HUD计时器);
                    document.querySelector(".hud").classList.add("可见");
                    显示HUD计时器 = setTimeout(() => {
                        隐藏HUD();
                    }, 700);
                }
            }

            // 防止长按触发文字选择
            document.addEventListener("contextmenu", (e) => e.preventDefault());

            const 添加控制事件 = (元素, 方向) => {
                const 事件类型 = {
                    start:
                        "ontouchstart" in window ? "touchstart" : "mousedown",
                    end: "ontouchend" in window ? "touchend" : "mouseup",
                };

                元素.addEventListener(事件类型.start, (e) => {
                    e.preventDefault();
                    移动状态[方向] = true;
                    控制键处理移动();
                });

                元素.addEventListener(事件类型.end, () => {
                    移动状态[方向] = false;
                    停止移动();
                });
            };

            添加控制事件(upBtn, "up");
            添加控制事件(leftBtn, "left");
            添加控制事件(rightBtn, "right");
            添加控制事件(downBtn, "down");
            function 深度比较(a, b) {
                if (a === b) return true;
                if (
                    typeof a !== "object" ||
                    typeof b !== "object" ||
                    a === null ||
                    b === null
                )
                    return false;

                const aKeys = Object.keys(a);
                const bKeys = Object.keys(b);
                if (aKeys.length !== bKeys.length) return false;

                for (const key of aKeys) {
                    if (!b.hasOwnProperty(key)) return false;
                    if (!深度比较(a[key], b[key])) return false;
                }
                return true;
            }

            // 更新HUD显示
            function 更新界面状态() {
                document.getElementById("roomCount").textContent =
                    已访问房间.size;
            }

            function 初始化canvas() {
                画布宽度 = Math.min(
                    window.innerWidth - 20,
                    window.innerHeight - 100
                ); // 动态宽度
                画布高度 = 画布宽度; // 动态高度

                // 保持单元格比例
                const 单元格宽 = 画布宽度 / 相机显示边长;
                const 单元格高 = 画布高度 / 相机显示边长;

                单元格大小 = Math.min(单元格宽, 单元格高);
                ctx.imageSmoothingEnabled = false;
                ctx.webkitImageSmoothingEnabled = false;
                const dpr = window.devicePixelRatio;
                const width = 单元格大小 * 相机显示边长,
                    height = 单元格大小 * 相机显示边长;
                // 重新设置 canvas 自身宽高大小和 css 大小。放大 canvas；css 保持不变，因为我们需要那么多的点
                canvas.width = Math.round(width * dpr);
                canvas.height = Math.round(height * dpr);
                canvas.style.width = width + "px";
                canvas.style.height = height + "px";
                // 直接用 scale 放大整个坐标系，相对来说就是放大了每个绘制操作
                ctx.scale(dpr, dpr);
                // 初始化小地图
                const 小地图 = document.getElementById("小地图");
                小地图.width = 地牢大小 * 小地图缩放;
                小地图.height = 地牢大小 * 小地图缩放;
                小地图Ctx = 小地图.getContext("2d");
            }

            function 生成地牢() {
                地牢 = Array(地牢大小)
                    .fill()
                    .map((_, y) =>
                        Array(地牢大小)
                            .fill()
                            .map((_, x) => new 单元格(x, y))
                    );

                let 已连接房间对 = new Set();

                let 房间宽度 =
                    房间尺寸范围[0] +
                    2 *
                        Math.floor(
                            (Math.random() *
                                (房间尺寸范围[1] - 房间尺寸范围[0])) /
                                2
                        );
                let 房间高度 =
                    房间尺寸范围[0] +
                    2 *
                        Math.floor(
                            (Math.random() *
                                (房间尺寸范围[1] - 房间尺寸范围[0])) /
                                2
                        );
                let 房间起始X = Math.floor(地牢大小 / 2 - 房间宽度 / 2);
                let 房间起始Y = Math.floor(地牢大小 / 2 - 房间高度 / 2);
                房间列表.push({
                    x: 房间起始X,
                    y: 房间起始Y,
                    w: 房间宽度,
                    h: 房间高度,
                    id: 0,
                    门: [],
                });
                放置房间(房间列表[0]);
                let 回溯 = false;
                for (let i = 1; i < 最大房间数; i++) {
                    let 放置成功 = false;
                    let 尝试次数 = 0;

                    while (!放置成功 && 尝试次数 < 300) {
                        尝试次数++;
                        let 上一个房间 = 房间列表[i - 1];
                        if (回溯)
                            上一个房间 =
                                房间列表[
                                    i -
                                        Math.floor(
                                            (Math.max(0, 尝试次数 - 10) / 40) *
                                                (房间列表.length - 2)
                                        ) -
                                        1
                                ];
                        房间宽度 =
                            房间尺寸范围[0] +
                            2 *
                                Math.floor(
                                    (Math.random() *
                                        (房间尺寸范围[1] - 房间尺寸范围[0])) /
                                        2
                                );
                        房间高度 =
                            房间尺寸范围[0] +
                            2 *
                                Math.floor(
                                    (Math.random() *
                                        (房间尺寸范围[1] - 房间尺寸范围[0])) /
                                        2
                                );

                        const 方向 = Math.floor(Math.random() * 4);

                        const 扩展距离 =
                            Math.floor(
                                Math.random() * Math.max(0, 尝试次数 - 10)
                            ) +
                            房间尺寸范围[1] +
                            2;

                        switch (方向) {
                            case 0:
                                房间起始X =
                                    上一个房间.x +
                                    Math.floor((上一个房间.w - 房间宽度) / 2);
                                房间起始Y = 上一个房间.y - 房间高度 - 扩展距离;
                                break;
                            case 1:
                                房间起始X =
                                    上一个房间.x + 上一个房间.w + 扩展距离;
                                房间起始Y =
                                    上一个房间.y +
                                    Math.floor((上一个房间.h - 房间高度) / 2);
                                break;
                            case 2:
                                房间起始X =
                                    上一个房间.x +
                                    Math.floor((上一个房间.w - 房间宽度) / 2);
                                房间起始Y =
                                    上一个房间.y + 上一个房间.h + 扩展距离;
                                break;
                            case 3:
                                房间起始X = 上一个房间.x - 房间宽度 - 扩展距离;
                                房间起始Y =
                                    上一个房间.y +
                                    Math.floor((上一个房间.h - 房间高度) / 2);
                                break;
                        }

                        房间起始X = Math.max(
                            5,
                            Math.min(房间起始X, 地牢大小 - 房间宽度 - 5)
                        );
                        房间起始Y = Math.max(
                            5,
                            Math.min(房间起始Y, 地牢大小 - 房间高度 - 5)
                        );

                        if (
                            区域是否空闲(
                                房间起始X,
                                房间起始Y,
                                房间宽度,
                                房间高度
                            )
                        ) {
                            let 房间类型 = "房间";
                            if (房间列表.length > 2 && Math.random() < 0.12) {
                                房间类型 = "挑战房间";
                            } else if (
                                房间列表.length > 2 &&
                                Math.random() < 0.15
                            ) {
                                房间类型 = "单向房间";
                            } else if (
                                房间列表.length > 2 &&
                                Math.random() < 0.1
                            ) {
                                房间类型 = "黑暗房间";
                            }

                            const 新房间 = {
                                x: 房间起始X,
                                y: 房间起始Y,
                                w: 房间宽度,
                                h: 房间高度,
                                id: i,
                                门: [],
                                类型: 房间类型,
                            };
                            if (房间类型 === "挑战房间") {
                                新房间.挑战状态 = {
                                    进行中: false,
                                    已完成: false,
                                    当前波次: 0,
                                    总波次: 4 + Math.round(Math.random()*Math.floor(当前层数 / 2)) + (玩家属性.挑战波数增加 || 0),
                                    波次最大回合数: 30 + 当前层数 * 3,
                                    波次当前回合数: 0,
                                    波次内怪物: [],
                                    原始门数据: [],
                                };
                            }
                            房间列表.push(新房间);
                            放置房间(新房间);
                            const 房间对ID = [房间列表[i - 1].id, 新房间.id]
                                .sort()
                                .join("-");
                            // 检查是否已经连接过
                            if (!已连接房间对.has(房间对ID)) {
                                let 路径 = 连接房间(房间列表[i - 1], 新房间);
                                if (路径) {
                                    生成走廊(路径);
                                    已连接房间对.add(房间对ID);
                                }
                            }
                            

                            放置成功 = true;
                        }
                    }
                    回溯 = false;
                    if (!放置成功) {
                        console.log(`第${i}个房间多次尝试后仍然放置失败`);
                        回溯 = true;
                    }
                }
                添加额外走廊(房间列表, 5, 已连接房间对);
                let has特殊房间生成 = false;
                if (Math.random() < 0.5) {
                    生成特殊房间();
                    has特殊房间生成 = true;
                }
                
                生成墙壁();

                const 第一个房间 = 房间列表[0];
                房间列表[1].类型='房间'
                玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
                玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;

                if (房间列表.length > 4) {
                    处理上锁的门();
                    生成钥匙();
                }
                if (has特殊房间生成) 生成寻宝戒指();
                生成金币();
                生成物品();
                生成怪物();
                if (当前层数 === 0) {
                    const 初始武器 = new 钢制长剑({ 不可破坏: true }); //初始装备
                    放置物品到房间(初始武器, 房间列表[0]);
                }
                更新视口();
                已访问房间.add(第一个房间.id); // 标记为已访问
                房间列表.forEach((房间) => 更新房间墙壁(房间));

                const 距离图 = 计算距离图(玩家初始位置.x, 玩家初始位置.y);

                // 寻找最远的可达房间（非特殊、非起点）
                let 最远距离 = -1;
                let 最远房间 = null;
                const 可用房间 = 房间列表.filter(
                    (房间) => 房间.id !== 0 && 房间.类型 == "房间"
                );

                可用房间.forEach((房间) => {
                    const 中心X = 房间.x + Math.floor(房间.w / 2);
                    const 中心Y = 房间.y + Math.floor(房间.h / 2);
                    const 距离 = 距离图[中心Y]?.[中心X]; // 使用中心点距离
                    生成陷阱(房间);

                    if (
                        距离 !== undefined &&
                        距离 !== Infinity &&
                        距离 > 最远距离
                    ) {
                        最远距离 = 距离;
                        最远房间 = 房间;
                    }
                });

                if (!最远房间 && 可用房间放楼梯.length > 0) {
                    最远房间 =
                        可用房间[
                            Math.floor(Math.random() * 可用房间.length)
                        ];
                    console.warn(
                        "未能通过距离找到最远房间放置楼梯，已随机选择。"
                    );
                }
                放置楼梯(最远房间, 楼梯图标.下楼, 单元格类型.楼梯下楼);
                if (当前层数 > 0) {
                    放置楼梯(第一个房间, 楼梯图标.上楼, 单元格类型.楼梯上楼);
                }
                更新界面状态();
                return;
            }
                        function 生成陷阱(房间) {
                 if (房间.id === 0 || 房间.类型 !== '房间') return;
                 const 陷阱池 = [
                    { 类: 隐形落石陷阱, 权重: 20 },
                    { 类: 隐形地刺陷阱, 权重: 20 },
                    { 类: 远射陷阱, 权重: 8 },
                    { 类: 隐形失明陷阱, 权重: 12 },
                    { 类: 召唤怪物陷阱, 权重: 10 },
                    { 类: 烈焰触发陷阱, 权重: 5 },
                    { 类: 隐形虫洞陷阱, 权重: 10 },
                 ];
                 
                 const 是否上锁 = 上锁房间列表.some(r => r.id === 房间.id);

                 if (Math.random() < 0.18) {
                     生成毒气陷阱群(房间);
                 }

                 const 陷阱数量 = Math.random() < 0.5 ? Math.ceil(Math.random()*5) : 0;

                 for (let i=0; i < 陷阱数量; i++) {
                     const 选定陷阱配置 = 加权随机选择(陷阱池.map(t => ({值: t, 权重: t.权重})));
                     if (选定陷阱配置) {
                         const 强化状态 = 是否上锁 || (Math.random() < 0.1 + 当前层数 * 0.025);
                         const 陷阱实例 = new 选定陷阱配置.类({强化: 强化状态});
                         if (选定陷阱配置.类 === 远射陷阱) {
                             放置怪物到房间(陷阱实例, 房间);
                         } else {
                             放置物品到房间(陷阱实例, 房间);
                         }
                     }
                 }
            }
            function 计算距离图(起始X, 起始Y) {
                const 距离图 = Array(地牢大小)
                    .fill(null)
                    .map(() => Array(地牢大小).fill(Infinity));
                const 队列 = [[起始X, 起始Y, 0]]; // x, y, 距离
                距离图[起始Y][起始X] = 0;
                const 已访问 = new Set([`${起始X},${起始Y}`]);
                const 方向 = [
                    { dx: 0, dy: -1, 当前墙: "上", 反方向墙: "下" },
                    { dx: 0, dy: 1, 当前墙: "下", 反方向墙: "上" },
                    { dx: -1, dy: 0, 当前墙: "左", 反方向墙: "右" },
                    { dx: 1, dy: 0, 当前墙: "右", 反方向墙: "左" },
                ];

                while (队列.length > 0) {
                    const [x, y, 距离] = 队列.shift();

                    for (const dir of 方向) {
                        const 新X = x + dir.dx;
                        const 新Y = y + dir.dy;

                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            continue;

                        const 位置键 = `${新X},${新Y}`;
                        if (已访问.has(位置键)) continue;

                        const 当前单元格 = 地牢[y]?.[x];
                        const 下一单元格 = 地牢[新Y]?.[新X];

                        // 检查移动是否有效（非墙、非锁门、路径通畅）
                        if (
                            当前单元格 &&
                            下一单元格 &&
                            ![单元格类型.墙壁, 单元格类型.上锁的门].includes(
                                下一单元格.背景类型
                            ) &&
                            !当前单元格.墙壁[dir.当前墙] &&
                            !下一单元格.墙壁[dir.反方向墙]
                        ) {
                            距离图[新Y][新X] = 距离 + 1;
                            已访问.add(位置键);
                            队列.push([新X, 新Y, 距离 + 1]);
                        }
                    }
                }
                return 距离图;
            }
            function 寻找可放置位置(中心X, 中心Y) {
                const 方向 = [
                    [0, 0],
                    [0, -1],
                    [1, 0],
                    [0, 1],
                    [-1, 0],
                ];
                for (const [dx, dy] of 方向) {
                    const 检查X = 中心X + dx;
                    const 检查Y = 中心Y + dy;
                    if (
                        检查X >= 0 &&
                        检查X < 地牢大小 &&
                        检查Y >= 0 &&
                        检查Y < 地牢大小 &&
                        位置是否可用(检查X, 检查Y, false)
                    ) {
                        return { x: 检查X, y: 检查Y };
                    }
                }
                return null;
            }
            function 生成罐子房间内容(房间) {
                for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                    for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                        if ((x + y) % 2 === 0) {
                            if (Math.random() < 0.3) {
                                放置物品到单元格(new 空罐子({}), x, y);
                            } else {
                                放置物品到单元格(new 罐子({}), x, y);
                            }
                        }
                    }
                }
            }

            function 生成植物房间内容(房间) {
                放置物品到房间(new 泉水({}), 房间);

                const 种子池 = [
                    { 类: 荆棘种子, 权重: 35 },
                    { 类: 护卫种子, 权重: 30 },
                    { 类: 远射种子, 权重: 25 },
                    { 类: 吸能种子, 权重: 10 },
                ];

                for (let i = 0; i < 6; i++) {
                    const 选定种子配置 = 加权随机选择(
                        种子池.map((s) => ({ 值: s, 权重: s.权重 }))
                    );
                    if (选定种子配置) {
                        const 数量 = 2 + Math.floor(Math.random() * 2);
                        const 种子实例 = new 选定种子配置.类({ 数量: 数量 });
                        放置物品到房间(种子实例, 房间);
                    }
                }
            }

            function 生成药水房内容(房间) {
                //放置物品到房间(new 泉水({}), 房间);

                const 药水池 = 物品池["药水"];
                const 药水数量 = 3 + Math.floor(Math.random() * 3);

                for (let i = 0; i < 药水数量; i++) {
                    const 选定药水配置 =
                        药水池[Math.floor(Math.random() * 药水池.length)];
                    if (选定药水配置) {
                        const 药水实例 = new 选定药水配置.类({
                            强化: Math.random() < 0.3,
                        });
                        放置物品到房间(药水实例, 房间);
                    }
                }

                const 怪物数量 = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < 怪物数量; i++) {
                    放置怪物到房间(new 伪装怪物({ 伪装成: "药水" }), 房间);
                }
            }
            function 生成书库房间内容(房间) {
                const 书架数量 = Math.floor(
                    房间.w * 房间.h * (0.15 + Math.random() * 0.2)
                );
                for (let i = 0; i < 书架数量; i++) {
                    放置物品到房间(
                        new 书架({ 有内容: Math.random() < 0.2 }),
                        房间
                    );
                }
                const 怪物数量 = Math.floor(
                    房间.w * 房间.h * (0.1 + Math.random() * 0.2)
                );
                for (let i = 0; i < 怪物数量; i++) {
                    放置怪物到房间(new 伪装怪物({ 伪装成: "书架" }), 房间);
                }
            }
            function 生成特殊房间() {
                let 房间宽度, 房间高度, 房间起始X, 房间起始Y;
                let 放置成功 = false;
                let 尝试次数 = 0;

                const 房间主题列表 = [
                    { 类型: "隐藏解谜棋盘", 概率: 0.15 },
                    { 类型: "隐藏罐子房间", 概率: 0.25 },
                    { 类型: "隐藏植物房间", 概率: 0.2 },
                    { 类型: "隐藏书库房间", 概率: 0.25 },
                    { 类型: "隐藏药水房间", 概率: 0.15 },
                ];

                const 选定主题 = 加权随机选择(
                    房间主题列表.map((t) => ({ 值: t.类型, 权重: t.概率 }))
                );

                while (!放置成功 && 尝试次数 < 100) {
                    尝试次数++;
                    房间宽度 = Math.floor(Math.random() * 3) + 7;
                    房间高度 = 房间宽度;
                    房间起始X =
                        Math.floor(Math.random() * (地牢大小 - 房间宽度 - 2)) +
                        1;
                    房间起始Y =
                        Math.floor(Math.random() * (地牢大小 - 房间高度 - 2)) +
                        1;

                    if (
                        区域是否空闲(房间起始X, 房间起始Y, 房间宽度, 房间高度)
                    ) {
                        const 新房间 = {
                            x: 房间起始X,
                            y: 房间起始Y,
                            w: 房间宽度,
                            h: 房间高度,
                            id: 房间列表.length,
                            门: [],
                            已连接: false,
                            类型: 选定主题,
                        };
                        房间列表.push(新房间);
                        放置房间(新房间);

                        switch (选定主题) {
                            case "隐藏解谜棋盘":
                                生成解谜棋盘(新房间);
                                break;
                            case "隐藏罐子房间":
                                生成罐子房间内容(新房间);
                                break;
                            case "隐藏植物房间":
                                生成植物房间内容(新房间);
                                break;
                            case "隐藏书库房间":
                                生成书库房间内容(新房间);
                                break;
                            case "隐藏药水房间":
                                生成药水房内容(新房间);
                                break;
                        }
                        放置成功 = true;
                    }
                }
            }
            function 生成寻宝戒指() {
                // 排除已经作为特殊房间的房间
                const 可用房间 = 房间列表.filter((房间) => 房间.类型 == "房间");
                if (可用房间.length === 0) return; // 没有可用房间则不生成

                const 目标房间 =
                    可用房间[Math.floor(Math.random() * 可用房间.length)];
                const 新戒指 = new 寻宝戒指({ 生效层数: 当前层数 });
                放置物品到房间(新戒指, 目标房间);
            }

            function 连接特殊房间(特殊房间) {
                let 最近房间 = null;
                let 最小距离 = Infinity;

                for (const 房间 of 房间列表) {
                    if (房间 === 特殊房间 || 房间.已连接) continue; // 排除特殊房间本身和已连接的房间

                    const 距离 =
                        Math.abs(特殊房间.x - 房间.x) +
                        Math.abs(特殊房间.y - 房间.y);
                    if (距离 < 最小距离) {
                        最小距离 = 距离;
                        最近房间 = 房间;
                    }
                }
                if (最近房间) {
                    let 路径 = 连接房间(特殊房间, 最近房间);

                    if (路径) {
                        生成走廊(路径);
                        特殊房间.已连接 = true; // 标记为已连接
                    } else {
                        添加日志(
                            `无法将特殊房间连接到地牢！房间 ID: ${特殊房间.id}`,
                            `错误`
                        );
                    }
                } else {
                    添加日志(
                        `没有找到可连接的房间！房间 ID: ${特殊房间.id}`,
                        `错误`
                    );
                }
            }
            function 生成墙壁() {
                for (let y = 0; y < 地牢大小; y++) {
                    for (let x = 0; x < 地牢大小; x++) {
                        const 当前单元格 = 地牢[y][x];
                        if (当前单元格.背景类型 !== 单元格类型.墙壁) {
                            if (
                                [
                                    单元格类型.墙壁,
                                    单元格类型.走廊,
                                    单元格类型.房间,
                                ].includes(当前单元格.背景类型)
                            ) {
                                地牢[y][x].墙壁 = {
                                    上:
                                        y > 0 &&
                                        地牢[y - 1][x].背景类型 !==
                                            地牢[y][x].背景类型 &&
                                        [
                                            单元格类型.墙壁,
                                            单元格类型.走廊,
                                            单元格类型.房间,
                                        ].includes(地牢[y - 1][x].背景类型),
                                    下:
                                        y < 地牢大小 - 1 &&
                                        地牢[y + 1][x].背景类型 !==
                                            地牢[y][x].背景类型 &&
                                        [
                                            单元格类型.墙壁,
                                            单元格类型.走廊,
                                            单元格类型.房间,
                                        ].includes(地牢[y + 1][x].背景类型),
                                    左:
                                        x > 0 &&
                                        地牢[y][x - 1].背景类型 !==
                                            地牢[y][x].背景类型 &&
                                        [
                                            单元格类型.墙壁,
                                            单元格类型.走廊,
                                            单元格类型.房间,
                                        ].includes(地牢[y][x - 1].背景类型),
                                    右:
                                        x < 地牢大小 - 1 &&
                                        地牢[y][x + 1].背景类型 !==
                                            地牢[y][x].背景类型 &&
                                        [
                                            单元格类型.墙壁,
                                            单元格类型.走廊,
                                            单元格类型.房间,
                                        ].includes(地牢[y][x + 1].背景类型),
                                };
                            } else {
                                地牢[y][x].墙壁 = {
                                    上:
                                        y > 0 &&
                                        地牢[y - 1][x].背景类型 ===
                                            单元格类型.墙壁,
                                    下:
                                        y < 地牢大小 - 1 &&
                                        地牢[y + 1][x].背景类型 ===
                                            单元格类型.墙壁,
                                    左:
                                        x > 0 &&
                                        地牢[y][x - 1].背景类型 ===
                                            单元格类型.墙壁,
                                    右:
                                        x < 地牢大小 - 1 &&
                                        地牢[y][x + 1].背景类型 ===
                                            单元格类型.墙壁,
                                };
                            }
                            const directions = [
                                { dx: 0, dy: -1, 墙: "上", 反向墙: "下" },
                                { dx: 0, dy: 1, 墙: "下", 反向墙: "上" },
                                { dx: -1, dy: 0, 墙: "左", 反向墙: "右" },
                                { dx: 1, dy: 0, 墙: "右", 反向墙: "左" },
                            ];

                            directions.forEach((dir) => {
                                const nx = x + dir.dx;
                                const ny = y + dir.dy;

                                if (
                                    nx >= 0 &&
                                    nx < 地牢大小 &&
                                    ny >= 0 &&
                                    ny < 地牢大小
                                ) {
                                    if (
                                        地牢[ny][nx].背景类型 ===
                                        单元格类型.墙壁
                                    ) {
                                        地牢[y][x].墙壁[dir.墙] = true; // 当前单元格
                                        地牢[ny][nx].墙壁[dir.反向墙] = true; // 相邻单元格
                                    }
                                }
                            });
                        }
                    }
                }
                for (let y = 0; y < 地牢大小; y++) {
                    for (let x = 0; x < 地牢大小; x++) {
                        const 当前单元格 = 地牢[y]?.[x];
                        if (!当前单元格) continue;

                        const 配对位置 = 当前单元格.配对单元格位置;
                        if (
                            配对位置 &&
                            [
                                单元格类型.走廊,
                                单元格类型.门,
                                单元格类型.上锁的门,
                            ].includes(当前单元格.背景类型)
                        ) {
                            const 配对单元格 = 地牢[配对位置.y]?.[配对位置.x];
                            // 确保配对单元格存在且类型匹配
                            if (
                                配对单元格 &&
                                配对单元格.背景类型 === 当前单元格.背景类型
                            ) {
                                // 根据相对位置移除墙壁
                                if (配对位置.x > x) {
                                    // 配对在右
                                    当前单元格.墙壁.右 = false;
                                    配对单元格.墙壁.左 = false;
                                } else if (配对位置.x < x) {
                                    // 配对在左
                                    当前单元格.墙壁.左 = false;
                                    配对单元格.墙壁.右 = false;
                                } else if (配对位置.y > y) {
                                    // 配对在下
                                    当前单元格.墙壁.下 = false;
                                    配对单元格.墙壁.上 = false;
                                } else if (配对位置.y < y) {
                                    // 配对在上
                                    当前单元格.墙壁.上 = false;
                                    配对单元格.墙壁.下 = false;
                                }
                            }
                        }
                    }
                }
            }
            function 添加额外走廊(房间列表, 数量, 已连接房间对) {
                let 添加次数 = 0;
                let 尝试次数 = 0;

                while (添加次数 < 数量 && 尝试次数 < 100) {
                    尝试次数++;

                    const 房间A =
                        房间列表[Math.floor(Math.random() * 房间列表.length)];
                    const 房间B =
                        房间列表[Math.floor(Math.random() * 房间列表.length)];
                    if (房间A === 房间B) continue;

                    const 房间对ID = [房间A.id, 房间B.id].sort().join("-");
                    if (已连接房间对.has(房间对ID)) {
                        continue;
                    }

                    const 路径 = 连接房间(房间A, 房间B);

                    if (路径) {
                        已连接房间对.add(房间对ID);
                        生成走廊(路径);
                        添加次数++;
                    }
                }
            }
                        function 恢复挑战区域() {
                if (生存挑战备份单元格.length === 0) return;

                生存挑战备份单元格.forEach(备份 => {
                    const { x, y, 类型, 背景类型, 墙壁, 关联物品, 关联怪物, 颜色索引, 标识 } = 备份;
                    const 单元格 = 地牢[y]?.[x];
                    if (单元格) {
                        单元格.类型 = 类型;
                        单元格.背景类型 = 背景类型;
                        单元格.墙壁 = 墙壁;
                        单元格.关联物品 = 关联物品;
                        单元格.关联怪物 = 关联怪物;
                        单元格.颜色索引 = 颜色索引;
                        单元格.标识 = 标识;
                    }
                });

                生存挑战备份单元格 = []; 
                生成墙壁(); 
                绘制();
                显示通知("随着你的倒下，挑战结界消失了...", "信息");
            }
            let 上次死亡地点 = null;
            function 玩家死亡() {
                if (死亡界面已显示 || 游戏状态 === "图鉴") return;
                const 玩家房间ID = 房间地图[玩家.y][玩家.x];
                const 玩家所在房间 = 房间列表[玩家房间ID];
                if (生存挑战激活) {
                    恢复挑战区域();
                    生存挑战激活 = false;
                }
                if (玩家所在房间 && 玩家所在房间.isSurvivalChallenge) {
                    let 石碑 = null;
                    for(const row of 地牢) {
                        for(const cell of row) {
                            if (cell.关联物品 instanceof 挑战石碑 && cell.关联物品.自定义数据.get("已激活")) {
                                石碑 = cell.关联物品;
                                break;
                            }
                        }
                        if(石碑) break;
                    }

                    if (石碑) {
                        石碑.发放奖励(玩家所在房间.survivalWave);
                        石碑.自定义数据.set("已激活", false);
                        玩家所在房间.isSurvivalChallenge = false;
                    }
                }

                if (!是否为教程层 && 当前层数 !== null) {
                    上次死亡地点 = { 层数: 当前层数, x: 玩家.x, y: 玩家.y };
                }

                死亡界面已显示 = true;
                const 设置菜单 = document.getElementById("设置菜单");
                if (设置菜单 && 设置菜单.classList.contains("显示")) {
                    关闭设置菜单();
                }
                房间列表.forEach((房间实例) => {
                    if (
                        房间实例.类型 === "挑战房间" &&
                        房间实例.挑战状态 &&
                        房间实例.挑战状态.进行中
                    ) {
                        显示通知(
                            `由于你的死亡，房间 ${房间实例.id} 的挑战失败了！`,
                            "错误",
                            true,
                            3000
                        );
                        房间实例.挑战状态.进行中 = false;
                        房间实例.挑战状态.已完成 = true;

                        房间实例.挑战状态.原始门数据.forEach((门数据) => {
                            const 门单元格 = 地牢[门数据.y]?.[门数据.x];
                            if (门单元格) {
                                门单元格.背景类型 = 门数据.原类型;
                                门单元格.标识 = 门数据.原标识;
                                门单元格.颜色索引 = 门数据.原颜色索引;
                                门单元格.钥匙ID = 门数据.原钥匙ID;
                                if (
                                    门数据.原类型 === 单元格类型.上锁的门 &&
                                    门数据.原标识
                                ) {
                                    const 门实例 = 门实例列表.get(
                                        门数据.原标识
                                    );
                                    if (门实例) {
                                        门实例.类型 = "上锁的门";
                                        门实例.是否上锁 = true;
                                    }
                                } else if (
                                    门数据.原类型 === 单元格类型.门 &&
                                    门数据.原标识
                                ) {
                                    const 门实例 = 门实例列表.get(
                                        门数据.原标识
                                    );
                                    if (门实例) {
                                        门实例.类型 = "门";
                                        门实例.是否上锁 = false;
                                    }
                                }
                            }
                        });
                        生成墙壁();
                    }
                });
                const 死亡遮罩 = document.createElement("div");
                死亡遮罩.id = "死亡遮罩";
                死亡遮罩.innerHTML = `
                <div class="死亡内容容器">
                    <div class="骷髅容器">
                        <div class="动态骷髅">${图标映射.死亡图标}</div>
                    </div>
                    <div class="重生选项">
                        <button class="重生按钮" id="保留重生">
                            <span class="按钮图标">⚡</span>
                            从本层重生（保留物品）
                        </button>
                        <button class="重生按钮" id="重新开始">
                            <span class="按钮图标">🔄</span>
                            全新开始（第0层）
                        </button>
                    </div>
                </div>
            `;
                if (!是否为教程层 && 当前层数 !== null) {
                    let 死亡凭证 = 生成死亡凭证(当前层数);
                    添加日志(
                        `您已死亡，但您曾经到达 ${当前层数} 层，您的凭证是：` +
                            死亡凭证,
                        "信息"
                    );
                    CopyTextToClipboard(死亡凭证);
                }
                游戏状态 = "死亡界面";

                const 粒子容器 = document.createElement("div");
                粒子容器.className = "死亡粒子";
                死亡遮罩.appendChild(粒子容器);
                生成死亡粒子(粒子容器);

                const 显示确认对话框 = () => {
                    const 确认遮罩 = document.createElement("div");
                    确认遮罩.className = "确认对话框遮罩";
                    确认遮罩.innerHTML = `
                    <div class="确认对话框">
                        <h3>警告</h3>
                        <p>你确定要放弃所有进度，从头开始吗？<br>这将清除你所有的物品和探索记录！</p>
                        <div class="确认按钮容器">
                            <button class="确认按钮 确认按钮-确认">确认放弃</button>
                            <button class="确认按钮 确认按钮-取消">再想想</button>
                        </div>
                    </div>
                `;
                    document.body.appendChild(确认遮罩);

                    确认遮罩.querySelector(".确认按钮-确认").onclick = () => {
                        确认遮罩.remove();
                        处理重生(false);
                        游戏状态 = "游戏中";
                    };

                    确认遮罩.querySelector(".确认按钮-取消").onclick = () => {
                        确认遮罩.remove();
                    };
                };

                死亡遮罩.querySelector("#保留重生").addEventListener(
                    "click",
                    function () {
                        处理重生(true);
                        游戏状态 = "游戏中";
                        this.style.transform = "scale(0.95)";
                        setTimeout(() => {
                            this.style.transform = "";
                            所有怪物.forEach((m) => {
                                m.绘制血条(true);
                            });
                        }, 500);
                    }
                );

                死亡遮罩.querySelector("#重新开始").addEventListener(
                    "click",
                    function () {
                        显示确认对话框();
                    }
                );

                document.body.appendChild(死亡遮罩);
            }

            function 生成物品(生成房间 = null) {
                const 当前层数权重 = Math.min(Math.floor(当前层数 / 2), 1); // 每2层提升品质
                let 可用房间 = 房间列表.filter((房间) => 房间.类型 == "房间");
                if (生成房间) 可用房间 = 生成房间;
                可用房间.forEach((房间) => {
                    const 是否上锁 = 上锁房间列表.some((r) => r.id === 房间.id);
                    const 房间类型 = 是否上锁 ? "上锁房间" : "普通房间";
                    const 基础概率 = 是否上锁
                        ? 物品生成配置.基础概率.上锁房间
                        : 物品生成配置.基础概率.普通房间;

                    // 计算实际生成概率
                    let 实际概率 = 基础概率;
                    if (是否上锁) 实际概率 += 0.1 + 当前层数 * 0.05;
                    实际概率 = Math.min(实际概率, 0.85);

                    if (Math.random() > 实际概率) return;
                    let 物品数量 = 1;
                    if (是否上锁) {
                        while (Math.random() < 0.8) {
                            物品数量++;
                        }
                        物品数量 = Math.min(物品数量, 5);
                    }
                    for (let i = 0; i < 物品数量; i++) {
                        // 计算品质分布
                        const 品质分布 = Object.entries(
                            物品生成配置.品质权重
                        ).reduce((acc, [品质, 权重]) => {
                            const 总权重 = 权重[0] + 权重[1] * 当前层数权重;
                            if (总权重 > 0)
                                acc.push({
                                    品质: parseInt(品质),
                                    权重: 总权重,
                                });
                            return acc;
                        }, []);

                        // 选择物品类型
                        const 类型分布 = 物品生成配置.类型分布[房间类型];
                        const 选中类型 = 加权随机选择(类型分布);

                        // 过滤可用物品
                        const 可用物品 = 物品池[选中类型["类型"]].filter(
                            (item) =>
                                当前层数 >= item.最小层 &&
                                品质分布.some((q) => q.品质 === item.品质)
                        );

                        if (可用物品.length === 0) return;

                        // 加权选择品质
                        const 目标品质 = 加权随机选择(
                            品质分布.map((q) => ({
                                值: q.品质,
                                权重: q.权重,
                            }))
                        );

                        // 筛选符合品质的物品
                        const 候选物品 = 可用物品.filter(
                            (item) => item.品质 === 目标品质
                        );
                        if (候选物品.length === 0) return;

                        // 创建物品实例
                        const 选中物品配置 =
                            候选物品[
                                Math.round(
                                    Math.random() * (候选物品.length - 1)
                                )
                            ];
                        const 新物品 = new 选中物品配置.类({});

                        if (是否上锁) {
                            新物品.强化 = true;
                        }

                        // 尝试放置物品
                        if (!放置物品到房间(新物品, 房间)) {
                            console.log("物品放置失败，位置被占用");
                        }
                    }
                });
            }
            function 生成怪物() {
                const 当前层数权重 = Math.floor(当前层数 / 3); // 每3层上上强度
                const 可用房间 = 房间列表.filter(
                    (房间) => 房间.类型 == "房间" || 房间.类型 == "黑暗房间"
                );
                可用房间.forEach((房间) => {
                    if (房间.id === 0) return; //原来js不能用countinue (误)
                    const 是否上锁 = 上锁房间列表.some((r) => r.id === 房间.id);
                    const 房间类型 = 是否上锁 ? "上锁房间" : "普通房间";

                    const 候选怪物 = 怪物池[房间类型].filter(
                        (m) => 当前层数 >= m.最小层
                    );

                    if (候选怪物.length === 0) return;

                    const 最大生成数 = 是否上锁 ? 最大怪物数 + 2 : 最大怪物数;
                    let 生成数量 = Math.round(
                        Math.random() *
                            Math.random() *
                            Math.random() *
                            最大生成数 +
                            当前层数权重
                    );

                    if (房间.类型 === "黑暗房间")
                        生成数量 = Math.max(2, 生成数量);

                    for (let i = 0; i < 生成数量; i++) {
                        const 总权重 = 候选怪物.reduce(
                            (sum, m) => sum + m.权重,
                            0
                        );
                        let 随机值 = Math.random() * 总权重;
                        let 选中配置 = null;

                        for (const m of 候选怪物) {
                            if (随机值 <= m.权重) {
                                选中配置 = m;
                                break;
                            }
                            随机值 -= m.权重;
                        }

                        let 生成成功 = false;
                        for (let 尝试次数 = 0; 尝试次数 < 10; 尝试次数++) {
                            const x =
                                房间.x + Math.floor(Math.random() * 房间.w);
                            const y =
                                房间.y + Math.floor(Math.random() * 房间.h);

                            if (
                                地牢[y][x].背景类型 === 单元格类型.房间 &&
                                !地牢[y][x].关联怪物 &&
                                !地牢[y][x].关联物品
                            ) {
                                const 新怪物 = new 选中配置.类({
                                    x: x,
                                    y: y,
                                    房间ID: 房间.id,
                                    强化: 是否上锁,
                                    基础攻击力: 3 + 当前层数权重,
                                });
                                新怪物.基础生命值 += 当前层数权重 * 3;
                                新怪物.当前生命值 += 当前层数权重 * 3;
                                放置怪物到单元格(新怪物, x, y);
                                生成成功 = true;
                                break;
                            }
                        }
                    }
                });
            }

            function 加权随机选择(选项列表) {
                const 乱序列表 = [...选项列表].sort(() => Math.random() - 0.5);

                // 计算累计权重
                let 累计权重 = 0;
                const 累计列表 = 乱序列表.map((opt) => {
                    累计权重 += opt.权重;
                    return { ...opt, 累计权重 };
                });

                const 随机值 = Math.random() * 累计权重;

                // 进行一个二分
                let left = 0;
                let right = 累计列表.length - 1;

                while (left <= right) {
                    const mid = Math.floor((left + right) / 2);
                    if (随机值 <= 累计列表[mid].累计权重) {
                        if (mid === 0 || 随机值 > 累计列表[mid - 1].累计权重) {
                            return 累计列表[mid].值 || 累计列表[mid];
                        }
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                }

                return 累计列表[0]?.值 || 累计列表[0];
            }

            function 生成死亡粒子(容器) {
                const 粒子数量 = 30;
                const 颜色 = ["#ff0000", "#ff4444", "#ff8888"];

                for (let i = 0; i < 粒子数量; i++) {
                    const 粒子 = document.createElement("div");
                    粒子.className = "死亡粒子";
                    粒子.style.cssText = `
                                                                        position: absolute;
                                                                        width: ${
                                                                            Math.random() *
                                                                                4 +
                                                                            2
                                                                        }px;
                                                                        height: ${
                                                                            Math.random() *
                                                                                4 +
                                                                            2
                                                                        }px;
                                                                        background: ${
                                                                            颜色[
                                                                                Math.floor(
                                                                                    Math.random() *
                                                                                        颜色.length
                                                                                )
                                                                            ]
                                                                        };
                                                                        border-radius: 50%;
                                                                        left: ${
                                                                            Math.random() *
                                                                            100
                                                                        }%;
                                                                        top: ${
                                                                            Math.random() *
                                                                            100
                                                                        }%;
                                                                        animation: 粒子飘落 ${
                                                                            Math.random() *
                                                                                3 +
                                                                            2
                                                                        }s linear infinite;
                                                                        opacity: ${
                                                                            Math.random() *
                                                                                0.6 +
                                                                            0.4
                                                                        };
                                                                    `;
                    粒子.style.setProperty("--random", Math.random());
                    容器.appendChild(粒子);
                }
            }
            function 处理重生(保留物品) {
                if (当前天气效果.includes("诡魅")) {
                    处理诡魅房间刷新(
                        玩家.x,
                        玩家.y,
                        玩家初始位置.x,
                        玩家初始位置.y
                    );
                }
                const 生命条 = document.querySelector(".health-bar");
                生命条.style.width = "100%";
                document.querySelector(".power-bar").style.width = `100%`;

                玩家状态.forEach((m) => {
                    m.移除状态();
                });
                if (当前激活卷轴列表.size > 0) {
                    当前激活卷轴列表.forEach((卷轴) => {
                        当前激活卷轴列表.delete(卷轴);
                        卷轴.卸下();
                    });
                }
                玩家属性 = { ...初始玩家属性 };
                应用永久Buffs();
                玩家状态 = [];

                if (保留物品) {
                    if (当前层数 === 5) {
                        const 迷宫尺寸 = 85;
                        const 偏移X = Math.floor((地牢大小 - 迷宫尺寸) / 2);
                        const 偏移Y = Math.floor((地牢大小 - 迷宫尺寸) / 2);
                        let rx, ry;
                        do {
                            rx = 偏移X + Math.floor(Math.random() * 迷宫尺寸);
                            ry = 偏移Y + Math.floor(Math.random() * 迷宫尺寸);
                        } while (地牢[ry]?.[rx]?.背景类型 !== 单元格类型.走廊);
                        玩家.x = rx;
                        玩家.y = ry;
                    } else {
                        玩家.x = 玩家初始位置.x;
                        玩家.y = 玩家初始位置.y;
                    }

                    玩家背包.forEach((item) => {
                        if (
                            item.类型 === "武器" &&
                            item.自定义数据.get("冷却剩余") > 0
                        ) {
                            item.自定义数据.set("冷却剩余", 0);
                        }
                    });

                    更新装备显示();
                } else {
                    上次死亡地点 = null;
                    玩家背包.clear();
                    玩家装备.clear();
                    所有地牢层.clear();
                    已访问房间.clear();
                    玩家.x = 玩家初始位置.x;
                    玩家.y = 玩家初始位置.y;
                    地牢 = [];
                    房间列表 = [];
                    所有计时器 = [];
                    if (当前层数 !== null) {
                        切换楼层(0, true);
                    } else {
                        进入教程层();
                    }
                    更新背包显示();
                    更新装备显示();

                    更新界面状态();
                    更新物体指示器();
                }

                const 死亡遮罩 = document.getElementById("死亡遮罩");
                if (死亡遮罩) 死亡遮罩.remove();
                死亡界面已显示 = false;
                更新视口();
            }
            function 切换楼层(
                新层数,
                完全重生 = false,
                目标坐标 = null,
                通过楼梯切换 = false,
                onCompleteCallback = null
            ) {
                const 遮罩 = document.getElementById("transitionMask");
                const 标题 = document.getElementById("floorTitle");

                遮罩.style.opacity = 1;
                if (新层数 === 5 && 当前层数 !== 5) {
                    标题.textContent = `米诺陶的迷宫`;
                } else if (新层数 === 10 && 当前层数 !== 10) {
                    标题.textContent = `法师图书馆`;
                } else {
                    标题.textContent = `地牢 ${
                        新层数 < 0 ? 当前层数 - 1 : 新层数
                    }`;
                }

                setTimeout(() => {
                    标题.style.opacity = 1;
                    标题.style.transform = "scale(1)";
                }, 200);

                setTimeout(() => {
                    const 旧楼层数据 = 所有地牢层.get(当前层数);
                    const 当前数据 = {
                        地牢数组: 地牢,
                        房间列表: 房间列表,
                        门实例列表: 门实例列表,
                        玩家位置: { x: 玩家.x, y: 玩家.y },
                        上锁房间列表: 上锁房间列表,
                        已访问房间: 已访问房间,
                        房间地图: 房间地图,
                        所有怪物: 所有怪物,
                        玩家初始位置: { x: 玩家初始位置.x, y: 玩家初始位置.y },
                        所有计时器: 所有计时器,
                        当前天气效果: [...当前天气效果],
                        已放置配方卷轴: 已放置配方卷轴 || false,
                    };

                    所有怪物.forEach((m) => {
                        m.绘制血条(true);
                    });

                    if (当前层数 !== null && !完全重生) {
                        const 待保存楼层数据 = 所有地牢层.get(当前层数) || {};
                        待保存楼层数据.地牢数组 = 地牢;
                        待保存楼层数据.房间列表 = 房间列表;
                        待保存楼层数据.门实例列表 = 门实例列表;
                        if (通过楼梯切换) {
                            待保存楼层数据.玩家位置 = { x: 玩家.x, y: 玩家.y };
                        } else {
                            if (!待保存楼层数据.玩家位置) {
                                待保存楼层数据.玩家位置 = { x: 玩家初始位置.x, y: 玩家初始位置.y };
                            }
                        }
                        待保存楼层数据.上锁房间列表 = 上锁房间列表;
                        待保存楼层数据.已访问房间 = 已访问房间;
                        待保存楼层数据.房间地图 = 房间地图;
                        待保存楼层数据.所有怪物 = 所有怪物;
                        待保存楼层数据.玩家初始位置 = { x: 玩家初始位置.x, y: 玩家初始位置.y };
                        待保存楼层数据.所有计时器 = 所有计时器;
                        待保存楼层数据.当前天气效果 = [...当前天气效果];
                        待保存楼层数据.已放置配方卷轴 = 当前数据.已放置配方卷轴;
                        所有地牢层.set(当前层数, 待保存楼层数据);
                    }

                    当前层数 = 新层数;

                    if (当前层数 === 5) {
                        生成迷宫关卡();
                    } else if (当前层数 === 10) {
                        生成法师图书馆();
                    } else if (所有地牢层.has(新层数)) {
                        const 新地牢数据 = 所有地牢层.get(新层数);
                        地牢 = 新地牢数据.地牢数组;
                        房间列表 = 新地牢数据.房间列表;
                        门实例列表 = 新地牢数据.门实例列表;
                        上锁房间列表 = 新地牢数据.上锁房间列表;
                        已访问房间 = 新地牢数据.已访问房间;
                        房间地图 = 新地牢数据.房间地图;
                        所有怪物 = 新地牢数据.所有怪物;
                        所有计时器 = 新地牢数据.所有计时器;
                        玩家初始位置 = 新地牢数据.玩家初始位置;
                        当前天气效果 = 新地牢数据.当前天气效果 || [];
                        已放置配方卷轴 = 新地牢数据.已放置配方卷轴 || false;
                        if (目标坐标 && 位置是否可用(目标坐标.x, 目标坐标.y, false)) {
                            玩家.x = 目标坐标.x;
                            玩家.y = 目标坐标.y;
                        } else {
                            玩家.x = 新地牢数据.玩家位置.x;
                            玩家.y = 新地牢数据.玩家位置.y;
                        }
                    } else {
                        房间列表 = [];
                        上锁房间列表 = [];
                        所有怪物 = [];
                        所有计时器 = [];
                        已访问房间 = new Set();
                        房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
                        门实例列表 = new Map();
                        if (当前层数 !== null && 当前层数 % 3 === 0 && 当前层数 !== 0) {
                            生成天气效果();
                        } else {
                            当前天气效果 = [];
                        }
                        生成地牢();
                        生成并放置随机配方卷轴(当前层数);
                        玩家.x = 玩家初始位置.x;
                        玩家.y = 玩家初始位置.y;
                    }

                    更新视口();
                    绘制();
                    更新界面状态();
                    更新物体指示器();
                    所有怪物.forEach((m) => { m.绘制血条(true); });
                    移动玩家(0, 0);
                    if (typeof onCompleteCallback === 'function') {
                        onCompleteCallback(); 
                    }
                    

                    标题.style.opacity = 0;
                    标题.style.transform = "scale(0.5)";
                    遮罩.style.opacity = 0;
                }, 1200);

            }
            function 保存传送点() {
                if (传送点列表.length >= 最大传送点数量) {
                    显示通知(
                        `最多只能保存 ${最大传送点数量} 个传送点！`,
                        "错误"
                    );
                    return;
                }
                if (当前层数 === null) {
                    显示通知(`不能在当前楼层设置传送点！`, "错误");
                    return;
                }
                if (
                    当前天气效果.includes("诡魅") ||
                    当前天气效果.includes("深夜")
                ) {
                    显示通知(`奇怪的气氛阻止了传送点的保存...`, "错误");
                    return;
                }
                const 当前位置标识 = `${当前层数}-${玩家.x}-${玩家.y}`;
                // 检查是否已在完全相同的位置保存过
                if (
                    传送点列表.some(
                        (点) => `${点.层数}-${点.x}-${点.y}` === 当前位置标识
                    )
                ) {
                    显示通知("当前位置已存在传送点！", "警告");
                    return;
                }

                // 允许玩家输入名称，或者使用默认名称
                let 传送点名称 = prompt(
                    `为传送点命名（可选，当前：第 ${当前层数} 层 (${玩家.x}, ${玩家.y})）：`,
                    `第 ${当前层数} 层 (${玩家.x}, ${玩家.y})`
                );
                if (传送点名称 === null) return; // 用户取消
                if (传送点名称.trim() === "") {
                    传送点名称 = `第 ${当前层数} 层 (${玩家.x}, ${玩家.y})`; // 默认名称
                }

                const 新传送点 = {
                    id:
                        Date.now().toString() +
                        Math.random().toString(36).substring(2, 7), // 简单唯一ID
                    名称: 传送点名称,
                    层数: 当前层数,
                    x: 玩家.x,
                    y: 玩家.y,
                };

                传送点列表.push(新传送点);
                显示通知(`传送点 "${新传送点.名称}" 已保存！`, "成功");
            }
            function 打开传送菜单() {
                if (当前天气效果.includes("诡魅")) {
                    显示通知("诡异的气息干扰了空间传送！", "错误");
                    return;
                }
                if (生存挑战激活) {
                        显示通知("强大的结界阻止了空间传送！", "错误");
                        return false;
                }
                const 遮罩 = document.getElementById("传送点遮罩");
                const 菜单 = document.getElementById("传送点菜单");
                const 列表容器 = document.getElementById("传送点列表容器");

                列表容器.innerHTML = "";
                const 标题栏 = 菜单.querySelector(".重铸弹窗-header");
                // 检查按钮是否已存在，防止重复添加
                let 保存按钮 = 标题栏.querySelector("#保存当前传送点按钮"); // 先查找
                if (!保存按钮) {
                    // 不存在则创建
                    保存按钮 = document.createElement("button");
                    保存按钮.textContent = "保存"; // 使用图标
                    保存按钮.className = "菜单操作按钮 传送菜单按钮-保存"; // 使用新基础类和特定类
                    保存按钮.id = "保存当前传送点按钮";
                    保存按钮.onclick = (事件) => {
                        事件.stopPropagation();
                        保存传送点(); // 调用现有的保存函数
                        列表容器.innerHTML = ""; // 清空旧列表
                        刷新传送菜单();
                    };
                    const 关闭按钮实例 = 标题栏.querySelector(".关闭按钮");
                    if (关闭按钮实例) {
                        标题栏.insertBefore(保存按钮, 关闭按钮实例);
                    } else {
                        标题栏.appendChild(保存按钮);
                    }
                }
                刷新传送菜单();

                遮罩.style.display = "block";
                菜单.style.opacity = 0;
                菜单.style.transform = "translate(-50%, -50%) scale(0.9)";
                requestAnimationFrame(() => {
                    菜单.style.transition =
                        "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
                    菜单.style.opacity = 1;
                    菜单.style.transform = "translate(-50%, -50%) scale(1)";
                });
                玩家属性.允许移动 += 1;
            }
            function 刷新传送菜单() {
                const 遮罩 = document.getElementById("传送点遮罩");
                const 菜单 = document.getElementById("传送点菜单");
                const 列表容器 = document.getElementById("传送点列表容器");
                列表容器.innerHTML = "";
                if (传送点列表.length === 0) {
                    列表容器.innerHTML =
                        "<p style='text-align: center; color: #888;'>没有已保存的传送点。</p>";
                } else {
                    传送点列表.forEach((点) => {
                        const 条目元素 = document.createElement("div");
                        条目元素.className = "重铸物品"; // 复用样式
                        条目元素.style.display = "flex";
                        条目元素.style.justifyContent = "space-between";
                        条目元素.style.alignItems = "center";
                        条目元素.style.padding = "10px 15px";

                        const 名称元素 = document.createElement("span");
                        名称元素.textContent = `${点.名称}`;
                        名称元素.style.flexGrow = "1";
                        名称元素.style.marginRight = "10px";

                        const 操作容器 = document.createElement("div");
                        操作容器.style.display = "flex";
                        操作容器.style.gap = "8px"; // 稍微增大按钮间距

                        const 传送按钮 = document.createElement("button");
                        传送按钮.innerHTML = "传送"; // 使用图标
                        传送按钮.className = "菜单操作按钮 传送菜单按钮-传送";
                        传送按钮.onclick = (事件) => {
                            事件.stopPropagation();
                            执行传送(点.id);
                        };

                        const 删除按钮 = document.createElement("button");
                        删除按钮.innerHTML = "删除"; // 使用图标
                        删除按钮.className = "菜单操作按钮 传送菜单按钮-删除";
                        删除按钮.onclick = (事件) => {
                            事件.stopPropagation();
                            删除传送点(点.id);
                            列表容器.innerHTML = "";
                            刷新传送菜单();
                        };

                        操作容器.appendChild(传送按钮);
                        操作容器.appendChild(删除按钮);

                        条目元素.appendChild(名称元素);
                        条目元素.appendChild(操作容器);
                        列表容器.appendChild(条目元素);
                    });
                }
            }

            function 关闭传送菜单() {
                const 遮罩 = document.getElementById("传送点遮罩");
                const 菜单 = document.getElementById("传送点菜单");
                菜单.style.transition =
                    "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
                菜单.style.opacity = 0;
                菜单.style.transform = "translate(-50%, -50%) scale(0.9)";
                setTimeout(() => {
                    遮罩.style.display = "none";
                    玩家属性.允许移动 -= 1;
                }, 300); // 等待动画完成
            }

            function 执行传送(目标点标识) {
                if (当前天气效果.includes("诡魅")) {
                    显示通知("诡异的气息干扰了空间传送！", "错误");
                    关闭传送菜单();
                    return;
                }

                const 目标点 = 传送点列表.find((点) => 点.id === 目标点标识);
                if (!目标点) {
                    显示通知("传送目标点无效！", "错误");
                    return;
                }

                const 当前玩家房间ID = 房间地图[玩家.y][玩家.x];
                if (当前玩家房间ID !== -1) {
                    const 当前玩家所在房间 = 房间列表[当前玩家房间ID];
                    if (
                        当前玩家所在房间 &&
                        当前玩家所在房间.类型 === "挑战房间" &&
                        当前玩家所在房间.挑战状态 &&
                        当前玩家所在房间.挑战状态.进行中
                    ) {
                        处理挑战失败(当前玩家所在房间);
                    }
                }

                关闭传送菜单();

                setTimeout(() => {
                    if (目标点.层数 === 当前层数) {
                        const 目标单元格 = 地牢[目标点.y]?.[目标点.x];
                        if (
                            目标单元格 &&
                            ![单元格类型.墙壁, 单元格类型.上锁的门].includes(
                                目标单元格.背景类型
                            )
                        ) {
                            玩家.x = 目标点.x;
                            玩家.y = 目标点.y;
                            添加日志(`已传送到 ${目标点.名称}`, "信息");
                            更新视口();
                            绘制();
                            处理怪物回合();
                            更新物体指示器();
                        } else {
                            显示通知(
                                "目标位置无法传送！可能已被阻挡。",
                                "错误"
                            );
                        }
                    } else {
                        切换楼层(目标点.层数, false, {
                            x: 目标点.x,
                            y: 目标点.y,
                        });
                        添加日志(`已传送到 ${目标点.名称}`, "信息");
                    }
                }, 350);
            }
            function 删除传送点(目标点标识) {
                const 索引 = 传送点列表.findIndex((点) => 点.id === 目标点标识);
                if (索引 !== -1) {
                    const 删除的名称 = 传送点列表[索引].名称;
                    传送点列表.splice(索引, 1);
                    显示通知(`传送点 "${删除的名称}" 已删除。`, "成功");
                }
            }
            function 放置楼梯(房间, 图标, 类型) {
                const 楼梯 = {
                    类型: "楼梯",
                    图标: 图标,
                    显示图标: 图标,
                    颜色索引: 颜色表.length,
                    使用: () => {
                          let 目标层数 =
                            类型 === 单元格类型.楼梯下楼
                                ? 当前层数 + 1
                                : 当前层数 - 1;
                        if (当前层数===null) 目标层数 = 0;
                        切换楼层(目标层数, false, null, true);
                    },
                    唯一标识: Symbol(`楼梯_${类型}`),
                    获取名称: () =>
                        类型 === 单元格类型.楼梯下楼 ? "下楼楼梯" : "上楼楼梯",
                    自定义数据: new Map(),
                    品质: 1,
                    能否拾起: false,
                    是否正常物品: false,
                    是否隐藏: false,
                    是否为隐藏物品: false,
                    效果描述: null,
                    已装备: false,
                    装备槽位: null,
                    堆叠数量: 1,
                    最大堆叠数量: 1,
                    颜色表: 颜色表,
                };
                放置物品到房间(楼梯, 房间, 类型);
            }

            function 生成金币() {
                const 普通房间生成概率 = 0.3;
                const 上锁房间生成概率 = 0.7;
                const 可用房间 = 房间列表.filter((房间) => 房间.类型 == "房间");
                可用房间.forEach((房间) => {
                    let 生成概率 = 普通房间生成概率;
                    let 最大数量 = 9 + 当前层数;

                    // 上锁房间生成更多金币
                    if (上锁房间列表.some((r) => r.id === 房间.id)) {
                        生成概率 = 上锁房间生成概率;
                        最大数量 = 22 + 当前层数;
                    }

                    if (Math.random() < 生成概率) {
                        const 数量 = Math.min(
                            Math.floor(Math.random() * 最大数量) + 1,
                            最大堆叠数
                        );
                        const 金币实例 = new 金币({ 数量 });
                        放置物品到房间(金币实例, 房间);
                    }
                });
            }
            function 区域是否空闲(x, y, w, h) {
                for (let i = y; i < y + h; i++) {
                    for (let j = x; j < x + w; j++) {
                        if (
                            i >= 地牢大小 ||
                            j >= 地牢大小 ||
                            地牢[i][j].背景类型 !== 单元格类型.墙壁
                        ) {
                            return false;
                        }
                    }
                }

                // 计算缓冲区范围
                const 缓冲距离 = 2;
                const xStart = Math.max(0, x - 缓冲距离);
                const xEnd = Math.min(地牢大小 - 1, x + w - 1 + 缓冲距离);
                const yStart = Math.max(0, y - 缓冲距离);
                const yEnd = Math.min(地牢大小 - 1, y + h - 1 + 缓冲距离);

                for (let yi = yStart; yi <= yEnd; yi++) {
                    for (let xi = xStart; xi <= xEnd; xi++) {
                        // 计算到房间边缘的最小曼哈顿距离
                        let dx = 0,
                            dy = 0;
                        if (xi < x) dx = x - xi;
                        else if (xi >= x + w) dx = xi - (x + w - 1);

                        if (yi < y) dy = y - yi;
                        else if (yi >= y + h) dy = yi - (y + h - 1);

                        const 总距离 = dx + dy;

                        // 如果曼哈顿距离≤2且单元格非墙壁，则区域被占用
                        if (
                            总距离 <= 缓冲距离 &&
                            地牢[yi][xi].背景类型 !== 单元格类型.墙壁
                        ) {
                            return false;
                        }
                    }
                }

                return true;
            }

            function 放置房间(房间) {
                for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                    for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                        const 单元格 = 地牢[y][x];
                        单元格.背景类型 = 单元格类型.房间;
                        房间地图[y][x] = 房间.id;
                        单元格.墙壁 = {
                            上: y === 房间.y,
                            下: y === 房间.y + 房间.h - 1,
                            左: x === 房间.x,
                            右: x === 房间.x + 房间.w - 1,
                        };
                    }
                }
                房间.已解锁 = false;
                return true;
            }

            function 更新房间墙壁(房间) {
                房间.门.forEach((门) => {
                    const { x, y } = 门;
                    if (y + 1 < 地牢大小) 地牢[y + 1][x].墙壁.上 = false;
                    if (y - 1 >= 0) 地牢[y - 1][x].墙壁.下 = false;
                    if (x + 1 < 地牢大小) 地牢[y][x + 1].墙壁.左 = false;
                    if (x - 1 >= 0) 地牢[y][x - 1].墙壁.右 = false;
                });
            }

            function 处理上锁的门() {
                const 上锁起始索引 = Math.floor(房间列表.length * 0.5);
                const 候选房间 = 房间列表.filter(
                    (房间) =>
                        房间.门.length > 0 &&
                        房间.id >= 上锁起始索引 &&
                        房间.类型 == "房间" // 排除特殊房间
                );
                const 上锁数量 = Math.min(
                    候选房间.length,
                    Math.floor(Math.random() * 候选房间.length * 0.5) + 1
                ); // 上锁一部分

                for (let i = 0; i < 上锁数量; i++) {
                    if (候选房间.length === 0) break;

                    const 目标房间 = 候选房间.splice(
                        Math.floor(Math.random() * 候选房间.length),
                        1
                    )[0];

                    if (目标房间.id !== 0) {
                        // 不锁起始房间
                        const 颜色索引 = i % 颜色表.length;
                        // 遍历房间记录的主门位置
                        目标房间.门.forEach((主门位置) => {
                            const 主门单元格 = 地牢[主门位置.y]?.[主门位置.x];
                            if (主门单元格 && 主门单元格.标识) {
                                const 门标识 = 主门单元格.标识;
                                // 查找所有拥有相同门标识的单元格（包括主门和配对门）
                                for (let y = 0; y < 地牢大小; y++) {
                                    for (let x = 0; x < 地牢大小; x++) {
                                        const 单元格 = 地牢[y]?.[x];
                                        if (
                                            单元格 &&
                                            单元格.标识 === 门标识 &&
                                            单元格.背景类型 === 单元格类型.门
                                        ) {
                                            单元格.背景类型 =
                                                单元格类型.上锁的门;
                                            单元格.钥匙ID = 目标房间.id;
                                            单元格.颜色索引 = 颜色索引;
                                            // 更新门实例状态（虽然可能没直接用到，但保持一致）
                                            const 门实例 =
                                                门实例列表.get(门标识);
                                            if (门实例) {
                                                门实例.类型 = "上锁的门";
                                                门实例.是否上锁 = true; // 添加一个明确的锁状态
                                            }
                                        }
                                    }
                                }
                            }
                        });
                        // 记录上锁房间信息
                        上锁房间列表.push({ ...目标房间, 颜色索引 });
                    }
                }
                // 标记房间状态
                上锁房间列表.forEach((房间) => {
                    const 原始房间 = 房间列表.find((r) => r.id === 房间.id);
                    if (原始房间) 原始房间.已解锁 = false; // 标记未解锁
                });
            }

            function 生成钥匙() {
                // 计算房间 ID 的 50% 分位点
                const 钥匙放置截止索引 = Math.floor(房间列表.length * 0.5);

                上锁房间列表.forEach((上锁房间) => {
                    const 新钥匙 = new 钥匙({
                        对应门ID: 上锁房间.id,
                        颜色索引: 上锁房间.颜色索引,
                        地牢层数: 当前层数,
                    });

                    // 只在房间 ID 小于 80% 分位点的房间中生成钥匙
                    const 可用房间 = 房间列表.filter(
                        (r) =>
                            !上锁房间列表.some((锁房) => 锁房.id === r.id) &&
                            r.id < 钥匙放置截止索引 &&
                            r.类型 === "房间"
                    );

                    const 目标房间 =
                        可用房间.length > 0
                            ? 可用房间[
                                  Math.floor(Math.random() * 可用房间.length)
                              ]
                            : null; // 确保有可用房间

                    if (目标房间 && 放置物品到房间(新钥匙, 目标房间)) {
                        // 放置成功
                    }
                });
            }

            function 寻找房间入口(房间, 避开方向 = {}) {
                const { x, y, w, h } = 房间;
                const 候选入口 = [];

                if (!避开方向.上 && y > 0) {
                    for (let i = x + 1; i < x + w - 1; i++) {
                        if (地牢[y - 1][i].类型 === 单元格类型.墙壁) {
                            候选入口.push({ x: i, y: y - 1 });
                        }
                    }
                }
                if (!避开方向.下 && y + h < 地牢大小 - 1) {
                    for (let i = x + 1; i < x + w - 1; i++) {
                        if (地牢[y + h][i].类型 === 单元格类型.墙壁) {
                            候选入口.push({ x: i, y: y + h });
                        }
                    }
                }
                if (!避开方向.左 && x > 0) {
                    for (let i = y + 1; i < y + h - 1; i++) {
                        if (地牢[i][x - 1].类型 === 单元格类型.墙壁) {
                            候选入口.push({ x: x - 1, y: i });
                        }
                    }
                }
                if (!避开方向.右 && x + w < 地牢大小 - 1) {
                    for (let i = y + 1; i < y + h - 1; i++) {
                        if (地牢[i][x + w].类型 === 单元格类型.墙壁) {
                            候选入口.push({ x: x + w, y: i });
                        }
                    }
                }
                return 候选入口; // 直接返回数组
            }

            function 连接房间(房间A, 房间B, 尝试 = 0) {
                if (!房间A || !房间B) return;
                if (尝试 >= 6) {
                    房间A =
                        房间列表[
                            Math.floor(Math.random() * (房间列表.length - 2))
                        ];
                }
                if (尝试 >= 12) return;
                const 相对位置 = {
                    左: 房间A.x < 房间B.x,
                    右: 房间A.x > 房间B.x,
                    上: 房间A.y < 房间B.y,
                    下: 房间A.y > 房间B.y,
                };

                const 避开方向 = {
                    起始: {
                        左: 相对位置.左,
                        右: 相对位置.右,
                        上: 相对位置.上,
                        下: 相对位置.下,
                    },
                    结束: {
                        左: 相对位置.右,
                        右: 相对位置.左,
                        上: 相对位置.下,
                        下: 相对位置.上,
                    },
                };

                const 起始候选 = 寻找房间入口(房间A, 避开方向.起始);
                const 结束候选 = 寻找房间入口(房间B, 避开方向.结束);

                if (!起始候选 || !结束候选) return;

                let 起始 = null;
                let 结束 = null;
                let 最小距离 = Infinity;

                for (const 房间起始 of 起始候选) {
                    for (const 房间结束 of 结束候选) {
                        const 距离 =
                            Math.abs(房间起始.x - 房间结束.x) +
                            Math.abs(房间起始.y - 房间结束.y);
                        if (距离 < 最小距离) {
                            最小距离 = 距离;
                            起始 = 房间起始;
                            结束 = 房间结束;
                        }
                    }
                }

                if (!起始 || !结束) {
                    return;
                }

                let 当前 = { x: 起始.x, y: 起始.y };
                let 路径 = [当前];
                let 门 = [];
                let 在房间内 = false;
                let 进入的房间 = null;

                门.push({ x: 起始.x, y: 起始.y, 进入的房间: 房间A });

                const x轴优先 =
                    Math.abs(结束.x - 起始.x) > Math.abs(结束.y - 起始.y);

                let 上一个节点 = 当前;
                while (当前.x !== 结束.x || 当前.y !== 结束.y) {
                    const dx = 结束.x - 当前.x;
                    const dy = 结束.y - 当前.y;

                    if (x轴优先 && dx !== 0) {
                        当前.x += dx > 0 ? 1 : -1;
                    } else if (dy !== 0) {
                        当前.y += dy > 0 ? 1 : -1;
                    } else if (!x轴优先 && dx !== 0) {
                        当前.x += dx > 0 ? 1 : -1;
                    }

                    let 附近的门数量 = [
                        { x: 当前.x, y: 当前.y - 1 },
                        { x: 当前.x, y: 当前.y + 1 },
                        { x: 当前.x - 1, y: 当前.y },
                        { x: 当前.x + 1, y: 当前.y },
                    ].reduce((数量, pos) => {
                        if (
                            pos.x >= 0 &&
                            pos.x < 地牢大小 &&
                            pos.y >= 0 &&
                            pos.y < 地牢大小
                        ) {
                            return (
                                数量 +
                                (地牢[pos.y][pos.x].背景类型 === 单元格类型.门)
                            );
                        }
                        return 数量;
                    }, 0);

                    const 碰撞房间 = 房间列表.find(
                        (房间) =>
                            当前.x >= 房间.x &&
                            当前.x <= 房间.x + 房间.w - 1 &&
                            当前.y >= 房间.y &&
                            当前.y <= 房间.y + 房间.h - 1 &&
                            房间 !== 房间A
                    );
                    if (碰撞房间 && !在房间内) {
                        在房间内 = true;
                        进入的房间 = 碰撞房间;
                        门.push({
                            x: 上一个节点.x,
                            y: 上一个节点.y,
                            进入的房间: 进入的房间,
                        });
                        附近的门数量 -= 1;
                    } else if (!碰撞房间 && 在房间内) {
                        if (当前.x !== 结束.x && 当前.y !== 结束.y) {
                            门.push({
                                x: 当前.x,
                                y: 当前.y,
                                进入的房间: 进入的房间,
                            });
                            路径.push({ x: 当前.x, y: 当前.y });
                            在房间内 = false;
                        }
                        附近的门数量 -= 1;
                    }
                    if (
                        地牢[当前.y][当前.x].背景类型 === 单元格类型.门 ||
                        附近的门数量 > 1
                    ) {
                        let 路径 = [];
                        let 门 = [];
                        return 连接房间(房间A, 房间B, 尝试 + 1);
                    }
                    if (
                        路径.length === 0 &&
                        地牢[当前.y][当前.x].类型 === 单元格类型.走廊
                    ) {
                        let 路径 = [];
                        let 门 = [];
                        return 连接房间(房间A, 房间B, 尝试 + 1);
                    }
                    if (!在房间内) {
                        路径.push({ x: 当前.x, y: 当前.y });
                    }
                    上一个节点 = { x: 当前.x, y: 当前.y };
                }

                if (!在房间内) {
                    门.push({ x: 结束.x, y: 结束.y, 进入的房间: 房间B });
                    路径.push(结束);
                }
                门.forEach((door) => {
                    放置门(door.x, door.y, door.进入的房间);
                });
                return 路径;
            }

            function 生成走廊(路径) {
                for (let i = 0; i < 路径.length; i++) {
                    const { x, y } = 路径[i];

                    // 确定偏移方向（尝试保持一致性，例如优先向右/向下偏移）
                    let adjX = x,
                        adjY = y;
                    if (i < 路径.length - 1) {
                        // 根据下一个点确定方向
                        const nextX = 路径[i + 1].x;
                        const nextY = 路径[i + 1].y;
                        if (nextX === x) {
                            // 垂直移动
                            adjX = x + 1; // 尝试向右偏移
                        } else {
                            // 水平移动
                            adjY = y + 1; // 尝试向下偏移
                        }
                    } else if (i > 0) {
                        // 根据上一个点确定方向（路径末端）
                        const prevX = 路径[i - 1].x;
                        const prevY = 路径[i - 1].y;
                        if (prevX === x) {
                            // 垂直移动
                            adjX = x + 1;
                        } else {
                            // 水平移动
                            adjY = y + 1;
                        }
                    }

                    // 放置主路径单元格
                    if (
                        地牢[y]?.[x] &&
                        地牢[y][x].背景类型 === 单元格类型.墙壁
                    ) {
                        地牢[y][x].背景类型 = 单元格类型.走廊;
                        地牢[y][x].墙壁 = {
                            上: false,
                            右: false,
                            下: false,
                            左: false,
                        }; // 清除墙壁
                        地牢[y][x].配对单元格位置 = { x: adjX, y: adjY }; // 记录伙伴位置
                    }

                    // 放置相邻单元格
                    if (
                        adjX >= 0 &&
                        adjX < 地牢大小 &&
                        adjY >= 0 &&
                        adjY < 地牢大小 &&
                        地牢[adjY]?.[adjX]
                    ) {
                        if (地牢[adjY][adjX].背景类型 === 单元格类型.墙壁) {
                            地牢[adjY][adjX].背景类型 = 单元格类型.走廊;
                            地牢[adjY][adjX].墙壁 = {
                                上: false,
                                右: false,
                                下: false,
                                左: false,
                            }; // 清除墙壁
                            地牢[adjY][adjX].配对单元格位置 = { x: x, y: y }; // 记录伙伴位置
                        }
                    }
                }
                // 单独处理墙壁清除，确保相邻的走廊单元格之间没有墙
                路径.forEach(({ x, y }) => {
                    if (
                        !地牢[y]?.[x] ||
                        地牢[y][x].背景类型 !== 单元格类型.走廊
                    )
                        return;

                    const adjPos = 地牢[y][x].配对单元格位置;
                    if (
                        adjPos &&
                        地牢[adjPos.y]?.[adjPos.x]?.背景类型 === 单元格类型.走廊
                    ) {
                        // 根据相对位置清除墙壁
                        if (adjPos.x > x) {
                            // 相邻在右侧
                            地牢[y][x].墙壁.右 = false;
                            地牢[adjPos.y][adjPos.x].墙壁.左 = false;
                        } else if (adjPos.x < x) {
                            // 相邻在左侧
                            地牢[y][x].墙壁.左 = false;
                            地牢[adjPos.y][adjPos.x].墙壁.右 = false;
                        } else if (adjPos.y > y) {
                            // 相邻在下方
                            地牢[y][x].墙壁.下 = false;
                            地牢[adjPos.y][adjPos.x].墙壁.上 = false;
                        } else if (adjPos.y < y) {
                            // 相邻在上方
                            地牢[y][x].墙壁.上 = false;
                            地牢[adjPos.y][adjPos.x].墙壁.下 = false;
                        }
                    }
                    // 清除与路径中上一个点的墙壁
                    const prevIndex =
                        路径.findIndex((p) => p.x === x && p.y === y) - 1;
                    if (prevIndex >= 0) {
                        const prev = 路径[prevIndex];
                        if (
                            地牢[prev.y]?.[prev.x]?.背景类型 === 单元格类型.走廊
                        ) {
                            if (prev.x === x) {
                                // 垂直连接
                                if (prev.y < y) {
                                    地牢[y][x].墙壁.上 = false;
                                    地牢[prev.y][prev.x].墙壁.下 = false;
                                } else {
                                    地牢[y][x].墙壁.下 = false;
                                    地牢[prev.y][prev.x].墙壁.上 = false;
                                }
                            } else {
                                // 水平连接
                                if (prev.x < x) {
                                    地牢[y][x].墙壁.左 = false;
                                    地牢[prev.y][prev.x].墙壁.右 = false;
                                } else {
                                    地牢[y][x].墙壁.右 = false;
                                    地牢[prev.y][prev.x].墙壁.左 = false;
                                }
                            }
                            // 同时清除配对单元格与上一个配对单元格的墙
                            const prevAdjPos =
                                地牢[prev.y]?.[prev.x]?.配对单元格位置;
                            const currentAdjPos = 地牢[y]?.[x]?.配对单元格位置;
                            if (
                                prevAdjPos &&
                                currentAdjPos &&
                                地牢[prevAdjPos.y]?.[prevAdjPos.x]?.背景类型 ===
                                    单元格类型.走廊 &&
                                地牢[currentAdjPos.y]?.[currentAdjPos.x]
                                    ?.背景类型 === 单元格类型.走廊
                            ) {
                                if (prevAdjPos.x === currentAdjPos.x) {
                                    // 垂直连接
                                    if (prevAdjPos.y < currentAdjPos.y) {
                                        地牢[currentAdjPos.y][
                                            currentAdjPos.x
                                        ].墙壁.上 = false;
                                        地牢[prevAdjPos.y][
                                            prevAdjPos.x
                                        ].墙壁.下 = false;
                                    } else {
                                        地牢[currentAdjPos.y][
                                            currentAdjPos.x
                                        ].墙壁.下 = false;
                                        地牢[prevAdjPos.y][
                                            prevAdjPos.x
                                        ].墙壁.上 = false;
                                    }
                                } else {
                                    // 水平连接
                                    if (prevAdjPos.x < currentAdjPos.x) {
                                        地牢[currentAdjPos.y][
                                            currentAdjPos.x
                                        ].墙壁.左 = false;
                                        地牢[prevAdjPos.y][
                                            prevAdjPos.x
                                        ].墙壁.右 = false;
                                    } else {
                                        地牢[currentAdjPos.y][
                                            currentAdjPos.x
                                        ].墙壁.右 = false;
                                        地牢[prevAdjPos.y][
                                            prevAdjPos.x
                                        ].墙壁.左 = false;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            function 是否在任意房间内(x, y) {
                return 房间列表.some(
                    (房间) =>
                        x >= 房间.x &&
                        x < 房间.x + 房间.w &&
                        y >= 房间.y &&
                        y < 房间.h
                ); //可改为直接判断单元格类型
            }

            function 放置门(x, y, 目标房间) {
                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return;

                // --- 确定门的方向和相邻位置 ---
                let adjX = -1,
                    adjY = -1;
                let isVerticalDoor = false; // 门是垂直放置（左右打开）还是水平放置（上下打开）

                // 检查左右是否是房间或走廊
                const leftCell = 地牢[y]?.[x - 1];
                const rightCell = 地牢[y]?.[x + 1];
                if (
                    (leftCell && leftCell.背景类型 !== 单元格类型.墙壁) ||
                    (rightCell && rightCell.背景类型 !== 单元格类型.墙壁)
                ) {
                    const upCell = 地牢[y - 1]?.[x];
                    const downCell = 地牢[y + 1]?.[x];
                    if (
                        (upCell && upCell.背景类型 !== 单元格类型.墙壁) ||
                        (downCell && downCell.背景类型 !== 单元格类型.墙壁)
                    ) {
                        adjX = -1;
                        adjY = -1;
                    } else {
                        isVerticalDoor = true;
                        adjY = y + 1; // 尝试在下方放置配对门
                        adjX = x;
                    }
                } else {
                    // 检查上下是否是房间或走廊
                    const upCell = 地牢[y - 1]?.[x];
                    const downCell = 地牢[y + 1]?.[x];
                    if (
                        (upCell && upCell.背景类型 !== 单元格类型.墙壁) ||
                        (downCell && downCell.背景类型 !== 单元格类型.墙壁)
                    ) {
                        isVerticalDoor = false; // 水平放置
                        adjX = x + 1; // 尝试在右方放置配对门
                        adjY = y;
                    } else {
                        adjX = -1;
                        adjY = -1;
                    }
                }

                // --- 创建逻辑门实例 ---
                const 新门 = new 门({
                    关联房间ID: 目标房间.id,
                    位置: { x, y }, // 主单元格位置
                });
                let mainDoorOrientation = null;
                if (isVerticalDoor) {
                    mainDoorOrientation = "EW";
                } else {
                    mainDoorOrientation = "NS";
                }

                // --- 放置第一个门单元格 ---
                if (地牢[y]?.[x]) {
                    地牢[y][x].标识 = 新门.唯一标识;
                    地牢[y][x].关联物品 = null;
                    地牢[y][x].背景类型 = 单元格类型.门;
                    地牢[y][x].墙壁 = {
                        上: false,
                        右: false,
                        下: false,
                        左: false,
                    }; // 清除所有墙
                    // 清除周围单元格对着门方向的墙壁
                    if (地牢[y]?.[x + 1]) 地牢[y][x + 1].墙壁.左 = false;
                    if (地牢[y]?.[x - 1]) 地牢[y][x - 1].墙壁.右 = false;
                    if (地牢[y + 1]?.[x]) 地牢[y + 1][x].墙壁.上 = false;
                    if (地牢[y - 1]?.[x]) 地牢[y - 1][x].墙壁.下 = false;
                    地牢[y][x].配对单元格位置 = { x: adjX, y: adjY };
                    地牢[y][x].isOneWay = false; // Initialize
                    地牢[y][x].oneWayAllowedDirection = null; // Initialize
                    地牢[y][x].doorOrientation = mainDoorOrientation;
                    地牢[y][x].主 = true;
                } else {
                    console.error(`尝试在无效位置 (${x}, ${y}) 放置门`);
                    return;
                }

                // --- 放置第二个（配对）门单元格 ---
                let 配对门放置成功 = false;
                if (
                    adjX >= 0 &&
                    adjX < 地牢大小 &&
                    adjY >= 0 &&
                    adjY < 地牢大小 &&
                    地牢[adjY]?.[adjX]
                ) {
                    const 配对门 = new 门({
                        关联房间ID: 目标房间.id,
                        位置: { x: adjX, y: adjY },
                    });
                    // 检查配对位置是否为墙壁，避免覆盖房间或走廊
                    if (地牢[adjY][adjX].背景类型 === 单元格类型.墙壁) {
                        地牢[adjY][adjX].标识 = 配对门.唯一标识;
                        地牢[adjY][adjX].关联物品 = null;
                        地牢[adjY][adjX].背景类型 = 单元格类型.门;
                        地牢[adjY][adjX].墙壁 = {
                            上: false,
                            右: false,
                            下: false,
                            左: false,
                        }; // 清除所有墙
                        地牢[adjY][adjX].配对单元格位置 = { x: x, y: y }; // 指回主单元格
                        地牢[adjY][adjX].isOneWay = false; // Initialize
                        地牢[adjY][adjX].oneWayAllowedDirection = null; // Initialize
                        地牢[adjY][adjX].doorOrientation = mainDoorOrientation;
                        配对门放置成功 = true;

                        // 清除周围单元格对着配对门方向的墙壁
                        if (地牢[adjY]?.[adjX + 1])
                            地牢[adjY][adjX + 1].墙壁.左 = false;
                        if (地牢[adjY]?.[adjX - 1])
                            地牢[adjY][adjX - 1].墙壁.右 = false;
                        if (地牢[adjY + 1]?.[adjX])
                            地牢[adjY + 1][adjX].墙壁.上 = false;
                        if (地牢[adjY - 1]?.[adjX])
                            地牢[adjY - 1][adjX].墙壁.下 = false;
                    } else {
                        // 如果配对位置不是墙，主门仍然放置，但没有配对门
                        地牢[y][x].配对单元格位置 = null; // 主门没有配对
                        console.warn(
                            `门的配对位置 (${adjX}, ${adjY}) 不是墙壁，只放置了单个门在 (${x}, ${y})`
                        );
                    }
                } else {
                    // 如果配对位置无效，主门仍然放置，但没有配对门
                    地牢[y][x].配对单元格位置 = null;
                    console.warn(
                        `门的配对位置 (${adjX}, ${adjY}) 超出边界，只放置了单个门在 (${x}, ${y})`
                    );
                }

                // --- 清除两个门单元格之间的墙壁 ---
                if (配对门放置成功) {
                    if (isVerticalDoor) {
                        // 垂直放置的门，清除上下墙
                        地牢[y][x].墙壁.下 = false;
                        地牢[adjY][adjX].墙壁.上 = false;
                    } else {
                        // 水平放置的门，清除左右墙
                        地牢[y][x].墙壁.右 = false;
                        地牢[adjY][adjX].墙壁.左 = false;
                    }
                }

                if (
                    目标房间 &&
                    !目标房间.门.some((d) => d.x === x && d.y === y)
                ) {
                    目标房间.门.push({ x, y });
                    if (配对门放置成功) 目标房间.门.push({ x: adjX, y: adjY });
                }
            }
            function randomlySetOneWayDirection(doorCell) {
                if (!doorCell || !doorCell.doorOrientation) {
                    console.error(
                        "Cannot set one-way direction: doorCell or its orientation is invalid.",
                        doorCell
                    );
                    return null; // Or a default
                }
                if (doorCell.doorOrientation === "NS") {
                    return Math.random() < 0.5 ? "N" : "S"; // Allow passage North or South
                } else if (doorCell.doorOrientation === "EW") {
                    return Math.random() < 0.5 ? "E" : "W"; // Allow passage East or West
                }
                return null; // Should not happen
            }

            function getMoveDirection(fromX, fromY, toX, toY) {
                if (toX > fromX) return "E";
                if (toX < fromX) return "W";
                if (toY > fromY) return "S";
                if (toY < fromY) return "N";
                return null;
            }
            function 放置物品到房间(
                物品实例,
                目标房间,
                放置物体 = 单元格类型.物品,
                禁用光晕 = false,
                特效 = false
            ) {
                // 寻找有效放置位置
                let 放置成功 = false;
                for (let 尝试次数 = 0; 尝试次数 < 20; 尝试次数++) {
                    // 计算房间有效区域
                    const 最小x = 目标房间.x;
                    const 最大x = 目标房间.x + 目标房间.w - 1;
                    const 最小y = 目标房间.y;
                    const 最大y = 目标房间.y + 目标房间.h - 1;

                    // 生成随机坐标
                    const x =
                        最小x + Math.floor(Math.random() * (最大x - 最小x + 1));
                    const y =
                        最小y + Math.floor(Math.random() * (最大y - 最小y + 1));

                    // 验证位置有效性
                    if (位置是否可用(x, y)) {
                        地牢[y][x].类型 = 放置物体;
                        地牢[y][x].关联物品 = 物品实例;
                        if (物品实例.颜色索引 === null || 禁用光晕) {
                            物品实例.颜色索引 = 物品实例.颜色表.length;
                        }
                        物品实例.x = x;
                        物品实例.y = y;
                        地牢[y][x].颜色索引 = 物品实例.颜色索引;
                        放置成功 = true;
                        if (特效)
                            计划显示格子特效(
                                [{ x: x, y: y }],
                                物品实例.颜色表[物品实例.颜色索引].slice(1)
                            );
                        break;
                    }
                }
                return 放置成功;
            }
            function 放置物品到单元格(
                物品实例,
                x,
                y,
                放置物体 = 单元格类型.物品,
                禁用光晕 = false
            ) {
                // 验证位置有效性
                if (位置是否可用(x, y, false)) {
                    地牢[y][x].类型 = 放置物体;
                    地牢[y][x].关联物品 = 物品实例;
                    if (物品实例.颜色索引 === null || 禁用光晕) {
                        物品实例.颜色索引 = 物品实例.颜色表.length;
                    }
                    物品实例.x = x;
                    物品实例.y = y;
                    地牢[y][x].颜色索引 = 物品实例.颜色索引;
                    绘制();
                    return true;
                }
                return false;
            }

            function 位置是否可用(x, y, 考虑玩家 = true) {
                // 边界检查
                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
                    return false;
                if (考虑玩家 && 玩家.x === x && 玩家.y === y) return false;
                const 单元格 = 地牢[y][x];

                // 必须是房间地板且没有其他物品
                return (
                    [单元格类型.房间, 单元格类型.走廊, 单元格类型.门].includes(
                        单元格.背景类型
                    ) &&
                    !单元格.关联物品 &&
                    !单元格.关联怪物
                );
            }

            //修改时记得同步修改使用背包物品
            function 尝试互动() {
                let 互动 = false;
                if (互动冷却) return;
                互动冷却 = true;
                setTimeout(() => (互动冷却 = false), 500);

                // 优先处理玩家所在格子的互动
                const 玩家所在单元格 = 地牢[玩家.y][玩家.x];
                //注意修改时要同时修改两个地方
                if (玩家所在单元格.关联物品) {
                    if (玩家所在单元格.关联物品?.类型 === "棋子") {
                        //这里的奇怪逻辑是历史问题...
                        玩家所在单元格.关联物品.能否拾起 = true;
                        if (尝试收集物品(玩家所在单元格.关联物品)) {
                            玩家所在单元格.类型 = null;
                            玩家所在单元格.关联物品 = null;
                            绘制();
                            互动 = true;
                        }
                    } else if (尝试收集物品(玩家所在单元格.关联物品)) {
                        玩家所在单元格.类型 = null;
                        玩家所在单元格.关联物品 = null;
                        绘制();
                        互动 = true;
                    } else if (
                        玩家所在单元格.关联物品?.类型 === "NPC" &&
                        !NPC互动中
                    ) {
                        玩家所在单元格.关联物品.使用();
                        NPC互动中 = true;
                        互动 = true;
                    }
                    if (玩家所在单元格.关联物品?.尝试互动?.()) {
                        互动 = true;
                    }
                }
                if (互动) return;

                const 方向 = [
                    { dx: 0, dy: -1 }, // 上
                    { dx: 1, dy: 0 }, // 右
                    { dx: 0, dy: 1 }, // 下
                    { dx: -1, dy: 0 }, // 左
                ];

                for (const { dx, dy } of 方向) {
                    const 目标X = 玩家.x + dx;
                    const 目标Y = 玩家.y + dy;

                    if (
                        目标X < 0 ||
                        目标X >= 地牢大小 ||
                        目标Y < 0 ||
                        目标Y >= 地牢大小
                    )
                        continue;

                    const 单元格 = 地牢[目标Y][目标X];
                    if (
                        单元格.关联物品 instanceof 祭坛类 &&
                        单元格.关联物品.自定义数据.get("激活条件") ===
                            "力量考验"
                    ) {
                        const 武器 = Array.from(
                            { length: 装备栏每页装备数 },
                            (_, i) =>
                                玩家装备.get(
                                    当前装备页 * 装备栏每页装备数 + i + 1
                                )
                        )
                            .filter((v) => v != null)
                            .find(
                                (i) =>
                                    i?.类型 === "武器" &&
                                    i?.堆叠数量 > 0 &&
                                    i?.自定义数据.get("冷却剩余") == 0
                            );
                        if (武器) {
                            单元格.关联物品.当被攻击(武器.攻击力, 玩家);
                            武器.自定义数据.set(
                                "耐久",
                                武器.自定义数据.get("耐久") - 武器.耐久消耗
                            );
                            if (武器.自定义数据.get("耐久") <= 0) {
                                处理销毁物品(武器.唯一标识, true);
                            }
                            武器.自定义数据.set("冷却剩余", 武器.最终冷却回合);
                            更新装备显示();
                            互动 = true;
                            break;
                        }
                    }
                    if (单元格.关联物品?.尝试互动?.()) {
                        互动 = true;
                        break;
                    }
                    // 处理上锁的门
                    if (单元格.背景类型 === 单元格类型.上锁的门) {
                        const 对应门 = 门实例列表.get(单元格.标识);
                        const 对应钥匙 = [...玩家背包.values()].find((item) =>
                            item.可交互目标(对应门)
                        );
                        if (对应钥匙) {
                            房间列表.find(
                                (房间) => 房间.id === 对应门.房间ID
                            )?.门?.forEach((item) => {
                                房间门 = 门实例列表.get(
                                    地牢[item.y][item.x].标识
                                );
                                互动 = 房间门.尝试解锁(玩家背包);
                                if (互动)
                                    地牢[房间门.所在位置.y][
                                        房间门.所在位置.x
                                    ].背景类型 = 单元格类型.门;
                            });
                            绘制();
                        }
                        if (互动) {
                            处理销毁物品(对应钥匙.唯一标识, true);
                            显示通知("解锁成功！", "成功");
                            break; // 互动成功，跳出循环
                        }
                    } else if (快速直线检查(玩家.x, 玩家.y, 目标X, 目标Y, 1)) {
                        //注意，此处未与本格互动成功才检测周围
                        if (单元格.关联物品) {
                            if (单元格.关联物品?.类型 === "棋子") {
                                单元格.关联物品.能否拾起 = true;
                                单元格.关联物品.isActive = false;
                                if (尝试收集物品(单元格.关联物品)) {
                                    单元格.类型 = null;
                                    单元格.关联物品 = null;
                                    绘制();
                                    互动 = true;
                                }
                            } else if (尝试收集物品(单元格.关联物品)) {
                                单元格.类型 = null;
                                单元格.关联物品 = null;
                                绘制();
                                互动 = true;
                            } else if (
                                单元格.关联物品?.类型 === "NPC" &&
                                !NPC互动中
                            ) {
                                单元格.关联物品.使用();
                                NPC互动中 = true;
                                互动 = true;
                                break;
                            }
                        }
                    }
                }
                if (互动) return;
                const 武器 = Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                    玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                )
                    .filter((v) => v != null)
                    .filter(
                        (i) =>
                            i?.类型 === "武器" &&
                            i?.堆叠数量 > 0 &&
                            i?.自定义数据.get("冷却剩余") == 0 && 
                            i?.自定义数据.get("攻击目标数") > 0 && 
                            !(i instanceof 充能魔杖)
                    );
                if (武器) {
                    let maxCount = 0;
                    let maxRange = 0; // 修改点：变量名保持，但逻辑会用最终范围
                    let 目标怪物,
                        目标路径 = [];
                    let 目标路径有效 = []; // 新增：用于存储真正有效的路径
                    武器.forEach((可用武器) => {
                        maxCount = Math.max(
                            maxCount,
                            可用武器.自定义数据.get("攻击目标数")
                        );
                        if (!(可用武器 instanceof 金币手枪))
                            maxRange = Math.max(
                                maxRange,
                                可用武器.最终攻击范围
                            ); // 修改点：使用最终攻击范围
                    });
                    let { 怪物, 路径 } = 获取周围怪物(maxCount, maxRange);
                    if (怪物 && 路径) {
                        武器.forEach((可用武器) => {
                            路径 = 路径.filter(
                                (item, index) => 怪物[index].当前生命值 > 0
                            );
                            怪物 = 怪物.filter((item) => item.当前生命值 > 0);
                            目标路径有效 = []; // 重置/初始化
                            目标怪物 = []; // 重置/初始化

                            路径.forEach((item, index) => {
                                // 修改点：检查路径长度时使用武器的最终攻击范围
                                if (item.length <= 可用武器.最终攻击范围 + 1) {
                                    目标路径有效.push(item);
                                    目标怪物.push(怪物[index]); // 确保怪物和路径对应
                                }
                            });
                            // 后续使用 目标路径有效 和 目标怪物
                            if (目标怪物.length > 0) {
                                // 修改为检查目标怪物
                                if (可用武器.使用(目标怪物, 目标路径有效)) {
                                    // 传递有效的目标和路径
                                    Array.from(
                                        { length: 装备栏每页装备数 },
                                        (_, i) =>
                                            玩家装备.get(
                                                当前装备页 * 装备栏每页装备数 +
                                                    i +
                                                    1
                                            )
                                    )
                                        .filter((v) => v != null)
                                        .forEach((装备) => {
                                            if (
                                                装备 instanceof 宠物 &&
                                                !装备.自定义数据.get("休眠中")
                                            ) {
                                                装备.当玩家攻击(目标怪物); // 传递有效的目标
                                            }
                                        });
                                    更新装备显示();
                                    绘制();
                                    互动 = true;
                                }
                            }
                        });
                    }
                }

                if (!互动) 显示通知("周围没有可互动物体了...", "信息");
                return;
            }

            function 克隆物品(原始物品) {
                if (!原始物品 || typeof 原始物品 !== "object") {
                    return 原始物品;
                }

                const 克隆实例 = Object.create(Object.getPrototypeOf(原始物品));

                for (const 键 in 原始物品) {
                    if (Object.hasOwnProperty.call(原始物品, 键)) {
                        if (
                            键 === "自定义数据" &&
                            原始物品.自定义数据 instanceof Map
                        ) {
                            克隆实例.自定义数据 = new Map(原始物品.自定义数据);
                        } else {
                            克隆实例[键] = 原始物品[键];
                        }
                    }
                }

                克隆实例.isActive = false;
                克隆实例.显示元素 = null;
                克隆实例.已装备 = false;
                克隆实例.装备槽位 = null;
                克隆实例.唯一标识 = Symbol(
                    Date.now().toString() + Math.random().toString()
                );
                return 克隆实例;
            }
            function 获取周围怪物(数量 = 1, 范围 = null) {
                if (当前天气效果.includes("诡魅") && 范围 > 2) {
                    // 假设范围>1表示远程
                    范围 = 2;
                }
                let 攻击范围 = 0;
                if (范围 === null) {
                    const 当前武器 = Array.from(
                        { length: 装备栏每页装备数 },
                        (_, i) =>
                            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                    )
                        .filter((v) => v != null)
                        .find(
                            (i) =>
                                i.类型 === "武器" &&
                                i.堆叠数量 > 0 &&
                                i.自定义数据.get("冷却剩余") === 0
                        );
                    if (!当前武器) return { 路径: null, 怪物: null };
                    攻击范围 = 当前武器.最终攻击范围;
                } else {
                    攻击范围 = 范围;
                }
                const 候选怪物 = [];
                for (let dx = -攻击范围; dx <= 攻击范围; dx++) {
                    for (let dy = -攻击范围; dy <= 攻击范围; dy++) {
                        const x = 玩家.x + dx;
                        const y = 玩家.y + dy;
                        if (
                            x >= 0 &&
                            x < 地牢大小 &&
                            y >= 0 &&
                            y < 地牢大小 &&
                            地牢[y][x].关联怪物?.状态 === 怪物状态.活跃 &&
                            怪物状态表.get(地牢[y][x].关联怪物)?.类型 !== "魅惑"
                        ) {
                            const 怪物实例 = 地牢[y][x].关联怪物;
                            if (检查视线(玩家.x, 玩家.y, x, y, 攻击范围)) {
                                候选怪物.push({
                                    怪物: 怪物实例,
                                    距离: Math.abs(dx) + Math.abs(dy),
                                    x: x,
                                    y: y,
                                });
                            }
                        }
                    }
                }
                const 排序后 = 候选怪物.sort((a, b) => a.距离 - b.距离);
                const 结果 = 排序后.slice(0, 数量);
                const 路径数组 = [];
                const 怪物数组 = [];
                for (const item of 结果) {
                    let 路径 = [];
                    if (
                        快速直线检查(玩家.x, 玩家.y, item.x, item.y, 攻击范围)
                    ) {
                        路径 = 获取直线路径(玩家.x, 玩家.y, item.x, item.y);
                    } else {
                        路径 = 广度优先搜索路径(
                            玩家.x,
                            玩家.y,
                            item.x,
                            item.y,
                            攻击范围,
                            true
                        );
                    }
                    if (路径) {
                        路径.shift();
                        路径数组.push(路径);
                        怪物数组.push(item.怪物);
                    }
                }
                return 路径数组.length > 0
                    ? { 路径: 路径数组, 怪物: 怪物数组 }
                    : { 路径: null, 怪物: null };
            }
            function 获取直线路径(startX, startY, endX, endY) {
                const path = [];
                let currentX = startX;
                let currentY = startY;
                const dx = endX - startX;
                const dy = endY - startY;
                const steps = Math.max(Math.abs(dx), Math.abs(dy));
                const xInc = dx / steps;
                const yInc = dy / steps;
                for (let i = 0; i <= steps; i++) {
                    const x = Math.round(currentX);
                    const y = Math.round(currentY);
                    path.push({ x: x, y: y });
                    currentX += xInc;
                    currentY += yInc;
                }
                return path;
            }
            // BFS U ARE MY GOD
            function 广度优先搜索路径(
                startX,
                startY,
                endX,
                endY,
                maxSteps,
                返回路径 = false
            ) {
                const 最小步数记录 = new Array(地牢大小)
                    .fill()
                    .map(() => new Array(地牢大小).fill(Infinity));
                const 前驱节点 = new Array(地牢大小)
                    .fill(null)
                    .map(() => new Array(地牢大小).fill(null));
                const 队列 = [[startX, startY, 0]];
                最小步数记录[startY][startX] = 0;
                const 方向 = [
                    { dx: 0, dy: -1, 当前墙: "上", 反方向墙: "下" },
                    { dx: 0, dy: 1, 当前墙: "下", 反方向墙: "上" },
                    { dx: -1, dy: 0, 当前墙: "左", 反方向墙: "右" },
                    { dx: 1, dy: 0, 当前墙: "右", 反方向墙: "左" },
                ];
                while (队列.length > 0) {
                    const [x, y, step] = 队列.shift();
                    if (x === endX && y === endY) {
                        if (返回路径) {
                            return 从终点回溯路径(前驱节点, endX, endY);
                        }
                        return true;
                    }
                    if (step >= maxSteps) continue;
                    for (const dir of 方向) {
                        const 新X = x + dir.dx;
                        const 新Y = y + dir.dy;
                        const 新步数 = step + 1;
                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            continue;
                        if (新步数 >= 最小步数记录[新Y][新X]) continue;
                        const 当前单元格 = 地牢[y][x];
                        const 下一单元格 = 地牢[新Y][新X];
                        if (
                            当前单元格.墙壁[dir.当前墙] ||
                            下一单元格.墙壁[dir.反方向墙]
                        )
                            continue;

                        const 移动方向 = getMoveDirection(x, y, 新X, 新Y);
                        if (
                            下一单元格.isOneWay &&
                            移动方向 !== 下一单元格.oneWayAllowedDirection
                        ) {
                            continue;
                        }

                        if (
                            [单元格类型.墙壁, 单元格类型.上锁的门].includes(
                                下一单元格.背景类型
                            )
                        )
                            continue;
                        最小步数记录[新Y][新X] = 新步数;
                        前驱节点[新Y][新X] = { x: x, y: y };
                        队列.push([新X, 新Y, 新步数]);
                    }
                }
                return 返回路径 ? [] : false;
            }
            function 从终点回溯路径(前驱节点, endX, endY) {
                const 路径 = [];
                let currentX = endX;
                let currentY = endY;
                while (前驱节点[currentY][currentX] !== null) {
                    路径.push({ x: currentX, y: currentY });
                    const tempX = 前驱节点[currentY][currentX].x;
                    const tempY = 前驱节点[currentY][currentX].y;
                    currentX = tempX;
                    currentY = tempY;
                }
                路径.push({ x: currentX, y: currentY });
                return 路径.reverse();
            }
            function 检查视线(startX, startY, endX, endY, maxSteps = Infinity) {
                const 曼哈顿距离 =
                    Math.abs(endX - startX) + Math.abs(endY - startY);
                if (曼哈顿距离 > maxSteps) return false;
                if (startX === endX && startY === endY) return true;
                if (快速直线检查(startX, startY, endX, endY, maxSteps)) {
                    return true;
                }
                return 广度优先搜索路径(startX, startY, endX, endY, maxSteps);
            }
            function 快速直线检查(startX, startY, endX, endY, maxSteps,玩家穿了潜行靴) {
                const 曼哈顿距离 =
                    Math.abs(endX - startX) + Math.abs(endY - startY);
                if (曼哈顿距离 > maxSteps) return false;
                if (startX === endX && startY === endY) return true;

                const path = 获取直线格子(startX, startY, endX, endY);
                if (path.length -1 > maxSteps) return false;

                
                for(let i=1; i < path.length; i++) {
                    const prev = path[i-1];
                    const curr = path[i];

                    if (curr.x < 0 || curr.x >= 地牢大小 || curr.y < 0 || curr.y >= 地牢大小) return false;
                    
                    const 单元格 = 地牢[curr.y][curr.x];

                    if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型)) return false;

                    if (玩家穿了潜行靴 && 单元格.关联物品) return false;

                    const 移动方向 = getMoveDirection(prev.x, prev.y, curr.x, curr.y);
                    if (单元格.isOneWay && 移动方向 !== 单元格.oneWayAllowedDirection) return false;

                    const dirs = [];
                    if (curr.x > prev.x) dirs.push("右");
                    else if (curr.x < prev.x) dirs.push("左");
                    
                    if (curr.y > prev.y) dirs.push("下");
                    else if (curr.y < prev.y) dirs.push("上");

                    for (const dir of dirs) {
                        const mapping = {
                            右: { 当前墙: "左", 反方向墙: "右" },
                            左: { 当前墙: "右", 反方向墙: "左" },
                            下: { 当前墙: "上", 反方向墙: "下" },
                            上: { 当前墙: "下", 反方向墙: "上" },
                        }[dir];
                        if (mapping && (地牢[curr.y][curr.x].墙壁[mapping.当前墙] || 地牢[prev.y][prev.x].墙壁[mapping.反方向墙])) {
                            return false;
                        }
                    }
                }
                return true;
            }
            function 获取移动方向(fromX, fromY, toX, toY) {
                const dx = toX - fromX;
                const dy = toY - fromY;
                const 主要方向 =
                    Math.abs(dx) > Math.abs(dy)
                        ? dx > 0
                            ? "右"
                            : "左"
                        : dy > 0
                        ? "下"
                        : "上";
                return {
                    右: { 当前墙: "右", 反方向墙: "左" },
                    左: { 当前墙: "左", 反方向墙: "右" },
                    下: { 当前墙: "下", 反方向墙: "上" },
                    上: { 当前墙: "上", 反方向墙: "下" },
                }[主要方向];
            }

            function 计划显示格子特效(路径数组, 颜色 = "FF0000", 间隔 = 100) {
                // 增加颜色参数，默认为红色
                if (长按移动) {
                    //return;
                }
                const 可见路径 = 路径数组.filter((节点) => {
                    return (
                        节点.x >= 视口偏移X &&
                        节点.x < 视口偏移X + 相机显示边长 &&
                        节点.y >= 视口偏移Y &&
                        节点.y < 视口偏移Y + 相机显示边长
                    );
                });
                if (可见路径.length > 0) {
                    相机锁定 = true;
                    待显示格子特效队列.push({
                        路径: 可见路径,
                        颜色: 颜色,
                        间隔: 间隔,
                    });
                }
            }
            function 显示格子特效(路径, 颜色 = "FF0000", 间隔 = 100) {
                const 画布Rect = canvas.getBoundingClientRect();

                路径.forEach((节点, index) => {
                    const 屏幕X = (节点.x - 当前相机X) * 单元格大小;
                    const 屏幕Y = (节点.y - 当前相机Y) * 单元格大小;

                    const 特效 = document.createElement("div");
                    特效.className = "攻击路径特效";

                    特效.style.cssText = `
            position: absolute;
            left: ${屏幕X + 画布Rect.left}px;
            top: ${屏幕Y + 画布Rect.top}px;
            width: ${单元格大小}px;
            height: ${单元格大小}px;
            background: radial-gradient(circle,
                ${hexToRgba(颜色, 0)} 0%,
                ${hexToRgba(颜色, 0.3)} 70%,
                transparent 100%
            );
            opacity: 0.7;
            pointer-events: none;
            z-index: 998;
            transition: left 0.05s linear, top 0.05s linear;
        `;

                    const worldX = 节点.x;
                    const worldY = 节点.y;
                    const effectData = {
                        element: 特效,
                        worldX: worldX,
                        worldY: worldY,
                    };

                    document.body.appendChild(特效);
                    活动DOM特效.push(effectData);

                    const removalDelay = 200 + index * 间隔;
                    setTimeout(function () {
                        特效.remove();

                        活动DOM特效 = 活动DOM特效.filter(
                            (item) => item.element !== 特效
                        );
                    }, removalDelay);
                });
            }
            function 尝试进入特殊房间(x, y) {
                const 房间ID = 房间地图[y][x];
                if (房间ID === -1) return;
                const 房间 = 房间列表[房间ID];
                if (
                    房间 &&
                    !房间.已连接 &&
                    房间?.类型?.slice(0, 2) === "隐藏"
                ) {
                    连接特殊房间(房间);
                    生成墙壁();
                    const 待销毁戒指 = [];
                    玩家背包.forEach((item) => {
                        if (
                            item instanceof 寻宝戒指 &&
                            item.自定义数据.get("生效层数") === 当前层数
                        ) {
                            待销毁戒指.push(item.唯一标识);
                        }
                    });
                    待销毁戒指.forEach((id) => {
                        处理销毁物品(id, true);
                    });
                    移动玩家(0, 0);
                    绘制();
                }
            }
            function 尝试执行吹动(实例, 移动计划, 已执行, 风向DX, 风向DY) {
                if (已执行.has(实例)) return true;
                if (!移动计划.has(实例)) return true;

                const { 新X, 新Y, 旧X, 旧Y, 类型 } = 移动计划.get(实例);

                if (
                    新X < 0 ||
                    新X >= 地牢大小 ||
                    新Y < 0 ||
                    新Y >= 地牢大小 ||
                    !检查直线移动可行性(旧X, 旧Y, 新X, 新Y, true) ||
                    [单元格类型.墙壁, 单元格类型.上锁的门].includes(
                        地牢[新Y][新X]?.背景类型
                    )
                ) {
                    已执行.add(实例);
                    return false;
                }

                const 占用单元格 = 地牢[新Y]?.[新X];
                const 占用者 = 占用单元格?.关联物品 || 占用单元格?.关联怪物;

                if (占用者) {
                    const 不可移动类型列表 = ["楼梯", "地形", "祭坛", "折跃门"];
                    const 物品是否不可移动 =
                        占用者 instanceof 物品 &&
                        不可移动类型列表.includes(占用者.类型);

                    if (物品是否不可移动) {
                        已执行.add(实例);
                        if (占用者 instanceof 火焰物品) {
                            if (地牢[旧Y]?.[旧X]?.关联物品 === 实例) {
                                地牢[旧Y][旧X].关联物品 = null;
                                if (地牢[旧Y]?.[旧X]?.类型 === 单元格类型.物品)
                                    地牢[旧Y][旧X].类型 = null;
                                地牢[旧Y][旧X].颜色索引 = 颜色表.length;
                            }
                            添加日志(
                                `${实例.名称} 被吹向火焰，烧毁了！`,
                                "信息"
                            );
                            return true;
                        }
                        return false;
                    }
                    if (移动计划.has(占用者)) {
                        const 占用者移动成功 = 尝试执行吹动(
                            占用者,
                            移动计划,
                            已执行,
                            风向DX,
                            风向DY
                        );
                        if (!占用者移动成功) {
                            已执行.add(实例);
                            return false;
                        }
                    } else {
                        已执行.add(实例);
                        return false;
                    }
                }

                try {
                    if (类型 === "物品") {
                        if (地牢[旧Y]?.[旧X]?.关联物品 === 实例) {
                            地牢[旧Y][旧X].关联物品 = null;
                            if (地牢[旧Y]?.[旧X]?.类型 === 单元格类型.物品)
                                地牢[旧Y][旧X].类型 = null;
                            地牢[旧Y][旧X].颜色索引 = 颜色表.length;
                        }

                        实例.x = 新X;
                        实例.y = 新Y;

                        地牢[新Y][新X].类型 = 单元格类型.物品;
                        地牢[新Y][新X].关联物品 = 实例;
                        地牢[新Y][新X].颜色索引 = 实例.颜色索引;

                        添加日志(
                            `${实例.名称} 被大风吹到了 (${新X},${新Y})！`,
                            "信息"
                        );
                    } else if (类型 === "怪物") {
                        const 旧X = 实例.x;
                        const 旧Y = 实例.y;
                        实例.恢复背景类型();
                        实例.x = 新X;
                        实例.y = 新Y;
                        实例.保存新位置类型(新X, 新Y);
                        地牢[新Y][新X].类型 = 单元格类型.怪物;
                        地牢[新Y][新X].关联怪物 = 实例;
                        添加日志(
                            `${实例.类型} 被大风吹到了 (${新X},${新Y})！`,
                            "信息"
                        );
                        实例.处理地形效果();
                        怪物动画状态.set(实例, {
                            旧逻辑X: 旧X,
                            旧逻辑Y: 旧Y,
                            目标逻辑X: this.x,
                            目标逻辑Y: this.y,
                            视觉X: 旧X,
                            视觉Y: 旧Y,
                            动画开始时间: Date.now(),
                            正在动画: true,
                        });
                    }
                    已执行.add(实例);
                    return true;
                } catch (错误) {
                    console.error(
                        `执行移动实例 ${
                            实例?.名称 || "未知"
                        } 到 (${新X}, ${新Y}) 时出错: `,
                        错误
                    );
                    已执行.add(实例);
                    return false;
                }
            }

            function 处理大风效果() {
                const 方向列表 = [
                    { dx: 0, dy: -1 },
                    { dx: 1, dy: 0 },
                    { dx: 0, dy: 1 },
                    { dx: -1, dy: 0 },
                ];
                const { dx: 风向DX, dy: 风向DY } =
                    方向列表[Math.floor(Math.random() * 4)];

                const 画布 = document.getElementById("dungeonCanvas");
                const 画布Rect = 画布.getBoundingClientRect();
                const 视口起始X = Math.floor(当前相机X);
                const 视口起始Y = Math.floor(当前相机Y);
                const 视口宽度格 = Math.ceil(画布Rect.width / 单元格大小);
                const 视口高度格 = Math.ceil(画布Rect.height / 单元格大小);
                const 视口结束X = Math.min(
                    地牢大小 - 1,
                    视口起始X + 视口宽度格
                );
                const 视口结束Y = Math.min(
                    地牢大小 - 1,
                    视口起始Y + 视口高度格
                );

                const 移动计划 = new Map();
                const 不可移动类型列表 = ["楼梯", "地形", "祭坛", "折跃门"];

                for (let y = 视口起始Y; y <= 视口结束Y; y++) {
                    for (let x = 视口起始X; x <= 视口结束X; x++) {
                        const 物品 = 地牢[y]?.[x]?.关联物品;
                        if (
                            物品 &&
                            !不可移动类型列表.includes(物品.类型) &&
                            (已访问房间.has(房间地图[y][x]) ||
                                房间地图[y][x] === -1)
                        ) {
                            if (Math.random() < 大风吹动概率) {
                                const 新X = x + 风向DX;
                                const 新Y = y + 风向DY;

                                if (
                                    新X >= 0 &&
                                    新X < 地牢大小 &&
                                    新Y >= 0 &&
                                    新Y < 地牢大小 &&
                                    ![
                                        单元格类型.墙壁,
                                        单元格类型.上锁的门,
                                    ].includes(地牢[新Y][新X]?.背景类型) &&
                                    检查直线移动可行性(x, y, 新X, 新Y, true) &&
                                    (已访问房间.has(房间地图[y][x]) ||
                                        房间地图[y][x] === -1)
                                ) {
                                    移动计划.set(物品, {
                                        新X,
                                        新Y,
                                        旧X: x,
                                        旧Y: y,
                                        类型: "物品",
                                    });
                                }
                            }
                        }
                    }
                }

                所有怪物.forEach((怪物) => {
                    const { x, y } = 怪物;
                    if (
                        怪物.状态 === 怪物状态.活跃 &&
                        x >= 视口起始X &&
                        x <= 视口结束X &&
                        y >= 视口起始Y &&
                        y <= 视口结束Y
                    ) {
                        if (Math.random() < 大风吹动概率) {
                            const 新X = x + 风向DX;
                            const 新Y = y + 风向DY;

                            if (
                                新X >= 0 &&
                                新X < 地牢大小 &&
                                新Y >= 0 &&
                                新Y < 地牢大小 &&
                                ![
                                    单元格类型.墙壁,
                                    单元格类型.上锁的门,
                                ].includes(地牢[新Y][新X]?.背景类型) &&
                                检查直线移动可行性(x, y, 新X, 新Y, true)
                            ) {
                                移动计划.set(怪物, {
                                    新X,
                                    新Y,
                                    旧X: x,
                                    旧Y: y,
                                    类型: "怪物",
                                });
                            }
                        }
                    }
                });

                if (
                    玩家.x >= 视口起始X &&
                    玩家.x <= 视口结束X &&
                    玩家.y >= 视口起始Y &&
                    玩家.y <= 视口结束Y
                ) {
                    if (Math.random() < 大风吹动概率) {
                        const 新X = 玩家.x + 风向DX;
                        const 新Y = 玩家.y + 风向DY;

                        if (
                            新X >= 0 &&
                            新X < 地牢大小 &&
                            新Y >= 0 &&
                            新Y < 地牢大小 &&
                            ![单元格类型.墙壁, 单元格类型.上锁的门].includes(
                                地牢[新Y][新X]?.背景类型
                            ) &&
                            检查直线移动可行性(玩家.x, 玩家.y, 新X, 新Y, true)
                        ) {
                            移动计划.set(玩家, {
                                新X,
                                新Y,
                                旧X: 玩家.x,
                                旧Y: 玩家.y,
                                类型: "玩家",
                            });
                        }
                    }
                }

                const 已执行 = new Set();
                const 待处理实例列表 = Array.from(移动计划.keys());

                待处理实例列表
                    .filter((实例) => 实例 instanceof 物品)
                    .forEach((物品实例) => {
                        尝试执行吹动(
                            物品实例,
                            移动计划,
                            已执行,
                            风向DX,
                            风向DY
                        );
                    });

                待处理实例列表
                    .filter((实例) => 实例 instanceof 怪物)
                    .forEach((怪物实例) => {
                        尝试执行吹动(
                            怪物实例,
                            移动计划,
                            已执行,
                            风向DX,
                            风向DY
                        );
                    });

                let 玩家被吹动 = false;
                let 玩家目标X = 玩家.x;
                let 玩家目标Y = 玩家.y;

                if (移动计划.has(玩家) && !已执行.has(玩家)) {
                    const { 新X, 新Y } = 移动计划.get(玩家);

                    const 最终目标单元格 = 地牢[新Y]?.[新X];
                    const 最终占用者 = 最终目标单元格?.关联物品;
                    const 最终占用者不可移动 =
                        最终占用者 &&
                        (不可移动类型列表.includes(最终占用者.类型) ||
                            最终占用者.能否拾起 === false);

                    if (!最终占用者不可移动) {
                        玩家.x = 新X;
                        玩家.y = 新Y;
                        玩家被吹动 = true;
                        玩家目标X = 新X;
                        玩家目标Y = 新Y;
                        添加日志("你被大风吹动了！", "警告");
                        已执行.add(玩家);
                    } else {
                        添加日志("你试图被风吹动，但撞到了障碍物！", "信息");
                    }
                }

                if (玩家被吹动) {
                    const 目标单元格 = 地牢[玩家目标Y]?.[玩家目标X];
                    if (目标单元格) {
                        if (
                            目标单元格.关联物品 &&
                            目标单元格.类型 === 单元格类型.物品 &&
                            目标单元格.关联物品.能否拾起 !== false
                        ) {
                            if (尝试收集物品(目标单元格.关联物品)) {
                                目标单元格.类型 = null;
                                目标单元格.关联物品 = null;
                            }
                        } else if (
                            [单元格类型.楼梯下楼, 单元格类型.楼梯上楼].includes(
                                目标单元格.类型
                            )
                        ) {
                            if (目标单元格.关联物品?.使用) {
                                目标单元格.关联物品.使用();
                                return;
                            }
                        } else if (目标单元格.关联物品 instanceof 折跃门) {
                            目标单元格.关联物品.使用();
                            return;
                        }

                        const 目标房间ID = 房间地图[玩家目标Y][玩家目标X];
                        if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
                            moveQueue = [];
                            isAutoMoving = false;
                            已访问房间.add(目标房间ID);
                        }
                    }
                }

                更新物体指示器();
                所有怪物.forEach((m) => m.绘制血条());
            }
            function 开始挑战(房间实例) {
                if (
                    !房间实例 ||
                    房间实例.类型 !== "挑战房间" ||
                    !房间实例.挑战状态 ||
                    房间实例.挑战状态.进行中 ||
                    房间实例.挑战状态.已完成
                ) {
                    return;
                }

                显示通知(
                    `挑战开始于房间 ${房间实例.id}！门已封锁！`,
                    "警告",
                    true,
                    3000
                );

                房间实例.挑战状态.进行中 = true;
                房间实例.挑战状态.当前波次 = 0;
                房间实例.挑战状态.波次内怪物 = [];
                房间实例.挑战状态.原始门数据 = [];

                // 封锁门
                房间实例.门.forEach((门坐标) => {
                    const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
                    if (
                        门单元格 &&
                        (门单元格.背景类型 === 单元格类型.门 ||
                            门单元格.背景类型 === 单元格类型.上锁的门)
                    ) {
                        房间实例.挑战状态.原始门数据.push({
                            x: 门坐标.x,
                            y: 门坐标.y,
                            原类型: 门单元格.背景类型,
                            原标识: 门单元格.标识, // 保存门实例的标识
                            原颜色索引: 门单元格.颜色索引,
                            原钥匙ID: 门单元格.钥匙ID,
                        });
                        门单元格.背景类型 = 单元格类型.墙壁;
                        门单元格.标识 = null; // 清除门标识，使其不再是功能性门
                        门单元格.颜色索引 = 颜色表.length; // 恢复默认墙壁颜色
                        门单元格.钥匙ID = null;
                    }
                    // 同时处理配对门单元格（如果存在）
                    if (门单元格 && 门单元格.配对单元格位置) {
                        const 配对X = 门单元格.配对单元格位置.x;
                        const 配对Y = 门单元格.配对单元格位置.y;
                        const 配对单元格 = 地牢[配对Y]?.[配对X];
                        if (
                            配对单元格 &&
                            (配对单元格.背景类型 === 单元格类型.门 ||
                                配对单元格.背景类型 === 单元格类型.上锁的门)
                        ) {
                            房间实例.挑战状态.原始门数据.push({
                                x: 配对X,
                                y: 配对Y,
                                原类型: 配对单元格.背景类型,
                                原标识: 配对单元格.标识,
                                原颜色索引: 配对单元格.颜色索引,
                                原钥匙ID: 配对单元格.钥匙ID,
                            });
                            配对单元格.背景类型 = 单元格类型.墙壁;
                            配对单元格.标识 = null;
                            配对单元格.颜色索引 = 颜色表.length;
                            配对单元格.钥匙ID = null;
                        }
                    }
                });

                生成墙壁(); // 更新墙壁连接信息，确保封锁效果
                绘制(); // 立即重绘以显示锁住的门

                刷新挑战房间下一波(房间实例);
            }

            function 刷新挑战房间下一波(房间实例) {
                if (!房间实例.挑战状态.进行中) return;

                房间实例.挑战状态.当前波次++;
                if (房间实例.挑战状态.当前波次 > 房间实例.挑战状态.总波次) {
                    完成挑战(房间实例);
                    return;
                }

                显示通知(
                    `房间 ${房间实例.id}：第 ${房间实例.挑战状态.当前波次} 波！`,
                    "警告",
                    true,
                    2000
                );

                房间实例.挑战状态.波次当前回合数 =
                    房间实例.挑战状态.波次最大回合数; // 重置计时器

                const 怪物数量 =
                    1 +
                    Math.floor(当前层数 / 3) +
                    Math.floor(房间实例.挑战状态.当前波次 / 2);
                生成挑战房间怪物(房间实例, 怪物数量);
                绘制(); // 确保新生成的怪物显示
            }

            function 生成挑战房间怪物(房间实例, 数量) {
                let 候选怪物Pool = 怪物池["上锁房间"];
                const 候选怪物 = 候选怪物Pool.filter(
                    (m) => 当前层数 >= m.最小层
                );

                if (候选怪物.length === 0) {
                    console.warn(
                        `挑战房间 ${房间实例.id} 在层数 ${当前层数} 无法找到合适的怪物生成。`
                    );
                    return;
                }

                for (let i = 0; i < 数量; i++) {
                    const 总权重 = 候选怪物.reduce((sum, m) => sum + m.权重, 0);
                    let 随机值 = Math.random() * 总权重;
                    let 选中配置 = 候选怪物[0]; // 默认选第一个，防止意外
                    for (const m of 候选怪物) {
                        if (随机值 <= m.权重) {
                            选中配置 = m;
                            break;
                        }
                        随机值 -= m.权重;
                    }

                    let 放置成功 = false;
                    for (let 尝试次数 = 0; 尝试次数 < 20; 尝试次数++) {
                        // 增加尝试次数
                        const x =
                            房间实例.x + Math.floor(Math.random() * 房间实例.w);
                        const y =
                            房间实例.y + Math.floor(Math.random() * 房间实例.h);

                        if (位置是否可用(x, y, true)) {
                            const 强化概率 =
                                0.15 +
                                当前层数 * 0.025 +
                                房间实例.挑战状态.当前波次 * 0.06;
                            const 怪物基础攻击 =
                                (选中配置.类.prototype.基础攻击力 || 3) +
                                Math.floor(当前层数 / 4) +
                                Math.floor(房间实例.挑战状态.当前波次 / 2);
                            const 怪物基础生命 =
                                (选中配置.类.prototype.基础生命值 || 20) +
                                当前层数 * 2 +
                                房间实例.挑战状态.当前波次 * 4;

                            const 新怪物 = new 选中配置.类({
                                x: x,
                                y: y,
                                房间ID: 房间实例.id,
                                强化: Math.random() < 强化概率,
                                状态: 怪物状态.活跃,
                                基础攻击力: 怪物基础攻击,
                                基础生命值: 怪物基础生命, // 确保传递给构造函数
                            });
                            // 再次确保生命值设置正确
                            新怪物.基础生命值 = 怪物基础生命;
                            新怪物.当前生命值 = 新怪物.基础生命值;

                            放置怪物到单元格(新怪物, x, y);
                            房间实例.挑战状态.波次内怪物.push(新怪物);
                            新怪物.绘制血条(); // 确保新怪物血条显示
                            放置成功 = true;
                            break;
                        }
                    }
                }
            }

            function 完成挑战(房间实例) {
                显示通知(
                    `房间 ${房间实例.id} 挑战成功！门已开启。`,
                    "成功",
                    true,
                    3000
                );

                房间实例.挑战状态.进行中 = false;
                房间实例.挑战状态.已完成 = true;

                // 恢复门
                房间实例.挑战状态.原始门数据.forEach((门数据) => {
                    const 门单元格 = 地牢[门数据.y]?.[门数据.x];
                    if (门单元格) {
                        门单元格.背景类型 = 门数据.原类型;
                        门单元格.标识 = 门数据.原标识; // 恢复门实例的标识
                        门单元格.颜色索引 = 门数据.原颜色索引;
                        门单元格.钥匙ID = 门数据.原钥匙ID;
                        // 如果原先是上锁的门，并且门实例列表中有记录，则恢复门实例状态
                        if (
                            门数据.原类型 === 单元格类型.上锁的门 &&
                            门数据.原标识
                        ) {
                            const 门实例 = 门实例列表.get(门数据.原标识);
                            if (门实例) {
                                门实例.类型 = "上锁的门";
                                门实例.是否上锁 = true;
                            }
                        } else if (
                            门数据.原类型 === 单元格类型.门 &&
                            门数据.原标识
                        ) {
                            const 门实例 = 门实例列表.get(门数据.原标识);
                            if (门实例) {
                                门实例.类型 = "门";
                                门实例.是否上锁 = false;
                            }
                        }
                    }
                });

                生成墙壁(); // 重新生成墙壁以正确显示恢复的门
                生成奖励(房间实例); // 在房间内生成奖励物品
                绘制();
            }
            function 处理挑战失败(房间实例) {
                if (
                    !房间实例 ||
                    房间实例.类型 !== "挑战房间" ||
                    !房间实例.挑战状态 ||
                    !房间实例.挑战状态.进行中
                ) {
                    return;
                }
                显示通知(
                    `由于你的离开，房间 ${房间实例.id} 的挑战失败了！`,
                    "错误",
                    true,
                    3000
                );
                房间实例.挑战状态.进行中 = false;
                房间实例.挑战状态.已完成 = true;

                房间实例.挑战状态.原始门数据.forEach((门数据) => {
                    const 门单元格 = 地牢[门数据.y]?.[门数据.x];
                    if (门单元格) {
                        门单元格.背景类型 = 门数据.原类型;
                        门单元格.标识 = 门数据.原标识;
                        门单元格.颜色索引 = 门数据.原颜色索引;
                        门单元格.钥匙ID = 门数据.原钥匙ID;
                        if (
                            门数据.原类型 === 单元格类型.上锁的门 &&
                            门数据.原标识
                        ) {
                            const 门实例 = 门实例列表.get(门数据.原标识);
                            if (门实例) {
                                门实例.类型 = "上锁的门";
                                门实例.是否上锁 = true;
                            }
                        } else if (
                            门数据.原类型 === 单元格类型.门 &&
                            门数据.原标识
                        ) {
                            const 门实例 = 门实例列表.get(门数据.原标识);
                            if (门实例) {
                                门实例.类型 = "门";
                                门实例.是否上锁 = false;
                            }
                        }
                    }
                });
                生成墙壁();
                绘制();
            }
            function 获取方向中文(dx, dy) {
                if (dx === 1) return "东";
                if (dx === -1) return "西";
                if (dy === 1) return "南";
                if (dy === -1) return "北";
                return "原地";
            }
            function 处理回合逻辑() {
                if (玩家属性.允许移动 > 0) return;
                if (地牢.length !== 100) return;
                更新武器冷却();
                处理怪物回合();
                所有怪物.forEach((m) => {
                    m.绘制血条();
                });
                处理天气效果();
                更新物体指示器();
                if (当前层数 === 5) {
                    const 怪物数量下限 = 10;
                    if (所有怪物.length < 怪物数量下限) {
                        const 需生成数量 = 怪物数量下限 - 所有怪物.length;
                        生成迷宫怪物(需生成数量);
                    }
                }
                const 能量条 = document.querySelector(".power-bar");
                const 当前能量 = parseFloat(能量条?.style.width) || 100;
                if (当前能量 < 70 && 能量条) {
                    能量条.style.width = `${Math.min(
                        70,
                        当前能量 + Math.round(Math.random() * 5) / 5
                    )}%`;
                }
                玩家状态.forEach((item) => {
                    item.更新状态();
                });
                所有计时器.forEach((item) => {
                    item.更新倒计时();
                });
                房间列表.forEach(房间 => {
                    if (房间.isSurvivalChallenge) {
                        const monstersInRoom = 所有怪物.filter(m => m.房间ID === 房间.id);
                        if (monstersInRoom.length === 0) {
                             let 石碑 = null;
                             // 我不知道什么是低效，It works perfectly. :)
                             for(const row of 地牢) {
                                for(const cell of row) {
                                    if(cell.关联物品 instanceof 挑战石碑 && cell.关联物品.自定义数据.get("已激活") && 房间地图[cell.y][cell.x] === 房间.id) {
                                        石碑 = cell.关联物品;
                                        break;
                                    }
                                }
                                if(石碑) break;
                             }
                            if(石碑) {
                                石碑.刷新生存挑战下一波(房间);
                            }
                        }
                    }
                });
                Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                    玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                )
                    .filter((v) => v != null)
                    .forEach((装备) => {
                        if (装备 instanceof 宠物) {
                            装备.恢复生命值();
                        }
                    });
                更新界面状态();
                房间列表.forEach((房间) => {
                    if (
                        房间.类型 === "挑战房间" &&
                        房间.挑战状态 &&
                        房间.挑战状态.进行中
                    ) {
                        房间.挑战状态.波次当前回合数--;
                        房间.挑战状态.波次内怪物 =
                            房间.挑战状态.波次内怪物.filter(
                                (m) => m.当前生命值 > 0 && 所有怪物.includes(m)
                            );

                        if (房间.挑战状态.波次内怪物.length === 0) {
                            添加日志(
                                `房间 ${房间.id} 第 ${房间.挑战状态.当前波次} 波怪物已清除！`,
                                "成功"
                            );
                            刷新挑战房间下一波(房间);
                        } else if (
                            房间.挑战状态.当前波次 < 房间.挑战状态.总波次
                        ) {
                            if (房间.挑战状态.波次当前回合数 <= 0) {
                                添加日志(
                                    `房间 ${房间.id} 第 ${房间.挑战状态.当前波次} 波时间到！`,
                                    "警告"
                                );
                                刷新挑战房间下一波(房间);
                            }
                        }
                    }
                });
            }
            function 处理玩家着陆效果(旧X, 旧Y, 新X, 新Y) {
                const 目标单元格 = 地牢[新Y]?.[新X];
                if (!目标单元格) return false;

                if (
                    目标单元格.关联物品 &&
                    目标单元格.类型 === 单元格类型.物品 &&
                    目标单元格.关联物品.能否拾起 &&
                    !目标单元格.关联物品.是否被丢弃
                ) {
                    if (尝试收集物品(目标单元格.关联物品)) {
                        目标单元格.类型 = null;
                        目标单元格.关联物品 = null;
                    }
                } else if (
                    [单元格类型.楼梯下楼, 单元格类型.楼梯上楼].includes(
                        目标单元格.类型
                    )
                ) {
                    if (
                        是否为教程层 &&
                        目标单元格.类型 === 单元格类型.楼梯下楼
                    ) {
                        是否为教程层 = false;
                        所有怪物.forEach((m) => {
                            m.绘制血条(true);
                            if (地牢[m.y] && 地牢[m.y][m.x])
                                地牢[m.y][m.x].关联怪物 = null;
                        });
                        所有怪物 = [];
                        document.getElementById("跳过教程按钮").style.display =
                            "none";
                        重置玩家状态();
                        切换楼层(0);
                        return true;
                    } else if (目标单元格.关联物品?.使用) {
                        目标单元格.关联物品.使用();
                        return true;
                    }
                } else if (目标单元格.关联物品 instanceof 折跃门) {
                    if (目标单元格.关联物品.使用()) {
                        return true;
                    }
                }

                const 目标房间ID = 房间地图[新Y][新X];
                处理单向房间(旧X, 旧Y, 新X, 新Y);
                if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
                    moveQueue = [];
                    isAutoMoving = false;
                    已访问房间.add(目标房间ID);
                    const 能量条 = document.querySelector(".power-bar");
                    const 当前能量 = parseFloat(能量条?.style.width) || 100;
                    if (能量条)
                        能量条.style.width = `${Math.min(
                            100,
                            当前能量 + 1.5
                        )}%`;
                    const 进入的房间 = 房间列表[目标房间ID];
                    if (
                        进入的房间 &&
                        进入的房间.类型 === "挑战房间" &&
                        进入的房间.挑战状态 &&
                        !进入的房间.挑战状态.进行中 &&
                        !进入的房间.挑战状态.已完成
                    ) {
                        开始挑战(进入的房间);
                    }
                    if (是否为教程层) {
                        教程阶段 = 目标房间ID;
                        教程提示已显示 = false;
                        显示教程提示();
                    }
                }

                尝试进入特殊房间(新X, 新Y);
                return false;
            }
            function 处理单向房间(旧X, 旧Y, 新X, 新Y) {
            const 新房间ID = 房间地图[新Y]?.[新X];
            const 进入的房间 = 房间列表[新房间ID];
            if (新房间ID === -1) return;
            进入的房间?.门?.forEach(门坐标 => {
                const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
                if (!门单元格 || ![单元格类型.门, 单元格类型.上锁的门].includes(门单元格.背景类型)) {
                    return;
                }

                const 配对单元格坐标 = 门单元格.配对单元格位置;
                const 配对单元格 = 配对单元格坐标 ? 地牢[配对单元格坐标.y]?.[配对单元格坐标.x] : null;

                const 是入口门 = 进入的房间?.首次进入的门坐标系统?.some(
                    保存的坐标 => 保存的坐标.x === 门坐标.x && 保存的坐标.y === 门坐标.y
                );

                if (是入口门) {
                    门单元格.isOneWay = false;
                    门单元格.oneWayAllowedDirection = null;
                    if (配对单元格) {
                        配对单元格.isOneWay = false;
                        配对单元格.oneWayAllowedDirection = null;
                    }
                }
            });

            if ((旧X !== undefined && 房间地图[旧Y]?.[旧X] === 新房间ID)) return;

            
            if (!进入的房间 || 进入的房间.类型 !== "单向房间") return;

            if (!进入的房间.首次进入的门坐标系统) {
                进入的房间.首次进入的门坐标系统 = [];
                let 最小距离 = Infinity;
                let 最近门坐标 = null;

                for (const 门坐标 of 进入的房间.门) {
                    const 距离 = Math.abs(新X - 门坐标.x) + Math.abs(新Y - 门坐标.y);
                    if (距离 < 最小距离) {
                        最小距离 = 距离;
                        最近门坐标 = 门坐标;
                    }
                }

                if (最近门坐标) {
                    const 主门单元格实例 = 地牢[最近门坐标.y]?.[最近门坐标.x];
                    if (主门单元格实例) {
                        进入的房间.首次进入的门坐标系统.push({ x: 最近门坐标.x, y: 最近门坐标.y });
                        if (主门单元格实例.配对单元格位置) {
                            进入的房间.首次进入的门坐标系统.push({ ...主门单元格实例.配对单元格位置 });
                        }
                    }
                }
            }

            进入的房间.门.forEach(门坐标 => {
                const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
                if (!门单元格 || ![单元格类型.门, 单元格类型.上锁的门].includes(门单元格.背景类型)) {
                    return;
                }

                const 配对单元格坐标 = 门单元格.配对单元格位置;
                const 配对单元格 = 配对单元格坐标 ? 地牢[配对单元格坐标.y]?.[配对单元格坐标.x] : null;

                const 是入口门 = 进入的房间.首次进入的门坐标系统.some(
                    保存的坐标 => 保存的坐标.x === 门坐标.x && 保存的坐标.y === 门坐标.y
                );

                if (!是入口门) {
                    门单元格.isOneWay = true;
                    门单元格.oneWayAllowedDirection = randomlySetOneWayDirection(门单元格);
                    if (配对单元格) {
                        配对单元格.oneWayAllowedDirection = 门单元格.oneWayAllowedDirection;
                    }
                }
            });
        }

            async function 移动玩家(dx, dy, 冷却 = true) {
                if (
                    玩家属性.允许移动 > 0 ||
                    (游戏状态 !== "游戏中" && 游戏状态 !== "图鉴")
                )
                    return false;
                if (冷却) {
                    const now = Date.now();
                    if (now - 上次移动 < 50) return;
                    上次移动 = now;
                }
                const 能量条 = document.querySelector(".power-bar");
                const 当前能量 = parseFloat(能量条.style.width) || 100;
                const 眩晕状态 = 玩家状态.some((s) => s.类型 === "眩晕");
                const 冻结状态 = 玩家状态.some((s) => s.类型 === "冻结");
                const 缓慢状态 = 玩家状态.some((s) => s.类型 === "缓慢");

                let 移动方向X = dx;
                let 移动方向Y = dy;

                if (眩晕状态 && (dx !== 0 || dy !== 0)) {
                    添加日志("你晕头转向，胡乱移动！", "警告");
                    const 方向列表 = [
                        { dx: 0, dy: -1 },
                        { dx: 1, dy: 0 },
                        { dx: 0, dy: 1 },
                        { dx: -1, dy: 0 },
                    ];
                    const 可移动方向 = 方向列表.filter((dir) =>
                        检查移动可行性(
                            玩家.x,
                            玩家.y,
                            玩家.x + dir.dx,
                            玩家.y + dir.dy
                        )
                    );

                    if (可移动方向.length > 0) {
                        const 随机方向 =
                            可移动方向[
                                Math.floor(Math.random() * 可移动方向.length)
                            ];
                        dx = 随机方向.dx;
                        dy = 随机方向.dy;
                    } else {
                        dx = 0;
                        dy = 0;
                    }

                    dx *= 玩家属性.移动步数;
                    dy *= 玩家属性.移动步数;

                    if (缓慢状态) {
                        dx = Math.sign(dx);
                        dy = Math.sign(dy);
                    }
                } else {
                    if (缓慢状态) {
                        dx = Math.sign(dx);
                        dy = Math.sign(dy);
                    }
                }

                let 新X = 玩家.x + dx;
                let 新Y = 玩家.y + dy;
                if (
                    新X < 0 ||
                    新X >= 地牢大小 ||
                    新Y < 0 ||
                    新Y >= 地牢大小 ||
                    (dy !== 0 && dx !== 0)
                )
                    return;
                相机锁定 = false;
                if (玩家正在钩索) {
                    玩家正在钩索 = false;
                    clearTimeout(钩索移动定时器);
                }
                const 目标X_挖掘 = 玩家.x + Math.sign(dx);
                const 目标Y_挖掘 = 玩家.y + Math.sign(dy);
                if (玩家属性.能挖掘墙壁 && (dx !== 0 || dy !== 0) && !生存挑战激活) {
                    if (目标X_挖掘 >= 0 && 目标X_挖掘 < 地牢大小 && 目标Y_挖掘 >= 0 && 目标Y_挖掘 < 地牢大小) {
                        const 目标单元格 = 地牢[目标Y_挖掘]?.[目标X_挖掘];
                        if (目标单元格 && 目标单元格.背景类型 === 单元格类型.墙壁) {
                             if(扣除能量(5)) {
                                目标单元格.背景类型 = 地牢[玩家.y][玩家.x].背景类型;
                                生成墙壁();
                                显示通知("你挖开了一堵墙！", "成功");
                             } else {
                                显示通知("能量不足，无法挖掘！", "错误");
                                return false;
                             }
                        }
                    }
                }
                let 剩余步数 = 缓慢状态 ? 1 : 玩家属性.移动步数;
                let 实际移动 = 0;
                let 目标X,
                    目标Y = 0;
                while (
                    剩余步数 > 0 &&
                    !冻结状态 &&
                    (玩家.x !== 新X || 玩家.y !== 新Y)
                ) {
                    目标X = 玩家.x + Math.sign(dx);
                    目标Y = 玩家.y + Math.sign(dy);
                    let 目标单元格 = 地牢[目标Y]?.[目标X];
                    let 当前单元格 = 地牢[玩家.y]?.[玩家.x];
                    if (!检查移动可行性(玩家.x, 玩家.y, 目标X, 目标Y)) break;
                    if (!目标单元格) {
                        更新视口();
                        绘制();
                        return;
                    }
                    if (
                        目标单元格.isOneWay &&
                        [单元格类型.门, 单元格类型.上锁的门].includes(
                            目标单元格.背景类型
                        )
                    ) {
                        const actualMoveMapDirection = getMoveDirection(
                            玩家.x,
                            玩家.y,
                            目标X,
                            目标Y
                        );
                        if (
                            actualMoveMapDirection !==
                            目标单元格.oneWayAllowedDirection
                        ) {
                            break;
                        }
                    }

                    const 旧X = 玩家.x;
                    const 旧Y = 玩家.y;

                    let 触发中断 = 处理玩家着陆效果(旧X, 旧Y, 目标X, 目标Y);

                    if (!触发中断) {
                        玩家.x = 目标X;
                        玩家.y = 目标Y;
                    } else {
                        break;
                    }
                    实际移动++;
                    剩余步数--;

                    if (当前激活卷轴列表.size > 0 && 实际移动 > 0) {
                        当前激活卷轴列表.forEach((卷轴) => {
                            卷轴.消耗能量();
                        });
                    }
                    if (!切换动画) {
                        处理回合逻辑();
                    }
                }
                if (冻结状态) {
                    处理回合逻辑();
                }
                if (地牢[玩家.y][玩家.x].关联物品 instanceof 折跃门) {
                    地牢[玩家.y][玩家.x].关联物品.使用();
                }
                尝试进入特殊房间(玩家.x, 玩家.y);
                if (实际移动 > 0 || 冻结状态) {
                    const 方向 =
                        Math.sign(dy) === -1
                            ? "上"
                            : Math.sign(dy) === 1
                            ? "下"
                            : Math.sign(dx) === -1
                            ? "左"
                            : Math.sign(dx) === 1
                            ? "右"
                            : "";
                    移动历史.push(方向);

                    if (移动历史.length > 调试序列.length) {
                        移动历史.shift();
                    }
                    Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                        玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                    )
                        .filter((v) => v != null)
                        .forEach((item) => {
                            if (item instanceof 寻宝戒指) {
                                if (
                                    item.自定义数据.get("生效层数") ===
                                        当前层数 &&
                                    !item.自定义数据.get("已生成折跃门")
                                ) {
                                    item.尝试生成折跃门();
                                }
                            }
                        });

                    if (移动历史.join(",") === 调试序列.join(",")) {
                        const 当前房间ID = 房间地图[玩家.y][玩家.x];
                        if (当前房间ID !== -1) {
                            const 迅捷卷轴测试 = new 迅捷卷轴({});
                            放置物品到房间(迅捷卷轴测试, 房间列表[当前房间ID]);

                            const 秘银锁甲测试 = new 秘银锁甲({});
                            放置物品到房间(秘银锁甲测试, 房间列表[当前房间ID]);

                            const 跃迁卷轴测试 = new 跃迁卷轴({});
                            放置物品到房间(跃迁卷轴测试, 房间列表[当前房间ID]);

                            const 真言卷轴测试 = new 真言卷轴({});
                            放置物品到房间(真言卷轴测试, 房间列表[当前房间ID]);
                            const 调试工具实例 = new 调试工具({});
                            放置物品到房间(调试工具实例, 房间列表[当前房间ID]);

                            const 湮灭卷轴测试 = new 湮灭卷轴({});
                            放置物品到房间(湮灭卷轴测试, 房间列表[当前房间ID]);

                            const 贪婪卷轴测试 = new 贪婪卷轴({});
                            放置物品到房间(贪婪卷轴测试, 房间列表[当前房间ID]);

                            const 附魔卷轴测试 = new 附魔卷轴({});
                            放置物品到房间(附魔卷轴测试, 房间列表[当前房间ID]);

                            const 回旋镖测试 = new 回旋镖({});
                            放置物品到房间(回旋镖测试, 房间列表[当前房间ID]);

                            const 冰霜法杖测试 = new 冰霜法杖({});
                            放置物品到房间(冰霜法杖测试, 房间列表[当前房间ID]);

                            const 剧毒匕首测试 = new 剧毒匕首({});
                            放置物品到房间(剧毒匕首测试, 房间列表[当前房间ID]);

                            const 重力锤测试 = new 重力锤({});
                            放置物品到房间(重力锤测试, 房间列表[当前房间ID]);

                            const 闪电链法杖测试 = new 闪电链法杖({});
                            放置物品到房间(
                                闪电链法杖测试,
                                房间列表[当前房间ID]
                            );

                            const 大地猛击锤测试 = new 大地猛击锤({});
                            放置物品到房间(
                                大地猛击锤测试,
                                房间列表[当前房间ID]
                            );

                            const 穿云箭测试 = new 穿云箭({});
                            放置物品到房间(穿云箭测试, 房间列表[当前房间ID]);

                            const 荆棘鞭测试 = new 荆棘鞭({});
                            放置物品到房间(荆棘鞭测试, 房间列表[当前房间ID]);

                            const 能量药水测试 = new 能量药水({});
                            放置物品到房间(能量药水测试, 房间列表[当前房间ID]);

                            const 狂暴药水测试 = new 狂暴药水({});
                            放置物品到房间(狂暴药水测试, 房间列表[当前房间ID]);

                            const 神龟药水测试 = new 神龟药水({});
                            放置物品到房间(神龟药水测试, 房间列表[当前房间ID]);

                            const 治疗药水测试 = new 治疗药水({});
                            放置物品到房间(治疗药水测试, 房间列表[当前房间ID]);

                            const 透视药水测试 = new 透视药水({});
                            放置物品到房间(透视药水测试, 房间列表[当前房间ID]);

                            const 隐身药水测试 = new 隐身药水({});
                            放置物品到房间(隐身药水测试, 房间列表[当前房间ID]);

                            const 橡木法杖测试 = new 橡木法杖({});
                            放置物品到房间(橡木法杖测试, 房间列表[当前房间ID]);

                            const 金币手枪测试 = new 金币手枪({});
                            放置物品到房间(金币手枪测试, 房间列表[当前房间ID]);

                            const 寻宝戒指测试 = new 寻宝戒指({});
                            放置物品到房间(寻宝戒指测试, 房间列表[当前房间ID]);

                            const 炸弹测试 = new 炸弹({});
                            放置物品到房间(炸弹测试, 房间列表[当前房间ID]);

                            const 冰盾测试 = new 冰盾({});
                            放置物品到房间(冰盾测试, 房间列表[当前房间ID]);

                            const 重铸台测试 = new 重铸台({});
                            放置物品到房间(重铸台测试, 房间列表[当前房间ID]);

                            const 神秘商人测试 = new 神秘商人({});
                            放置物品到房间(神秘商人测试, 房间列表[当前房间ID]);

                            const 探险家测试 = new 探险家({});
                            放置物品到房间(探险家测试, 房间列表[当前房间ID]);

                            const 喷火枪测试 = new 喷火枪({});
                            放置物品到房间(喷火枪测试, 房间列表[当前房间ID]);

                            const 背包扩容祭坛测试 = new 背包扩容祭坛({});
                            放置物品到房间(
                                背包扩容祭坛测试,
                                房间列表[当前房间ID]
                            );

                            const 宠物测试 = new 水母({});
                            放置物品到房间(宠物测试, 房间列表[当前房间ID]);

                            const 金币测试 = new 金币({ 数量: 64 });
                            放置物品到房间(金币测试, 房间列表[当前房间ID]);
                            if (!彩蛋3触发) {
                                显示通知("你被加强了，快上！", "信息", true);
                                彩蛋3触发 = true;
                            }
                        }
                        移动历史 = [];
                    }
                    更新视口();
                    if (当前天气效果.includes("诡魅")) {
                        处理诡魅房间刷新(
                            玩家.x - dx,
                            玩家.y - dy,
                            玩家.x,
                            玩家.y
                        );
                    }
                }
                if (isAutoMoving && (玩家.x !== 新X || 玩家.y !== 新Y)) {
                    moveQueue = [];
                    isAutoMoving = false;
                }
                if (玩家属性.随机掉落 && Math.random() < 0.09) {
                    const 可掉落物品 = [...玩家背包.values()].filter(item => !item.是否隐藏 && !item.已装备);
                    if (可掉落物品.length > 0) {
                        const 掉落物品 = 可掉落物品[Math.floor(Math.random() * 可掉落物品.length)];
                        if (处理丢弃物品(掉落物品.唯一标识)) {
                            显示通知(`【诅咒】你的 ${掉落物品.获取名称()} 不小心掉了出来！`, "警告");
                        }
                    }
                }
                更新界面状态();
                绘制();
            }
            function 扣除能量(能量, 是否卷轴 = false) {
                if(调试无限能量) return true;
                const 能量条 = document.querySelector(".power-bar");
                let 当前能量 = Math.max(
                    Math.min(parseFloat(能量条.style.width), 100),
                    0
                );
                当前能量 -= 能量;
                if (当前能量 <= 0) {
                    if (当前激活卷轴列表.size > 0) {
                        当前激活卷轴列表.forEach((卷轴) => {
                            当前激活卷轴列表.delete(卷轴);
                            卷轴.卸下();
                        });

                        当前能量 = 0;
                    }
                    更新装备显示();
                    if (是否卷轴)
                        显示通知("能量不足，已自动取消卷轴效果", "信息");
                    return false;
                }
                能量条.style.width = `${Math.max(0, 当前能量)}%`;
                触发HUD显示();
                return true;
            }
            function 检查移动可行性(
                fromX,
                fromY,
                toX,
                toY,
                未解锁房间视作障碍 = false
            ) {
                if (toX < 0 || toX >= 地牢大小 || toY < 0 || toY >= 地牢大小)
                    return false;

                const dx = toX - fromX;
                const dy = toY - fromY;
                const 方向 = {
                    dx: dx !== 0 ? (dx > 0 ? 1 : -1) : 0,
                    dy: dy !== 0 ? (dy > 0 ? 1 : -1) : 0,
                };
                if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                    if (dx !== 0 && dy !== 0) return false;
                    return 快速直线检查(
                        fromX,
                        fromY,
                        toX,
                        toY,
                        Math.max(Math.abs(dx), Math.abs(dy))
                    );
                }

                let currentX = fromX;
                let currentY = fromY;

                while (currentX !== toX || currentY !== toY) {
                    currentX += 方向.dx;
                    currentY += 方向.dy;

                    const 当前单元格 = 地牢[currentY][currentX];
                    const 前一单元格 =
                        地牢[currentY - 方向.dy][currentX - 方向.dx];

                    const 垂直移动 = 方向.dy !== 0;
                    const 墙方向 = 垂直移动
                        ? 方向.dy > 0
                            ? "下"
                            : "上"
                        : 方向.dx > 0
                        ? "右"
                        : "左";

                    if (垂直移动) {
                        if (
                            前一单元格.墙壁[方向.dy > 0 ? "下" : "上"] ||
                            当前单元格.墙壁[方向.dy > 0 ? "上" : "下"]
                        ) {
                            return false;
                        }
                    } else {
                        if (
                            前一单元格.墙壁[方向.dx > 0 ? "右" : "左"] ||
                            当前单元格.墙壁[方向.dx > 0 ? "左" : "右"]
                        ) {
                            return false;
                        }
                    }

                    if (
                        [单元格类型.墙壁, 单元格类型.上锁的门].includes(
                            当前单元格.背景类型
                        )
                    ) {
                        return false;
                    }
                    if (
                        房间地图[currentY][currentX] !== 0 &&
                        房间地图[currentY][currentX] !== -1 &&
                        !已访问房间.has(房间地图[currentY][currentX]) &&
                        未解锁房间视作障碍
                    )
                        return false;
                }
                return true;
            }
            function 处理丢弃物品(唯一标识) {
                const 物品实例 = 玩家背包.get(唯一标识);
                if (!物品实例) return false;

                let 目标X = 玩家.x;
                let 目标Y = 玩家.y;
                let 可用 = false;

                if (位置是否可用(目标X, 目标Y, false)) {
                    可用 = true;
                } else {
                    const 方向 = [
                        [0, -1],
                        [0, 1],
                        [-1, 0],
                        [1, 0],
                        [1, -1],
                        [1, 1],
                        [-1, 1],
                        [-1, -1],
                    ];
                    for (const [dx, dy] of 方向) {
                        const 新X = 玩家.x + dx;
                        const 新Y = 玩家.y + dy;

                        if (
                            新X >= 0 &&
                            新X < 地牢大小 &&
                            新Y >= 0 &&
                            新Y < 地牢大小 &&
                            位置是否可用(新X, 新Y) &&
                            检查移动可行性(玩家.x, 玩家.y, 新X, 新Y)
                        ) {
                            目标X = 新X;
                            目标Y = 新Y;
                            可用 = true;
                            break;
                        }
                    }
                }

                if (!可用) {
                    显示通知("周围没有空间丢弃物品！", "错误");
                    return false;
                }
                if (!物品实例.当被丢弃(目标X, 目标Y)) {
                    return false;
                }
                玩家背包.delete(唯一标识);
                if (物品实例.已装备) {
                    物品实例.取消装备();
                    玩家装备.delete(物品实例.装备槽位);
                    物品实例.已装备 = false;
                    物品实例.装备槽位 = null;
                }

                物品实例.是否被丢弃 = true;
                物品实例.isActive = false;
                放置物品到单元格(物品实例, 目标X, 目标Y);

                更新背包显示();
                更新装备显示();
                显示通知(`丢弃了 ${物品实例.获取名称()}`, "信息");
                document.getElementById("浮动提示框").style.display = "none";

                return true;
            }
            function 处理天气效果() {
                if (当前天气效果.includes("雷暴")) {
                    处理雷暴效果();
                }
                if (当前天气效果.includes("大风")) {
                    处理大风效果();
                }
                if (当前天气效果.includes("严寒")) {
                    处理严寒效果();
                } else {
                    解冻药水();
                }
            }
            function 是否靠近火源(目标X, 目标Y) {
                if (目标X === 玩家.x && 目标Y === 玩家.y) {
                    if (玩家状态.some((s) => s.类型 === "火焰")) return true;
                    if (
                        Array.from({ length: 装备栏每页装备数 }, (_, i) =>
                            玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                        )
                            .filter((v) => v != null)
                            .some(
                                (装备) =>
                                    装备 instanceof 火把 &&
                                    装备.自定义数据?.get("耐久") > 0
                            )
                    )
                        return true;
                }

                const 方向数组 = [
                    [0, 0],
                    [0, -1],
                    [0, 1],
                    [-1, 0],
                    [1, 0],
                    [-1, -1],
                    [1, -1],
                    [-1, 1],
                    [1, 1],
                ];
                for (const [dx, dy] of 方向数组) {
                    const 检查X = 目标X + dx;
                    const 检查Y = 目标Y + dy;
                    if (
                        检查X >= 0 &&
                        检查X < 地牢大小 &&
                        检查Y >= 0 &&
                        检查Y < 地牢大小
                    ) {
                        const 单元格 = 地牢[检查Y]?.[检查X];
                        const 怪物实例 = 单元格?.关联怪物;
                        if (
                            单元格?.关联物品 instanceof 火焰物品 &&
                            单元格.关联物品.自定义数据.get("倒计时") > 0
                        ) {
                            return true;
                        } else if (
                            单元格?.关联物品 instanceof 火把 &&
                            单元格.关联物品.自定义数据.get("耐久") > 0 &&
                            单元格.关联物品.是否被丢弃
                        ) {
                            return true;
                        } else if (
                            怪物实例 &&
                            怪物状态表.get(怪物实例)?.类型 === "火焰"
                        ) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function 解冻药水() {
                let 解冻发生标志 = false;
                玩家背包.forEach((物品实例) => {
                    if (
                        物品实例 instanceof 药水类 &&
                        物品实例.自定义数据.get("是否冻结")
                    ) {
                        物品实例.自定义数据.set("是否冻结", false);

                        解冻发生标志 = true;
                    }
                });
                if (解冻发生标志) {
                    添加日志("背包里的药水解冻了。", "信息");
                    更新背包显示();
                }
            }

            function 处理严寒效果() {
                if (
                    !玩家状态.some((s) => s.类型 === "冻结") &&
                    !是否靠近火源(玩家.x, 玩家.y)
                ) {
                    if (Math.random() < 0.1) {
                        new 状态效果(
                            "冻结",
                            "#2196F3",
                            图标映射.冰冻怪物,
                            2,
                            null,
                            null,
                            null,
                            1
                        );
                        添加日志("你被严寒冻结了！", "错误");
                    }
                }

                let 有药水被冻结 = false;
                玩家背包.forEach((物品实例) => {
                    if (
                        物品实例 instanceof 药水类 &&
                        !物品实例.自定义数据.get("是否冻结")
                    ) {
                        if (!是否靠近火源(玩家.x, 玩家.y)) {
                            物品实例.自定义数据.set("是否冻结", true);
                            有药水被冻结 = true;
                            添加日志(
                                `${物品实例.获取名称()} 被冻结了！`,
                                "警告"
                            );
                        }
                    }
                });
                if (有药水被冻结) {
                    更新背包显示();
                }
                if (是否靠近火源(玩家.x, 玩家.y)) {
                    解冻药水();
                }
            }
            function 处理雷暴效果() {
                if (Math.random() < 0.1) {
                    const 玩家房间ID = 房间地图[玩家.y][玩家.x];
                    if (玩家房间ID === -1) return;

                    const 玩家所在房间 = 房间列表[玩家房间ID];
                    if (
                        !玩家所在房间 ||
                        玩家所在房间.w < 2 ||
                        玩家所在房间.h < 2
                    )
                        return;

                    const rx =
                        玩家所在房间.x +
                        Math.floor(Math.random() * (玩家所在房间.w - 1));
                    const ry =
                        玩家所在房间.y +
                        Math.floor(Math.random() * (玩家所在房间.h - 1));

                    const 闪电坐标 = [
                        { x: rx, y: ry },
                        { x: rx + 1, y: ry },
                        { x: rx, y: ry + 1 },
                        { x: rx + 1, y: ry + 1 },
                    ];

                    计划显示格子特效(闪电坐标, "FFFF00", 50);

                    闪电坐标.forEach((坐标) => {
                        if (
                            坐标.x < 0 ||
                            坐标.x >= 地牢大小 ||
                            坐标.y < 0 ||
                            坐标.y >= 地牢大小
                        )
                            return;
                        const 单元格 = 地牢[坐标.y]?.[坐标.x];
                        if (!单元格) return;

                        if (
                            单元格.关联物品 &&
                            单元格.关联物品?.类型 !== "楼梯" &&
                            !(单元格.关联物品 instanceof 挑战石碑)
                        ) {
                            const 被毁物品 = 单元格.关联物品;
                            添加日志(`${被毁物品.名称} 被闪电摧毁了！`, "警告");
                            const 计时器索引 = 所有计时器.findIndex(
                                (t) => t.唯一标识 === 被毁物品.唯一标识
                            );
                            if (计时器索引 !== -1) {
                                所有计时器.splice(计时器索引, 1);
                            }
                            if (玩家背包.has(被毁物品.唯一标识)) {
                                处理销毁物品(被毁物品.唯一标识, true);
                            }
                            单元格.关联物品 = null;
                            单元格.类型 = 单元格.背景类型;
                        }

                        if (单元格.关联怪物) {
                            const 怪物 = 单元格.关联怪物;
                            let 被击中日志 = `${怪物.类型} 被闪电击中`;
                            if (怪物.强化) {
                                怪物.受伤(15, "雷暴");
                                被击中日志 += `，损失了 15 点生命！`;
                            } else {
                                怪物.强化 = true;
                                怪物.绘制血条();
                                显示通知(`${怪物.类型} 被闪电强化了！`, "警告");
                                被击中日志 += `，并被强化了！`;
                                绘制();
                            }
                            const 火焰强度 = 3;
                            const 火焰持续 = 3;
                            new 状态效果(
                                "火焰",
                                效果颜色编号映射[效果名称编号映射.火焰],
                                "火",
                                火焰持续,
                                null,
                                null,
                                怪物,
                                火焰强度
                            );
                            被击中日志 += ` 还着火了！`;

                            添加日志(被击中日志, "警告");
                        }

                        if (玩家.x === 坐标.x && 玩家.y === 坐标.y) {
                            伤害玩家(15, "雷暴");
                            显示通知("你被闪电击中了！", "错误");

                            const 火焰强度玩家 = 3;
                            const 火焰持续玩家 = 3;
                            new 状态效果(
                                "火焰",
                                效果颜色编号映射[效果名称编号映射.火焰],
                                图标映射.火焰,
                                火焰持续玩家,
                                null,
                                null,
                                null,
                                火焰强度玩家
                            );
                            添加日志("你被闪电点燃了！", "错误");
                        }

                        if (位置是否可用(坐标.x, 坐标.y, false)) {
                            const 火焰 = new 火焰物品({
                                强化: Math.random() < 0.1,
                            });
                            if (!放置物品到单元格(火焰, 坐标.x, 坐标.y)) {
                                console.warn(
                                    `未能放置火焰物品在 (${坐标.x}, ${坐标.y})`
                                );
                            }
                        }
                    });
                    绘制();
                }
            }
            let 融合区物品 = [null, null, null, null]; // 存储物品的唯一标识 Symbol
            let 融合结果 = null; // 存储融合结果的物品实例

            const 融合配方列表 = [
                {
                    输入: ["治疗药水", "治疗药水"].sort(),
                    输出类: "治疗药水",
                    输出数量: 1,
                    输出配置: { 强化: true },
                },
                {
                    输入: ["钢制长剑", "治疗药水"].sort(),
                    输出类: "吸血剑",
                    输出数量: 1,
                },
                {
                    输入: ["钢制长剑", "钢制长剑"].sort(),
                    输出类: "钢制长剑",
                    输出数量: 1,
                    输出配置: { 强化: true },
                },
            ];

            let fusionGoldQuantities = [0, 0, 0, 0];

            function 添加到融合区(物品唯一标识) {
                const 物品实例 = 玩家背包.get(物品唯一标识);
                if (!物品实例) {
                    return;
                }

                let targetSlotIndex = -1;

                if (物品实例 instanceof 金币) {
                    for (let i = 0; i < 4; i++) {
                        const slotItemId = 融合区物品[i];
                        const itemInSlot = slotItemId
                            ? 玩家背包.get(slotItemId)
                            : null;
                        if (
                            slotItemId === null ||
                            (itemInSlot instanceof 金币 &&
                                fusionGoldQuantities[i] < 最大堆叠数)
                        ) {
                            targetSlotIndex = i;
                            break;
                        }
                    }
                } else {
                    targetSlotIndex = 融合区物品.findIndex(
                        (格子) => 格子 === null
                    );
                }

                if (targetSlotIndex === -1) {
                    显示通知("融合区已满或无合适槽位！", "错误");
                    return;
                }

                if (物品实例 instanceof 金币) {
                    物品实例.堆叠数量--;
                    if (物品实例.堆叠数量 > 0) {
                    } else {
                        物品实例.是否隐藏 = true;
                        融合区物品[targetSlotIndex] = 物品实例.唯一标识;
                    }
                    if (!融合区物品[targetSlotIndex]) {
                        融合区物品[targetSlotIndex] = 物品实例.唯一标识;
                    }
                    fusionGoldQuantities[targetSlotIndex]++;
                    document.getElementById("浮动提示框").style.display =
                        "none";
                } else {
                    // 非金币物品
                    if (物品实例.堆叠数量 > 1) {
                        物品实例.堆叠数量 -= 1;
                    } else {
                        物品实例.是否隐藏 = true; // 标记为隐藏，表示已移入融合区
                        物品实例.isActive = false;
                        if (物品实例.显示元素)
                            物品实例.显示元素.classList.remove("active");
                        document.getElementById("浮动提示框").style.display =
                            "none";
                    }
                    融合区物品[targetSlotIndex] = 物品实例.唯一标识;
                    // fusionGoldQuantities is not used for non-gold items this way
                }

                检查融合配方();
                更新融合窗口();
                更新背包显示();
                更新装备显示();
            }

            let 当前匹配的融合配方 = null;

            function 检查融合配方() {
                当前匹配的融合配方 = null;
                const 输出格子 = document.getElementById("融合输出格子");
                输出格子.innerHTML = "";
                融合结果 = null;
                输出格子.onclick = null;

                const 融合槽有效条目 = [];
                for (let i = 0; i < 4; i++) {
                    const id = 融合区物品[i];
                    if (id) {
                        const item = 玩家背包.get(id);
                        if (item) {
                            if (item instanceof 金币) {
                                if (fusionGoldQuantities[i] > 0) {
                                    融合槽有效条目.push({
                                        item: item,
                                        quantityInSlot: fusionGoldQuantities[i],
                                    });
                                }
                            } else {
                                融合槽有效条目.push({
                                    item: item,
                                    quantityInSlot: item.堆叠数量,
                                });
                            }
                        }
                    }
                }

                if (融合槽有效条目.length === 0) {
                    return;
                }

                const 融合槽物品实例列表 = 融合槽有效条目.map(
                    (entry) => entry.item
                );
                const 融合槽物品名称列表_sorted = 融合槽物品实例列表
                    .map((item) => item.名称)
                    .sort();
                const 磨刀石实例 = 融合槽物品实例列表.find(item => item instanceof 磨刀石);
                const 武器实例ForSharpen = 融合槽物品实例列表.find(item => item instanceof 武器类);
                const 融合区第一个是磨刀石 = 玩家背包.get(融合区物品[0]) instanceof 磨刀石;

                if (融合槽物品实例列表.length === 2 && 磨刀石实例 && 武器实例ForSharpen && 融合区第一个是磨刀石) {
                    if (磨刀石实例.自定义数据.get("耐久") > 0) {
                        当前匹配的融合配方 = "磨刀石打磨";
                        融合结果 = 克隆物品(武器实例ForSharpen);
                        融合结果.唯一标识 = Symbol("SharpenPreview_" + Date.now());
                        const 预览元素 = 融合结果.生成显示元素("融合");
                        预览元素.style.cursor = "pointer";
                        输出格子.appendChild(预览元素);
                        输出格子.onclick = () => setTimeout(() => 执行融合(), 0);
                        return;
                    }
                }

                

                const 附魔卷轴实例 = 融合槽物品实例列表.find(
                    (item) =>
                        item instanceof 附魔卷轴 &&
                        item.自定义数据.get("已解锁")
                );
                const 其他物品实例列表 = 融合槽物品实例列表.filter(
                    (item) => !(item instanceof 附魔卷轴)
                );

                if (附魔卷轴实例 && 其他物品实例列表.length === 1) {
                    const 目标物品实例 = 其他物品实例列表[0];
                    if (
                        目标物品实例 instanceof 武器类 ||
                        目标物品实例 instanceof 防御装备类
                    ) {
                        const 附魔兼容性 = {
                            火焰附魔: ["武器", "防御装备"],
                            保护附魔: ["防御装备"],
                            耐久附魔: ["武器", "防御装备"],
                            锋利附魔: ["武器"],
                            爆炸保护附魔: ["防御装备"],
                            连锁附魔: ["武器"],
                            荆棘附魔: ["防御装备"],
                        };
                        const 附魔种类 = 附魔卷轴实例.当前附魔效果名;
                        const 允许列表 = 附魔兼容性[附魔种类];
                        let 兼容 =
                            允许列表 && 允许列表.includes(目标物品实例.类型);

                        if (
                            兼容 &&
                            目标物品实例.自定义数据
                                .get("附魔")
                                ?.some(
                                    (e) =>
                                        e.种类 === 附魔种类 &&
                                        e.等级 >= 附魔卷轴实例.品质
                                )
                        ) {
                            兼容 = false;
                        }

                        if (兼容) {
                            当前匹配的融合配方 = "卷轴附魔融合";
                            融合结果 = 克隆物品(目标物品实例);
                            
                            const 输入物品是否有不可破坏 = [附魔卷轴实例, 目标物品实例].some(item => item.自定义数据?.get("不可破坏"));
                            if (输入物品是否有不可破坏) {
                                融合结果.自定义数据.set("不可破坏", true);
                            }

                            const 预览元素 = 融合结果.生成显示元素("融合");
                            const 附魔提示 = document.createElement("div");
                            附魔提示.textContent = `将被附魔: ${附魔种类} (${附魔卷轴实例.品质}级)`;
                            附魔提示.style.color = "cyan";
                            附魔提示.style.fontSize = "0.8em";
                            附魔提示.style.textAlign = "center";
                            预览元素.appendChild(附魔提示);

                            输出格子.appendChild(预览元素);
                            输出格子.onclick = () =>
                                setTimeout(() => 执行融合(), 0);
                            return;
                        }
                    }
                }

                const firstSlotItem = 玩家背包.get(融合区物品[0]);
                if (firstSlotItem && firstSlotItem instanceof 药水类) {
                    let onlyPotionAndGold = true;
                    let totalGold = 0;
                    if (融合槽有效条目.length > 1) {
                        for (let i = 1; i < 4; i++) {
                            const itemSymbol = 融合区物品[i];
                            if (itemSymbol) {
                                const item = 玩家背包.get(itemSymbol);
                                if (
                                    item instanceof 金币 &&
                                    fusionGoldQuantities[i] > 0
                                ) {
                                    totalGold += fusionGoldQuantities[i];
                                } else {
                                    onlyPotionAndGold = false;
                                    break;
                                }
                            }
                        }
                    } else {
                        onlyPotionAndGold = false;
                    }

                    if (onlyPotionAndGold && totalGold > 0) {
                        const 新药水 = 克隆物品(firstSlotItem);
                        const 原基础持续 =
                            新药水.自定义数据.get("基础持续时间") || 3;
                        const 延长回合 = totalGold;
                        新药水.自定义数据.set(
                            "基础持续时间",
                            原基础持续 + 延长回合
                        );
                        新药水.效果描述 = (新药水.效果描述 || "").replace(
                            /持续\s*\d+\s*回合/g,
                            `持续 ${新药水.持续时间} 回合`
                        );
                        新药水.唯一标识 = Symbol(
                            "FusionPotionExtendPreview_" + Date.now()
                        );

                        融合结果 = 新药水;
                        当前匹配的融合配方 = "药水金币延长";

                        const 预览元素 = 融合结果.生成显示元素("融合");
                        预览元素.style.cursor = "pointer";
                        输出格子.appendChild(预览元素);
                        输出格子.onclick = () =>
                            setTimeout(() => 执行融合(), 0);
                        return;
                    }
                }
                const combinedRecipeList = [
                    ...已发现的程序生成配方,
                    ...融合配方列表,
                ];
                for (const 配方 of combinedRecipeList) {
                    const sortedRecipeInputs = [...配方.输入].sort();

                    if (
                        融合槽物品名称列表_sorted.length ===
                            sortedRecipeInputs.length &&
                        融合槽物品名称列表_sorted.every(
                            (name, index) => name === sortedRecipeInputs[index]
                        )
                    ) {
                        const 输出类构造器 = window[配方.输出类];
                        if (输出类构造器) {
                            const 输出配置 = 配方.输出配置
                                ? { ...配方.输出配置 }
                                : {};
                            
                            const 输入物品是否有不可破坏 = 融合槽物品实例列表.some(item => item.自定义数据?.get("不可破坏"));
                            
                            融合结果 = new 输出类构造器(输出配置);
                            融合结果.堆叠数量 = 配方.输出数量 || 1;
                            融合结果.唯一标识 = Symbol(
                                "FusionRecipePreview_" + Date.now()
                            );
                            if (输入物品是否有不可破坏) {
                                融合结果.自定义数据.set("不可破坏", true);
                            }
                            当前匹配的融合配方 = 配方;

                            const 预览元素 = 融合结果.生成显示元素("融合");
                            预览元素.style.cursor = "pointer";
                            输出格子.appendChild(预览元素);
                            输出格子.onclick = () =>
                                setTimeout(() => 执行融合(), 0);
                            return;
                        }
                    }
                }

                if (融合槽有效条目.length === 2) {
                    const item1 = 融合槽有效条目[0].item;
                    const item2 = 融合槽有效条目[1].item;

                    if (
                        item1 &&
                        item2 &&
                        item1.名称 === item2.名称 &&
                        (item1 instanceof 武器类 ||
                            item1 instanceof 防御装备类) &&
                        (item2 instanceof 武器类 ||
                            item2 instanceof 防御装备类) &&
                        item1.constructor.name === item2.constructor.name
                    ) {
                        融合结果 = 克隆物品(item1);
                        融合结果.唯一标识 = Symbol(
                            "FusionEquipPreview_" + Date.now()
                        );
                        当前匹配的融合配方 = "装备融合";

                        const mergedBuffs = 合并Buff列表(
                            item1.自定义数据.get("fusedBuffs"),
                            item2.自定义数据.get("fusedBuffs")
                        );
                        if (mergedBuffs.length > 0)
                            融合结果.自定义数据.set("fusedBuffs", mergedBuffs);
                        else 融合结果.自定义数据.delete("fusedBuffs");

                        const mergedEnchantments = 合并附魔列表(
                            item1.自定义数据.get("附魔"),
                            item2.自定义数据.get("附魔")
                        );
                        融合结果.自定义数据.set("附魔", mergedEnchantments);

                        const item1Dur = item1.自定义数据.get("耐久") || 0;
                        const item1MaxDur =
                            item1.自定义数据.get("原耐久") || item1Dur;
                        const item2Dur = item2.自定义数据.get("耐久") || 0;
                        const item2MaxDur =
                            item2.自定义数据.get("原耐久") || item2Dur;
                        const newMaxDur =
                            item1MaxDur + Math.floor(item2MaxDur * 0.3);
                        const newCurrDur = Math.min(
                            newMaxDur,
                            item1Dur + Math.floor(item2Dur * 0.7)
                        );
                        融合结果.自定义数据.set("耐久", newCurrDur);
                        融合结果.自定义数据.set("原耐久", newMaxDur);

                        融合结果.强化 = item1.强化 || item2.强化;
                        if (item1.自定义数据.get("不可破坏") || item2.自定义数据.get("不可破坏")) {
                            融合结果.自定义数据.set("不可破坏", true);
                        } else {
                            融合结果.自定义数据.delete("不可破坏");
                        }
                        融合结果.品质 = Math.max(item1.品质, item2.品质);
                        融合结果.颜色索引 = 融合结果.品质 - 1;

                        const 预览元素 = 融合结果.生成显示元素("融合");
                        预览元素.style.cursor = "pointer";
                        输出格子.appendChild(预览元素);
                        输出格子.onclick = () =>
                            setTimeout(() => 执行融合(), 0);
                        return;
                    }
                }
                

                const 武器槽标识 = 融合区物品[0];
                if (武器槽标识) {
                    const 武器实例 = 玩家背包.get(武器槽标识);
                    if (武器实例 && 是否为有效融合武器(武器实例)) {
                        const 材料实例列表 = [];
                        let 金币总量 = 0;

                        for (let i = 1; i < 4; i++) {
                            const 标识 = 融合区物品[i];
                            if (标识) {
                                const 物品 = 玩家背包.get(标识);
                                if (物品) {
                                    if (物品 instanceof 金币) {
                                        金币总量 += fusionGoldQuantities[i];
                                    } else if (是否为有效融合材料(物品)) {
                                        材料实例列表.push(物品);
                                    }
                                }
                            }
                        }

                        if (材料实例列表.length > 0 || 金币总量 > 0) {
                            const buffs = 计算融合Buff(
                                武器实例,
                                材料实例列表,
                                金币总量
                            );

                            融合结果 = 克隆物品(武器实例);
                            融合结果.唯一标识 = Symbol(
                                "FusionBuffPreview_" + Date.now()
                            );
                            当前匹配的融合配方 = "词条融合";

                            const 输入物品是否有不可破坏 = [武器实例, ...材料实例列表].some(item => item.自定义数据?.get("不可破坏"));
                            if (输入物品是否有不可破坏) {
                                融合结果.自定义数据.set("不可破坏", true);
                            }

                            if (buffs.length > 0) {
                                融合结果.自定义数据.set("fusedBuffs", buffs);
                            } else {
                                融合结果.自定义数据.delete("fusedBuffs");
                            }

                            const 预览元素 = 融合结果.生成显示元素("融合");
                            预览元素.style.cursor = "pointer";
                            输出格子.appendChild(预览元素);
                            输出格子.onclick = () =>
                                setTimeout(() => 执行融合(), 0);
                            return;
                        }
                    }
                }
            }

            function 从融合区移除(格子索引) {
                const 物品标识 = 融合区物品[格子索引];
                if (物品标识 === null) return;
                document.getElementById("浮动提示框").style.display = "none";

                let 物品实例 = 玩家背包.get(物品标识);

                if (
                    物品实例 instanceof 金币 &&
                    fusionGoldQuantities[格子索引] > 0
                ) {
                    fusionGoldQuantities[格子索引]--;
                    const collectedSuccessfully = 尝试收集物品(
                        new 金币({ 数量: 1 }),
                        true
                    );

                    if (
                        !collectedSuccessfully &&
                        fusionGoldQuantities[格子索引] > 0
                    ) {
                        fusionGoldQuantities[格子索引]++;

                        // 尝试收集物品 内部会在直接收集失败时显示通知
                    }
                    玩家背包.get(物品标识).是否隐藏 = false;
                    if (fusionGoldQuantities[格子索引] === 0) {
                        if (玩家背包.has(物品标识)) {
                        }
                        融合区物品[格子索引] = null;
                    }
                } else if (!(物品实例 instanceof 金币)) {
                    if (物品实例.是否隐藏) {
                        物品实例.是否隐藏 = false;
                    } else {
                        // 对于非金币，如果不是隐藏的代表物，意味着它是从一个可见堆叠中取出的
                        // 理论上，添加到融合区时，如果原堆叠数量>1，原堆叠数量已减1
                        // 如果原堆叠数量为1，则它被标记为隐藏。
                        // 所以这里不需要 物品实例.堆叠数量++; 因为返回的是单个单位
                    }
                    物品实例.isActive = false;
                    融合区物品[格子索引] = null;
                    fusionGoldQuantities[格子索引] = 0;
                } else if (
                    物品实例 instanceof 金币 &&
                    fusionGoldQuantities[格子索引] <= 0
                ) {
                    // 以防万一的状态同步问题，确保清理
                    if (玩家背包.has(物品标识)) {
                        玩家背包.delete(物品标识);
                    }
                    融合区物品[格子索引] = null;
                    fusionGoldQuantities[格子索引] = 0;
                }

                检查融合配方();
                更新融合窗口();
                更新背包显示();
                更新装备显示();
            }

            function 执行融合() {
                if (!融合结果) {
                    显示通知("没有有效的融合结果！", "错误");
                    return;
                }

                const consumedItemSymbolsInFusionSlots = new Set();
                const originalFusionSlotItems = [...融合区物品];
                const originalFusionGoldQuantities = [...fusionGoldQuantities];

                if (当前匹配的融合配方 === "卷轴附魔融合") {
                    const 附魔卷轴实例 = 玩家背包.get(
                        originalFusionSlotItems.find(
                            (id) =>
                                id &&
                                玩家背包.get(id) instanceof 附魔卷轴 &&
                                玩家背包.get(id).自定义数据.get("已解锁")
                        )
                    );
                    const 目标物品原件 = 玩家背包.get(
                        originalFusionSlotItems.find(
                            (id) =>
                                id &&
                                !(玩家背包.get(id) instanceof 附魔卷轴) &&
                                (玩家背包.get(id) instanceof 武器类 ||
                                    玩家背包.get(id) instanceof 防御装备类)
                        )
                    );

                    if (!附魔卷轴实例 || !目标物品原件) {
                        显示通知("融合错误：找不到卷轴或目标物品！", "错误");
                        融合结果 = null;
                        当前匹配的融合配方 = null;
                        更新融合窗口();
                        return;
                    }

                    const 输出物品 = 克隆物品(目标物品原件); // 创建一个全新的克隆作为输出
                    const 附魔成功 = 附魔卷轴实例.附魔效果.call(
                        附魔卷轴实例,
                        输出物品
                    ); // 对克隆体附魔，会消耗原卷轴能量

                    if (附魔成功) {
                        融合结果 = 输出物品; // 设定新的、附魔后的克隆体为融合结果

                        // 标记原卷轴和原目标物品为消耗品
                        consumedItemSymbolsInFusionSlots.add(
                            附魔卷轴实例.唯一标识
                        );
                        consumedItemSymbolsInFusionSlots.add(
                            目标物品原件.唯一标识
                        );
                        输出物品.是否隐藏 = false;

                        尝试收集物品(输出物品, true);

                        附魔卷轴实例.可用次数 =
                            (附魔卷轴实例.可用次数 === undefined
                                ? 1
                                : 附魔卷轴实例.可用次数) - 1;
                        if (附魔卷轴实例.可用次数 > 0) {
                            consumedItemSymbolsInFusionSlots.delete(
                                附魔卷轴实例.唯一标识
                            ); // 如果还有次数，则不完全消耗
                            if (附魔卷轴实例.是否隐藏)
                                附魔卷轴实例.是否隐藏 = false; // 如果之前是隐藏的（堆叠中的最后一个），则设为可见
                        }
                        // 如果可用次数 <= 0，它会因为在consumedItemSymbolsInFusionSlots中而被后续逻辑清理
                        显示通知(`${输出物品.获取名称()} 附魔成功！`, "成功");
                    } else {
                        显示通知("附魔失败！(能量不足或不兼容)", "错误");
                        融合结果 = null;
                        当前匹配的融合配方 = null;
                        更新融合窗口();
                        return;
                    }
                } else if (当前匹配的融合配方 === "药水金币延长") {
                    const 药水槽索引 = originalFusionSlotItems.findIndex(
                        (id) => id && 玩家背包.get(id) instanceof 药水类
                    );
                    if (药水槽索引 === -1) {
                        显示通知("融合错误：找不到药水！", "错误");
                        return;
                    }

                    const 药水实例 = 玩家背包.get(
                        originalFusionSlotItems[药水槽索引]
                    );
                    let 总消耗金币数量 = 0;
                    const 金币槽位信息 = [];

                    for (let i = 0; i < 4; i++) {
                        if (i === 药水槽索引) continue;
                        const id = originalFusionSlotItems[i];
                        if (
                            id &&
                            玩家背包.get(id) instanceof 金币 &&
                            originalFusionGoldQuantities[i] > 0
                        ) {
                            总消耗金币数量 += originalFusionGoldQuantities[i];
                            金币槽位信息.push({
                                index: i,
                                quantity: originalFusionGoldQuantities[i],
                                symbol: id,
                            });
                        }
                    }

                    if (总消耗金币数量 === 0) {
                        显示通知("融合错误：需要金币！", "错误");
                        return;
                    }

                    const potionExtendEnergyCost = 2 * 总消耗金币数量;
                    if (!扣除能量(potionExtendEnergyCost)) {
                        显示通知(
                            `能量不足！需要 ${potionExtendEnergyCost} 点能量。`,
                            "错误"
                        );
                        return;
                    }

                    consumedItemSymbolsInFusionSlots.add(
                        originalFusionSlotItems[药水槽索引]
                    );

                    for (const 金币信息 of 金币槽位信息) {
                        fusionGoldQuantities[金币信息.index] = 0;
                        consumedItemSymbolsInFusionSlots.add(金币信息.symbol);
                    }

                    const 延长后的药水 = 克隆物品(融合结果);
                    延长后的药水.唯一标识 = Symbol(
                        "ExtendedPotion_" + Date.now()
                    );
                    延长后的药水.是否隐藏 = false;

                    if (尝试收集物品(延长后的药水, true)) {
                        显示通知(
                            `${延长后的药水.名称} 持续时间已延长！`,
                            "成功"
                        );
                    } else {
                        显示通知("融合失败：无法将产物放入背包！", "错误");
                        const 能量条 = document.querySelector(".power-bar");
                        const 当前能量 = parseFloat(能量条.style.width) || 0;
                        if (能量条)
                            能量条.style.width = `${Math.min(
                                100,
                                当前能量 + potionExtendEnergyCost
                            )}%`;
                        console.error(
                            "药水金币延长融合：收集产物失败，未实现精确回滚。"
                        );
                        return;
                    }
                } else if (
                    当前匹配的融合配方 &&
                    typeof 当前匹配的融合配方 === "object" &&
                    当前匹配的融合配方 !== "装备融合" &&
                    当前匹配的融合配方 !== "词条融合"
                ) {
                    const 配方 = 当前匹配的融合配方;
                    const recipeEnergyCost = 5 * 配方.输入.length;
                    if (!扣除能量(recipeEnergyCost)) {
                        显示通知(
                            `能量不足！需要 ${recipeEnergyCost} 点能量。`,
                            "错误"
                        );
                        return;
                    }

                    const 虚拟输出物品 = 克隆物品(融合结果);
                    虚拟输出物品.堆叠数量 = 配方.输出数量 || 1;
                    虚拟输出物品.是否隐藏 = false;
                    let 能够收集输出 = false;

                    let 预计背包占用 = [...玩家背包.values()].filter(
                        (item) => !item.是否隐藏
                    ).length;
                    const tempConsumedSymbols = new Set();
                    const tempFusionGoldQuantitiesForCheck = [
                        ...originalFusionGoldQuantities,
                    ];

                    配方.输入.forEach((requiredItemName) => {
                        let foundInSlot = false;
                        for (let i = 0; i < 4; i++) {
                            const itemSymbolInSlot = originalFusionSlotItems[i];
                            if (
                                itemSymbolInSlot &&
                                !tempConsumedSymbols.has(itemSymbolInSlot)
                            ) {
                                const itemInSlot =
                                    玩家背包.get(itemSymbolInSlot);
                                if (
                                    itemInSlot &&
                                    itemInSlot.名称 === requiredItemName
                                ) {
                                    if (itemInSlot instanceof 金币) {
                                        if (
                                            tempFusionGoldQuantitiesForCheck[
                                                i
                                            ] > 0
                                        ) {
                                            tempFusionGoldQuantitiesForCheck[
                                                i
                                            ]--;
                                            if (
                                                tempFusionGoldQuantitiesForCheck[
                                                    i
                                                ] === 0
                                            ) {
                                                tempConsumedSymbols.add(
                                                    itemSymbolInSlot
                                                );
                                            }
                                            foundInSlot = true;
                                            break;
                                        }
                                    } else {
                                        tempConsumedSymbols.add(
                                            itemSymbolInSlot
                                        );
                                        foundInSlot = true;
                                        break;
                                    }
                                }
                            }
                        }
                    });

                    let slotsFreed = 0;
                    tempConsumedSymbols.forEach((symbol) => {
                        const item = 玩家背包.get(symbol);
                        if (
                            item &&
                            (item.是否隐藏 ||
                                item.堆叠数量 === 1 ||
                                (item instanceof 金币 &&
                                    tempFusionGoldQuantitiesForCheck[
                                        originalFusionSlotItems.indexOf(symbol)
                                    ] === 0))
                        ) {
                            slotsFreed++;
                        }
                    });
                    预计背包占用 -= slotsFreed;

                    const 现有可堆叠 = [...玩家背包.values()].find(
                        (item) => !item.是否隐藏 && item.可堆叠于(虚拟输出物品)
                    );
                    if (现有可堆叠) {
                        if (
                            现有可堆叠.堆叠数量 + 虚拟输出物品.堆叠数量 <=
                            现有可堆叠.最大堆叠数量
                        ) {
                            能够收集输出 = true;
                        } else {
                            const 剩余数量 =
                                现有可堆叠.堆叠数量 +
                                虚拟输出物品.堆叠数量 -
                                现有可堆叠.最大堆叠数量;
                            const 需要新槽位 = Math.ceil(
                                剩余数量 / 虚拟输出物品.最大堆叠数量
                            );
                            if (预计背包占用 + 需要新槽位 <= 最大背包容量) {
                                能够收集输出 = true;
                            }
                        }
                    } else {
                        const 需要新槽位 = Math.ceil(
                            虚拟输出物品.堆叠数量 / 虚拟输出物品.最大堆叠数量
                        );
                        if (预计背包占用 + 需要新槽位 <= 最大背包容量) {
                            能够收集输出 = true;
                        }
                    }

                    if (!能够收集输出) {
                        显示通知("背包空间不足，无法容纳融合产物！", "错误");
                        const 能量条 = document.querySelector(".power-bar");
                        const 当前能量 = parseFloat(能量条.style.width) || 0;
                        if (能量条)
                            能量条.style.width = `${Math.min(
                                100,
                                当前能量 + recipeEnergyCost
                            )}%`;
                        触发HUD显示();
                        return;
                    }

                    配方.输入.forEach((requiredItemName) => {
                        let consumedThisRecipeItem = false;
                        for (let i = 0; i < 4; i++) {
                            const itemSymbolInSlot = 融合区物品[i];
                            if (
                                itemSymbolInSlot &&
                                !consumedItemSymbolsInFusionSlots.has(
                                    itemSymbolInSlot
                                )
                            ) {
                                const itemInSlotInstance =
                                    玩家背包.get(itemSymbolInSlot);
                                if (
                                    itemInSlotInstance &&
                                    itemInSlotInstance.名称 === requiredItemName
                                ) {
                                    if (itemInSlotInstance instanceof 金币) {
                                        if (fusionGoldQuantities[i] > 0) {
                                            fusionGoldQuantities[i]--;
                                            if (fusionGoldQuantities[i] === 0) {
                                                consumedItemSymbolsInFusionSlots.add(
                                                    itemSymbolInSlot
                                                );
                                            }
                                            consumedThisRecipeItem = true;
                                            break;
                                        }
                                    } else {
                                        consumedItemSymbolsInFusionSlots.add(
                                            itemSymbolInSlot
                                        );
                                        consumedThisRecipeItem = true;
                                        break;
                                    }
                                }
                            }
                        }
                    });

                    const 实际输出物品 = 融合结果

                    if (尝试收集物品(实际输出物品, true)) {
                        显示通知(
                            `成功融合出 ${实际输出物品.获取名称()}！`,
                            "成功"
                        );
                    } else {
                        显示通知(
                            "融合失败：无法将产物放入背包（未知错误）！",
                            "错误"
                        );
                    }
                } else                 if (当前匹配的融合配方 === "磨刀石打磨") {
                    const 磨刀石实例 = 玩家背包.get(originalFusionSlotItems[0]);
                    const 武器实例 = 玩家背包.get(originalFusionSlotItems[1]);
                    const energyCost = 15;

                    if (!扣除能量(energyCost)) {
                        显示通知(`能量不足！需要 ${energyCost} 点能量。`, "错误");
                        return;
                    }

                    const buffs = 武器实例.自定义数据.get("fusedBuffs") || [];
                    let attackBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石攻击加成);
                    let cooldownBuff = buffs.find(b => b.type === 融合Buff类型.磨刀石冷却缩减);

                    const buffUses = 20 + Math.floor(Math.random() * 11);

                    if (attackBuff) {
                        attackBuff.value += 1;
                        attackBuff.usesLeft = (attackBuff.usesLeft || 0) + buffUses;
                    } else {
                        buffs.push({ type: 融合Buff类型.磨刀石攻击加成, value: 1, usesLeft: buffUses });
                    }

                    if (cooldownBuff) {
                        cooldownBuff.value += 1;
                        cooldownBuff.usesLeft = (cooldownBuff.usesLeft || 0) + buffUses;
                    } else {
                        buffs.push({ type: 融合Buff类型.磨刀石冷却缩减, value: 1, usesLeft: buffUses });
                    }
                    
                    武器实例.自定义数据.set("fusedBuffs", buffs);
                    
                    磨刀石实例.自定义数据.set("耐久", 磨刀石实例.自定义数据.get("耐久") - 1);

                    显示通知(`${武器实例.获取名称()} 被成功打磨！`, "成功");
                    
                    if (磨刀石实例.自定义数据.get("耐久") <= 0) {
                        consumedItemSymbolsInFusionSlots.add(磨刀石实例.唯一标识);
                    } else {
                         const stoneInSlot = originalFusionSlotItems[0];
                        if (stoneInSlot) {
                            融合区物品[0] = null;
                            const stoneInstance = 玩家背包.get(stoneInSlot);
                            if(stoneInstance) stoneInstance.是否隐藏 = false;
                        }
                    }

                    const weaponInSlot = originalFusionSlotItems[1];
                    if (weaponInSlot) {
                        融合区物品[1] = null;
                        const weaponInstance = 玩家背包.get(weaponInSlot);
                        if(weaponInstance) weaponInstance.是否隐藏 = false;
                    }

                    } else if (当前匹配的融合配方 === "装备融合") {
                    const item1_id = originalFusionSlotItems[0];
                    const item2_id = originalFusionSlotItems[1];
                    const item1_original_in_backpack = 玩家背包.get(item1_id);
                    const item2_original_in_backpack = 玩家背包.get(item2_id);

                    if (
                        !item1_original_in_backpack ||
                        !item2_original_in_backpack
                    ) {
                        显示通知("融合错误：物品丢失！", "错误");
                        return;
                    }
                    if (
                        !(
                            item1_original_in_backpack instanceof 武器类 ||
                            item1_original_in_backpack instanceof 防御装备类
                        ) ||
                        !(
                            item2_original_in_backpack instanceof 武器类 ||
                            item2_original_in_backpack instanceof 防御装备类
                        )
                    ) {
                        显示通知(
                            "融合错误：只有武器或装备才能进行此类融合！",
                            "错误"
                        );
                        return;
                    }
                    if (
                        item1_original_in_backpack.constructor.name !==
                        item2_original_in_backpack.constructor.name
                    ) {
                        显示通知("融合错误：装备类型不一致！", "错误");
                        return;
                    }

                    const equipFusionEnergyCost =
                        20 +
                        (item1_original_in_backpack.品质 +
                            item2_original_in_backpack.品质) *
                            5 +
                        ((item1_original_in_backpack.自定义数据.get(
                            "fusedBuffs"
                        )?.length || 0) +
                            (item2_original_in_backpack.自定义数据.get(
                                "fusedBuffs"
                            )?.length || 0)) *
                            2 +
                        ((item1_original_in_backpack.自定义数据.get("附魔")
                            ?.length || 0) +
                            (item2_original_in_backpack.自定义数据.get("附魔")
                                ?.length || 0)) *
                            3;
                    if (!扣除能量(equipFusionEnergyCost)) {
                        显示通知(
                            `能量不足！需要 ${equipFusionEnergyCost} 点能量。`,
                            "错误"
                        );
                        return;
                    }

                    const mergedItem = 克隆物品(融合结果); // 融合结果是在检查时创建的克隆
                    mergedItem.唯一标识 = Symbol("MergedEquip_" + Date.now()); // 给新物品一个新的唯一ID
                    mergedItem.是否隐藏 = false;

                    consumedItemSymbolsInFusionSlots.add(item1_id);
                    consumedItemSymbolsInFusionSlots.add(item2_id);

                    if (尝试收集物品(mergedItem, true)) {
                        显示通知(`${mergedItem.获取名称()} 融合成功！`, "成功");
                    } else {
                        显示通知("融合失败：无法将产物放入背包！", "错误");
                        // 理论上应该回滚能量消耗等，但目前简化处理
                    }
                } else if (当前匹配的融合配方 === "词条融合") {
                    const 武器槽标识 = originalFusionSlotItems[0];
                    const 武器原件 = 玩家背包.get(武器槽标识);

                    if (!武器原件 || !是否为有效融合武器(武器原件)) {
                        显示通知("融合错误：原始武器无效！", "错误");
                        return;
                    }

                    const 待消耗材料实例 = [];
                    let 总计消耗金币数量 = 0;
                    let energyCostBuff = 10;

                    for (let i = 1; i <= 3; i++) {
                        const 标识 = originalFusionSlotItems[i];
                        if (标识) {
                            const 物品 = 玩家背包.get(标识);
                            if (
                                物品 instanceof 金币 &&
                                originalFusionGoldQuantities[i] > 0
                            ) {
                                总计消耗金币数量 +=
                                    originalFusionGoldQuantities[i];
                            } else if (
                                物品 &&
                                !(物品 instanceof 金币) &&
                                是否为有效融合材料(物品)
                            ) {
                                待消耗材料实例.push(物品);
                            }
                        }
                    }
                    energyCostBuff +=
                        待消耗材料实例.length * 3 + 总计消耗金币数量 * 0.5;

                    if (!扣除能量(energyCostBuff)) {
                        显示通知(
                            `能量不足！需要 ${energyCostBuff} 点能量。`,
                            "错误"
                        );
                        return;
                    }

                    待消耗材料实例.forEach((材料) => {
                        consumedItemSymbolsInFusionSlots.add(材料.唯一标识);
                    });

                    if (总计消耗金币数量 > 0) {
                        for (let i = 1; i <= 3; i++) {
                            const 标识 = originalFusionSlotItems[i];
                            if (
                                标识 &&
                                玩家背包.get(标识) instanceof 金币 &&
                                originalFusionGoldQuantities[i] > 0
                            ) {
                                fusionGoldQuantities[i] = 0;
                                consumedItemSymbolsInFusionSlots.add(标识);
                            }
                        }
                    }

                    const 应用的Buffs = 融合结果.自定义数据.get("fusedBuffs");
                    if (应用的Buffs && 应用的Buffs.length > 0) {
                        const 旧Buffs =
                            武器原件.自定义数据.get("fusedBuffs") || [];
                        const 合并后的Buffs = 合并Buff列表(
                            旧Buffs,
                            应用的Buffs
                        );
                        武器原件.自定义数据.set("fusedBuffs", 合并后的Buffs);

                        let 耐久加成值 = 0;
                        let 耐久倍率 = 0;
                        合并后的Buffs.forEach((buff) => {
                            if (buff.type === 融合Buff类型.耐久加成)
                                耐久加成值 += buff.value;
                            if (buff.type === 融合Buff类型.耐久倍率)
                                耐久倍率 += buff.value;
                        });
                        if (耐久加成值 > 0 || 耐久倍率 !== 0) {
                            const 物品类原型 = Object.getPrototypeOf(
                                武器原件.constructor
                            ).prototype;
                            const 默认原耐久 =
                                武器原件.自定义数据.get("原耐久") || 30;
                            let 新最大耐久 = Math.round(
                                默认原耐久 + 耐久加成值
                            );
                            if (耐久倍率 !== 0)
                                新最大耐久 = Math.round(
                                    新最大耐久 * (1 + 耐久倍率)
                                );
                            武器原件.自定义数据.set("原耐久", 新最大耐久);
                            const 当前耐久 =
                                武器原件.自定义数据.get("耐久") || 0;
                            武器原件.自定义数据.set(
                                "耐久",
                                Math.min(
                                    新最大耐久,
                                    当前耐久 +
                                        Math.floor(
                                            (新最大耐久 - 当前耐久) * 0.2
                                        )
                                )
                            );
                        }
                        显示通知(`${武器原件.获取名称()} 强化成功！`, "成功");
                    } else {
                        显示通知(
                            `${武器原件.获取名称()} 没有获得强化效果。`,
                            "信息"
                        );
                    }

                    if (武器原件.是否隐藏) {
                        武器原件.是否隐藏 = false;
                    }
                }

                for (let i = 0; i < 4; i++) {
                    const 物品标识 = originalFusionSlotItems[i];
                    if (物品标识) {
                        if (consumedItemSymbolsInFusionSlots.has(物品标识)) {
                            const itemInBackpack = 玩家背包.get(物品标识);
                            if (itemInBackpack) {
                                if (itemInBackpack instanceof 金币) {
                                    if (
                                        originalFusionGoldQuantities[i] > 0 &&
                                        fusionGoldQuantities[i] === 0
                                    ) {
                                        if (itemInBackpack.堆叠数量 === 0) {
                                            // 代表物自身已空
                                            处理销毁物品(物品标识, true);
                                        }
                                    }
                                } else {
                                    if (itemInBackpack.堆叠数量 === 1) {
                                        // 非金币，单堆叠被消耗
                                        处理销毁物品(物品标识, true);
                                    } else if (
                                        itemInBackpack.堆叠数量 > 1 &&
                                        !(
                                            当前匹配的融合配方 === "装备融合" &&
                                            itemInBackpack.唯一标识 ===
                                                originalFusionSlotItems[0]
                                        ) &&
                                        !(
                                            当前匹配的融合配方 === "词条融合" &&
                                            itemInBackpack.唯一标识 ===
                                                originalFusionSlotItems[0]
                                        )
                                    ) {
                                        // 对于非金币，如果它是一个堆叠的一部分被消耗了，它的数量在配方逻辑中已经减少了
                                        // 这里不需要额外操作，除非它因为数量变为0而需要被删除
                                    }
                                }
                            }
                            融合区物品[i] = null;
                            if (
                                物品标识 &&
                                玩家背包.get(物品标识) instanceof 金币
                            ) {
                                fusionGoldQuantities[i] = 0;
                            }
                        } else if (
                            i === 0 &&
                            当前匹配的融合配方 === "词条融合"
                        ) {
                            // 基底武器不被删除，但从融合槽清空
                            融合区物品[i] = null;
                            const baseItemInstance = 玩家背包.get(物品标识);
                            if (baseItemInstance)
                                baseItemInstance.是否隐藏 = false;
                        }
                    }
                }

                融合结果 = null;
                当前匹配的融合配方 = null;
                更新融合窗口();
                更新背包显示();
                更新装备显示();
            }

            function 更新融合窗口() {
                const 窗口 = document.getElementById("融合窗口");
                if (!窗口) return;

                for (let i = 1; i <= 4; i++) {
                    const 格子 = document.getElementById(`融合区格子${i}`);
                    格子.innerHTML = "";
                    格子.onclick = () =>
                        setTimeout(() => {
                            从融合区移除(i - 1);
                        }, 0);
                }

                融合区物品.forEach((物品标识, index) => {
                    if (物品标识 !== null) {
                        const 物品实例 = 玩家背包.get(物品标识);
                        if (物品实例) {
                            const 格子 = document.getElementById(
                                `融合区格子${index + 1}`
                            );
                            const 物品元素 = 物品实例.生成显示元素("融合");
                            物品元素.style.cursor = "pointer";

                            if (
                                物品实例 instanceof 金币 &&
                                fusionGoldQuantities[index] > 0
                            ) {
                                let 堆叠元素 =
                                    物品元素.querySelector(".物品堆叠");
                                if (!堆叠元素) {
                                    堆叠元素 = document.createElement("div");
                                    堆叠元素.className = "物品堆叠";
                                    物品元素.appendChild(堆叠元素);
                                }
                                堆叠元素.textContent = `x${fusionGoldQuantities[index]}`;
                            } else if (
                                !(物品实例 instanceof 金币) &&
                                物品实例.堆叠数量 > 1
                            ) {
                                // Non-gold items show their own stack if > 1, already handled by 生成显示元素
                            } else if (物品实例.堆叠数量 <= 1) {
                                const 堆叠元素 =
                                    物品元素.querySelector(".物品堆叠");
                                if (堆叠元素) 堆叠元素.remove();
                            }

                            格子.appendChild(物品元素);
                        } else {
                            console.warn(
                                `更新融合窗口：找不到标识为 ${物品标识.toString()} 的物品实例`
                            );
                            融合区物品[index] = null;
                            fusionGoldQuantities[index] = 0;
                        }
                    }
                });

                const 输出格子 = document.getElementById("融合输出格子");
                输出格子.innerHTML = "";
                输出格子.onclick = null;
                if (融合结果) {
                    const 结果元素 = 融合结果.生成显示元素("融合");
                    结果元素.style.cursor = "pointer";
                    输出格子.appendChild(结果元素);
                    输出格子.onclick = () =>
                        setTimeout(() => {
                            执行融合();
                        }, 0);
                }
            }

            function 清空融合区() {
                for (let i = 0; i < 融合区物品.length; i++) {
                    // Need to ensure all gold is returned based on fusionGoldQuantities
                    if (
                        融合区物品[i] !== null &&
                        玩家背包.get(融合区物品[i]) instanceof 金币
                    ) {
                        const goldToReturn = fusionGoldQuantities[i];
                        if (goldToReturn > 0) {
                            尝试收集物品(
                                new 金币({ 数量: goldToReturn }),
                                true
                            );
                        }
                        玩家背包.get(融合区物品[i]).是否隐藏 = false;
                        fusionGoldQuantities[i] = 0;
                        融合区物品[i] = null;
                    } else if (融合区物品[i] !== null) {
                        从融合区移除(i); // Standard removal for non-gold
                    }
                }
                融合结果 = null;
                更新融合窗口();
                更新背包显示(); // This might be redundant if 从融合区移除 already calls it
            }

            let 已发现的程序生成配方 = [];
            let 程序生成配方列表 = [];
            function 生成单个随机融合配方(层数) {
                const MAX_ATTEMPTS = 50;
                for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
                    const numInputs = Math.round(Math.random() * 0.7) + 2; // 2 to 3 inputs
                    const inputs = [];
                    const inputItemNames = [];

                    const 可用物品池 = Object.values(物品池)
                        .flat()
                        .filter(
                            (itemCfg) =>
                                itemCfg.最小层 <= 层数 &&
                                itemCfg.类.name !== "配方卷轴" &&
                                itemCfg.类.name !== "神秘商人" &&
                                itemCfg.类.name !== "探险家" &&
                                itemCfg.类.name !== "物品祭坛" &&
                                itemCfg.类.name !== "耐久祭坛" &&
                                itemCfg.类.name !== "背包扩容祭坛" &&
                                itemCfg.类.name !== "重铸台" &&
                                itemCfg.类.name !== "折跃门" &&
                                itemCfg.类.name !== "寻宝戒指" &&
                                itemCfg.类.name !== "罐子"
                        );

                    if (
                        可用物品池.length < numInputs &&
                        !(
                            numInputs === 2 &&
                            可用物品池.length === 1 &&
                            Math.random() < 0.5
                        )
                    )
                        continue; // Need enough unique items or allow gold/keys

                    let canUseSpecial = true; // Allow one special item (gold/key)
                    for (let i = 0; i < numInputs; i++) {
                        let selectedItemConfig;
                        if (canUseSpecial && Math.random() < 0.3) {
                            // 30% chance to try and add gold/key
                            if (Math.random() < 0.7 && 层数 >= 0) {
                                // Favor gold
                                selectedItemConfig = {
                                    类: 金币,
                                    name: "金币",
                                    isSpecial: true,
                                    品质: 1,
                                };
                            } else if (层数 >= 1) {
                                // Keys appear from floor 1
                                selectedItemConfig = {
                                    类: 钥匙,
                                    name: "钥匙",
                                    isSpecial: true,
                                    品质: 1,
                                };
                            } else if (可用物品池.length > 0) {
                                selectedItemConfig =
                                    可用物品池[
                                        Math.floor(
                                            Math.random() * 可用物品池.length
                                        )
                                    ];
                            } else {
                                continue; // Not enough base items to select from
                            }
                            if (selectedItemConfig.isSpecial)
                                canUseSpecial = false; // Only one special item
                        } else if (可用物品池.length > 0) {
                            selectedItemConfig =
                                可用物品池[
                                    Math.floor(
                                        Math.random() * 可用物品池.length
                                    )
                                ];
                        } else {
                            break; // Not enough items
                        }

                        if (selectedItemConfig) {
                            const tempInstance = new selectedItemConfig.类({});
                            inputs.push(tempInstance.名称); // Store by name for recipe matching
                            inputItemNames.push(tempInstance.名称);
                        }
                    }

                    if (inputs.length !== numInputs) continue; // Failed to get enough inputs

                    // Select output (higher quality or different useful item)
                    const outputPool = 可用物品池.filter(
                        (itemCfg) =>
                            (!inputItemNames.includes(
                                new itemCfg.类({}).名称
                            ) && // Output is not one of the inputs
                                itemCfg.品质 >
                                    Math.min(
                                        ...inputs.map(
                                            (name) =>
                                                (
                                                    可用物品池.find(
                                                        (cfg) =>
                                                            new cfg.类({})
                                                                .名称 === name
                                                    ) || { 品质: 1 }
                                                ).品质
                                        )
                                    )) || // Higher quality
                            (itemCfg.品质 >= 2 && Math.random() < 0.4) // Or a decent quality item
                    );

                    if (outputPool.length === 0) continue;
                    const outputItemConfig =
                        outputPool[
                            Math.floor(Math.random() * outputPool.length)
                        ];
                    const outputInstance = new outputItemConfig.类({});

                    const recipe = {
                        输入: inputs.sort(),
                        输出类: outputItemConfig.类.name,
                        输出类名称: outputInstance.名称,
                        输出数量: 1,
                        输出配置: {
                            品质: outputInstance.品质,
                            强化: true,
                        },
                        说明: `${inputItemNames.join(" + ")} = ${
                            outputInstance.名称
                        }${outputItemConfig.强化 ? "[强]" : ""}`,
                        发现层数: 层数,
                    };

                    // Check if this recipe (by inputs and output name) already exists
                    const existingRecipe = 程序生成配方列表.find(
                        (r) =>
                            r.输出类名称 === recipe.输出类名称 &&
                            r.输入.length === recipe.输入.length &&
                            r.输入.every(
                                (val, index) => val === recipe.输入[index]
                            )
                    );
                    const existingHardcodedRecipe = 融合配方列表.find(
                        (r) =>
                            (r.输出类名称 || r.输出类) === recipe.输出类名称 &&
                            r.输入.length === recipe.输入.length &&
                            r.输入.every(
                                (val, index) => val === recipe.输入[index]
                            )
                    );

                    if (!existingRecipe && !existingHardcodedRecipe) {
                        程序生成配方列表.push(recipe);
                        return recipe;
                    }
                }
                return null; // Failed to generate a unique recipe
            }

            let 已放置配方卷轴 = false;
            function 生成并放置随机配方卷轴(层数) {
                if (层数 === null || 层数 < 0) return;

                if (是否为教程层) return;

                const 已为本层学习配方 = 程序生成配方列表.some(
                    (r) => r.发现层数 === 层数
                );

                if (!已为本层学习配方) {
                    const 新配方 = 生成单个随机融合配方(层数);
                    if (新配方) {
                        console.log(`你领悟了新的融合知识: ${新配方.说明}`);

                        if (!已放置配方卷轴) {
                            const 配方物品 = new 配方卷轴({
                                recipeData: 新配方,
                                层数: 层数,
                            });
                            const 可用房间 = 房间列表.filter(
                                (房间) => 房间.类型 == "房间"
                            );
                            if (可用房间.length > 0) {
                                const 目标房间 =
                                    可用房间[
                                        Math.floor(
                                            Math.random() * 可用房间.length
                                        )
                                    ];
                                if (放置物品到房间(配方物品, 目标房间)) {
                                    已放置配方卷轴 = true;
                                }
                            }
                        }
                    }
                }
            }

            function 合并Buff列表(list1, list2) {
                const merged = new Map();

                function addOrUpdateBuff(buff) {
                    const existing = merged.get(buff.type);
                    if (existing) {
                        if (
                            typeof existing.value === "number" &&
                            typeof buff.value === "number"
                        ) {
                            existing.value += buff.value;
                            let 上限 = 1.0;
                            if (
                                buff.type.includes("MULTIPLIER") ||
                                buff.type.includes("CHANCE") ||
                                buff.type.includes("STEAL") ||
                                buff.type.includes("PERCENT")
                            ) {
                                上限 =
                                    {
                                        [融合Buff类型.攻击倍率]: 0.75,
                                        [融合Buff类型.冷却倍率]: 0.9,
                                        [融合Buff类型.耐久倍率]: 1.5,
                                        [融合Buff类型.防御倍率]: 0.75,
                                        [融合Buff类型.中毒几率]: 0.8,
                                        [融合Buff类型.冰冻几率]: 0.8,
                                        [融合Buff类型.生命偷取]: 0.7,
                                        [融合Buff类型.击退几率]: 0.8,
                                        [融合Buff类型.攻击吸能]: 0.7,
                                        [融合Buff类型.火焰伤害]: 0.8,
                                        [融合Buff类型.闪避几率]: 0.7,
                                        [融合Buff类型.暴击几率]: 0.6,
                                        [融合Buff类型.暴击伤害倍率]: 2.5,
                                    }[buff.type] || 1.0;
                                existing.value = Math.min(existing.value, 上限);
                            } else if (buff.type === 融合Buff类型.冷却缩减) {
                                const 武器基础冷却 = 1; // Assume a base for capping, or pass weapon
                                上限 = 武器基础冷却 > 0 ? 武器基础冷却 - 1 : 0;
                                existing.value = Math.max(
                                    0,
                                    Math.min(existing.value, 上限)
                                );
                            } else if (
                                buff.type === 融合Buff类型.固定伤害减免
                            ) {
                                上限 = 10;
                                existing.value = Math.min(existing.value, 上限);
                            } else if (buff.type === 融合Buff类型.受击回能) {
                                上限 = 30;
                                existing.value = Math.min(existing.value, 上限);
                            } else if (buff.type === 融合Buff类型.范围加成) {
                                上限 = 5;
                                existing.value = Math.min(existing.value, 上限);
                            } else if (buff.type.includes("加成")) {
                                existing.value = Math.min(existing.value, 15);
                            }
                        }
                    } else {
                        merged.set(buff.type, { ...buff });
                    }
                }

                (list1 || []).forEach(addOrUpdateBuff);
                (list2 || []).forEach(addOrUpdateBuff);

                return Array.from(merged.values());
            }

            function 合并附魔列表(list1, list2) {
                const merged = new Map();

                function addOrUpdateEnchantment(enchant) {
                    const existing = merged.get(enchant.种类);
                    if (existing) {
                        if (enchant.等级 > existing.等级) {
                            merged.set(enchant.种类, { ...enchant });
                        }
                    } else {
                        merged.set(enchant.种类, { ...enchant });
                    }
                }
                (list1 || []).forEach(addOrUpdateEnchantment);
                (list2 || []).forEach(addOrUpdateEnchantment);
                return Array.from(merged.values());
            }

            function 哈希字符串(str) {
                let hash = 0;
                if (!str || str.length === 0) return hash;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = (hash << 5) - hash + char;
                    hash |= 0;
                }
                return Math.abs(hash);
            }

            function 种子伪随机数(seed) {
                let t = (seed += 0x6d2b79f5);
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }

            function 是否为有效融合武器(物品) {
                return 物品 instanceof 武器类 || 物品 instanceof 防御装备类;
            }

            function 是否为有效融合材料(物品) {
                return (
                    物品 instanceof 炸弹 ||
                    物品 instanceof 卷轴类 ||
                    物品.类型 === "药水" ||
                    物品 instanceof 钥匙
                );
            }

            function 计算融合Buff(武器, 材料列表, 金币数量) {
                if (!武器) return [];

                const 基础种子字符串 = 武器.唯一标识.toString();
                let 组合种子字符串 = 基础种子字符串;
                const 有效材料 = 材料列表.filter((m) => m != null);
                if (有效材料.length === 0 && 金币数量 === 0) return [];

                有效材料.sort((a, b) =>
                    a.constructor.name.localeCompare(b.constructor.name)
                );
                有效材料.forEach(
                    (mat) => (组合种子字符串 += mat.constructor.name)
                );
                组合种子字符串 += 金币数量;

                const 组合种子 = 哈希字符串(组合种子字符串);
                const 最终Buff列表 = [];
                const 金币增幅系数 =
                    1 + Math.log10(Math.max(1, (金币数量 || 0) / 2 + 1)) * 0.45;

                const 是否武器 = 武器 instanceof 武器类;
                const 是否防具 = 武器 instanceof 防御装备类;

                有效材料.forEach((材料, 索引) => {
                    const 材料种子 = 哈希字符串(
                        组合种子字符串 + 索引 + 最终Buff列表.length
                    );
                    const 随机数生成 = () =>
                        种子伪随机数(材料种子 + 最终Buff列表.length);

                    let buff类型 = null;
                    let buff数值 = 0;
                    const 可能的Buff列表 = [];

                    if (材料 instanceof 炸弹) {
                        if (是否武器)
                            可能的Buff列表.push(
                                融合Buff类型.攻击加成,
                                融合Buff类型.火焰伤害,
                                融合Buff类型.暴击几率,
                                融合Buff类型.击退几率
                            );
                        if (是否防具)
                            可能的Buff列表.push(
                                融合Buff类型.防御加成,
                                融合Buff类型.固定伤害减免,
                                融合Buff类型.火焰伤害
                            );
                        可能的Buff列表.push(融合Buff类型.耐久加成);
                    } else if (材料 instanceof 卷轴类) {
                        if (是否武器)
                            可能的Buff列表.push(
                                融合Buff类型.冷却缩减,
                                融合Buff类型.范围加成,
                                融合Buff类型.攻击倍率,
                                融合Buff类型.攻击吸能,
                                融合Buff类型.暴击伤害倍率
                            );
                        if (是否防具)
                            可能的Buff列表.push(
                                融合Buff类型.防御倍率,
                                融合Buff类型.闪避几率,
                                融合Buff类型.受击回能,
                                融合Buff类型.中毒几率
                            );
                        可能的Buff列表.push(
                            融合Buff类型.冰冻几率,
                            融合Buff类型.耐久倍率
                        );
                    } else if (材料.类型 === "药水") {
                        if (是否武器)
                            可能的Buff列表.push(
                                融合Buff类型.生命偷取,
                                融合Buff类型.中毒几率,
                                融合Buff类型.暴击伤害倍率,
                                融合Buff类型.攻击吸能
                            );
                        if (是否防具)
                            可能的Buff列表.push(
                                融合Buff类型.防御加成,
                                融合Buff类型.受击回能,
                                融合Buff类型.中毒几率
                            );
                        可能的Buff列表.push(融合Buff类型.耐久加成);
                    } else if (材料 instanceof 钥匙) {
                        if (是否武器) {
                            可能的Buff列表.push(融合Buff类型.幸运一击);
                            可能的Buff列表.push(融合Buff类型.暴击几率);
                        }
                        可能的Buff列表.push(融合Buff类型.耐久加成);
                    }

                    if (可能的Buff列表.length === 0) return;

                    buff类型 =
                        可能的Buff列表[
                            Math.floor(随机数生成() * 可能的Buff列表.length)
                        ];

                    switch (buff类型) {
                        case 融合Buff类型.攻击加成:
                            buff数值 = Math.round(
                                (1 + 随机数生成() * 3) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.攻击倍率:
                            buff数值 = Math.min(
                                0.3,
                                (0.03 + 随机数生成() * 0.12) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.冷却缩减:
                            buff数值 = Math.round(
                                (1 + 随机数生成() * 1) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.冷却倍率:
                            buff数值 = Math.min(
                                0.5,
                                (0.05 + 随机数生成() * 0.15) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.耐久加成:
                            if (材料 instanceof 钥匙) {
                                buff数值 = Math.round(
                                    (2 +
                                        随机数生成() * 5 +
                                        (金币数量 > 0 ? 金币数量 / 5 : 0)) *
                                        金币增幅系数 *
                                        0.8
                                );
                            } else {
                                buff数值 = Math.round(
                                    (5 + 随机数生成() * 20) * 金币增幅系数
                                );
                            }
                            break;
                        case 融合Buff类型.耐久倍率:
                            buff数值 = Math.min(
                                0.75,
                                (0.1 + 随机数生成() * 0.25) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.范围加成:
                            buff数值 =
                                是否武器 &&
                                武器.自定义数据.has("攻击范围") &&
                                武器.自定义数据.get("攻击范围") > 1 &&
                                随机数生成() < 0.7
                                    ? Math.round(1 * 金币增幅系数)
                                    : 0;
                            break;
                        case 融合Buff类型.防御加成:
                            buff数值 = Math.round(
                                (1 + 随机数生成() * 2) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.防御倍率:
                            buff数值 = Math.min(
                                0.3,
                                (0.05 + 随机数生成() * 0.1) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.中毒几率:
                        case 融合Buff类型.冰冻几率:
                        case 融合Buff类型.生命偷取:
                        case 融合Buff类型.击退几率:
                        case 融合Buff类型.攻击吸能:
                        case 融合Buff类型.火焰伤害:
                        case 融合Buff类型.闪避几率:
                            buff数值 = Math.min(
                                0.4,
                                (0.05 + 随机数生成() * 0.2) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.暴击几率:
                            if (材料 instanceof 钥匙) {
                                let 基础值 = 0.025;
                                let 品质加成 = 材料.品质 * 0.018;
                                let 金币效应 =
                                    金币数量 > 10
                                        ? 0.025
                                        : 金币数量 > 0
                                        ? 0.012
                                        : 0;
                                buff数值 = Math.min(
                                    0.22,
                                    (基础值 + 品质加成 + 金币效应) *
                                        金币增幅系数
                                );
                            } else {
                                buff数值 = Math.min(
                                    0.25,
                                    (0.03 + 随机数生成() * 0.1) * 金币增幅系数
                                );
                            }
                            break;
                        case 融合Buff类型.暴击伤害倍率:
                            buff数值 = Math.min(
                                1.0,
                                (0.1 + 随机数生成() * 0.4) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.固定伤害减免:
                            buff数值 = Math.round(
                                (1 + 随机数生成() * 1) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.受击回能:
                            buff数值 = Math.round(
                                (3 + 随机数生成() * 7) * 金币增幅系数
                            );
                            break;
                        case 融合Buff类型.幸运一击:
                            if (材料 instanceof 钥匙) {
                                let 基础值 = 0.035;
                                let 品质加成 = 材料.品质 * 0.022;
                                let 金币效应 =
                                    金币数量 > 10
                                        ? 0.03
                                        : 金币数量 > 0
                                        ? 0.018
                                        : 0;
                                buff数值 = Math.min(
                                    0.28,
                                    (基础值 + 品质加成 + 金币效应) *
                                        金币增幅系数
                                );
                            } else {
                                buff数值 = Math.min(
                                    0.25,
                                    (0.02 +
                                        材料.品质 * 0.015 +
                                        (武器.品质 - 1) * 0.01) *
                                        金币增幅系数
                                );
                            }
                            break;
                        default:
                            buff数值 = 0;
                    }

                    if (
                        buff数值 !== null &&
                        buff数值 !== undefined &&
                        !isNaN(buff数值) &&
                        Math.abs(buff数值) > 0.001
                    ) {
                        const 已存在Buff索引 = 最终Buff列表.findIndex(
                            (b) => b.type === buff类型
                        );
                        if (已存在Buff索引 > -1) {
                            if (
                                typeof 最终Buff列表[已存在Buff索引].value ===
                                    "number" &&
                                typeof buff数值 === "number"
                            ) {
                                最终Buff列表[已存在Buff索引].value += buff数值;
                                let 上限 = 1.0;
                                if (
                                    buff类型.includes("MULTIPLIER") ||
                                    buff类型.includes("CHANCE") ||
                                    buff类型.includes("STEAL") ||
                                    buff类型.includes("PERCENT")
                                ) {
                                    上限 =
                                        {
                                            [融合Buff类型.攻击倍率]: 0.5,
                                            [融合Buff类型.冷却倍率]: 0.75,
                                            [融合Buff类型.耐久倍率]: 1.0,
                                            [融合Buff类型.防御倍率]: 0.5,
                                            [融合Buff类型.中毒几率]: 0.6,
                                            [融合Buff类型.冰冻几率]: 0.6,
                                            [融合Buff类型.生命偷取]: 0.5,
                                            [融合Buff类型.击退几率]: 0.6,
                                            [融合Buff类型.攻击吸能]: 0.5,
                                            [融合Buff类型.火焰伤害]: 0.6,
                                            [融合Buff类型.闪避几率]: 0.5,
                                            [融合Buff类型.暴击几率]: 0.4,
                                            [融合Buff类型.暴击伤害倍率]: 1.5,
                                            [融合Buff类型.幸运一击]: 0.3,
                                        }[buff类型] || 1.0;
                                    最终Buff列表[已存在Buff索引].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引].value,
                                            上限
                                        );
                                } else if (buff类型 === 融合Buff类型.冷却缩减) {
                                    const 武器基础冷却 =
                                        武器.自定义数据.get("冷却回合") || 1;
                                    上限 =
                                        武器基础冷却 > 0 ? 武器基础冷却 - 1 : 0;
                                    最终Buff列表[已存在Buff索引].value =
                                        Math.max(
                                            0,
                                            Math.min(
                                                最终Buff列表[已存在Buff索引]
                                                    .value,
                                                上限
                                            )
                                        );
                                    上限 = 99999;
                                } else if (
                                    buff类型 === 融合Buff类型.固定伤害减免
                                ) {
                                    上限 = 5;
                                    最终Buff列表[已存在Buff索引].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引].value,
                                            上限
                                        );
                                } else if (buff类型 === 融合Buff类型.受击回能) {
                                    上限 = 20;
                                    最终Buff列表[已存在Buff索引].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引].value,
                                            上限
                                        );
                                } else if (
                                    buff类型 === 融合Buff类型.范围加成 &&
                                    武器.自定义数据.has("攻击范围")
                                ) {
                                    上限 = Math.floor(
                                        武器.自定义数据.get("攻击范围") * 0.5
                                    );
                                    最终Buff列表[已存在Buff索引].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引].value,
                                            上限
                                        );
                                } else if (buff类型.includes("加成")) {
                                    最终Buff列表[已存在Buff索引].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引].value,
                                            15
                                        );
                                }
                            }
                        } else {
                            最终Buff列表.push({
                                type: buff类型,
                                value: buff数值,
                            });
                        }
                    }
                });

                if (有效材料.length === 0 && 金币数量 >= 10) {
                    const 金币随机数 = 种子伪随机数(组合种子 + 1);
                    if (
                        金币随机数 <
                        (0.45 + Math.log10(金币数量 / 5 + 1) * 0.1) *
                            金币增幅系数
                    ) {
                        let 所有可能Buff_gold;
                        if (是否武器) {
                            所有可能Buff_gold = [
                                融合Buff类型.攻击加成,
                                融合Buff类型.攻击倍率,
                                融合Buff类型.冷却缩减,
                                融合Buff类型.耐久加成,
                                融合Buff类型.暴击几率,
                                融合Buff类型.范围加成,
                                融合Buff类型.中毒几率,
                                融合Buff类型.冰冻几率,
                                融合Buff类型.火焰伤害,
                                融合Buff类型.幸运一击,
                            ];
                        } else if (是否防具) {
                            所有可能Buff_gold = [
                                融合Buff类型.防御加成,
                                融合Buff类型.防御倍率,
                                融合Buff类型.耐久加成,
                                融合Buff类型.闪避几率,
                                融合Buff类型.固定伤害减免,
                                融合Buff类型.受击回能,
                                融合Buff类型.中毒几率,
                            ];
                        } else {
                            所有可能Buff_gold = [融合Buff类型.耐久加成];
                        }

                        const 随机Buff类型 =
                            所有可能Buff_gold[
                                Math.floor(
                                    种子伪随机数(组合种子 + 2) *
                                        所有可能Buff_gold.length
                                )
                            ];
                        let 随机Buff数值 = 0;
                        switch (随机Buff类型) {
                            case 融合Buff类型.攻击加成:
                                随机Buff数值 = Math.round(
                                    (1 + 种子伪随机数(组合种子 + 3) * 1.5) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.攻击倍率:
                                随机Buff数值 = Math.min(
                                    0.1,
                                    (0.01 + 种子伪随机数(组合种子 + 4) * 0.04) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.冷却缩减:
                                随机Buff数值 = Math.round(
                                    种子伪随机数(组合种子 + 5) *
                                        1 *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.耐久加成:
                                随机Buff数值 = Math.round(
                                    (5 + 种子伪随机数(组合种子 + 6) * 15) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.防御加成:
                                随机Buff数值 = Math.round(
                                    (1 + 种子伪随机数(组合种子 + 7) * 1) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.防御倍率:
                                随机Buff数值 = Math.min(
                                    0.15,
                                    (0.02 + 种子伪随机数(组合种子 + 8) * 0.05) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.暴击几率:
                                随机Buff数值 = Math.min(
                                    0.08,
                                    (0.01 +
                                        种子伪随机数(组合种子 + 9) * 0.025) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.范围加成:
                                if (
                                    是否武器 &&
                                    武器.自定义数据.has("攻击范围") &&
                                    武器.自定义数据.get("攻击范围") > 1
                                )
                                    随机Buff数值 = Math.round(1 * 金币增幅系数);
                                else 随机Buff数值 = 0;
                                break;
                            case 融合Buff类型.闪避几率:
                                随机Buff数值 = Math.min(
                                    0.05,
                                    (0.01 +
                                        种子伪随机数(组合种子 + 10) * 0.02) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.固定伤害减免:
                                随机Buff数值 = Math.round(
                                    种子伪随机数(组合种子 + 11) *
                                        1 *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.受击回能:
                                随机Buff数值 = Math.round(
                                    (2 + 种子伪随机数(组合种子 + 12) * 5) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.中毒几率:
                                随机Buff数值 = Math.min(
                                    0.15,
                                    (0.02 +
                                        种子伪随机数(组合种子 + 13) * 0.05) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.冰冻几率:
                                随机Buff数值 = Math.min(
                                    0.15,
                                    (0.02 +
                                        种子伪随机数(组合种子 + 14) * 0.05) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.火焰伤害:
                                随机Buff数值 = Math.min(
                                    0.15,
                                    (0.02 +
                                        种子伪随机数(组合种子 + 15) * 0.05) *
                                        金币增幅系数
                                );
                                break;
                            case 融合Buff类型.幸运一击:
                                随机Buff数值 = Math.min(
                                    0.12,
                                    (0.015 +
                                        种子伪随机数(组合种子 + 16) * 0.035) *
                                        金币增幅系数
                                );
                                break;
                            default:
                                随机Buff数值 = 0;
                                break;
                        }
                        if (随机Buff数值 > 0.001 && 随机Buff类型) {
                            const 已存在Buff索引_gold = 最终Buff列表.findIndex(
                                (b) => b.type === 随机Buff类型
                            );
                            if (已存在Buff索引_gold > -1) {
                                最终Buff列表[已存在Buff索引_gold].value +=
                                    随机Buff数值;
                                let 上限 = 1.0;
                                if (
                                    随机Buff类型.includes("MULTIPLIER") ||
                                    随机Buff类型.includes("CHANCE") ||
                                    随机Buff类型.includes("STEAL") ||
                                    随机Buff类型.includes("PERCENT")
                                ) {
                                    上限 =
                                        {
                                            [融合Buff类型.攻击倍率]: 0.5,
                                            [融合Buff类型.冷却倍率]: 0.75,
                                            [融合Buff类型.耐久倍率]: 1.0,
                                            [融合Buff类型.防御倍率]: 0.5,
                                            [融合Buff类型.中毒几率]: 0.6,
                                            [融合Buff类型.冰冻几率]: 0.6,
                                            [融合Buff类型.生命偷取]: 0.5,
                                            [融合Buff类型.击退几率]: 0.6,
                                            [融合Buff类型.攻击吸能]: 0.5,
                                            [融合Buff类型.火焰伤害]: 0.6,
                                            [融合Buff类型.闪避几率]: 0.5,
                                            [融合Buff类型.暴击几率]: 0.4,
                                            [融合Buff类型.暴击伤害倍率]: 1.5,
                                            [融合Buff类型.幸运一击]: 0.3,
                                        }[随机Buff类型] || 1.0;
                                    最终Buff列表[已存在Buff索引_gold].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引_gold]
                                                .value,
                                            上限
                                        );
                                } else if (
                                    随机Buff类型 === 融合Buff类型.冷却缩减
                                ) {
                                    const 武器基础冷却 =
                                        武器.自定义数据.get("冷却回合") || 1;
                                    上限 =
                                        武器基础冷却 > 0 ? 武器基础冷却 - 1 : 0;
                                    最终Buff列表[已存在Buff索引_gold].value =
                                        Math.max(
                                            0,
                                            Math.min(
                                                最终Buff列表[
                                                    已存在Buff索引_gold
                                                ].value,
                                                上限
                                            )
                                        );
                                    上限 = 99999;
                                } else if (
                                    随机Buff类型 === 融合Buff类型.固定伤害减免
                                ) {
                                    上限 = 5;
                                    最终Buff列表[已存在Buff索引_gold].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引_gold]
                                                .value,
                                            上限
                                        );
                                } else if (
                                    随机Buff类型 === 融合Buff类型.受击回能
                                ) {
                                    上限 = 20;
                                    最终Buff列表[已存在Buff索引_gold].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引_gold]
                                                .value,
                                            上限
                                        );
                                } else if (
                                    随机Buff类型 === 融合Buff类型.范围加成 &&
                                    武器.自定义数据.has("攻击范围")
                                ) {
                                    上限 = Math.floor(
                                        武器.自定义数据.get("攻击范围") * 0.5
                                    );
                                    最终Buff列表[已存在Buff索引_gold].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引_gold]
                                                .value,
                                            上限
                                        );
                                } else if (随机Buff类型.includes("加成")) {
                                    最终Buff列表[已存在Buff索引_gold].value =
                                        Math.min(
                                            最终Buff列表[已存在Buff索引_gold]
                                                .value,
                                            15
                                        );
                                }
                            } else {
                                最终Buff列表.push({
                                    type: 随机Buff类型,
                                    value: 随机Buff数值,
                                });
                            }
                        }
                    }
                }

                let buffMaterialCount = 0;
                有效材料.forEach((mat) => {
                    if (
                        mat instanceof 卷轴类 ||
                        mat.类型 === "药水" ||
                        mat instanceof 钥匙
                    ) {
                        buffMaterialCount++;
                    }
                });

                if (buffMaterialCount >= 2) {
                    const synergySeed = 哈希字符串(
                        组合种子字符串 + "Synergy" + 最终Buff列表.length
                    );
                    let synergyValue = 0;
                    if (是否武器) {
                        synergyValue = Math.round(
                            (1 + 种子伪随机数(synergySeed) * 1) * 金币增幅系数
                        );
                    } else if (是否防具) {
                        synergyValue = Math.round(
                            (1 + 种子伪随机数(synergySeed) * 0.5) * 金币增幅系数
                        );
                    }
                    if (synergyValue > 0) {
                        const existingSynergy = 最终Buff列表.find(
                            (b) => b.type === 融合Buff类型.协同效应
                        );
                        if (existingSynergy) {
                            existingSynergy.value += synergyValue;
                            if (是否武器)
                                existingSynergy.value = Math.min(
                                    existingSynergy.value,
                                    3
                                );
                            if (是否防具)
                                existingSynergy.value = Math.min(
                                    existingSynergy.value,
                                    2
                                );
                        } else {
                            最终Buff列表.push({
                                type: 融合Buff类型.协同效应,
                                value: synergyValue,
                            });
                        }
                    }
                }
                return 最终Buff列表;
            }

            function 格式化Buff提示(buff) {
                const 格式化数值 = (类型, 数值) => {
                    if (
                        类型.includes("MULTIPLIER") ||
                        类型.includes("CHANCE") ||
                        类型.includes("STEAL") ||
                        类型.includes("PERCENT") ||
                        类型 === 融合Buff类型.幸运一击
                    )
                        return `${(数值 * 100).toFixed(1)}%`;
                    if (
                        类型.includes("REDUCTION") &&
                        类型 !== 融合Buff类型.固定伤害减免
                    )
                        return `${数值.toFixed(1)}`;
                    return `+${数值.toFixed(1)}`;
                };
                switch (buff.type) {
                    case 融合Buff类型.攻击加成:
                        return `攻击力 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.攻击倍率:
                        return `攻击力 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.冷却缩减:
                        return `冷却 -${格式化数值(buff.type, buff.value)}回合`;
                    case 融合Buff类型.冷却倍率:
                        return `冷却缩减 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.耐久加成:
                        return `最大耐久 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.耐久倍率:
                        return `最大耐久 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.范围加成:
                        return `攻击范围 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.中毒几率:
                        return `附加中毒 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.火焰伤害:
                        return `附加燃烧 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.冰冻几率:
                        return `附加冰冻 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.生命偷取:
                        return `生命偷取 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.防御加成:
                        return `防御力 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.防御倍率:
                        return `防御力 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.暴击几率:
                        return `暴击几率 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.暴击伤害倍率:
                        return `暴击伤害 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.击退几率:
                        return `几率击退 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.攻击吸能:
                        return `攻击吸能 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.闪避几率:
                        return `闪避几率 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.固定伤害减免:
                        return `伤害减免 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.受击回能:
                        return `受击回能 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.幸运一击:
                        return `幸运一击 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.协同效应:
                        return `协同效应 ${格式化数值(buff.type, buff.value)}`;
                    case 融合Buff类型.磨刀石攻击加成:
                        return `磨刀石强化攻击: +${buff.value.toFixed(0)} (剩余${buff.usesLeft}次)`;
                    case 融合Buff类型.磨刀石冷却缩减:
                        return `磨刀石强化冷却: -${buff.value.toFixed(0)} (剩余${buff.usesLeft}次)`;
                    default:
                        return `未知强化: ${buff.type}`;
                }
            }

            function 伤害玩家(原始攻击力, 伤害来源 = null) {
                if (调试无限生命) return;
                let 最终攻击力 = 原始攻击力;
                let 伤害来源文本 =
                    伤害来源 instanceof 怪物
                        ? 伤害来源.类型
                        : 伤害来源 || "未知来源";

                let 闪避成功 = false;

                // 遍历装备，优先处理闪避
                for (const 装备 of Array.from(玩家装备.values()).filter(
                    (v) => v != null
                )) {
                    if (装备 instanceof 防御装备类) {
                        const buffs = 装备.自定义数据.get("fusedBuffs") || [];
                        const dodgeBuff = buffs.find(
                            (b) => b.type === 融合Buff类型.闪避几率
                        );
                        if (dodgeBuff && Math.random() < dodgeBuff.value) {
                            闪避成功 = true;
                            添加日志(
                                `通过 ${装备.获取名称()} 闪避了来自 ${伤害来源文本} 的攻击！`,
                                "成功"
                            );
                            break; // 一旦闪避成功，不再计算后续伤害
                        }
                    }
                }

                if (闪避成功) {
                    触发HUD显示();
                    return; // 不造成伤害
                }

                // 按顺序应用防御效果
                Array.from(玩家装备.values())
                    .filter((v) => v != null)
                    .forEach((装备) => {
                        if (最终攻击力 <= 0) return; // 如果伤害已经为0或负数，则不再计算

                        if (
                            装备 instanceof 宠物 &&
                            !装备.自定义数据.get("休眠中")
                        ) {
                            最终攻击力 = 装备.当玩家被攻击(
                                最终攻击力,
                                伤害来源
                            );
                        }
                        if (装备 instanceof 防御装备类) {
                            最终攻击力 = 装备.当被攻击(最终攻击力, 伤害来源); // 防御装备的当被攻击方法已包含固定减伤
                        }
                    });

                最终攻击力 = Math.max(0, 最终攻击力 - (玩家属性.防御加成 || 0));

                if (最终攻击力 <= 0 && 原始攻击力 > 0)
                    最终攻击力 = Math.round(Math.random() * 100) / 100;

                更新装备显示();
                触发扣血特效();

                const 玩家最大生命值 = 100 + (玩家属性.最大生命值加成 || 0);

                const 生命条 = document.querySelector(".health-bar");
                const 当前宽度 = parseFloat(生命条.style.width) || 100;
                let 新宽度 = Math.max(0, 当前宽度 - (最终攻击力 / 玩家最大生命值) * 100);
                if (游戏状态 === "图鉴" && 最终攻击力 > 0)
                    新宽度 = Math.max(1, 新宽度); // 图鉴模式至少留1血
                生命条.style.width = `${新宽度}%`;

                if (最终攻击力 > 0) {
                    添加日志(
                        `受到了 ${伤害来源文本} 的伤害！损失了 ${最终攻击力.toFixed(
                            1
                        )} 点血量！`,
                        `警告`
                    );
                } else if (原始攻击力 > 0) {
                    添加日志(`成功抵挡了来自 ${伤害来源文本} 的攻击！`, `成功`);
                }

                触发HUD显示();
                let 实际击退 = false;
                let 击退后X = 玩家.x,
                    原始X = 玩家.x;
                let 击退后Y = 玩家.y,
                    原始Y = 玩家.y;
                if (新宽度 > 0 && 伤害来源 instanceof 怪物 && 切换动画) {
                    let dx = 玩家.x - 伤害来源.x;
                    let dy = 玩家.y - 伤害来源.y;
                    let 击退DX = 0,
                        击退DY = 0;

                    if (Math.abs(dx) > Math.abs(dy))
                        击退DX =
                            Math.sign(dx) ||
                            (dy === 0 ? (Math.random() < 0.5 ? 1 : -1) : 0);
                    else if (Math.abs(dy) > Math.abs(dx))
                        击退DY =
                            Math.sign(dy) ||
                            (dx === 0 ? (Math.random() < 0.5 ? 1 : -1) : 0);
                    else if (dx !== 0 && dy !== 0) {
                        if (Math.random() < 0.5) 击退DX = Math.sign(dx);
                        else 击退DY = Math.sign(dy);
                    }
                    if (击退DX === 0 && 击退DY === 0) {
                        if (Math.random() < 0.5)
                            击退DX = Math.random() < 0.5 ? 1 : -1;
                        else 击退DY = Math.random() < 0.5 ? 1 : -1;
                    }

                    if (击退DX !== 0 || 击退DY !== 0) {
                        const 新X = 玩家.x + 击退DX;
                        const 新Y = 玩家.y + 击退DY;
                        if (
                            新X >= 0 &&
                            新X < 地牢大小 &&
                            新Y >= 0 &&
                            新Y < 地牢大小 &&
                            检查移动可行性(玩家.x, 玩家.y, 新X, 新Y) &&
                            ![单元格类型.墙壁, 单元格类型.上锁的门].includes(
                                地牢[新Y]?.[新X]?.背景类型
                            )
                        ) {
                            const 目标单元格 = 地牢[新Y]?.[新X];
                            const 目标物品 = 目标单元格?.关联物品;
                            const 不可移动类型列表 = ["楼梯"];
                            const 目标不可移动 =
                                目标物品 &&
                                (不可移动类型列表.includes(目标物品.类型) ||
                                    目标物品.能否拾起 === false);
                            if (!目标不可移动) {
                                玩家.x = 新X;
                                玩家.y = 新Y;
                                击退后X = 新X;
                                击退后Y = 新Y;
                                实际击退 = true;
                            }
                        }
                    }
                }
                if (实际击退) {
                    const 触发中断 = 处理玩家着陆效果(
                        原始X,
                        原始Y,
                        击退后X,
                        击退后Y
                    );
                    if (!触发中断) 更新视口();
                }

                if (新宽度 <= 0) {
                    玩家死亡();
                }
            }
            function 更新武器冷却() {
                const 时间加速 = 当前激活卷轴列表.has(Array.from(当前激活卷轴列表).find(item => item instanceof 时间卷轴));
                const 冷却减少量 = 时间加速 ? 2 : 1;
            
                玩家背包.forEach((item) => {
                    if ((item.类型 === "武器" || item instanceof 钩索) && item.自定义数据.get("冷却剩余") > 0) {
                        item.自定义数据.set("冷却剩余", Math.max(0, item.自定义数据.get("冷却剩余") - 冷却减少量));
                    }
                });
                更新装备显示();
            }

            function 处理怪物回合() {
                // 激活当前房间怪物
                const 当前房间ID = 房间地图[玩家.y][玩家.x];
                跟踪玩家怪物数 = 0;
                所有怪物.forEach((m) => {
                    if (房间地图[m.y][m.x] === 当前房间ID) {
                        m.状态 = 怪物状态.活跃;
                    }
                });
                const 玩家穿了潜行靴子 = Array.from(玩家装备.values()).some(item => item instanceof 潜行靴子);

                // 处理每个活跃怪物
                所有怪物.forEach((m) => {
                    if (m.状态 === 怪物状态.活跃) {
                        let { x, y } = m.选择目标();
                        let 可以追踪 = true;
                        if (玩家穿了潜行靴子 && 怪物状态表.get(m)?.类型 !== "魅惑") {
                            可以追踪 = 快速直线检查(m.x, m.y, 玩家.x, 玩家.y, m.跟踪距离,玩家穿了潜行靴子);
                        }

                        const 曼哈顿距离 =
                            Math.abs(m.x - x) + Math.abs(m.y - y);
            
                        if (可以追踪 && 曼哈顿距离 <= m.跟踪距离) {
                            m.目标路径 = m.计算路径(x, y);
                        } else {
                            m.目标路径 = null;
                            if (玩家穿了潜行靴子) { // 巡逻逻辑
                                const 方向列表 = [{dx: 0, dy: -1}, {dx: 1, dy: 0}, {dx: 0, dy: 1}, {dx: -1, dy: 0}];
                                const 可移动方向 = 方向列表.filter(dir => 检查移动可行性(m.x, m.y, m.x + dir.dx, m.y + dir.dy));
                                if (可移动方向.length > 0) {
                                    const 随机方向 = 可移动方向[Math.floor(Math.random() * 可移动方向.length)];
                                    m.目标路径 = [{ x: m.x + 随机方向.dx, y: m.y + 随机方向.dy }];
                                }
                            }
                        }
                        if (m.目标路径) {
                            m.通向目标路径 = m.计算目标路径(m.目标.x, m.目标.y);
                            if (m.通向目标路径) {
                                if (
                                    m.目标路径.length > 0 &&
                                    !(
                                        m.通向目标路径.length > 1 &&
                                        玩家状态.some(
                                            (s) => s.类型 === "隐身"
                                        ) &&
                                        怪物状态表.get(m)?.类型 !== "魅惑"
                                    )
                                ) {
                                    m.追击玩家中 = true;
                                    m.尝试移动(); //可能有bug：当玩家远离怪物时，药水效果不会正常被处理。
                                } else {
                                    m.追击玩家中 = false;
                                }
                            } else {
                                m.追击玩家中 = false;
                            }
                            m.通向目标路径 = m.计算目标路径(m.目标.x, m.目标.y);
                            if (m.通向目标路径) {
                                if (
                                    !(
                                        m.通向目标路径.length > 1 &&
                                        玩家状态.some(
                                            (s) => s.类型 === "隐身"
                                        ) &&
                                        怪物状态表.get(m)?.类型 !== "魅惑"
                                    )
                                ) {
                                    m.尝试攻击();
                                } else {
                                    m.绘制血条();
                                }
                            } else {
                                m.绘制血条(true);
                            }
                            const 我的状态 = 怪物状态表.get(m);
                            我的状态?.更新状态();
                            if (m instanceof 大魔法师) {
                                m.更新技能冷却();
                            }
                        } else {
                            m.追击玩家中 = false;
                        }
                    }
                });
                const 提示元素 =
                    怪物追踪提示.容器元素.querySelector(".hud-label");
                if (跟踪玩家怪物数 > 3) {
                    提示元素.classList.add("怪物数量警告");
                } else {
                    提示元素.classList.remove("怪物数量警告");
                }
                怪物追踪提示.更新({
                    内容: `追踪怪物：${跟踪玩家怪物数}`,
                }); //图标: 跟踪玩家怪物数 > 0 ? "🔥" : "👹"  删去，太唐了
            }
            function 切换日志显示() {
                日志面板可见 = !日志面板可见;
                const 按钮 = document.querySelector(
                    "#设置菜单 button:nth-child(1)"
                ); // 第一个按钮
                if (日志面板可见) {
                    document.querySelector(".日志面板").classList.add("可见");
                    按钮.textContent = "关闭日志界面"; // 更新按钮文本
                } else {
                    document
                        .querySelector(".日志面板")
                        .classList.remove("可见");
                    按钮.textContent = "打开日志界面"; // 更新按钮文本
                }
            }
            function 切换背包显示() {
                const 弹窗 = document.querySelector(".背包弹窗");
                const 融合窗口 = document.getElementById("融合窗口");
                const 当前状态 = 弹窗.classList.contains("显示中");
                // 关闭背包时清除所有选中状态
                if (当前状态) {
                    玩家属性.允许移动 -= 1;
                    document.getElementById("浮动提示框").style.display =
                        "none";
                    清空融合区();
                    document.querySelectorAll(".物品条目").forEach((el) => {
                        el.classList.remove("active");
                        if (el.__物品实例) {
                            el.__物品实例.isActive = false;
                        }
                    });
                } else {
                    玩家属性.允许移动 += 1;
                    更新融合窗口();
                    融合窗口.style.display = "flex";
                    requestAnimationFrame(() => {
                        融合窗口.classList.add("显示中");
                        融合窗口.style.opacity = 1;
                        融合窗口.style.transform = "translateX(0)";
                        融合窗口.style.pointerEvents = "auto";
                        融合窗口.style["flex-direction"] = "row";
                    });
                }
                // 更新全局状态
                界面可见性.背包 = !当前状态;

                弹窗.classList.toggle("显示中", !当前状态);
            }
            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape" && 界面可见性.背包) {
                    切换背包显示();
                }
            });
            document.addEventListener("click", (e) => {
                const 弹窗 = document.querySelector(".背包弹窗");
                const 背包区域 = document.querySelector(".背包弹窗 .物品容器");
                if (
                    界面可见性.背包 &&
                    !e.target.closest(".背包弹窗") &&
                    !e.target.closest("#背包按钮")
                ) {
                    切换背包显示();
                } else if (
                    教程提示已显示 &&
                    !e.target.closest("#教程提示窗口")
                ) {
                    关闭教程提示();
                } else if (
                    document
                        .getElementById("设置菜单")
                        .classList.contains("显示") &&
                    !e.target.closest("#设置按钮")
                ) {
                    切换设置菜单();
                } else if (
                    document.getElementById("教程回放窗口").style.display ===
                        "block" &&
                    !e.target.closest(".教程提示窗口") &&
                    !e.target.closest("#回放教程按钮")
                ) {
                    关闭教程回放窗口();
                }
                if (!e.target.closest(".物品条目") && 界面可见性.背包) {
                    document.getElementById("浮动提示框").style.display =
                        "none";
                    document.querySelectorAll(".物品条目").forEach((el) => {
                        el.classList.remove("active");
                        if (el.__物品实例) {
                            el.__物品实例.isActive = false;
                            //console.log(el.__物品实例.类型);
                        }
                    });
                }
            });

            // 键盘事件监听
            document.addEventListener("keydown", (e) => {
                const keyMap = {
                    ArrowUp: "up",
                    w: "up",
                    W: "up",
                    ArrowLeft: "left",
                    a: "left",
                    A: "left",
                    ArrowDown: "down",
                    s: "down",
                    S: "down",
                    ArrowRight: "right",
                    d: "right",
                    D: "right",
                };
                if (keyMap[e.key] && 玩家属性.允许移动 === 0) {
                    const direction = keyMap[e.key];

                    // 不重复触发
                    if (移动状态[direction]) return;

                    移动状态[direction] = true;
                    const dx = 移动状态.left
                        ? -玩家属性.移动步数
                        : 移动状态.right
                        ? 玩家属性.移动步数
                        : 0;
                    const dy = 移动状态.up
                        ? -玩家属性.移动步数
                        : 移动状态.down
                        ? 玩家属性.移动步数
                        : 0;

                    if (dx !== 0 || dy !== 0) {
                        移动玩家(dx, dy);
                    }
                    // 延迟调用
                    clearTimeout(开始移动定时器);
                    开始移动定时器 = setTimeout(开始移动, 250);

                    e.preventDefault(); // 阻止默认行为
                } else if (功能键映射[e.key]) {
                    功能键映射[e.key]();
                } else if (e.key === "Escape" && 界面可见性.背包) {
                    切换背包显示();
                }
            });

            document.addEventListener("keyup", (e) => {
                const keyMap = {
                    ArrowUp: "up",
                    w: "up",
                    W: "up",
                    ArrowLeft: "left",
                    a: "left",
                    A: "left",
                    ArrowDown: "down",
                    s: "down",
                    S: "down",
                    ArrowRight: "right",
                    d: "right",
                    D: "right",
                };
                if (keyMap[e.key]) {
                    const direction = keyMap[e.key];
                    移动状态[direction] = false; // 清除移动状态
                    clearTimeout(开始移动定时器); // 重要！清除 开始移动 定时器
                    停止移动();
                    e.preventDefault();
                }
            });
            function 获取玩家视野范围() {
                if (玩家状态.some(s => s.类型 === '失明')) return 0;
                const 玩家房间ID = 房间地图[玩家.y]?.[玩家.x];
                const 玩家所在房间 =
                    玩家房间ID !== undefined && 玩家房间ID !== -1
                        ? 房间列表[玩家房间ID]
                        : null;
                if (玩家所在房间?.类型==="黑暗房间") return 1;
                const 画布 = document.getElementById("dungeonCanvas");
                const 画布Rect = 画布.getBoundingClientRect();
                if (!当前天气效果.includes("深夜")) return Math.floor(画布Rect.width / 单元格大小 / 2);
                
                let 基础视野 = 3; // 默认视野范围
                let 视野加成 = 0;
                玩家装备.forEach((物品) => {
                    if (物品 instanceof 火把) {
                        视野加成 += 物品.自定义数据.get("视野加成") || 0;
                    }
                });
                return 基础视野 + 视野加成;
            }

            function 是否在光源范围内(目标X, 目标Y) {
                const 目标单元格 = 地牢[目标Y]?.[目标X];
                if (!目标单元格) return false;

                const 目标房间ID = 房间地图[目标Y]?.[目标X];
                if (目标房间ID !== -1) {
                    const 目标所在房间 = 房间列表[目标房间ID];
                    const 玩家所在房间ID = 房间地图[玩家.y]?.[玩家.x];
                    if (
                        目标所在房间 &&
                        目标所在房间.类型 === "黑暗房间" &&
                        玩家所在房间ID !== 目标房间ID
                    ) {
                        return false;
                    }
                }
                
                const 玩家距离 =
                    Math.abs(目标X - 玩家.x) + Math.abs(目标Y - 玩家.y);
                const 玩家视野 = 获取玩家视野范围();
                if (玩家距离 <= 玩家视野) {
                    if (
                        检查视线(玩家.x, 玩家.y, 目标X, 目标Y, 玩家视野) ||
                        目标单元格.背景类型 === 单元格类型.上锁的门
                    ) {
                        return true;
                    }
                }
                
                const 检查范围 = 5;
                for (let dy = -检查范围; dy <= 检查范围; dy++) {
                    for (let dx = -检查范围; dx <= 检查范围; dx++) {
                        const checkX = 目标X + dx;
                        const checkY = 目标Y + dy;

                        if (
                            checkX >= 0 &&
                            checkX < 地牢大小 &&
                            checkY >= 0 &&
                            checkY < 地牢大小
                        ) {
                            const 单元格 = 地牢[checkY]?.[checkX];
                            if (
                                单元格?.关联物品 &&
                                单元格.关联物品.自定义数据?.has("光照范围")
                            ) {
                                const 光源物品 = 单元格.关联物品;
                                const 光照范围 =
                                    光源物品.自定义数据.get("光照范围");
                                const 怪物实例 = 单元格.关联怪物;
                                let 光源有效 = false;

                                if (
                                    光源物品 instanceof 火把 &&
                                    光源物品.自定义数据.get("耐久") > 0 &&
                                    光源物品.是否被丢弃
                                ) {
                                    光源有效 = true;
                                } else if (光源物品 instanceof 火焰物品) {
                                    光源有效 = true;
                                } else if (
                                    怪物实例 &&
                                    怪物状态表.get(怪物实例)?.类型 === "火焰"
                                ) {
                                    光源有效 = true;
                                } else if (光源物品 instanceof 照明弹光源) {
                                    光源有效 = true;
                                }

                                if (光源有效) {
                                    const 距离光源 =
                                        Math.abs(目标X - 光源物品.x) +
                                        Math.abs(目标Y - 光源物品.y);
                                    if (距离光源 <= 光照范围) {
                                        if (
                                            检查视线(
                                                光源物品.x,
                                                光源物品.y,
                                                目标X,
                                                目标Y,
                                                光照范围
                                            ) ||
                                            目标单元格.背景类型 ===
                                                单元格类型.上锁的门
                                        ) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            }
            const 图标映射_原始 = { ...图标映射 };
            function 切换中文模式() {
                图标映射 = 中文模式 ? 图标映射_原始 : 中文对照图标映射; // 需要先备份原始图标映射
                楼梯图标 = {
                    下楼: 图标映射.下楼楼梯,
                    上楼: 图标映射.上楼楼梯,
                };
                中文模式 = !中文模式; // 切换状态

                // --- 更新主菜单按钮文本 ---
                const 主菜单切换按钮 = document.getElementById("切换中文按钮");
                if (主菜单切换按钮) {
                    主菜单切换按钮.textContent = 中文模式
                        ? "已切换为中文"
                        : "已切换为 Emoji";
                }

                document.querySelector(
                    "#背包按钮"
                ).innerHTML = `${图标映射.背包按钮}`;
                document.querySelector(
                    "#互动按钮"
                ).innerHTML = `${图标映射.互动按钮}`;

                切换HUD模式();
            }
            let 切换动画 = true;
            function 切换动画模式() {
                切换动画 = !切换动画; // 切换状态

                // --- 更新主菜单按钮文本 ---
                const 主菜单切换按钮 = document.getElementById("切换动画按钮");
                if (主菜单切换按钮) {
                    主菜单切换按钮.textContent = 切换动画
                        ? "已切换为自动"
                        : "已切换为回合制";
                }
            }

            function 使用装备槽物品(槽位编号) {
                const 物品实例 = 玩家装备.get(槽位编号);

                if (!物品实例) return;

                // 无需考虑堆叠
                if (物品实例.类型 === "武器") {
                    if (
                        物品实例.堆叠数量 > 0 &&
                        物品实例.自定义数据.get("冷却剩余") == 0
                    ) {
                        const { 怪物, 路径 } = 获取周围怪物(
                            物品实例.自定义数据.get("攻击目标数"),
                            物品实例.最终攻击范围
                        );
                        if (怪物 !== null) {
                            if (物品实例.使用(怪物, 路径)) {
                                Array.from(
                                    { length: 装备栏每页装备数 },
                                    (_, i) =>
                                        玩家装备.get(
                                            当前装备页 * 装备栏每页装备数 +
                                                i +
                                                1
                                        )
                                )
                                    .filter((v) => v != null)
                                    .forEach((装备) => {
                                        if (
                                            装备 instanceof 宠物 &&
                                            !装备.自定义数据.get("休眠中")
                                        ) {
                                            装备.当玩家攻击(怪物);
                                        }
                                    });
                                更新装备显示();
                                绘制();
                                return true;
                            }
                        } else {
                            if (当前天气效果.includes("诡魅")) {
                                显示通知(
                                    "太远了...看不清怪物的真实位置了...",
                                    "错误"
                                );
                            } else {
                                显示通知("附近没有目标", "错误");
                            }
                        }
                    } else {
                        显示通知("武器还未准备好", "错误");
                        return false;
                    }
                }
                if (物品实例.类型 === "卷轴") {
                    显示通知("请使用卷轴键使用该物品", "错误");
                    return false;
                }
                if (物品实例.使用()) {
                    if (物品实例.堆叠数量 <= 0) {
                        if (物品实例.装备槽位)
                            玩家装备.delete(物品实例.装备槽位);
                        玩家背包.delete(物品实例.唯一标识);
                    }
                    更新背包显示();
                    更新装备显示();
                    显示通知("已使用物品", "成功");
                    return true;
                } else {
                    if (物品实例.类型 !== "武器") {
                        显示通知("无法使用该物品", "错误");
                    }
                }
                return false;
            }

            function 卸下装备槽物品(槽位编号) {
                const 当前物品 = 玩家装备.get(槽位编号);

                if (当前物品) {
                    当前物品.取消装备();
                    显示通知("已卸下", "成功");
                    更新装备显示();
                    更新背包显示();

                    const 槽位 = document.getElementById(`装备槽${槽位编号}`);
                    槽位.style.transform = "scale(0.95)";
                    setTimeout(() => (槽位.style.transform = "scale(1)"), 200);
                }
            }
            function 处理销毁物品(唯一标识, 直接清理 = false) {
                const 目标物品 = 玩家背包.get(唯一标识);
                if (!直接清理) {
                    if (!confirm("确定要销毁这个物品吗？")) return false;
                }
                if (!目标物品) return false;

                const 物品元素 = 目标物品.显示元素;
                document.getElementById("浮动提示框").style.display = "none";

                if (!直接清理 && 物品元素 && document.body.contains(物品元素)) {
                    const 烟花容器 = document.createElement("div");
                    烟花容器.style.position = "fixed";
                    const rect = 物品元素.getBoundingClientRect();
                    烟花容器.style.left = `${rect.left + rect.width / 2}px`;
                    烟花容器.style.top = `${rect.top + rect.height / 2}px`;
                    烟花容器.style.zIndex = 99999;
                    document.body.appendChild(烟花容器);

                    for (let i = 0; i < 12; i++) {
                        const 粒子 = document.createElement("div");
                        粒子.className = "烟花粒子";
                        粒子.innerHTML = ["✨", "❄️", "⚡", "⭐", "💥", "🔥"][
                            i % 6
                        ];
                        粒子.style.color =
                            目标物品.颜色表[目标物品.颜色索引] || "#fff";
                        粒子.style.setProperty(
                            "--tx",
                            Math.cos((i * 30 * Math.PI) / 180)
                        );
                        粒子.style.setProperty(
                            "--ty",
                            Math.sin((i * 30 * Math.PI) / 180)
                        );
                        烟花容器.appendChild(粒子);
                    }
                    setTimeout(() => 烟花容器.remove(), 800);
                    物品元素.style.opacity = "0";
                    物品元素.style.transition = "opacity 0.2s";
                }

                if (目标物品.安全销毁()) {
                    [...玩家背包.values()].forEach((item) => {
                        if (item instanceof 宠物) {
                            for (let 槽位 in item.自定义数据.get("装备")) {
                                if (
                                    item.自定义数据.get("装备")[槽位] ===
                                    目标物品
                                ) {
                                    item.自定义数据.get("装备")[槽位] = null;
                                    item.更新宠物管理窗口();
                                }
                            }
                        }
                    });
                    if (目标物品.装备槽位) 玩家装备.delete(目标物品.装备槽位);
                    玩家背包.delete(唯一标识);
                    更新背包显示();
                    更新装备显示();
                }
                return true;
            }
            function 尝试收集物品(新物品, 直接收集 = false) {
                if (!新物品) return;
                if (!新物品.当被收集("玩家")) {
                    return false;
                }
                if (!新物品.能否拾起) return false;

                // 查找可堆叠物品
                const 现有物品 = [...玩家背包.values()].find((item) =>
                    item.可堆叠于(新物品)
                );

                // 处理可堆叠情况
                if (现有物品) {
                    if (现有物品.堆叠数量 < 现有物品.最大堆叠数量) {
                        if (
                            现有物品.堆叠数量 + 新物品.堆叠数量 >=
                            现有物品.最大堆叠数量
                        ) {
                            新物品.堆叠数量 -=
                                现有物品.最大堆叠数量 - 现有物品.堆叠数量;
                            现有物品.堆叠数量 = 现有物品.最大堆叠数量;
                            return 尝试收集物品(新物品, 直接收集);
                        } else {
                            现有物品.堆叠数量 += 新物品.堆叠数量;
                            更新背包显示();
                            更新装备显示();
                            const 特效元素 = document.createElement("div");
                            特效元素.className = "收集特效";
                            特效元素.style.cssText = `
   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
 `;
                            if (新物品.类型 === "金币") {
                                特效元素.style.cssText = `
   --辉光颜色: ${颜色表[2]};
   color: ${颜色表[2]};
 `;
                            }
                            特效元素.innerHTML = 新物品.显示图标;
                            if (!直接收集) {
                                document.body.appendChild(特效元素);
                            }
                            setTimeout(() => 特效元素.remove(), 1100);
                            return true;
                        }
                    }
                    // 当前堆叠已满则创建新堆叠
                }

                // 处理新物品，需要考虑该函数会被递归调用，故需要刷新（刷新准没错（（（
                if (
                    [...玩家背包.values()].reduce(
                        (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
                        0
                    ) >= 最大背包容量
                ) {
                    更新背包显示();
                    更新装备显示();
                    显示通知("背包已满！", "错误");
                    return false;
                }
                if (新物品.堆叠数量 > 0) {
                    玩家背包.set(新物品.唯一标识, 新物品);
                    添加日志(`已收集物品 ${新物品.获取名称()}`, "信息");
                }
                更新背包显示();
                更新装备显示();
                const 特效元素 = document.createElement("div");
                特效元素.className = "收集特效";
                特效元素.style.cssText = `
   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
 `;
                if (新物品.类型 === "金币") {
                    特效元素.style.cssText = `
   --辉光颜色: ${颜色表[2]};
   color: ${颜色表[2]};
 `;
                }
                特效元素.innerHTML = 新物品.显示图标;
                if (!直接收集) {
                    document.body.appendChild(特效元素);
                }
                setTimeout(() => 特效元素.remove(), 1100);
                return true;
            }

            function 使用背包物品(物品标识) {
                const 物品实例 = 玩家背包.get(物品标识);
                if (!物品实例) return false;
                if (物品实例.类型 === "武器") {
                    if (
                        物品实例.堆叠数量 > 0 &&
                        物品实例.自定义数据.get("冷却剩余") == 0
                    ) {
                        const { 怪物, 路径 } = 获取周围怪物(
                            物品实例.自定义数据.get("攻击目标数"),
                            物品实例.最终攻击范围
                        );
                        if (怪物 !== null) {
                            if (物品实例.使用(怪物, 路径)) {
                                Array.from(
                                    { length: 装备栏每页装备数 },
                                    (_, i) =>
                                        玩家装备.get(
                                            当前装备页 * 装备栏每页装备数 +
                                                i +
                                                1
                                        )
                                )
                                    .filter((v) => v != null)
                                    .forEach((装备) => {
                                        if (
                                            装备 instanceof 宠物 &&
                                            !装备.自定义数据.get("休眠中")
                                        ) {
                                            装备.当玩家攻击(怪物);
                                        }
                                    });
                                更新装备显示();
                                绘制();
                                互动 = true;
                                return true;
                            }
                            //失败后回退到 物品实例.使用()
                        } else {
                            if (当前天气效果.includes("诡魅")) {
                                显示通知(
                                    "太远了...看不清怪物的真实位置了...",
                                    "错误"
                                );
                            } else {
                                显示通知("附近没有目标", "错误");
                            }
                        }
                    } else {
                        显示通知("武器还未准备好", "错误");
                        return false;
                    }
                }
                if (物品实例.类型 === "卷轴") {
                    显示通知("请在装备栏中使用该物品", "错误");
                    return false;
                }
                if (物品实例.使用()) {
                    document.getElementById("浮动提示框").style.display =
                        "none";
                    if (物品实例.堆叠数量 <= 0) {
                        if (物品实例.装备槽位)
                            玩家装备.delete(物品实例.装备槽位);
                        玩家背包.delete(物品标识);
                        物品实例.isActive = false;
                    }
                    更新背包显示();
                    更新装备显示();
                    显示通知("已使用物品", "成功");
                    return true;
                } else {
                    显示通知("无法使用该物品", "错误");
                }
                return false;
            }

            function 更新背包显示() {
                document.getElementById("最大容量").textContent = 最大背包容量;
                const 容器 = document.getElementById("背包物品栏");
                容器.innerHTML = "";

                玩家背包.forEach((item) => {
                    if (!item.是否隐藏) {
                        const 元素 = item.生成显示元素();
                        if (item.isActive) {
                            元素.classList.add("active");
                        }
                        容器.appendChild(元素);
                    }
                });

                document.getElementById("当前容量").textContent = [
                    ...玩家背包.values(),
                ].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0);
            }
            function 切换装备页(方向) {
                const 旧页 = 当前装备页;
                当前装备页 += 方向;

                let 最高槽位 = 0;
                for (const key of 玩家装备.keys()) {
                    if (key > 最高槽位) 最高槽位 = key;
                }
                const 最大有效页 = Math.max(0, Math.ceil(最高槽位 / 4) - 1);
                const 允许最大页 = Math.ceil(最大装备槽数量 / 4) - 1;

                当前装备页 = Math.max(0, Math.min(当前装备页, 允许最大页));

                if (当前装备页 !== 旧页) {
                    更新装备显示();

                    const 装备栏元素 = document.querySelector(".装备栏");
                    if (装备栏元素) {
                        装备栏元素.style.transition = "transform 0.1s ease-out";
                        装备栏元素.style.transform = `translateX(${
                            方向 > 0 ? "-" : ""
                        }5px)`;
                        setTimeout(() => {
                            装备栏元素.style.transform = "";
                        }, 100);
                    }
                }
            }

            function 初始化装备系统() {
                const 装备栏元素 = document.querySelector(".装备栏");

                const 处理装备槽点击 = (槽位, 实际槽位编号) => {
                    const 当前物品 = 玩家装备.get(实际槽位编号);
                    if (!当前物品) return;

                    if (当前物品 instanceof 卷轴类) {
                        if (当前激活卷轴列表.has(当前物品)) {
                            当前激活卷轴列表.delete(当前物品);
                            当前物品.卸下();
                            const 物品元素 = 槽位.querySelector(".物品条目");
                            if (物品元素) 物品元素.classList.remove("卷轴闪烁");
                            显示通知("已禁用卷轴", "成功");
                        } else {
                            当前激活卷轴列表.add(当前物品);
                            if (当前物品.使用()) {
                                显示通知("已启用卷轴", "成功");
                                const 物品元素 =
                                    槽位.querySelector(".物品条目");
                                if (物品元素)
                                    物品元素.classList.add("卷轴闪烁");
                            } else {
                                当前激活卷轴列表.delete(当前物品);
                            }
                            更新装备显示();
                        }
                    } else {
                        使用装备槽物品(实际槽位编号);
                    }
                };

                if ("ontouchstart" in window && 装备栏元素) {
                    装备栏元素.addEventListener(
                        "touchstart",
                        (e) => {
                            触摸起始X = e.touches[0].clientX;
                            触摸移动X = 触摸起始X;
                            装备栏滑动中 = false;
                        },
                        { passive: true }
                    );

                    装备栏元素.addEventListener("touchmove", (e) => {
                        if (!触摸起始X) return;
                        触摸移动X = e.touches[0].clientX;
                        const deltaX = 触摸移动X - 触摸起始X;
                        if (Math.abs(deltaX) > 20) {
                            装备栏滑动中 = true;
                        }
                    });

                    装备栏元素.addEventListener("touchend", (e) => {
                        if (!触摸起始X || !装备栏滑动中) {
                            触摸起始X = 0;
                            return;
                        }
                        const deltaX = 触摸移动X - 触摸起始X;
                        const 滑动阈值 = 50;
                        if (deltaX < -滑动阈值) {
                            切换装备页(1);
                        } else if (deltaX > 滑动阈值) {
                            切换装备页(-1);
                        }
                        触摸起始X = 0;
                        触摸移动X = 0;
                        装备栏滑动中 = false;
                    });

                    装备栏元素.addEventListener("touchcancel", (e) => {
                        触摸起始X = 0;
                        触摸移动X = 0;
                        装备栏滑动中 = false;
                    });
                }

                document.querySelectorAll(".装备槽").forEach((槽位, index) => {
                    const handleTouchEnd = (e) => {
                        if (装备栏滑动中) return;
                        const 实际槽位编号 =
                            当前装备页 * 装备栏每页装备数 + (index + 1);
                        处理装备槽点击(槽位, 实际槽位编号);
                    };

                    槽位.addEventListener("touchend", handleTouchEnd);
                    槽位.addEventListener("touchcancel", handleTouchEnd);

                    if (!("ontouchstart" in window)) {
                        槽位.addEventListener("contextmenu", (e) => {
                            e.preventDefault();
                            卸下装备槽物品(
                                当前装备页 * 装备栏每页装备数 + (index + 1)
                            );
                        });
                        槽位.addEventListener("click", (e) => {
                            const 实际槽位编号 =
                                当前装备页 * 装备栏每页装备数 + (index + 1);
                            处理装备槽点击(槽位, 实际槽位编号);
                        });
                    }
                });
            }
            function 更新装备显示() {
                for (
                    let i = 1 + 当前装备页 * 装备栏每页装备数;
                    i <= 装备栏每页装备数 + 当前装备页 * 装备栏每页装备数;
                    i++
                ) {
                    const 槽位 = document.getElementById(
                        `装备槽${((i - 1) % 装备栏每页装备数) + 1}`
                    );
                    if (!槽位) continue;

                    const 装备物品 = 玩家装备.get(i);

                    if (装备物品 && !装备物品.是否隐藏) {
                        const 克隆元素 = 装备物品
                            .生成显示元素("装备")
                            .cloneNode(true);
                        if (window.outerWidth < 770) {
                            克隆元素.style.transform = "scale(0.55)";
                        }
                        克隆元素.classList.remove("active");
                        克隆元素.classList.remove("hover");
                        克隆元素.__物品实例 = 装备物品;
                        克隆元素.removeAttribute("data-quality");

                        [
                            "丢弃按钮",
                            "使用按钮",
                            "装备按钮",
                            "上屏按钮",
                        ].forEach((className) => {
                            克隆元素.querySelector(`.${className}`)?.remove();
                        });

                        if (
                            装备物品.类型 === "武器" &&
                            (装备物品.自定义数据.get("冷却剩余") > 0 ||
                                槽位.querySelector(`.冷却遮罩`))
                        ) {
                            if (槽位.innerHTML === "") {
                                const 耐久标签 = document.createElement("div");
                                耐久标签.className = "耐久标签";
                                耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
                                    "耐久"
                                )}`;
                                克隆元素.appendChild(耐久标签);
                                槽位.appendChild(克隆元素);
                            }
                            let 遮罩 = 槽位.querySelector(`.冷却遮罩`);
                            if (!遮罩) {
                                遮罩 = document.createElement("div");
                            }
                            遮罩.className = "冷却遮罩";
                            const 进度 =
                                1 -
                                装备物品.自定义数据.get("冷却剩余") /
                                    装备物品.自定义数据.get("冷却回合");
                            遮罩.style.clipPath = `inset(${进度 * 100}% 0 0 0)`;
                            if (!槽位.querySelector(`.冷却遮罩`)) {
                                槽位.appendChild(遮罩);
                            }
                            if (进度 === 1) {
                                setTimeout(() => 遮罩.remove(), 220);
                            }
                            continue;
                        }
                        if (
                            装备物品.类型 === "防御装备" ||
                            (装备物品.类型 === "武器" &&
                                !槽位.querySelector(`.冷却遮罩`))
                        ) {
                            const 耐久标签 = document.createElement("div");
                            耐久标签.className = "耐久标签";
                            耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
                                "耐久"
                            )}`;
                            克隆元素.appendChild(耐久标签);
                        }
                        if (
                            装备物品 instanceof 卷轴类 &&
                            当前激活卷轴列表.has(装备物品)
                        ) {
                            克隆元素.classList.add("卷轴闪烁");
                        }
                        if (装备物品 instanceof 宠物) {
                            const 血量标签 = document.createElement("div");
                            血量标签.className = "宠物血量标签";
                            血量标签.textContent = `HP: ${装备物品.自定义数据.get(
                                "当前生命值"
                            )} / ${装备物品.自定义数据.get("最大生命值")}`;
                            克隆元素.appendChild(血量标签);
                        }
                        槽位.innerHTML = "";
                        槽位.appendChild(克隆元素);
                    } else {
                        槽位.innerHTML = "";
                    }
                }
            }
            function 怪物放置物品(物品, x, y, 能否拾起 = false) {
                let 目标X = x;
                let 目标Y = y;
                let 可用 = false;
                if (位置是否可用(目标X, 目标Y, false)) {
                    可用 = true;
                } else {
                    const 主要方向 = [
                        [0, -1],
                        [0, 1],
                        [-1, 0],
                        [1, 0],
                    ];

                    const 次要方向 = [
                        [1, -1],
                        [1, 1],
                        [-1, 1],
                        [-1, -1],
                    ];

                    for (const [dx, dy] of 主要方向) {
                        const 新X = x + dx;
                        const 新Y = y + dy;

                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            continue;
                        if (位置是否可用(新X, 新Y)) {
                            目标X = 新X;
                            目标Y = 新Y;
                            可用 = true;
                            break;
                        }
                    }

                    if (!可用) {
                        for (const [dx, dy] of 次要方向) {
                            const 新X = x + dx;
                            const 新Y = y + dy;

                            if (
                                新X < 0 ||
                                新X >= 地牢大小 ||
                                新Y < 0 ||
                                新Y >= 地牢大小
                            )
                                continue;
                            if (位置是否可用(新X, 新Y)) {
                                目标X = 新X;
                                目标Y = 新Y;
                                可用 = true;
                                break;
                            }
                        }
                    }
                }
                if (!可用) {
                    添加日志("怪物放置物品：没有可放置的位置");
                    return { x: null, y: null, 新物品: null };
                }
                let 放置物品 = 物品;
                放置物品.堆叠数量 = 1;
                放置物品.能否拾起 = 能否拾起;
                放置怪物到单元格(放置物品, 目标X, 目标Y);
                return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
            }

            function 玩家放置物品(物品, 能否拾起 = false) {
                let 目标X = 玩家.x;
                let 目标Y = 玩家.y;
                let 可用 = false;
                if (位置是否可用(目标X, 目标Y, false)) {
                    可用 = true;
                } else {
                    const 主要方向 = [
                        [0, -1],
                        [0, 1],
                        [-1, 0],
                        [1, 0],
                    ];

                    const 次要方向 = [
                        [1, -1],
                        [1, 1],
                        [-1, 1],
                        [-1, -1],
                    ];

                    for (const [dx, dy] of 主要方向) {
                        const 新X = 玩家.x + dx;
                        const 新Y = 玩家.y + dy;

                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            continue;
                        if (位置是否可用(新X, 新Y)) {
                            目标X = 新X;
                            目标Y = 新Y;
                            可用 = true;
                            break;
                        }
                    }

                    if (!可用) {
                        for (const [dx, dy] of 次要方向) {
                            const 新X = 玩家.x + dx;
                            const 新Y = 玩家.y + dy;

                            if (
                                新X < 0 ||
                                新X >= 地牢大小 ||
                                新Y < 0 ||
                                新Y >= 地牢大小
                            )
                                continue;
                            if (位置是否可用(新X, 新Y)) {
                                目标X = 新X;
                                目标Y = 新Y;
                                可用 = true;
                                break;
                            }
                        }
                    }
                }
                if (!可用) {
                    添加日志("玩家放置物品：没有可放置的位置");
                    return { x: null, y: null, 新物品: null };
                }
                let 放置物品 = 克隆物品(物品);
                放置物品.堆叠数量 = 1;
                放置物品.能否拾起 = 能否拾起;
                放置物品到单元格(放置物品, 目标X, 目标Y);
                return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
            }
            function 放置怪物到单元格(怪物, x, y) {
                if (位置是否可用(x, y) || !地牢[y][x].关联物品?.阻碍怪物) {
                    地牢[y][x].类型 = 单元格类型.怪物;
                    地牢[y][x].关联怪物 = 怪物;
                    怪物.x = x;
                    怪物.y = y;
                    怪物.房间ID = 房间地图[y][x];
                    所有怪物.push(怪物);
                    绘制();
                    return true;
                }
                return false;
            }
            function 生成奖励(房间) {
                const 奖励数量 = 3;
                const 奖励物品 = [];
                const 层数 = Math.max(当前层数, 0); // 确保层数不为负
                const 下一层数 = 层数 + 1;

                const 品质权重基础 = [
                    // 定义基础权重，不受层数直接影响，但会通过物品池过滤间接影响
                    { 品质: 1, 权重: 20 },
                    { 品质: 2, 权重: 35 },
                    { 品质: 3, 权重: 25 },
                    { 品质: 4, 权重: 15 },
                    { 品质: 5, 权重: 5 },
                ];

                let 已选中 = false;
                let 尝试次数 = 0;
                const 已生成物品名称 = new Set(); // 用于确保奖励不重复

                for (let i = 0; i < 奖励数量; i++) {
                    已选中 = false;
                    尝试次数 = 0;
                    while (!已选中 && 尝试次数 < 100) {
                        const 候选物品池 = Object.values(物品池)
                            .flat()
                            .filter((itemCfg) => {
                                const 临时实例 = new itemCfg.类({});
                                return (
                                    itemCfg.最小层 <= 下一层数 &&
                                    临时实例.类型 !== "工具" &&
                                    itemCfg.类.name !== "神秘商人" &&
                                    itemCfg.类.name !== "探险家" &&
                                    itemCfg.类.name !== "物品祭坛" &&
                                    itemCfg.类.name !== "耐久祭坛" &&
                                    itemCfg.类.name !== "背包扩容祭坛" &&
                                    itemCfg.类.name !== "重铸台" &&
                                    itemCfg.类.name !== "折跃门" &&
                                    itemCfg.类.name !== "寻宝戒指" &&
                                    itemCfg.类.name !== "配方卷轴" &&
                                    itemCfg.类.name !== "钥匙" &&
                                    itemCfg.类.name !== "金币"
                                );
                            });

                        if (候选物品池.length === 0) {
                            尝试次数 = 100; // 没有可选物品，跳出循环
                            continue;
                        }

                        // 2. 从候选池中根据品质权重选择物品
                        let 选中物品模板 = null;
                        let 品质尝试次数 = 0;
                        while (!选中物品模板 && 品质尝试次数 < 50) {
                            const 目标品质配置 = 加权随机选择(
                                品质权重基础.map((p) => ({
                                    值: p.品质,
                                    权重: p.权重,
                                }))
                            );
                            const 品质过滤后物品 = 候选物品池.filter(
                                (item) => item.品质 === 目标品质配置
                            );

                            if (品质过滤后物品.length > 0) {
                                选中物品模板 =
                                    品质过滤后物品[
                                        Math.floor(
                                            Math.random() *
                                                品质过滤后物品.length
                                        )
                                    ];
                            }
                            品质尝试次数++;
                        }

                        if (!选中物品模板) {
                            // 如果按品质没选到，就从候选池随机选一个
                            选中物品模板 =
                                候选物品池[
                                    Math.floor(
                                        Math.random() * 候选物品池.length
                                    )
                                ];
                        }

                        // 3. 创建物品实例
                        if (选中物品模板) {
                            const 物品实例 = new 选中物品模板.类({
                                数量: 1, // 奖励通常是单个
                                强化:
                                    Math.random() <
                                    0.2 + Math.min(层数, 10) * 0.05, // 强化概率随层数略微增加
                                已解锁: true, // 奖励物品默认解锁
                            });

                            if (
                                !已生成物品名称.has(物品实例.名称) &&
                                物品实例.是否正常物品
                            ) {
                                奖励物品.push(物品实例);
                                已生成物品名称.add(物品实例.名称);
                                已选中 = true;
                            }
                        }
                        尝试次数++;
                    }
                }

                奖励物品.forEach((物品) => {
                    放置物品到房间(物品, 房间, 单元格类型.物品, false, true);
                });
            }
            function 解谜成功(房间) {
                for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                    for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                        if (
                            地牢[y][x].类型 === 单元格类型.物品 &&
                            地牢[y][x].关联物品 instanceof 棋子
                        ) {
                            地牢[y][x].类型 = null;
                            地牢[y][x].关联物品 = null;
                        }
                    }
                }
                生成奖励(房间);
                显示通知("解谜成功！获得了丰厚奖励！", "成功");
                绘制();
            }
            function 检查解谜是否成功(棋子数量) {
                const 当前房间ID = 房间地图[玩家.y][玩家.x];
                if (当前房间ID === -1) return false;

                const 当前房间 = 房间列表[当前房间ID];
                if (当前房间.类型 !== "隐藏解谜棋盘") return false;
                let 棋子现存数量 = 0;
                const 棋盘宽度 = 当前房间.w;
                const 棋盘高度 = 当前房间.h;
                const 棋盘 = Array(棋盘高度)
                    .fill(null)
                    .map(() => Array(棋盘宽度).fill(0));
                const 棋子列表 = [];

                for (let y = 当前房间.y; y < 当前房间.y + 当前房间.h; y++) {
                    for (let x = 当前房间.x; x < 当前房间.x + 当前房间.w; x++) {
                        if (
                            地牢[y][x].类型 === 单元格类型.物品 &&
                            地牢[y][x].关联物品 instanceof 棋子 &&
                            地牢[y][x].关联物品.堆叠数量 === 1
                        ) {
                            棋盘[y - 当前房间.y][x - 当前房间.x] =
                                地牢[y][x].关联物品;
                            棋子列表.push({
                                x: x - 当前房间.x,
                                y: y - 当前房间.y,
                                棋子: 地牢[y][x].关联物品,
                            });
                            棋子现存数量++;
                        }
                    }
                }
                if (棋子现存数量 >= 棋子数量) {
                    for (const 棋子信息 of 棋子列表) {
                        const 攻击位置 = 棋子信息.棋子.可攻击位置(
                            棋子信息.x,
                            棋子信息.y,
                            棋盘
                        );
                        for (const 其他棋子信息 of 棋子列表) {
                            if (棋子信息 === 其他棋子信息) continue;
                            if (
                                攻击位置.some(
                                    (pos) =>
                                        pos.x === 其他棋子信息.x &&
                                        pos.y === 其他棋子信息.y
                                )
                            ) {
                                return false;
                            }
                        }
                    }

                    解谜成功(当前房间);
                    return true;
                }
                return false;
            }
            function 生成解谜棋盘(房间) {
                const 棋盘大小 = Math.min(房间.w, 房间.h);
                const 棋盘 = Array(棋盘大小)
                    .fill(null)
                    .map(() => Array(棋盘大小).fill(0));
                const 棋子种类 = {
                    A: [国际象棋车, 国际象棋象],
                    B: [国际象棋马, 中国象棋炮],
                };

                const 首个棋子层级 = Math.random() < 0.6 ? "A" : "B";
                const 首个棋子类 =
                    棋子种类[首个棋子层级][
                        Math.floor(
                            Math.random() * 棋子种类[首个棋子层级].length
                        )
                    ];
                棋盘[0][0] = new 首个棋子类({});

                for (let y = 0; y < 棋盘大小; y++) {
                    for (let x = 0; x < 棋盘大小; x++) {
                        if (x === 0 && y === 0) continue;
                        if (棋盘[y][x]) continue;

                        let 当前层级 = "A";
                        while (当前层级) {
                            const 可放置棋子 = [];
                            for (const 棋子类 of 棋子种类[当前层级]) {
                                if (可以放置(x, y, 棋子类, 棋盘)) {
                                    可放置棋子.push(棋子类);
                                }
                            }

                            if (可放置棋子.length > 0) {
                                const 权重 = 可放置棋子.map((棋子类) => {
                                    const 威胁数 = 计算新增威胁格子数(
                                        x,
                                        y,
                                        棋子类,
                                        棋盘
                                    );
                                    return 1 / (威胁数 + 1);
                                });

                                const 最小权重 = Math.min(...权重);

                                if (当前层级 === "A") {
                                    可放置棋子.push("下一层");
                                    权重.push(最小权重);
                                }

                                const 总权重 = 权重.reduce(
                                    (sum, w) => sum + w,
                                    0
                                );
                                let 随机数 = Math.random() * 总权重;
                                let 选中棋子类 = null;
                                for (let i = 0; i < 可放置棋子.length; i++) {
                                    if (随机数 < 权重[i]) {
                                        选中棋子类 = 可放置棋子[i];
                                        break;
                                    }
                                    随机数 -= 权重[i];
                                }

                                if (选中棋子类) {
                                    if (选中棋子类 === "下一层") {
                                        当前层级 = "B";
                                    } else {
                                        棋盘[y][x] = new 选中棋子类({});
                                        break;
                                    }
                                }
                            } else {
                                if (当前层级 === "A") {
                                    当前层级 = "B";
                                } else {
                                    break;
                                }
                            }
                        }
                    }
                }
                const 棋子 = [];
                房间.棋子数量 = 0;
                for (let i = 0; i < 棋盘大小; i++) {
                    for (let j = 0; j < 棋盘大小; j++) {
                        if (棋盘[j][i]) {
                            棋子.push(棋盘[j][i]);
                        }
                    }
                }
                棋子.forEach((棋子) => {
                    放置物品到房间(棋子, 房间);
                    房间.棋子数量++;
                });
                return { 棋盘 };
            }

            function 可以放置(x, y, 棋子类, 棋盘) {
                if (棋盘[y][x]) return false;

                for (let i = 0; i < 棋盘.length; i++) {
                    for (let j = 0; j < 棋盘[i].length; j++) {
                        const 已放置棋子 = 棋盘[j][i];
                        if (已放置棋子) {
                            const 攻击位置 = 已放置棋子.可攻击位置(i, j, 棋盘);
                            if (
                                攻击位置.some(
                                    (pos) => pos.x === x && pos.y === y
                                )
                            ) {
                                return false;
                            }
                        }
                    }
                }

                const 临时棋盘 = 棋盘.map((row) =>
                    row.map((cell) => (cell ? new cell.constructor() : null))
                );
                临时棋盘[y][x] = new 棋子类();
                const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(
                    x,
                    y,
                    临时棋盘
                );
                for (let i = 0; i < 棋盘.length; i++) {
                    for (let j = 0; j < 棋盘.length; j++) {
                        if (临时棋盘[j][i] && (i !== x || j !== y)) {
                            if (
                                新棋子攻击位置.some(
                                    (pos) => pos.x === i && pos.y === j
                                )
                            ) {
                                return false;
                            }
                        }
                    }
                }

                for (let i = 0; i < 棋盘.length; i++) {
                    for (let j = 0; j < 棋盘.length; j++) {
                        if (临时棋盘[j][i] instanceof 中国象棋炮) {
                            const 炮的攻击位置 = 临时棋盘[j][i].可攻击位置(
                                i,
                                j,
                                临时棋盘
                            );
                            for (let m = 0; m < 棋盘.length; m++) {
                                for (let n = 0; n < 棋盘.length; n++) {
                                    if (
                                        临时棋盘[n][m] &&
                                        (m !== i || n !== j)
                                    ) {
                                        if (
                                            炮的攻击位置.some(
                                                (pos) =>
                                                    pos.x === m && pos.y === n
                                            )
                                        ) {
                                            return false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return true;
            }

            function 计算新增威胁格子数(x, y, 棋子类, 棋盘) {
                const 临时棋盘 = 棋盘.map((row) =>
                    row.map((cell) => (cell ? new cell.constructor() : null))
                );
                临时棋盘[y][x] = new 棋子类();
                const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(
                    x,
                    y,
                    临时棋盘
                );

                let 新增威胁数 = 0;

                for (let i = 0; i < 棋盘.length; i++) {
                    for (let j = 0; j < 棋盘[i].length; j++) {
                        if (临时棋盘[j][i] === null) {
                            if (
                                新棋子攻击位置.some(
                                    (pos) => pos.x === i && pos.y === j
                                ) ||
                                !可以放置(i, j, 棋子类, 临时棋盘)
                            ) {
                                新增威胁数++;
                            }
                        }
                    }
                }
                return 新增威胁数;
            }

                    function 显示通知(内容, 类型 = "信息", 强制显示 = false, 持续时间 = 1500) {
            添加日志(内容, 类型);
            if (!是否显示通知 && !强制显示) {
                return;
            }

            const 容器 = document.querySelector(".通知容器") || document.createElement("div");
            if (!document.body.contains(容器)) {
                容器.className = "通知容器";
                document.body.appendChild(容器);
            }

            const 最大通知数 = 2;

            // 当通知数量达到或超过上限时，立即移除最旧的通知
            while (容器.children.length >= 最大通知数) {
                const 待移除通知 = Array.from(容器.children).find(n => !n.classList.contains('持久'));
                if (待移除通知) {
                    clearTimeout(待移除通知._timer); // 清除其自动消失的计时器
                    待移除通知.remove(); // 立即从DOM中移除
                } else {
                    // 如果所有通知都是持久性的，则无法添加新通知
                    console.warn("无法显示新通知，因为所有可见通知都是持久性的。");
                    return;
                }
            }

            const 图标表 = {
                信息: "ℹ️",
                成功: 图标映射.成功,
                警告: "⚠️",
                错误: 图标映射.错误,
            };
            const 通知 = document.createElement("div");
            通知.className = `通知条目 ${类型}`;
            if(强制显示) 通知.classList.add('持久');
            
            通知.innerHTML = `
                <span class="通知图标">${图标表[类型]}</span>
                <span class="通知内容">${内容}</span>
                <button class="关闭按钮">×</button>
            `;

            通知.querySelector('.关闭按钮').addEventListener('click', () => {
                if (通知._timer) clearTimeout(通知._timer);
                隐藏通知(通知);
            });
            
            
                通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
                通知.addEventListener('mouseenter', () => clearTimeout(通知._timer));
                通知.addEventListener('mouseleave', () => {
                    通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
                });
            

            容器.appendChild(通知);
        }

            function 生成天气效果() {
                当前天气效果 = [];

                const 乱序天气列表 = [...所有天气列表].sort(
                    () => Math.random() - 0.5
                );

                const 要选择的数量 =
                    Math.random() < 0.5 ? 1 : Math.min(2, 乱序天气列表.length);

                当前天气效果 = 乱序天气列表.slice(0, 要选择的数量);

                if (当前天气效果.includes("深夜")) {
                    显示通知("夜幕降临，周围变得一片漆黑...", "警告");
                }
                if (当前天气效果.includes("雷暴")) {
                    显示通知("乌云密布，雷声滚滚...", "警告");
                }
                if (当前天气效果.includes("大风")) {
                    显示通知("狂风呼啸，站稳脚跟！", "警告");
                }
                if (当前天气效果.includes("严寒")) {
                    显示通知("严冬将至...", "警告");
                }
                if (当前天气效果.includes("诡魅")) {
                    显示通知(
                        "空气中弥漫着诡异的气息，你的感知似乎受到了干扰...",
                        "警告"
                    );
                }
            }
            function 处理诡魅房间刷新(旧玩家X, 旧玩家Y, 玩家X, 玩家Y) {
                const 旧视野房间ID集合 = 获取视野内房间ID(旧玩家X, 旧玩家Y);
                const 新视野房间ID集合 = 获取视野内房间ID(玩家X, 玩家Y);
                房间列表.forEach((房间) => {
                    if (
                        房间.类型?.slice(0, 2) === "隐藏" ||
                        !已访问房间.has(房间.id) ||
                        新视野房间ID集合.has(房间.id) ||
                        房间.id === 0
                    ) {
                        return;
                    }
                    if (旧视野房间ID集合.has(房间.id)) {
                        刷新房间内容(房间);
                    }
                });
            }

            function 获取视野内房间ID(中心X, 中心Y) {
                const 视野范围 = 获取玩家视野范围() + 2;
                const 房间ID集合 = new Set();
                const 检查范围 = 视野范围;

                for (let dy = -检查范围; dy <= 检查范围; dy++) {
                    for (let dx = -检查范围; dx <= 检查范围; dx++) {
                        const 检查X = 中心X + dx;
                        const 检查Y = 中心Y + dy;

                        if (
                            检查X >= 0 &&
                            检查X < 地牢大小 &&
                            检查Y >= 0 &&
                            检查Y < 地牢大小
                        ) {
                            const 距离 = Math.abs(dx) + Math.abs(dy);
                            if (距离 <= 视野范围) {
                                const 房间ID = 房间地图[检查Y][检查X];
                                if (房间ID !== -1) {
                                    房间ID集合.add(房间ID);
                                }
                            }
                        }
                    }
                }
                return 房间ID集合;
            }

            function 刷新房间内容(房间) {
                添加日志(`房间 ${房间.id} 的气息变得混乱不清...`, "警告");
                已访问房间.delete(房间.id);

                for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                    for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                        const 单元格 = 地牢[y]?.[x];
                        if (!单元格) continue;

                        if (单元格.关联物品) {
                            const 物品实例 = 单元格.关联物品;
                            if (
                                物品实例 instanceof 钥匙 ||
                                物品实例.类型 === "楼梯"
                            ) {
                                continue;
                            }

                            所有计时器 = 所有计时器.filter(
                                (计时器) =>
                                    计时器.唯一标识 !== 物品实例.唯一标识
                            );

                            if (玩家背包.has(物品实例.唯一标识)) {
                                处理销毁物品(物品实例.唯一标识, true);
                            } else {
                            }
                            单元格.关联物品 = null;
                            单元格.类型 = 单元格.背景类型;
                            单元格.颜色索引 = 颜色表.length;
                        }

                        if (单元格.关联怪物) {
                            const 怪物实例 = 单元格.关联怪物;

                            所有怪物 = 所有怪物.filter((m) => m !== 怪物实例);

                            怪物状态表.delete(怪物实例);

                            怪物实例.血条元素?.remove();
                            单元格.关联怪物 = null;
                        }
                    }
                }

                const 怪物数量 = Math.floor(Math.random() * 3) + 1;
                const 候选怪物 = 怪物池["普通房间"].filter(
                    (m) => 当前层数 >= m.最小层
                );
                if (候选怪物.length > 0) {
                    for (let i = 0; i < 怪物数量; i++) {
                        const 总权重 = 候选怪物.reduce(
                            (sum, m) => sum + m.权重,
                            0
                        );
                        let 随机值 = Math.random() * 总权重;
                        let 选中配置 = 候选怪物[0];
                        for (const m of 候选怪物) {
                            if (随机值 <= m.权重) {
                                选中配置 = m;
                                break;
                            }
                            随机值 -= m.权重;
                        }

                        let 放置成功 = false;
                        for (let 尝试 = 0; 尝试 < 10; 尝试++) {
                            const x =
                                房间.x + Math.floor(Math.random() * 房间.w);
                            const y =
                                房间.y + Math.floor(Math.random() * 房间.h);
                            if (位置是否可用(x, y, false)) {
                                const 新怪物 = new 选中配置.类({
                                    x: x,
                                    y: y,
                                    房间ID: 房间.id,
                                    强化: Math.random() < 0.1,
                                });
                                放置怪物到单元格(新怪物, x, y);
                                放置成功 = true;
                                break;
                            }
                        }
                    }
                }

                if (Math.random() < 0.5) {
                    const 数量 = Math.floor(Math.random() * (5 + 当前层数)) + 1;
                    放置物品到房间(new 金币({ 数量: 数量 }), 房间);
                } else if (Math.random() < 0.3) {
                    生成物品([房间]);
                }
            }
            function 隐藏通知(通知元素) {
                if (!通知元素 || !通知元素.parentElement) return;

                通知元素.classList.add("离场");
                通知元素.addEventListener("animationend", () => {
                    通知元素.remove();

                    const 容器 = document.querySelector(".通知容器");
                    if (容器 && 容器.children.length === 0) {
                        容器.remove();
                    }
                });
            }
            function 添加日志(内容, 类型 = "信息") {
                const 时间戳 = new Date().toLocaleTimeString();
                const 条目 = document.createElement("div");
                条目.className = `日志条目 ${类型}`;
                条目.innerHTML = `<span class="日志时间">[${时间戳}]</span> ${内容}`;

                document.getElementById("logContent").appendChild(条目);

                条目.scrollIntoView({ behavior: "smooth" });
                日志历史.push({ 时间戳, 内容, 类型 });
            }
            function 收纳通知() {
                是否显示通知 = !是否显示通知;
                let 按钮 = document.querySelector(
                    "#设置菜单 button:nth-child(2)"
                );
                if (是否显示通知) {
                    按钮.innerHTML = "收纳通知";
                    显示通知("已重新显示通知", "信息");
                    按钮.textContent = "收纳通知";
                } else {
                    按钮.innerHTML = "显示通知";
                    显示通知("已将通知收纳入日志中", "信息");
                    按钮.textContent = "显示通知";
                }
            }
            function 关闭重铸界面() {
                const 弹窗 = document.querySelector(".重铸弹窗");
                if (!弹窗) return;

                弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
                弹窗.style.opacity = 0;

                document.querySelectorAll(".重铸物品").forEach((el) => {
                    el.__物品实例 = null;
                });

                setTimeout(() => {
                    弹窗.parentElement?.remove();
                    更新背包显示();
                    玩家属性.允许移动 -= 1;
                }, 300);
            }

            function 执行重铸() {
                const 源元素 = document.querySelector("#sourceItems .selected");
                const 材料元素 = document.querySelector(
                    "#materialItems .selected"
                );

                const 源物品 = 源元素?.__物品实例;
                const 材料物品 = 材料元素?.__物品实例;

                if (!源物品 || !材料物品) {
                    显示通知("需要选择两个有效装备", "错误");
                    return;
                }
                if (源物品 === 材料物品) {
                    显示通知("需要选择两个不同装备", "错误");
                    return;
                }
                if (源物品.名称 !== 材料物品.名称) {
                    显示通知("装备名称不一致", "错误");
                    return;
                }

                const 当前耐久 = 源物品.自定义数据.get("耐久");
                const 最大耐久 = 源物品.自定义数据.get("原耐久");
                const 可用空间 = 最大耐久 - 当前耐久;
                const 可转移量 = Math.min(
                    材料物品.自定义数据.get("耐久"),
                    可用空间
                );

                if (可转移量 <= 0) {
                    显示通知(
                        可用空间 <= 0 ? "目标已满耐久" : "材料无可用耐久",
                        "错误"
                    );
                    return;
                }
                const 消耗金币 = 当前重铸台.计算消耗(源物品, 材料物品);
                if (!扣除金币(消耗金币)) {
                    显示通知("金币不足！", "错误");
                    return false;
                }

                源物品.自定义数据.set("耐久", 当前耐久 + 可转移量);
                处理销毁物品(材料物品.唯一标识, true);

                const 剩余耐久 = 当前重铸台.自定义数据.get("耐久") - 1;
                当前重铸台.自定义数据.set("耐久", 剩余耐久);
                当前重铸台.效果描述 = `将同名装备的耐久融合\n剩余耐久：${剩余耐久}/${当前重铸台.自定义数据.get(
                    "最大耐久"
                )}`;

                显示通知(`消耗 ${消耗金币} 金币成功修复！`, "成功");
                关闭重铸界面();
            }
            function 扣除金币(数量) {
                const 可用金币总量 = [...玩家背包.values()]
                    .filter(
                        (i) =>
                            i instanceof 金币 && !i.是否隐藏 && i.堆叠数量 > 0
                    )
                    .reduce((sum, i) => sum + i.堆叠数量, 0);

                if (可用金币总量 < 数量) {
                    return false;
                }

                const 可见金币列表 = [...玩家背包.values()].filter(
                    (i) => i instanceof 金币 && !i.是否隐藏 && i.堆叠数量 > 0
                );

                let 剩余扣除 = 数量;

                for (const 金币实例 of 可见金币列表) {
                    if (剩余扣除 === 0) break;
                    const 本次可扣除 = Math.min(金币实例.堆叠数量, 剩余扣除);
                    金币实例.堆叠数量 -= 本次可扣除;
                    剩余扣除 -= 本次可扣除;

                    if (金币实例.堆叠数量 === 0) {
                        玩家背包.delete(金币实例.唯一标识);
                    }
                }
                return 剩余扣除 === 0;
            }

            function 触发扣血特效() {
                const 特效 = document.getElementById("扣血特效");
                特效.style.animation = "none";
                特效.offsetHeight;
                特效.style.animation = "扣血脉冲 0.8s ease-out";
            }

            let 指示器缓存 = new Map();

            function 计算精确边缘位置(怪物) {
                const 画布 = document.getElementById("dungeonCanvas");
                const 画布Rect = 画布.getBoundingClientRect();

                const 视口左边界 = 当前相机X;
                const 视口右边界 =
                    当前相机X + Math.floor(画布Rect.width / 单元格大小) - 1;
                const 视口上边界 = 当前相机Y;
                const 视口下边界 =
                    当前相机Y + Math.floor(画布Rect.height / 单元格大小) - 1;

                if (
                    怪物.x >= 视口左边界 &&
                    怪物.x <= 视口右边界 &&
                    怪物.y >= 视口上边界 &&
                    怪物.y <= 视口下边界
                ) {
                    return null;
                }

                const 玩家像素X =
                    (玩家.x - 当前相机X) * 单元格大小 + 单元格大小 / 2;
                const 玩家像素Y =
                    (玩家.y - 当前相机Y) * 单元格大小 + 单元格大小 / 2;

                const dx =
                    (怪物.x - 当前相机X) * 单元格大小 +
                    单元格大小 / 2 -
                    玩家像素X;
                const dy =
                    (怪物.y - 当前相机Y) * 单元格大小 +
                    单元格大小 / 2 -
                    玩家像素Y;

                // 计算射线方向向量
                const 方向长度 = Math.sqrt(dx * dx + dy * dy);
                if (方向长度 === 0) return null;
                const dirX = dx / 方向长度;
                const dirY = dy / 方向长度;

                // 计算与画布边界的交点（使用视口实际尺寸）
                const 画布左 = 0;
                const 画布右 = 画布Rect.width;
                const 画布上 = 0;
                const 画布下 = 画布Rect.height;

                let t = Infinity;

                if (dirX < 0) {
                    const tLeft = (画布左 - 玩家像素X) / dirX;
                    const y = 玩家像素Y + dirY * tLeft;
                    if (y >= 画布上 && y <= 画布下) t = tLeft;
                }

                if (dirX > 0) {
                    const tRight = (画布右 - 玩家像素X) / dirX;
                    const y = 玩家像素Y + dirY * tRight;
                    if (y >= 画布上 && y <= 画布下) t = Math.min(t, tRight);
                }

                if (dirY < 0) {
                    const tTop = (画布上 - 玩家像素Y) / dirY;
                    const x = 玩家像素X + dirX * tTop;
                    if (x >= 画布左 && x <= 画布右) t = Math.min(t, tTop);
                }

                if (dirY > 0) {
                    const tBottom = (画布下 - 玩家像素Y) / dirY;
                    const x = 玩家像素X + dirX * tBottom;
                    if (x >= 画布左 && x <= 画布右) t = Math.min(t, tBottom);
                }

                if (t === Infinity) return null;

                // 计算最终交点位置（页面坐标）
                return {
                    x: 玩家像素X + dirX * t + 画布Rect.left,
                    y: 玩家像素Y + dirY * t + 画布Rect.top,
                };
            }

            function 更新物体指示器() {
                const 容器 = document.getElementById("怪物指示器容器");
                const 可见怪物 = new Set();

                所有怪物.forEach((怪物, index) => {
                    if (怪物.状态 !== 怪物状态.活跃) return;
                    if (!怪物.追击玩家中) return;

                    // 计算精确位置，其内部会处理怪物不可见情况
                    const 位置 = 计算精确边缘位置(怪物);
                    if (!位置) {
                        if (指示器缓存.has(index))
                            指示器缓存.get(index).remove();
                        return;
                    }

                    // 创建/更新指示器
                    let 指示器 = 指示器缓存.get(index);
                    if (!指示器) {
                        指示器 = document.createElement("div");
                        指示器.className = "怪物指示器";
                        容器.appendChild(指示器);
                        指示器缓存.set(index, 指示器);
                    }

                    指示器.style.transform = `translate(${位置.x}px, ${位置.y}px)`;
                    可见怪物.add(index);
                });

                // 清理不可见指示器
                指示器缓存.forEach((指示器, key) => {
                    if (!可见怪物.has(key)) {
                        指示器.remove();
                        指示器缓存.delete(key);
                    }
                });
                const 玩家寻宝戒指列表 = Array.from(
                    { length: 装备栏每页装备数 },
                    (_, i) =>
                        玩家装备.get(当前装备页 * 装备栏每页装备数 + i + 1)
                )
                    .filter((v) => v != null)
                    .filter((item) => item instanceof 寻宝戒指);
                let 玩家寻宝戒指 = null;
                if (玩家寻宝戒指列表) {
                    玩家寻宝戒指 = 玩家寻宝戒指列表.find(
                        (item) => item.自定义数据.get("生效层数") === 当前层数
                    );
                } else {
                    const 指示器 = document.querySelector(".折跃门指示器");
                    if (指示器) {
                        指示器.style.display = "none"; // 隐藏
                    }
                }
                if (玩家寻宝戒指) {
                    const 折跃门位置 =
                        玩家寻宝戒指.自定义数据.get("折跃门位置");
                    if (折跃门位置) {
                        const 屏幕位置 = 计算精确边缘位置({
                            x: 折跃门位置.x,
                            y: 折跃门位置.y,
                        });

                        let 指示器 = document.querySelector(".折跃门指示器");
                        if (!指示器) {
                            指示器 = document.createElement("div");
                            指示器.className = "怪物指示器 折跃门指示器"; // 添加额外的类名
                            指示器.style.background = "gold";
                            指示器.style.boxShadow = "0 0 8px gold";
                            容器.appendChild(指示器);
                        }
                        if (屏幕位置) {
                            指示器.style.transform = `translate(${屏幕位置.x}px, ${屏幕位置.y}px)`;
                            指示器.style.display = "block"; // 确保显示
                        } else {
                            指示器.style.display = "none"; // 隐藏
                        }
                    } else {
                        const 指示器 = document.querySelector(".折跃门指示器");
                        if (指示器) {
                            指示器.style.display = "none"; // 隐藏
                        }
                    }
                } else {
                    const 指示器 = document.querySelector(".折跃门指示器");
                    if (指示器) {
                        指示器.style.display = "none"; // 隐藏
                    }
                }
            }
            function hexToRgba(hex, alpha) {
                let r = parseInt(hex.slice(0, 2), 16),
                    g = parseInt(hex.slice(2, 4), 16),
                    b = parseInt(hex.slice(4, 6), 16);

                if (alpha) {
                    return (
                        "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")"
                    );
                } else {
                    return "rgb(" + r + ", " + g + ", " + b + ")";
                }
            }
            // Hex转RGB
            function hexToRgb(hex) {
                hex = hex.replace(/^#/, "");
                if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                }
                const num = parseInt(hex, 16);
                return [(num >> 16) & 0xff, (num >> 8) & 0xff, num & 0xff];
            }
            function blendColors(hexArray) {
                if (hexArray.length === 0) return "#000000"; // 处理空数组情况

                // RGB转HSL
                function rgbToHsl(r, g, b) {
                    (r /= 255), (g /= 255), (b /= 255);
                    const max = Math.max(r, g, b),
                        min = Math.min(r, g, b);
                    let h,
                        s,
                        l = (max + min) / 2;

                    if (max === min) {
                        h = s = 0;
                    } else {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch (max) {
                            case r:
                                h = (g - b) / d + (g < b ? 6 : 0);
                                break;
                            case g:
                                h = (b - r) / d + 2;
                                break;
                            case b:
                                h = (r - g) / d + 4;
                                break;
                        }
                        h *= 60;
                    }
                    return [h, s, l];
                }

                // HSL转RGB
                function hslToRgb(h, s, l) {
                    let r, g, b;
                    if (s === 0) {
                        r = g = b = l; // 灰色
                    } else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1 / 6) return p + (q - p) * 6 * t;
                            if (t < 1 / 2) return q;
                            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                            return p;
                        };
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        r = hue2rgb(p, q, h / 360 + 1 / 3);
                        g = hue2rgb(p, q, h / 360);
                        b = hue2rgb(p, q, h / 360 - 1 / 3);
                    }
                    return [
                        Math.round(r * 255),
                        Math.round(g * 255),
                        Math.round(b * 255),
                    ];
                }

                // RGB转Hex
                function rgbToHex(r, g, b) {
                    return (
                        "#" +
                        [r, g, b]
                            .map((x) => {
                                const hex = x.toString(16);
                                return hex.length === 1 ? "0" + hex : hex;
                            })
                            .join("")
                    );
                }

                // 处理每个Hex颜色
                const hslArray = hexArray.map((hex) => {
                    const [r, g, b] = hexToRgb(hex);
                    return rgbToHsl(r, g, b);
                });

                // 计算平均H（向量平均）
                let sumSin = 0,
                    sumCos = 0;
                for (const [h] of hslArray) {
                    const radians = (h * Math.PI) / 180;
                    sumSin += Math.sin(radians);
                    sumCos += Math.cos(radians);
                }
                const avgH =
                    (Math.atan2(
                        sumSin / hexArray.length,
                        sumCos / hexArray.length
                    ) *
                        180) /
                    Math.PI;
                const normalizedH = (avgH + 360) % 360; // 确保在0-360度之间

                // 计算平均S和L
                const avgS =
                    hslArray.reduce((sum, [, s]) => sum + s, 0) /
                    hexArray.length;
                const avgL =
                    hslArray.reduce((sum, [, , l]) => sum + l, 0) /
                    hexArray.length;

                // 转换回RGB并转为Hex
                const [r, g, b] = hslToRgb(normalizedH, avgS, avgL);
                return rgbToHex(r, g, b);
            }
            function 打开收购窗口(npc) {
                if (界面可见性.背包) 切换背包显示();
                玩家属性.允许移动 += 1;
                NPC互动中 = true; // 标记互动中
                当前NPC = npc; // 保存当前NPC引用

                const 窗口 = document.getElementById("收购窗口");
                const 需求列表容器 = document.getElementById("收购需求列表");
                const 玩家列表容器 = document.getElementById("玩家可售列表");
                const 金币显示 = document.getElementById("收购窗口金币");

                需求列表容器.innerHTML = "";
                玩家列表容器.innerHTML = "";

                金币显示.textContent = [...玩家背包.values()]
                    .filter((i) => i instanceof 金币)
                    .reduce((sum, i) => sum + i.堆叠数量, 0);

                // 显示收购需求
                const 需求 = npc.自定义数据.get("收购需求") || [];
                需求.forEach((req) => {
                    const 元素 = document.createElement("div");
                    元素.className = "收购需求条目";
                    元素.innerHTML = `
                     <span class="需求图标" style="color:${
                         物品池[
                             Object.keys(物品池).find((key) =>
                                 物品池[key].some(
                                     (item) => item.类.name === req.类名
                                 )
                             )
                         ]?.find((item) => item.类.name === req.类名)?.类
                             ?.prototype?.颜色表?.[req.颜色索引] ?? "#FFF"
                     }">${req.图标}</span>
                     <span class="需求名称">${req.名称}${
                        req.强化需求 ? " [强]" : ""
                    } </span>
                     <span class="需求价格">??? 金币</span> <!-- 价格在点击玩家物品时计算 -->
                 `;
                    需求列表容器.appendChild(元素);
                });

                // 显示玩家可出售物品
                玩家背包.forEach((item) => {
                    // 检查是否满足任一收购需求
                    const 匹配需求 = 需求.find(
                        (req) =>
                            item.名称 === req.名称 &&
                            (req.强化需求 ? item.强化 === true : true) // 强化需求匹配
                    );

                    if (匹配需求) {
                        const 价格 = npc.计算收购价格(item, 匹配需求);
                        if (价格 > 0) {
                            // 价格为0表示不满足强化需求等硬性条件
                            const 元素 = document.createElement("div");
                            元素.className = "玩家可售条目";
                            元素.innerHTML = `
                            <span class="物品图标" style="color:${
                                item.颜色表[item.颜色索引] ?? "#FFF"
                            }">${item.图标}</span>
                            <span class="物品名称">${item.获取名称()} ${
                                item.堆叠数量 > 1 ? `x${item.堆叠数量}` : ""
                            }</span>
                            <span class="出售价格">${价格} 金币</span>
                        `;
                            元素.onclick = () => 尝试出售(item, 价格, npc);
                            玩家列表容器.appendChild(元素);
                        }
                    }
                });

                窗口.style.display = "flex"; // 使用 flex 以便内部布局生效
            }

            function 关闭收购窗口() {
                const 窗口 = document.getElementById("收购窗口");
                窗口.classList.add("关闭中");
                setTimeout(() => {
                    窗口.style.display = "none";
                    窗口.classList.remove("关闭中");
                    玩家属性.允许移动 -= 1;
                }, 300);
                NPC互动中 = false; // 结束互动
                当前NPC = null;
            }

            function 尝试出售(物品实例, 价格, npc) {
                if (npc.自定义数据.get("交易次数") <= 0) {
                    显示通知("探险家已经不想再收购了。", "警告");
                    关闭收购窗口();
                    return;
                }

                // 1. 预计算出售后的背包容量变化
                let 潜在空格子 = 0;
                if (物品实例.堆叠数量 === 1) {
                    潜在空格子 = 1; // 如果物品完全移除，会空出一个格子
                }
                const 当前物品数量 = [...玩家背包.values()].reduce(
                    (sum, i) => sum + (i.是否隐藏 ? 0 : 1),
                    0
                );
                const 预计出售后物品数量 = 当前物品数量 - 潜在空格子;

                // 2. 检查是否有足够的空间放金币
                const 金币实例 = [...玩家背包.values()].find(
                    (i) => i instanceof 金币
                );
                let 需要的金币格子 = 0;
                if (金币实例) {
                    const 可堆叠空间 = 最大堆叠数 - 金币实例.堆叠数量;
                    const 剩余金币 = 价格 - Math.min(价格, 可堆叠空间);
                    if (剩余金币 > 0) {
                        需要的金币格子 = Math.ceil(剩余金币 / 最大堆叠数); // 计算需要多少个新格子放剩余金币
                    }
                } else {
                    需要的金币格子 = Math.ceil(价格 / 最大堆叠数); // 没有金币实例，计算需要多少新格子
                }

                // 比较预计的背包占用和最大容量
                if (预计出售后物品数量 + 需要的金币格子 > 最大背包容量) {
                    显示通知("背包空间不足，无法完成交易！", "错误");
                    return; // 出售失败
                }
                if (物品实例.堆叠数量 > 1) {
                    物品实例.堆叠数量 -= 1;
                } else {
                    玩家背包.delete(物品实例.唯一标识);
                    if (物品实例.已装备) {
                        玩家装备.delete(物品实例.装备槽位);
                        物品实例.已装备 = false;
                        物品实例.装备槽位 = null;
                    }
                }

                尝试收集物品(new 金币({ 数量: 价格 }), true); // 直接收集

                npc.自定义数据.set(
                    "交易次数",
                    npc.自定义数据.get("交易次数") - 1
                );

                // 6. 刷新收购窗口内容
                玩家属性.允许移动 -= 1;
                打开收购窗口(npc); // 重新打开以刷新列表和金币

                // 7. 更新UI
                更新背包显示();
                更新装备显示();
                显示通知(
                    `成功出售 ${物品实例.名称}，获得 ${价格} 金币！`,
                    "成功"
                );

                // 8. 如果交易次数用完，自动关闭窗口
                if (npc.自定义数据.get("交易次数") <= 0) {
                    显示通知("探险家满意地离开了。", "信息");
                    关闭收购窗口();
                }
            }
            function 打开交易窗口(npc) {
                if (npc.自定义数据.get("刷新次数") === 0) {
                    显示通知("货物已告罄", "信息");
                    return;
                }
                玩家属性.允许移动 += 1;

                当前NPC = npc;
                const 窗口 = document.getElementById("交易窗口");
                窗口.querySelector("#交易次数").textContent =
                    npc.自定义数据.get("刷新次数");
                窗口.querySelector("#当前金币").textContent = [
                    ...玩家背包.values(),
                ]
                    .filter((i) => i instanceof 金币)
                    .reduce((sum, i) => sum + i.堆叠数量, 0);

                const 库存容器 = 窗口.querySelector(".库存列表");
                库存容器.innerHTML = "";

                npc.自定义数据.get("库存").forEach((物品) => {
                    let 价格 = npc.获取价格(物品);
                    const 元素 = document.createElement("div");
                    元素.className = "交易物品条目";
                    元素.innerHTML = `
            <div class="物品头">
                <span style="color:${
                    物品.颜色表[物品.颜色索引]
                }; font-family: color-emoji">${物品.图标}</span>
                ${物品.获取名称()}
                <span class="物品价格">${价格} 金币</span>
            </div>
            <div class="物品描述">${物品.效果描述 || "神秘物品"}</div>
        `;

                    元素.addEventListener("click", () => 尝试购买(物品, 价格));
                    库存容器.appendChild(元素);
                });

                窗口.style.display = "block";
                窗口.classList.remove("关闭中");
                document.body.appendChild(窗口);
            }

            function 尝试购买(物品, 价格) {
                const npc = 当前NPC;
                const 金币列表 = [...玩家背包.values()].filter(
                    (i) => i instanceof 金币
                );
                const 总金币 = 金币列表.reduce((sum, i) => sum + i.堆叠数量, 0);

                if (总金币 < 价格) {
                    显示通知("金币不足！", "错误");
                    return;
                }
                // 添加物品
                if (物品.类型 === "NPC" && !彩蛋2触发) {
                    显示通知("就是你小子在酒吧里点了一个酒吧!?", "信息", true);
                    彩蛋2触发 = true;
                }
                const 新物品 = 克隆物品(物品);
                if (!尝试收集物品(新物品, true)) {
                    //注意：如果购买物品数量多，则会出现部分成功收集并返回false的情况
                    return;
                }

                if (!扣除金币(价格)) {
                    显示通知("金币不足！", "错误");
                    return;
                }

                // 更新NPC状态
                npc.自定义数据.set(
                    "刷新次数",
                    npc.自定义数据.get("刷新次数") - 1
                );

                更新背包显示();
                显示通知(`购买 ${物品.名称} 成功！`, "成功");
                关闭交易窗口();
            }

            function 关闭交易窗口() {
                document.getElementById("交易窗口").classList.add("关闭中");
                setTimeout(() => {
                    document.getElementById("交易窗口").style.display = "none";
                    玩家属性.允许移动 -= 1;
                }, 300);

                当前NPC = null;
                NPC互动中 = false;
            }

            function 进入教程层() {
                是否为教程层 = true;
                教程阶段 = 0;
                教程提示已显示 = false;
                document.getElementById("跳过教程按钮").style.display = "block";
                生成教程地牢();
                setTimeout(() => {
                    显示教程提示();
                }, 200);
                更新物体指示器();
                所有怪物.forEach((m) => {
                    m.绘制血条();
                });
                绘制();
            }

            function 跳过教程() {
                是否为教程层 = false;
                document.getElementById("跳过教程按钮").style.display = "none";
                所有怪物.forEach((m) => {
                    m.绘制血条(true);
                    if (地牢[m.y] && 地牢[m.y][m.x])
                        地牢[m.y][m.x].关联怪物 = null;
                });
                所有怪物 = [];
                重置玩家状态();
                最高教程阶段 = 6;
                切换楼层(0);
            }

            function 重置玩家状态() {
                最大背包容量 = 12;
                if (当前激活卷轴列表.size > 0) {
                    当前激活卷轴列表.forEach((卷轴) => {
                        当前激活卷轴列表.delete(卷轴);
                        卷轴.卸下();
                    });
                }
                玩家属性 = { ...初始玩家属性 };
                玩家背包.clear();
                玩家装备.clear();
                玩家状态.forEach((m) => {
                    m.移除状态();
                });
                玩家状态 = [];
                // 重置 HUD
                document.querySelector(".health-bar").style.width = "100%";
                document.querySelector(".power-bar").style.width = "100%";
                更新装备显示();
                更新背包显示();
            }

            function 生成教程地牢() {
                地牢 = Array(地牢大小)
                    .fill()
                    .map((_, y) =>
                        Array(地牢大小)
                            .fill()
                            .map((_, x) => new 单元格(x, y))
                    );
                房间列表 = [];
                上锁房间列表 = [];
                所有怪物 = [];
                门实例列表 = new Map();
                房间地图 = Array(地牢大小)
                    .fill()
                    .map(() => Array(地牢大小).fill(-1));
                已访问房间 = new Set();

                const 教程房间配置 = [
                    { x: 10, y: 10, w: 7, h: 5, id: 0, 门: [] }, // 初始房间：移动教学
                    { x: 20, y: 10, w: 7, h: 5, id: 1, 门: [] }, // 背包、装备教学：钢制长剑
                    { x: 30, y: 10, w: 7, h: 5, id: 2, 门: [] }, // 战斗、HUD、互动教学：普通怪物
                    { x: 40, y: 10, w: 7, h: 5, id: 3, 门: [] }, // 上锁房间、药水、强化：上锁的门，房间内有狂暴药水
                    { x: 50, y: 10, w: 7, h: 5, id: 4, 门: [] }, // 卷轴、冰冻怪物：冰冻怪物，清净卷轴（未鉴定）
                    { x: 60, y: 10, w: 7, h: 5, id: 5, 门: [] }, // 新物品：商人、祭坛、宠物
                    { x: 70, y: 10, w: 7, h: 5, id: 6, 门: [] }, // 下楼
                ];

                for (const 房间配置 of 教程房间配置) {
                    房间列表.push(房间配置);
                    放置房间(房间配置);
                }

                for (let i = 0; i < 房间列表.length - 1; i++) {
                    let 路径 = 连接房间(房间列表[i], 房间列表[i + 1]);
                    if (路径) {
                        生成走廊(路径);
                    }
                }
                生成墙壁();

                const 颜色索引 = 3 % 颜色表.length;
                房间列表[3].门.forEach((门) => {
                    const 单元格 = 地牢[门.y][门.x];
                    门实例列表.get(单元格.标识).类型 = "上锁的门";
                    if (单元格.背景类型 === 单元格类型.门) {
                        单元格.背景类型 = 单元格类型.上锁的门;
                        单元格.钥匙ID = 房间列表[3].id;
                        单元格.颜色索引 = 颜色索引;
                    }
                });
                上锁房间列表.push({ ...房间列表[3], 颜色索引 });

                const 第一个房间 = 房间列表[0];
                玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
                玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;
                已访问房间.add(第一个房间.id);

                放置物品到房间(new 钢制长剑({ 不可破坏: true }), 房间列表[1]);
                放置怪物到单元格(
                    new 怪物({
                        掉落概率: 1,
                        基础攻击力: 1,
                        基础生命值: 15,
                        掉落物: new 钥匙({
                            对应门ID: 上锁房间列表[0].id,
                            颜色索引: 上锁房间列表[0].颜色索引,
                            地牢层数: -1,
                        }),
                    }),
                    房间列表[2].x + 3,
                    房间列表[2].y + 2
                );

                放置怪物到单元格(
                    new 怪物({
                        基础攻击力: 1,
                        基础生命值: 15,
                        强化: true,
                        掉落物: new 金币({ 数量: 64 }),
                    }),
                    房间列表[3].x + 3,
                    房间列表[3].y + 2
                );
                放置物品到房间(
                    new 清净卷轴({ 已解锁: false, 强化: true }),
                    房间列表[3]
                );
                放置物品到房间(new 狂暴药水({ 强化: true }), 房间列表[3]);

                放置怪物到单元格(
                    new 冰冻怪物({
                        基础攻击力: 3,
                        基础生命值: 45,
                        掉落物: new 冰盾({}),
                        掉落概率: 1,
                    }),
                    房间列表[4].x + 2,
                    房间列表[4].y + 2
                );
                放置物品到房间(new 神秘商人({}), 房间列表[5]);
                放置物品到房间(new 物品祭坛({}), 房间列表[5]);
                放置物品到房间(new 宠物({}), 房间列表[5]);
                //生成解谜棋盘(房间列表[1]);
                //房间列表[1].类型 = "隐藏解谜棋盘"
                放置楼梯(
                    房间列表[房间列表.length - 1],
                    楼梯图标.下楼,
                    单元格类型.楼梯下楼
                );
                房间列表.forEach((房间) => 更新房间墙壁(房间));
                更新视口();
                绘制();
            }
            function 显示教程提示(强制 = false) {
                if (教程提示已显示 && !强制) return;

                const 提示窗口 = document.getElementById("教程提示窗口");
                const 提示内容元素 = document.getElementById("教程提示内容");

                if (教程阶段 > 最高教程阶段) {
                    最高教程阶段 = 教程阶段;
                }

                let 提示文本 = 获取教程文本(教程阶段);

                if (提示文本 === "未知教程阶段") {
                    提示窗口.style.display = "none";
                    return;
                }

                提示内容元素.innerHTML = 提示文本;
                提示窗口.style.display = "block";
                玩家属性.允许移动++;
                教程提示已显示 = true;
            }

            function 打开教程回放窗口() {
                if (教程提示已显示) 关闭教程提示();
                const 回放窗口 = document.getElementById("教程回放窗口");
                当前回放阶段 = 0;
                显示回放教程页(当前回放阶段);
                回放窗口.style.display = "block";
                玩家属性.允许移动 += 1;

                document.getElementById("上一页教程按钮").onclick = () => {
                    if (当前回放阶段 > 0) {
                        当前回放阶段 = 获取上一个有效阶段(当前回放阶段);
                        显示回放教程页(当前回放阶段);
                    }
                };
                document.getElementById("下一页教程按钮").onclick = () => {
                    const 下一阶段 = 获取下一个有效阶段(当前回放阶段);
                    if (下一阶段 !== null && 下一阶段 <= 最高教程阶段) {
                        当前回放阶段 = 下一阶段;
                        显示回放教程页(当前回放阶段);
                    }
                };
            }

            function 获取上一个有效阶段(当前阶段) {
                let 上一阶段 = 当前阶段;
                do {
                    if (上一阶段 === 2.5) 上一阶段 = 2;
                    else 上一阶段 = Math.floor(上一阶段 - 1);
                } while (
                    上一阶段 > 0 &&
                    获取教程文本(上一阶段) === "未知教程阶段"
                );
                return Math.max(0, 上一阶段);
            }

            function 获取下一个有效阶段(当前阶段) {
                let 下一阶段 = 当前阶段;
                do {
                    if (下一阶段 === 2) 下一阶段 = 2.5;
                    else 下一阶段 = Math.ceil(下一阶段 + 1);
                } while (
                    获取教程文本(下一阶段) === "未知教程阶段" &&
                    下一阶段 <= 6
                ); // 假设最大阶段是6

                return 下一阶段 <= 6 ? 下一阶段 : null; // 如果超过最大阶段，返回null
            }

            function 显示回放教程页(阶段) {
                const 内容元素 = document.getElementById("教程回放内容");
                const 页码元素 = document.getElementById("教程页码");
                const 上一页按钮 = document.getElementById("上一页教程按钮");
                const 下一页按钮 = document.getElementById("下一页教程按钮");

                内容元素.innerHTML = 获取教程文本(阶段);

                let 当前页码 = 1;
                let 总页数 = 1;
                let temp阶段 = 0;
                while (temp阶段 < 最高教程阶段) {
                    const 下一阶段 = 获取下一个有效阶段(temp阶段);
                    if (下一阶段 === null || 下一阶段 > 最高教程阶段) break;
                    总页数++;
                    if (下一阶段 <= 阶段) 当前页码++;
                    temp阶段 = 下一阶段;
                }

                页码元素.textContent = `${当前页码} / ${总页数}`;

                上一页按钮.disabled = 阶段 <= 0;
                const 下一阶段 = 获取下一个有效阶段(阶段);
                下一页按钮.disabled =
                    下一阶段 === null || 下一阶段 > 最高教程阶段;
            }

            function 关闭教程回放窗口() {
                const 回放窗口 = document.getElementById("教程回放窗口");
                回放窗口.classList.add("关闭中"); // 复用关闭动画类
                setTimeout(() => {
                    回放窗口.style.display = "none";
                    回放窗口.classList.remove("关闭中");
                }, 300);
                玩家属性.允许移动 -= 1;
            }
            function 获取教程文本(阶段) {
                let 提示文本 = "";
                const isMobile = window.innerWidth < 769;

                switch (阶段) {
                    case 0:
                        提示文本 = isMobile
                            ? `欢迎来到中文地牢！<br>
                <b>基础移动：</b><br>
                - 长按方向键可以连续移动。<br>
                - 直接点击地图上的目标位置，角色会自动寻路。<br>
                <br>
                <b>注意：</b>长按移动会忽略攻击和互动，适合快速探索。<br>
                <b>兼容模式:</b>如果 emoji 无法显示，可以点击设置按钮⚙️再点击'切换为中文模式'按钮`
                            : `欢迎来到中文地牢！<br>
                <b>基础移动：</b><br>
                - 使用 W (上)、A (左)、S (下)、D (右) 键 或 ↑↓←→ 方向键移动。<br>
                - 直接点击地图上的目标位置，角色会自动寻路。<br>
                <br>
                <b>兼容模式:</b>如果 emoji 无法显示，可以按 - 键切换成汉字模式`;
                        break;
                    case 1:
                        提示文本 = isMobile
                            ? `<b>背包与装备：</b><br>
                - 打开背包：点击屏幕下方的背包图标 ${图标映射.背包按钮}。<br>
                - 背包功能：<br>
                    - 点击物品：使用、丢弃或装备物品。丢弃的物品按互动键可以捡回。<br>
                    - 装备武器：点击武器，再点击“装备”按钮（${图标映射.装备按钮}）。<br>
                   
                - 装备栏 (屏幕右下角的“田”字格)：<br>
                    - 单击装备槽内物品以使用，左右滑动可以换页<br>
                请尝试打开背包，装备上你找到的钢制长剑。`
                            : `<b>背包与装备：</b><br>
                - 打开背包：按 E 键。<br>
                - 背包功能：<br>
                    - 点击物品：使用、丢弃或装备物品。丢弃的物品按互动键可以捡回。<br>
                    - 装备武器：点击武器，再点击“装备”按钮（${图标映射.装备按钮}）。<br>
                  
                - 装备栏 (屏幕右下角的“田”字格)：<br>
                    - 使用数字键 1-4 使用对应槽位物品，右键卸下，J、K键可以换页。<br>
                请尝试打开背包，装备上你找到的钢制长剑。`;
                        break;
                    case 2: // 进入房间时的提示
                        提示文本 = isMobile
                            ? `<b>战斗与HUD：</b><br>
                - HUD（屏幕左上角）：<br>
                     - 显示/隐藏：点击眼睛图标 ${图标映射.HUD智能} 按钮。<br>
                    - ❤️ 生命条：显示你的生命值。<br>
                    - ⚡ 能量条：显示你的能量值（使用卷轴等特殊物品会消耗）。<br>
                - 武器有冷却时间与耐久，耐久即将耗尽时可以停止使用，后续等待机会修补<br>
                <b>战斗：</b><br>
                - 靠近怪物，使用已装备的武器攻击它（点击装备栏中武器）。<br>
                - 击败怪物可获得战利品。<br>`
                            : `<b>战斗与HUD：</b><br>
                - HUD（屏幕左上角）：<br>
                    - 显示/隐藏：按 Q 键。<br>
                    - ❤️ 生命条：显示你的生命值。<br>
                    - ⚡ 能量条：显示你的能量值（使用卷轴等特殊物品会消耗）。<br>
                 - 武器有冷却时间与耐久，耐久即将耗尽时可以停止使用，后续等待机会修补<br>
                <b>战斗：</b><br>
                - 靠近怪物，使用已装备的武器攻击它（按对应数字键）。<br>
                - 击败怪物可获得战利品。<br>`;
                        break;

                    case 2.5: // 击败怪物后的提示
                        提示文本 = isMobile
                            ? `<b>互动：</b><br>
                - 点击屏幕下方的互动按钮 ${图标映射.互动按钮}。<br>
                - 互动功能：<br>
                    - 拾取周围的物品（直接走到物品的格子上也可以拾取）。<br>
                    - 打开上锁的门（需要拥有对应颜色的钥匙）。<br>
                    - 与 NPC、祭坛等互动。<br>
                    - 自动选择武器并攻击范围内的敌人。<br>
                 <b>提示：</b>掉落的钥匙有光晕，门的颜色和钥匙发出的光晕的颜色要一致才能解锁。<br>
                 请使用互动键拾取钥匙,并尝试打开下一道门.`
                            : `<b>互动：</b><br>
                - 按 F 键。<br>
                - 互动功能：<br>
                    - 拾取周围的物品（直接走到物品的格子上也可以拾取）。<br>
                    - 打开上锁的门（需要拥有对应颜色的钥匙）。<br>
                    - 与 NPC、祭坛等互动。<br>
                    - 自动选择武器并攻击范围内的敌人。<br>
                <b>提示：</b>掉落的钥匙有光晕，门的颜色和钥匙发出的光晕的颜色要一致才能解锁。<br>
                 请使用互动键拾取钥匙,并尝试打开下一道门.`;
                        break;
                    case 3:
                        提示文本 = `你成功打开了上锁的房间！<br>
                <b>强化物品：</b><br>
                - 上锁房间内通常有更高品质的物品，它们带有强化效果，属性更强。<br>
                - 注意：怪物也会被强化！<br>
                <br>
                <b>药水：</b><br>
                - 药水有持续时间，效果会在一定回合后消失。<br>
                - 在关键时候打开背包使用药水,它可以救你一命！`;
                        break;
                    case 4:
                        提示文本 = isMobile
                            ? `<b>卷轴与能量：</b><br>
                - 卷轴是强大的消耗品，但使用需要消耗能量，能量条在左上角的HUD中显示，并随玩家移动恢复。<br>
                - 卷轴使用方法：<br>
                    1. 装备：打开背包(${图标映射.背包按钮})，点击卷轴，再点击“装备”按钮(${图标映射.装备按钮})。<br>
                    2. 激活：点击屏幕下方的卷轴图标 ${图标映射.卷轴按钮} 按钮,再点击装备栏中高亮的卷轴。<br>
                - 你获得的清净卷轴可以移除自身的所有状态效果。<br>
                - 卷轴需要使用特殊卷轴解读后才能知道效果。<br>
                - 激活后再点击装备槽中高亮的卷轴可以取消激活`
                            : `<b>卷轴与能量：</b><br>
                - 卷轴是强大的消耗品，但使用需要消耗能量，能量条在左上角的HUD中显示。玩家移动/探索房间/击杀怪物均可恢复能量，但是只依靠玩家移动恢复能量是不可取的。<br>
                - 卷轴使用方法：<br>
                    1. 装备：打开背包(E)，点击卷轴，再点击“装备”按钮(${图标映射.装备按钮})。<br>
                    2. 激活：按 R 键。<br>
                 - 你获得的清净卷轴可以移除自身的所有状态效果。<br>
                - 卷轴需要使用特殊卷轴解读后才能知道效果。<br>
                - 激活后再点击装备槽中高亮的卷轴可以取消激活`;
                        break;

                    case 5:
                        提示文本 = `<b>探索更多：</b><br>
               这个房间里有一些特殊的物品，为你展示地牢物品的多样。<br>
                如果背包已满，你可以尝试丢掉一些物品或将它们装备给宠物。<br>
                如果装备槽已满，长按或右键已装备物品可以将其卸下<br>
                遇到未知物品尝试与其互动 或 拾起后在背包中使用。`;
                        break;
                    case 6:
                        提示文本 = isMobile
                            ? `<b>开始游戏：</b><br>
                点击设置⚙️可以打开功能菜单<br>
                - 地牢有很多层，每层都有不同的怪物和宝藏。<br>
                - 找到并走下楼梯 ${图标映射.下楼楼梯} 即可进入下一层，开始你的冒险！`
                            : `<b>开始游戏：</b><br>
                按 G 键可以打开日志界面。<br>
                按 Z 键可以导出存档。<br>
                按 U 键可以自杀。<br>
                - 地牢有很多层，每层都有不同的怪物和宝藏。<br>
                - 找到并走下楼梯 ${图标映射.下楼楼梯} 即可进入下一层，开始你的冒险！`;
                        break;
                    default:
                        提示文本 = "未知教程阶段"; // 或者返回空字符串
                }
                return 提示文本;
            }
            function 关闭教程提示() {
                const 提示窗口 = document.getElementById("教程提示窗口");
                if (提示窗口) {
                    提示窗口.classList.add("关闭中");
                    教程提示已显示 = false;
                    setTimeout(() => {
                        提示窗口.style.display = "none";
                        提示窗口.classList.remove("关闭中");
                        玩家属性.允许移动 -= 1;
                        玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
                    }, 300);
                }
            }

            const 安全参数 = {
                方程组: [
                    {
                        a: 7,
                        b: 3,
                        c: 2,
                        d: 5,
                    },
                    {
                        a: 4,
                        b: 9,
                        c: 6,
                        d: 8,
                    },
                ],
                模数: 9973,
            };

            function 生成死亡凭证(L) {
                let R;
                do {
                    // R ≡ (L^2 + 1) mod 13
                    const 基础值 = (L * L + 1) % 13;
                    R =
                        基础值 +
                        Math.floor(Math.random() * (安全参数.模数 - 基础值)) *
                            13;
                } while (R >= 安全参数.模数 || R === 0);

                const 方程计算 = (系数, L, R) => {
                    const 项1 = 系数.a * L;
                    const 项2 = 系数.b * R * R;
                    const 项3 = 系数.c * L * R;
                    const 项4 = 系数.d * R * R * R;
                    return (项1 + 项2 + 项3 + 项4) % 安全参数.模数;
                };

                const C1 = 方程计算(安全参数.方程组[0], L, R);
                const C2 = 方程计算(安全参数.方程组[1], L, R);

                const 组件 = [
                    L.toString().padStart(3, "0"),
                    R.toString().padStart(4, "0"),
                    (C1 + C2).toString().padStart(3, "0"),
                ];

                return 组件.join("-");
            }

            function 验证死亡凭证(凭证, 待验层数) {
                const [L部分, R部分, C部分] = 凭证.split("-");
                const L = parseInt(L部分);
                const R = parseInt(R部分);
                const 总校验码 = parseInt(C部分);

                if (L !== 待验层数 || R <= 0 || R >= 安全参数.模数)
                    return false;

                // R ≡ (L² +1) mod 13
                if (R % 13 !== (L * L + 1) % 13) return false;

                const 方程计算 = (系数, L, R) => {
                    const 计算值 =
                        系数.a * L +
                        系数.b * R * R +
                        系数.c * L * R +
                        系数.d * R * R * R;
                    return 计算值 % 安全参数.模数;
                };

                const 真实C1 = 方程计算(安全参数.方程组[0], L, R);
                const 真实C2 = 方程计算(安全参数.方程组[1], L, R);

                return 真实C1 + 真实C2 === 总校验码;
            }

            function CopyTextToClipboard(val) {
                const textArea = document.createElement("textArea");
                textArea.value = val;
                textArea.style.width = 0;
                textArea.style.position = "fixed";
                textArea.style.left = "-999px";
                textArea.style.top = "10px";
                textArea.setAttribute("readonly", "readonly");
                document.body.appendChild(textArea);

                textArea.select();
                document.execCommand("copy");
                document.body.removeChild(textArea);
            }
            function 获取附魔描述(enchantments) {
                const numberToRoman = (num) => {
                    const romanMap = {
                        1: "I",
                        2: "II",
                        3: "III",
                        4: "IV",
                        5: "V",
                        6: "VI",
                        7: "VII",
                        8: "VIII",
                        9: "IX",
                        10: "X",
                    };
                    return romanMap[num] || "";
                };

                return enchantments
                    .map((enchant) => {
                        const romanLevel = numberToRoman(enchant.等级);
                        return `[${enchant.种类}] ${romanLevel}级`;
                    })
                    .join("\n");
            }

            function 切换设置菜单() {
                const 菜单 = document.getElementById("设置菜单");
                if (菜单.classList.contains("显示")) {
                    菜单.classList.remove("显示");
                    菜单.classList.add("隐藏"); // 添加隐藏类以触发动画
                    setTimeout(() => {
                        菜单.classList.remove("隐藏");
                        玩家属性.允许移动 -= 1;
                    }, 300);
                } else {
                    菜单.classList.remove("隐藏");
                    菜单.classList.add("显示");
                    玩家属性.允许移动 += 1;
                }
            }

            function 关闭设置菜单() {
                const 菜单 = document.getElementById("设置菜单");
                菜单.classList.remove("显示");
                菜单.classList.add("隐藏"); // 添加隐藏类以触发动画
                setTimeout(() => {
                    菜单.classList.remove("隐藏");
                    玩家属性.允许移动 -= 1;
                    玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
                }, 300);
            }

            function 更新视口() {
                let 原始目标X = 玩家.x - 7;
                let 原始目标Y = 玩家.y - 7;

                原始目标X = Math.max(0, Math.min(原始目标X, 地牢大小 - 15));
                原始目标Y = Math.max(0, Math.min(原始目标Y, 地牢大小 - 15));

                // 缓动更新目标
                if (相机目标X !== 原始目标X || 相机目标Y !== 原始目标Y) {
                    相机锁定 = true;
                    相机目标X = 原始目标X;
                    相机目标Y = 原始目标Y;
                }
            }
            function 动画帧() {
                // 插值
                const dx = 相机目标X - 当前相机X;
                const dy = 相机目标Y - 当前相机Y;

                当前相机X += dx * 相机移动速度;
                当前相机Y += dy * 相机移动速度;
                const 当前时间 = Date.now();
                // 检测移动完成
                if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) {
                    当前相机X = 相机目标X;
                    当前相机Y = 相机目标Y;

                    更新物体指示器();
                }
                if (待显示格子特效队列.length > 0) {
                    for (let i = 待显示格子特效队列.length - 1; i >= 0; i--) {
                        const 路径数据 = 待显示格子特效队列[i];
                        显示格子特效(
                            路径数据.路径,
                            路径数据.颜色,
                            路径数据.间隔
                        );
                    }
                    待显示格子特效队列 = [];
                }

                if (活动DOM特效.length > 0) {
                    const 画布RectUpdate = canvas.getBoundingClientRect(); // 获取最新的画布位置信息
                    活动DOM特效.forEach((item) => {
                        // 检查元素是否还存在于 DOM 中，防止意外移除导致错误
                        if (document.body.contains(item.element)) {
                            // 使用平滑插值的相机位置 (当前相机X/Y) 计算屏幕坐标
                            const 屏幕X =
                                (item.worldX - 当前相机X) * 单元格大小;
                            const 屏幕Y =
                                (item.worldY - 当前相机Y) * 单元格大小;
                            // 更新 DOM 元素的屏幕位置
                            item.element.style.left = `${
                                屏幕X + 画布RectUpdate.left
                            }px`;
                            item.element.style.top = `${
                                屏幕Y + 画布RectUpdate.top
                            }px`;
                        } else {
                            // 如果元素意外地不在 DOM 中了，从跟踪数组中清理掉
                            活动DOM特效 = 活动DOM特效.filter(
                                (trackedItem) =>
                                    trackedItem.element !== item.element
                            );
                        }
                    });
                }
                所有怪物.forEach((怪物) => {
                    const 动画状态 = 怪物动画状态.get(怪物);
                    if (动画状态?.正在动画) {
                        const 已过时间 = 当前时间 - 动画状态.动画开始时间;
                        const t = Math.min(1, 已过时间 / 怪物移动动画时长); // 插值因子 (0 到 1)

                        // 使用线性插值计算视觉逻辑坐标
                        动画状态.视觉X =
                            动画状态.旧逻辑X +
                            (动画状态.目标逻辑X - 动画状态.旧逻辑X) * t;
                        动画状态.视觉Y =
                            动画状态.旧逻辑Y +
                            (动画状态.目标逻辑Y - 动画状态.旧逻辑Y) * t;

                        // 如果动画完成
                        if (t >= 1) {
                            动画状态.正在动画 = false;
                            动画状态.视觉X = 动画状态.目标逻辑X; // 确保最终位置精确
                            动画状态.视觉Y = 动画状态.目标逻辑Y;
                        }
                    }
                });
                if (待显示爆炸范围.length > 0) {
                    const 画布RectExplosion = canvas.getBoundingClientRect();

                    待显示爆炸范围.forEach((explosionData) => {
                         if (explosionData && explosionData.爆炸范围.length > 0) {
                            explosionData.爆炸范围.forEach(({ x, y, 距离 }) => {
                                const 屏幕X = (x - 当前相机X) * 单元格大小;
                                const 屏幕Y = (y - 当前相机Y) * 单元格大小;
                                if (
                                    屏幕X + 单元格大小 < 0 || 
                                    屏幕X > 画布RectExplosion.width || 
                                    屏幕Y + 单元格大小 < 0 || 
                                    屏幕Y > 画布RectExplosion.height
                                ) {
                                    return;
                                }
                                const 特效 = document.createElement("div");
                                特效.style.cssText = `
                                    position: absolute;
                                    left: ${屏幕X + 画布RectExplosion.left}px;
                                    top: ${屏幕Y + 画布RectExplosion.top}px;
                                    width: ${单元格大小}px;
                                    height: ${单元格大小}px;
                                    background: ${获取爆炸颜色(距离, explosionData.范围)};
                                    opacity: 0.7;
                                    animation: 爆炸闪烁 ${0.4 + (距离 / explosionData.范围) * 0.1}s;
                                    pointer-events: none;
                                    z-index: 999;
                                `;

                                document.body.appendChild(特效);

                                const worldX = x;
                                const worldY = y;
                                const effectData = {
                                    element: 特效,
                                    worldX: worldX,
                                    worldY: worldY,
                                };
                                活动DOM特效.push(effectData);

                                setTimeout(() => {
                                    特效.remove();
                                    活动DOM特效 = 活动DOM特效.filter(
                                        (item) => item.element !== 特效
                                    );
                                }, 500); 
                            });
                        }
                    });

                    待显示爆炸范围 = [];
                }

                if (
                    (游戏状态 === "图鉴" || 游戏状态 === "游戏中") &&
                    当前时间 - 上次自动回合时间 >= 自动回合间隔 &&
                    切换动画
                ) {
                    if (!死亡界面已显示 && 玩家属性.允许移动 === 0) {
                        处理回合逻辑();
                        上次自动回合时间 = 当前时间;
                    }
                }

                // 更新整数视口
                视口偏移X = Math.floor(当前相机X);
                视口偏移Y = Math.floor(当前相机Y);

                绘制();
                requestAnimationFrame(动画帧);
            }
            function 获取爆炸颜色(距离) {
                const 渐变 = [
                    "radial-gradient(circle, #ff0000 0%, #ff4500 70%, transparent 100%)",
                    "radial-gradient(circle, #ff4500 0%, #ff8c00 70%, transparent 100%)",
                    "radial-gradient(circle, #ff8c00 0%, #ffd700 70%, transparent 100%)",
                ];
                return 渐变[Math.min(距离, 2)];
            }
            function 绘制() {
                
                const 缓冲区域 = 2;
                const 起始X = Math.max(0, Math.floor(当前相机X - 缓冲区域));
                const 结束X = Math.min(
                    地牢大小,
                    起始X + 相机显示边长 + 缓冲区域 * 2
                );
                const 起始Y = Math.max(0, Math.floor(当前相机Y - 缓冲区域));
                const 结束Y = Math.min(
                    地牢大小,
                    起始Y + 相机显示边长 + 缓冲区域 * 2
                );
                const 清理X = (起始X - 当前相机X) * 单元格大小 - 单元格大小;
                const 清理Y = (起始Y - 当前相机Y) * 单元格大小 - 单元格大小;
                const 清理宽 = (结束X - 起始X + 2) * 单元格大小;
                const 清理高 = (结束Y - 起始Y + 2) * 单元格大小;
                ctx.clearRect(清理X, 清理Y, 清理宽, 清理高);

                const 小数偏移X = (当前相机X % 1) * 单元格大小;
                const 小数偏移Y = (当前相机Y % 1) * 单元格大小;

                for (let y = 起始Y; y < 结束Y; y++) {
                    for (let x = 起始X; x < 结束X; x++) {
                        if (地牢.length > 0) {
                            地牢[y][x]?.绘制();
                        }
                    }
                }
                const 玩家屏幕X = (玩家.x - 当前相机X + 0.5) * 单元格大小;
                const 玩家屏幕Y = (玩家.y - 当前相机Y + 0.5) * 单元格大小;
                if (moveQueue.length > 0) {
                    drawPath(moveQueue);
                }
                const hexArray_ = [];
                if (玩家状态.length > 0) {
                    玩家状态.forEach((item) => {
                        hexArray_.push(item.颜色);
                    });
                    ctx.fillStyle = blendColors(hexArray_);
                } else {
                    ctx.fillStyle = "#ff4444";
                }
                ctx.beginPath();
                ctx.arc(玩家屏幕X, 玩家屏幕Y, 单元格大小 / 3, 0, Math.PI * 2);

                ctx.fill();
                ctx.stroke();
                所有怪物.forEach((怪物实例) => {
                    const 动画状态 = 怪物动画状态.get(怪物实例);
                    let 绘制逻辑X = 怪物实例.x;
                    let 绘制逻辑Y = 怪物实例.y;

                    if (动画状态?.正在动画) {
                        绘制逻辑X =
                            动画状态.视觉X !== undefined
                                ? 动画状态.视觉X
                                : 怪物实例.x;
                        绘制逻辑Y =
                            动画状态.视觉Y !== undefined
                                ? 动画状态.视觉Y
                                : 怪物实例.y;
                    }

                    const 怪物视口X = 绘制逻辑X - 视口偏移X;
                    const 怪物视口Y = 绘制逻辑Y - 视口偏移Y;
                    const 怪物所在房间ID = 房间地图[怪物实例.y]?.[怪物实例.x];
                    const 怪物所在房间 =
                        怪物所在房间ID !== -1 ? 房间列表[怪物所在房间ID] : null;
                    if (
                        怪物视口X >= -缓冲区域 &&
                        怪物视口X < 相机显示边长 + 缓冲区域 &&
                        怪物视口Y >= -缓冲区域 &&
                        怪物视口Y < 相机显示边长 + 缓冲区域 &&
                        (怪物实例.隐身中 ?? false) === false &&
                        (怪物所在房间ID === -1 ||
                            已访问房间.has(怪物所在房间ID) ||
                            游戏状态 === "图鉴") &&
                        !(
                            (玩家状态.some(s => s.类型 === '失明') || 当前天气效果.includes("深夜") ||
                                (怪物所在房间 &&
                                    怪物所在房间.类型 === "黑暗房间")) &&
                            !是否在光源范围内(怪物实例.x, 怪物实例.y)
                        )
                    ) {
                        const 怪物屏幕X =
                            (绘制逻辑X - 当前相机X + 0.5) * 单元格大小;
                        const 怪物屏幕Y =
                            (绘制逻辑Y - 当前相机Y + 0.5) * 单元格大小;

                        ctx.font = `${单元格大小 * 0.8}px color-emoji`;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";

                        // 设置绘制颜色
                        if (怪物实例.受击动画) {
                            ctx.fillStyle = "#FF0000";
                        } else {
                            ctx.fillStyle = 怪物实例.颜色 || "#FFFFFF";
                        }

                        // 绘制怪物图标
                        ctx.fillText(怪物实例.图标, 怪物屏幕X, 怪物屏幕Y);

                        const 怪物当前状态 = 怪物状态表.get(怪物实例);
                        if (怪物当前状态) {
                            ctx.fillStyle = 怪物当前状态.颜色 || "#FFFFFF";
                            ctx.font = `${单元格大小 * 0.5}px Arial`;
                            const 状态图标X = 怪物屏幕X + 单元格大小 * 0.3;
                            const 状态图标Y = 怪物屏幕Y - 单元格大小 * 0.3;
                            ctx.fillText(
                                怪物当前状态.图标 || "?",
                                状态图标X,
                                状态图标Y
                            );
                        } else if (怪物实例.强化 && 怪物实例.类型 != "伪装怪物") {
                            ctx.fillStyle = "#FF0000";
                            ctx.font = `${单元格大小 * 0.5}px Arial`;
                            const 强化标记X = 怪物屏幕X + 单元格大小 * 0.3;
                            const 强化标记Y = 怪物屏幕Y - 单元格大小 * 0.3;
                            ctx.fillText("强", 强化标记X, 强化标记Y);
                        }
                        怪物实例.绘制血条();
                    }
                });
                
                绘制小地图();
            }
            function 绘制小地图() {
                if (
                    当前天气效果.includes("诡魅") ||
                    当前天气效果.includes("深夜")
                ) {
                    小地图Ctx.fillStyle = "#000000";
                    小地图Ctx.fillRect(0, 0, 小地图.width, 小地图.height);

                    小地图Ctx.fillStyle = "#555";
                    小地图Ctx.font = "20px Arial";
                    小地图Ctx.textAlign = "center";
                    小地图Ctx.textBaseline = "middle";
                    小地图Ctx.fillText(
                        "地图受到干扰",
                        小地图.width / 2,
                        小地图.height / 2
                    );
                    return;
                }
                const 缩放比例 = 3;
                小地图Ctx.fillStyle = "#1a1a1a";
                小地图Ctx.fillRect(0, 0, 小地图.width, 小地图.height);
                if (地牢.length > 0) {
                    for (let y = 0; y < 地牢大小; y++) {
                        for (let x = 0; x < 地牢大小; x++) {
                            const 物品 = 地牢[y][x]?.关联物品;
                            if (
                                物品 &&
                                (物品 instanceof 护卫植物 ||
                                    物品 instanceof 远射植物) &&
                                已访问房间.has(房间地图[y][x])
                            ) {
                                小地图Ctx.fillStyle = "#228B22";
                                小地图Ctx.beginPath();
                                小地图Ctx.arc(
                                    x * 缩放比例 + 缩放比例 / 2,
                                    y * 缩放比例 + 缩放比例 / 2,
                                    缩放比例 * 0.7,
                                    0,
                                    Math.PI * 2
                                );
                                小地图Ctx.fill();
                            }
                            if (地牢[y][x]?.背景类型 === 单元格类型.走廊) {
                                小地图Ctx.strokeStyle = "#666666";

                                小地图Ctx.strokeRect(
                                    x * 缩放比例,
                                    y * 缩放比例,
                                    缩放比例,
                                    缩放比例
                                );
                            }
                        }
                    }
                }

                房间列表.forEach((房间) => {
                    const 已访问 = 已访问房间.has(房间.id);
                    const 是上锁房间 = 上锁房间列表.some(
                        (r) => r.id === 房间.id
                    );

                    if (是上锁房间) {
                        const 颜色索引 = 上锁房间列表.find(
                            (r) => r.id === 房间.id
                        ).颜色索引;
                        小地图Ctx.strokeStyle = 颜色表[颜色索引] || "#FFD700";
                    } else {
                        小地图Ctx.strokeStyle = 已访问 ? "#4caf50" : "#666666";
                    }

                    小地图Ctx.strokeRect(
                        房间.x * 缩放比例,
                        房间.y * 缩放比例,
                        房间.w * 缩放比例,
                        房间.h * 缩放比例
                    );

                    if (已访问) {
                        小地图Ctx.fillStyle = "#4caf5022";
                        小地图Ctx.fillRect(
                            房间.x * 缩放比例,
                            房间.y * 缩放比例,
                            房间.w * 缩放比例,
                            房间.h * 缩放比例
                        );
                    }
                });
                传送点列表.forEach((点) => {
                    if (点.层数 === 当前层数) {
                        const 传送点X = 点.x * 缩放比例 + 缩放比例 / 2;
                        const 传送点Y = 点.y * 缩放比例 + 缩放比例 / 2;
                        const 半径 = 缩放比例 * 0.8;

                        小地图Ctx.shadowColor = "#FF00FF";
                        小地图Ctx.shadowBlur = 8;

                        小地图Ctx.fillStyle = "#FF00FF";
                        小地图Ctx.beginPath();
                        小地图Ctx.arc(传送点X, 传送点Y, 半径, 0, Math.PI * 2);
                        小地图Ctx.fill();

                        小地图Ctx.shadowBlur = 0;
                        小地图Ctx.fillStyle = "#FFFFFF";
                        小地图Ctx.beginPath();
                        小地图Ctx.arc(
                            传送点X,
                            传送点Y,
                            半径 * 0.3,
                            0,
                            Math.PI * 2
                        );
                        小地图Ctx.fill();
                    }
                });

                if (上次死亡地点 && 上次死亡地点.层数 === 当前层数) {
                    const 死亡X = 上次死亡地点.x * 缩放比例;
                    const 死亡Y = 上次死亡地点.y * 缩放比例;
                    const 标记尺寸 = 缩放比例 * 2.5;

                    小地图Ctx.shadowColor = "rgba(255, 0, 0, 0.8)";
                    小地图Ctx.shadowBlur = 10;

                    小地图Ctx.fillStyle = "rgba(200, 0, 0, 0.8)";
                    小地图Ctx.beginPath();
                    小地图Ctx.arc(
                        死亡X + 缩放比例 / 2,
                        死亡Y + 缩放比例 / 2,
                        标记尺寸 * 0.5,
                        0,
                        Math.PI * 2
                    );
                    小地图Ctx.fill();

                    小地图Ctx.shadowBlur = 0;

                    小地图Ctx.font = `${标记尺寸 * 0.8}px color-emoji`;
                    小地图Ctx.textAlign = "center";
                    小地图Ctx.textBaseline = "middle";
                    小地图Ctx.fillStyle = "#FFFFFF";
                    小地图Ctx.fillText(
                        图标映射.死亡图标,
                        死亡X + 缩放比例 / 2,
                        死亡Y + 缩放比例 / 2 + 标记尺寸 * 0.05
                    );
                }

                小地图Ctx.shadowColor = "transparent";
                小地图Ctx.shadowBlur = 0;

                小地图Ctx.fillStyle = "#ff0000";
                小地图Ctx.beginPath();
                小地图Ctx.arc(
                    玩家.x * 缩放比例,
                    玩家.y * 缩放比例,
                    Math.max(3, 缩放比例 / 2),
                    0,
                    Math.PI * 2
                );
                小地图Ctx.fill();
                小地图Ctx.strokeStyle = "#ffffff";
                小地图Ctx.lineWidth = 2;
                小地图Ctx.stroke();

                const 视野半径 = Math.floor(相机显示边长 / 2);
                const 视野框X = (玩家.x - 视野半径) * 缩放比例;
                const 视野框Y = (玩家.y - 视野半径) * 缩放比例;
                const 视野框尺寸 = 相机显示边长 * 缩放比例;

                小地图Ctx.strokeStyle = "#ffd700";
                小地图Ctx.lineWidth = 1;
                小地图Ctx.strokeRect(视野框X, 视野框Y, 视野框尺寸, 视野框尺寸);
            }
            async function startAutoMove() {
                if (moveQueue.length === 0) return;
                const moveInterval = setInterval(() => {
                    if (moveQueue.length === 0) {
                        clearInterval(moveInterval);
                        return;
                    }
                    if (玩家属性.允许移动 === 0) {
                        let targetIndex = Math.min(
                            玩家属性.移动步数 - 1,
                            moveQueue.length - 1
                        );
                        let validMove = true;
                        // 检查直线可行性
                        for (let i = 0; i <= targetIndex; i++) {
                            if (
                                !检查直线移动可行性(
                                    玩家.x,
                                    玩家.y,
                                    moveQueue[i].x,
                                    moveQueue[i].y
                                )
                            ) {
                                targetIndex = i - 1;
                                validMove = false;
                                break;
                            }
                        }
                        if (targetIndex >= 0 && validMove) {
                            const target = moveQueue[targetIndex];
                            移动玩家(
                                target.x - 玩家.x,
                                target.y - 玩家.y,
                                false
                            );
                            moveQueue = moveQueue.slice(targetIndex + 1);
                        } else {
                            // 无法多格移动时单格移动
                            const target = moveQueue.shift();
                            移动玩家(
                                target.x - 玩家.x,
                                target.y - 玩家.y,
                                false
                            );
                        }
                    }
                }, 移动间隔); // 间隔时间
            }
            function 打开配方书() {
                if (
                    游戏状态 === "游戏中" &&
                    玩家属性.允许移动 > 0 &&
                    document.getElementById("配方书遮罩").style.display ===
                        "block"
                )
                    return;
                if (游戏状态 === "游戏中") 玩家属性.允许移动++;

                const 遮罩 = document.getElementById("配方书遮罩");
                const 窗口 = document.getElementById("配方书窗口");
                const 内容容器 = document.getElementById("配方书内容容器");
                const 关闭按钮 = document.getElementById("关闭配方书按钮");

                内容容器.innerHTML = "";

                const 所有已知配方 = new Map();

                融合配方列表.forEach((配方) => {
                    if (配方.说明) {
                        所有已知配方.set(配方.说明, 配方);
                    } else {
                        const inputNames = 配方.输入.join(" + ");
                        const outputName = 配方.输出类名称 || 配方.输出类;
                        const tempDesc = `${inputNames} = ${outputName}`;
                        所有已知配方.set(tempDesc, { ...配方, 说明: tempDesc });
                    }
                });
                已发现的程序生成配方.forEach((配方) => {
                    if (配方.说明) {
                        所有已知配方.set(配方.说明, 配方);
                    }
                });

                if (所有已知配方.size === 0) {
                    内容容器.innerHTML =
                        "<p style='text-align: center; color: #888;'>尚未发现任何配方。</p>";
                } else {
                    所有已知配方.forEach((配方) => {
                        const 配方条目 = document.createElement("div");
                        配方条目.style.cssText = `
                        background: rgba(255, 255, 255, 0.05);
                        padding: 10px 15px;
                        border: 1px solid rgba(76, 175, 80, 0.3);
                        border-radius: 6px;
                        font-size: 0.95em;
                        line-height: 1.5;
                        color: #e0e0e0;
                        text-align: left;
                    `;
                        配方条目.textContent =
                            配方.说明 ||
                            `${配方.输入.join(" + ")} → ${
                                配方.输出类名称 || 配方.输出类
                            }`;
                        内容容器.appendChild(配方条目);
                    });
                }

                关闭按钮.onclick = 关闭配方书;

                遮罩.style.display = "block";
                窗口.style.opacity = 0;
                窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
                requestAnimationFrame(() => {
                    窗口.style.transition =
                        "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
                    窗口.style.opacity = 1;
                    窗口.style.transform = "translate(-50%, -50%) scale(1)";
                });
            }

            function 关闭配方书() {
                const 遮罩 = document.getElementById("配方书遮罩");
                const 窗口 = document.getElementById("配方书窗口");
                if (!遮罩 || !窗口 || 遮罩.style.display === "none") return;

                窗口.style.transition =
                    "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
                窗口.style.opacity = 0;
                窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
                setTimeout(() => {
                    遮罩.style.display = "none";
                    if (游戏状态 === "游戏中") {
                        玩家属性.允许移动--;
                        玩家属性.允许移动 = Math.max(0, 玩家属性.允许移动);
                    }
                }, 300);
            }
            
            function 应用永久Buffs() {
                // 先重置为初始值
                玩家属性 = { ...初始玩家属性 };

                // 应用永久Buff
                Object.keys(永久Buffs).forEach(key => {
                    if (key !== '已获得效果') {
                        if (typeof 玩家属性[key] === 'number' && typeof 永久Buffs[key] === 'number') {
                            玩家属性[key] = (初始玩家属性[key] || 0) + 永久Buffs[key];
                        } else {
                            玩家属性[key] = 永久Buffs[key];
                        }
                    }
                });

                // 确保已获得的效果列表也同步
                玩家属性.已获得神龛效果 = Array.from(永久Buffs.已获得效果);

            }
            function 检查直线移动可行性(
                fromX,
                fromY,
                toX,
                toY,
                未解锁房间视作障碍 = false
            ) {
                const dx = toX - fromX;
                const dy = toY - fromY;

                if (dx !== 0 && dy !== 0) return false; // 禁止斜向移动

                const steps = Math.max(Math.abs(dx), Math.abs(dy));
                const dirX = dx > 0 ? 1 : dx < 0 ? -1 : 0;
                const dirY = dy > 0 ? 1 : dy < 0 ? -1 : 0;

                for (let i = 1; i <= steps; i++) {
                    const x = fromX + dirX * i;
                    const y = fromY + dirY * i;

                    if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
                        return false;
                    if (
                        !检查移动可行性(
                            x - dirX,
                            y - dirY,
                            x,
                            y,
                            未解锁房间视作障碍
                        )
                    )
                        return false;
                }

                return true;
            }
            const 主菜单容器 = document.getElementById("主菜单容器");
            const 新建游戏按钮 = document.getElementById("新建游戏按钮");
            const 读取存档按钮 = document.getElementById("读取存档按钮");
            const 图鉴按钮 = document.getElementById("图鉴按钮");
            const 读凭证按钮 = document.getElementById("读凭证按钮");
            function 收集所有定义() {
                const definitions = 获取所有可用的定义();
                所有物品定义 = definitions.items;
                所有怪物定义 = definitions.monsters;
            }
            // --- 菜单控制函数 ---
            function 显示主菜单() {
                游戏状态 = "主菜单";
                document.body.classList.remove("游戏进行中");
                主菜单容器.style.opacity = 1;
                主菜单容器.style.pointerEvents = "auto";

                const 死亡遮罩 = document.getElementById("死亡遮罩");
                if (死亡遮罩) 死亡遮罩.remove();
                死亡界面已显示 = false; // 重置死亡状态
            }

            function 隐藏主菜单() {
                游戏状态 = "游戏中";
                document.body.classList.add("游戏进行中");
                主菜单容器.style.opacity = 0;
                主菜单容器.style.pointerEvents = "none";
            }

            function 启动游戏(存档数据 = null) {
                程序生成配方列表 = []; // Reset for new game or load
                已发现的程序生成配方 = [];

                if (存档数据) {
                    console.log("正在加载存档...", 存档数据);
                    try {
                        恢复游戏状态(存档数据);
                        if (存档数据.配方信息) {
                            程序生成配方列表 =
                                存档数据.配方信息.程序生成配方列表 || [];
                            已发现的程序生成配方 =
                                存档数据.配方信息.已发现的程序生成配方 || [];
                            // Ensure discovered recipes are also in the main fusion list
                            已发现的程序生成配方.forEach((discoveredRecipe) => {
                                if (
                                    !融合配方列表.some(
                                        (r) => r.说明 === discoveredRecipe.说明
                                    )
                                ) {
                                    融合配方列表.push(discoveredRecipe);
                                }
                            });
                        }

                        初始化canvas();
                        初始化装备系统();
                        更新视口();
                        更新背包显示();
                        更新装备显示();
                        更新界面状态();
                        更新物体指示器();

                        最高教程阶段 = 存档数据.教程?.最高阶段 || 6;
                        是否为教程层 = false;
                        document.getElementById("跳过教程按钮").style.display =
                            "none";
                        动画帧();
                        显示通知("存档加载成功！", "成功");
                        绘制();
                    } catch (错误) {
                        console.error("加载存档失败:", 错误);
                        显示通知("加载存档失败", "错误");
                        显示主菜单();
                    }
                } else {
                    重置所有游戏状态();
                    初始化canvas();
                    初始化装备系统();
                    if (window.innerWidth < 769) {
                        document
                            .getElementById("小地图容器")
                            .classList.add("隐藏");
                    }
                    //当前层数 = 5;
                    //生成沉没的迷宫();
                    当前层数 = null;
                    进入教程层();
                    动画帧();
                }

                隐藏主菜单();
            }
            function 揭示并激活陷阱群(陷阱ID, 持续时间, 是否强化) {
                const 待转换列表 = [];
                for (let y = 0; y < 地牢大小; y++) {
                    for (let x = 0; x < 地牢大小; x++) {
                        const 物品 = 地牢[y]?.[x]?.关联物品;
                        if (物品 instanceof 隐形毒气陷阱 && 物品.自定义数据.get('关联陷阱ID') === 陷阱ID) {
                            待转换列表.push({x, y, 物品});
                        }
                    }
                }
                
                if (待转换列表.length > 0) {
                     显示通知(`陷阱被触发了，周围的毒气喷涌而出！`, "警告", true);
                }

                待转换列表.forEach(条目 => {
                    const {x, y, 物品} = 条目;
                    if(地牢[y]?.[x]?.关联物品 === 物品) {
                        const 新毒气 = new 毒气({
                            强化: 是否强化,
                            
                                倒计时: 9999,
                                爆炸时间: 9999,
                        });
                        地牢[y][x].关联物品 = null; 
                        地牢[y][x].类型 = null;
                        if (放置物品到单元格(新毒气, x, y)) {
                           所有计时器.push(新毒气);
                        }
                    }
                });
                绘制();
            }

            function 生成毒气陷阱群(房间) {
                if (房间.id === 0 || 房间.类型 !== '房间') return;

                const 模式 = Math.random() < 0.5 ? '十字' : 'X形';
                let 长度 = 2 + Math.floor(Math.random() * 2);

                let 放置成功 = false;
                for (let 尝试 = 0; 尝试 < 3000; 尝试++) {
                    const 中心X = 房间.x + 1 + Math.floor(Math.random() * (房间.w - 2));
                    const 中心Y = 房间.y + 1 + Math.floor(Math.random() * (房间.h - 2));
                    
                    const 陷阱坐标 = [{ x: 中心X, y: 中心Y }];
                    
                    if (模式 === '十字') {
                        for(let i = 1; i <= 长度; i++) {
                            陷阱坐标.push({x: 中心X + i, y: 中心Y});
                            陷阱坐标.push({x: 中心X - i, y: 中心Y});
                            陷阱坐标.push({x: 中心X, y: 中心Y + i});
                            陷阱坐标.push({x: 中心X, y: 中心Y - i});
                        }
                    } else { // X形
                        for(let i = 1; i <= 长度; i++) {
                            陷阱坐标.push({x: 中心X + i, y: 中心Y + i});
                            陷阱坐标.push({x: 中心X - i, y: 中心Y - i});
                            陷阱坐标.push({x: 中心X + i, y: 中心Y - i});
                            陷阱坐标.push({x: 中心X - i, y: 中心Y + i});
                        }
                    }

                    const 是否全部可用 = 陷阱坐标.every(pos => 位置是否可用(pos.x, pos.y, false));
                    
                    if (是否全部可用) {
                        const 陷阱ID = Symbol('trapGroup_' + Date.now());
                        const 强化 = Math.random() < 0.15 + 当前层数 * 0.02;

                        陷阱坐标.forEach(pos => {
                             const 新陷阱 = new 隐形毒气陷阱({强化: 强化, 关联陷阱ID: 陷阱ID});
                             放置物品到单元格(新陷阱, pos.x, pos.y);
                        });
                        放置成功 = true;
                        break; 
                    }
                    if (尝试 % 100 === 0) 长度 = 2 + Math.floor(Math.random() * 2);
                }
            }
            function 重置所有游戏状态() {
                所有怪物.forEach((m) => {
                    m.绘制血条(true);
                });
                所有怪物.forEach((怪物) => {
                    怪物动画状态.delete(怪物);
                });
                地牢 = [];
                房间列表 = [];
                上锁房间列表 = [];
                所有怪物 = [];
                所有计时器 = [];
                玩家背包 = new Map();
                玩家装备 = new Map();
                门实例列表 = new Map();
                已访问房间 = new Set();
                房间地图 = Array(地牢大小)
                    .fill()
                    .map(() => Array(地牢大小).fill(-1));
                玩家初始位置 = { x: 0, y: 0 };
                玩家.x = 0;
                玩家.y = 0;
                当前层数 = 0; // 不进入教程
                玩家属性 = { ...初始玩家属性 };
                永久Buffs = { 已获得效果: new Set() };
                玩家状态.forEach((m) => {
                    m.移除状态();
                });
                if (当前激活卷轴列表.size > 0) {
                    当前激活卷轴列表.forEach((卷轴) => {
                        当前激活卷轴列表.delete(卷轴);
                        卷轴.卸下();
                    });
                }
                玩家属性 = { ...初始玩家属性 };
                玩家状态 = [];
                移动历史 = [];
                已击杀怪物数 = 0;
                NPC互动中 = false;
                当前NPC = null;
                死亡界面已显示 = false;
                教程阶段 = 0;
                最高教程阶段 = 0;
                是否为教程层 = false;
                日志历史 = [];
                最大背包容量 = 12;

                document.getElementById("背包物品栏").innerHTML = "";
                document
                    .querySelectorAll(".装备槽")
                    .forEach((槽) => (槽.innerHTML = ""));
                document.getElementById("logContent").innerHTML = ""; // 清空日志面板内容

                document.querySelector(".health-bar").style.width = "100%";
                document.querySelector(".power-bar").style.width = "100%";
                怪物追踪提示.更新({ 内容: `追踪怪物：0` });
                击杀提示.更新({ 内容: `已击杀怪物：0` });

                界面可见性 = { hud: false, 背包: false };
            }

            /**
             * 序列化地牢单元格
             * @param {单元格} 单元格实例
             * @param {Map<Symbol, string>} 物品标识映射 - 用于转换物品引用
             * @param {Map<怪物, number>} 怪物索引映射 - 用于转换怪物引用
             * @returns {object | null}
             */
            function 序列化单元格(单元格实例, 物品标识映射, 怪物索引映射) {
                if (!单元格实例) return null;
                try {
                    let 关联物品标识 = null;
                    let 关联物品图标 = null;

                    if (
                        单元格实例.类型 === 单元格类型.楼梯下楼 ||
                        单元格实例.类型 === 单元格类型.楼梯上楼
                    ) {
                        关联物品标识 = null;
                        关联物品图标 = 单元格实例.关联物品?.图标;
                    }
                    else if (单元格实例.关联物品) {
                        关联物品标识 = 物品标识映射.get(
                            单元格实例.关联物品.唯一标识
                        );
                        if (!关联物品标识) {
                            console.warn(
                                `单元格 (${单元格实例.x},${单元格实例.y}) 关联物品未在标识映射中找到:`,
                                单元格实例.关联物品
                            );
                            const serializedItem = 序列化物品(
                                单元格实例.关联物品
                            );
                            if (serializedItem) {
                                关联物品标识 = serializedItem.唯一标识符串;
                                if (
                                    !物品标识映射.has(
                                        单元格实例.关联物品.唯一标识
                                    )
                                ) {
                                    物品标识映射.set(
                                        单元格实例.关联物品.唯一标识,
                                        关联物品标识
                                    );
                                }
                            }
                        }
                    }

                    let 关联怪物索引 = null;
                    if (单元格实例.关联怪物) {
                        关联怪物索引 = 怪物索引映射.get(单元格实例.关联怪物);
                        if (关联怪物索引 === undefined) {
                            console.warn(
                                `单元格 (${单元格实例.x},${单元格实例.y}) 关联怪物未在索引映射中找到:`,
                                单元格实例.关联怪物
                            );
                        }
                    }

                    return {
                        类型: 单元格实例.类型,
                        背景类型: 单元格实例.背景类型,
                        墙壁: { ...单元格实例.墙壁 },
                        钥匙ID: 单元格实例.钥匙ID,
                        颜色索引: 单元格实例.颜色索引,
                        关联物品标识: 关联物品标识,
                        关联物品图标: 关联物品图标,
                        关联怪物索引: 关联怪物索引,
                        标识符串: 单元格实例.标识
                            ? 单元格实例.标识.toString()
                            : null,
                        配对单元格位置: 单元格实例.配对单元格位置
                            ? { ...单元格实例.配对单元格位置 }
                            : null,
                        isOneWay: 单元格实例.isOneWay,
                        oneWayAllowedDirection: 单元格实例.oneWayAllowedDirection,
                        doorOrientation: 单元格实例.doorOrientation,
                    };
                } catch (e) {
                    console.error(
                        `序列化单元格 (${单元格实例.x}, ${单元格实例.y}) 失败:`,
                        e
                    );
                    return null;
                }
            }

            function 保存游戏状态() {
                console.log("开始打包游戏状态...");
                try {
                    const 全局物品标识映射 = new Map();
                    [...玩家背包.values(), ...玩家装备.values()].forEach(
                        (物品实例) => {
                            if (物品实例) {
                                全局物品标识映射.set(
                                    物品实例.唯一标识,
                                    物品实例.唯一标识.toString()
                                );
                            }
                        }
                    );
                    const 当前楼层所有怪物 = 所有地牢层.get(当前层数)?.所有怪物 || [];
        const 怪物索引映射 = new Map();
        当前楼层所有怪物.forEach((怪物, 索引) => 怪物索引映射.set(怪物, 索引));

                    const 序列化玩家背包 = Array.from(玩家背包.values())
                        .map(序列化物品)
                        .filter((物品数据) => 物品数据 != null);

                    const 序列化玩家装备 = Array.from(玩家装备.entries())
                        .map(([槽位, 物品实例]) =>
                            物品实例
                                ? {
                                      槽位: 槽位,
                                      唯一标识符串: 全局物品标识映射.get(
                                          物品实例.唯一标识
                                      ),
                                  }
                                : null
                        )
                        .filter((装备数据) => 装备数据 != null);

                    const 序列化玩家状态 = 玩家状态
                        .map((状态实例) => {
                            let 来源标识符串 = null;
                            if (状态实例.来源 && 状态实例.来源.唯一标识) {
                                来源标识符串 = 全局物品标识映射.get(
                                    状态实例.来源.唯一标识
                                );
                            }
                            return {
                                类型: 状态实例.类型,
                                颜色: 状态实例.颜色,
                                图标: 状态实例.图标,
                                持续时间: 状态实例.持续时间,
                                剩余回合: 状态实例.剩余回合,
                                强度: 状态实例.强度,
                                来源类名: 状态实例.来源?.constructor.name,
                                来源标识符串: 来源标识符串,
                            };
                        })
                        .filter((状态数据) => 状态数据 != null);

                    const 序列化激活卷轴 = Array.from(当前激活卷轴列表)
                        .map((卷轴实例) =>
                            全局物品标识映射.get(卷轴实例.唯一标识)
                        )
                        .filter((标识符串) => 标识符串 != null);

                    const 当前楼层临时数据 = {
                        地牢数组: 地牢,
                        房间列表: 房间列表,
                        上锁房间列表: 上锁房间列表,
                        已访问房间: 已访问房间,
                        房间地图: 房间地图,
                        门实例列表: 门实例列表,
                        所有怪物: 所有怪物,
                        所有计时器: 所有计时器,
                        玩家初始位置: 玩家初始位置,
                        玩家位置: 玩家,
                        当前天气效果: 当前天气效果,
                        已放置配方卷轴:
                            所有地牢层.get(当前层数)?.已放置配方卷轴 || false,
                    };

                    const 序列化所有楼层数据 = {};
                    for (const [层号, 楼层数据] of 所有地牢层.entries()) {
                        if (层号 !== 当前层数)
                            序列化所有楼层数据[层号] = 序列化楼层(
                                层号,
                                楼层数据,
                                全局物品标识映射
                            );
                    }
                    if (当前层数 !== null) {
                        序列化所有楼层数据[当前层数] = 序列化楼层(
                            当前层数,
                            当前楼层临时数据,
                            全局物品标识映射
                        );
                    }

                    const 当前生命值百分比 =
                        parseFloat(
                            document.querySelector(".health-bar")?.style.width
                        ) || 100;
                    const 当前能量值百分比 =
                        parseFloat(
                            document.querySelector(".power-bar")?.style.width
                        ) || 100;

                    const 存档数据 = {
                        版本: 存档版本,
                        保存时间: new Date().toISOString(),
                        当前层数: 当前层数,
                        玩家: {
                            x: 玩家.x,
                            y: 玩家.y,
                            属性: { ...玩家属性 },
                            最大背包容量: 最大背包容量,
                            背包: 序列化玩家背包,
                            装备: 序列化玩家装备,
                            状态: 序列化玩家状态,
                            当前生命值百分比: 当前生命值百分比,
                            当前能量值百分比: 当前能量值百分比,
                            最大背包容量: 最大背包容量,
                            最大装备槽数量: 最大装备槽数量,
                        },
                        教程: {
                            阶段: 教程阶段,
                            最高阶段: 最高教程阶段,
                            是否教程层: 是否为教程层,
                        },
                        UI: {
                            hud模式: hud模式,
                            显示模式: 显示模式,
                            激活卷轴列表: 序列化激活卷轴,
                            日志历史: 日志历史,
                            当前装备页: 当前装备页,
                        },
                        游戏统计: { 已击杀怪物数: 已击杀怪物数 },
                        所有地牢层数据: 序列化所有楼层数据,
                        传送点列表: 传送点列表.map((点) => ({ ...点 })),
                        上次死亡地点: 上次死亡地点 ? { ...上次死亡地点 } : null,
                        永久Buffs: {
                            ...永久Buffs,
                            已获得效果: Array.from(永久Buffs.已获得效果 || [])
                        },
                        生存挑战激活: 生存挑战激活,
            序列化生存挑战备份单元格: 生存挑战备份单元格.map(备份 => ({
                x: 备份.x,
                y: 备份.y,
                类型: 备份.类型,
                背景类型: 备份.背景类型,
                墙壁: { ...备份.墙壁 },
                // 将对象引用转换成可序列化的ID
                关联物品标识: 备份.关联物品 ? 全局物品标识映射.get(备份.关联物品.唯一标识) : null,
                关联怪物索引: 备份.关联怪物 ? 怪物索引映射.get(备份.关联怪物) : null,
                颜色索引: 备份.颜色索引,
                标识: 备份.标识 ? 备份.标识.toString() : null,
            })),
                        配方信息: {
                            程序生成配方列表: 程序生成配方列表,
                            已发现的程序生成配方: 已发现的程序生成配方,
                        },
                    };
                    const 序列化数据 = JSON.stringify(存档数据, null, 2);
                    console.log("游戏状态打包完成！");
                    return 序列化数据;
                } catch (错误) {
                    console.error("打包游戏状态失败:", 错误);
                    显示通知("打包游戏状态失败！", "错误");
                    return null;
                }
            }
            function 读取游戏状态() {
                console.log("开始读取游戏状态...");
                const 序列化数据 = localStorage.getItem("dungeonSaveData_v2");
                if (!序列化数据) {
                    console.log("未找到存档数据。");
                    return null;
                }

                try {
                    const 存档数据 = JSON.parse(序列化数据);
                    // 版本检查 (可选但推荐)
                    if (存档数据.版本 !== 存档版本) {
                        console.warn(
                            `存档版本不匹配 (${存档数据.版本})，可能导致加载问题。`
                        );
                        // 可以选择拒绝加载或尝试兼容性处理
                        // return null;
                    }
                    console.log("存档数据读取成功！");
                    return 存档数据;
                } catch (错误) {
                    console.error("读取或解析存档数据失败:", 错误);
                    显示通知("读取存档数据失败！", "错误");
                    return null;
                }
            }

            /**
             * 恢复单个单元格状态
             * @param {object} 单元格数据
             * @param {number} x
             * @param {number} y
             * @param {Map<string, 物品>} 全局物品实例映射 - 通过物品标识符串查找实例
             * @param {Map<number, 怪物>} 怪物实例映射 - 通过怪物索引查找实例
             * @param {Map<string, 门>} 门实例映射 - 通过门标识符串查找实例
             * @returns {单元格}
             */
            function 恢复单元格(
                单元格数据,
                x,
                y,
                全局物品实例映射,
                怪物实例映射,
                门实例映射
            ) {
                const 单元格实例 = new 单元格(x, y);
                if (!单元格数据) return 单元格实例;

                单元格实例.类型 = 单元格数据.类型 ?? 单元格类型.墙壁;
                单元格实例.背景类型 = 单元格数据.背景类型 ?? 单元格实例.类型;
                单元格实例.墙壁 = {
                    ...(单元格数据.墙壁 || {
                        上: false,
                        右: false,
                        下: false,
                        左: false,
                    }),
                };
                单元格实例.钥匙ID = 单元格数据.钥匙ID ?? null;
                单元格实例.颜色索引 = 单元格数据.颜色索引 ?? 颜色表.length;

                单元格实例.关联物品 = null;
                单元格实例.关联怪物 = null;

                if (
                    单元格实例.类型 === 单元格类型.楼梯下楼 ||
                    单元格实例.类型 === 单元格类型.楼梯上楼
                ) {
                    const 图标 =
                        单元格数据.关联物品图标 ||
                        (单元格实例.类型 === 单元格类型.楼梯下楼
                            ? 楼梯图标.下楼
                            : 楼梯图标.上楼);
                    单元格实例.关联物品 = {
                        类型: "楼梯",
                        图标: 图标,
                        显示图标: 图标,
                        颜色索引: 颜色表.length,
                        唯一标识: Symbol(`楼梯_${单元格实例.类型}`),
                        获取名称: () =>
                            单元格实例.类型 === 单元格类型.楼梯下楼
                                ? "下楼楼梯"
                                : "上楼楼梯",
                        自定义数据: new Map(),
                        品质: 1,
                        能否拾起: false,
                        是否正常物品: false,
                        是否隐藏: false,
                        是否为隐藏物品: false,
                        效果描述: null,
                        已装备: false,
                        装备槽位: null,
                        堆叠数量: 1,
                        最大堆叠数量: 1,
                        颜色表: 颜色表,
                        使用: () => {
                            const 目标层数 =
                                单元格实例.类型 === 单元格类型.楼梯下楼
                                    ? 当前层数 + 1
                                    : 当前层数 - 1;
                            切换楼层(目标层数);
                        },
                    };
                }
                else if (单元格数据.关联物品标识) {
                    const 物品实例 = 全局物品实例映射.get(
                        单元格数据.关联物品标识
                    );
                    if (物品实例) {
                        单元格实例.关联物品 = 物品实例;
                        物品实例.x = x;
                        物品实例.y = y;
                    } else {
                        console.warn(
                            `单元格 (${x},${y}) 关联物品标识 ${单元格数据.关联物品标识} 未找到对应实例`
                        );
                    }
                }

                if (
                    单元格数据.关联怪物索引 !== null &&
                    单元格数据.关联怪物索引 !== undefined
                ) {
                    单元格实例.关联怪物 = 单元格数据.关联怪物索引;
                }

                if (单元格数据.标识符串) {
                    const 门实例 = 门实例映射.get(单元格数据.标识符串);
                    if (门实例) {
                        单元格实例.标识 = 门实例.唯一标识;
                    } else {
                        单元格实例.临时门标识符串 = 单元格数据.标识符串;
                        console.warn(
                            `单元格 (${x},${y}) 的门标识 ${单元格数据.标识符串} 对应的门实例尚未恢复`
                        );
                    }
                }
                单元格实例.配对单元格位置 = 单元格数据.配对单元格位置
                    ? { ...单元格数据.配对单元格位置 }
                    : null;
                
                单元格实例.isOneWay = 单元格数据.isOneWay || false;
                单元格实例.oneWayAllowedDirection = 单元格数据.oneWayAllowedDirection || null;
                单元格实例.doorOrientation = 单元格数据.doorOrientation || null;

                return 单元格实例;
            }
            /**
             * 序列化单个物品实例 - 扩展版
             * @param {物品} 物品实例
             * @returns {object | null} 可序列化的物品数据，如果物品无效则返回 null
             */
            function 序列化物品(物品实例) {
                if (!物品实例 || !物品实例.constructor) {
                    console.warn("尝试序列化无效物品", 物品实例);
                    return null;
                }
                try {
                    const 类名 = 物品实例.constructor.name;
                    const 配置 = {
                        // 包含核心状态和构造所需参数
                        类型: 物品实例.类型,
                        名称: 物品实例.名称,
                        图标: 物品实例.图标,
                        品质: 物品实例.品质,
                        数量: 物品实例.堆叠数量,
                        最大堆叠数量: 物品实例.最大堆叠数量,
                        颜色索引: 物品实例.颜色索引,
                        强化: 物品实例.强化,
                        能否拾起: 物品实例.能否拾起,
                        是否正常物品: 物品实例.是否正常物品,
                        是否隐藏: 物品实例.是否隐藏,
                        是否为隐藏物品: 物品实例.是否为隐藏物品,
                        效果描述: 物品实例.效果描述,
                        已装备: 物品实例.已装备,
                        装备槽位: 物品实例.装备槽位,
                        x: 物品实例.x,
                        y: 物品实例.y,
                        是否被丢弃: 物品实例.是否被丢弃 || false,
                        阻碍怪物: 物品实例.阻碍怪物,
                        数据: 物品实例.自定义数据
                            ? Object.fromEntries(物品实例.自定义数据)
                            : {},
                    };

                    // --- 特殊物品类处理 ---

                    // 武器类 & 防御装备类: 保存附魔 (自定义数据已包含)
                    if (
                        物品实例 instanceof 武器类 ||
                        物品实例 instanceof 防御装备类
                    ) {
                        // 配置.数据.附魔 在 Object.fromEntries(物品实例.自定义数据) 中已处理
                        // 需要确保 冷却剩余 被保存 (武器类)
                        if (物品实例 instanceof 武器类) {
                            配置.数据.冷却剩余 =
                                物品实例.自定义数据.get("冷却剩余") ?? 0;
                        }
                    }

                    // 卷轴类: 保存已解锁状态 (自定义数据已包含)

                    // 附魔卷轴: 保存可用次数和效果名
                    if (物品实例 instanceof 附魔卷轴) {
                        配置.数据.可用次数 = 物品实例.可用次数;
                        // 找到效果名用于恢复
                        const 效果索引 = 物品实例.附魔池.findIndex(
                            (func) => func === 物品实例.附魔效果
                        );
                        if (效果索引 !== -1) {
                            配置.数据.附魔效果名 = 物品实例.效果名[效果索引];
                        } else {
                            console.warn("无法找到附魔卷轴的效果名:", 物品实例);
                        }
                    }

                    // 神秘商人 / 物品祭坛: 序列化库存
                    if (
                        物品实例 instanceof 神秘商人 ||
                        物品实例 instanceof 物品祭坛
                    ) {
                        配置.数据.库存序列化 = (
                            物品实例.自定义数据.get("库存") || []
                        )
                            .map(序列化物品)
                            .filter((item) => item !== null);
                        // 从原始数据中移除库存，避免重复和循环引用
                        delete 配置.数据.库存;
                    }

                    // 宠物: 序列化装备标识和技能，以及其他状态
                    if (物品实例 instanceof 宠物) {
                        const 宠物装备 = 物品实例.自定义数据.get("装备") || {};
                        配置.数据.装备标识 = {}; // 使用新字段存储标识
                        for (const 槽位 in 宠物装备) {
                            if (宠物装备[槽位] && 宠物装备[槽位].唯一标识) {
                                配置.数据.装备标识[槽位] =
                                    宠物装备[槽位].唯一标识.toString();
                            } else {
                                配置.数据.装备标识[槽位] = null;
                            }
                        }
                        // 技能通常是简单对象数组，可以直接序列化
                        配置.数据.技能 = JSON.parse(
                            JSON.stringify(
                                物品实例.自定义数据.get("技能") || []
                            )
                        ); // 深拷贝确保安全
                        // 其他宠物特定状态已在自定义数据中

                        // 从原始数据中移除复杂对象，避免循环引用
                        delete 配置.数据.装备;
                    }

                    // 折跃门: 保存目标房间ID
                    if (物品实例 instanceof 折跃门) {
                        const 目标房间 = 物品实例.自定义数据.get("目标房间");
                        配置.数据.目标房间ID = 目标房间 ? 目标房间.id : null;
                    }

                    // 钥匙: (自定义数据已包含)
                    // 炸弹: (自定义数据已包含)

                    return {
                        类名: 类名,
                        唯一标识符串: 物品实例.唯一标识.toString(),
                        配置: 配置,
                    };
                } catch (e) {
                    console.error(
                        `序列化物品 ${物品实例?.名称} (${类名}) 失败:`,
                        e
                    );
                    return null;
                }
            }

            /**
             * 序列化单个怪物实例 - 扩展版
             * @param {怪物} 怪物实例
             * @param {number} 怪物索引
             * @param {Array<怪物>} 当前楼层所有怪物列表 - 用于查找引用索引
             * @returns {object | null} 可序列化的怪物数据
             */
            function 序列化怪物(怪物实例, 怪物索引, 当前楼层所有怪物列表) {
                if (!怪物实例 || !怪物实例.constructor) {
                    console.warn("尝试序列化无效怪物", 怪物实例);
                    return null;
                }
                const 类名 = 怪物实例.constructor.name;
                try {
                    let 仇恨目标标识 = null;
                    if (怪物实例.仇恨 === 玩家) {
                        仇恨目标标识 = "玩家";
                    } else if (怪物实例.仇恨 instanceof 怪物) {
                        const 仇恨索引 = 当前楼层所有怪物列表.findIndex(
                            (m) => m === 怪物实例.仇恨
                        );
                        if (仇恨索引 !== -1) {
                            仇恨目标标识 = `怪物_${仇恨索引}`;
                        } else {
                            console.warn(
                                `怪物 ${怪物索引} 的仇恨目标未在当前楼层找到:`,
                                怪物实例.仇恨
                            );
                        }
                    }

                    const 状态效果数据 = 怪物状态表.get(怪物实例);
                    let 序列化状态 = null;
                    if (状态效果数据) {
                        序列化状态 = {
                            类型: 状态效果数据.类型,
                            颜色: 状态效果数据.颜色,
                            图标: 状态效果数据.图标,
                            持续时间: 状态效果数据.持续时间,
                            剩余回合: 状态效果数据.剩余回合,
                            强度: 状态效果数据.强度,
                        };
                    }

                    const 配置 = {
                        x: 怪物实例.x,
                        y: 怪物实例.y,
                        图标: 怪物实例.图标,
                        房间ID: 怪物实例.房间ID,
                        当前生命值: 怪物实例.当前生命值,
                        状态: 怪物实例.状态,
                        强化: 怪物实例.强化,
                        攻击冷却剩余: 怪物实例.攻击冷却回合剩余,
                        受伤冻结回合剩余: 怪物实例.受伤冻结回合剩余,
                        仇恨目标标识: 仇恨目标标识,
                        // --- 特定怪物属性保存 ---
                        基础攻击力: 怪物实例.基础攻击力, // 保存基础值，因为强化可能影响计算后的攻击力
                        基础生命值: 怪物实例.基础生命值,
                        移动率: 怪物实例.移动率,
                        基础移动距离: 怪物实例.基础移动距离,
                        基础攻击范围: 怪物实例.基础攻击范围,
                        跟踪距离: 怪物实例.跟踪距离,
                        攻击冷却: 怪物实例.攻击冷却, // 保存基础冷却回合
                        受伤冻结回合: 怪物实例.受伤冻结回合, // 保存基础冻结回合
                        掉落概率: 怪物实例.掉落概率, // 保存掉落概率
                        当前格: 怪物实例.当前格,
                    };

                    // --- 特定怪物类处理 ---
                    if (怪物实例 instanceof 腐蚀怪物) {
                        配置.腐蚀强度 = 怪物实例.腐蚀强度;
                        配置.腐蚀持续 = 怪物实例.腐蚀持续;
                    }
                    if (怪物实例 instanceof 盗贼怪物) {
                        配置.偷窃几率 = 怪物实例.偷窃几率;
                        配置.偷窃武器几率 = 怪物实例.偷窃武器几率;
                        配置.偷到的金币 = 怪物实例.偷到的金币;
                        配置.偷到的武器列表序列化 = 怪物实例.偷到的武器列表
                            .map(序列化物品)
                            .filter((i) => i != null);
                    }
                    if (怪物实例 instanceof 吸能怪物) {
                        配置.吸能比例 = 怪物实例.吸能比例;
                        配置.最小吸能 = 怪物实例.最小吸能;
                    }
                    if (怪物实例 instanceof 剧毒云雾怪物) {
                        配置.毒云范围 = 怪物实例.毒云范围;
                        配置.毒云持续 = 怪物实例.毒云持续;
                        配置.毒云强度 = 怪物实例.毒云强度;
                    }
                    if (怪物实例 instanceof 召唤师怪物) {
                        配置.召唤冷却剩余 = 怪物实例.召唤冷却剩余;
                        配置.最大召唤物数量 = 怪物实例.最大召唤物数量;
                        配置.召唤物类名 = 怪物实例.召唤物类.name;
                        配置.当前召唤物索引列表 = 怪物实例.当前召唤物列表
                            .map((仆从) =>
                                当前楼层所有怪物列表.findIndex(
                                    (m) => m === 仆从
                                )
                            )
                            .filter((index) => index !== -1);
                    }
                    if (怪物实例 instanceof 幽灵仆从) {
                        配置.生命周期 = 怪物实例.生命周期;
                        const 召唤者索引 = 当前楼层所有怪物列表.findIndex(
                            (m) => m === 怪物实例.召唤者
                        );
                        配置.召唤者索引 = 召唤者索引 !== -1 ? 召唤者索引 : null;
                    }
                    if (怪物实例 instanceof 萨满怪物) {
                        配置.治疗冷却剩余 = 怪物实例.治疗冷却剩余;
                        // 其他属性是构造时确定的，无需重复保存
                    }
                    if (怪物实例 instanceof 大史莱姆怪物) {
                        // 分裂数量是构造时确定的
                    }
                    if (怪物实例 instanceof 瞬移怪物) {
                        配置.瞬移几率 = 怪物实例.瞬移几率;
                        配置.受击瞬移几率 = 怪物实例.受击瞬移几率;
                    }
                    if (怪物实例 instanceof 伪装怪物) {
                        配置.伪装状态 = 怪物实例.伪装状态;
                        配置.伪装图标 = 怪物实例.伪装图标;
                        配置.真实图标 = 怪物实例.真实图标;
                        // 触发距离是构造时确定的
                    }
                    if (怪物实例 instanceof 炸弹怪物) {
                        配置.携带炸弹 = 怪物实例.携带炸弹;
                    }
                    if (怪物实例 instanceof 大魔法师) {
                        配置.技能冷却 = 怪物实例.技能冷却;
                        配置.隐身中 = 怪物实例.隐身中;
                        配置.isClone = 怪物实例.isClone;
                        // 分身引用需要特殊处理，在恢复阶段链接
                        const 分身索引 = 怪物实例.分身
                            ? 当前楼层所有怪物列表.findIndex(
                                  (m) => m === 怪物实例.分身
                              )
                            : -1;
                        配置.分身索引 = 分身索引 !== -1 ? 分身索引 : null;
                    }
                    if (怪物实例 instanceof 旋风怪物) {
                        // 新增
                        配置.召唤冷却剩余 = 怪物实例.召唤冷却剩余;
                        配置.最大召唤物数量 = 怪物实例.最大召唤物数量;
                        // 保存召唤物索引列表
                        配置.当前召唤物索引列表 = 怪物实例.当前召唤物列表
                            .map((旋) =>
                                当前楼层所有怪物列表.findIndex((m) => m === 旋)
                            )
                            .filter((index) => index !== -1);
                    }
                    if (怪物实例 instanceof 旋风) {
                        // 新增
                        配置.生命周期 = 怪物实例.生命周期;
                    }

                    const 掉落物序列化 = 怪物实例.掉落物
                        ? 序列化物品(怪物实例.掉落物)
                        : null;

                    return {
                        类名: 类名,
                        怪物索引: 怪物索引,
                        配置: 配置,
                        掉落物: 掉落物序列化,
                        状态效果: 序列化状态,
                    };
                } catch (e) {
                    console.error(
                        `序列化怪物 ${怪物实例?.类型} (${类名}) 失败:`,
                        e
                    );
                    return null;
                }
            }

            // 序列化炸弹 和 序列化单元格 函数保持不变，因为它们依赖于 序列化物品 和 序列化怪物

                        function 序列化楼层(层号, 楼层原始数据, 全局物品标识映射) {
                console.log(`开始序列化楼层 ${层号}`);
                if (!楼层原始数据) {
                    console.warn(`楼层 ${层号} 数据不存在，跳过序列化`);
                    return null;
                }
                try {
                    const {
                        地牢数组 = [],
                        房间列表 = [],
                        上锁房间列表 = [],
                        已访问房间 = new Set(),
                        房间地图 = [],
                        门实例列表 = new Map(),
                        所有怪物 = [],
                        所有计时器 = [],
                        玩家初始位置 = { x: 0, y: 0 },
                        玩家位置 = 玩家位置,
                        当前天气效果 = [],
                    } = 楼层原始数据;

                    const 地上物品列表 = [];
                    for (let y = 0; y < 地牢数组.length; y++) {
                        for (let x = 0; x < 地牢数组[y]?.length; x++) {
                            const 物品 = 地牢数组[y][x]?.关联物品;
                            if (物品) {
                                地上物品列表.push(物品);
                                if (!全局物品标识映射.has(物品.唯一标识)) {
                                    全局物品标识映射.set(
                                        物品.唯一标识,
                                        物品.唯一标识.toString()
                                    );
                                }
                            }
                        }
                    }
                    const 序列化地上物品 = 地上物品列表
                        .map(序列化物品)
                        .filter((i) => i != null);

                    const 怪物索引映射 = new Map();
                    const 序列化怪物列表 = 所有怪物
                        .map((怪物, 索引) => {
                            怪物索引映射.set(怪物, 索引);
                            return 序列化怪物(怪物, 索引, 所有怪物);
                        })
                        .filter((m) => m != null);

                    const 序列化地牢格子 = 地牢数组.map((行) =>
                        行
                            .map((单元格) =>
                                序列化单元格(
                                    单元格,
                                    全局物品标识映射,
                                    怪物索引映射
                                )
                            )
                            .filter((g) => g != null)
                    );

                    const 序列化物品列表 = 所有计时器
                        .map(序列化物品)
                        .filter((b) => b != null);
                    序列化物品列表.forEach((炸弹数据) => {
                        if (炸弹数据) {
                            const 符号 = Symbol(
                                炸弹数据.唯一标识符串.slice(7, -1)
                            );
                            if (!全局物品标识映射.has(符号)) {
                                全局物品标识映射.set(
                                    符号,
                                    炸弹数据.唯一标识符串
                                );
                            }
                        }
                    });

                    const 序列化门实例 = Array.from(门实例列表.values()).map(
                        (门) => ({
                            唯一标识符串: 门.唯一标识.toString(),
                            类型: 门.类型,
                            是否上锁: 门.是否上锁,
                            房间ID: 门.房间ID,
                            所在位置: { ...门.所在位置 },
                        })
                    );
                    const 序列化挑战房间状态 = (楼层原始数据.房间列表 || [])
                        .filter((r) => r.类型 === "挑战房间" && r.挑战状态)
                        .map((r) => {
                            const 挑战状态 = r.挑战状态;
                            const 挑战状态拷贝 = {
                                进行中: 挑战状态.进行中,
                                已完成: 挑战状态.已完成,
                                当前波次: 挑战状态.当前波次,
                                总波次: 挑战状态.总波次,
                                波次最大回合数: 挑战状态.波次最大回合数,
                                波次当前回合数: 挑战状态.波次当前回合数,
                                波次内怪物: [],
                                原始门数据: [],
                            };

                            if (
                                挑战状态.波次内怪物 &&
                                Array.isArray(挑战状态.波次内怪物)
                            ) {
                                挑战状态拷贝.波次内怪物 =
                                    挑战状态.波次内怪物
                                        .map((怪实例) => {
                                            const 索引 = (
                                                楼层原始数据.所有怪物 || []
                                            ).findIndex((m) => m === 怪实例);
                                            return 索引 !== -1
                                                ? `怪物_${索引}`
                                                : null;
                                        })
                                        .filter((id) => id !== null);
                            }

                            if (
                                挑战状态.原始门数据 &&
                                Array.isArray(挑战状态.原始门数据)
                            ) {
                                挑战状态拷贝.原始门数据 =
                                    挑战状态.原始门数据.map((门数据) => ({
                                        ...门数据,
                                        原标识: 门数据.原标识
                                            ? 门数据.原标识.toString()
                                            : null,
                                    }));
                            }

                            return {
                                id: r.id,
                                状态: 挑战状态拷贝,
                            };
                        });
                    console.log(`楼层 ${层号} 序列化完成`);
                    return {
                        玩家位置: 玩家位置,
                        玩家初始位置: { ...玩家初始位置 },
                        房间列表: 房间列表.map((r) => {
                            const { 挑战状态, ...restOfRoom } = r;
                            return {
                                ...restOfRoom,
                                门: r.门 ? [...r.门] : [],
                            };
                        }),
                        上锁房间列表: 上锁房间列表.map((r) => {
                            const { 挑战状态, ...restOfRoom } = r;
                            return {
                                ...restOfRoom,
                                门: r.门 ? [...r.门] : [],
                            };
                        }),
                        已访问房间数组: Array.from(已访问房间 || new Set()),
                        房间地图: 房间地图.map((row) => [...row]),
                        挑战状态列表: 序列化挑战房间状态,
                        序列化地上物品: 序列化地上物品,
                        序列化怪物列表: 序列化怪物列表,
                        序列化物品列表: 序列化物品列表,
                        序列化地牢格子: 序列化地牢格子,
                        序列化门实例: 序列化门实例,
                        当前天气效果: [...当前天气效果],
                    };
                } catch (e) {
                    console.error(`序列化楼层 ${层号} 失败:`, e);
                    return null;
                }
            }

            /**
             * 恢复单个物品实例
             * @param {object} 物品数据
             * @param {Map<string, Symbol>} 全局物品标识映射 - string -> symbol
             * @returns {物品 | null}
             */
            function 恢复物品(物品数据, 全局物品标识映射) {
                if (!物品数据 || !物品数据.类名) return null;
                const 类构造器 = window[物品数据.类名];
                if (!类构造器 || typeof 类构造器 !== "function") {
                    console.warn(`未找到物品类构造器: ${物品数据.类名}`);
                    return null;
                }
                try {
                    const 配置 = { ...物品数据.配置 };
                    const 标识符串 = 物品数据.唯一标识符串;
                    let 唯一标识 = 全局物品标识映射.get(标识符串); // 尝试从全局映射获取 Symbol

                    if (!唯一标识) {
                        // 如果全局映射没有，根据规则创建或查找 Symbol
                        if (物品数据.类名 === "钥匙") {
                            配置.对应门ID = 配置.数据?.对应门ID; // 注意：数据可能还未转为Map
                            配置.地牢层数 = 配置.数据?.地牢层数;
                            if (
                                配置.对应门ID !== undefined &&
                                配置.地牢层数 !== undefined
                            ) {
                                唯一标识 = Symbol.for(
                                    `${配置.地牢层数}层${配置.对应门ID}`
                                );
                            } else {
                                console.warn(
                                    "钥匙缺少门ID或层数信息，无法恢复Symbol.for:",
                                    配置
                                );
                                唯一标识 = Symbol(标识符串);
                            }
                        } else if (标识符串 && 标识符串.startsWith("Symbol(")) {
                            const description = 标识符串.slice(7, -1);
                            唯一标识 = Symbol(description);
                        } else {
                            console.warn(
                                "物品缺少有效唯一标识符串，生成新Symbol:",
                                物品数据
                            );
                            唯一标识 = Symbol(
                                `恢复_${物品数据.类名}_${Date.now()}`
                            );
                        }
                        全局物品标识映射.set(标识符串, 唯一标识); // 加入全局映射
                    }

                    // 恢复 Map 类型的自定义数据
                    if (配置.数据) {
                        配置.数据 = new Map(Object.entries(配置.数据));
                    } else {
                        配置.数据 = new Map(); // 确保数据属性存在
                    }

                    // 创建实例
                    const 实例 = new 类构造器({ ...配置, 唯一标识: 唯一标识 });
                    实例.自定义数据 = 配置.数据;
                    实例.是否隐藏 = 配置.是否隐藏;
                    实例.堆叠数量 = 配置.数量;
                    实例.图标 = 配置.图标;
                    // --- 特殊物品类恢复 ---

                    // 武器类/防御装备类: 恢复附魔 (已在自定义数据中), 恢复冷却剩余
                    if (实例 instanceof 武器类) {
                        实例.自定义数据.set(
                            "冷却剩余",
                            配置.数据.get("冷却剩余") ?? 0
                        );
                    }
                    // 卷轴类: 恢复已解锁 (已在自定义数据中)

                    // 附魔卷轴: 恢复可用次数和效果函数
                    if (实例 instanceof 附魔卷轴) {
                        实例.可用次数 = 配置.数据.get("可用次数") ?? 1;
                        const 效果名 = 配置.数据.get("附魔效果名");
                        const 效果索引 = 实例.效果名.indexOf(效果名);
                        if (效果索引 !== -1) {
                            实例.附魔效果 = 实例.附魔池[效果索引];
                        } else {
                            console.warn(`无法恢复附魔卷轴效果: ${效果名}`);
                            // 可以设置一个默认效果或标记为无效
                        }
                    }

                    // 神秘商人 / 物品祭坛: 库存将在恢复楼层后处理 (需要全局物品映射完整)

                    // 宠物: 装备和技能将在恢复楼层/游戏状态后处理

                    // 折跃门: 目标房间将在恢复楼层后处理

                    // 炸弹: 倒计时等在自定义数据中

                    // 恢复地上物品的位置和状态
                    实例.x = 配置.x ?? null;
                    实例.y = 配置.y ?? null;
                    实例.是否被丢弃 = 配置.是否被丢弃 ?? false;

                    // 恢复装备状态（将在恢复玩家装备时处理）
                    实例.已装备 = false;
                    实例.装备槽位 = null;

                    return 实例;
                } catch (e) {
                    console.error(`恢复物品 ${物品数据.类名} 失败:`, e);
                    return null;
                }
            }

            /**
             * 恢复单个怪物实例 - 扩展版
             * @param {object} 怪物数据
             * @param {Map<string, 物品>} 全局物品实例映射
             * @param {Map<number, 怪物>} 当前楼层怪物映射 (用于存储恢复的实例)
             * @returns {怪物 | null}
             */
            function 恢复怪物(怪物数据, 全局物品实例映射, 当前楼层怪物映射) {
                if (!怪物数据 || !怪物数据.类名) return null;
                const 类构造器 = window[怪物数据.类名];
                if (!类构造器 || typeof 类构造器 !== "function") {
                    console.warn(`未找到怪物类构造器: ${怪物数据.类名}`);
                    return null;
                }
                try {
                    const 配置 = { ...怪物数据.配置 }; // 复制配置

                    // 恢复掉落物
                    let 掉落物实例 = null;
                    if (怪物数据.掉落物) {
                        const 临时物品标识映射 = new Map(); // 掉落物用临时映射
                        掉落物实例 = 恢复物品(
                            怪物数据.掉落物,
                            临时物品标识映射
                        );
                        if (掉落物实例) {
                            // 如果掉落物是全局物品（如玩家背包中的），确保使用全局实例
                            const 全局实例 = 全局物品实例映射.get(
                                怪物数据.掉落物.唯一标识符串
                            );
                            if (全局实例) 掉落物实例 = 全局实例;
                            else
                                全局物品实例映射.set(
                                    怪物数据.掉落物.唯一标识符串,
                                    掉落物实例.唯一标识
                                ); // 添加到全局
                        }
                    }
                    配置.掉落物 = 掉落物实例;

                    // --- 恢复基础属性 ---
                    // 构造函数可能依赖基础属性，先恢复它们
                    const 实例 = new 类构造器({
                        // 传递构造函数可能需要的核心参数
                        x: 配置.x,
                        y: 配置.y,
                        房间ID: 配置.房间ID,
                        强化: 配置.强化,
                        掉落物: 配置.掉落物, // 传递恢复的掉落物实例
                        // ... 其他构造函数可能需要的参数 ...
                    });

                    // --- 恢复状态 ---
                    实例.图标 = 配置.图标 ?? 实例.图标;
                    实例.基础生命值 = 配置.基础生命值 ?? 实例.生命值;
                    实例.基础攻击力 = 配置.基础攻击力 ?? 实例.生命值;
                    实例.当前生命值 = 配置.当前生命值 ?? 实例.生命值;
                    实例.状态 = 配置.状态 ?? 怪物状态.休眠;
                    实例.攻击冷却回合剩余 = 配置.攻击冷却剩余 ?? 0;
                    实例.受伤冻结回合剩余 = 配置.受伤冻结回合剩余 ?? 0;
                    实例.移动率 = 配置.移动率 ?? 实例.移动率; // 使用保存的值或默认值
                    实例.基础移动距离 = 配置.基础移动距离 ?? 实例.基础移动距离;
                    实例.基础攻击范围 = 配置.基础攻击范围 ?? 实例.基础攻击范围;
                    实例.跟踪距离 = 配置.跟踪距离 ?? 实例.跟踪距离;
                    实例.攻击冷却 = 配置.攻击冷却 ?? 实例.攻击冷却;
                    实例.受伤冻结回合 = 配置.受伤冻结回合 ?? 实例.受伤冻结回合;
                    实例.掉落概率 = 配置.掉落概率 ?? 实例.掉落概率;

                    // --- 恢复特定怪物状态 ---
                    if (实例 instanceof 腐蚀怪物) {
                        实例.腐蚀强度 = 配置.腐蚀强度 ?? 1;
                        实例.腐蚀持续 = 配置.腐蚀持续 ?? 4;
                    }
                    if (实例 instanceof 盗贼怪物) {
                        实例.偷窃几率 = 配置.偷窃几率 ?? 0.5;
                        实例.偷窃武器几率 = 配置.偷窃武器几率 ?? 0.15;
                        实例.偷到的金币 = 配置.偷到的金币 ?? 0;
                        实例.偷到的武器列表 = (配置.偷到的武器列表序列化 || [])
                            .map((wData) => 恢复物品(wData, 全局物品实例映射)) // 使用全局映射恢复
                            .filter((w) => w != null);
                    }
                    if (实例 instanceof 吸能怪物) {
                        实例.吸能比例 = 配置.吸能比例 ?? 0.3;
                        实例.最小吸能 = 配置.最小吸能 ?? 5;
                    }
                    if (实例 instanceof 剧毒云雾怪物) {
                        实例.毒云范围 = 配置.毒云范围 ?? 1;
                        实例.毒云持续 = 配置.毒云持续 ?? 3;
                        实例.毒云强度 = 配置.毒云强度 ?? 2;
                    }
                    if (实例 instanceof 召唤师怪物) {
                        实例.召唤冷却剩余 = 配置.召唤冷却剩余 ?? 0;
                        实例.最大召唤物数量 = 配置.最大召唤物数量 ?? 2;
                        实例.召唤物类 = window[配置.召唤物类名] || 幽灵仆从; // 恢复类引用
                        // 召唤物列表将在恢复楼层后链接
                        实例.临时召唤物索引列表 = 配置.当前召唤物索引列表 || [];
                    }
                    if (实例 instanceof 幽灵仆从) {
                        实例.生命周期 = 配置.生命周期 ?? 8;
                        // 召唤者将在恢复楼层后链接
                        实例.临时召唤者索引 = 配置.召唤者索引;
                    }
                    if (实例 instanceof 萨满怪物) {
                        实例.治疗冷却剩余 = 配置.治疗冷却剩余 ?? 0;
                        // 其他是常量
                    }
                    if (实例 instanceof 瞬移怪物) {
                        实例.瞬移几率 = 配置.瞬移几率 ?? 0.6;
                        实例.受击瞬移几率 = 配置.受击瞬移几率 ?? 0.4;
                    }
                    if (实例 instanceof 伪装怪物) {
                        实例.伪装状态 = 配置.伪装状态 ?? false; // 默认非伪装
                    }
                    if (实例 instanceof 炸弹怪物) {
                        实例.携带炸弹 = 配置.携带炸弹 ?? true;
                    }
                    if (实例 instanceof 大魔法师) {
                        实例.技能冷却 = 配置.技能冷却 ?? {
                            隐身术: 0,
                            分身术: 0,
                            火球术: 0,
                            冰冻术: 0,
                            传送术: 0,
                            召唤术: 0,
                        };
                        实例.隐身中 = 配置.隐身中 ?? false;
                        实例.isClone = 配置.isClone ?? false;
                        // 分身将在恢复楼层后链接
                        实例.临时分身索引 = 配置.分身索引;
                    }
                    if (实例 instanceof 旋风怪物) {
                        // 新增
                        实例.召唤冷却剩余 = 配置.召唤冷却剩余 ?? 0;
                        实例.最大召唤物数量 = 配置.最大召唤物数量 ?? 1;
                        // 暂存召唤物索引，待链接
                        实例.临时召唤物索引列表 = 配置.当前召唤物索引列表 || [];
                    }
                    if (实例 instanceof 旋风) {
                        // 新增
                        实例.生命周期 = 配置.生命周期 ?? 10;
                    }
                    // 存入怪物映射
                    if (怪物数据.怪物索引 !== undefined) {
                        当前楼层怪物映射.set(怪物数据.怪物索引, 实例);
                    }

                    // 恢复状态效果 (创建效果，但不立即应用)
                    if (怪物数据.状态效果) {
                        const 效果 = new 状态效果(
                            怪物数据.状态效果.类型,
                            怪物数据.状态效果.颜色,
                            怪物数据.状态效果.图标,
                            怪物数据.状态效果.持续时间,
                            怪物数据.状态效果.剩余回合,
                            null,
                            实例, // 关联怪物
                            怪物数据.状态效果.强度
                        );
                        // 效果的 应用/更新/移除 将在游戏循环中处理，这里只需创建并让 怪物状态表 知道它
                        // 怪物状态表 在恢复楼层完成后统一填充
                    }
                    实例.临时状态效果 = 怪物数据.状态效果; // 暂存

                    // 暂存仇恨标识，待所有怪物恢复后处理
                    实例.临时仇恨目标标识 = 配置.仇恨目标标识;

                    return 实例;
                } catch (e) {
                    console.error(`恢复怪物 ${怪物数据.类名} 失败:`, e);
                    return null;
                }
            }

            function 恢复楼层(
                层号,
                楼层存档数据,
                全局物品实例映射,
                全局物品标识映射
            ) {
                console.log(`开始恢复楼层 ${层号}`);
                if (!楼层存档数据) {
                    console.warn(`楼层 ${层号} 存档数据无效，跳过恢复`);
                    return null;
                }
                try {
                    const 楼层数据 = {
                        玩家位置: 楼层存档数据.玩家位置,
                        玩家初始位置: {
                            ...(楼层存档数据.玩家初始位置 || { x: 0, y: 0 }),
                        },
                        房间列表: [...(楼层存档数据.房间列表 || [])],
                        上锁房间列表: [...(楼层存档数据.上锁房间列表 || [])],
                        已访问房间: new Set(楼层存档数据.已访问房间数组 || []),
                        房间地图: [...(楼层存档数据.房间地图 || [])],
                        地牢数组: [],
                        所有怪物: [],
                        所有计时器: [],
                        门实例列表: new Map(),
                        当前天气效果: [...(楼层存档数据.当前天气效果 || [])],
                        已放置配方卷轴: 楼层存档数据.已放置配方卷轴 || false,
                    };

                    const 地上物品实例映射 = new Map();
                    if (楼层存档数据.序列化地上物品) {
                        楼层存档数据.序列化地上物品.forEach((物品数据) => {
                            let 实例 = 全局物品实例映射.get(
                                物品数据.唯一标识符串
                            );
                            if (!实例) {
                                实例 = 恢复物品(物品数据, 全局物品标识映射);
                                if (实例) {
                                    全局物品实例映射.set(
                                        物品数据.唯一标识符串,
                                        实例
                                    );
                                }
                            }
                            if (实例) {
                                地上物品实例映射.set(
                                    物品数据.唯一标识符串,
                                    实例
                                );
                                实例.x = 物品数据.配置?.x ?? null;
                                实例.y = 物品数据.配置?.y ?? null;
                            }
                        });
                    }

                    const 门实例映射 = new Map();
                    if (楼层存档数据.序列化门实例) {
                        楼层存档数据.序列化门实例.forEach((门数据) => {
                            let 唯一标识;
                            const 现有符号 = 全局物品标识映射.get(
                                门数据.唯一标识符串
                            );
                            if (现有符号) {
                                唯一标识 = 现有符号;
                            } else {
                                唯一标识 = Symbol(
                                    门数据.唯一标识符串.slice(7, -1)
                                );
                                全局物品标识映射.set(
                                    门数据.唯一标识符串,
                                    唯一标识
                                );
                            }

                            const 实例 = new 门({
                                关联房间ID: 门数据.房间ID,
                                位置: { ...门数据.所在位置 },
                            });
                            实例.唯一标识 = 唯一标识;
                            实例.类型 = 门数据.类型;
                            实例.是否上锁 = 门数据.是否上锁;
                            楼层数据.门实例列表.set(唯一标识, 实例);
                            门实例映射.set(门数据.唯一标识符串, 实例);
                        });
                    }

                    楼层数据.地牢数组 = Array(地牢大小)
                        .fill()
                        .map((_, y) =>
                            Array(地牢大小)
                                .fill()
                                .map((_, x) => {
                                    const 单元格数据 =
                                        楼层存档数据.序列化地牢格子?.[y]?.[x];
                                    return 恢复单元格(
                                        单元格数据,
                                        x,
                                        y,
                                        全局物品实例映射,
                                        new Map(),
                                        门实例映射
                                    );
                                })
                        );
                    for (let y = 0; y < 地牢大小; y++) {
                        for (let x = 0; x < 地牢大小; x++) {
                            const 单元格 = 楼层数据.地牢数组[y][x];
                            if (单元格.临时门标识符串) {
                                const 门实例 = 门实例映射.get(
                                    单元格.临时门标识符串
                                );
                                if (门实例) {
                                    单元格.标识 = 门实例.唯一标识;
                                }
                                delete 单元格.临时门标识符串;
                            }
                        }
                    }

                    const 当前楼层怪物映射 = new Map();
                    if (楼层存档数据.序列化怪物列表) {
                        楼层数据.所有怪物 = 楼层存档数据.序列化怪物列表
                            .map((怪物数据) =>
                                恢复怪物(
                                    怪物数据,
                                    全局物品实例映射,
                                    当前楼层怪物映射
                                )
                            )
                            .filter((m) => m != null);
                    }

                    楼层数据.所有怪物.forEach((怪物实例, 索引) => {
                        if (怪物实例.x !== null && 怪物实例.y !== null) {
                            const 单元格 =
                                楼层数据.地牢数组[怪物实例.y]?.[怪物实例.x];
                            if (单元格) {
                                if (!(单元格.关联怪物 instanceof 怪物)) {
                                    单元格.关联怪物 = 怪物实例;
                                    单元格.类型 = 单元格类型.怪物;
                                }
                            }
                        }
                        if (怪物实例.临时仇恨目标标识) {
                            const 标识 = 怪物实例.临时仇恨目标标识;
                            if (标识 === "玩家") {
                                怪物实例.仇恨 = 玩家;
                            } else if (标识.startsWith("怪物_")) {
                                const 仇恨索引 = parseInt(标识.split("_")[1]);
                                怪物实例.仇恨 =
                                    当前楼层怪物映射.get(仇恨索引) || null;
                            }
                            delete 怪物实例.临时仇恨目标标识;
                        }
                        if (
                            怪物实例 instanceof 召唤师怪物 &&
                            怪物实例.临时召唤物索引列表
                        ) {
                            怪物实例.当前召唤物列表 =
                                怪物实例.临时召唤物索引列表
                                    .map((召唤索引) =>
                                        当前楼层怪物映射.get(召唤索引)
                                    )
                                    .filter((仆从) => 仆从 != null);
                            delete 怪物实例.临时召唤物索引列表;
                        }
                        if (
                            怪物实例 instanceof 幽灵仆从 &&
                            怪物实例.临时召唤者索引 !== undefined
                        ) {
                            怪物实例.召唤者 =
                                当前楼层怪物映射.get(怪物实例.临时召唤者索引) ||
                                null;
                            delete 怪物实例.临时召唤者索引;
                        }
                        if (
                            怪物实例 instanceof 大魔法师 &&
                            怪物实例.临时分身索引 !== undefined
                        ) {
                            怪物实例.分身 =
                                当前楼层怪物映射.get(怪物实例.临时分身索引) ||
                                null;
                            delete 怪物实例.临时分身索引;
                        }
                        if (
                            怪物实例 instanceof 旋风怪物 &&
                            怪物实例.临时召唤物索引列表
                        ) {
                            怪物实例.当前召唤物列表 =
                                怪物实例.临时召唤物索引列表
                                    .map((召唤索引) =>
                                        当前楼层怪物映射.get(召唤索引)
                                    )
                                    .filter((旋) => 旋 instanceof 旋风);
                            delete 怪物实例.临时召唤物索引列表;
                        }
                        if (怪物实例.临时状态效果) {
                            const 状态数据 = 怪物实例.临时状态效果;
                            new 状态效果(
                                状态数据.类型,
                                状态数据.颜色,
                                状态数据.图标,
                                状态数据.持续时间,
                                状态数据.剩余回合,
                                null,
                                怪物实例,
                                状态数据.强度
                            );
                            delete 怪物实例.临时状态效果;
                        }
                    });

                    if (楼层存档数据.序列化物品列表) {
                        楼层数据.所有计时器 = 楼层存档数据.序列化物品列表
                            .map((物品数据) => {
                                // Changed from 炸弹数据 to 物品数据 for clarity
                                let 实例 = 全局物品实例映射.get(
                                    物品数据.唯一标识符串
                                );
                                if (!实例) {
                                    实例 = 恢复物品(物品数据, 全局物品标识映射);
                                    if (实例)
                                        全局物品实例映射.set(
                                            物品数据.唯一标识符串,
                                            实例
                                        );
                                }
                                return 实例;
                            })
                            .filter((b) => b != null);
                    }

                    for (const 物品实例 of 全局物品实例映射.values()) {
                        if (物品实例 instanceof 宠物) {
                            const 装备标识 =
                                物品实例.自定义数据.get("装备标识") || {};
                            const 恢复后装备 = {};
                            for (const 槽位 in 装备标识) {
                                const 标识符串 = 装备标识[槽位];
                                if (标识符串) {
                                    const 装备物品实例 =
                                        全局物品实例映射.get(标识符串);
                                    if (
                                        装备物品实例 &&
                                        ((槽位 === "武器" &&
                                            装备物品实例 instanceof 武器类) ||
                                            (槽位 === "防具" &&
                                                装备物品实例 instanceof
                                                    防御装备类))
                                    ) {
                                        恢复后装备[槽位] = 装备物品实例;
                                    }
                                } else {
                                    恢复后装备[槽位] = null;
                                }
                            }
                            物品实例.自定义数据.set("装备", 恢复后装备);
                        } else if (物品实例 instanceof 折跃门) {
                            const 目标房间ID =
                                物品实例.自定义数据.get("目标房间");
                            if (
                                目标房间ID !== null &&
                                目标房间ID !== undefined
                            ) {
                                const 目标房间 = 楼层数据.房间列表.find(
                                    (r) => r.id === 目标房间ID.id
                                );
                                if (目标房间) {
                                    物品实例.自定义数据.set(
                                        "目标房间",
                                        目标房间
                                    );
                                }
                            } else {
                                物品实例.自定义数据.set("目标房间", null);
                            }
                        } else if (
                            物品实例 instanceof 神秘商人 ||
                            物品实例 instanceof 物品祭坛
                        ) {
                            const 库存序列化 =
                                物品实例.自定义数据.get("库存序列化") || [];
                            const 恢复后库存 = [];
                            库存序列化.forEach((物品数据) => {
                                let 库存物品实例 = 全局物品实例映射.get(
                                    物品数据.唯一标识符串
                                );
                                if (!库存物品实例) {
                                    库存物品实例 = 恢复物品(
                                        物品数据,
                                        全局物品标识映射
                                    );
                                    if (库存物品实例)
                                        全局物品实例映射.set(
                                            物品数据.唯一标识符串,
                                            库存物品实例
                                        );
                                }
                                if (库存物品实例) {
                                    恢复后库存.push(库存物品实例);
                                }
                            });
                            物品实例.自定义数据.set("库存", 恢复后库存);
                        }
                    }
                    if (
                        楼层存档数据.挑战状态列表 &&
                        Array.isArray(楼层存档数据.挑战状态列表)
                    ) {
                        楼层存档数据.挑战状态列表.forEach((存档的挑战状态) => {
                            const 对应房间 = 楼层数据.房间列表.find(
                                (r) => r.id === 存档的挑战状态.id
                            );
                            if (对应房间 && 存档的挑战状态.状态) {
                                对应房间.类型 = "挑战房间"; // 确保类型被正确设置
                                对应房间.挑战状态 = JSON.parse(
                                    JSON.stringify(存档的挑战状态.状态)
                                ); // 深拷贝恢复

                                // 恢复怪物引用
                                if (
                                    对应房间.挑战状态.波次内怪物 &&
                                    Array.isArray(对应房间.挑战状态.波次内怪物)
                                ) {
                                    对应房间.挑战状态.波次内怪物 =
                                        对应房间.挑战状态.波次内怪物
                                            .map((怪物标识符) => {
                                                if (
                                                    typeof 怪物标识符 ===
                                                        "string" &&
                                                    怪物标识符.startsWith(
                                                        "怪物_"
                                                    )
                                                ) {
                                                    const 索引 = parseInt(
                                                        怪物标识符.split("_")[1]
                                                    );
                                                    return (
                                                        楼层数据.所有怪物[
                                                            索引
                                                        ] || null
                                                    ); // 从已恢复的楼层怪物列表中获取
                                                }
                                                return null;
                                            })
                                            .filter((m) => m !== null);
                                }

                                // 恢复原始门数据中的Symbol标识
                                if (
                                    对应房间.挑战状态.原始门数据 &&
                                    Array.isArray(对应房间.挑战状态.原始门数据)
                                ) {
                                    对应房间.挑战状态.原始门数据.forEach(
                                        (门数据) => {
                                            if (
                                                门数据.原标识 &&
                                                typeof 门数据.原标识 ===
                                                    "string"
                                            ) {
                                                let 门符号 =
                                                    全局物品标识映射.get(
                                                        门数据.原标识
                                                    ); // 尝试从全局映射获取
                                                if (
                                                    !门符号 &&
                                                    门数据.原标识.startsWith(
                                                        "Symbol("
                                                    )
                                                ) {
                                                    const description =
                                                        门数据.原标识.slice(
                                                            7,
                                                            -1
                                                        );
                                                    门符号 =
                                                        Symbol(description); // 重新创建Symbol
                                                    全局物品标识映射.set(
                                                        门数据.原标识,
                                                        门符号
                                                    ); // 更新全局映射
                                                }
                                                门数据.原标识 =
                                                    门符号 || 门数据.原标识; // 使用恢复的Symbol或原始字符串
                                            }
                                        }
                                    );
                                }
                            }
                        });
                    }
                    console.log(`楼层 ${层号} 恢复完成`);
                    return 楼层数据;
                } catch (e) {
                    console.error(`恢复楼层 ${层号} 失败:`, e);
                    return null;
                }
            }

            function 恢复游戏状态(存档数据) {
                console.log("开始恢复游戏状态...");
                if (!存档数据) {
                    console.error("无效的存档数据，无法恢复。");
                    显示通知("存档数据损坏，无法加载！", "错误");
                    return;
                }
                重置所有游戏状态();
                try {
                    当前层数 = 存档数据.当前层数 ?? 0;
                    玩家属性 = {
                        ...初始玩家属性,
                        ...(存档数据.玩家?.属性 || {}),
                    };
                    最大背包容量 = 存档数据.玩家?.最大背包容量 ?? 12;
                    教程阶段 = 存档数据.教程?.阶段 ?? 0;
                    最高教程阶段 = 存档数据.教程?.最高阶段 ?? 0;
                    是否为教程层 = 存档数据.教程?.是否教程层 ?? false;
                    hud模式 = 存档数据.UI?.hud模式 ?? "默认";
                    显示模式 = 存档数据.UI?.显示模式 ?? "装备";

                    已击杀怪物数 = 存档数据.游戏统计?.已击杀怪物数 ?? 0;
                    日志历史 = 存档数据.UI?.日志历史 || [];
                    最大装备槽数量 = 存档数据.玩家?.最大装备槽数量 ?? 8;
                    当前装备页 = 存档数据.UI?.当前装备页 ?? 0;
                    上次死亡地点 = 存档数据.上次死亡地点 || null;
                    程序生成配方列表 =
                        存档数据.配方信息?.程序生成配方列表 || [];
                    已发现的程序生成配方 =
                        存档数据.配方信息?.已发现的程序生成配方 || [];

                    已发现的程序生成配方.forEach((discoveredRecipe) => {
                        if (
                            !融合配方列表.some(
                                (r) => r.说明 === discoveredRecipe.说明
                            )
                        ) {
                            融合配方列表.push(discoveredRecipe);
                        }
                    });

                    日志历史.forEach((log) => 添加日志(log.内容, log.类型));
                    击杀提示.更新({ 内容: `已击杀怪物: ${已击杀怪物数}` });

                    const 全局物品实例映射 = new Map();
                    const 全局物品标识映射 = new Map();

                    玩家背包 = new Map();
                    if (存档数据.玩家?.背包) {
                        存档数据.玩家.背包.forEach((物品数据) => {
                            const 实例 = 恢复物品(物品数据, 全局物品标识映射);
                            if (实例) {
                                玩家背包.set(实例.唯一标识, 实例);
                                全局物品实例映射.set(
                                    物品数据.唯一标识符串,
                                    实例
                                );
                            }
                        });
                    }

                    玩家装备 = new Map();
                    if (存档数据.玩家?.装备) {
                        存档数据.玩家.装备.forEach((装备数据) => {
                            const 实例 = 全局物品实例映射.get(
                                装备数据.唯一标识符串
                            );
                            if (实例) {
                                实例.已装备 = true;
                                实例.装备槽位 = 装备数据.槽位;
                                玩家装备.set(实例.装备槽位, 实例);
                            }
                        });
                    }

                    所有地牢层 = new Map();
                    if (存档数据.所有地牢层数据) {
                        for (const [层号Str, 楼层存档] of Object.entries(
                            存档数据.所有地牢层数据
                        )) {
                            const 层号 = parseInt(层号Str);
                            if (!isNaN(层号) && 楼层存档) {
                                const 恢复后楼层 = 恢复楼层(
                                    层号,
                                    楼层存档,
                                    全局物品实例映射,
                                    全局物品标识映射
                                );
                                if (恢复后楼层) {
                                    所有地牢层.set(层号, 恢复后楼层);
                                }
                            }
                        }
                    }
                    生存挑战激活 = 存档数据.生存挑战激活 || false;
                    生存挑战备份单元格 = []; // 先清空
        if (存档数据.序列化生存挑战备份单元格 && 生存挑战激活) {
            const 当前楼层数据 = 所有地牢层.get(当前层数);
            if (当前楼层数据) {
                存档数据.序列化生存挑战备份单元格.forEach(序列化备份 => {
                    const 恢复的备份 = {
                        x: 序列化备份.x,
                        y: 序列化备份.y,
                        类型: 序列化备份.类型,
                        背景类型: 序列化备份.背景类型,
                        墙壁: { ...序列化备份.墙壁 },
                        颜色索引: 序列化备份.颜色索引,
                        标识: 序列化备份.标识 ? Symbol(序列化备份.标识.slice(7, -1)) : null,
                        关联物品: null,
                        关联怪物: null,
                    };

                    // 从ID恢复物品和怪物实例
                    if (序列化备份.关联物品标识) {
                        恢复的备份.关联物品 = 全局物品实例映射.get(序列化备份.关联物品标识) || null;
                    }
                    if (序列化备份.关联怪物索引 !== null) {
                        恢复的备份.关联怪物 = 当前楼层数据.所有怪物[序列化备份.关联怪物索引] || null;
                    }
                    生存挑战备份单元格.push(恢复的备份);
                });
            }
        }

                    传送点列表 = 存档数据.传送点列表 || [];
                    if (所有地牢层.has(当前层数)) {
                        const 当前楼层数据 = 所有地牢层.get(当前层数);
                        地牢 = 当前楼层数据.地牢数组;
                        房间列表 = 当前楼层数据.房间列表;
                        上锁房间列表 = 当前楼层数据.上锁房间列表;
                        已访问房间 = 当前楼层数据.已访问房间;
                        房间地图 = 当前楼层数据.房间地图;
                        门实例列表 = 当前楼层数据.门实例列表;
                        所有怪物 = 当前楼层数据.所有怪物;
                        所有计时器 = 当前楼层数据.所有计时器;
                        玩家初始位置 = 当前楼层数据.玩家初始位置;
                        当前天气效果 = 当前楼层数据.当前天气效果;

                        玩家.x =
                            存档数据.玩家?.x ??
                            当前楼层数据.玩家位置?.x ??
                            玩家初始位置.x;
                        玩家.y =
                            存档数据.玩家?.y ??
                            当前楼层数据.玩家位置?.y ??
                            玩家初始位置.y;

                        怪物状态表 = new WeakMap();
                        所有怪物.forEach((怪物) => {
                            const 怪物存档数据 = 存档数据.所有地牢层数据[
                                当前层数
                            ]?.序列化怪物列表?.find(
                                (m) =>
                                    怪物.x === m.配置.x && 怪物.y === m.配置.y
                            );
                            if (怪物存档数据?.状态效果) {
                                new 状态效果(
                                    怪物存档数据.状态效果.类型,
                                    怪物存档数据.状态效果.颜色,
                                    怪物存档数据.状态效果.图标,
                                    怪物存档数据.状态效果.持续时间,
                                    怪物存档数据.状态效果.剩余回合,
                                    null,
                                    怪物,
                                    怪物存档数据.状态效果.强度
                                );
                            }
                        });
                    } else {
                        console.warn(
                            `存档中未找到当前层 ${当前层数} 的数据，将重新生成！`
                        );
                        房间列表 = [];
                        上锁房间列表 = [];
                        所有怪物 = [];
                        所有计时器 = [];
                        已访问房间 = new Set();
                        门实例列表 = new Map();
                        房间地图 = Array(地牢大小)
                            .fill()
                            .map(() => Array(地牢大小).fill(-1));
                        生成地牢();
                        生成并放置随机配方卷轴(当前层数);
                        玩家.x = 玩家初始位置.x;
                        玩家.y = 玩家初始位置.y;
                        if (房间列表.length > 0) 已访问房间.add(房间列表[0].id);
                    }

                    玩家状态 = [];
                    if (存档数据.玩家?.状态) {
                        存档数据.玩家.状态.forEach((状态数据) => {
                            let 来源实例 = null;
                            if (状态数据.来源标识符串) {
                                来源实例 = 全局物品实例映射.get(
                                    状态数据.来源标识符串
                                );
                            }
                            new 状态效果(
                                状态数据.类型,
                                状态数据.颜色,
                                状态数据.图标,
                                状态数据.持续时间,
                                状态数据.剩余回合,
                                来源实例,
                                null,
                                状态数据.强度
                            );
                        });
                    }
                    if (存档数据.永久Buffs) {
                        永久Buffs = { ...存档数据.永久Buffs };
                        永久Buffs.已获得效果 = new Set(存档数据.永久Buffs.已获得效果 || []);
                    } else {
                        永久Buffs = { 已获得效果: new Set() }; // 兼容旧存档
                    }
                    应用永久Buffs(); 

                    当前激活卷轴列表 = new Set();
                    if (存档数据.UI?.激活卷轴列表) {
                        存档数据.UI.激活卷轴列表.forEach((标识符串) => {
                            const 实例 = 全局物品实例映射.get(标识符串);
                            if (实例 instanceof 卷轴类) {
                                当前激活卷轴列表.add(实例);
                                实例.使用();
                            }
                        });
                    }
                    const 保存的生命百分比 =
                        存档数据.玩家?.当前生命值百分比 ?? 100;
                    const 保存的能量百分比 =
                        存档数据.玩家?.当前能量值百分比 ?? 100;
                    const healthBar = document.querySelector(".health-bar");
                    const powerBar = document.querySelector(".power-bar");
                    if (healthBar) {
                        healthBar.style.width = `${Math.max(
                            0,
                            Math.min(100, 保存的生命百分比)
                        )}%`;
                        if (保存的生命百分比 <= 20)
                            healthBar.classList.add("低数值警告");
                        else healthBar.classList.remove("低数值警告");
                    }
                    if (powerBar) {
                        powerBar.style.width = `${Math.max(
                            0,
                            Math.min(100, 保存的能量百分比)
                        )}%`;
                        if (保存的能量百分比 <= 20)
                            powerBar.classList.add("低数值警告");
                        else powerBar.classList.remove("低数值警告");
                    }
                    
                    

                    console.log("游戏状态恢复完成！");
                } catch (错误) {
                    console.error("恢复游戏状态时发生严重错误:", 错误);
                    显示通知("加载存档时发生严重错误，将开始新游戏。", "错误");
                    显示主菜单();
                }
            }

            function 导出存档() {
                if (是否为教程层) {
                    显示通知("不支持在教程关卡导出存档", "错误");
                    return;
                }
                if (游戏状态 === "图鉴") {
                    显示通知("不支持在图鉴导出存档", "错误");
                    return;
                }
                玩家属性.允许移动 -= 1;

                const 存档字符串 = 保存游戏状态(); // 调用只返回字符串的版本
                玩家属性.允许移动 += 1;
                if (存档字符串) {
                    const 数据块 = new Blob([存档字符串], {
                        type: "application/json",
                    });
                    const 下载链接 = URL.createObjectURL(数据块);
                    const 链接元素 = document.createElement("a");
                    链接元素.href = 下载链接;
                    // 文件名包含日期和时间戳
                    const 时间戳 = new Date()
                        .toISOString()
                        .replace(/[:.]/g, "-");
                    链接元素.download = `中文地牢存档_${时间戳}.json`;
                    document.body.appendChild(链接元素);
                    链接元素.click(); // 模拟点击下载
                    document.body.removeChild(链接元素); // 清理 DOM
                    URL.revokeObjectURL(下载链接); // 释放对象 URL
                    显示通知("存档已导出为文件。", "成功"); // 导出成功提示
                } else {
                    显示通知("导出存档失败！", "错误"); // 保存失败时提示
                }
            }

            function 导入存档(存档字符串) {
                try {
                    const 存档数据 = JSON.parse(存档字符串);
                    // 在这里可以添加更严格的存档数据结构验证
                    if (存档数据 && 存档数据.版本) {
                        if (存档数据.版本 === 存档版本) {
                            启动游戏(存档数据);
                        } else {
                            显示通知("存档版本不匹配！", "错误");
                        }
                    } else {
                        显示通知("存档数据无效或缺少版本信息！", "错误");
                    }
                } catch (错误) {
                    console.error("导入存档失败:", 错误);
                    显示通知("导入存档失败，数据格式错误或损坏！", "错误");
                }
            }
            // --- 菜单按钮事件监听 ---
            新建游戏按钮.addEventListener("click", () => {
                启动游戏();
            });

            读取存档按钮.addEventListener("click", () => {
                const 文件输入控件 = document.getElementById("存档文件输入");
                文件输入控件.value = ""; // 清空，确保 change 事件触发
                文件输入控件.click(); // 打开文件选择对话框
            });

            const 存档文件输入控件 = document.getElementById("存档文件输入");
            存档文件输入控件.addEventListener("change", (事件) => {
                const 选择的文件 = 事件.target.files[0];
                if (!选择的文件) {
                    return; // 用户取消
                }

                if (!选择的文件.name.toLowerCase().endsWith(".json")) {
                    显示通知("请选择有效的 JSON 存档文件！", "错误");
                    return;
                }

                const 文件阅读器 = new FileReader();

                文件阅读器.onload = (读取事件) => {
                    const 存档字符串 = 读取事件.target.result;
                    导入存档(存档字符串); // 调用导入函数处理文件内容
                };

                文件阅读器.onerror = (错误事件) => {
                    console.error("读取文件时出错:", 错误事件);
                    显示通知("读取存档文件失败！", "错误");
                };

                文件阅读器.readAsText(选择的文件); // 读取文件内容为文本
            });

            读凭证按钮.addEventListener("click", () => {
                const 凭证 = prompt("请输入死亡凭证:");
                if (凭证) {
                    const parts = 凭证.split("-");
                    if (parts.length === 3) {
                        const L = parseInt(parts[0]);
                        if (!isNaN(L) && 验证死亡凭证(凭证, L)) {
                            alert(`凭证有效！记录最高层数：${L}`);
                        } else {
                            alert("无效的死亡凭证！");
                        }
                    } else {
                        alert("凭证格式错误！");
                    }
                }
            });
            function 生成图鉴地牢(分区索引 = 0, 每层条目数 = 9) {
                // 提供默认值
                // 初始化地牢数据结构
                地牢 = Array(地牢大小)
                    .fill()
                    .map((_, y) =>
                        Array(地牢大小)
                            .fill()
                            .map((_, x) => new 单元格(x, y))
                    );
                房间列表 = [];
                上锁房间列表 = []; // 图鉴中没有上锁的房间
                所有怪物 = []; // 清空怪物列表，稍后按需添加静态怪物
                怪物状态表 = new WeakMap(); // 重置怪物状态表
                门实例列表 = new Map();
                房间地图 = Array(地牢大小)
                    .fill()
                    .map(() => Array(地牢大小).fill(-1));
                已访问房间 = new Set(); // 稍后会将所有图鉴房间标记为已访问

                // --- 合并物品和怪物定义，并标记类型 ---
                const 所有条目定义 = [
                    ...所有物品定义.map((def) => ({
                        ...def,
                        图鉴类型: "物品",
                    })),
                    ...所有怪物定义.map((def) => ({
                        ...def,
                        图鉴类型: "怪物",
                    })),
                ];
                const 总条目数 = 所有条目定义.length;

                // 定义图鉴房间和布局参数
                const 房间尺寸 = 5; // 图鉴展示房间的大小
                const 间距 = -1; // 房间之间的间距
                const 走廊宽度 = 3; // 中心走廊的宽度
                const 中心Y = Math.floor(地牢大小 / 2); // 走廊垂直居中

                // --- 计算当前分区要显示的条目范围 ---
                const 起始条目索引 = 分区索引 * 每层条目数;
                const 结束条目索引 = Math.min(
                    起始条目索引 + 每层条目数,
                    总条目数
                ); // 包含起始，不包含结束
                const 当前分区条目数 = 结束条目索引 - 起始条目索引;
                if (当前分区条目数 <= 0) {
                    console.warn(`图鉴分区 ${分区索引 + 1} 没有条目可显示。`);
                    // 设置玩家初始位置到默认点
                    玩家初始位置.x = Math.floor(地牢大小 / 2);
                    玩家初始位置.y = 中心Y;
                    玩家.x = 玩家初始位置.x;
                    玩家.y = 玩家初始位置.y;
                    更新视口();
                    return; // 直接返回，不生成内容
                }

                // 1. 创建中心走廊 (长度根据当前分区条目数计算)
                const 走廊起始X = 5; // 走廊开始的X坐标
                const 走廊结束X = Math.min(
                    地牢大小 - 2,
                    走廊起始X + 当前分区条目数 * (房间尺寸 + 间距) + 4
                );
                for (let x = 走廊起始X; x <= 走廊结束X; x++) {
                    for (
                        let dy = -Math.ceil(走廊宽度 / 2);
                        dy <= Math.floor(走廊宽度 / 2);
                        dy++
                    ) {
                        const y = 中心Y + dy;
                        if (y >= 0 && y < 地牢大小 && 地牢[y]?.[x]) {
                            // 确保坐标有效
                            地牢[y][x].背景类型 = 单元格类型.走廊;
                        }
                    }
                }

                // 2. 放置展示房间和内容
                let 当前X = 走廊起始X + 4; // 第一个房间的起始X坐标
                let 房间ID计数 = 0;
                let 实际放置条目计数 = 0; // 用于交替放置

                // 辅助函数：放置一个展示条目（物品或怪物）
                const 放置条目 = (条目定义, 类型) => {
                    // 计算房间Y坐标，上下交替放置
                    const 房间Y偏移 = Math.floor(走廊宽度 / 2) + 2; // 上下偏移相同
                    const 房间Y =
                        中心Y +
                        (实际放置条目计数 % 2 === 0
                            ? -(房间Y偏移 + 房间尺寸)
                            : 房间Y偏移); // 使用实际放置计数来交替
                    const 房间起始X = 当前X;
                    const 房间起始Y = 房间Y;

                    // 边界检查，防止房间超出地牢范围
                    if (
                        房间起始X + 房间尺寸 >= 地牢大小 ||
                        房间起始Y < 0 ||
                        房间起始Y + 房间尺寸 >= 地牢大小
                    ) {
                        console.warn(
                            `图鉴房间 ${房间ID计数} (类型: ${类型}) 在 (${房间起始X}, ${房间起始Y}) 超出边界，跳过。`
                        );
                        当前X += 房间尺寸 + 间距; // 即使跳过也要增加X坐标，防止重叠
                        //房间ID计数++; // ID计数现在与实际放置条目解耦
                        return false; // 跳过这个条目
                    }

                    // 创建房间对象
                    const 新房间 = {
                        x: 房间起始X,
                        y: 房间起始Y,
                        w: 房间尺寸,
                        h: 房间尺寸,
                        id: 房间ID计数,
                        门: [],
                        类型: "图鉴展示", // 特殊房间类型
                    };
                    房间列表.push(新房间);
                    放置房间(新房间); // 在地牢数组中实际放置房间格子

                    // 连接房间和走廊（简化版，直接在中间放门）
                    let 门X = 房间起始X + Math.floor(房间尺寸 / 2);
                    let 门Y房间侧, 门Y走廊侧;
                    if (实际放置条目计数 % 2 === 0) {
                        // 房间在走廊上方
                        门Y房间侧 = 房间起始Y + 房间尺寸 - 1; // 房间底部
                        门Y走廊侧 = 门Y房间侧 + 1; // 走廊顶部
                    } else {
                        // 房间在走廊下方
                        门Y房间侧 = 房间起始Y; // 房间顶部
                        门Y走廊侧 = 门Y房间侧 - 1; // 走廊底部
                    }

                    // 确保门的位置有效再放置
                    if (地牢[门Y房间侧]?.[门X] && 地牢[门Y走廊侧]?.[门X]) {
                        const 门实例 = new 门({
                            关联房间ID: 新房间.id,
                            位置: { x: 门X, y: 门Y房间侧 },
                        }); // 创建逻辑门
                        地牢[门Y房间侧][门X].背景类型 = 单元格类型.门;
                        地牢[门Y走廊侧][门X].背景类型 = 单元格类型.门;
                        地牢[门Y房间侧][门X].标识 = 门实例.唯一标识; // 关联标识
                        地牢[门Y走廊侧][门X].标识 = 门实例.唯一标识;
                        门实例列表.set(门实例.唯一标识, 门实例); // 添加到全局列表
                        新房间.门.push({ x: 门X, y: 门Y房间侧 }); // 记录门位置
                        新房间.门.push({ x: 门X, y: 门Y走廊侧 });
                        // 更新房间墙壁状态以移除门处的墙壁 (放置后立即处理)
                        地牢[门Y房间侧][门X].墙壁 = {
                            上: false,
                            下: false,
                            左: false,
                            右: false,
                        };
                        地牢[门Y走廊侧][门X].墙壁 = {
                            上: false,
                            下: false,
                            左: false,
                            右: false,
                        };
                        // 同时清除相邻走廊/房间格子的对应墙壁
                        if (地牢[门Y房间侧 + 1]?.[门X])
                            地牢[门Y房间侧 + 1][门X].墙壁.上 = false;
                        if (地牢[门Y房间侧 - 1]?.[门X])
                            地牢[门Y房间侧 - 1][门X].墙壁.下 = false;
                        if (地牢[门Y走廊侧 + 1]?.[门X])
                            地牢[门Y走廊侧 + 1][门X].墙壁.上 = false;
                        if (地牢[门Y走廊侧 - 1]?.[门X])
                            地牢[门Y走廊侧 - 1][门X].墙壁.下 = false;
                    } else {
                        console.warn(
                            `无法为图鉴房间 ${新房间.id} 在 (${门X}, ${门Y房间侧}) 和 (${门X}, ${门Y走廊侧}) 放置门。`
                        );
                    }

                    // 在房间中心放置物品或怪物
                    const 放置X = 房间起始X + Math.floor(房间尺寸 / 2);
                    const 放置Y = 房间起始Y + Math.floor(房间尺寸 / 2);
                    if (类型 === "物品") {
                        try {
                            const 实例 = new 条目定义.类({}); // 创建物品实例
                            实例.堆叠数量 = 1; // 图鉴中只显示一个
                            if (实例 instanceof 卷轴类) {
                                实例.自定义数据.set("已解锁", true);
                            }
                            放置物品到单元格(实例, 放置X, 放置Y); // 放置物品
                        } catch (错误) {
                            console.error(
                                `图鉴：无法实例化物品 ${条目定义.类?.name}:`,
                                错误
                            );
                        }
                    } else if (类型 === "怪物") {
                        try {
                            const 实例 = new 条目定义.类({
                                x: 放置X,
                                y: 放置Y,
                                状态: 怪物状态.休眠,
                            }); // 创建怪物实例
                            实例.状态 = 怪物状态.休眠; // 设置为休眠状态
                            放置怪物到单元格(实例, 放置X, 放置Y); // 放置怪物
                        } catch (错误) {
                            console.error(
                                `图鉴：无法实例化怪物 ${条目定义.类?.name}:`,
                                错误
                            );
                        }
                    }

                    // 更新下一个房间的起始X坐标和房间ID
                    当前X += 房间尺寸 + 间距;
                    房间ID计数++;
                    实际放置条目计数++; // 增加实际放置计数
                    return true; // 放置成功
                };

                // 只放置当前分区的条目
                for (let i = 起始条目索引; i < 结束条目索引; i++) {
                    const 当前条目定义 = 所有条目定义[i];
                    放置条目(当前条目定义, 当前条目定义.图鉴类型);
                }

                // 3. 设置玩家初始位置
                玩家初始位置.x = 走廊起始X + 1; // 放在走廊起点附近
                玩家初始位置.y = 中心Y;
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;
                const 总分区数 = Math.ceil(总条目数 / 每层条目数);
                const 楼梯上X = 走廊起始X;
                const 楼梯上Y = 中心Y;
                const 楼梯下X = 走廊结束X;
                const 楼梯下Y = 中心Y;

                // 上楼楼梯 (放在走廊起点)
                if (分区索引 > 0) {
                    // 只有非第一分区才有上楼梯
                    const 上楼梯实例 = {
                        图标: 楼梯图标.上楼,
                        显示图标: 楼梯图标.上楼,
                        类型: "楼梯", // 确保类型正确
                        使用: () => {
                            进入图鉴地牢(分区索引 - 1, 每层条目数);
                        },
                        获取名称: () => "上一个分区",
                        唯一标识: Symbol("图鉴上楼梯"), // 给个唯一标识
                        自定义数据: new Map(),
                        品质: 1,
                        颜色索引: 颜色表.length,
                        堆叠数量: 1,
                        最大堆叠数量: 1,
                        能否拾起: false,
                        是否正常物品: false,
                        是否隐藏: false,
                        是否为隐藏物品: false,
                        效果描述: null,
                        已装备: false,
                        装备槽位: null,
                        颜色表: 颜色表,
                    };
                    // 确保放置位置有效
                    if (
                        地牢[楼梯上Y]?.[楼梯上X] &&
                        地牢[楼梯上Y][楼梯上X].背景类型 === 单元格类型.走廊
                    ) {
                        放置物品到单元格(
                            上楼梯实例,
                            楼梯上X,
                            楼梯上Y,
                            单元格类型.楼梯上楼
                        );
                    } else {
                        console.warn(
                            `无法在 (${楼梯上X}, ${楼梯上Y}) 放置上楼梯`
                        );
                    }
                }

                // 下楼楼梯 (放在走廊终点)
                if (分区索引 < 总分区数 - 1) {
                    // 只有非最后一分区才有下楼梯
                    const 下楼梯实例 = {
                        图标: 楼梯图标.下楼,
                        显示图标: 楼梯图标.下楼,
                        类型: "楼梯", // 确保类型正确
                        使用: () => {
                            进入图鉴地牢(分区索引 + 1, 每层条目数);
                        },
                        获取名称: () => "下一个分区",
                        唯一标识: Symbol("图鉴下楼梯"), // 给个唯一标识
                        自定义数据: new Map(),
                        品质: 1,
                        颜色索引: 颜色表.length,
                        堆叠数量: 1,
                        最大堆叠数量: 1,
                        能否拾起: false,
                        是否正常物品: false,
                        是否隐藏: false,
                        是否为隐藏物品: false,
                        效果描述: null,
                        已装备: false,
                        装备槽位: null,
                        颜色表: 颜色表,
                    };
                    // 确保放置位置有效
                    if (
                        地牢[楼梯下Y]?.[楼梯下X] &&
                        地牢[楼梯下Y][楼梯下X].背景类型 === 单元格类型.走廊
                    ) {
                        放置物品到单元格(
                            下楼梯实例,
                            楼梯下X,
                            楼梯下Y,
                            单元格类型.楼梯下楼
                        );
                    } else {
                        console.warn(
                            `无法在 (${楼梯下X}, ${楼梯下Y}) 放置下楼梯`
                        );
                    }
                }
                const 初始武器 = new 钢制长剑({ 不可破坏: true });
                放置物品到单元格(初始武器, 玩家.x + 2, 玩家.y);
                放置物品到单元格(
                    new 迅捷卷轴({
                        数量: 1,
                        已解锁: true,
                        能量消耗: 0,
                    }),
                    玩家.x + 1,
                    玩家.y
                );

                // 4. 最后处理墙壁和视野
                生成墙壁(); // 生成所有墙壁
                房间列表.forEach((房间) => 更新房间墙壁(房间)); // 清除门周围墙壁

                更新视口(); // 更新玩家视野
            }
            function 进入图鉴地牢(分区索引, 每层条目数) {
                // 图鉴模式的特定重置
                当前层数 = -2 - 分区索引; // 用负数区分不同分区
                最大背包容量 = 24;
                所有地牢层 = new Map();
                document.getElementById("logContent").innerHTML = "";
                document.querySelector(".health-bar").style.width = "100%";
                document.querySelector(".power-bar").style.width = "100%";

                生成图鉴地牢(分区索引, 每层条目数); // 调用生成函数，传入分区信息

                更新背包显示();
                更新装备显示();
                更新界面状态();
                动画帧(); // 启动动画
                隐藏主菜单(); // 确保主菜单隐藏
                是否为教程层 = false;
                document.getElementById("跳过教程按钮").style.display = "none";
                最高教程阶段 = 6;
                游戏状态 = "图鉴";
                显示通知(`已进入图鉴分区 ${分区索引 + 1}`, "信息");
            }
            function 打开图鉴分区选择() {
                游戏状态 = "图鉴选择"; // 设置为选择状态
                收集所有定义();
                // 确保主菜单隐藏
                主菜单容器.style.opacity = 0;
                主菜单容器.style.pointerEvents = "none";
                document.body.classList.remove("游戏进行中"); // 移除游戏进行中样式

                // 1. 计算分区信息
                const 物品总数 = 所有物品定义.length;
                const 怪物总数 = 所有怪物定义.length;
                const 总条目数 = 物品总数 + 怪物总数;
                const 房间尺寸 = 5; // 图鉴展示房间的大小
                const 间距 = -1; // 房间之间的间距
                // 计算每“层”理论上可以放多少房间 (考虑左右边距5格)
                const 可用宽度 = 地牢大小 - 10;
                const 每侧房间数 = Math.floor(可用宽度 / (房间尺寸 + 间距));
                const 每层条目数 = Math.max(1, 每侧房间数); // 每层放两侧，至少放1个
                const 总分区数 = Math.ceil(总条目数 / 每层条目数);

                // 2. 显示分区选择窗口
                const 遮罩 = document.getElementById("图鉴分区选择遮罩");
                const 窗口 = document.getElementById("图鉴分区选择窗口");
                const 列表容器 = document.getElementById("图鉴分区列表容器");
                const 关闭按钮 = document.getElementById("关闭图鉴选择按钮");

                列表容器.innerHTML = ""; // 清空旧内容

                if (总分区数 === 0) {
                    列表容器.innerHTML =
                        "<p style='text-align: center; color: #888;'>图鉴内容为空。</p>";
                } else {
                    for (let i = 0; i < 总分区数; i++) {
                        const 分区按钮 = document.createElement("button");
                        分区按钮.className = "菜单按钮"; // 复用菜单按钮样式
                        分区按钮.style.minWidth = "150px"; // 调整按钮宽度
                        分区按钮.textContent = `图鉴分区 ${i + 1}`;
                        分区按钮.onclick = () => {
                            关闭图鉴分区选择(); // 关闭选择窗口
                            初始化canvas();
                            初始化装备系统();
                            进入图鉴地牢(i, 每层条目数);
                        };
                        列表容器.appendChild(分区按钮);
                    }
                }

                // 关闭按钮事件
                关闭按钮.onclick = 关闭图鉴分区选择;

                遮罩.style.display = "block";
                // 添加打开动画
                窗口.style.opacity = 0;
                窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
                requestAnimationFrame(() => {
                    窗口.style.transition =
                        "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
                    窗口.style.opacity = 1;
                    窗口.style.transform = "translate(-50%, -50%) scale(1)";
                });
            }
            function 关闭图鉴分区选择() {
                const 遮罩 = document.getElementById("图鉴分区选择遮罩");
                const 窗口 = document.getElementById("图鉴分区选择窗口");
                if (!遮罩 || !窗口 || 遮罩.style.display === "none") return; // 防止重复关闭

                窗口.style.transition =
                    "opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
                窗口.style.opacity = 0;
                窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
                setTimeout(() => {
                    遮罩.style.display = "none";
                    // 如果是在选择状态下关闭且未进入图鉴，则返回主菜单
                    if (游戏状态 === "图鉴选择") {
                        显示主菜单();
                    }
                }, 300); // 等待动画完成
            }
            图鉴按钮.addEventListener("click", () => {
                打开图鉴分区选择();
            });

            //初始化canvas();
            //初始化装备系统();
            if (window.innerWidth < 769) {
                document.getElementById("小地图容器").classList.add("隐藏");
            }
            function 获取直线格子(x0, y0, x1, y1) {
                const 格子列表 = [];
                const ix0 = Math.floor(x0);
                const iy0 = Math.floor(y0);
                const ix1 = Math.floor(x1);
                const iy1 = Math.floor(y1);

                const dx = Math.abs(ix1 - ix0);
                const dy = -Math.abs(iy1 - iy0);
                let sx = ix0 < ix1 ? 1 : -1;
                let sy = iy0 < iy1 ? 1 : -1;
                let err = dx + dy;
                let e2;

                let 当前X = ix0;
                let 当前Y = iy0;

                while (true) {
                    格子列表.push({ x: 当前X, y: 当前Y });
                    if (当前X === ix1 && 当前Y === iy1) break;
                    e2 = 2 * err;
                    if (e2 >= dy) {
                        err += dy;
                        当前X += sx;
                    }
                    if (e2 <= dx) {
                        err += dx;
                        当前Y += sy;
                    }
                }
                return 格子列表;
            }
            function 放置怪物到房间(怪物实例, 目标房间) {
                if (!怪物实例 || !目标房间) {
                    console.error("放置怪物到房间：无效的怪物实例或目标房间。");
                    return false;
                }

                let 放置成功 = false;
                const 最大尝试次数 = 目标房间.w * 目标房间.h * 2; // 尝试次数上限，避免死循环

                for (let 尝试计数 = 0; 尝试计数 < 最大尝试次数; 尝试计数++) {
                    // 在房间内部随机选择一个坐标
                    const 随机X =
                        目标房间.x + Math.floor(Math.random() * 目标房间.w);
                    const 随机Y =
                        目标房间.y + Math.floor(Math.random() * 目标房间.h);

                    // 检查选定坐标是否有效且空闲 (不考虑玩家位置，因为这是后台放置)
                    if (位置是否可用(随机X, 随机Y, false)) {
                        // 调用现有的单元格放置函数
                        if (放置怪物到单元格(怪物实例, 随机X, 随机Y)) {
                            怪物实例.房间ID = 目标房间.id; // 确保房间ID正确设置
                            // console.log(`怪物 ${怪物实例.类型} 成功放置在房间 ${目标房间.id} 的 (${随机X}, ${随机Y})`);
                            放置成功 = true;
                            break; // 成功放置，跳出尝试循环
                        }
                    }
                }

                if (!放置成功) {
                    console.warn(
                        `在房间 ${目标房间.id} (${
                            目标房间.类型 || "未知类型"
                        }) 中多次尝试后未能放置怪物 ${
                            怪物实例.类型
                        }。房间可能已满或无合适位置。`
                    );
                }
                return 放置成功;
            }

            function 生成沉没的迷宫() {
                // =================================================
                // 1. 初始化与重置游戏状态
                // =================================================
                console.log("正在生成特殊关卡：沉没的迷宫...");
                地牢 = Array(地牢大小)
                    .fill()
                    .map((_, y) =>
                        Array(地牢大小)
                            .fill()
                            .map((_, x) => new 单元格(x, y))
                    );
                房间列表 = [];
                上锁房间列表 = [];
                所有怪物 = [];
                怪物状态表 = new WeakMap();
                门实例列表 = new Map();
                房间地图 = Array(地牢大小)
                    .fill()
                    .map(() => Array(地牢大小).fill(-1));
                已访问房间 = new Set();
                所有计时器 = [];
                当前天气效果 = [];

                // =================================================
                // 2. 定义迷宫的房间布局
                // =================================================
                const 房间布局 = [
                    // --- 中央区域 ---
                    {
                        名称: "中央大厅",
                        id: 0,
                        x: 45,
                        y: 45,
                        w: 11,
                        h: 11,
                        门: [],
                    },
                    {
                        名称: "北翼大门",
                        id: 1,
                        x: 48,
                        y: 38,
                        w: 5,
                        h: 5,
                        门: [],
                    },
                    {
                        名称: "东翼大门",
                        id: 2,
                        x: 58,
                        y: 48,
                        w: 5,
                        h: 5,
                        门: [],
                    },
                    {
                        名称: "南翼大门",
                        id: 3,
                        x: 48,
                        y: 58,
                        w: 5,
                        h: 5,
                        门: [],
                    },
                    {
                        名称: "西翼大门",
                        id: 4,
                        x: 38,
                        y: 48,
                        w: 5,
                        h: 5,
                        门: [],
                    },

                    // --- 北翼：冰霜主题 ---
                    {
                        名称: "北翼_冰霜回廊",
                        id: 5,
                        x: 46,
                        y: 28,
                        w: 9,
                        h: 7,
                        门: [],
                    },
                    {
                        名称: "北翼_冰封大殿",
                        id: 6,
                        x: 47,
                        y: 15,
                        w: 7,
                        h: 9,
                        门: [],
                    },
                    {
                        名称: "北翼_守卫室",
                        id: 7,
                        x: 40,
                        y: 16,
                        w: 5,
                        h: 5,
                        门: [],
                    },
                    {
                        名称: "北翼_宝库",
                        id: 8,
                        x: 56,
                        y: 16,
                        w: 5,
                        h: 5,
                        门: [],
                    },

                    // --- 东翼：火焰与爆炸主题 ---
                    {
                        名称: "东翼_灼热通道",
                        id: 9,
                        x: 66,
                        y: 47,
                        w: 9,
                        h: 7,
                        门: [],
                    },
                    {
                        名称: "东翼_爆裂熔炉",
                        id: 10,
                        x: 79,
                        y: 46,
                        w: 9,
                        h: 9,
                        门: [],
                    },
                    {
                        名称: "东翼_守卫室",
                        id: 11,
                        x: 80,
                        y: 39,
                        w: 5,
                        h: 5,
                        门: [],
                    },
                    {
                        名称: "东翼_宝库",
                        id: 12,
                        x: 80,
                        y: 57,
                        w: 5,
                        h: 5,
                        门: [],
                    },

                    // --- 南翼：剧毒与自然主题 ---
                    {
                        名称: "南翼_藤蔓走廊",
                        id: 13,
                        x: 46,
                        y: 66,
                        w: 9,
                        h: 7,
                        门: [],
                    },
                    {
                        名称: "南翼_毒沼之心",
                        id: 14,
                        x: 47,
                        y: 77,
                        w: 7,
                        h: 9,
                        门: [],
                    },
                    {
                        名称: "南翼_守卫室",
                        id: 15,
                        x: 56,
                        y: 78,
                        w: 5,
                        h: 5,
                        门: [],
                    },
                    {
                        名称: "南翼_宝库",
                        id: 16,
                        x: 40,
                        y: 78,
                        w: 5,
                        h: 5,
                        门: [],
                    },

                    // --- 西翼：诡诈与敏捷主题 ---
                    {
                        名称: "西翼_幻影之道",
                        id: 17,
                        x: 26,
                        y: 47,
                        w: 9,
                        h: 7,
                        门: [],
                    },
                    {
                        名称: "西翼_诡诈大厅",
                        id: 18,
                        x: 13,
                        y: 46,
                        w: 9,
                        h: 9,
                        门: [],
                    },
                    {
                        名称: "西翼_守卫室",
                        id: 19,
                        x: 14,
                        y: 57,
                        w: 5,
                        h: 5,
                        门: [],
                    },
                    {
                        名称: "西翼_宝库",
                        id: 20,
                        x: 14,
                        y: 39,
                        w: 5,
                        h: 5,
                        门: [],
                    },

                    // --- 最终区域 ---
                    {
                        名称: "四色祭坛",
                        id: 21,
                        x: 25,
                        y: 25,
                        w: 9,
                        h: 9,
                        门: [],
                    },
                    {
                        名称: "最终秘室",
                        id: 22,
                        x: 26,
                        y: 13,
                        w: 7,
                        h: 7,
                        门: [],
                    },
                ];

                const 获取房间 = (名称) =>
                    房间列表.find((r) => r.名称 === 名称);

                房间列表 = 房间布局;
                房间列表.forEach((房间配置) => {
                    放置房间(房间配置);
                });

                // =================================================
                // 3. 连接房间，构建迷宫路径
                // =================================================
                let 已连接房间对 = new Set();
                const 连接并生成走廊 = (房间A, 房间B) => {
                    const 房间对ID = [房间A.id, 房间B.id].sort().join("-");
                    if (已连接房间对.has(房间对ID)) return;
                    const 路径 = 连接房间(房间A, 房间B);
                    if (路径) {
                        生成走廊(路径);
                        已连接房间对.add(房间对ID);
                    } else {
                        console.warn(
                            `无法连接房间 '${房间A.名称}' 和 '${房间B.名称}'`
                        );
                    }
                };

                // --- 主干道连接 ---
                连接并生成走廊(获取房间("中央大厅"), 获取房间("北翼大门"));
                连接并生成走廊(获取房间("中央大厅"), 获取房间("东翼大门"));
                连接并生成走廊(获取房间("中央大厅"), 获取房间("南翼大门"));
                连接并生成走廊(获取房间("中央大厅"), 获取房间("西翼大门"));

                // --- 各翼内部连接 ---
                连接并生成走廊(获取房间("北翼大门"), 获取房间("北翼_冰霜回廊"));
                连接并生成走廊(
                    获取房间("北翼_冰霜回廊"),
                    获取房间("北翼_冰封大殿")
                );
                连接并生成走廊(
                    获取房间("北翼_冰封大殿"),
                    获取房间("北翼_守卫室")
                );
                连接并生成走廊(
                    获取房间("北翼_冰封大殿"),
                    获取房间("北翼_宝库")
                );

                连接并生成走廊(获取房间("东翼大门"), 获取房间("东翼_灼热通道"));
                连接并生成走廊(
                    获取房间("东翼_灼热通道"),
                    获取房间("东翼_爆裂熔炉")
                );
                连接并生成走廊(
                    获取房间("东翼_爆裂熔炉"),
                    获取房间("东翼_守卫室")
                );
                连接并生成走廊(
                    获取房间("东翼_爆裂熔炉"),
                    获取房间("东翼_宝库")
                );

                连接并生成走廊(获取房间("南翼大门"), 获取房间("南翼_藤蔓走廊"));
                连接并生成走廊(
                    获取房间("南翼_藤蔓走廊"),
                    获取房间("南翼_毒沼之心")
                );
                连接并生成走廊(
                    获取房间("南翼_毒沼之心"),
                    获取房间("南翼_守卫室")
                );
                连接并生成走廊(
                    获取房间("南翼_毒沼之心"),
                    获取房间("南翼_宝库")
                );

                连接并生成走廊(获取房间("西翼大门"), 获取房间("西翼_幻影之道"));
                连接并生成走廊(
                    获取房间("西翼_幻影之道"),
                    获取房间("西翼_诡诈大厅")
                );
                连接并生成走廊(
                    获取房间("西翼_诡诈大厅"),
                    获取房间("西翼_守卫室")
                );
                连接并生成走廊(
                    获取房间("西翼_诡诈大厅"),
                    获取房间("西翼_宝库")
                );

                // --- 最终区域连接 ---
                连接并生成走廊(获取房间("四色祭坛"), 获取房间("最终秘室"));

                // --- 增加迷宫复杂度的额外连接 ---
                连接并生成走廊(获取房间("北翼_守卫室"), 获取房间("四色祭坛"));
                连接并生成走廊(获取房间("西翼_宝库"), 获取房间("四色祭坛"));
                连接并生成走廊(
                    获取房间("东翼_灼热通道"),
                    获取房间("北翼_冰霜回廊")
                );
                连接并生成走廊(
                    获取房间("南翼_藤蔓走廊"),
                    获取房间("西翼_幻影之道")
                );

                // =================================================
                // 4. 设置门锁与钥匙 (已重构)
                // =================================================
                const 锁定房间门 = (房间名称, 颜色索引) => {
                    const 房间 = 获取房间(房间名称);
                    if (!房间) return;
                    上锁房间列表.push({ ...房间, 颜色索引 });
                    房间.门.forEach((门坐标) => {
                        const 门单元格 = 地牢[门坐标.y]?.[门坐标.x];
                        if (门单元格 && 门单元格.背景类型 === 单元格类型.门) {
                            门单元格.背景类型 = 单元格类型.上锁的门;
                            门单元格.钥匙ID = 房间.id;
                            门单元格.颜色索引 = 颜色索引;
                            const 门实例 = 门实例列表.get(门单元格.标识);
                            if (门实例) {
                                门实例.类型 = "上锁的门";
                                门实例.是否上锁 = true;
                            }
                        }
                    });
                };

                // --- 锁定除北翼外的所有区域 ---
                锁定房间门("东翼大门", 1); // 蓝色
                锁定房间门("南翼大门", 2); // 黄色
                锁定房间门("西翼大门", 3); // 品红色
                锁定房间门("最终秘室", 4); // 红色
                // 注意：北翼大门现在是默认开启的，不调用锁定函数

                // --- 放置钥匙，形成线性流程 ---
                // 东翼钥匙（蓝色）放在北翼宝库
                放置物品到房间(
                    new 钥匙({
                        对应门ID: 获取房间("东翼大门").id,
                        颜色索引: 1,
                        地牢层数: 当前层数,
                    }),
                    获取房间("北翼_宝库")
                );
                // 南翼钥匙（黄色）放在东翼宝库
                放置物品到房间(
                    new 钥匙({
                        对应门ID: 获取房间("南翼大门").id,
                        颜色索引: 2,
                        地牢层数: 当前层数,
                    }),
                    获取房间("东翼_宝库")
                );
                // 西翼钥匙（品红色）放在南翼宝库
                放置物品到房间(
                    new 钥匙({
                        对应门ID: 获取房间("西翼大门").id,
                        颜色索引: 3,
                        地牢层数: 当前层数,
                    }),
                    获取房间("南翼_宝库")
                );
                // 最终秘室钥匙（红色）放在西翼宝库
                放置物品到房间(
                    new 钥匙({
                        对应门ID: 获取房间("最终秘室").id,
                        颜色索引: 4,
                        地牢层数: 当前层数,
                    }),
                    获取房间("西翼_宝库")
                );

                // =================================================
                // 5. 填充内容：怪物、物品和特殊NPC
                // =================================================
                // --- 中央大厅 ---
                放置物品到房间(new 探险家({}), 获取房间("中央大厅"));
                放置物品到房间(new 物品祭坛({}), 获取房间("中央大厅"));

                // --- 北翼 (冰霜) ---
                放置怪物到房间(
                    new 冰冻怪物({ 强化: true }),
                    获取房间("北翼_冰封大殿")
                );
                放置怪物到房间(new 盔甲怪物({}), 获取房间("北翼_冰封大殿"));
                放置怪物到房间(
                    new 盔甲怪物({ 强化: true }),
                    获取房间("北翼_守卫室")
                );
                放置物品到房间(
                    new 冰霜法杖({ 强化: true }),
                    获取房间("北翼_宝库")
                );
                放置怪物到房间(new 冰冻怪物({}), 获取房间("北翼_宝库")); // 宝库增加怪物

                // --- 东翼 (火焰) ---
                放置怪物到房间(
                    new 炸弹怪物({ 强化: true }),
                    获取房间("东翼_爆裂熔炉")
                );
                放置物品到房间(
                    new 喷火枪({ 强化: true }),
                    获取房间("东翼_爆裂熔炉")
                );
                放置怪物到房间(
                    new 盔甲怪物({ 强化: true }),
                    获取房间("东翼_守卫室")
                );
                放置物品到房间(
                    new 炸弹({ 数量: 5, 强化: true }),
                    获取房间("东翼_宝库")
                );
                放置怪物到房间(new 炸弹怪物({}), 获取房间("东翼_宝库")); // 宝库增加怪物

                // --- 南翼 (剧毒) ---
                放置怪物到房间(
                    new 仙人掌怪物({ 强化: true }),
                    获取房间("南翼_毒沼之心")
                );
                放置怪物到房间(new 腐蚀怪物({}), 获取房间("南翼_毒沼之心"));
                放置怪物到房间(
                    new 盔甲怪物({ 强化: true }),
                    获取房间("南翼_守卫室")
                );
                放置物品到房间(
                    new 剧毒匕首({ 强化: true }),
                    获取房间("南翼_宝库")
                );
                放置怪物到房间(new 腐蚀怪物({}), 获取房间("南翼_宝库")); // 宝库增加怪物

                // --- 西翼 (诡诈) ---
                放置怪物到房间(
                    new 瞬移怪物({ 强化: true }),
                    获取房间("西翼_诡诈大厅")
                );
                放置怪物到房间(new 敏捷怪物({}), 获取房间("西翼_诡诈大厅"));
                放置怪物到房间(
                    new 盔甲怪物({ 强化: true }),
                    获取房间("西翼_守卫室")
                );
                放置物品到房间(
                    new 隐身药水({ 数量: 2 }),
                    获取房间("西翼_宝库")
                );
                放置怪物到房间(new 伪装怪物({}), 获取房间("西翼_宝库")); // 宝库增加怪物

                // --- 最终区域 ---
                放置物品到单元格(
                    new 物品({ 名称: "绿色锁孔", 图标: "🟢", 能否拾起: false }),
                    27,
                    27
                );
                放置物品到单元格(
                    new 物品({ 名称: "蓝色锁孔", 图标: "🔵", 能否拾起: false }),
                    31,
                    27
                );
                放置物品到单元格(
                    new 物品({ 名称: "黄色锁孔", 图标: "🟡", 能否拾起: false }),
                    27,
                    31
                );
                放置物品到单元格(
                    new 物品({ 名称: "品红锁孔", 图标: "🟣", 能否拾起: false }),
                    31,
                    31
                );

                放置怪物到房间(
                    new 大魔法师({ 强化: true }),
                    获取房间("最终秘室")
                );
                放置物品到房间(
                    new 真言卷轴({ 强化: true, 已解锁: true }),
                    获取房间("最终秘室")
                );

                // =================================================
                // 6. 最终设置
                // =================================================
                生成墙壁();
                房间列表.forEach((房间) => 更新房间墙壁(房间));

                const 起始房间 = 获取房间("中央大厅");
                玩家初始位置.x = 起始房间.x + Math.floor(起始房间.w / 2);
                玩家初始位置.y = 起始房间.y + Math.floor(起始房间.h / 2);
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;
                已访问房间.add(起始房间.id);

                放置楼梯(
                    获取房间("最终秘室"),
                    楼梯图标.下楼,
                    单元格类型.楼梯下楼
                );

                更新视口();
                更新界面状态();
                绘制();

                console.log("“沉没的迷宫”已生成完毕。祝你好运，探险家！");
            }

            function 生成迷宫怪物(数量) {
                const 迷宫尺寸 = 85;
                const 偏移X = Math.floor((地牢大小 - 迷宫尺寸) / 2);
                const 偏移Y = Math.floor((地牢大小 - 迷宫尺寸) / 2);
                const 怪物候选池 = 怪物池["普通房间"].filter(
                    (m) =>
                        m.最小层 <= 5 &&
                        m.类.name !== "米诺陶" &&
                        m.类.name !== "大魔法师"
                );

                if (怪物候选池.length === 0) return;

                for (let i = 0; i < 数量; i++) {
                    let 放置成功 = false;
                    for (let 尝试 = 0; 尝试 < 50; 尝试++) {
                        const x = 偏移X + Math.floor(Math.random() * 迷宫尺寸);
                        const y = 偏移Y + Math.floor(Math.random() * 迷宫尺寸);

                        if (
                            地牢[y]?.[x]?.背景类型 === 单元格类型.走廊 &&
                            !地牢[y][x].关联物品 &&
                            !地牢[y][x].关联怪物
                        ) {
                            const 距离玩家 =
                                Math.abs(x - 玩家.x) + Math.abs(y - 玩家.y);
                            if (距离玩家 > 15) {
                                const 怪物配置 =
                                    怪物候选池[
                                        Math.floor(
                                            Math.random() * 怪物候选池.length
                                        )
                                    ];
                                const 新怪物 = new 怪物配置.类({
                                    强化: Math.random() < 0.3,
                                });
                                if (放置怪物到单元格(新怪物, x, y)) {
                                    新怪物.状态 = 怪物状态.活跃;
                                    新怪物.绘制血条();
                                    放置成功 = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            function 生成迷宫关卡() {
                当前层数 = 5;
                地牢 = Array(地牢大小)
                    .fill()
                    .map((_, y) =>
                        Array(地牢大小)
                            .fill()
                            .map((_, x) => new 单元格(x, y))
                    );
                房间列表 = [];
                上锁房间列表 = [];
                所有怪物 = [];
                怪物状态表 = new WeakMap();
                门实例列表 = new Map();
                房间地图 = Array(地牢大小)
                    .fill()
                    .map(() => Array(地牢大小).fill(-1));
                已访问房间 = new Set();
                所有计时器 = [];
                当前天气效果 = [];

                const 迷宫网格尺寸 = 43;
                const 通道宽度 = 2;
                const 迷宫尺寸 = 迷宫网格尺寸 * 通道宽度;
                const 迷宫X偏移 = Math.floor((地牢大小 - 迷宫尺寸) / 2);
                const 迷宫Y偏移 = Math.floor((地牢大小 - 迷宫尺寸) / 2);

                let 迷宫网格 = Array(迷宫网格尺寸)
                    .fill(1)
                    .map(() => Array(迷宫网格尺寸).fill(1));
                let 堆栈 = [];
                let 起始格子X = 1,
                    起始格子Y = 1;
                迷宫网格[起始格子Y][起始格子X] = 0;
                堆栈.push({ x: 起始格子X, y: 起始格子Y });

                while (堆栈.length > 0) {
                    let 当前节点 = 堆栈.pop();
                    let 邻居列表 = [];
                    const 方向数组 = [
                        [0, 2],
                        [0, -2],
                        [2, 0],
                        [-2, 0],
                    ];
                    方向数组.sort(() => Math.random() - 0.5);

                    for (const [方向X, 方向Y] of 方向数组) {
                        const 新格子X = 当前节点.x + 方向X;
                        const 新格子Y = 当前节点.y + 方向Y;
                        if (
                            新格子X > 0 &&
                            新格子X < 迷宫网格尺寸 - 1 &&
                            新格子Y > 0 &&
                            新格子Y < 迷宫网格尺寸 - 1 &&
                            迷宫网格[新格子Y][新格子X] === 1
                        ) {
                            邻居列表.push({
                                x: 新格子X,
                                y: 新格子Y,
                                墙壁X: 当前节点.x + 方向X / 2,
                                墙壁Y: 当前节点.y + 方向Y / 2,
                            });
                        }
                    }

                    if (邻居列表.length > 0) {
                        堆栈.push(当前节点);
                        let 选定邻居 = 邻居列表[0];
                        迷宫网格[选定邻居.墙壁Y][选定邻居.墙壁X] = 0;
                        迷宫网格[选定邻居.y][选定邻居.x] = 0;
                        堆栈.push({ x: 选定邻居.x, y: 选定邻居.y });
                    }
                }

                for (let 格子Y = 0; 格子Y < 迷宫网格尺寸; 格子Y++) {
                    for (let 格子X = 0; 格子X < 迷宫网格尺寸; 格子X++) {
                        if (迷宫网格[格子Y][格子X] === 0) {
                            for (let 偏移Y = 0; 偏移Y < 通道宽度; 偏移Y++) {
                                for (let 偏移X = 0; 偏移X < 通道宽度; 偏移X++) {
                                    const 最终X =
                                        格子X * 通道宽度 + 偏移X + 迷宫X偏移;
                                    const 最终Y =
                                        格子Y * 通道宽度 + 偏移Y + 迷宫Y偏移;
                                    if (地牢[最终Y]?.[最终X]) {
                                        地牢[最终Y][最终X].背景类型 =
                                            单元格类型.走廊;
                                    }
                                }
                            }
                        }
                    }
                }
                生成墙壁();

                玩家初始位置.x = 起始格子X * 通道宽度 + 迷宫X偏移;
                玩家初始位置.y = 起始格子Y * 通道宽度 + 迷宫Y偏移;
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;
                已访问房间.add(-1);
                放置楼梯(
                    { x: 玩家初始位置.x, y: 玩家初始位置.y, w: 2, h: 2 },
                    楼梯图标.上楼,
                    单元格类型.楼梯上楼
                );
                let 首领X, 首领Y;
                let 首领已放置 = false;
                for (
                    let 尝试次数 = 0;
                    尝试次数 < 100 && !首领已放置;
                    尝试次数++
                ) {
                    let 格子X =
                        迷宫网格尺寸 - Math.floor(Math.random() * 5) - 2;
                    let 格子Y =
                        迷宫网格尺寸 - Math.floor(Math.random() * 5) - 2;
                    if (
                        格子X > 0 &&
                        格子Y > 0 &&
                        迷宫网格[格子Y][格子X] === 0
                    ) {
                        首领X = 格子X * 通道宽度 + 迷宫X偏移;
                        首领Y = 格子Y * 通道宽度 + 迷宫Y偏移;
                        if (
                            Math.abs(首领X - 玩家初始位置.x) +
                                Math.abs(首领Y - 玩家初始位置.y) >
                            50
                        ) {
                            首领已放置 = true;
                        }
                    }
                }
                if (!首领已放置) {
                    首领X = (迷宫网格尺寸 - 2) * 通道宽度 + 迷宫X偏移;
                    首领Y = (迷宫网格尺寸 - 2) * 通道宽度 + 迷宫Y偏移;
                }

                const 首领 = new 米诺陶({ 强化: true });
                放置怪物到单元格(首领, 首领X, 首领Y);
                首领.状态 = 怪物状态.活跃;

                const 物品数量 = 5 + Math.floor(Math.random() * 5);
                const 可用物品池 = Object.values(物品池)
                    .flat()
                    .filter(
                        (i) =>
                            i.最小层 <= 5 &&
                            i.类.name !== "米诺陶" &&
                            i.类.name !== "大魔法师"
                    );

                for (let i = 0; i < 物品数量; i++) {
                    let 物品X, 物品Y;
                    for (let 尝试次数 = 0; 尝试次数 < 50; 尝试次数++) {
                        const 格子X =
                            Math.floor(Math.random() * (迷宫网格尺寸 - 2)) + 1;
                        const 格子Y =
                            Math.floor(Math.random() * (迷宫网格尺寸 - 2)) + 1;
                        if (迷宫网格[格子Y][格子X] === 0) {
                            物品X = 格子X * 通道宽度 + 迷宫X偏移;
                            物品Y = 格子Y * 通道宽度 + 迷宫Y偏移;
                            if (位置是否可用(物品X, 物品Y, false)) {
                                const 物品配置 =
                                    可用物品池[
                                        Math.floor(
                                            Math.random() * 可用物品池.length
                                        )
                                    ];
                                if (物品配置.类.name !== "治疗药水") {
                                    放置物品到单元格(
                                        new 物品配置.类({
                                            强化: Math.random() < 0.2,
                                        }),
                                        物品X,
                                        物品Y
                                    );
                                    break;
                                }
                            }
                        }
                    }
                }

                const 药水数量 = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < 药水数量; i++) {
                    let 药水X, 药水Y;
                    for (let 尝试次数 = 0; 尝试次数 < 50; 尝试次数++) {
                        const 格子X =
                            Math.floor(Math.random() * (迷宫网格尺寸 - 2)) + 1;
                        const 格子Y =
                            Math.floor(Math.random() * (迷宫网格尺寸 - 2)) + 1;
                        if (迷宫网格[格子Y][格子X] === 0) {
                            药水X = 格子X * 通道宽度 + 迷宫X偏移;
                            药水Y = 格子Y * 通道宽度 + 迷宫Y偏移;
                            if (位置是否可用(药水X, 药水Y, false)) {
                                放置物品到单元格(
                                    new 治疗药水({ 强化: true }),
                                    药水X,
                                    药水Y
                                );
                                break;
                            }
                        }
                    }
                }

                生成迷宫怪物(15);

                更新视口();
                更新界面状态();
                绘制();
            }
            function 生成迷宫出口(x, y) {
                const 楼梯 = {
                    类型: "楼梯",
                    图标: 楼梯图标.下楼,
                    显示图标: 楼梯图标.下楼,
                    颜色索引: 颜色表.length,
                    使用: () => {
                        切换楼层(当前层数 + 1, false, null, true);
                    },
                    唯一标识: Symbol(`楼梯_下楼`),
                    获取名称: () => "下楼楼梯",
                    自定义数据: new Map(),
                    品质: 1,
                    能否拾起: false,
                    是否正常物品: false,
                    是否隐藏: false,
                    是否为隐藏物品: false,
                    效果描述: null,
                    已装备: false,
                    装备槽位: null,
                    堆叠数量: 1,
                    最大堆叠数量: 1,
                    颜色表: 颜色表,
                };

                if (位置是否可用(x, y, false)) {
                    放置物品到单元格(楼梯, x, y, 单元格类型.楼梯下楼);
                } else {
                    const 附近位置 = [
                        [0, 0],
                        [0, 1],
                        [0, -1],
                        [1, 0],
                        [-1, 0],
                    ];
                    for (const [dx, dy] of 附近位置) {
                        if (位置是否可用(x + dx, y + dy, false)) {
                            放置物品到单元格(
                                楼梯,
                                x + dx,
                                y + dy,
                                单元格类型.楼梯下楼
                            );
                            return;
                        }
                    }
                }
            }
            function 检查房间连通性(房间) {
                const 墙壁类型 = 单元格类型.墙壁;
                const 地板类型 = 单元格类型.房间;

                const 地板格子 = [];
                for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                    for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                        if (地牢[y]?.[x]?.背景类型 === 地板类型) {
                            地板格子.push({ x, y });
                        }
                    }
                }

                if (地板格子.length === 0) return true;

                const 起始点 = 地板格子[0];
                const 队列 = [起始点];
                const 已访问 = new Set([`${起始点.x},${起始点.y}`]);
                let 可达计数 = 0;

                while (队列.length > 0) {
                    const 当前 = 队列.shift();
                    可达计数++;

                    const 方向 = [
                        [0, 1],
                        [0, -1],
                        [1, 0],
                        [-1, 0],
                    ];
                    for (const [dx, dy] of 方向) {
                        const 邻居X = 当前.x + dx;
                        const 邻居Y = 当前.y + dy;
                        const 邻居键 = `${邻居X},${邻居Y}`;

                        if (
                            邻居X >= 房间.x &&
                            邻居X < 房间.x + 房间.w &&
                            邻居Y >= 房间.y &&
                            邻居Y < 房间.y + 房间.h &&
                            地牢[邻居Y]?.[邻居X]?.背景类型 === 地板类型 &&
                            !已访问.has(邻居键)
                        ) {
                            已访问.add(邻居键);
                            队列.push({ x: 邻居X, y: 邻居Y });
                        }
                    }
                }

                return 可达计数 === 地板格子.length;
            }

            function 生成符文圈群组(房间, 数量 = 1) {
                for (let i = 0; i < 数量; i++) {
                    const 尺寸 = 2 + Math.floor(Math.random() * 2);
                    const 效果列表 = ["狂暴", "神龟", "缓慢", "中毒"];
                    // 为整个群组确定一个初始效果和周期
                    const 初始效果类型 =
                        效果列表[Math.floor(Math.random() * 效果列表.length)];
                    const 初始剩余周期 = Math.floor(Math.random() * 10);

                    let 放置成功 = false;
                    for (let 尝试 = 0; 尝试 < 20; 尝试++) {
                        const 起始X =
                            房间.x +
                            Math.floor(Math.random() * (房间.w - 尺寸));
                        const 起始Y =
                            房间.y +
                            Math.floor(Math.random() * (房间.h - 尺寸));

                        let 可以放置 = true;
                        for (let y = 起始Y; y < 起始Y + 尺寸; y++) {
                            for (let x = 起始X; x < 起始X + 尺寸; x++) {
                                if (!位置是否可用(x, y, false)) {
                                    可以放置 = false;
                                    break;
                                }
                            }
                            if (!可以放置) break;
                        }

                        if (可以放置) {
                            for (let y = 起始Y; y < 起始Y + 尺寸; y++) {
                                for (let x = 起始X; x < 起始X + 尺寸; x++) {
                                    // 使用相同的初始效果和周期来创建符文圈
                                    放置物品到单元格(
                                        new 符文圈({
                                            效果类型: 初始效果类型,
                                            周期: 10,
                                            剩余周期: 初始剩余周期,
                                        }),
                                        x,
                                        y
                                    );
                                }
                            }
                            放置成功 = true;
                            break;
                        }
                    }
                }
            }

            function 生成法师图书馆() {
                当前层数 = 8;

                地牢 = Array(地牢大小)
                    .fill()
                    .map((_, y) =>
                        Array(地牢大小)
                            .fill()
                            .map((_, x) => new 单元格(x, y))
                    );
                房间列表 = [];
                上锁房间列表 = [];
                所有怪物 = [];
                怪物状态表 = new WeakMap();
                门实例列表 = new Map();
                房间地图 = Array(地牢大小)
                    .fill()
                    .map(() => Array(地牢大小).fill(-1));
                已访问房间 = new Set();
                所有计时器 = [];
                当前天气效果 = [];

                const 房间布局 = [
                    {
                        名称: "中央大厅",
                        id: 0,
                        x: 45,
                        y: 45,
                        w: 11,
                        h: 11,
                        门: [],
                    },
                    {
                        名称: "火焰之径",
                        id: 1,
                        x: 58,
                        y: 48,
                        w: 20,
                        h: 5,
                        门: [],
                    },
                    {
                        名称: "火焰宝库",
                        id: 2,
                        x: 80,
                        y: 48,
                        w: 7,
                        h: 7,
                        门: [],
                    },
                    {
                        名称: "冰霜书库",
                        id: 3,
                        x: 47,
                        y: 15,
                        w: 7,
                        h: 25,
                        门: [],
                    },
                    {
                        名称: "冰霜宝库",
                        id: 4,
                        x: 48,
                        y: 5,
                        w: 7,
                        h: 7,
                        门: [],
                    },
                    {
                        名称: "奥术回廊",
                        id: 5,
                        x: 22,
                        y: 48,
                        w: 21,
                        h: 5,
                        门: [],
                    },
                    {
                        名称: "奥术宝库",
                        id: 6,
                        x: 13,
                        y: 48,
                        w: 7,
                        h: 7,
                        门: [],
                    },
                    {
                        名称: "剧毒档案室",
                        id: 7,
                        x: 48,
                        y: 58,
                        w: 5,
                        h: 11,
                        门: [],
                    },
                    {
                        名称: "剧毒宝库",
                        id: 8,
                        x: 48,
                        y: 71,
                        w: 7,
                        h: 7,
                        门: [],
                    },
                    {
                        名称: "最终秘室",
                        id: 9,
                        x: 60,
                        y: 10,
                        w: 15,
                        h: 15,
                        门: [],
                    },
                ];
                房间列表 = 房间布局;
                房间列表.forEach((房间配置) => 放置房间(房间配置));

                const 获取房间 = (名称) =>
                    房间列表.find((r) => r.名称 === 名称);
                let 已连接房间对 = new Set();
                const 连接并生成走廊 = (房A, 房B) => {
                    const 房间A = 获取房间(房A);
                    const 房间B = 获取房间(房B);
                    if (!房间A || !房间B) return;
                    const 房间对ID = [房间A.id, 房间B.id].sort().join("-");
                    if (已连接房间对.has(房间对ID)) return;
                    const 路径 = 连接房间(房间A, 房间B);
                    if (路径) {
                        生成走廊(路径);
                        已连接房间对.add(房间对ID);
                    }
                };

                连接并生成走廊("中央大厅", "火焰之径");
                连接并生成走廊("火焰之径", "火焰宝库");
                连接并生成走廊("中央大厅", "冰霜书库");
                连接并生成走廊("冰霜书库", "冰霜宝库");
                连接并生成走廊("中央大厅", "奥术回廊");
                连接并生成走廊("奥术回廊", "奥术宝库");
                连接并生成走廊("中央大厅", "剧毒档案室");
                连接并生成走廊("剧毒档案室", "剧毒宝库");
                放置楼梯(
                    获取房间("中央大厅"),
                    楼梯图标.上楼,
                    单元格类型.楼梯上楼
                );

                for (let i = 0; i < 3; i++)
                    放置物品到房间(new 书架({}), 获取房间("中央大厅"));
                for (let i = 0; i < 3; i++)
                    放置怪物到房间(
                        new 伪装怪物({ 伪装成: "书架" }),
                        获取房间("中央大厅")
                    );
                for (let i = 0; i < 4; i++)
                    放置物品到房间(new 神秘商人({}), 获取房间("中央大厅"));

                const 火焰房间 = 获取房间("火焰之径");
                for (let i = 0; i < 15; i++)
                    放置物品到房间(new 火焰物品({ 倒计时: 99999 }), 火焰房间);
                for (let i = 0; i < 3; i++)
                    放置怪物到房间(new 炸弹怪物({ 强化: true }), 火焰房间);
                放置物品到房间(
                    new 魔法水晶({
                        水晶ID: "火焰",
                        颜色索引: 4,
                        管辖房间: ["火焰之径", "火焰宝库"],
                    }),
                    获取房间("火焰宝库")
                );

                const 冰霜房间 = 获取房间("冰霜书库");
                let 冰霜连通 = false;
                let 冰霜尝试 = 0;
                do {
                    for (let y = 冰霜房间.y; y < 冰霜房间.y + 冰霜房间.h; y++) {
                        for (
                            let x = 冰霜房间.x;
                            x < 冰霜房间.x + 冰霜房间.w;
                            x++
                        ) {
                            地牢[y][x].背景类型 = 单元格类型.房间;
                        }
                    }
                    for (let y = 冰霜房间.y; y < 冰霜房间.y + 冰霜房间.h; y++) {
                        for (
                            let x = 冰霜房间.x;
                            x < 冰霜房间.x + 冰霜房间.w;
                            x++
                        ) {
                            if (Math.random() < 0.3)
                                地牢[y][x].背景类型 = 单元格类型.墙壁;
                        }
                    }
                    冰霜连通 = 检查房间连通性(冰霜房间);
                    冰霜尝试++;
                } while (!冰霜连通 && 冰霜尝试 < 1000);

                for (let i = 0; i < 4; i++)
                    放置怪物到房间(new 冰冻怪物({ 强化: true }), 冰霜房间);
                for (let i = 0; i < 3; i++)
                    放置怪物到房间(new 盗贼怪物({ 强化: true }), 冰霜房间);
                放置物品到房间(
                    new 魔法水晶({
                        水晶ID: "冰霜",
                        颜色索引: 1,
                        管辖房间: ["冰霜书库", "冰霜宝库"],
                    }),
                    获取房间("冰霜宝库")
                );

                const 奥术房间 = 获取房间("奥术回廊");
                放置怪物到房间(new 瞬移怪物({ 强化: true }), 奥术房间);
                for (let i = 0; i < 3; i++)
                    放置怪物到房间(new 召唤师怪物({ 强化: true }), 奥术房间);
                放置物品到房间(
                    new 魔法水晶({
                        水晶ID: "奥术",
                        颜色索引: 3,
                        管辖房间: ["奥术回廊", "奥术宝库"],
                    }),
                    获取房间("奥术宝库")
                );

                const 剧毒房间 = 获取房间("剧毒档案室");
                for (let i = 0; i < 8; i++)
                    放置物品到房间(new 毒液物品({ 倒计时: 99999 }), 剧毒房间);
                for (let i = 0; i < 5; i++)
                    放置怪物到房间(new 腐蚀怪物({ 强化: true }), 剧毒房间);
                放置怪物到房间(new 剧毒云雾怪物({ 强化: true }), 剧毒房间);
                放置物品到房间(
                    new 魔法水晶({
                        水晶ID: "剧毒",
                        颜色索引: 0,
                        管辖房间: ["剧毒档案室", "剧毒宝库"],
                    }),
                    获取房间("剧毒宝库")
                );

                const 最终房间 = 获取房间("最终秘室");
                let boss房连通 = false;
                let boss房尝试 = 0;
                do {
                    for (let y = 最终房间.y; y < 最终房间.y + 最终房间.h; y++) {
                        for (
                            let x = 最终房间.x;
                            x < 最终房间.x + 最终房间.w;
                            x++
                        ) {
                            地牢[y][x].背景类型 = 单元格类型.房间;
                        }
                    }
                    const 墙体数量 = 4 + Math.round(Math.random() * 4);
                    for (let i = 0; i < 墙体数量; i++) {
                        const isHorizontal = Math.random() < 0.5;
                        const 墙体长度 =
                            2 + Math.floor(Math.random() * (最终房间.w - 3));
                        if (isHorizontal) {
                            const y =
                                最终房间.y +
                                Math.floor(Math.random() * 最终房间.h);
                            const xStart =
                                最终房间.x +
                                Math.floor(
                                    Math.random() * (最终房间.w - 墙体长度)
                                );
                            for (let x = xStart; x < xStart + 墙体长度; x++) {
                                if (地牢[y]?.[x])
                                    地牢[y][x].背景类型 = 单元格类型.墙壁;
                            }
                        } else {
                            const x =
                                最终房间.x +
                                Math.floor(Math.random() * 最终房间.w);
                            const yStart =
                                最终房间.y +
                                Math.floor(
                                    Math.random() * (最终房间.h - 墙体长度)
                                );
                            for (let y = yStart; y < yStart + 墙体长度; y++) {
                                if (地牢[y]?.[x])
                                    地牢[y][x].背景类型 = 单元格类型.墙壁;
                            }
                        }
                    }
                    boss房连通 = 检查房间连通性(最终房间);
                    boss房尝试++;
                } while (!boss房连通 && boss房尝试 < 2000);

                生成墙壁();
                房间列表.forEach((房间) => 更新房间墙壁(房间));

                生成符文圈群组(最终房间, 3);
                放置怪物到房间(new 大魔法师({ 强化: true }), 最终房间);

                const 起始房间 = 获取房间("中央大厅");
                玩家初始位置.x = 起始房间.x + Math.floor(起始房间.w / 2);
                玩家初始位置.y = 起始房间.y + Math.floor(起始房间.h / 2);
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;
                已访问房间.add(起始房间.id);

                更新视口();
                更新界面状态();
                绘制();
            }

            function 检查所有水晶状态() {
                let 已摧毁数量 = 0;
                for (const row of 地牢) {
                    for (const cell of row) {
                        if (
                            cell.关联物品 instanceof 魔法水晶 &&
                            cell.关联物品.自定义数据.get("已摧毁")
                        ) {
                            已摧毁数量++;
                        }
                    }
                }
                if (已摧毁数量 >= 4) {
                    生成最终传送门();
                }
            }

            function 生成最终传送门() {
                const 中心大厅 = 房间列表.find((r) => r.名称 === "中央大厅");
                const 最终秘室 = 房间列表.find((r) => r.名称 === "最终秘室");
                if (中心大厅 && 最终秘室) {
                    const 传送门 = new 折跃门({
                        目标房间: 最终秘室,
                        是否为隐藏物品: false,
                    });
                    放置物品到房间(
                        传送门,
                        中心大厅,
                        单元格类型.物品,
                        false,
                        true
                    );
                    显示通知(
                        "一股强大的魔法能量汇聚在中央大厅，开启了一道传送门！",
                        "成功"
                    );
                }
            }
            function 显示自定义确认对话框(message, onConfirm) {
                if (document.querySelector('.确认对话框遮罩')) return;

                const 确认遮罩 = document.createElement("div");
                确认遮罩.className = "确认对话框遮罩";
                确认遮罩.innerHTML = `
                    <div class="确认对话框">
                        <h3>确认操作</h3>
                        <p>${message.replace(/\n/g, '<br>')}</p>
                        <div class="确认按钮容器">
                            <button class="确认按钮 确认按钮-确认">确认</button>
                            <button class="确认按钮 确认按钮-取消">取消</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(确认遮罩);

                const closeDialog = () => {
                    确认遮罩.style.opacity = '0';
                    setTimeout(() => 确认遮罩.remove(), 300);
                };

                确认遮罩.querySelector(".确认按钮-确认").onclick = () => {
                    closeDialog();
                    if (typeof onConfirm === 'function') {
                        onConfirm();
                    }
                };
                确认遮罩.querySelector(".确认按钮-取消").onclick = closeDialog;
            }
            当前层数 = null;
            显示主菜单();
            注册全局类();
            //进入教程层();
            //切换楼层(0);
            //更新背包显示();
            //更新界面状态();
            //动画帧(); // 启动动画循环
        </script>
    </body>
</html>
