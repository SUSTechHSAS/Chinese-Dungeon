<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=0.5" />
    <title>Dungeon Game</title>
    <style>
        /*或哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈*/
        /* General Styles */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            margin: 0;
            padding-top: 5vh;
            background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%);
            background-color: #1a1a1a;
            overflow: hidden;
            justify-content: flex-start;
        }

        /*隐藏滚轮*/
        ::-webkit-scrollbar {
            display: none;
        }

        /* 不可选中 */
        .不可选中 {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Dungeon Canvas */
        #dungeonCanvas {
            border: 2px solid #2e2e2e;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
            margin-bottom: 5vh;
            transition: transform 0.15s ease-out;
            filter:
                contrast(1.1) brightness(1.1);
        }

        /* --- 主菜单 --- */
        #主菜单容器 {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10005;
            /* 确保在最顶层 */
            opacity: 1;
            transition: opacity 0.5s ease-out;
            color: #e0e0e0;
            font-family: "HarmonyOS Sans SC", "MiSans", system-ui, "color-emoji";
        }

        #游戏标题 {
            font-size: 5rem;
            margin-bottom: 3rem;
            color: #4caf50;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
            font-family: 'Arial Black', Gadget, sans-serif;
            /* 更具冲击力的字体 */
            letter-spacing: 2px;
            animation: 标题浮动 3s ease-in-out infinite;
        }

        @keyframes 标题浮动 {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }


        #菜单选项 {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .菜单按钮 {
            padding: 1rem 2.5rem;
            font-size: 1.4rem;
            border: 2px solid #4caf50;
            border-radius: 8px;
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.2), rgba(67, 160, 71, 0.1));
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 250px;
            text-align: center;
            font-family: inherit;
            /* 继承body字体 */
        }

        .菜单按钮:hover {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.4), rgba(67, 160, 71, 0.3));
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
            border-color: #66bb6a;
        }

        .菜单按钮:active {
            transform: translateY(1px);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
        }

        .菜单按钮:disabled {
            background: rgba(100, 100, 100, 0.2);
            border-color: #666;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }


        #版本信息 {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 0.8rem;
            color: #555;
        }

        /* --- 游戏状态控制 --- */
        body:not(.游戏进行中) #dungeonCanvas,
        body:not(.游戏进行中) .hud,
        body:not(.游戏进行中) .control-pad,
        body:not(.游戏进行中) .装备栏,
        body:not(.游戏进行中) #小地图容器,
        body:not(.游戏进行中) .control-row,
        /* 隐藏设置和小地图切换按钮的父容器 */
        body:not(.游戏进行中) #怪物指示器容器,
        body:not(.游戏进行中) #浮动提示框,
        body:not(.游戏进行中) .背包弹窗,
        body:not(.游戏进行中) #日志面板,
        body:not(.游戏进行中) #交易窗口,
        body:not(.游戏进行中) .附魔弹窗,
        body:not(.游戏进行中) .重铸遮罩,
        body:not(.游戏进行中) .宠物遮罩,
        body:not(.游戏进行中) .通知容器,
        body:not(.游戏进行中) #教程提示窗口,
        body:not(.游戏进行中) #跳过教程按钮,
        body:not(.游戏进行中) #回放教程按钮,
        body:not(.游戏进行中) #设置菜单

        /* 隐藏游戏内元素 */
            {
            display: none;
            opacity: 0;
            pointer-events: none;
        }

        body.游戏进行中 #主菜单容器 {
            opacity: 0;
            pointer-events: none;
        }

        /* --- HUD --- */
        .hud {
            position: absolute;
            top: 5px;
            left: 5px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            font-family: Arial;
            display: flex;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            min-width: 180px;
            flex-direction: column;
        }

        .hud.可见 {
            opacity: 1;
            pointer-events: auto;
        }

        /* --- 地图实体 --- */
        .怪物图标 {
            position: absolute;
            font-size: 1.2em;
            text-shadow: 0 0 8px #ff0000;
            transition: transform 0.2s;
        }

        /* 扣血特效 */
        .扣血遮罩 {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            animation: 扣血脉冲 0.8s ease-out;
        }

        @keyframes 扣血脉冲 {
            0% {
                opacity: 0.8;
            }

            100% {
                opacity: 0;
            }
        }

        .怪物指示器 {
            position: fixed;
            left: 0;
            top: 0;
            width: 12px;
            height: 12px;
            background: #ff4444;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
            pointer-events: none;
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            z-index: 1000;
        }

        /* 调整触发按钮样式 */
        #hudToggle {
            width: 6vmin;
            height: 6vmin;
            font-size: 3vmin;
            background: #2196f3;
            position: absolute;
            left: 48%;
            transform: translateX(-50%);
            bottom: 120%;
            z-index: 1000;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            /* 增加条目间距 */
        }

        .hud-icon {
            font-family: "color-emoji";
            font-size: 1.2em;
            width: 24px;
            text-align: center;
        }

        .hud-bar-container {
            position: relative;
            flex-grow: 1;
            height: 14px;
            margin-top: 4px;
            /* 进度条与图标间距 */
            height: 18px;
            /* 增大容器高度 */
        }

        .health-bar {
            background: linear-gradient(to right, #ff4444, #ff7676);
        }

        .power-bar {
            background: linear-gradient(to right, #1554db, #2c73f7);
        }

        .hud-label {
            color: #4caf50;
            font-size: 0.9em;
        }

        .怪物数量警告 {
            color: #ff4444;
        }

        .界面文本行 {
            color: #4caf50;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
        }

        .进度条标签 {
            position: absolute;
            left: 4px;
            /* 改为左侧定位 */
            white-space: nowrap;
            bottom: 1px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.75em;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            z-index: 2;
            /* 确保文字在上层 */
        }

        .hud-bar {
            position: relative;
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        @keyframes 进度条呼吸 {
            0% {
                opacity: 0.9;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 0.9;
            }
        }

        .低数值警告 {
            animation: 进度条呼吸 1.5s ease infinite;
        }

        /* --- Control Panel --- */
        .control-pad {
            position: fixed;
            left: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Directional Buttons Container */
        #方向键容器 {
            position: fixed;
            left: 20px;
            top: 50%;
            display: flex;
            /* Added for better button arrangement */
            gap: 1rem;
            /* Added for spacing between buttons */
        }

        .control-row {
            display: flex;
            justify-content: center;
            margin: 5px 0;
            gap: 1.2rem;
        }

        .control-btn {
            font-family: "color-emoji";
            width: 15vmin;
            height: 15vmin;
            border-radius: 3vmin;
            margin: 0 2px;
            font-size: 4vmin;
            background: linear-gradient(145deg,
                    rgba(76, 175, 80, 0.9) 30%,
                    rgba(67, 160, 71, 0.9) 100%);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
            color: white;
            border: 2px solid #fff;
            opacity: 0.95;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .control-btn:active {
            background: #45a049;
            transform: scale(0.9);
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.8);
        }

        #upBtn {
            margin-bottom: -12px;
            z-index: 2;
        }

        #leftBtn,
        #rightBtn {
            margin-left: -64px;
            margin: 0 1rem;
        }

        #downBtn {
            margin-top: -12px;
            z-index: 1;
        }

        #背包按钮 {
            /* Backpack Button */
            background: #2196f3;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
        }

        /* --- Inventory (背包) --- */
        .背包弹窗 {
            /* Inventory Popup */
            position: fixed;
            bottom: -600px;
            left: 50%;
            transform: translateX(-50%);
            width: 80vmin;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 12px;
            padding: 15px;
            transition: bottom 0.3s ease;
            z-index: 1001;
            max-height: 50vh;
            display: flex;
            flex-direction: column;
        }

        .背包弹窗.显示中 {
            bottom: 12vh;
        }

        .弹窗头部 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .弹窗头部 h3 {
            color: #4caf50;
            margin: 0;
            font-size: 1.2em;
        }

        .关闭按钮 {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            padding: 8px;
        }

        .物品容器 {
            flex: 1;
            overflow-y: auto;
            padding: 5px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
        }

        .物品条目 {
            position: relative;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hover:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .物品图标 {
            font-family: "color-emoji";
            font-size: 2em;
            text-align: center;
            margin-bottom: 8px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
            transition: transform 0.3s;
        }

        .汉字图标 {
            font-family: "Microsoft YaHei", sans-serif;
            font-weight: bold;
            font-size: 1.2em;
        }

        .hover:hover .物品图标 {
            transform: scale(1.2) rotate(-15deg);
        }

        .物品名称 {
            font-size: 0.9em;
            text-align: center;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .物品堆叠 {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: linear-gradient(45deg,
                    rgba(0, 0, 0, 0.6),
                    rgba(50, 50, 50, 0.8));
            color: #fff;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .装备按钮,
        .丢弃按钮,
        .使用按钮 {
            font-family: "color-emoji";
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: none;
            color: white;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            padding: 0;
            z-index: 1;
        }

        .装备按钮:active,
        .丢弃按钮:active,
        .使用按钮:active {
            transform: scale(0.9);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.4);
        }


        .装备按钮 {
            bottom: 3px;
            left: 3px;
            background: linear-gradient(145deg, #ffb74d, #ff9800);
            /* 橙色渐变 */
        }

        .装备按钮:hover {
            background: linear-gradient(145deg, #ffa726, #fb8c00);
            box-shadow: 0 2px 6px rgba(255, 152, 0, 0.4);
        }


        .丢弃按钮 {
            top: 3px;
            right: 3px;
            background: linear-gradient(145deg, #bdbdbd, #9e9e9e);
            /* 灰色渐变 */
        }

        .丢弃按钮:hover {
            background: linear-gradient(145deg, #aeaeae, #8e8e8e);
            box-shadow: 0 2px 6px rgba(158, 158, 158, 0.4);
        }


        .使用按钮 {
            top: 3px;
            left: 3px;
            background: linear-gradient(145deg, #81c784, #4caf50);
            /* 绿色渐变 */
        }

        .使用按钮:hover {
            background: linear-gradient(145deg, #66bb6a, #43a047);
            box-shadow: 0 2px 6px rgba(76, 175, 80, 0.4);
        }

        .物品条目:hover .装备按钮,
        .物品条目:hover .丢弃按钮,
        .物品条目:hover .使用按钮 {
            opacity: 1;
        }

        .物品条目.active .物品图标 {
            transform: scale(1.2) rotate(-15deg);
        }

        .冷却标签 {
            position: absolute;
            bottom: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8em;
        }

        .耐久标签 {
            position: absolute;
            bottom: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8em;
            z-index: 2;
        }

        /* 怪物血条 */
        .怪物血条 {
            position: fixed;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            pointer-events: none;
            z-index: 100;
        }

        .血条背景 {
            height: 100%;
            background: #444;
        }

        .当前血量 {
            height: 100%;
            background: #f00;
            transition: width 0.3s;
        }

        /* 死亡动画 */
        .骷髅图标 {
            font-family: "color-emoji";
            font-size: 80px;
            animation: 骷髅抖动 1s infinite;
        }

        .死亡文字 {
            color: white;
            font-size: 40px;
            text-shadow: 0 0 10px red;
            margin-top: 20px;
        }

        .重生选项 {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .重生按钮 {
            font-family: "color-emoji";
            padding: 12px 24px;
            font-size: 18px;
            border: 2px solid #fff;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .重生按钮:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .死亡内容 {
            text-align: center;
            animation: 死亡浮现 1s ease-out;
        }

        #死亡遮罩 {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(45deg,
                    rgba(20, 0, 0, 0.9) 0%,
                    rgba(60, 0, 0, 0.95) 100%);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            animation: 界面浮现 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes 界面浮现 {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .死亡内容容器 {
            font-family: "color-emoji";
            background: rgba(10, 0, 0, 0.8);
            border: 2px solid #ff444480;
            border-radius: 16px;
            padding: 40px 60px;
            box-shadow: 0 0 40px rgba(255, 50, 50, 0.3);
            text-align: center;
        }

        .骷髅容器 {
            position: relative;
            margin-bottom: 30px;
        }

        .动态骷髅 {
            font-size: 6rem;
            text-shadow: 0 0 30px #ff0000;
            animation: 骷髅呼吸 2s ease-in-out infinite;
            display: inline-block;
        }

        @keyframes 骷髅呼吸 {
            0% {
                transform: scale(1) rotate(-5deg);
                opacity: 0.9;
            }

            50% {
                transform: scale(1.1) rotate(5deg);
                opacity: 1;
            }

            100% {
                transform: scale(1) rotate(-5deg);
                opacity: 0.9;
            }
        }

        .重生选项 {
            font-family: "color-emoji";
            display: grid;
            gap: 20px;
            margin-top: 30px;
        }

        .重生按钮 {
            font-family: "color-emoji";
            padding: 16px 32px;
            font-size: 1.2rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(145deg,
                    rgba(100, 0, 0, 0.8),
                    rgba(150, 0, 0, 0.6));
            color: #fff;
            position: relative;
            overflow: hidden;
            border: 1px solid #ff4444;
        }

        .重生按钮::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.2),
                    transparent);
            transition: 0.5s;
        }

        .重生按钮:hover::before {
            left: 100%;
        }

        .重生按钮:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 50, 50, 0.4);
        }

        .重生按钮:active {
            transform: translateY(1px);
        }

        #重新开始 {
            background: linear-gradient(145deg,
                    rgba(50, 50, 50, 0.8),
                    rgba(30, 30, 30, 0.6));
            border-color: #666;
        }

        @keyframes 粒子飘落 {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 0.8;
            }

            100% {
                transform: translate(${Math.random() * 100 - 50}px, 100vh) scale(0);
                opacity: 0;
            }
        }

        /* 添加点击态样式 */
        .物品条目.active {
            background: rgba(255, 255, 255, 0.2) !important;
            transform: translateY(-2px) !important;
        }

        .物品条目.active .装备按钮,
        .物品条目.active .丢弃按钮,
        .物品条目.active .使用按钮 {
            opacity: 1 !important;
        }

        .物品条目[data-quality="1"] {
            border: 1px solid #00ff00;
        }

        .物品条目[data-quality="2"] {
            border: 1px solid #0000ff;
        }

        .物品条目[data-quality="3"] {
            border: 1px solid #ffff00;
        }

        .物品条目[data-quality="4"] {
            animation: 紫光脉动 2s infinite;
        }

        @keyframes 紫光脉动 {

            0%,
            100% {
                box-shadow: 0 0 12px rgba(224, 64, 251, 0.3);
            }

            50% {
                box-shadow: 0 0 24px rgba(224, 64, 251, 0.6);
            }
        }

        .物品条目[data-quality="5"] {
            animation: 红光脉动 2s infinite;
        }

        @keyframes 红光脉动 {

            0%,
            100% {
                box-shadow: 0 0 12px #ff0000;
            }

            50% {
                box-shadow: 0 0 24px #ff0000;
            }
        }


        .装备栏 {
            transition: opacity 0.3s ease;
            position: fixed;
            right: 20px;
            top: 75%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 12px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            z-index: 1000;
        }

        .装备槽 {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .冷却遮罩 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            clip-path: inset(0 0 100% 0);
            transition: clip-path 0.22s linear;
            pointer-events: none;
        }

        .装备槽 .物品条目 {
            transform: scale(0.75) translateY(-3px);
            margin: -5px 0;
        }

        .装备槽:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* --- Staircase (楼梯) --- */
        .楼梯 {
            background-color: #4a4a4a;
            font-size: 1.5em;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* --- Tooltip (浮动提示框) --- */
        #浮动提示框 {
            /* Tooltip */
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-family: Arial;
            font-size: 12px;
            max-width: 200px;
            pointer-events: none;
            z-index: 1002;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: none;
            line-height: 1.4;
        }

        #浮动提示框 br {
            margin: 4px 0;
            content: "";
            display: block;
        }

        /* --- Level Transition (楼层过渡遮罩) --- */
        .楼层过渡遮罩 {
            /* Level Transition Overlay */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .层数标题 {
            /* Level Number Title */
            color: #ffffff;
            font-size: 4em;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            opacity: 0;
            transform: scale(3);
            transition: all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            font-family: "Arial Black", sans-serif;
            letter-spacing: 4px;
        }

        /* --- Notifications (通知) --- */
        .通知容器 {
            /* Notification Container */
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 99999;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            font-family: Arial, "微软雅黑";
        }

        .通知条目 {
            /* Notification Item */
            background: rgba(40, 40, 40, 0.95);
            color: #e0e0e0;
            padding: 12px 24px;
            border-radius: 6px;
            min-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border-left: 4px solid;
            opacity: 0;
            transform: translateY(-30px);
            animation: 通知入场 0.3s ease-out forwards;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.2s linear;
            display: flex;
            align-items: center;
            gap: 12px;
            backdrop-filter: blur(5px);
        }

        .通知条目.离场 {
            /* Leaving Notification */
            animation: 通知离场 0.3s ease-in forwards;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.2s linear;
        }

        @keyframes 通知入场 {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes 通知离场 {
            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        .通知条目.成功 {
            border-color: #4caf50;
        }

        .通知条目.警告 {
            border-color: #ff9800;
        }

        .通知条目.错误 {
            border-color: #f44336;
        }

        .通知条目.信息 {
            border-color: #2196f3;
        }

        .通知图标 {
            font-family: "color-emoji";
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .关闭按钮 {
            font-family: "color-emoji";
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            margin-left: auto;
            padding-left: 20px;
            transition: color 0.2s;
        }

        .关闭按钮:hover {
            color: #fff;
        }

        /* --- Responsive Design --- */
        #小地图容器 {
            position: absolute;
            transform: translateY(-50%);
            transition: opacity 0.3s ease, transform 0.3s ease;
            mix-blend-mode: lighten;
        }

        #小地图容器:hover {
            mix-blend-mode: normal;
        }

        #跳过教程按钮 {
            font-size: 0.8em;
            display: block;
            position: fixed;
            top: 185px;
            right: 22px;
            height: 5vmin;
            width: 20vmin;
        }

        @media (min-width: 769px) {
            .control-pad {
                display: none;
            }

            .control-btn {
                display: none;
            }

            .control-row {
                display: none;
            }

            #小地图容器 {
                position: fixed;
                top: 20px;
                right: 20px;
                transform: none;
            }

            #跳过教程按钮 {
                top: 240px;
            }

            #回放教程按钮 {
                top: 185px;
            }

            .装备栏 {
                position: fixed;
                right: 20px;
                top: 75%;
                transform: translateY(-50%);
            }
        }

        @media (max-width: 768px) {
            .control-pad {
                display: flex;
            }

            .control-btn {
                display: flex;
            }

            .control-row {
                display: flex;
            }

            #跳过教程按钮 {
                top: 40px;
            }

            #回放教程按钮 {
                top: 10px;
            }

            #小地图容器,
            .装备栏 {
                right: 20px;
                top: 75%;
            }
        }

        canvas {
            mix-blend-mode: lighten;
        }

        /* 烟花动画 */
        @keyframes 烟花炸裂 {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(calc(var(--tx) * 100px),
                        calc(var(--ty) * 100px)) scale(0);
                opacity: 0;
            }
        }

        .烟花粒子 {
            font-family: "color-emoji";
            position: fixed;
            z-index: 99999;
            font-size: 1.2em;
            animation: 烟花炸裂 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            pointer-events: none;
        }

        @keyframes 收集脉冲 {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
                text-shadow:
                    0 0 30px var(--辉光颜色),
                    0 0 40px var(--辉光颜色);
            }

            100% {
                transform: scale(1);
                opacity: 0;
                text-shadow:
                    0 0 10px var(--辉光颜色),
                    0 0 20px var(--辉光颜色);
            }
        }

        .收集特效 {
            font-family: "color-emoji";
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            z-index: 99998;
            animation: 收集脉冲 1.1s ease-out forwards;
            text-shadow: 0 0 10px var(--辉光颜色);
        }

        /*卷轴类待点击动画*/
        .卷轴闪烁 {
            animation: 卷轴脉冲 0.8s ease-in-out infinite;
            position: relative;
        }

        @keyframes 卷轴脉冲 {
            0% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
                background: rgba(255, 215, 0, 0.1);
            }

            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
                background: rgba(255, 215, 0, 0.3);
            }

            100% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
                background: rgba(255, 215, 0, 0.1);
            }
        }

        .卷轴闪烁::after {
            content: "";
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border-radius: 8px;
            background: linear-gradient(45deg,
                    rgba(255, 215, 0, 0.3) 0%,
                    rgba(255, 215, 0, 0.1) 50%,
                    rgba(255, 215, 0, 0.3) 100%);
            z-index: -1;
            animation: 光晕扩散 1.2s infinite;
        }

        @keyframes 光晕扩散 {
            0% {
                opacity: 0.8;
            }

            100% {
                opacity: 0;
            }
        }

        /* 日志容器 */
        .日志面板 {
            position: fixed;
            right: 20px;
            bottom: -600px;
            width: 250px;
            height: 200px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 8px;
            padding: 12px;
            transition: bottom 0.3s ease;
            color: #c0c0c0;
            display: flex;
            flex-direction: column;
        }

        .日志内容 {
            flex: 1;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.4;
            scrollbar-width: thin;
            scrollbar-color: #4caf50 #2a2a2a;
        }

        .日志面板.可见 {
            bottom: 135px;
        }

        .日志内容 .成功 {
            color: green;
        }

        .日志内容 .错误 {
            color: red;
        }

        .日志内容 .警告 {
            color: yellow;
        }

        /* 滚动条样式 */
        .日志内容::-webkit-scrollbar {
            width: 6px;
        }

        .日志内容::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        .日志内容::-webkit-scrollbar-thumb {
            background: #4caf50;
            border-radius: 3px;
        }

        @keyframes 爆炸闪烁 {
            0% {
                transform: scale(0);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        /* --- NPC-------流浪奸商 --- */
        #交易窗口 {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 500px;
            background: linear-gradient(145deg, rgba(20, 20, 20, 0.95), rgba(40, 40, 40, 0.98));
            border: 2px solid #4caf50;
            border-radius: 12px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
            color: #e0e0e0;
            z-index: 1001;
            backdrop-filter: blur(5px);
            animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: none;
            flex-direction: column;
            transition: all 0.7s cubic-bezier(0.4, 0, 0.2, 1);
            max-height: 80vh;
        }

        #交易窗口.关闭中 {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            pointer-events: none;
        }

        .窗口标题 {
            padding: 15px 20px;
            font-size: 1.3em;
            color: #4caf50;
            border-bottom: 1px solid rgba(76, 175, 80, 0.3);
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.4);
            text-align: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .库存列表 {
            display: grid;
            gap: 12px;
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .交易物品条目 {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .交易物品条目 .物品头 {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            font-weight: bold;
        }

        .交易物品条目 .物品描述 {
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.4;
        }


        .交易物品条目:hover {
            border-color: #4caf50;
            background: rgba(76, 175, 80, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(76, 175, 80, 0.2);
        }

        .物品价格 {
            color: #ffd700;
            font-size: 0.9em;
            font-weight: bold;
            white-space: nowrap;
            margin-left: 10px;
        }

        .交易底部 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-top: 1px solid rgba(76, 175, 80, 0.3);
            background: rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

        .玩家金币 {
            color: #ffd700;
            font-weight: bold;
        }


        #交易窗口 .按钮 {
            padding: 8px 20px;
            font-size: 1em;
            border: 2px solid #4caf50;
            border-radius: 6px;
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.4), rgba(67, 160, 71, 0.3));
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        #交易窗口 .按钮:hover {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.6), rgba(67, 160, 71, 0.5));
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
            border-color: #66bb6a;
        }

        #交易窗口 .按钮:active {
            transform: translateY(0px);
            box-shadow: 0 2px 5px rgba(76, 175, 80, 0.2);
        }

        /* --- NPC-------探险家收购 --- */
        #收购窗口 {
            display: none;
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 700px;
            background: linear-gradient(145deg, rgba(20, 20, 20, 0.95), rgba(40, 40, 40, 0.98));
            border: 2px solid #ff9800;
            border-radius: 12px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.7);
            color: #e0e0e0;
            z-index: 1001;
            backdrop-filter: blur(5px);
            animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transition: all 0.7s cubic-bezier(0.4, 0, 0.2, 1);
            flex-direction: column;
            max-height: 85vh;
        }

        #收购窗口.关闭中 {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            pointer-events: none;
        }

        #收购窗口 .窗口标题 {
            color: #ff9800;
            border-bottom: 1px solid rgba(255, 152, 0, 0.3);
            text-shadow: 0 0 5px rgba(255, 152, 0, 0.4);
            padding: 15px 20px;
            font-size: 1.3em;
            text-align: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .收购内容 {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            padding: 15px;
            gap: 15px;
        }

        .收购物品列表,
        .玩家背包预览 {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 10px;
            overflow: hidden;
        }

        .收购物品列表 h4,
        .玩家背包预览 h4 {
            margin-bottom: 10px;
            text-align: center;
            color: #ffcc80;
            flex-shrink: 0;
            padding-bottom: 5px;
            border-bottom: 1px dashed rgba(255, 152, 0, 0.2);
        }


        #收购需求列表,
        #玩家可售列表 {
            align-content: start;
            padding: 10px 5px;
            overflow-y: auto;
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
        }


        .收购需求条目,
        .玩家可售条目 {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            transition: all 0.2s ease;
            text-align: center;
        }

        .玩家可售条目 {
            cursor: pointer;
        }


        .收购需求条目 .需求图标,
        .玩家可售条目 .物品图标 {
            font-size: 1.8em;
            display: block;
            margin-bottom: 5px;
            font-family: "color-emoji";
        }

        .玩家可售条目 .物品图标 {
            text-shadow: 0 0 5px currentColor;
        }


        .收购需求条目 .需求名称,
        .玩家可售条目 .物品名称 {
            font-size: 0.85em;
            display: block;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .收购需求条目 .需求价格,
        .玩家可售条目 .出售价格 {
            font-size: 0.9em;
            color: #ffd700;
            font-weight: bold;
            display: block;
        }

        .玩家可售条目:hover {
            border-color: #ff9800;
            background: rgba(255, 152, 0, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(255, 152, 0, 0.2);
        }


        #收购窗口 .交易底部 {
            border-top: 1px solid rgba(255, 152, 0, 0.3);
        }

        #收购窗口 .玩家金币 {
            color: #ffd700;
            font-weight: bold;
        }

        #收购窗口 .按钮 {
            padding: 8px 20px;
            font-size: 1em;
            border: 2px solid #ff9800;
            border-radius: 6px;
            background: linear-gradient(145deg, rgba(255, 152, 0, 0.4), rgba(245, 124, 0, 0.3));
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        #收购窗口 .按钮:hover {
            background: linear-gradient(145deg, rgba(255, 152, 0, 0.6), rgba(245, 124, 0, 0.5));
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
            border-color: #ffb74d;
        }

        #收购窗口 .按钮:active {
            transform: translateY(0px);
            box-shadow: 0 2px 5px rgba(255, 152, 0, 0.2);
        }

        /* 附魔系统 */
        .附魔弹窗 {
            font-family: "color-emoji";
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #2a0a3a 0%, #1a1a2f 100%);
            border: 2px solid #634b7d;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 40px #6b2fa070;
            z-index: 10000;
            min-width: 400px;
            max-width: 90vw;
            backdrop-filter: blur(5px);
            animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .附魔弹窗.关闭中 {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            pointer-events: none;
        }

        @keyframes 弹窗浮现 {
            from {
                opacity: 0;
                transform: translate(-50%, -45%) scale(0.9);
                /* 初始缩小并偏移 */
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
                /* 恢复原大小和位置 */
            }
        }

        .附魔头 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #4a3560;
        }

        .附魔标题 {
            color: #c792ea;
            font-size: 1.4em;
            text-shadow: 0 0 10px #c792ea80;
            font-family: '微软雅黑', sans-serif;
        }

        .附魔装备容器 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 20px;
        }

        .可附魔 {
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            background: #2d1b3c;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #4a3560;
        }

        .可附魔:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 25px #c792ea80;
            background: #3a254d;
        }

        .可附魔:hover .物品图标 {
            animation: 装备浮动 1.5s ease-in-out infinite;
        }

        @keyframes 装备浮动 {
            0% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-5px);
            }

            100% {
                transform: translateY(0);
            }
        }

        .附魔特效 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .魔幻粒子 {
            will-change: transform, opacity;
            filter: blur(2px);
            mix-blend-mode: screen;
            position: absolute;
            width: var(--size);
            height: var(--size);
            border-radius: 50%;
            background: hsla(var(--hue), 80%, var(--lightness), 0.8);
            transition: all 0.3s;
            animation:
                粒子脉动 1.2s var(--delay) both,
                光晕闪烁 1.4s var(--delay) linear infinite;
        }

        @keyframes 粒子脉动 {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(0.3);
            }

            100% {
                opacity: 0;
                transform: translate(var(--target-x), var(--target-y)) scale(0.2);
            }
        }

        @keyframes 光晕闪烁 {

            0%,
            100% {
                box-shadow: 0 0 15px 3px hsl(var(--hue), 100%, 60%);
            }

            50% {
                box-shadow: 0 0 25px 6px hsl(var(--hue), 100%, 70%);
            }
        }


        .附魔确认按钮 {
            background: linear-gradient(145deg, #c792ea, #9c27b0);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.1em;
            margin-top: 20px;
            display: block;
            width: 100%;
        }

        .附魔确认按钮:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #c792ea80;
        }

        /* 关闭按钮优化 */
        .附魔弹窗 .关闭按钮 {
            background: none;
            border: none;
            color: #c792ea;
            font-size: 1.8em;
            cursor: pointer;
            transition: all 0.3s;
            padding: 5px;
            line-height: 1;
        }

        .附魔弹窗 .关闭按钮:hover {
            color: #ff4081;
            transform: rotate(90deg);
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            .附魔弹窗 {
                min-width: 300px;
                padding: 15px;
            }

            .附魔标题 {
                font-size: 1.2em;
            }

            .附魔装备容器 {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* 状态提示动画 */
        @keyframes 成功闪光 {
            0% {
                background-color: #4CAF5050;
            }

            50% {
                background-color: #4CAF5020;
            }

            100% {
                background-color: transparent;
            }
        }

        .附魔成功 {
            animation: 成功闪光 1.5s ease-out;
        }

        .重铸弹窗 {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1ae6;
            border: 2px solid #4a4a4a;
            border-radius: 12px;
            padding: 20px;
            width: 80vmin;
            max-width: 600px;
            color: #e0e0e0;
            z-index: 10000;
            box-shadow: 0 0 30px #00000080;
            animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transition:
                opacity 0.3s ease,
                transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        .重铸弹窗-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .重铸弹窗-column {
            flex: 1;
            padding: 10px;
        }

        .重铸弹窗-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            max-height: 50vh;
            overflow-y: auto;
            gap: 10px;
        }

        .重铸物品 {
            border: 1px solid #444;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            transform-origin: center;
            position: relative;
        }

        .重铸物品.selected {
            border-color: #4caf50;
            background: #2b2b2b;
            transform: scale(1.1);
            z-index: 1;
        }

        .重铸台耐久标签 {
            font-size: 0.8em;
            color: #888;
        }

        .重铸物品:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .重铸遮罩 {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(3px);
            z-index: 9999;
        }

        #repairCost {
            font-family: 'Arial Black';
            text-shadow: 0 0 5px currentColor;
            transition: color 0.3s ease;
        }

        /* 强化标识 */
        .重铸台强化标识 {
            position: absolute;
            top: 2px;
            right: 2px;
            color: #FFD700;
            font-size: 0.8em;
            text-shadow: 0 0 3px #FFD700;
        }

        /*------小地图-------*/
        #小地图 {
            position: relative;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #4caf50;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            background: rgba(0, 0, 0, 0.9);
            z-index: 999;
            image-rendering: pixelated;
        }

        #小地图:hover {
            mix-blend-mode: normal
        }

        .宠物管理窗口 {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1ae6;
            border: 2px solid #4a4a4a;
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            color: #e0e0e0;
            z-index: 10000;
            box-shadow: 0 0 30px #00000080;
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            max-height: 80vh;
            overflow-y: auto;
        }

        .宠物遮罩 {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: 9999;
        }

        .宠物状态栏 {
            margin: 15px 0;
        }

        .条容器,
        .宠物经验条容器 {
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
        }

        .宠物血量条 {
            height: 100%;
            background: linear-gradient(90deg, #f44336, #ff7043);
            border-radius: 10px;
            transition: width 0.3s;
        }

        .宠物经验条 {
            height: 100%;
            background: linear-gradient(90deg, #2196f3, #4dabf5);
            border-radius: 10px;
            transition: width 0.3s;
        }

        .宠物血量文本,
        .宠物经验文本 {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 0.9em;
        }

        .宠物属性 {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            color: #ddd;
            font-size: 0.9em;
        }

        .宠物装备格子容器 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .宠物装备格子 {
            border: 1px solid #555;
            padding: 10px;
            border-radius: 5px;
            position: relative;
            min-height: 80px;
            background: #2b2b2b;
        }

        .宠物装备槽位名 {
            position: relative;
            top: 4px;
            left: 10px;
            padding: 0 5px;
            font-size: 0.8em;
            color: #aaa;
        }

        .宠物装备选择按钮,
        .宠物装备卸下按钮 {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
            color: #fff;
            border: 2px solid #fff;
            opacity: 0.95;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
            font-family: inherit;
        }

        .宠物装备卸下按钮 {
            background: linear-gradient(145deg, rgba(244, 67, 54, 0.9) 30%, rgba(206, 61, 49, 0.9) 100%);
            box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
            position: absolute;
            bottom: 5px;
            right: 5px;
        }

        .宠物技能容器 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .宠物技能 {
            border: 1px solid #555;
            padding: 10px;
            border-radius: 5px;
            background-color: #333;
        }

        .宠物装备选择弹窗 {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1ae6;
            border: 2px solid #4a4a4a;
            border-radius: 12px;
            padding: 20px;
            width: 80%;
            max-width: 400px;
            color: #e0e0e0;
            z-index: 10001;
            box-shadow: 0 0 30px #00000080;
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            max-height: 75vh;
            overflow: scroll;
        }

        .可装备物品容器 {
            max-height: 60vh;
            overflow-y: auto;
            /* 滚动 */
            padding: 10px;
        }

        /* 可选装备样式 */
        .宠物可选装备 {
            display: flex;
            align-items: center;
            padding: 8px;
            border: 1px solid #2c3e50;
            border-radius: 6px;
            margin-bottom: 5px;
            background-color: #41586b;
            transition: background-color 0.2s;
        }

        .宠物可选装备:hover {
            background-color: #546e7a;
        }

        .宠物装备名称 {
            position: relative;
            top: 4px;
            left: 2px;
            padding: 0 5px;
            font-size: 0.8em;
            color: #aaa;
        }

        .宠物可选装备图标 {
            font-family: "color-emoji";
            margin-right: 10px;
            font-size: 1.2em;
        }

        .宠物装备图标 {
            font-family: "color-emoji";
        }

        .宠物装备选择弹窗 .关闭按钮 {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: #e74c3c;
            cursor: pointer;
            padding: 5px;
            z-index: 1;
        }

        .宠物装备选择确认按钮 {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            color: #fff;
            border: none;
            border-radius: 5px;
            padding: 6px 12px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            font-family: inherit;
            margin-left: auto;
        }

        .宠物装备选择确认按钮:hover {
            background: linear-gradient(145deg, rgba(67, 160, 71, 0.9) 30%, rgba(58, 140, 62, 0.9) 100%);
            transform: translateY(-2px);
            /* 上浮效果 */
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
        }

        .通用按钮:hover {
            background: linear-gradient(145deg, rgba(67, 160, 71, 0.9) 30%, rgba(58, 140, 62, 0.9) 100%);
            transform: translateY(-2px);
            /* 上浮效果 */
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
        }

        .宠物装备选择确认按钮:active {
            transform: scale(0.95);
        }

        .宠物可选装备 {
            padding: 10px;
        }

        .可装备物品容器 {
            max-height: 65vh;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 10px;
        }

        .宠物管理窗口,
        .宠物装备选择弹窗 {
            animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .宠物可选装备 {
            justify-content: space-between;
        }

        .宠物基本信息面板 p,
        .宠物技能面板 p {
            line-height: 1.6;
        }

        .宠物已装备物品 {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        /* 无装备提示 */
        .无装备提示,
        .无技能提示 {
            color: #aaa;
            text-align: center;
            padding: 20px;
        }

        .宠物管理窗口 .关闭按钮 {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: #e74c3c;
            cursor: pointer;
            transition: transform 0.3s;
            padding: 5px;
        }

        .宠物管理窗口 .关闭按钮:hover {
            color: #ff4081;
            transform: rotate(90deg);
            /* 旋转动画 */
        }

        .宠物管理窗口 .通用按钮 {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 4px 20px #4caf504d;
            color: #fff;
            border: 2px solid #fff;
            opacity: .95;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            font-family: inherit;
            margin-top: 10px;
            width: 100%;
        }

        .宠物血量标签 {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            white-space: nowrap;
            z-index: 1;
        }

        /* --------------教程---------------*/
        .教程提示窗口 {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #282828f2, #3a3a3af2);
            color: #e0e0e0;
            padding: 20px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
            z-index: 10002;
            width: 85%;
            text-align: center;
            border: 2px solid #4caf50;
            animation: 弹窗浮现 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: none;
            font-family: "HarmonyOS Sans SC", "MiSans", system-ui, 'color-emoji';
        }

        .教程提示窗口 p {
            font-size: 1.1em;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .教程提示窗口 .关闭按钮 {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 2px 8px #4caf5066;
            color: #fff;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-family: inherit;
        }

        .教程提示窗口 .关闭按钮:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px #4caf5080;
            background: linear-gradient(145deg, rgba(67, 160, 71, 0.9) 30%, rgba(58, 140, 62, 0.9) 100%);
        }

        .教程提示窗口.关闭中 {
            animation: 弹窗消失 0.3s ease-out forwards;
        }

        @keyframes 弹窗消失 {
            to {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
        }

        #回放教程按钮 {
            position: fixed;
            right: 22px;
            width: 20vmin;
        }

        #教程回放窗口 {
            display: none;
            max-width: 90%;
        }

        .教程导航 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            color: #aaa;
        }

        .教程导航 button {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.7) 30%, rgba(67, 160, 71, 0.7) 100%) !important;
            box-shadow: 0 2px 6px #4caf504d !important;
            padding: 6px 12px !important;
            font-size: 0.9em !important;
        }

        .教程导航 button:disabled {
            background: #555 !important;
            cursor: not-allowed;
            opacity: 0.6;
            box-shadow: none !important;
        }

        /* -----------设置----------*/
        .设置菜单 {
            position: fixed;
            bottom: -450px;
            left: 68%;
            transform: translateX(-50%);
            background: #000000e5;
            border-radius: 12px;
            padding: 15px;
            transition: bottom 0.3s ease;
            z-index: 1003;
            text-align: center;
        }


        .设置菜单 button {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 10px;
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 4px 20px #4caf504d;
            color: #fff;
            border: 2px solid #fff;
            opacity: 0.95;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1em;
        }

        .设置菜单 button:active {
            background: #45a049;
            transform: scale(0.9);
            box-shadow: 0 0 5px #4caf50cc
        }

        .设置菜单.显示 {
            bottom: 110px;
        }

        .设置菜单.隐藏 {
            animation: 弹窗消失 0.3s ease-out forwards;
        }

        #小地图容器.隐藏,
        .装备栏.隐藏 {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-50%) scale(0.8);
        }

        @keyframes 扭曲 {
            0% {
                transform: scale(1) skew(0deg);
            }

            25% {
                transform: scale(1.1) skew(5deg);
            }

            50% {
                transform: scale(0.9) skew(-5deg);
            }

            75% {
                transform: scale(1.05) skew(2deg);
            }

            100% {
                transform: scale(1) skew(0deg);
                opacity: 0;
            }
        }

        /* -----------优化字体适配------------- */
        body,
        .hud,
        .控制按钮 {
            font-family: "HarmonyOS Sans SC", "MiSans", system-ui, "color-emoji";
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        @font-face {
            font-family: "color-emoji";
            src: local("Apple Color Emoji"),
                url('./AppleColorEmoji.woff') format('woff'),
                local("Segoe UI Emoji"),
                local("Segoe UI Symbol"),
                local("Noto Color Emoji"),
                local("Arial");
        }
    </style>
</head>

<body>
    <canvas id="dungeonCanvas"></canvas>
    <div id="主菜单容器">
        <h1 id="游戏标题">中文地牢</h1>
        <div id="菜单选项">
            <button id="新建游戏按钮" class="菜单按钮">开始新游戏</button>
            <button id="读取存档按钮" class="菜单按钮" disabled>读取存档</button>
            <button id="图鉴按钮" class="菜单按钮" disabled>图鉴 (待开发)</button>
            <button id="读凭证按钮" class="菜单按钮">读取凭证</button>
        </div>
        <div id="版本信息">v1066</div>
    </div>
    <div id="教程提示窗口" class="教程提示窗口">
        <p id="教程提示内容"></p>
        <button class="关闭按钮" onclick="关闭教程提示()">我知道了</button>
    </div>

    <button id="回放教程按钮" class="control-btn" onclick="打开教程回放窗口()"
        style="display: block; height: 5vmin; font-size: 0.8em;">回看教程</button>
    <button id="跳过教程按钮" class="control-btn" onclick="跳过教程()">跳过</button>
    <div id="教程回放窗口" class="教程提示窗口">
        <p id="教程回放内容"></p>
        <div class="教程导航">
            <button id="上一页教程按钮" class="关闭按钮" style="
        margin-left: unset;
    ">上一页</button>
            <span id="教程页码" style="
        margin-left: auto;
    ">1 / 1</span>
            <button id="下一页教程按钮" class="关闭按钮">下一页</button>
        </div>
        <button class="关闭按钮" onclick="关闭教程回放窗口()">关闭</button>
    </div>
    <div id="扣血特效" class="扣血遮罩"></div>
    <div id="怪物指示器容器"></div>
    <div class="装备栏">
        <div class="装备槽" id="装备槽1"></div>
        <div class="装备槽" id="装备槽2"></div>
        <div class="装备槽" id="装备槽3"></div>
        <div class="装备槽" id="装备槽4"></div>
    </div>
    <div class="control-pad 不可选中" style="z-index: 1000">
        <!-- 日志浮窗Z:1002 大于 悬浮提示Z:1002 背包Z：1001 控制钮Z：1000 设置钮Z：999-->
        <div class="control-row">
            <div class="control-btn" id="upBtn">↑</div>
        </div>
        <div class="control-row">
            <div class="control-btn" id="leftBtn">←</div>
            <div class="control-btn" id="rightBtn">→</div>
        </div>
        <div class="control-row">
            <div class="control-btn" id="downBtn">↓</div>
        </div>
        <div class="control-row">
            <button id="背包按钮" onclick="切换背包显示()" class="control-btn">
                🎒
            </button>
            <button class="control-btn" id="互动按钮" onclick="尝试互动()">
                ⚡
            </button>
            <button id="卷轴按钮" class="control-btn" onclick="激活卷轴模式()" style="
                        display: none;
                        background: linear-gradient(145deg, #ffd700, #ffaa00);
                        box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
                    ">
                📜
            </button>
            <button id="hudToggle" class="control-btn" style="position: absolute; bottom: 110%" onclick=切换HUD模式()>
                👁️
            </button>
        </div>
    </div>
    <div class=control-row style=right:23px;position:fixed;bottom:20px;z-index:999>
        <button id="设置按钮" class="control-btn" onclick="切换设置菜单()" style="font-size: 1em;">⚙️</button>
        <button id="切换显示按钮" class="control-btn" onclick="切换显示模式()" style="font-size: 1em;">小地图</button>
    </div>
    <div id="浮动提示框"></div>
<div id="设置菜单" class="设置菜单">
        <button onclick="切换日志显示()">打开日志菜单</button>
        <button onclick="切换中文模式()">切换中文模式</button>
        <button onclick="收纳通知()">收纳通知</button>
        <button onclick="保存传送点()">保存传送点</button> <!-- 新增 -->
        <button onclick="打开传送菜单()">打开传送菜单</button> <!-- 新增 -->
        <button onclick="导出存档()">导出存档</button>
    </div>
    <!-- 新增：传送点菜单 -->
    <div id="传送点遮罩" class="重铸遮罩" style="display: none; z-index: 10001;">
        <div id="传送点菜单" class="重铸弹窗">
             <div class="重铸弹窗-header">
                 <h3>选择传送目标</h3>
                 <button class="关闭按钮" onclick="关闭传送菜单()">×</button>
             </div>
             <div id="传送点列表容器" class="重铸弹窗-items" style="max-height: 60vh;">
                 <!-- 传送点列表将动态填充到这里 -->
             </div>
        </div>
    </div>
    <input type="file" id="存档文件输入" accept=".json" style="display: none;" />
    <div id="小地图容器">
        <canvas id="小地图"></canvas>
    </div>
    <div class="hud">
        <div class="hud-item">
            <span class="hud-icon">♥️</span>
            <div class="hud-bar-container">
                <div class="hud-bar health-bar" style="width: 100%"></div>
            </div>
        </div>
        <div class="hud-item">
            <span class="hud-icon">⚡︎</span>
            <div class="hud-bar-container">
                <div class="hud-bar power-bar" style="width: 100%"></div>
            </div>
        </div>
        <div class="hud-item">
            <div class="界面文本行">
                <span class="hud-label">已探索房间：<span id="roomCount">0</span></span>
            </div>
        </div>
    </div>
    <div class="背包弹窗">
        <div class="弹窗头部">
            <h3>
                背包 (容量：<span id="当前容量">0</span>/<span id="最大容量">12</span>)
            </h3>
            <button onclick="切换背包显示()" class="关闭按钮">×</button>
        </div>
        <div id="背包物品栏" class="物品容器"></div>
    </div>
    <div id="transitionMask" class="楼层过渡遮罩">
        <div id="floorTitle" class="层数标题"></div>
    </div>
    <div class="日志面板" id="日志面板" style="z-index: 1002">
        <div class="日志内容" id="logContent"></div>
    </div>
    <div id="交易窗口">
        <div class="窗口标题">神秘商人（剩余交易次数：<span id="交易次数">3</span>）</div>
        <div class="库存列表"></div>
        <div class="交易底部">
            <div class="玩家金币">持有金币：<span id="当前金币">0</span></div>
            <button onclick="关闭交易窗口()" class="按钮">离开</button>
        </div>
    </div>
    <div id="收购窗口" class="游戏窗口">
        <div class="窗口标题">探险家收购</div>
        <div class="收购内容">
            <div class="收购物品列表">
                <h4>探险家想收购的物品：</h4>
                <div id="收购需求列表" class="库存列表"></div>
            </div>
            <div class="玩家背包预览">
                <h4>你拥有的（点击出售）：</h4>
                <div id="玩家可售列表" class="库存列表"></div>
            </div>
        </div>
        <div class="交易底部">
            <div class="玩家金币">持有金币：<span id="收购窗口金币">0</span></div>
            <button onclick="关闭收购窗口()" class="按钮">告辞</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById("dungeonCanvas");
        const ctx = canvas.getContext("2d");

        // 常量 好吧有些已经变成变量了
        let 单元格大小 = 30;
        let 画布宽度 = Math.min(
            window.innerWidth - 20,
            window.innerHeight - 20
        ); // 动态宽度
        let 画布高度 = 画布宽度; // 动态高度
        const 房间尺寸范围 = [5, 9];
        const 最大房间数 = 15;
        let 相机显示边长 = 15;
        const 最大堆叠数 = 64;
        const 地牢大小 = 100;
        const 存档版本 = "v1"
        const 所有天气列表 = ["雷暴", "诡魅", "大风", "严寒", "深夜", "深夜"];
        const 大风吹动概率 = 0.3;
        let 互动冷却 = false;

        const 调试序列 = ["上", "上", "下", "下", "左", "右", "左", "右"];
        // 单元格类型枚举
        let 当前层数 = 0;
        let 所有地牢层 = new Map(); // 保存各层地牢数据

        let 图标映射 = {
            // 物品
            药水: "🧪",
            钢制长剑: "🗡️",
            橡木法杖: "🪄",
            吸血剑: "🗡️",
            喷火枪: "💥",
            冰霜法杖: "🪄",
            重力锤: "🔨",
            剧毒匕首: "🐍",
            卷轴: "📜",
            钥匙: "🔑",
            金币: "🪙",
            回旋镖: "🪃",
            闪电链法杖: "🌩️",
            大地猛击锤: "🔨",
            穿云箭: "🏹",
            荆棘鞭: "⛓️",
            秘银锁甲: "🥼",
            真言卷轴: "📖",
            钢制板甲: "🥋",
            金币手枪: "🔫",
            下楼楼梯: "⬇️",
            上楼楼梯: "⬆️",
            怪物: "👾",
            炸弹怪物: "💣",
            盔甲怪物: "💂",
            炸弹: "💣",
            缓慢: "🐌",
            敏捷怪物: "🏃",
            远攻怪物: "👼",
            仙人掌怪物: "🌵",
            大魔法师: "🧙",
            寻宝戒指: "💍",
            装备按钮: "🛡",
            死亡图标: "💀",
            错误: "❌",
            成功: "✅",
            冰冻怪物: "🧊",
            冰盾: "❄",
            重铸台: "⚒️",
            神秘商人: "🧙",
            探险家: "👨‍🌾",
            祭坛: "🛐",
            互动按钮: "⚡",
            背包按钮: "🎒",
            卷轴按钮: "📜",
            HUD常显: "👀",
            HUD智能: "👁️",
            HUD常隐: "😑",
            宠物: "🐾",
            熊猫: "🐼",
            水母: "🪼",
            大史莱姆: "🦠",
            小史莱姆: "🦠",
            瞬移怪物: "💫",
            伪装怪物: "👿",
            腐蚀怪物: "👹",
            盗贼怪物: "🥷",
            萨满怪物: "⚕️",
            召唤师怪物: "🧿",
            幽灵仆从: "👻",
            吸能怪物: "😈",
            剧毒云雾怪物: "☁️",
            旋风怪物: "🌪️",
            旋风: "🌀",
            旋风物品: "🍃",
            眩晕: "💫",
            火焰: "🔥",
            引雷针护符: "🗼",
            荆棘种子: "🌱",
            荆棘丛: "🌵",
        };
        const 中文对照图标映射 = {
            药水: "药",
            钢制长剑: "剑",
            吸血剑: "吸",
            橡木法杖: "法",
            卷轴: "卷",
            钥匙: "钥",
            金币: "金",
            喷火枪: "喷",
            回旋镖: "回",
            闪电链法杖: "链",
            大地猛击锤: "震",
            穿云箭: "穿",
            荆棘鞭: "鞭",
            秘银锁甲: "翈",
            真言卷轴: "视",
            钢制板甲: "甲",
            金币手枪: "枪",
            下楼楼梯: "下",
            上楼楼梯: "上",
            怪物: "怪",
            炸弹怪物: "爆",
            炸弹: "炸",
            盔甲怪物: "魁",
            敏捷怪物: "速",
            远攻怪物: "远",
            仙人掌怪物: "刺",
            大魔法师: "师",
            寻宝戒指: "戒",
            装备按钮: "装",
            死亡图标: "☠︎",
            错误: "✘",
            成功: "✔",
            缓慢: "慢",
            冰冻怪物: "㓕",
            冰盾: "栤",
            重铸台: "铸",
            神秘商人: "商",
            探险家: "探",
            祭坛: "坛",
            互动按钮: "互",
            背包按钮: "背",
            卷轴按钮: "卷",
            HUD常显: "显",
            HUD智能: "䚐",
            HUD常隐: "隐",
            宠物: "宠",
            熊猫: "態",
            水母: "鲝",
            冰霜法杖: "霜",
            重力锤: "引",
            剧毒匕首: "毒",
            大史莱姆: "大",
            小史莱姆: "小",
            瞬移怪物: "瞬",
            伪装怪物: "伪",
            腐蚀怪物: "蚀",
            盗贼怪物: "盗",
            萨满怪物: "萨",
            召唤师怪物: "召",
            幽灵仆从: "仆",
            吸能怪物: "能",
            剧毒云雾怪物: "雾",
            旋风怪物: "旋",
            旋风: "風",
            旋风物品: "风",
            眩晕: "晕",
            火焰: "火",
            引雷针护符: "引",
            荆棘种子: "种",
            荆棘丛: "荆",
        };
        // 单元格类型枚举
        const 单元格类型 = {
            墙壁: 0,
            房间: 1,
            走廊: 2,
            门: 3,
            上锁的门: 4,
            物品: 5,
            楼梯下楼: 6,
            楼梯上楼: 7,
            怪物: 8,
        };
        const 怪物状态 = {
            休眠: 0,
            活跃: 1,
            攻击: 2,
        };
        const 颜色表 = [
            "#00FF00", // 绿色
            "#0000FF", // 蓝色
            "#FFFF00", // 黄色
            "#FF00FF", // 品红
            "#FF0000", // 红色
        ];
        const 效果颜色编号映射 = [
            "#ff0000",
            "#00ff00",
            "#2196F3",
            "#FF9800",
            "#808080",
            "#9C27B0",
            "#008000",
            "#888888",
            "#8FBC8F",
            "#FFEB3B",
            "#CC5500",
            "#FFD700",
        ];
        const 效果名称编号映射 = {
            治疗: 0,
            能量: 1,
            神龟: 2,
            狂暴: 3,
            隐身: 4,
            透视: 5,
            中毒: 6,
            缓慢: 7,
            腐蚀: 8,
            眩晕: 9,
            火焰: 10,
            充能: 11,
        };
        const 颜色名表 = ["绿", "蓝", "黄", "品红", "红"];
        let 楼梯图标 = { 下楼: 图标映射.下楼楼梯, 上楼: 图标映射.上楼楼梯 };
        const 功能键映射 = {
            "1": () => 使用装备槽物品(1),
            "2": () => 使用装备槽物品(2),
            "3": () => 使用装备槽物品(3),
            "4": () => 使用装备槽物品(4),
            "q": () => { // 原逻辑
                界面可见性.hud = !界面可见性.hud;
                hud模式 = 界面可见性.hud ? "常显" : "常隐";
                document
                    .querySelector(".hud")
                    .classList.toggle("可见", 界面可见性.hud);
            },
            "f": () => {  // 互动按钮
                if (NPC互动中) {
                    if (当前NPC.名称 === "神秘商人") {
                        关闭交易窗口();
                    }
                } else {
                    尝试互动();
                }
            },
            "e": () => { // 背包按钮
                界面可见性.背包 = !界面可见性.背包;
                切换背包显示();
            },
            "r": () => { // 卷轴互动
                if (
                    document.getElementById("卷轴按钮").style //卷轴互动按钮，此处依赖 卷轴按钮 是否显示来检测，电脑端实际上因为 卷轴按钮 父容器不显示而 卷轴按钮 自身属性无意义
                        .display === "flex"
                )
                    激活卷轴模式();
            },
            "-": 切换中文模式,
            "g": 切换日志显示,
            "z": 导出存档,
        };
        const 物品生成配置 = {
            基础概率: {
                普通房间: 0.4,
                上锁房间: 0.7,
            },
            品质权重: {
                1: [60, 0], // 品质: [基础刷新概率,随层数增长的附加刷新概率]
                2: [25, 20],
                3: [10, 30],
                4: [5, 40],
                5: [0, 10],
            },
            类型分布: {
                普通房间: [
                    { 类型: "武器", 权重: 40 },
                    { 类型: "防具", 权重: 30 },
                    { 类型: "药水", 权重: 20 },
                    { 类型: "卷轴", 权重: 10 },
                    { 类型: "工具", 权重: 25 },
                    { 类型: "宠物", 权重: 10 },
                ],
                上锁房间: [
                    { 类型: "卷轴", 权重: 30 },
                    { 类型: "武器", 权重: 30 },
                    { 类型: "药水", 权重: 25 },
                    { 类型: "防具", 权重: 15 },
                    { 类型: "工具", 权重: 25 },
                    { 类型: "宠物", 权重: 10 },
                ],
            },
        };


        const 创建物品池 = () => ({
            武器: [
                { 类: 荆棘种子, 品质: 1, 最小层: 1 },
                { 类: 橡木法杖, 品质: 2, 最小层: 3 },
                { 类: 钢制长剑, 品质: 1, 最小层: 0 },
                { 类: 吸血剑, 品质: 1, 最小层: 0 },
                { 类: 喷火枪, 品质: 1, 最小层: 0 },
                { 类: 炸弹, 品质: 2, 最小层: 1 },
                { 类: 金币手枪, 品质: 3, 最小层: 2 },
                { 类: 回旋镖, 品质: 2, 最小层: 1 },
                { 类: 闪电链法杖, 品质: 3, 最小层: 3 },
                { 类: 大地猛击锤, 品质: 3, 最小层: 3 },
                { 类: 穿云箭, 品质: 2, 最小层: 2 },
                { 类: 荆棘鞭, 品质: 1, 最小层: 1 },
                { 类: 冰霜法杖, 品质: 3, 最小层: 2 },
                { 类: 重力锤, 品质: 4, 最小层: 5 },
                { 类: 剧毒匕首, 品质: 1, 最小层: 1 },
                { 类: 神秘商人, 品质: 1, 最小层: 1 }, // 奸商武力值要高，所以在武器类（确信）

            ],
            工具: [
                { 类: 能量熔炉, 品质: 3, 最小层: 4 },
                { 类: 物品祭坛, 品质: 1, 最小层: 0 },
                { 类: 耐久祭坛, 品质: 2, 最小层: 0 },
                { 类: 背包扩容祭坛, 品质: 2, 最小层: 0 },
                { 类: 重铸台, 品质: 3, 最小层: 2 },
                { 类: 探险家, 品质: 1, 最小层: 1 },
                { 类: 火把, 品质: 1, 最小层: 3 },
            ],
            防具: [
                { 类: 引雷针护符, 品质: 3, 最小层: 2 },
                { 类: 钢制板甲, 品质: 2, 最小层: 0 },
                { 类: 秘银锁甲, 品质: 4, 最小层: 2 },
                { 类: 冰盾, 品质: 1, 最小层: 1 },
            ],
            药水: [
                { 类: 治疗药水, 品质: 2, 最小层: 0 },
                { 类: 狂暴药水, 品质: 2, 最小层: 0 },
                { 类: 神龟药水, 品质: 3, 最小层: 1 },
                { 类: 能量药水, 品质: 4, 最小层: 1 },
                { 类: 隐身药水, 品质: 3, 最小层: 2 },
                { 类: 透视药水, 品质: 3, 最小层: 1 },
            ],
            卷轴: [
                { 类: 迅捷卷轴, 品质: 2, 最小层: 0 },
                { 类: 清净卷轴, 品质: 2, 最小层: 0 },
                { 类: 跃迁卷轴, 品质: 3, 最小层: 2 },
                { 类: 真言卷轴, 品质: 4, 最小层: 4 },
                { 类: 湮灭卷轴, 品质: 1, 最小层: 0 },
                { 类: 贪婪卷轴, 品质: 3, 最小层: 3 },
                { 类: 神秘卷轴, 品质: 1, 最小层: 0 },
                { 类: 附魔卷轴, 品质: 1, 最小层: 1 },
            ],
            宠物: [
                { 类: 熊猫, 品质: 3, 最小层: 2 },
                { 类: 水母, 品质: 4, 最小层: 2 },
            ],
        });

        const 创建怪物池 = () => ({
            普通房间: [
                { 类: 怪物, 权重: 45, 最小层: 0 },
                { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
                { 类: 敏捷怪物, 权重: 15, 最小层: 2 },
                { 类: 远攻怪物, 权重: 25, 最小层: 1 },
                { 类: 炸弹怪物, 权重: 15, 最小层: 3 },
                { 类: 冰冻怪物, 权重: 15, 最小层: 2 },
                { 类: 仙人掌怪物, 权重: 25, 最小层: 1 },
                { 类: 大史莱姆怪物, 权重: 15, 最小层: 2 },
                { 类: 瞬移怪物, 权重: 10, 最小层: 3 },
                { 类: 伪装怪物, 权重: 8, 最小层: 1 },
                { 类: 腐蚀怪物, 权重: 12, 最小层: 2 },
                { 类: 盗贼怪物, 权重: 10, 最小层: 1 },
                { 类: 萨满怪物, 权重: 7, 最小层: 3 },
                { 类: 召唤师怪物, 权重: 6, 最小层: 4 },
                { 类: 吸能怪物, 权重: 11, 最小层: 1 },
                { 类: 剧毒云雾怪物, 权重: 9, 最小层: 2 },
                { 类: 旋风怪物, 权重: 10, 最小层: 4 },
            ],
            上锁房间: [
                { 类: 炸弹怪物, 权重: 35, 最小层: 1 },
                { 类: 远攻怪物, 权重: 30, 最小层: 3 },
                { 类: 敏捷怪物, 权重: 35, 最小层: 2 },
                { 类: 冰冻怪物, 权重: 15, 最小层: 0 },
                { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
                { 类: 仙人掌怪物, 权重: 30, 最小层: 1 },
                { 类: 大史莱姆怪物, 权重: 20, 最小层: 2 },
                { 类: 瞬移怪物, 权重: 15, 最小层: 3 },
                { 类: 伪装怪物, 权重: 12, 最小层: 1 },
                { 类: 腐蚀怪物, 权重: 18, 最小层: 2 },
                { 类: 盗贼怪物, 权重: 18, 最小层: 1 },
                { 类: 萨满怪物, 权重: 5, 最小层: 3 },
                { 类: 召唤师怪物, 权重: 4, 最小层: 4 },
                { 类: 吸能怪物, 权重: 9, 最小层: 1 },
                { 类: 剧毒云雾怪物, 权重: 7, 最小层: 2 },
                { 类: 旋风怪物, 权重: 12, 最小层: 3 },
            ]
        });

        // 全局变量
        let 地牢 = [];
        let 房间列表 = [];
        let 当前天气效果 = [];
        let 玩家装备 = new Map(); // 以装备槽位为索引，目前有 4 个槽位，索引从 1 开始
        let 玩家 = { x: 0, y: 0 };
        let 小地图Ctx;
        const 小地图缩放 = 3;
        const 小地图Offset = 10;
        let 视口偏移X = 0,
            视口偏移Y = 0;
        let 跟踪玩家怪物数 = 0;
        let 房间地图 = Array(地牢大小)
            .fill()
            .map(() => Array(地牢大小).fill(-1)); // 记录每个单元格所属房间ID
        let 上锁房间列表 = []; // 存储被锁定房间对象
        let 已访问房间 = new Set(); // 记录已访问过的房间
        let 显示HUD计时器 = null;
        let hud模式 = "默认";
        let 背包可见 = false;
        let 玩家背包 = new Map(); // 以物品唯一标识为索引
        let 最大背包容量 = 12;
        let 门实例列表 = new Map();
        const 通知队列 = [];
        let 移动历史 = []
        let 传送点列表 = []; // 存储传送点 { id: string, 名称: string, 层数: number, x: number, y: number }
        const 最大传送点数量 = 5; // 限制最大保存数量
        let 上次移动 = 0;
        let 移动状态 = {
            up: false,
            down: false,
            left: false,
            right: false,
        };
        let hud显示 = false;
        let 界面可见性 = {
            hud: false,
            背包: false,
        };
        let 所有怪物 = [];
        const 怪物生成概率 = 0.7;
        const 最大怪物数 = 5; //一个房间内的怪物生成上限
        let 玩家初始位置 = { x: 0, y: 0 };
        let 死亡界面已显示 = false;
        let 单击移动定时器 = null;
        let 开始移动定时器 = null;
        let 长按移动 = false;
        let 当前激活卷轴列表 = new Set();
        let 卷轴模式激活 = false; //是否点击了卷轴按钮
        let 移动间隔 = 100; // 长按连续移动间隔
        let 首次移动延迟 = 250; // 首次移动后的延迟
        let 最后移动时间 = 0;
        let 移动定时器 = null;
        let 教程阶段 = 0;
        let 教程提示已显示 = false;
        let 是否为教程层 = false;
        let 玩家属性 = {
            移动步数: 1,
            攻击加成: 0,
            防御加成: 0,
            掉落倍率: 1,
            透视: false,
            允许移动: true,
        };
        let 初始玩家属性 = {
            移动步数: 1,
            攻击加成: 0,
            防御加成: 0,
            掉落倍率: 1,
            透视: false,
            允许移动: true,
        };
        let 相机目标X = 视口偏移X;
        let 相机目标Y = 视口偏移Y;
        let 当前相机X = 视口偏移X;
        let 当前相机Y = 视口偏移Y;
        let 相机锁定 = false; // 防止中途更新目标
        const 相机移动速度 = 0.2;
        let 显示模式 = "装备"; // 默认显示装备槽
        let 日志历史 = [];
        let 是否显示通知 = true;
        let 日志面板可见 = false;
        let 所有计时器 = [];
        let 玩家状态 = [];
        let NPC互动中 = false;
        let 当前NPC = null;
        let 已击杀怪物数 = 0;
        let 怪物状态表 = new WeakMap(); //好耶！WeakMap！
        let 彩蛋1触发, 彩蛋2触发, 彩蛋3触发 = false; //卑鄙的人，彩蛋要靠自己寻找才有意义
        let 待显示格子特效队列 = [];
        let 待显示爆炸范围 = { 爆炸范围: [], 爆炸距离: null };
        let 物品池;
        let 怪物池;
        let moveQueue = [];
        let isAutoMoving = false;
        let 最高教程阶段 = 0;
        let 当前回放阶段 = 0;
        let 中文模式 = false;
        let 游戏状态 = "主菜单"; // "主菜单", "游戏中"
        canvas.addEventListener('touchstart', 处理地图点击);
        canvas.addEventListener('click', 处理地图单击); // 兼容PC端点击
        function 注册全局类() {
            // --- 基础类 ---
            window.门 = 门;
            window.物品 = 物品;
            window.怪物 = 怪物;
            window.单元格 = 单元格;
            window.状态效果 = 状态效果;

            // --- 物品子类 ---
            window.钥匙 = 钥匙;
            window.金币 = 金币;
            window.武器类 = 武器类;
            window.卷轴类 = 卷轴类;
            window.防御装备类 = 防御装备类;
            window.棋子 = 棋子;
            window.药水类 = 药水类;
            window.宠物 = 宠物;
            window.重铸台 = 重铸台;
            window.神秘商人 = 神秘商人;
            window.探险家 = 探险家;
            window.物品祭坛 = 物品祭坛;
            window.耐久祭坛 = 耐久祭坛;
            window.背包扩容祭坛 = 背包扩容祭坛;
            window.寻宝戒指 = 寻宝戒指;
            window.折跃门 = 折跃门;
            window.炸弹 = 炸弹;
            window.旋风物品 = 旋风物品;
            window.火焰物品 = 火焰物品;
            window.火把 = 火把;

            // --- 武器具体子类 ---
            window.吸血剑 = 吸血剑;
            window.冰霜法杖 = 冰霜法杖;
            window.重力锤 = 重力锤;
            window.剧毒匕首 = 剧毒匕首;
            window.荆棘鞭 = 荆棘鞭;
            window.回旋镖 = 回旋镖;
            window.闪电链法杖 = 闪电链法杖;
            window.大地猛击锤 = 大地猛击锤;
            window.穿云箭 = 穿云箭;
            window.钢制长剑 = 钢制长剑;
            window.橡木法杖 = 橡木法杖;
            window.金币手枪 = 金币手枪;
            window.喷火枪 = 喷火枪;
            window.引雷针护符 = 引雷针护符;
            window.荆棘种子 = 荆棘种子;
            window.荆棘丛 = 荆棘丛;
            window.能量熔炉 = 能量熔炉;

            // --- 防御装具体子类 ---
            window.秘银锁甲 = 秘银锁甲;
            window.钢制板甲 = 钢制板甲;
            window.冰盾 = 冰盾;

            // --- 卷轴具体子类 ---
            window.迅捷卷轴 = 迅捷卷轴;
            window.神秘卷轴 = 神秘卷轴;
            window.贪婪卷轴 = 贪婪卷轴;
            window.清净卷轴 = 清净卷轴;
            window.附魔卷轴 = 附魔卷轴;
            window.跃迁卷轴 = 跃迁卷轴;
            window.真言卷轴 = 真言卷轴;
            window.湮灭卷轴 = 湮灭卷轴;

            // --- 药水具体子类 ---
            window.治疗药水 = 治疗药水;
            window.能量药水 = 能量药水;
            window.狂暴药水 = 狂暴药水;
            window.神龟药水 = 神龟药水;
            window.隐身药水 = 隐身药水;
            window.透视药水 = 透视药水;

            // --- 棋子具体子类 ---
            window.国际象棋车 = 国际象棋车;
            window.国际象棋马 = 国际象棋马;
            window.国际象棋象 = 国际象棋象;
            window.中国象棋炮 = 中国象棋炮;

            // --- 宠物具体子类 ---
            window.熊猫 = 熊猫;
            window.水母 = 水母;

            // --- 怪物子类 ---
            window.大魔法师 = 大魔法师;
            window.腐蚀怪物 = 腐蚀怪物;
            window.盗贼怪物 = 盗贼怪物;
            window.吸能怪物 = 吸能怪物;
            window.剧毒云雾怪物 = 剧毒云雾怪物;
            window.召唤师怪物 = 召唤师怪物;
            window.幽灵仆从 = 幽灵仆从;
            window.萨满怪物 = 萨满怪物;
            window.大史莱姆怪物 = 大史莱姆怪物;
            window.小史莱姆怪物 = 小史莱姆怪物;
            window.瞬移怪物 = 瞬移怪物;
            window.伪装怪物 = 伪装怪物;
            window.炸弹怪物 = 炸弹怪物;
            window.盔甲怪物 = 盔甲怪物;
            window.敏捷怪物 = 敏捷怪物;
            window.远攻怪物 = 远攻怪物;
            window.仙人掌怪物 = 仙人掌怪物;
            window.冰冻怪物 = 冰冻怪物;
            window.旋风怪物 = 旋风怪物;
            window.幽灵怪物 = 幽灵怪物;
            window.旋风 = 旋风;
        }

        function 处理地图点击(e) {
            e.preventDefault();
            const touch = e.touches[0];
            处理点击(touch.clientX, touch.clientY);
        }

        function 处理地图单击(e) {
            处理点击(e.clientX, e.clientY);
        }

        //来源对象需要提供应用效果与移除效果（可选）函数
        class 状态效果 {
            constructor(类型, 颜色, 图标, 持续时间, 剩余回合 = null, 来源 = null, 关联怪物 = null, 强度 = 1) {
                this.类型 = 类型;
                this.剩余回合 = 剩余回合 || 持续时间;
                this.来源 = 来源;
                this.持续时间 = 持续时间;
                this.关联怪物 = 关联怪物;
                this.颜色 = 颜色;
                this.图标 = 图标;
                this.强度 = 强度;

                if (!this.关联怪物) {
                    const 现有效果 = 玩家状态.find(item => item.类型 === this.类型);
                    if (现有效果) {
                        现有效果.剩余回合 = Math.max(现有效果.剩余回合, this.剩余回合);
                        现有效果.强度 = Math.min(5, (现有效果.强度 || 1) + (this.强度 || 1));
                        现有效果.持续时间 = Math.max(现有效果.持续时间, this.持续时间);
                        现有效果.进度条实例?.更新({
                            数值: (现有效果.剩余回合 / 现有效果.持续时间) * 100,
                            标签: `${现有效果.类型} ${现有效果.剩余回合}回合` + (现有效果.强度 > 1 ? ` (强度 ${现有效果.强度})` : '')
                        });
                        return;
                    }

                    玩家状态.push(this);
                    this.进度条实例 = new 进度条元素({
                        图标: 图标,
                        颜色: 颜色,
                        初始值: 100,
                        标签: `${this.类型} ${this.剩余回合}回合` + (this.强度 > 1 ? ` (强度 ${this.强度})` : ''),
                    });
                    this.来源?.应用效果();
                } else {
                    const 现有怪物效果 = 怪物状态表.get(this.关联怪物);
                    if (现有怪物效果 && 现有怪物效果.类型 === this.类型) {
                        现有怪物效果.剩余回合 = Math.max(现有怪物效果.剩余回合, this.剩余回合);
                        现有怪物效果.强度 = Math.min(5, (现有怪物效果.强度 || 1) + (this.强度 || 1));
                        this.关联怪物.获得效果(现有怪物效果);
                        return;
                    }
                    怪物状态表.set(this.关联怪物, this);
                    this.关联怪物.获得效果(this);
                }
            }
            更新状态() {
                let 剩余回合 = this.剩余回合;
                剩余回合 = Math.max(0, 剩余回合 - 1);
                this.剩余回合 = 剩余回合;

                if (this.类型 === '中毒' && !this.关联怪物) {
                    伤害玩家(this.强度 || 1, '中毒');
                    添加日志(`你受到 ${this.强度 || 1} 点中毒伤害`, '错误');
                }
                if (this.类型 === '火焰' && !this.关联怪物) {
                    伤害玩家(this.强度 || 1, '火焰'); // 使用强度作为伤害
                    添加日志(`你被火焰灼烧，受到 ${this.强度 || 1} 点伤害`, '错误');
                }
                if (this.类型 === '冻结' && 玩家状态.some(s => s.类型 === "火焰")) {
                    this.剩余回合--;
                }
                if (!this.关联怪物) {
                    const 百分比 = (剩余回合 / this.持续时间) * 100;
                    this.进度条实例?.更新({
                        数值: 百分比,
                        标签: `${this.类型} ${剩余回合}回合` + (this.强度 > 1 ? ` (强度 ${this.强度})` : ''),
                    });
                }

                if (剩余回合 === 0) {
                    this.移除状态();
                } else {
                    this.来源?.应用效果();
                }
            }
            移除状态() {
                this.来源?.移除效果();

                if (!this.关联怪物) {
                    玩家状态 = 玩家状态.filter((item) => item !== this);
                } else {
                    if (怪物状态表.get(this.关联怪物) === this) {
                        怪物状态表.delete(this.关联怪物);
                    }
                }
                if (this.进度条实例) {
                    this.进度条实例.销毁();
                    this.进度条实例 = null;
                }
                return;
            }
        }


        //处理canvas的点击
        function 处理点击(clientX, clientY) {
            if (游戏状态 !== "游戏中") return;
            if (
                界面可见性.背包
            ) {
                切换背包显示();
                document.getElementById("浮动提示框").style.display =
                    "none";
                return;
            } else if (教程提示已显示) {
                关闭教程提示();
                return;
            } else if (document.getElementById("设置菜单").classList.contains("显示")) {
                切换设置菜单()
                return;
            } else if (document.getElementById('教程回放窗口').style.display === 'block') {
                关闭教程回放窗口();
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const gridX = 视口偏移X + Math.floor(x / (单元格大小));
            const gridY = 视口偏移Y + Math.floor(y / (单元格大小));

            const 全路径 = 广度优先搜索路径(
                玩家.x,
                玩家.y,
                gridX,
                gridY,
                30,
                true
            );
            const 截断路径 = [];
            for (const 节点 of 全路径) {
                const 房间ID = 房间地图[节点.y][节点.x];
                // 记录进入未探索房间的第一个格子
                if (房间ID !== -1 && !已访问房间.has(房间ID)) {
                    截断路径.push(节点);
                    break;
                }
                截断路径.push(节点);
            }
            截断路径.shift();
            if (截断路径.length > 0) {
                moveQueue = 截断路径;
                startAutoMove();
            }
        }


        class 门 {
            constructor(配置) {
                this.唯一标识 = Symbol(Date.now().toString() + Math.random().toString());
                this.类型 = "门"; //常驻类型
                this.是否上锁 = false;
                this.房间ID = 配置.关联房间ID;
                this.所在位置 = 配置.位置; // {x, y}

                // 自动注册到全局列表
                门实例列表.set(this.唯一标识, this); // 注册逻辑
            }

            尝试解锁(玩家背包) {
                return [...玩家背包.values()].some((item) =>
                    item.可交互目标(this)
                );
            }
        }

        class 怪物 {
            constructor(配置 = {}) {
                this.房间ID = (配置.房间ID === undefined) ? null : 配置.房间ID;
                this.x = (配置.x === undefined) ? null : 配置.x;
                this.y = (配置.y === undefined) ? null : 配置.y;
                this.目标路径 = [];
                this.状态 = 配置.状态 || 怪物状态.休眠;
                this.基础生命值 = 配置.基础生命值 || 23;
                this.基础攻击力 = 配置.基础攻击力 || 3;
                this.移动率 = 配置.移动率 || 0.7;
                this.图标 = 配置.图标 || 图标映射.怪物; //图标即名称
                this.类型 = 配置.类型 || "怪物";
                this.掉落物 =
                    配置.掉落物 ||
                    new 金币({ 数量: Math.floor(Math.random() * 5) + 1 });
                this.掉落概率 = 配置.掉落概率 ?? 1,
                    this.血条元素 = null;
                this.受击动画 = false;
                this.基础攻击范围 = 配置.基础攻击范围 || 1;
                this.受伤冻结回合 = 配置.受伤冻结回合 || 1;
                this.基础移动距离 = 配置.基础移动距离 || 1;

                this.跟踪距离 = 配置.跟踪距离 || 15;
                this.基础颜色 = 配置.颜色 || "#FFFFFF";
                this.强化 = 配置.强化 || false;

                this.当前生命值 = 配置.当前生命值 || this.生命值;//我觉得没有人会想要生成一只残血的怪物 //冰冻怪物：你好，有的
                this.攻击冷却 = 配置.攻击冷却 || 0;
                this.受伤冻结回合剩余 = 0;
                this.攻击冷却回合剩余 = 0;
                this.当前格 = 配置.当前格 ?? null;
                if (this.房间ID === null && this.y !== null && this.x !== null) {
                    this.房间ID = 房间地图[this.y][this.x];
                }
                this.仇恨 = null;

            }
            计算路径(目标X, 目标Y) {
                this.目标 = { x: 目标X, y: 目标Y };
                const 目标距离 = Math.floor(this.攻击范围 / 2);
                const 玩家距离图 = this.生成玩家距离图(目标X, 目标Y);

                // 当前已在有效攻击位置
                if (玩家距离图[this.y][this.x] === 目标距离) {
                    跟踪玩家怪物数++;
                    return [];
                }

                const 开放列表 = [];
                const 关闭列表 = new Set();
                const 方向映射表 = [
                    { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                    { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                    { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                    { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" }
                ];

                const 起点节点 = {
                    x: this.x,
                    y: this.y,
                    g: 0,
                    parent: null,
                };
                开放列表.push(起点节点);
                关闭列表.add(`${起点节点.x},${起点节点.y}`);

                while (开放列表.length > 0) {
                    let 当前节点 = 开放列表.shift();
                    if (玩家距离图[当前节点.y][当前节点.x] === 目标距离) {
                        const 路径 = [];
                        let 节点 = 当前节点;
                        while (节点.parent) {
                            路径.push(节点);
                            节点 = 节点.parent;
                        }
                        return 路径.reverse();
                    }

                    // 扩展相邻节点
                    方向映射表.forEach(方向 => {
                        const 新X = 当前节点.x + 方向.dx;
                        const 新Y = 当前节点.y + 方向.dy;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) return;

                        const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                        const 目标单元格 = 地牢[新Y][新X];

                        if (当前单元格.墙壁[方向.当前墙] ||
                            目标单元格.墙壁[方向.目标墙] ||
                            目标单元格.背景类型 === 单元格类型.墙壁 ||
                            目标单元格.背景类型 === 单元格类型.上锁的门) return;

                        const 位置键 = `${新X},${新Y}`;
                        if (!关闭列表.has(位置键)) {
                            关闭列表.add(位置键);
                            开放列表.push({
                                x: 新X,
                                y: 新Y,
                                g: 当前节点.g + 1,
                                parent: 当前节点
                            });
                        }
                    });
                }
                return [];
            }

            // 生成玩家实际路径距离图?什么是效率问题,我不懂
            生成玩家距离图(玩家X, 玩家Y) {
                const 距离图 = Array.from({ length: 地牢大小 }, () =>
                    Array(地牢大小).fill(Infinity)
                );
                const 队列 = [];
                const 方向映射表 = [
                    { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                    { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                    { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                    { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" }
                ];

                // 初始化玩家起始位置
                距离图[玩家Y][玩家X] = 0;
                队列.push({ x: 玩家X, y: 玩家Y });

                while (队列.length > 0) {
                    const 当前 = 队列.shift();

                    方向映射表.forEach(方向 => {
                        const 新X = 当前.x + 方向.dx;
                        const 新Y = 当前.y + 方向.dy;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) return;

                        const 当前单元格 = 地牢[当前.y][当前.x];
                        const 目标单元格 = 地牢[新Y][新X];

                        // 使用与怪物相同的移动规则
                        if (当前单元格.墙壁[方向.当前墙] ||
                            目标单元格.墙壁[方向.目标墙] ||
                            目标单元格.背景类型 === 单元格类型.墙壁 ||
                            目标单元格.背景类型 === 单元格类型.上锁的门) return;

                        // 找到更短路径
                        if (距离图[新Y][新X] > 距离图[当前.y][当前.x] + 1) {
                            距离图[新Y][新X] = 距离图[当前.y][当前.x] + 1;
                            队列.push({ x: 新X, y: 新Y });
                        }
                    });
                }

                return 距离图;
            }
            计算目标路径(目标X, 目标Y) {

                const 开放列表 = [];
                const 关闭列表 = new Set();
                const 方向映射表 = [
                    {
                        dx: 1,
                        dy: 0,
                        当前墙: "右",
                        目标墙: "左",
                    },
                    {
                        dx: -1,
                        dy: 0,
                        当前墙: "左",
                        目标墙: "右",
                    },
                    {
                        dx: 0,
                        dy: 1,
                        当前墙: "下",
                        目标墙: "上",
                    },
                    {
                        dx: 0,
                        dy: -1,
                        当前墙: "上",
                        目标墙: "下",
                    },
                ];

                const 起点节点 = {
                    x: this.x,
                    y: this.y,
                    g: 0,
                    parent: null,
                };
                开放列表.push(起点节点);

                while (开放列表.length > 0) {
                    let 当前节点 = 开放列表.shift();

                    if (当前节点.x === 目标X && 当前节点.y === 目标Y) {
                        const 路径 = [];
                        while (当前节点.parent) {
                            路径.push(当前节点);
                            当前节点 = 当前节点.parent;
                        }
                        return 路径.reverse();
                    }

                    // 探索四个方向
                    方向映射表.forEach((方向) => {
                        const 新X = 当前节点.x + 方向.dx;
                        const 新Y = 当前节点.y + 方向.dy;
                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            return;
                        const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                        const 目标单元格 = 地牢[新Y][新X];
                        const 当前墙阻挡 = 当前单元格.墙壁[方向.当前墙];
                        const 目标墙阻挡 = 目标单元格.墙壁[方向.目标墙];
                        const 硬阻挡 =
                            目标单元格.背景类型 === 单元格类型.墙壁 ||
                            目标单元格.背景类型 === 单元格类型.上锁的门;

                        if (当前墙阻挡 || 目标墙阻挡 || 硬阻挡) return;

                        // 检查是否已访问
                        const 位置键 = `${新X},${新Y}`;
                        if (!关闭列表.has(位置键)) {
                            开放列表.push({
                                x: 新X,
                                y: 新Y,
                                g: 当前节点.g + 1,//听别人说g值怎么怎么样，也就那样
                                parent: 当前节点,
                            });
                            关闭列表.add(位置键);
                        }
                    });
                }
                return null;
            }
            选择目标() {
                if (怪物状态表.get(this)?.类型 === "魅惑") {
                    return this.寻找最近怪物目标();
                }
                if (this.仇恨 instanceof 怪物) {
                    return { x: this.仇恨.x, y: this.仇恨.y };
                }
                return { x: 玩家.x, y: 玩家.y }; // 默认目标为玩家
            }

            寻找最近怪物目标() {
                let 最近距离 = Infinity;
                let 最近目标 = null;

                所有怪物.forEach(其他怪物 => {
                    if (其他怪物 === this || 其他怪物.当前生命值 <= 0 || 其他怪物.状态 === 怪物状态.休眠 || ["冻结", "魅惑"].includes(怪物状态表.get(其他怪物)?.类型) || 其他怪物 instanceof 大魔法师) return;

                    const 距离 = Math.abs(this.x - 其他怪物.x) + Math.abs(this.y - 其他怪物.y);
                    if (距离 < 最近距离 && 检查视线(this.x, this.y, 其他怪物.x, 其他怪物.y)) {
                        最近距离 = 距离;
                        最近目标 = 其他怪物;
                    }
                });
                this.魅惑目标怪物 = 最近目标;
                return 最近目标 ? { x: 最近目标.x, y: 最近目标.y } : { x: this.x, y: this.y };
            }

            尝试移动() {
                let 移动率 = this.移动率;
                const 我的状态 = 怪物状态表.get(this);
                switch (我的状态?.类型) {
                    case "冻结":
                        return;
                    case "火焰":
                        this.受伤(3, "火焰");
                        this.受伤冻结回合剩余 = 0;
                        break;
                    case "魅惑":
                        移动率 = 1;
                        break;
                    case "缓慢":
                        移动率 = 0.5;
                        break;
                    case "中毒":
                        this.受伤(我的状态.强度 || 1, '中毒');
                        this.受伤冻结回合剩余 = 0;
                        break;
                }
                if (this.当前生命值 <= 0) return;
                if (房间地图[玩家.y][玩家.x] === 0) return;
                if (this.受伤冻结回合剩余 > 0) {
                    this.受伤冻结回合剩余 -= 1;
                } else {
                    if (this.跟踪距离 >= this.目标路径.length && 怪物状态表.get(this)?.类型 !== "魅惑") {
                        跟踪玩家怪物数++;
                    }
                    if (
                        this.目标路径.length === 0 ||
                        Math.random() > 移动率 ||
                        this.跟踪距离 < this.目标路径.length
                    ) {
                        this.追击玩家中 = false;
                        return;
                    }
                    //this.目标路径 = this.计算路径(this.目标.x,this.目标.y);
                    // 获取下一个移动方向
                    const 下一步 = this.目标路径[Math.min(this.移动距离 - 1, this.目标路径.length - 1)];
                    if (下一步) {
                        const dx = 下一步.x - this.x;
                        const dy = 下一步.y - this.y;

                        // 规划实际可移动位置
                        const 最终位置 = this.规划移动路径(dx, dy);
                        if (!最终位置) return;
                        if (this instanceof 大魔法师 && 房间地图[最终位置.y][最终位置.x] === -1) return;
                        this.恢复背景类型();
                        this.保存新位置类型(最终位置.x, 最终位置.y);
                        this.x = 最终位置.x;
                        this.y = 最终位置.y;
                        地牢[this.y][this.x].类型 = 单元格类型.怪物;
                        地牢[this.y][this.x].关联怪物 = this;
                        this.处理地形效果();
                    }

                }
                if (this.接受萨满治疗) {
                    计划显示格子特效([{ x: this.x, y: this.y }], "00FF00", 0);
                    this.接受萨满治疗 = false;
                }
                this.绘制血条();
            }
            处理地形效果() {
                if (地牢[this.y][this.x]?.关联物品 instanceof 火焰物品) {
                    const 火焰实例移动后 = 地牢[this.y][this.x].关联物品;
                    const 强度移动后 = 火焰实例移动后.自定义数据.get('火焰强度') ?? 1;
                    const 持续移动后 = 火焰实例移动后.自定义数据.get('火焰持续') ?? 3;
                    new 状态效果("火焰", 效果颜色编号映射[效果名称编号映射.火焰], "火", 持续移动后, null, null, this, 强度移动后);
                    添加日志(`${this.类型} 踩到了火焰，着火了！`, "警告");
                } else if (地牢[this.y][this.x]?.关联物品 instanceof 荆棘丛) {
                    const 伤害量 = 地牢[this.y][this.x]?.关联物品?.自定义数据.get('伤害');
                    this.受伤(伤害量, '荆棘丛'); // 受到伤害
                    添加日志(`${this.类型} 踩进了荆棘丛，受到 ${伤害量} 点伤害！`, "警告");
                    if (Math.random() < 地牢[this.y][this.x]?.关联物品?.自定义数据.get('减速概率')) {
                        new 状态效果("缓慢", 效果颜色编号映射[效果名称编号映射.缓慢], "慢", 地牢[this.y][this.x]?.关联物品?.自定义数据.get('减速回合'), null, null, this, 1);
                        添加日志(`${this.类型} 被荆棘缠绕，移动变慢了！`, "警告");
                    }
                }
            }
            规划移动路径() {
                let 当前位置 = { x: this.x, y: this.y };
                let 有效位置 = null;
                let 可行距离 = this.移动距离 + 1;
                for (
                    let i = 0;
                    i < Math.min(this.目标路径.length, 可行距离);
                    i++
                ) {
                    const 节点 = this.目标路径[i];

                    const nextX = 节点.x;
                    const nextY = 节点.y;
                    if (地牢[nextY][nextX].类型 === 单元格类型.怪物) {
                        可行距离 = this.移动距离 + 1; //防止怪物团结一心变身 Bolt
                    }
                    if (
                        this.检查移动可行性(
                            当前位置.x,
                            当前位置.y,
                            nextX,
                            nextY
                        )
                    ) {
                        if (this.位置合法(nextX, nextY)) {
                            有效位置 = { x: nextX, y: nextY };
                        }
                    } else {
                        this.目标路径 = this.目标路径.slice(i);
                        return 当前位置;
                    }
                    当前位置 = { x: nextX, y: nextY };

                    if (有效位置 && i >= Math.min(this.移动距离, this.目标路径.length) - 1) {
                        this.目标路径 = this.目标路径.slice(i);
                        return 有效位置;
                    }
                }
                return 有效位置;
            }

            检查移动可行性(fromX, fromY, toX, toY) {
                const dx = toX - fromX;
                const dy = toY - fromY;
                const steps = Math.max(Math.abs(dx), Math.abs(dy));
                const xStep = dx / steps;
                const yStep = dy / steps;

                let currentX = fromX;
                let currentY = fromY;

                for (let i = 0; i <= steps; i++) {
                    const x = Math.round(currentX);
                    const y = Math.round(currentY);

                    if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
                        return false;

                    if (i > 0) {
                        const prevX = Math.round(currentX - xStep);
                        const prevY = Math.round(currentY - yStep);
                        const 移动方向 = 获取移动方向(prevX, prevY, x, y);

                        const 当前单元格 = 地牢[y][x];
                        const 前单元格 = 地牢[prevY][prevX];

                        if (
                            当前单元格.墙壁[移动方向.反方向墙] ||
                            前单元格.墙壁[移动方向.当前墙]
                        ) {
                            return false;
                        }
                    }

                    if (x === toX && y === toY) break;

                    currentX += xStep;
                    currentY += yStep;
                }
                return true;
            }
            位置合法(x, y) {
                if (地牢[y][x].类型 === 单元格类型.物品 && 地牢[y][x].关联物品?.阻碍怪物) {
                    return false;
                }
                if (房间地图[y][x] !== -1 && !已访问房间.has(房间地图[y][x])) {
                    return false;
                }
                return [
                    单元格类型.房间,
                    单元格类型.走廊,
                    单元格类型.门,
                ].includes(地牢[y][x].背景类型) && ![
                    单元格类型.楼梯上楼,
                    单元格类型.楼梯下楼,
                    单元格类型.怪物,
                ].includes(地牢[y][x].类型);
            }

            恢复背景类型() {
                地牢[this.y][this.x].类型 = this.当前格;
                if (this.当前格 === 单元格类型.物品 && 地牢[this.y][this.x].关联物品 === null) {
                    地牢[this.y][this.x].类型 = null;
                }
                地牢[this.y][this.x].关联怪物 = null;
            }

            保存新位置类型(x, y) {
                this.当前格 = 地牢[y][x].类型;
            }

            尝试攻击() {
                if (怪物状态表.get(this)?.类型 === "冻结") return;
                if (this.攻击冷却回合剩余 > 0) {
                    this.攻击冷却回合剩余 -= 1;
                    return false;
                }

                if (this.通向目标路径.length > this.攻击范围) return false;


                if (怪物状态表.get(this)?.类型 === "魅惑") {
                    if (this.魅惑目标怪物 !== this && this.魅惑目标怪物 !== null) {
                        this.魅惑目标怪物?.受伤(this.攻击力, this)
                        this.攻击冷却回合剩余 = this.攻击冷却;
                        计划显示格子特效(this.通向目标路径);
                        return true;
                    } else {
                        return false;
                    }
                }
                if (this.仇恨 instanceof 怪物) {
                    if (this.仇恨 !== this && this.仇恨 !== null) {
                        if (this.仇恨.当前生命值 <= 0) {
                            this.仇恨 = null;
                            return false;
                        }
                        this.仇恨?.受伤(this.攻击力, this)
                        this.攻击冷却回合剩余 = this.攻击冷却;
                        计划显示格子特效(this.通向目标路径);
                        return true;
                    } else {
                        return false;
                    }
                }
                伤害玩家(this.攻击力, this);
                this.攻击冷却回合剩余 = this.攻击冷却;
                计划显示格子特效(this.通向目标路径);


                return true;
            }
            get 攻击范围() {
                return this.基础攻击范围 + (this.强化 ? 1 : 0); // + (this.远程武器 ? 3 : 0);
            }
            get 攻击力() {
                return this.基础攻击力;
                +(this.强化 ? this.基础攻击力 : 0); //+ (this.武器.攻击力 ? 3 : 0);
            }
            get 颜色() {
                if (怪物状态表.get(this)) {
                    return 怪物状态表.get(this)?.颜色; // 药水颜色
                }
                return this.强化 ? "#ff0000" : this.基础颜色;
            }
            get 移动距离() {
                return this.基础移动距离 + (this.强化 ? 1 : 0)
            }
            get 生命值() {
                return this.基础生命值 + (this.强化 ? 30 : 0);
            }
            get 物品掉率() {
                return this.掉落概率 + (this.强化 ? 0.1 : 0);
            }
            获得效果(状态效果) {
                return true;
            }
            受伤(伤害, 来源 = null) {
                if (this.当前生命值 > 0) {
                    this.当前生命值 -= 伤害;
                    if (!(来源 instanceof 怪物) && 来源 !== '荆棘丛') {
                        this.受伤冻结回合剩余 = this.受伤冻结回合;
                    } else {
                        if (!(来源 instanceof 大魔法师)) this.仇恨 = 来源;
                    }
                    this.触发受击动画();
                    if (this.当前生命值 <= 0) {
                        if (来源 === "玩家") { //炸弹炸死不算数
                            已击杀怪物数++;
                            const 能量条 = document.querySelector(".power-bar");
                            const 当前能量 = parseFloat(能量条.style.width) || 100;
                            能量条.style.width = `${Math.min(100, 当前能量 + 7)}%`;
                            击杀提示.更新({ 内容: `已击杀怪物：${已击杀怪物数}` });
                            const 装备宠物列表 = [...玩家装备.values()].filter(装备 => 装备 instanceof 宠物);
                            装备宠物列表.forEach(宠物 => {
                                // 获得的经验与怪物基础生命值相关
                                const 经验值 = Math.floor(this.基础生命值 / 10);
                                宠物.获得经验(经验值);
                            });
                        }
                        if (来源 instanceof 宠物) {
                            const 经验值 = Math.floor(this.基础生命值 / 10);
                            来源.获得经验(经验值);
                        }
                        this.恢复背景类型();
                        this.血条元素?.remove();
                        所有怪物 = 所有怪物.filter((m) => m !== this);
                        if (当前天气效果.includes("诡魅") && !(this instanceof 幽灵怪物) && Math.random() < 0.3) {
                            const 新幽灵 = new 幽灵怪物({
                                x: this.x,
                                y: this.y,
                                房间ID: this.房间ID,
                                状态: 怪物状态.活跃,
                                强化: this.强化 // 幽灵继承强化状态
                            });
                            if (放置怪物到单元格(新幽灵, this.x, this.y)) {
                                添加日志(`一个${新幽灵.类型}从 ${this.类型} 的残骸中浮现！`, "警告");
                            }
                        } else if (Math.random() <= this.物品掉率 * 玩家属性.掉落倍率) {
                            if (this.掉落物.自定义数据.get("耐久")) this.掉落物.自定义数据.set("耐久", Math.floor(Math.min(this.掉落物.自定义数据.get("耐久"), this.掉落物.自定义数据.get("耐久") * 玩家属性.掉落倍率 * Math.random() * Math.random())))
                            放置物品到单元格(this.掉落物, this.x, this.y);
                        }
                        const 玩家单元格 = 地牢[玩家.y][玩家.x];
                        if (
                            玩家单元格.关联物品 &&
                            玩家单元格.类型 === 单元格类型.物品
                        ) {
                            if (尝试收集物品(玩家单元格.关联物品)) {
                                玩家单元格.类型 = null;
                                玩家单元格.关联物品 = null;
                            }
                        }
                        if (是否为教程层 && this.房间ID === 2) {
                            教程阶段 = 2.5; // 推进到2.5
                            教程提示已显示 = false;
                            setTimeout(() => {
                                显示教程提示();
                            }, 200);
                        }
                        //绘制应该由调用者处理
                        return;
                    }
                    this.绘制血条();
                }
            }
            绘制血条(隐藏血条 = false) {
                if (隐藏血条) {
                    if (this.血条元素) {
                        this.血条元素.style.display = "none";
                        return;
                    }
                }
                if (当前天气效果.includes('深夜') && !是否在光源范围内(this.x, this.y)) {
                    if (this.血条元素) {
                        this.血条元素.style.display = "none";
                        return;
                    }
                }
                const 画布Rect = canvas.getBoundingClientRect();
                const 小数偏移X = (当前相机X % 1) * 单元格大小;
                const 小数偏移Y = (当前相机Y % 1) * 单元格大小;
                const 屏幕X = (this.x - 视口偏移X) * 单元格大小 - 小数偏移X;
                const 屏幕Y = (this.y - 视口偏移Y) * 单元格大小 - 小数偏移Y;
                const 宽度 = 单元格大小;
                // 判断是否在屏幕可见区域
                const 在视口内 =
                    屏幕X + 单元格大小 > 0 &&
                    屏幕X + 单元格大小 < 画布Rect.width &&
                    屏幕Y + 单元格大小 > 0 &&
                    屏幕Y + 单元格大小 < 画布Rect.height;

                if (this.状态 === 怪物状态.活跃 && 在视口内) {
                    if (!this.血条元素) {
                        this.血条元素 = document.createElement("div");
                        this.血条元素.className = "怪物血条";
                        document.body.appendChild(this.血条元素);
                    }

                    this.血条元素.style.cssText = `
                                                                        left: ${屏幕X +
                        画布Rect.left
                        }px;
                                                                        top: ${屏幕Y -
                        12 +
                        画布Rect.top
                        }px;
                                                                        width: ${宽度}px;
                                                                        display: block;
                                                                    `;

                    const 血量百分比 = Math.max(
                        0,
                        this.当前生命值 / this.生命值 * 100
                    );
                    this.血条元素.innerHTML = `
                                                                        <div class="血条背景">
                                                                            <div class="当前血量" style="width:${血量百分比}%"></div>
                                                                        </div>
                                                                    `;
                } else {
                    if (this.血条元素) {
                        this.血条元素.style.display = "none";
                    }
                }
            }
            触发受击动画() {
                this.受击动画 = true;
                绘制();
                setTimeout(() => {
                    this.受击动画 = false;
                    绘制();
                }, 200);
            }
        }
        class 幽灵怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.幽灵仆从,
                    基础生命值: 15 + (配置.强化 ? 10 : 0),
                    基础攻击力: 4 + (配置.强化 ? 2 : 0),
                    移动率: 1.0,
                    掉落概率: 0.1, // 低概率掉落特殊物品
                    掉落物: new 灵能盾牌({}),
                    基础攻击范围: 1,
                    跟踪距离: 30,
                    受伤冻结回合: 1, // 正常受伤反应
                    ...配置, // 继承传入的 x, y, 房间ID, 强化等
                });
            }

            // --- 重写：检查移动可行性 (允许穿墙) ---
            检查移动可行性(fromX, fromY, toX, toY) {
                // 边界检查
                if (toX < 0 || toX >= 地牢大小 || toY < 0 || toY >= 地牢大小) return false;

                const 目标单元格 = 地牢[toY][toX];
                // 不能进入锁住的门或地图边界之外的“墙”（虽然边界检查已处理）
                if (目标单元格.背景类型 === 单元格类型.上锁的门) { // 假设幽灵不能穿上锁的门
                    return false;
                }
                // 不能移动到已有其他怪物的位置 (除非是其他幽灵？可以调整)
                if (目标单元格.关联怪物 && 目标单元格.关联怪物 !== this) {
                    return false;
                }

                return true; // 允许穿过普通墙壁和门
            }
            // --- 重写：规划移动路径 (允许穿墙) ---
            规划移动路径() {
                let 当前位置 = { x: this.x, y: this.y };
                let 有效位置 = null;
                let 可行距离 = this.移动距离 + 1;

                for (let i = 0; i < Math.min(this.目标路径.length, 可行距离); i++) {
                    const 节点 = this.目标路径[i];
                    const nextX = 节点.x;
                    const nextY = 节点.y;

                    // 使用幽灵的穿墙检查
                    if (this.检查移动可行性(当前位置.x, 当前位置.y, nextX, nextY)) {
                        if (this.位置合法(nextX, nextY)) { // 位置合法也需要考虑穿墙
                            有效位置 = { x: nextX, y: nextY };
                        }
                    } else {
                        // 如果路径被阻挡（例如撞到锁门或其他怪物），停止规划
                        this.目标路径 = this.目标路径.slice(i); // 更新剩余路径
                        return 当前位置; // 返回当前可达的最后位置
                    }

                    当前位置 = { x: nextX, y: nextY };

                    // 如果已找到有效位置且达到移动距离，返回该位置
                    if (有效位置 && i >= Math.min(this.移动距离, this.目标路径.length) - 1) {
                        this.目标路径 = this.目标路径.slice(i + 1); // 更新剩余路径
                        return 有效位置;
                    }
                }
                // 如果循环结束仍未返回，返回最后一个有效位置
                if (有效位置) this.目标路径 = []; // 路径走完
                return 有效位置;
            }
            // --- 重写：位置合法判断 (允许穿墙，但不能停在锁门里) ---
            位置合法(x, y) {
                const 单元格 = 地牢[y]?.[x];
                if (!单元格) return false;
                // 不能停在锁住的门里或墙里（虽然能穿过）
                if ([单元格类型.上锁的门].includes(单元格.背景类型)) return false;
                // 不能停在已有怪物（非自身）或阻碍性物品的位置
                if ((单元格.关联怪物 && 单元格.关联怪物 !== this) ||
                    (单元格.关联物品 && 单元格.关联物品.阻碍怪物)) {
                    return false;
                }
                // 允许停在房间、走廊、普通门，甚至墙壁内部（如果需要完全穿墙停留）
                // 如果不允许停在墙内，取消下一行的注释
                // if (单元格.背景类型 === 单元格类型.墙壁) return false;
                return true;
            }

            // --- 重写：计算路径 (允许穿墙) ---
            计算目标路径(目标X, 目标Y) {
                this.目标 = { x: 目标X, y: 目标Y };
                const 开放列表 = [];
                const 关闭列表 = new Set();
                const 方向映射表 = [ /* ... 方向定义不变 ... */
                    { dx: 1, dy: 0, }, { dx: -1, dy: 0, }, { dx: 0, dy: 1, }, { dx: 0, dy: -1, },
                ];

                const 起点节点 = { x: this.x, y: this.y, g: 0, parent: null };
                开放列表.push(起点节点);
                关闭列表.add(`${起点节点.x},${起点节点.y}`);

                while (开放列表.length > 0) {
                    let 当前节点 = 开放列表.shift();

                    if (当前节点.x === 目标X && 当前节点.y === 目标Y) {
                        const 路径 = [];
                        while (当前节点.parent) {
                            路径.push(当前节点);
                            当前节点 = 当前节点.parent;
                        }
                        return 路径.reverse();
                    }

                    方向映射表.forEach((方向) => {
                        const 新X = 当前节点.x + 方向.dx;
                        const 新Y = 当前节点.y + 方向.dy;
                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) return;

                        // 幽灵的移动检查：只检查目标格子是否为上锁的门
                        const 目标单元格 = 地牢[新Y][新X];
                        if (目标单元格.背景类型 === 单元格类型.上锁的门) return;

                        const 位置键 = `${新X},${新Y}`;
                        if (!关闭列表.has(位置键)) {
                            开放列表.push({ x: 新X, y: 新Y, g: 当前节点.g + 1, parent: 当前节点 });
                            关闭列表.add(位置键);
                        }
                    });
                }
                return null; // 找不到路径
            }

            // 计算路径 (用于移动，非目标路径)
            计算路径(目标X, 目标Y) {
                // 幽灵的寻路逻辑与计算目标路径相同，因为它可以穿墙
                return this.计算目标路径(目标X, 目标Y);
            }
        }
        class 大魔法师 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.大魔法师,
                    类型: "大魔法师",
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.活跃,
                    基础生命值: 配置.基础生命值 || 55,
                    基础攻击力: 配置.基础攻击力 || 8,
                    强化: 配置.强化 || false,
                    移动率: 配置.移动率 || 0.8,
                    基础攻击范围: 4,
                    跟踪距离: 20,
                    攻击冷却: 1,
                    受伤冻结回合: 1,
                    掉落物: new 真言卷轴({ 品质: 4, 已解锁: true, 强化: true }),
                    掉落概率: 1,
                    ...配置,
                });
                this.当前生命值 = 配置.当前生命值 || this.生命值
                this.技能冷却 = {
                    隐身术: 0,
                    分身术: 0,
                    火球术: 0,
                    冰冻术: 0,
                    传送术: 0,
                    召唤术: 0,
                };
                this.每回合恢复量 = 2;
                this.隐身中 = false;
                this.逃离目标 = null;
                this.原始移动距离 = this.基础移动距离;
                this.isClone = false
                this.隐身提示间隔 = 2;
                this.隐身提示计数 = 0;
            }

            尝试移动() {
                if (this.隐身中) {
                    this.隐身移动();
                    return;
                }

                if (this.当前生命值 <= 0) return;
                super.尝试移动();

                this.绘制血条();
            }

            选择逃离目标() {
                const 最大距离 = this.跟踪距离; // 最大逃离距离
                const 可达点 = [];

                const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0 }];
                const 已访问 = new Set([`${this.x},${this.y}`]);
                const 已在房间中 = 房间地图[this.y][this.x] !== -1;
                const 已在房间 = 房间地图[this.y][this.x];

                while (队列.length > 0) {
                    const 当前 = 队列.shift();

                    const 房间ID = 房间地图[当前.y][当前.x];
                    if (已访问房间.has(房间ID)) {
                        if (!已在房间中) {
                            可达点.push({ x: 当前.x, y: 当前.y, 距离: 当前.距离 }); // 记录距离
                        } else {
                            if (房间ID === 已在房间) 可达点.push({ x: 当前.x, y: 当前.y, 距离: 当前.距离 });
                        }
                    }


                    if (当前.距离 > 最大距离) continue;

                    const 方向 = [
                        { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                        { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                        { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                        { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
                    ];

                    for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;
                        const 位置键 = `${新X},${新Y}`;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;
                        const 当前单元格 = 地牢[当前.y][当前.x];
                        const 目标单元格 = 地牢[新Y][新X];
                        if (当前单元格.墙壁[当前墙] || 目标单元格.墙壁[目标墙]) continue;
                        if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.背景类型)) continue;


                        if (!已访问.has(位置键) && this.位置合法(新X, 新Y)) {
                            已访问.add(位置键);
                            队列.push({ x: 新X, y: 新Y, 距离: 当前.距离 + 1 });
                        }
                    }
                }

                let 最远点 = null;
                let 最大自身距离 = -1;


                for (const 点 of 可达点) {

                    if (点.距离 > 最大自身距离) {
                        最大自身距离 = 点.距离;
                        最远点 = 点;
                    }
                }

                return 最远点;
            }

            隐身移动() {
                if (this.当前生命值 < this.生命值) {
                    this.当前生命值 = Math.min(this.生命值, this.当前生命值 + this.每回合恢复量);
                    this.绘制血条();
                } else {
                    this.隐身中 = false;
                    this.基础移动距离 = this.原始移动距离;
                    添加日志(`${this.类型} 现形了!`, "信息");
                    显示通知("使用分身迷惑你后，隐身的大魔法师缓缓现出真身...")
                    this.绘制血条();
                    return;
                }
                if (
                    this.目标路径.length === 0 ||
                    Math.random() > this.移动率 ||
                    this.跟踪距离 < this.目标路径.length
                ) {
                    this.追击玩家中 = false;
                    return;
                }
                if (!this.逃离目标) {
                    this.逃离目标 = this.选择逃离目标();
                }
                this.目标路径 = this.计算目标路径(this.逃离目标.x, this.逃离目标.y);
                if (this.目标路径) {
                    const 下一步 = this.目标路径[Math.min(this.移动距离 - 1, this.目标路径.length - 1)]
                    const 最终位置 = this.规划移动路径();
                    if (!最终位置 || (this.y === this.逃离目标.y && this.x === this.逃离目标.x)) {

                        this.逃离目标 = null;
                        return;
                    }
                    this.恢复背景类型();
                    this.保存新位置类型(最终位置.x, 最终位置.y);
                    this.x = 最终位置.x;
                    this.y = 最终位置.y;
                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
                    地牢[this.y][this.x].关联怪物 = this;
                } else {
                    this.逃离目标 = null;
                }

                this.绘制血条();
                this.隐身提示计数++;
                if (this.隐身提示计数 >= this.隐身提示间隔) {
                    this.隐身提示计数 = 0;

                    const 画布Rect = canvas.getBoundingClientRect();
                    let 屏幕X = (this.x - 相机目标X) * 单元格大小;
                    let 屏幕Y = (this.y - 相机目标Y) * 单元格大小;
                    if (屏幕X + 单元格大小 < 0 || 屏幕X > 画布Rect.width || 屏幕Y + 单元格大小 < 0 || 屏幕Y > 画布Rect.height) {
                        return;
                    }
                    计划显示格子特效([{ x: this.x, y: this.y }], "000000");
                }
            }

            尝试攻击() {
                if (怪物状态表.get(this)?.类型 === "冻结") return;

                if (this.攻击冷却回合剩余 > 0) {
                    this.攻击冷却回合剩余 -= 1;
                    return false;
                }
                if (this.通向目标路径.length > this.攻击范围) return false;
                if (!this.isClone) {
                    if (this.当前生命值 < this.生命值 * 0.3 && !this.隐身中) {
                        this.隐身术();
                        this.分身术();
                        添加日志(`${this.类型} 负伤逃跑了!`, "信息");

                        return true;
                    } else if (this.隐身中) {
                        return true;
                    }
                }


                if (Math.random() < 0.5) {
                    const 技能列表 = ["火球术", "冰冻术", "传送术", "召唤术"];
                    const 随机技能 = 技能列表[Math.floor(Math.random() * 技能列表.length)];

                    switch (随机技能) {
                        case "火球术":
                            if (!this.火球术()) {
                                this.普通攻击();
                                this.攻击冷却回合剩余 = this.攻击冷却;
                            }
                            break;
                        case "冰冻术":
                            if (!this.冰冻术()) {
                                this.普通攻击();
                                this.攻击冷却回合剩余 = this.攻击冷却;
                            }
                            break;
                        case "传送术":
                            this.传送术();
                            break;
                        case "召唤术":
                            if (!this.召唤术()) {
                                this.普通攻击();
                                this.攻击冷却回合剩余 = this.攻击冷却;
                            }
                            break;
                    }
                    return true;
                } else {
                    this.普通攻击();
                    this.攻击冷却回合剩余 = this.攻击冷却
                    return true;
                }
            }
            普通攻击() {
                const 攻击模式 = Math.floor(Math.random() * 4);
                let 方向列表 = [];

                switch (攻击模式) {
                    case 0:
                        方向列表 = [
                            { dx: 0, dy: -1 },
                            { dx: 0, dy: 1 },
                            { dx: -1, dy: 0 },
                            { dx: 1, dy: 0 },
                        ];
                        break;
                    case 1:
                        方向列表 = [
                            { dx: -1, dy: -1 },
                            { dx: 1, dy: -1 },
                            { dx: -1, dy: 1 },
                            { dx: 1, dy: 1 },
                        ];
                        break;
                    case 2:
                    case 3:
                        const 基本方向 = [
                            { dx: 0, dy: -1 },
                            { dx: 1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: -1, dy: 0 },
                        ];

                        const 顺时针方向变化 = [
                            { dx: 1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: -1, dy: 0 },
                            { dx: 0, dy: -1 },
                        ];

                        const 逆时针方向变化 = [
                            { dx: 0, dy: -1 },
                            { dx: -1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: 1, dy: 0 },
                        ];

                        基本方向.forEach(起始方向 => {
                            let 当前方向 = 起始方向;
                            let 当前X = this.x;
                            let 当前Y = this.y;
                            let 路径 = [];

                            let 层数 = 0;
                            while (Math.abs(当前X - this.x) + Math.abs(当前Y - this.y) <= this.攻击范围) {
                                层数++;
                                let 步数 = 层数 * 2 - 1;

                                if (层数 > 1) {

                                    const 方向变化 = 攻击模式 === 2 ? 顺时针方向变化 : 逆时针方向变化;
                                    let 方向索引 = 方向变化.findIndex(d => d.dx === 当前方向.dx && d.dy === 当前方向.dy);


                                    方向索引 = (方向索引 + 1) % 4;
                                    当前方向 = 方向变化[方向索引];


                                    当前X += 当前方向.dx;
                                    当前Y += 当前方向.dy;
                                    if (!检查移动可行性(当前X - 当前方向.dx, 当前Y - 当前方向.dy, 当前X, 当前Y)) break;

                                    const 单元格 = 地牢[当前Y]?.[当前X];
                                    if (单元格?.关联怪物 && 单元格.类型 === 单元格类型.怪物 && 单元格.关联怪物?.状态 === 怪物状态.活跃 && !(单元格.关联怪物 instanceof 大魔法师)) {
                                        单元格.关联怪物.受伤(this.攻击力, this);

                                    } else if (当前X === 玩家.x && 当前Y === 玩家.y) {
                                        伤害玩家(this.攻击力, this);
                                    }

                                    路径.push({ x: 当前X, y: 当前Y });
                                    步数--;

                                }



                                for (let i = 0; i < 步数; i++) {
                                    当前X += 当前方向.dx;
                                    当前Y += 当前方向.dy;

                                    if (!检查移动可行性(当前X - 当前方向.dx, 当前Y - 当前方向.dy, 当前X, 当前Y)) break;

                                    const 单元格 = 地牢[当前Y]?.[当前X];

                                    if (单元格?.关联怪物 && 单元格.类型 === 单元格类型.怪物 && 单元格.关联怪物?.状态 === 怪物状态.活跃) {
                                        单元格.关联怪物.受伤(this.攻击力, this);
                                    } else if (当前X === 玩家.x && 当前Y === 玩家.y) {
                                        伤害玩家(this.攻击力, this);
                                    }
                                    路径.push({ x: 当前X, y: 当前Y });

                                }
                                if (Math.abs(当前X - this.x) + Math.abs(当前Y - this.y) > this.攻击范围) break;
                            }

                            计划显示格子特效(路径);
                        });
                        return;
                }

                方向列表.forEach(方向 => {
                    let 当前X = this.x + 方向.dx;
                    let 当前Y = this.y + 方向.dy;
                    let 路径 = [];

                    while (Math.abs(当前X - this.x) + Math.abs(当前Y - this.y) <= this.攻击范围) {
                        if (!检查移动可行性(当前X - 方向.dx, 当前Y - 方向.dy, 当前X, 当前Y)) break;

                        const 单元格 = 地牢[当前Y]?.[当前X];


                        if (单元格?.关联怪物 && 单元格.类型 === 单元格类型.怪物 && 单元格.关联怪物?.状态 === 怪物状态.活跃) {
                            单元格.关联怪物.受伤(this.攻击力, this);
                            break;
                        }

                        else if (当前X === 玩家.x && 当前Y === 玩家.y) {
                            伤害玩家(this.攻击力, this);
                            break;
                        }

                        路径.push({ x: 当前X, y: 当前Y });
                        当前X += 方向.dx;
                        当前Y += 方向.dy;
                    }
                    计划显示格子特效(路径);
                });
            }

            召唤术() {
                if (this.技能冷却.召唤术 > 0) return false;
                const 方向 = [
                    { dx: -1, dy: -1 },
                    { dx: 1, dy: -1 },
                    { dx: -1, dy: 1 },
                    { dx: 1, dy: 1 },
                ];
                let 召唤位置 = null;
                for (const { dx, dy } of 方向) {
                    const x = this.x + dx;
                    const y = this.y + dy;
                    if (this.位置合法(x, y) && !地牢[y][x].关联怪物 && !地牢[y][x].关联物品) {
                        召唤位置 = { x, y };
                        break;
                    }
                }
                if (!召唤位置) {
                    添加日志(`${this.类型} 尝试召唤，但周围没有可用空间！`, "信息");
                    return false;
                }
                const 追踪数 = 跟踪玩家怪物数;
                let 召唤数量 = 2;
                if (追踪数 >= 5) {
                    return false;
                } else if (追踪数 >= 3) {
                    召唤数量 = 1;
                }
                const 可召唤怪物 = [];
                for (let 房间类型 in 怪物池) {
                    怪物池[房间类型].forEach(怪物配置 => {
                        if (怪物配置.类 !== 大魔法师) {
                            可召唤怪物.push(怪物配置);
                        }
                    });
                }
                for (let i = 0; i < 召唤数量; i++) {
                    const 总权重 = 可召唤怪物.reduce((sum, m) => sum + m.权重, 0);
                    let 随机值 = Math.random() * 总权重;
                    let 选中配置 = null;

                    for (const m of 可召唤怪物) {
                        if (随机值 <= m.权重) {
                            选中配置 = m;
                            break;
                        }
                        随机值 -= m.权重;
                    }
                    const 新怪物 = new 选中配置.类({
                        x: 召唤位置.x,
                        y: 召唤位置.y,
                        房间ID: 房间地图[召唤位置.y][召唤位置.x],
                        状态: 怪物状态.活跃,
                    });
                    放置怪物到单元格(新怪物, 召唤位置.x, 召唤位置.y);
                    新怪物.处理地形效果()

                    计划显示格子特效([{ x: 召唤位置.x, y: 召唤位置.y }], "800080");
                    for (const { dx, dy } of 方向) {
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (this.位置合法(x, y) && !地牢[y][x].关联怪物 && !地牢[y][x].关联物品) {
                            召唤位置 = { x, y };
                            break;
                        }
                    }
                }
                显示通知(`${this.类型} 使用了召唤术！`, "信息");
                this.技能冷却.召唤术 = 8;
                return true;
            }

            隐身术() {
                if (this.隐身中) return;

                this.逃离目标 = this.选择逃离目标();
                this.隐身中 = true;
                this.基础移动距离 = 2;
                this.绘制血条(true);
                添加日志(`${this.类型} 使用了隐身术!`, "信息");
            }


            分身术() {
                if (this.技能冷却.分身术 > 0 || this.分身?.当前生命值 > 0 || this.isClone) return;
                if (this.分身?.当前生命值 > 0) {
                    this.分身.恢复背景类型();
                    this.分身.血条元素.remove();
                    所有怪物 = 所有怪物.filter((m) => m !== this.分身);
                }
                let x = this.x;
                let y = this.y;
                const 分身 = new 大魔法师({
                    x: x,
                    y: y,
                    当前生命值: this.当前生命值,
                    房间ID: this.房间ID,
                });
                this.分身 = 分身;
                分身.isClone = true;
                let 放置 = 怪物放置物品(分身, x, y);
                if (放置.x === null) {
                    this.分身.当前生命值 = 0;
                }
                this.尝试移动();
                添加日志(`${this.类型} 使用了分身术!`, "信息");
                this.技能冷却.分身术 = 10;
            }

            火球术() {
                if (this.技能冷却.火球术 > 0) return false;

                const 最大距离 = 8;
                const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;


                if (玩家距离 > 0 && 玩家距离 <= 最大距离) {

                    const 攻击路径 = this.计算目标路径(玩家.x, 玩家.y);
                    if (攻击路径) {
                        计划显示格子特效(攻击路径);

                        const 扔出炸弹 = new 炸弹({ 能否拾起: false, 颜色索引: 4 });
                        let 目标 = {};
                        目标 = 玩家放置物品(扔出炸弹);
                        if (目标.x !== null || 目标.y !== null) {
                            扔出炸弹.使用(false, 目标.x, 目标.y);
                        }
                        添加日志(`${this.类型} 使用了火球术!`, "信息");
                        this.技能冷却.火球术 = 4;
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }

            冰冻术() {
                if (this.技能冷却.冰冻术 > 0) return false;
                const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;
                const 范围 = 2;
                if (玩家距离 > 范围) return false;
                for (let dx = -范围; dx <= 范围; dx++) {
                    for (let dy = -范围; dy <= 范围; dy++) {
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
                            const 单元格 = 地牢[y][x];

                            if (单元格.关联怪物 && 单元格.关联怪物.类型 !== "冰冻怪物" && 单元格.关联怪物.类型 !== "大魔法师") {
                                new 状态效果("冻结", "#2196F3", "冻", 3, null, null, 单元格.关联怪物);
                            }
                            if (x === 玩家.x && y === 玩家.y && ![...玩家装备.values()].some((item) => item.名称 === '冰盾')) {
                                伤害玩家(this.攻击力, this);
                                new 状态效果("冻结", "#2196F3", 图标映射.冰冻怪物, 3, 3);
                            }
                            if (单元格.关联物品 instanceof 炸弹) {
                                if (!单元格.关联物品.能否拾起) {
                                    单元格.关联物品.自定义数据.set("倒计时", 单元格.关联物品.自定义数据.get("爆炸时间"));
                                    单元格.关联物品.能否拾起 = true;
                                    所有计时器 = 所有计时器.filter((item) => item !== 单元格.关联物品);
                                    单元格.关联物品.x = null;
                                    单元格.关联物品.y = null;
                                    添加日志("炸弹已被熄灭！", "信息");
                                    绘制();
                                }
                            }
                        }
                        if (单元格.关联怪物?.类型 !== "大魔法师") {
                            计划显示格子特效([{ x: x, y: y }], "0000DD");
                        }

                    }
                }
                添加日志(`${this.类型} 使用了冰冻术!`, "信息");
                this.技能冷却.冰冻术 = 6;
                return true;
            }
            传送术() {
                if (this.技能冷却.传送术 > 0) return;

                const 最小距离 = 5;
                const 最大距离 = 10;


                const 可达点 = [];
                const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
                const 已访问 = new Set([`${this.x},${this.y} `]);

                const 方向 = [
                    { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                    { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                    { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                    { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
                ];

                while (队列.length > 0) {
                    const 当前 = 队列.shift();


                    if (当前.距离 >= 最小距离 && 当前.距离 <= 最大距离 && 已访问房间.has(房间地图[当前.y][当前.x])) {
                        可达点.push({ x: 当前.x, y: 当前.y });
                    }

                    if (当前.距离 > 最大距离) continue;


                    for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;
                        const 位置键 = `${新X},${新Y} `;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;
                        const 当前单元格 = 地牢[当前.y][当前.x];
                        const 目标单元格 = 地牢[新Y][新X];
                        if (当前单元格.墙壁[当前墙] || 目标单元格.墙壁[目标墙]) continue;
                        if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.背景类型)) continue;


                        if (!已访问.has(位置键) && this.位置合法(新X, 新Y)) {
                            已访问.add(位置键);
                            队列.push({ x: 新X, y: 新Y, 距离: 当前.距离 + 1 });
                        }
                    }
                }


                if (可达点.length > 0) {
                    const 目标点 = 可达点[Math.floor(Math.random() * 可达点.length)];
                    this.恢复背景类型();
                    this.保存新位置类型(目标点.x, 目标点.y);
                    this.x = 目标点.x;
                    this.y = 目标点.y;
                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
                    地牢[this.y][this.x].关联怪物 = this;
                    添加日志(`${this.类型} 使用了传送术!`, "信息");
                    this.技能冷却.传送术 = 7;
                    this.处理地形效果();
                    绘制();
                }
            }
            受伤(伤害, 来源 = null) {
                if (this.当前生命值 > 0) {
                    this.当前生命值 -= 伤害;
                    if (!(来源 instanceof 怪物)) {
                        this.受伤冻结回合剩余 = this.受伤冻结回合;
                    }
                    this.触发受击动画();

                    if (this.当前生命值 <= 0) {
                        if (来源 === "玩家") {
                            已击杀怪物数++;
                            const 能量条 = document.querySelector(".power-bar");
                            const 当前能量 = parseFloat(能量条.style.width) || 100;
                            能量条.style.width = `${Math.min(100, 当前能量 + 7)}%`;
                            击杀提示.更新({ 内容: `已击杀怪物：${已击杀怪物数} ` });
                            const 装备宠物列表 = [...玩家装备.values()].filter(装备 => 装备 instanceof 宠物);
                            装备宠物列表.forEach(宠物 => {

                                const 经验值 = Math.floor(this.基础生命值 / 10);
                                宠物.获得经验(经验值);
                            });
                        }
                        if (来源 instanceof 宠物) {
                            const 经验值 = Math.floor(this.基础生命值 / 10);
                            来源.获得经验(经验值);
                        }

                        this.恢复背景类型();
                        this.血条元素.remove();
                        所有怪物 = 所有怪物.filter((m) => m !== this);


                        if (this.isClone !== true && Math.random() <= this.物品掉率 * 玩家属性.掉落倍率) {
                            if (this.掉落物.自定义数据.get("耐久")) this.掉落物.自定义数据.set("耐久", Math.floor(Math.min(this.掉落物.自定义数据.get("耐久"), this.掉落物.自定义数据.get("耐久") * 玩家属性.掉落倍率 * Math.random() * Math.random())))
                            if (房间列表[房间地图[this.y][this.x]]) {
                                放置物品到单元格(this.掉落物, this.x, this.y);
                                生成奖励(房间列表[房间地图[this.y][this.x]]);
                                显示通知("大魔法师被彻底抹除了...")
                            }

                        }

                        const 玩家单元格 = 地牢[玩家.y][玩家.x];
                        if (
                            玩家单元格.关联物品 &&
                            玩家单元格.类型 === 单元格类型.物品
                        ) {
                            if (尝试收集物品(玩家单元格.关联物品)) {
                                玩家单元格.类型 = null;
                                玩家单元格.关联物品 = null;
                            }
                        }
                        return;
                    }
                    this.绘制血条();
                }
            }

            更新技能冷却() {
                for (const 技能 in this.技能冷却) {
                    if (this.技能冷却[技能] > 0) {
                        this.技能冷却[技能]--;
                    }
                }
            }
            绘制血条(隐藏血条 = false) {
                if (this.隐身中) {
                    this.血条元素.style.display = "none";
                    return;
                }
                super.绘制血条(隐藏血条);
            }

        }
        class 腐蚀怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.腐蚀怪物,
                    类型: "腐蚀怪物",
                    基础生命值: 35 + (配置.强化 ? 15 : 0),
                    基础攻击力: 4 + (配置.强化 ? 2 : 0),
                    移动率: 0.6,
                    掉落物: new 重铸台({ 耐久: 1 }),
                    掉落概率: 0.1,
                    攻击冷却: 1,
                    ...配置,
                });
                this.腐蚀强度 = 1 + (配置.强化 ? 1 : 0);
                this.腐蚀持续 = 4 + (配置.强化 ? 2 : 0);
            }

            尝试攻击() {
                if (super.尝试攻击()) {
                    if (怪物状态表.get(this)?.类型 === "魅惑") {

                    } else {

                        new 状态效果("腐蚀", "#8FBC8F", "☠️", this.腐蚀持续, null, this, null, this.腐蚀强度);
                        添加日志("你的装备被腐蚀了！", "错误");
                    }
                    return true;
                }
                return false;
            }

            应用效果() {

                const 腐蚀量 = 1 + Math.floor(this.腐蚀强度 / 2);
                let 实际腐蚀 = false;
                [...玩家装备.values()].forEach(装备 => {
                    if (装备.自定义数据?.has('耐久') && !装备.自定义数据.get('不可破坏')) {
                        const 原耐久 = 装备.自定义数据.get('耐久');
                        装备.自定义数据.set('耐久', Math.max(0, 原耐久 - 腐蚀量));
                        if (原耐久 > 0 && 装备.自定义数据.get('耐久') === 0) {
                            添加日志(`${装备.名称} 被腐蚀损坏了！`, "错误");
                            处理销毁物品(装备.唯一标识, true);
                            实际腐蚀 = true;
                        } else if (装备.自定义数据.get('耐久') < 原耐久) {
                            添加日志(`${装备.名称} 被腐蚀了！损失 ${腐蚀量} 点耐久。`, "错误");
                            实际腐蚀 = true;
                        }
                    }
                });
                if (实际腐蚀) {
                    更新装备显示();
                }
            }
            移除效果() {
                return true;
            }
        }
        class 盗贼怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.盗贼怪物,
                    类型: "盗贼怪物",
                    基础生命值: 25 + (配置.强化 ? 10 : 0),
                    基础攻击力: 4 + (配置.强化 ? 1 : 0),
                    移动率: 0.9,
                    基础移动距离: 2,
                    掉落物: new 金币({ 数量: 1 }),
                    掉落概率: 0.3,
                    跟踪距离: 20,
                    ...配置,
                });
                this.偷窃几率 = 0.5 + (配置.强化 ? 0.2 : 0);
                this.偷窃武器几率 = 0.15 + (配置.强化 ? 0.1 : 0);
                this.偷到的金币 = 0;
                this.偷到的武器列表 = [];
            }

            尝试攻击() {

                if (怪物状态表.get(this)?.类型 === "魅惑") {
                    return super.尝试攻击();
                }


                const 攻击成功 = super.尝试攻击();
                if (攻击成功) {

                    if (Math.random() < this.偷窃几率) {
                        const 玩家金币 = [...玩家背包.values()]
                            .filter(i => i instanceof 金币)
                            .reduce((sum, i) => sum + i.堆叠数量, 0);
                        if (玩家金币 > 0) {
                            const 偷窃数量 = Math.min(玩家金币, Math.floor(Math.random() * (5 + this.攻击力)) + 1);
                            if (扣除金币(偷窃数量)) {
                                this.偷到的金币 += 偷窃数量;
                                显示通知(`${this.类型} 偷走了你的 ${偷窃数量} 金币！`, "错误");
                                添加日志(`${this.类型} 偷走了 ${偷窃数量} 金币！`, "错误");
                            }
                        }
                    }

                    if (Math.random() < this.偷窃武器几率) {
                        const 玩家装备武器 = [...玩家装备.values()].filter(item => item instanceof 武器类);

                        if (玩家装备武器.length > 1) {

                            const 目标武器索引 = Math.floor(Math.random() * 玩家装备武器.length);
                            const 被偷武器 = 玩家装备武器[目标武器索引];


                            玩家装备.delete(被偷武器.装备槽位);
                            被偷武器.已装备 = false;
                            const 原槽位 = 被偷武器.装备槽位;
                            被偷武器.装备槽位 = null;


                            this.偷到的武器列表.push(被偷武器);
                            玩家背包.delete(被偷武器.唯一标识);
                            被偷武器.已装备 = false;
                            被偷武器.装备槽位 = null;

                            显示通知(`${this.类型} 偷走了你的 ${被偷武器.获取名称()}！`, "错误");
                            添加日志(`${this.类型} 偷走了 ${被偷武器.获取名称()}！`, "错误");


                            更新装备显示();
                            更新背包显示();
                        }
                    }
                }
                return 攻击成功;
            }

            受伤(伤害, 来源 = null) {
                const 原始血量 = this.当前生命值;
                super.受伤(伤害, 来源);


                if (原始血量 > 0 && this.当前生命值 <= 0) {
                    let 掉落成功 = false;

                    if (this.偷到的金币 > 0) {
                        const 掉落金币 = new 金币({ 数量: this.偷到的金币 });
                        if (放置物品到单元格(掉落金币, this.x, this.y)) {
                            添加日志(`${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`, "成功");
                            掉落成功 = true;
                        } else {
                            let 方向 = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                            for (const [dx, dy] of 方向) {
                                if (放置物品到单元格(掉落金币, this.x + dx, this.y + dy)) {
                                    添加日志(`${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`, "成功");
                                    掉落成功 = true;
                                    break;
                                }
                            }
                            if (!掉落成功) {
                                方向 = [[1, -1], [1, 1], [-1, -1], [1, -1]];
                                for (const [dx, dy] of 方向) {
                                    if (放置物品到单元格(掉落金币, this.x + dx, this.y + dy)) {
                                        添加日志(`${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`, "成功");
                                        掉落成功 = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (!掉落成功) 添加日志(`${this.类型} 死亡，但未能掉落金币（周围无空间）`, "警告");
                    }


                    this.偷到的武器列表.forEach(武器 => {
                        掉落成功 = false;
                        if (放置物品到单元格(武器, this.x, this.y)) {
                            添加日志(`${this.类型} 死亡，掉落了 ${武器.获取名称()}！`, "成功");
                            掉落成功 = true;
                        } else {
                            let 方向 = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                            for (const [dx, dy] of 方向) {
                                if (放置物品到单元格(武器, this.x + dx, this.y + dy)) {
                                    添加日志(`${this.类型} 死亡，掉落了 ${武器.获取名称()}！`, "成功");
                                    掉落成功 = true;
                                    break;
                                }
                            }
                            if (!掉落成功) {
                                方向 = [[1, -1], [1, 1], [-1, -1], [1, -1]];
                                for (const [dx, dy] of 方向) {
                                    if (放置物品到单元格(掉落金币, this.x + dx, this.y + dy)) {
                                        添加日志(`${this.类型} 死亡，掉落了 ${this.偷到的金币} 金币！`, "成功");
                                        掉落成功 = true;
                                        break;
                                    }
                                }
                            }
                        }
                        if (!掉落成功) {
                            添加日志(`${this.类型} 死亡，但未能掉落 ${武器.获取名称()}（周围无空间）`, "警告");

                            if (尝试收集物品(武器, true)) {
                                添加日志(`${武器.获取名称()} 已返回你的背包！`, "成功");
                            } else {
                                添加日志(`背包已满，无法返还 ${武器.获取名称()}！`, "错误");

                            }
                        }
                    });
                    this.偷到的武器列表 = [];
                    更新背包显示();
                }
            }
        }
        class 吸能怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.吸能怪物,
                    类型: "吸能怪物",
                    基础生命值: 28 + (配置.强化 ? 12 : 0),
                    基础攻击力: 4 + (配置.强化 ? 2 : 0),
                    移动率: 0.7,
                    掉落物: new 能量药水({ 数量: 1 }),
                    掉落概率: 0.4,
                    基础攻击范围: 1,
                    ...配置,
                });
                this.吸能比例 = 0.3 + (配置.强化 ? 0.15 : 0);
                this.最小吸能 = 5 + (配置.强化 ? 10 : 0);
            }

            尝试攻击() {

                if (怪物状态表.get(this)?.类型 === "魅惑") {
                    return super.尝试攻击();
                }

                const 攻击成功 = super.尝试攻击();
                if (攻击成功) {
                    const 造成伤害 = this.攻击力;
                    const 吸取量 = Math.max(this.最小吸能, Math.ceil(造成伤害 * this.吸能比例));
                    if (卷轴扣除能量(吸取量)) {
                        const 能量条 = document.querySelector(".power-bar");
                        const 当前能量 = parseFloat(能量条.style.width) || 0;
                        添加日志(`${this.类型} 吸取了你 ${吸取量.toFixed(0)} 点能量！`, "错误");
                        触发HUD显示();
                    }
                }
                return 攻击成功;
            }
        }

        class 剧毒云雾怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.剧毒云雾怪物,
                    类型: "剧毒云雾怪物",
                    基础生命值: 25 + (配置.强化 ? 15 : 0),
                    基础攻击力: 5 + (配置.强化 ? 2 : 0),
                    移动率: 0.6,
                    掉落物: new 治疗药水({ 数量: 1 }),
                    掉落概率: 0.3,
                    基础攻击范围: 1,
                    ...配置,
                });
                this.毒云范围 = 1 + (配置.强化 ? 1 : 0);
                this.毒云持续 = 3 + (配置.强化 ? 1 : 0);
                this.毒云强度 = 2 + (配置.强化 ? 1 : 0);
            }

            受伤(伤害, 来源 = null) {
                const 原始血量 = this.当前生命值;
                super.受伤(伤害, 来源);


                if (原始血量 > 0 && this.当前生命值 <= 0) {
                    this.释放毒云();
                }
            }

            释放毒云() {
                添加日志(`${this.类型} 死亡时释放了剧毒云雾！`, "警告");
                const 范围 = this.毒云范围;
                const 中心X = this.x;
                const 中心Y = this.y;

                for (let dx = -范围; dx <= 范围; dx++) {
                    for (let dy = -范围; dy <= 范围; dy++) {


                        const x = 中心X + dx;
                        const y = 中心Y + dy;

                        if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
                            const 单元格 = 地牢[y][x];

                            if (单元格.背景类型 !== 单元格类型.墙壁 && 单元格.背景类型 !== 单元格类型.上锁的门) {

                                if (玩家.x === x && 玩家.y === y) {
                                    new 状态效果("中毒", "#008000", "☠️", this.毒云持续, null, null, null, this.毒云强度);
                                    添加日志("你吸入了剧毒云雾！", "错误");
                                }

                                if (单元格.关联怪物 && 单元格.关联怪物 !== this && 怪物状态表.get(单元格.关联怪物)?.类型 !== '魅惑') {
                                    new 状态效果("中毒", "#008000", "☠️", this.毒云持续, null, null, 单元格.关联怪物, this.毒云强度);
                                    添加日志(`${单元格.关联怪物.类型} 吸入了剧毒云雾！`, "信息");
                                }

                                [...玩家装备.values()].forEach(装备 => {
                                    if (装备 instanceof 宠物 && 装备.x === x && 装备.y === y && !装备.自定义数据.get("休眠中")) {


                                        装备.受伤(this.毒云强度);
                                        添加日志(`${装备.名称} 吸入了剧毒云雾！`, "错误");
                                    }
                                });


                                计划显示格子特效([{ x: x, y: y }], "90EE90", 150);
                            }
                        }
                    }
                }
            }
        }
        class 召唤师怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.召唤师怪物,
                    类型: "召唤师怪物",
                    基础生命值: 30 + (配置.强化 ? 15 : 0),
                    基础攻击力: 3 + (配置.强化 ? 1 : 0),
                    移动率: 0.7,
                    掉落物: new 能量药水({ 数量: 1 }),
                    掉落概率: 0.3,
                    基础攻击范围: 4,
                    跟踪距离: 15,
                    ...配置,
                });
                this.召唤冷却 = 3 + (配置.强化 ? -1 : 0);
                this.召唤冷却剩余 = Math.floor(Math.random() * this.召唤冷却);
                this.最大召唤物数量 = 2 + (配置.强化 ? 1 : 0);
                this.当前召唤物列表 = [];
                this.召唤物类 = 幽灵仆从;
            }

            尝试移动() {
                const 我的状态 = 怪物状态表.get(this);
                if (我的状态?.类型 === "冻结") return;

                if (this.当前生命值 <= 0) return;


                this.当前召唤物列表 = this.当前召唤物列表.filter(仆从 => 仆从 && 仆从.当前生命值 > 0);


                if (this.受伤冻结回合剩余 > 0) {
                    this.受伤冻结回合剩余--;
                    this.绘制血条();
                    return;
                }

                if (this.召唤冷却剩余 > 0) {
                    this.召唤冷却剩余--;
                }


                if (我的状态?.类型 === "魅惑") {
                    const 目标 = this.寻找最近怪物目标();
                    if (目标) {
                        const 逃离点 = this.选择逃离目标(目标.x, 目标.y, 5);
                        if (逃离点) {
                            this.目标路径 = this.计算路径(逃离点.x, 逃离点.y);
                            if (this.目标路径) super.尝试移动();
                        }
                    }
                    this.绘制血条();
                    return;
                }


                if (this.召唤冷却剩余 <= 0 && this.当前召唤物列表.length < this.最大召唤物数量) {
                    if (this.尝试召唤()) {
                        this.召唤冷却剩余 = this.召唤冷却;

                        this.绘制血条();
                        return;
                    }
                }


                const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
                if (玩家距离 < this.基础攻击范围 - 1 && 玩家距离 > 0) {
                    const 逃离点 = this.选择逃离目标(玩家.x, 玩家.y, 5);
                    if (逃离点) {
                        this.目标路径 = this.计算路径(逃离点.x, 逃离点.y);
                        if (this.目标路径) super.尝试移动();
                        else { /* 无法逃离则不动 */ }
                    } else { /* 无法选择逃离点则不动 */ }
                } else {


                    if (Math.random() < 0.2) {
                        const 方向 = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                        const [dx, dy] = 方向[Math.floor(Math.random() * 4)];
                        const 新X = this.x + dx;
                        const 新Y = this.y + dy;
                        if (检查移动可行性(this.x, this.y, 新X, 新Y) && 位置是否可用(新X, 新Y, false)) {
                            this.恢复背景类型();
                            this.保存新位置类型(新X, 新Y);
                            this.x = 新X; this.y = 新Y;
                            地牢[新Y][新X].类型 = 单元格类型.怪物;
                            地牢[新Y][新X].关联怪物 = this;
                        }
                    }
                }
                this.绘制血条();
            }


            选择逃离目标(目标X, 目标Y, 范围) {
                const 可达点 = [];
                const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
                const 已访问 = new Set([`${this.x},${this.y}`]);

                while (队列.length > 0) {
                    const 当前 = 队列.shift();
                    const 距离目标 = Math.abs(当前.x - 目标X) + Math.abs(当前.y - 目标Y);
                    const 距离自身 = 当前.距离;

                    if (距离自身 <= 范围 && 距离目标 > Math.abs(this.x - 目标X) + Math.abs(this.y - 目标Y)) {
                        可达点.push({ x: 当前.x, y: 当前.y, 距离目标: 距离目标 });
                    }

                    if (当前.距离 >= 范围) continue;

                    const 方向 = [{ dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 }];
                    for (const { dx, dy } of 方向) {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;
                        const 位置键 = `${新X},${新Y}`;

                        if (新X >= 0 && 新X < 地牢大小 && 新Y >= 0 && 新Y < 地牢大小 && !已访问.has(位置键) && 位置是否可用(新X, 新Y, false)) {
                            if (检查移动可行性(当前.x, 当前.y, 新X, 新Y)) {
                                已访问.add(位置键);
                                队列.push({ x: 新X, y: 新Y, 距离: 当前.距离 + 1 });
                            }
                        }
                    }
                }

                if (可达点.length > 0) {
                    可达点.sort((a, b) => b.距离目标 - a.距离目标);
                    return 可达点[0];
                }
                return null;
            }


            尝试召唤() {
                const 方向 = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [1, -1], [-1, 1], [1, 1]];
                let 召唤成功数 = 0;
                const 需要召唤数 = 1 + (this.强化 ? Math.floor(Math.random() * 2) : 0);

                for (let i = 0; i < 需要召唤数; i++) {
                    let 放置成功 = false;
                    方向.sort(() => Math.random() - 0.5);
                    for (const [dx, dy] of 方向) {
                        const 召唤X = this.x + dx;
                        const 召唤Y = this.y + dy;
                        if (召唤X >= 0 && 召唤X < 地牢大小 && 召唤Y >= 0 && 召唤Y < 地牢大小 && 位置是否可用(召唤X, 召唤Y, false) && 检查直线移动可行性(this.x, this.y, 召唤X, 召唤Y, true)) {
                            const 新召唤物 = new this.召唤物类({
                                x: 召唤X,
                                y: 召唤Y,
                                房间ID: this.房间ID,
                                状态: 怪物状态.活跃,
                                召唤者: this,
                                强化: this.强化,
                            });
                            放置怪物到单元格(新召唤物, 召唤X, 召唤Y);
                            新召唤物.处理地形效果();
                            this.当前召唤物列表.push(新召唤物);
                            召唤成功数++;
                            放置成功 = true;
                            break;
                        }
                    }
                    if (!放置成功 && i === 0) return false;
                    if (!放置成功 && i > 0) break;
                }

                if (召唤成功数 > 0) {
                    添加日志(`${this.类型} 召唤了 ${召唤成功数} 个 幽灵奴仆！`, "信息");
                    计划显示格子特效(this.当前召唤物列表.slice(-召唤成功数).map(s => ({ x: s.x, y: s.y })), "8A2BE2", 0);
                    return true;
                }
                return false;
            }

            尝试攻击() {

                if (this.召唤冷却剩余 <= 0 || this.当前召唤物列表.length < this.最大召唤物数量) {
                    return false;
                }

                if (怪物状态表.get(this)?.类型 === "魅惑") {

                    return super.尝试攻击();
                } else {

                    return super.尝试攻击();
                }
            }

            受伤(伤害, 来源 = null) {
                const 原始血量 = this.当前生命值;
                super.受伤(伤害, 来源);
                if (原始血量 > 0 && this.当前生命值 <= 0) {
                    this.当前召唤物列表.forEach(仆从 => {
                        if (仆从 && 仆从.当前生命值 > 0 && Math.random() < 0.7) {
                            仆从.受伤(仆从.生命值 * 2, "召唤者死亡");
                            添加日志(`${仆从.类型} 随着 ${this.类型} 的死亡而消散了。`, "信息");
                        }
                    });
                    this.当前召唤物列表 = [];
                }
            }
        }

        class 幽灵仆从 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.幽灵仆从,
                    类型: "幽灵仆从",
                    基础生命值: 10 + (配置.强化 ? 3 : 0),
                    基础攻击力: 2 + (配置.强化 ? 1 : 0),
                    移动率: 0.9,
                    掉落物: null,
                    掉落概率: 0,
                    基础攻击范围: 1,
                    跟踪距离: 10,
                    ...配置,
                });
                this.生命周期 = 8 + (配置.强化 ? 4 : 0);
                this.召唤者 = 配置.召唤者;
            }

            尝试移动() {
                if (this.当前生命值 <= 0) return;

                this.生命周期--;
                if (this.生命周期 <= 0) {
                    this.受伤(this.生命值 * 2, "生命周期结束");
                    添加日志(`${this.类型} 消散了。`, "信息");
                    return;
                }


                if ((!this.召唤者 || this.召唤者.当前生命值 <= 0) && Math.random() < 0.1) {
                    this.受伤(this.生命值 * 2, "召唤者死亡");
                    return;
                }


                this.目标路径 = this.计算路径(玩家.x, 玩家.y);
                super.尝试移动();
                this.绘制血条();
            }


            选择目标() {

                return { x: 玩家.x, y: 玩家.y };
            }
        }

        class 萨满怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.萨满怪物,
                    类型: "萨满怪物",
                    基础生命值: 35 + (配置.强化 ? 10 : 0),
                    基础攻击力: 2 + (配置.强化 ? 1 : 0),
                    移动率: 0.7,
                    掉落物: new 治疗药水({ 数量: Math.ceil(Math.random() * 3) }),
                    掉落概率: 0.5,
                    基础攻击范围: 1,
                    跟踪距离: 12,
                    ...配置,
                });
                this.治疗范围 = 3 + (配置.强化 ? 2 : 0);
                this.治疗量 = 8 + (配置.强化 ? 4 : 0);
                this.治疗冷却 = 1 - (配置.强化 ? 1 : 0)
                this.治疗冷却剩余 = Math.floor(Math.random() * (this.治疗冷却 + 1));
                this.优先治疗阈值 = 0.7;
            }


            尝试移动() {
                const 我的状态 = 怪物状态表.get(this);
                if (我的状态?.类型 === "冻结" || 我的状态?.类型 === "魅惑") {
                    super.尝试移动();
                    this.绘制血条();
                    return;
                }
                if (this.当前生命值 <= 0) return;
                if (this.受伤冻结回合剩余 > 0) {
                    this.受伤冻结回合剩余--;
                    this.绘制血条();
                    return;
                }


                if (this.治疗冷却剩余 > 0) {
                    this.治疗冷却剩余--;
                }


                const 待治疗友军 = this.寻找待治疗友军();

                if (待治疗友军 && this.治疗冷却剩余 <= 0) {
                    const 距离 = Math.abs(this.x - 待治疗友军.x) + Math.abs(this.y - 待治疗友军.y);
                    if (距离 <= this.治疗范围) {
                        this.执行治疗(待治疗友军);
                    }
                    this.目标路径 = this.计算目标路径(待治疗友军.x, 待治疗友军.y);
                    if (this.目标路径) {
                        super.尝试移动();
                    }

                    this.绘制血条();
                    return;
                }


                this.目标路径 = this.计算路径(玩家.x, 玩家.y);
                super.尝试移动();
                this.绘制血条();
            }

            尝试攻击() {

                if (怪物状态表.get(this)?.类型 === "魅惑" || 怪物状态表.get(this)?.类型 === "冻结") return false;
                if (this.治疗冷却剩余 > 0) {
                    return;
                }

                const 待治疗友军 = this.寻找待治疗友军();
                if (待治疗友军 && this.治疗冷却剩余 <= 0) {
                    const 距离 = Math.abs(this.x - 待治疗友军.x) + Math.abs(this.y - 待治疗友军.y);
                    if (距离 <= this.治疗范围) {
                        return false;
                    }
                }

                return super.尝试攻击();
            }

            寻找待治疗友军() {
                let 最优先目标 = null;
                let 最低血量百分比 = this.优先治疗阈值;

                所有怪物.forEach(友军 => {
                    if (友军 === this || 友军.当前生命值 <= 0 || 友军.当前生命值 >= 友军.生命值 || 怪物状态表.get(友军)?.类型 === '魅惑') return;
                    const 距离 = Math.abs(this.x - 友军.x) + Math.abs(this.y - 友军.y);

                    if (距离 <= this.治疗范围 + 3) {
                        const 血量百分比 = 友军.当前生命值 / 友军.生命值;
                        if (血量百分比 < 最低血量百分比) {
                            最低血量百分比 = 血量百分比;
                            最优先目标 = 友军;
                        }
                    }
                });
                return 最优先目标;
            }

            执行治疗(目标) {
                const 治疗量 = this.治疗量;
                目标.当前生命值 = Math.min(目标.生命值, 目标.当前生命值 + 治疗量);
                this.治疗冷却剩余 = this.治疗冷却;
                添加日志(`${this.类型} 治疗了 ${目标.类型}，恢复了 ${治疗量} 点生命！`, "信息");
                目标.绘制血条();
                目标.接受萨满治疗 = true;

            }
        }

        class 大史莱姆怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.大史莱姆,
                    类型: "大史莱姆",
                    基础生命值: 40 + (配置.强化 ? 20 : 0),
                    基础攻击力: 5 + (配置.强化 ? 2 : 0),
                    移动率: 0.5, // 移动较慢
                    掉落物: new 金币({ 数量: Math.floor(Math.random() * 8) + 3 }),
                    掉落概率: 0.8,
                    攻击冷却: 1,
                    ...配置,
                });
                this.分裂数量 = 2 + (配置.强化 ? 2 : 0);
            }

            尝试攻击() {
                if (super.尝试攻击()) {
                    // 攻击成功后施加缓慢效果
                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        if (this.魅惑目标怪物) {
                            new 状态效果("缓慢", "#888888", "慢", 5, null, null, this.魅惑目标怪物);
                        }
                    } else {
                        new 状态效果("缓慢", "#888888", 图标映射.缓慢, 5, 5); // 假设缓慢持续5回合
                    }
                    return true;
                }
                return false;
            }

            受伤(伤害, 来源 = null) {
                const 原始血量 = this.当前生命值;
                super.受伤(伤害, 来源);
                // 如果死亡，则分裂
                if (原始血量 > 0 && this.当前生命值 <= 0) {
                    this.分裂();
                }
            }

            分裂() {
                let 成功分裂数 = 0;
                const 方向 = [
                    { dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                    { dx: -1, dy: -1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
                ];

                for (let i = 0; i < this.分裂数量; i++) {
                    let 放置成功 = false;
                    for (const { dx, dy } of 方向) {
                        const 新X = this.x + dx;
                        const 新Y = this.y + dy;
                        if (位置是否可用(新X, 新Y)) {
                            let 史莱姆
                            if (Math.random() < 0.25) {
                                史莱姆 = new 大史莱姆怪物({
                                    x: 新X,
                                    y: 新Y,
                                    房间ID: this.房间ID,
                                    状态: 怪物状态.活跃, // 出生即活跃
                                    强化: this.强化, // 继承强化状态
                                });
                            } else {
                                史莱姆 = new 小史莱姆怪物({
                                    x: 新X,
                                    y: 新Y,
                                    房间ID: this.房间ID,
                                    状态: 怪物状态.活跃, // 出生即活跃
                                    强化: this.强化, // 继承强化状态
                                });
                            }
                            放置怪物到单元格(史莱姆, 新X, 新Y);
                            成功分裂数++;
                            放置成功 = true;
                            // 移除已用方向，避免重复放置
                            方向.splice(方向.findIndex(d => d.dx === dx && d.dy === dy), 1);
                            break;
                        }
                    }
                    // 如果所有方向都试过还失败，就不再尝试分裂更多
                    if (!放置成功) break;
                }
                if (成功分裂数 > 0) {
                    添加日志(`${this.类型} 分裂成了 ${成功分裂数} 个小史莱姆！`, "警告");
                }
            }
        }

        class 小史莱姆怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.小史莱姆,
                    类型: "小史莱姆",
                    基础生命值: 15 + (配置.强化 ? 10 : 0),
                    基础攻击力: 3 + (配置.强化 ? 1 : 0),
                    移动率: 0.8, // 移动较快
                    掉落物: new 金币({ 数量: Math.floor(Math.random() * 3) + 1 }),
                    掉落概率: 0.5,
                    攻击冷却: 0, // 攻击更快
                    基础攻击范围: 1,
                    基础移动距离: 2, // 可以移动两格
                    ...配置,
                });
            }

            尝试攻击() {
                if (super.尝试攻击()) {
                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        if (this.魅惑目标怪物) {
                            new 状态效果("缓慢", "#888888", 图标映射.缓慢, 3, null, null, this.魅惑目标怪物);
                        }
                    } else {
                        new 状态效果("缓慢", "#888888", 图标映射.缓慢, 3, 3); // 缓慢持续3回合
                    }
                    return true;
                }
                return false;
            }
        }

        class 瞬移怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.瞬移怪物,
                    类型: "瞬移怪物",
                    基础生命值: 25 + (配置.强化 ? 15 : 0),
                    基础攻击力: 6 + (配置.强化 ? 3 : 0),
                    移动率: 1,
                    掉落物: new 能量药水({ 数量: 1 }),
                    掉落概率: 0.4,
                    基础攻击范围: 3,
                    受伤冻结回合: 0, // 受伤不冻结，可能直接瞬移走
                    ...配置,
                });
                this.瞬移几率 = 0.6 + (配置.强化 ? 0.2 : 0);
                this.受击瞬移几率 = 0.4 + (配置.强化 ? 0.2 : 0);
            }

            尝试移动() {
                const 我的状态 = 怪物状态表.get(this);
                if (我的状态?.类型 === "冻结") return;

                if (this.当前生命值 <= 0) return;
                if (房间地图[玩家.y][玩家.x] === 0) return; // 教程层不动

                // 魅惑状态下的移动
                if (我的状态?.类型 === "魅惑") {
                    const 目标 = this.寻找最近怪物目标();
                    if (目标 && Math.random() < this.瞬移几率) {
                        this.瞬移到(目标.x, 目标.y, 5); // 尝试瞬移到目标怪物附近
                    } else if (目标) {
                        // 不瞬移则正常寻路移动
                        this.目标路径 = this.计算路径(目标.x, 目标.y);
                        super.尝试移动(); // 调用基类移动
                    }
                    this.绘制血条();
                    return; // 处理完魅惑移动后返回
                }

                // 正常状态下的移动
                const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
                if (玩家距离 <= this.跟踪距离 && Math.random() < this.瞬移几率) {
                    this.瞬移到(玩家.x, 玩家.y, 3); // 尝试瞬移到玩家附近
                } else {
                    // 不瞬移则正常寻路移动
                    if (this.目标路径.length > 0 && this.追击玩家中) {
                        super.尝试移动(); // 调用基类移动
                    }
                }
                this.绘制血条();
            }

            尝试攻击() {
                if (怪物状态表.get(this)?.类型 === "冻结") return false;
                if (this.攻击冷却回合剩余 > 0) {
                    this.攻击冷却回合剩余 -= 1;
                    return false;
                }

                if (怪物状态表.get(this)?.类型 === "魅惑") {
                    const { x: 目标X, y: 目标Y } = this.寻找最近怪物目标();
                    this.通向目标路径 = this.计算目标路径(目标X, 目标Y);
                    if (this.通向目标路径 === null) return false;
                    if (this.通向目标路径.length <= this.攻击范围) {
                        if (this.魅惑目标怪物) {
                            this.魅惑目标怪物.受伤(this.攻击力, this);
                            this.攻击冷却回合剩余 = this.攻击冷却;
                            计划显示格子特效(this.通向目标路径);
                            return true;
                        }
                    }
                } else {
                    this.通向目标路径 = this.计算目标路径(玩家.x, 玩家.y);
                    if (this.通向目标路径 === null) return false;
                    if (this.通向目标路径.length <= this.攻击范围) {
                        伤害玩家(this.攻击力, this);
                        this.攻击冷却回合剩余 = this.攻击冷却;
                        计划显示格子特效(this.通向目标路径);
                        return true;
                    }
                }
                return false;
            }

            瞬移到(目标X, 目标Y, 范围) {
                const 候选位置 = [];
                const 搜索范围 = 范围 + 2; // 稍微扩大搜索范围以找到更多候选点

                // 1. 查找目标点周围的可用格子
                for (let dx = -范围; dx <= 范围; dx++) {
                    for (let dy = -范围; dy <= 范围; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const 新X = 目标X + dx;
                        const 新Y = 目标Y + dy;
                        if (新X >= 0 && 新X < 地牢大小 && 新Y >= 0 && 新Y < 地牢大小 && 位置是否可用(新X, 新Y, false)) {
                            候选位置.push({ x: 新X, y: 新Y });
                        }
                    }
                }

                // 2. 筛选出 BFS 可达的格子
                const 可达位置 = 候选位置.filter(pos =>
                    检查直线移动可行性(this.x, this.y, pos.x, pos.y, true)
                );


                if (可达位置.length > 0) {
                    const 目标位置 = 可达位置[Math.floor(Math.random() * 可达位置.length)];
                    // 保存旧位置用于恢复单元格类型
                    const 旧X = this.x;
                    const 旧Y = this.y;

                    this.恢复背景类型(); // 恢复旧位置单元格
                    this.保存新位置类型(目标位置.x, 目标位置.y); // 保存新位置背景类型
                    this.x = 目标位置.x;
                    this.y = 目标位置.y;
                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
                    地牢[this.y][this.x].关联怪物 = this;
                    this.处理地形效果();
                    添加日志(`${this.类型} 瞬移了！`, "信息");
                    绘制(); // 瞬移后立即重绘
                }
                // 如果没有可达位置，则不瞬移
            }
            瞬移逃跑() {
                const 范围 = 8; // 逃跑瞬移范围更大
                const 候选位置 = [];
                // 1. 查找自身周围的可用格子作为逃跑候选
                for (let dx = -范围; dx <= 范围; dx++) {
                    for (let dy = -范围; dy <= 范围; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const 新X = this.x + dx;
                        const 新Y = this.y + dy;
                        if (新X >= 0 && 新X < 地牢大小 && 新Y >= 0 && 新Y < 地牢大小 && 位置是否可用(新X, 新Y, false)) {
                            const 距离玩家 = Math.abs(新X - 玩家.x) + Math.abs(新Y - 玩家.y);
                            const 距离自身 = Math.abs(dx) + Math.abs(dy);
                            // 优先选择远离玩家的位置
                            if (距离玩家 > Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y)) {
                                候选位置.push({ x: 新X, y: 新Y, 距离玩家: 距离玩家, 距离自身: 距离自身 });
                            }
                        }
                    }
                }

                // 2. 筛选出 BFS 可达的逃跑位置
                const 可达逃跑位置 = 候选位置.filter(pos =>
                    检查直线移动可行性(this.x, this.y, pos.x, pos.y, true) // 允许较长路径
                );


                if (可达逃跑位置.length > 0) {
                    // 3. 从可达位置中选择最优（最远）
                    可达逃跑位置.sort((a, b) => b.距离玩家 - a.距离玩家); // 按距离玩家远近排序
                    const 目标位置 = 可达逃跑位置[0]; // 选择最远的

                    // 保存旧位置
                    const 旧X = this.x;
                    const 旧Y = this.y;

                    this.恢复背景类型(); // 恢复旧位置
                    this.保存新位置类型(目标位置.x, 目标位置.y); // 保存新位置
                    this.x = 目标位置.x;
                    this.y = 目标位置.y;
                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
                    地牢[this.y][this.x].关联怪物 = this;
                    添加日志(`${this.类型} 受伤后瞬移逃跑了！`, "信息")
                    this.处理地形效果();
                    绘制();
                }
                // 如果没有可达的逃跑位置，则不瞬移
            }

            受伤(伤害, 来源 = null) {
                const 原始血量 = this.当前生命值;
                super.受伤(伤害, 来源);
                // 受伤后有几率瞬移逃跑
                if (原始血量 > 0 && this.当前生命值 > 0 && Math.random() < this.受击瞬移几率) {
                    this.瞬移逃跑();
                }
            }
        }

        class 伪装怪物 extends 怪物 {
            constructor(配置 = {}) {
                const 伪装物品列表 = [
                    { 图标: 图标映射.药水, 名称: "药水" },
                    { 图标: 图标映射.卷轴, 名称: "卷轴" },
                    { 图标: 图标映射.金币, 名称: "金币" }
                ];
                const 伪装 = 伪装物品列表[Math.floor(Math.random() * 伪装物品列表.length)];

                super({
                    类型: "伪装怪物",
                    图标: 图标映射.伪装怪物,
                    基础生命值: 30 + (配置.强化 ? 10 : 0),
                    基础攻击力: 7 + (配置.强化 ? 3 : 0),
                    移动率: 0, // 初始不动
                    掉落物: new 金币({ 数量: Math.floor(Math.random() * 10) + 5 }), // 掉落较多金币
                    掉落概率: 0.9,
                    基础攻击范围: 1,
                    ...配置,
                });
                this.伪装状态 = true;
                this.图标 = 伪装.图标;
                this.触发距离 = 2 + (配置.强化 ? -1 : 0);

            }
            尝试移动() {
                if (this.当前生命值 <= 0) return;

                // 如果仍在伪装状态，检查玩家距离
                if (this.伪装状态) {
                    const 玩家距离 = Math.abs(this.x - 玩家.x) + Math.abs(this.y - 玩家.y);
                    if (玩家距离 <= this.触发距离) {
                        this.解除伪装();
                    } else {
                        return; // 未触发则不动
                    }
                }

                // 解除伪装后，正常移动
                if (!this.伪装状态) {
                    super.尝试移动();
                }
                this.绘制血条();
            }

            解除伪装() {
                if (!this.伪装状态) return;
                this.伪装状态 = false;
                this.图标 = 图标映射.伪装怪物;
                this.移动率 = 0.8; // 恢复正常移动率
                this.状态 = 怪物状态.活跃; // 变为活跃状态
                显示通知(`一个${this.类型}显现了！`, "警告");
                添加日志(`伪装的 ${this.图标} 原来是 ${this.类型}！`, "警告");
                this.绘制血条(); // 显示血条
                绘制(); // 重绘以更新图标
            }

            绘制血条(隐藏血条 = false) {
                // 只有在非伪装状态下才绘制血条
                if (!this.伪装状态) {
                    super.绘制血条(隐藏血条);
                } else if (this.血条元素) {
                    // 确保伪装时血条是隐藏的
                    this.血条元素.style.display = "none";
                }
            }

            尝试攻击() {
                // 只有在非伪装状态下才能攻击
                if (!this.伪装状态) {
                    return super.尝试攻击();
                }
                return false;
            }

            受伤(伤害, 来源 = null) {
                // 受到伤害时立即解除伪装
                if (this.伪装状态) {
                    this.解除伪装();
                }
                super.受伤(伤害, 来源);
            }
        }
        class 炸弹怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    基础移动距离: 2,
                    图标: 图标映射.炸弹怪物,
                    类型: "炸弹怪物",
                    掉落物: new 炸弹({
                        数量: Math.floor(Math.random() * 5) + 1,
                    }),
                    房间ID: 配置.房间ID || null,
                    强化: 配置.强化 || false,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    生命值: 配置.基础生命值 || 45,
                    基础攻击力: 配置.基础攻击力 || 3,
                    移动率: 配置.移动率 || 0.7,
                });
                this.携带炸弹 = true;
            }

            尝试移动() {
                super.尝试移动();
                if (this.携带炸弹) {

                    const 距离 =
                        Math.abs(this.x - 玩家.x) +
                        Math.abs(this.y - 玩家.y); //不想增加魅惑逻辑了...
                    if (距离 <= this.攻击范围) {
                        this.放置炸弹();
                        this.携带炸弹 = false;
                        this.基础移动距离 = 1; // 恢复普通怪物
                        this.图标 = 图标映射.怪物;
                    }
                }
            }

            放置炸弹() {
                const 扔出炸弹 = new 炸弹({ 能否拾起: false, 颜色索引: 4 });
                let 目标 = {};
                目标 = 玩家放置物品(扔出炸弹);
                if (目标.x !== null || 目标.y !== null) {
                    扔出炸弹.使用(false, 目标.x, 目标.y);
                }
            }
        }
        class 旋风怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.旋风怪物,
                    类型: "旋风怪物",
                    基础生命值: 38 + (配置.强化 ? 18 : 0),
                    基础攻击力: 3 + (配置.强化 ? 1 : 0), // 直接攻击力不高
                    移动率: 0.75,
                    掉落物: new 金币({ 数量: Math.floor(Math.random() * 10) + 5 }),
                    掉落概率: 0.6,
                    基础攻击范围: 1, // 主要靠旋风
                    跟踪距离: 15,
                    ...配置,
                });
                this.召唤冷却 = 4 + (配置.强化 ? -1 : 0); // 召唤间隔
                this.召唤冷却剩余 = Math.floor(Math.random() * (this.召唤冷却 + 1));
                this.最大召唤物数量 = 1 + (配置.强化 ? 1 : 0); // 同时存在的旋风数量
                this.当前召唤物列表 = [];
                this.召唤物类 = 旋风; // 召唤旋风怪物
            }

            尝试移动() {
                const 我的状态 = 怪物状态表.get(this);
                if (我的状态?.类型 === "冻结") return;

                if (this.当前生命值 <= 0) return;

                // 清理已消失的召唤物
                this.当前召唤物列表 = this.当前召唤物列表.filter(旋 => 旋 && 旋.当前生命值 > 0);

                if (this.受伤冻结回合剩余 > 0) {
                    this.受伤冻结回合剩余--;
                    this.绘制血条();
                    return;
                }

                // 冷却处理
                if (this.召唤冷却剩余 > 0) {
                    this.召唤冷却剩余--;
                }

                // 尝试召唤
                if (this.召唤冷却剩余 <= 0 && this.当前召唤物列表.length < this.最大召唤物数量) {
                    if (this.尝试召唤()) {
                        this.召唤冷却剩余 = this.召唤冷却;
                        this.绘制血条();
                        return; // 召唤成功后本回合可能不再移动或攻击
                    }
                }

                super.尝试移动();
                this.绘制血条();
            }

            尝试召唤() {
                const 方向 = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [1, -1], [-1, 1], [1, 1]];
                let 召唤成功数 = 0;
                const 需要召唤数 = 1; // 一次只召唤一个

                for (let i = 0; i < 需要召唤数; i++) {
                    let 放置成功 = false;
                    方向.sort(() => Math.random() - 0.5); // 随机方向
                    for (const [dx, dy] of 方向) {
                        const 召唤X = this.x + dx;
                        const 召唤Y = this.y + dy;
                        if (召唤X >= 0 && 召唤X < 地牢大小 && 召唤Y >= 0 && 召唤Y < 地牢大小 && 位置是否可用(召唤X, 召唤Y, false)) {
                            const 新召唤物 = new this.召唤物类({
                                x: 召唤X,
                                y: 召唤Y,
                                房间ID: this.房间ID,
                                状态: 怪物状态.活跃,
                                强化: this.强化,
                            });
                            放置怪物到单元格(新召唤物, 召唤X, 召唤Y);
                            this.当前召唤物列表.push(新召唤物);
                            召唤成功数++;
                            放置成功 = true;
                            break;
                        }
                    }
                    if (!放置成功) return false; // 无法放置则召唤失败
                }

                if (召唤成功数 > 0) {
                    添加日志(`${this.类型} 释放了一个旋风！`, "信息");
                    计划显示格子特效(this.当前召唤物列表.slice(-召唤成功数).map(s => ({ x: s.x, y: s.y })), "ADD8E6", 0); // 淡蓝色特效
                    return true;
                }
                return false;
            }

            // 可以保留基础攻击，或者让它完全依赖旋风
            尝试攻击() {
                super.尝试攻击()
                return true; // 目前主要靠旋风
            }

            受伤(伤害, 来源 = null) {
                const 原始血量 = this.当前生命值;
                super.受伤(伤害, 来源);
                // 死亡时驱散场上所有由它召唤的旋风（可选）
                if (原始血量 > 0 && this.当前生命值 <= 0) {
                    this.当前召唤物列表.forEach(旋 => {
                        if (旋 && 旋.当前生命值 > 0) {
                            旋.受伤(旋.生命值 * 2, "召唤者死亡"); // 强制移除
                        }
                    });
                    this.当前召唤物列表 = [];
                }
            }
        }
        class 旋风 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.旋风,
                    类型: "旋风",
                    基础生命值: 5 + (配置.强化 ? 5 : 0), // 很脆弱
                    基础攻击力: 0, // 不直接攻击
                    移动率: 0.9, // 移动较快
                    掉落概率: 0,
                    基础攻击范围: 0, // 接触触发
                    跟踪距离: 30, // 追踪范围大
                    受伤冻结回合: 0, // 不受冻结影响移动
                    基础移动距离: 2, // 移动快
                    ...配置,
                });
                this.生命周期 = 10 + (配置.强化 ? 5 : 0); // 存在时间
            }

            尝试移动() {
                if (this.当前生命值 <= 0) return;

                // 生命周期处理
                this.生命周期--;
                if (this.生命周期 <= 0) {
                    this.受伤(this.生命值 * 2, "生命周期结束"); // 时间到了消失
                    添加日志(`${this.类型} 消散了。`, "信息");
                    this.移除自身();
                    return;
                }
                let { x, y } = this.选择目标();
                // 碰撞检测与效果触发
                if (this.x === x && this.y === y) {
                    this.触发效果();
                }
                this.目标路径 = this.计算目标路径(x, y)
                if (this.当前生命值 <= 0) return;
                if (房间地图[玩家.y][玩家.x] === 0) return;
                if (
                    this.目标路径.length === 0 ||
                    Math.random() > this.移动率 ||
                    this.跟踪距离 < this.目标路径.length
                ) {
                    this.追击玩家中 = false;
                    return;
                }


                const 下一步 = this.目标路径[Math.min(this.移动距离 - 1, this.目标路径.length - 1)];
                if (下一步) {
                    const dx = 下一步.x - this.x;
                    const dy = 下一步.y - this.y;

                    // 规划实际可移动位置
                    const 最终位置 = this.规划移动路径(dx, dy);
                    if (!最终位置) return;
                    this.恢复背景类型();
                    this.保存新位置类型(最终位置.x, 最终位置.y);
                    this.x = 最终位置.x;
                    this.y = 最终位置.y;
                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
                    地牢[this.y][this.x].关联怪物 = this;
                }
                if (this.x === x && this.y === y) {
                    this.触发效果();
                    return;
                }
                this.绘制血条(true); // 强制不显示血条
            }

            绘制血条(隐藏血条 = true) {
                // 旋风不显示血条
                if (this.血条元素) {
                    this.血条元素.style.display = "none";
                }
            }

            尝试攻击() {
                let { x, y } = this.选择目标();
                if (this.x === x && this.y === y) {
                    this.触发效果();
                }
                return false;
            }

            触发效果() {
                添加日志(`${this.类型} 撞到了你，释放了气流！`, "警告");
                this.受伤(this.生命值 * 2, "效果触发");
                this.移除自身();
                const 中心X = this.x;
                const 中心Y = this.y;

                // 在3x3区域生成旋风物品
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        // if (dx === 0 && dy === 0) continue; // 不在中心生成
                        const x = 中心X + dx;
                        const y = 中心Y + dy;

                        if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
                            // 检查目标格子是否可放置（非墙、非上锁门）
                            const 单元格 = 地牢[y][x];
                            if (单元格 && ![单元格类型.墙壁, 单元格类型.上锁的门].includes(单元格.背景类型) && !单元格.关联物品) {
                                const 旋风物品实例 = new 旋风物品({});
                                // 使用放置物品到单元格，并将其添加到所有计时器列表
                                if (放置物品到单元格(旋风物品实例, x, y)) {
                                    旋风物品实例.x = x;
                                    旋风物品实例.y = y;
                                    所有计时器.push(旋风物品实例); // 添加到计时器列表
                                    计划显示格子特效([{ x: x, y: y }], "90EE90"); // 显示生成特效
                                }
                            }
                        }
                    }
                }
                new 状态效果("眩晕", 效果颜色编号映射[效果名称编号映射.眩晕], 图标映射.眩晕, 2);
            }

            移除自身() {
                this.恢复背景类型();
                if (this.血条元素) this.血条元素.remove();
                所有怪物 = 所有怪物.filter((m) => m !== this);
                绘制(); // 更新画面
            }
        }
        class 盔甲怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.盔甲怪物,
                    类型: "盔甲怪物",
                    强化: 配置.强化 || false,
                    掉落物: new 钢制板甲({
                        数量: 1,
                    }),
                    掉落概率: 0.5,
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    生命值: 配置.基础生命值 || 35,
                });
            }
        }
        class 敏捷怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    基础移动距离: 3,
                    跟踪距离: 40,
                    图标: 图标映射.敏捷怪物,
                    类型: "敏捷怪物",
                    强化: 配置.强化 || false,
                    掉落物: new 迅捷卷轴({
                        数量: 1,
                    }),
                    掉落概率: 0.3,
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    生命值: 配置.基础生命值 || 28,
                    基础攻击力: 配置.基础攻击力 || 4,
                    移动率: 配置.移动率 || 0.85,
                });
            }
        }
        class 远攻怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.远攻怪物,
                    类型: "远攻怪物",
                    掉落物: new 橡木法杖({
                        数量: 1,
                    }),
                    掉落概率: 0.3,
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    强化: 配置.强化 || false,
                    生命值: 配置.基础生命值 || 35,
                    基础攻击力: 配置.基础攻击力 || 3,
                    移动率: 配置.移动率 || 0.7,
                    基础攻击范围: 3,
                    跟踪距离: 25,
                });
            }
        }
        class 仙人掌怪物 extends 怪物 {
            constructor(配置 = {}) {
                const 随机品质 = 1 + Math.floor(Math.random() * Math.random() * 4);
                const 荆棘卷轴实例 = new 附魔卷轴({
                    品质: 随机品质, // 使用随机品质
                    已解锁: true,     // 默认掉落已鉴定
                    强化: 配置.强化 || false // 可选：继承强化状态
                });

                // 手动设置附魔效果为荆棘
                const 效果名 = "荆棘附魔";
                const 效果索引 = 荆棘卷轴实例.效果名.indexOf(效果名);

                if (效果索引 !== -1) {
                    荆棘卷轴实例.附魔效果 = 荆棘卷轴实例.附魔池[效果索引]; // 设置效果函数
                    荆棘卷轴实例.效果描述 = `为防御装备附加${效果名} ${'I'.repeat(随机品质)}级`; // 更新描述
                    荆棘卷轴实例.名称 = `${效果名}卷轴`; // 可以考虑更新名称
                    荆棘卷轴实例.颜色索引 = 随机品质 - 1; // 根据品质更新颜色
                }
                super({
                    图标: 图标映射.仙人掌怪物,
                    类型: "仙人掌怪物",
                    掉落物: 荆棘卷轴实例,
                    掉落概率: 0.3 + (配置.强化 ? 0.15 : 0),
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    强化: 配置.强化 || false,
                    生命值: 配置.基础生命值 || 30,
                    基础攻击力: 配置.基础攻击力 || 3,
                    移动率: 配置.移动率 || 0.7,
                });
            }
            受伤(伤害, 来源 = null) {
                if (来源 === "玩家") {
                    伤害玩家(this.攻击力, this);
                }
                super.受伤(伤害, 来源);
            }
        }
        class 冰冻怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.冰冻怪物,
                    类型: "冰冻怪物",
                    掉落物: new 冰盾({
                        数量: 1,
                    }),
                    掉落概率: 配置.掉落概率 || 0.3,
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    强化: 配置.强化 || false,
                    生命值: 配置.基础生命值 || 23,
                    基础攻击力: 配置.基础攻击力 || 3,
                    移动率: 配置.移动率 || 0.7,
                    基础攻击范围: 1,
                    跟踪距离: 25,
                    攻击冷却: 4,
                });
            }
            尝试攻击() {
                if (玩家状态.some(s => s.类型 === "冻结") && this.攻击冷却回合剩余 === 0) {//倘若已有效果则不攻击，缓冲攻击冷却给其它怪物起辅助作用
                    return false;
                }
                if (super.尝试攻击()) {
                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        new 状态效果("冻结", "#2196F3", "冻", 3, null, null, this.魅惑目标怪物);
                    } else if (![...玩家装备.values()].some(
                        (item) => item.名称 === '冰盾')) {
                        new 状态效果("冻结", "#2196F3", 图标映射.冰冻怪物, 3, 3); // 添加冻结效果
                    }
                }
            }
            获得效果(状态效果) {
                if (状态效果.类型 === "冻结") {
                    状态效果.移除状态();
                    return false;
                }
                if (状态效果.类型 === "火焰") {
                    this.恢复背景类型();
                    this.血条元素.remove();
                    所有怪物 = 所有怪物.filter((m) => m !== this);
                    const 新怪物 = new 怪物({
                        x: this.x,
                        y: this.y,
                        当前生命值: this.当前生命值,
                    });
                    放置怪物到单元格(新怪物, this.x, this.y);
                    新怪物.绘制血条();
                }
                return true;
            }
        }
        class 物品 {
            constructor(配置 = {}) {
                this.类型 = 配置.类型 || "其他物品";
                this.名称 = 配置.名称 || "未命名物品";
                this.图标 = 配置.图标 || "◎";
                this.品质 = 配置.品质 || 1;
                this.堆叠数量 = 配置.堆叠数量 || 1;
                this.最大堆叠数量 = 配置.最大堆叠数量 || 最大堆叠数;
                this.颜色索引 = 配置.颜色索引 || 0;
                this.自定义数据 = new Map(Object.entries(配置.数据 || {}));
                const date = new Date();
                this.唯一标识 = 配置.唯一标识 || Symbol(Date.now().toString() + Math.random().toString());
                this.已装备 = 配置.已装备 || false;
                this.装备槽位 = 配置.已装备 || null;
                this.x = 配置.x || null;
                this.y = 配置.y || null;
                this.显示元素 = null;
                this.isActive = false; //屎山莫动
                this.强化 = 配置.强化 || false;
                this.能否拾起 = (配置.能否拾起 === undefined) ? true : 配置.能否拾起;
                this.是否正常物品 = (配置.是否正常物品 === undefined) ? true : 配置.是否正常物品; // 用于配置是否是只能存在于地图上被玩家使用的物品
                this.效果描述 = 配置.效果描述 || null;
                this.是否隐藏 = 配置.是否隐藏 || false; //是否在背包中显示
                this.是否为隐藏物品 = 配置.是否为隐藏物品 || false; //是否在地图上显示
                this.阻碍怪物 = 配置.阻碍怪物 !== undefined ? 配置.阻碍怪物 : true;
                this.是否被丢弃 = 配置.是否被丢弃 ?? false
                //将 || 换为 ??
            }
            装备() {
                if (this.已装备) return false;

                // 寻找空装备槽
                const 空槽 = [1, 2, 3, 4].find(
                    (id) =>
                        ![...玩家装备.values()].some(
                            (item) => item.装备槽位 === id
                        )
                );

                if (空槽) {
                    this.已装备 = true;
                    this.装备槽位 = 空槽;
                    玩家装备.set(this.装备槽位, this);
                    更新装备显示();
                    return true;
                }
                return false;
            }

            取消装备() {
                if (!this.已装备) return false;
                玩家装备.delete(this.装备槽位);
                this.已装备 = false;
                this.装备槽位 = null;
                更新装备显示();
                return true;
            }
            // 通用方法：获取显示名称（可被子类覆盖）
            获取名称() {
                return (
                    `${this.名称} [${this.品质} 级]` +
                    (this.强化 ? ` [强化]` : ``)
                );
            }

            // 通用方法：使用物品（返回能否使用该物品，需要自己处理物品消耗，不用处理物品移除）
            使用() {
                this.堆叠数量 -= 1;
                return true;
            }
            当被收集(玩家) {
                return true;
            }
            当被丢弃(x, y) {
                return true;
            }
            // 通用方法：能否与目标交互（如开门、攻击等）
            可交互目标(目标) {
                return false; // 默认无交互
            }
            刷新显示() {
                //你应该在打开背包界面时使用它
                this.显示元素.innerHTML = `
            < div class="物品图标" > ${this
                        .图标
                    }</div >
            <div class="物品名称">${this.获取名称()}</div>
                                                                        ${this
                        .堆叠数量 >
                        1
                        ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
                        : ""
                    }
        `;
            }

            // 通用方法：获取悬停提示信息
            获取提示() {
                if (this.效果描述 !== null) {
                    return [
                        `${this.获取名称()} `,
                        `类型：${this.类型} `,
                        `品质：${"★".repeat(this.品质)} `,
                        `堆叠：${this.堆叠数量} `,
                        `效果描述：${this.效果描述} `,
                    ].join("\n");
                } else {
                    return [
                        `${this.获取名称()} `,
                        `类型：${this.类型} `,
                        `品质：${"★".repeat(this.品质)} `,
                        `堆叠：${this.堆叠数量} `,
                    ].join("\n");
                }

            }
            安全销毁() {
                this.取消装备();
                this.自定义数据.clear();
                this.唯一标识 = null;
                return true;
            }
            get 显示图标() {
                return this.图标; // 子类可以覆写此方法来修改背包内图标
            }
            get 显示名称() {
                return this.名称; // 子类可以覆写此方法来修改显示元素内名称，防止装备栏显示名称过长
            }
            get 颜色表() {
                return 颜色表;
            }
            // 通用方法：生成显示元素
            生成显示元素(用途 = "背包") {
                const 元素 = document.createElement("div");
                元素.className = "物品条目 hover";
                元素.setAttribute("data-quality", this.品质);
                if (用途 === "背包") {
                    元素.innerHTML = `
                                                                        <div class="物品图标">${this
                            .显示图标
                        }</div>
                                                                        <div class="物品名称">${this.获取名称()}</div>
                                                                        ${this
                            .堆叠数量 >
                            1
                            ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
                            : ""
                        }
                                                                    `;
                    this.显示元素 = 元素;
                } else if (用途 === "装备") {
                    元素.innerHTML = `
                                                                        <div class="物品图标">${this
                            .显示图标
                        }</div>
                                                                        <div class="物品名称">${this
                            .显示名称
                        }</div>
                                                                        ${this
                            .堆叠数量 >
                            1
                            ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
                            : ""
                        }
                                                                    `;
                }
                if (this.isActive) {
                    元素.classList.add("active");
                }

                元素.addEventListener("click", () => {
                    this.isActive = true;
                    元素.classList.add("active");

                    // 点击时其他元素取消激活
                    document.querySelectorAll(".物品条目").forEach((el) => {
                        if (el !== 元素 && el.__物品实例) {
                            el.classList.remove("active");
                            el.__物品实例.isActive = false;
                        }
                    });
                });
                元素.__物品实例 = this;
                // 图标样式
                const 图标元素 = 元素.querySelector(".物品图标");
                图标元素.style = `
                                                                        color: ${this
                        .颜色表[
                    this
                        .颜色索引
                    ]
                    };
                                                                        font-size: 2.5em;
                                                                        text-shadow: 0 0 8px ${this
                        .颜色表[
                    this
                        .颜色索引
                    ]
                    };
                                                                    `;

                const 丢弃按钮 = document.createElement("button");
                丢弃按钮.className = "丢弃按钮";
                丢弃按钮.innerHTML = "↓";
                丢弃按钮.addEventListener("click", (e) => {
                    e.stopPropagation();
                    this.isActive = true;
                    元素.classList.add("active");
                    document.querySelectorAll(".物品条目").forEach((el) => {
                        if (el !== 元素 && el.__物品实例) {
                            el.classList.remove("active");
                            el.__物品实例.isActive = false;
                        }
                    });
                    处理丢弃物品(this.唯一标识);
                });
                元素.prepend(丢弃按钮);

                // 使用按钮
                const 使用按钮 = document.createElement("button");
                使用按钮.className = "使用按钮";
                使用按钮.innerHTML = "⚡";
                使用按钮.onclick = (e) => {
                    e.stopPropagation();
                    this.isActive = true;
                    元素.classList.add("active");
                    document.querySelectorAll(".物品条目").forEach((el) => {
                        if (el !== 元素 && el.__物品实例) {
                            el.classList.remove("active");
                            el.__物品实例.isActive = false;
                        }
                    });
                    使用背包物品(this.唯一标识);
                };
                元素.prepend(使用按钮);

                元素.addEventListener("mousemove", (e) => {
                    const 提示框 = document.getElementById("浮动提示框");
                    提示框.innerHTML = this.获取提示().replace(
                        /\n/g,
                        "<br>"
                    );
                    提示框.style.left = `${e.pageX + 15}px`;
                    提示框.style.top = `${e.pageY + 15}px`;
                    提示框.style.display = "block";
                });

                元素.addEventListener("mouseleave", () => {
                    document.getElementById("浮动提示框").style.display =
                        "none";
                    if (元素.__物品实例) {
                        元素.classList.remove("active");
                        元素.__物品实例.isActive = false;
                    }
                });
                this.装备按钮 = null;
                this.装备按钮 = document.createElement("button");
                this.装备按钮.className = "装备按钮";
                this.装备按钮.innerHTML = 图标映射.装备按钮;
                this.装备按钮.onclick = (e) => {
                    e.stopPropagation();
                    this.isActive = true;
                    元素.classList.add("active");
                    document.querySelectorAll(".物品条目").forEach((el) => {
                        if (el !== 元素 && el.__物品实例) {
                            el.classList.remove("active");
                            el.__物品实例.isActive = false;
                        }
                    });
                    if (this.已装备) {
                        this.取消装备();
                        显示通知("已卸下", "成功");
                    } else {
                        if (this.装备()) {
                            显示通知("已装备", "成功");
                        } else {
                            显示通知("槽位已满", "错误");
                        }
                    }
                    this.装备按钮.style.background = this.已装备
                        ? "#f44336"
                        : "#FF9800";
                    更新装备显示();
                    更新背包显示();

                    document.getElementById("浮动提示框").style.display =
                        "none";
                };
                this.装备按钮.style.background = this.已装备
                    ? "#f44336"
                    : "#FF9800";
                元素.prepend(this.装备按钮);
                return 元素;
            }
            可堆叠于(其他物品) {
                if (
                    this.堆叠数量 >= this.最大堆叠数量 ||
                    this.堆叠数量 >= 最大堆叠数
                )
                    return false;
                // 基础属性比较
                const 基础相同 =
                    this.类型 === 其他物品.类型 &&
                    this.名称 === 其他物品.名称 &&
                    this.图标 === 其他物品.图标 &&
                    this.品质 === 其他物品.品质 &&
                    this.强化 === 其他物品.强化 &&
                    this.获取名称() === 其他物品.获取名称();
                //this.获取提示() === 其他物品.获取提示();

                // 自定义数据比较
                const 数据相同 = this.比较自定义数据(其他物品.自定义数据);

                return 基础相同 && 数据相同;
            }
            比较自定义数据(其他数据) {
                if (this.自定义数据.size !== 其他数据.size) return false;

                for (const [键, 值] of this.自定义数据) {
                    if (!其他数据.has(键)) return false;

                    const 其他值 = 其他数据.get(键);
                    if (typeof 值 === "object" && 值 !== null) {
                        if (!深度比较(值, 其他值)) return false;
                    } else if (值 !== 其他值) {
                        return false;
                    }
                }
                return true;
            }
        }
        class 钥匙 extends 物品 {
            constructor(配置) {
                let 钥匙唯一标识 = Symbol.for(
                    配置.地牢层数.toString() + "层" + 配置.对应门ID.toString()
                );
                super({
                    类型: "钥匙",
                    名称: "钥匙",
                    图标: 图标映射.钥匙,
                    品质: 2,
                    颜色索引: 配置.颜色索引,
                    唯一标识: 钥匙唯一标识,
                    数据: {
                        对应门ID: 配置.对应门ID,
                        地牢层数: 配置.地牢层数,
                    },
                });
            }

            获取名称() {
                const 颜色名 = 颜色名表[this.颜色索引] || "未知";
                return `${颜色名} 铜钥匙`;
            }

            可交互目标(门实例) {
                if (
                    门实例.类型 == "上锁的门" &&
                    (this.自定义数据.get("地牢层数") == 当前层数 || this.自定义数据.get("地牢层数") == -1)
                ) {
                    return (
                        this.自定义数据.get("对应门ID") === 门实例.房间ID
                    );
                }
            }
            获取提示() {
                return [
                    `类型：${this.类型} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `房间 ID：${this.自定义数据.get("对应门ID")} `,
                    `层数：${this.自定义数据.get("地牢层数")} `,
                ].join("\n");
            }
            使用() {
                显示通知("请使用互动键来使用钥匙", "错误");
                return false;
            }
        }
        class 金币 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "金币",
                    名称: "金币",
                    图标: 图标映射.金币,
                    品质: 1,
                    颜色索引: 2,
                    堆叠数量: 配置.数量 || 1,
                });
            }

            获取名称() {
                return `${this.名称} `;
            }
            使用() {
                return false;
            }
        }

        class 武器类 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "武器",
                    名称: 配置.名称 || "铁剑",
                    图标: 配置.图标 || "⚔️",
                    品质: 配置.品质 || 1,
                    颜色索引: 配置.品质 - 1 || 0,
                    堆叠数量: 配置.堆叠数量 || 1,
                    最大堆叠数量: 1,
                    效果描述: 配置.效果描述 || null,
                    强化: 配置.强化 || false,
                    数据: {

                        基础攻击力: 配置.基础攻击力 || 3,
                        冷却回合: 配置.冷却回合 || 1,
                        冷却剩余: 0,
                        攻击范围: 配置.攻击范围 || 1,
                        耐久: 配置.耐久 || 30,
                        原耐久: 配置.耐久 || 30,
                        不可破坏: 配置.不可破坏 || false,
                        攻击目标数: 配置.攻击目标数 || 1,
                        附魔: 配置.附魔 || [],
                        ...配置.数据,
                    },
                });
            }

            使用(目标怪物列表, 目标路径) {
                if (
                    this.堆叠数量 <= 0 ||
                    this.自定义数据.get("冷却剩余") > 0
                )
                    return 0; // 返回0伤害表示失败

                const 总伤害 = this.攻击力;
                let 总有效伤害 = 0; // 记录实际造成的伤害

                目标怪物列表.forEach((怪物) => {
                    if (怪物.当前生命值 > 0) {
                        const 原始血量 = 怪物.当前生命值;
                        怪物.受伤(总伤害, "玩家");
                        const 实际伤害 = 原始血量 - 怪物.当前生命值;
                        if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                    }
                });

                // 处理耐久消耗
                this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                    // 即使损坏，如果造成了伤害，也应返回伤害值
                }

                // 设置冷却
                this.自定义数据.set(
                    "冷却剩余",
                    Math.max(this.自定义数据.get("冷却回合") - (this.强化 ? 1 : 0), 0)
                );

                // 显示通知 (只显示一次总伤害)
                if (总有效伤害 > 0) {
                    if (目标怪物列表.length > 1) {
                        显示通知(`${this.名称} 对 ${目标怪物列表.length} 个目标造成共 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");
                    } else {
                        显示通知(`${this.名称} 造成 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");
                    }
                }
                this.触发通用附魔();
                if (总有效伤害 > 0) {
                    目标路径.forEach((攻击路径) => {
                        计划显示格子特效(攻击路径);
                    });
                }
                return 总有效伤害; // 返回造成的总伤害
            }
            触发通用附魔(目标怪物列表) {
                // --- 火焰附魔 ---
                if (
                    !当前天气效果.includes("严寒")
                ) {
                    if (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级) {
                        const 火焰等级 = this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔").等级;
                        目标怪物列表.forEach(怪物 => {
                            if (怪物.当前生命值 > 0) {
                                new 状态效果("火焰", "#CC5500", "火", 火焰等级, null, null, 怪物);
                            }
                        });
                    }
                }

                // --- 连锁附魔 ---
                const 连锁附魔 = this.自定义数据.get("附魔")?.find(item => item.种类 === "连锁附魔");
                if (连锁附魔) {
                    const 连锁距离 = 连锁附魔.等级;
                    目标怪物列表.forEach(初始目标 => {
                        if (初始目标.当前生命值 > 0) {
                            this.触发连锁(初始目标, 连锁距离, 目标怪物列表); // 使用基类的方法
                        }
                    });
                }
            }
            触发连锁(当前目标, 连锁距离, 已攻击过的怪物 = []) {
                let 第一层 = false
                if (this.访问过 === undefined) {
                    this.访问过 = [];
                    第一层 = true;
                }
                if (this.访问过.includes(当前目标)) return;
                this.访问过.push(当前目标)
                if (连锁距离 <= 0) return;
                const 可连锁目标 = this.寻找连锁目标(当前目标, 连锁距离, this.访问过);
                for (const 新目标 of 可连锁目标) {
                    计划显示格子特效(新目标.路径);
                    this.使用([新目标.怪物]);
                    添加日志(`连锁附魔击中了 ${新目标.怪物.类型}！`, "成功");
                }
                if (第一层) this.访问过 = undefined
            }
            寻找连锁目标(中心怪物, 连锁距离, 已攻击过的怪物) {
                const 开放列表 = [{ x: 中心怪物.x, y: 中心怪物.y, 距离: 0, 路径: [] }];
                const 已访问 = new Set([`${中心怪物.x},${中心怪物.y} `]);
                const 可连锁目标 = [];

                for (const 怪物 of 已攻击过的怪物) {
                    已访问.add(`${怪物.x},${怪物.y} `);
                }

                const 方向 = [
                    { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                    { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                    { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                    { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" }
                ];

                while (开放列表.length > 0) {
                    const 当前 = 开放列表.shift();

                    if (当前.距离 >= 连锁距离) continue;

                    for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;

                        const 位置键 = `${新X},${新Y} `;
                        if (已访问.has(位置键)) continue;

                        const 当前单元格 = 地牢[当前.y][当前.x];
                        const 目标单元格 = 地牢[新Y][新X];

                        if (当前单元格.墙壁[当前墙] || 目标单元格.墙壁[目标墙] || 目标单元格.背景类型 === 单元格类型.墙壁 || 目标单元格.背景类型 === 单元格类型.上锁的门) continue;

                        const 新路径 = [...当前.路径, { x: 新X, y: 新Y }];

                        if (目标单元格.类型 === 单元格类型.怪物 && 目标单元格.关联怪物?.状态 === 怪物状态.活跃) {
                            可连锁目标.push({ 怪物: 目标单元格.关联怪物, 路径: 新路径 });
                            已访问.add(位置键);
                        }
                        已访问.add(位置键);
                        开放列表.push({ x: 新X, y: 新Y, 距离: 当前.距离 + 1, 路径: 新路径 });
                    }
                }

                return 可连锁目标;
            }
            获取提示() {
                return this.效果描述 === null ? [`${this.获取名称()} `,
                `品质：${"★".repeat(this.品质)} `,
                `攻击力：${this.攻击力} `,
                `耐久：${this.自定义数据.get("耐久")} `,
                `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                `范围：${this.自定义数据.get("攻击范围")} 格`,
                获取附魔描述(this.自定义数据.get("附魔")),
                this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n") : [
                    `${this.获取名称()} `,
                    `攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} `,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `范围：${this.自定义数据.get("攻击范围")} 格`,
                    `效果描述：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
            获取名称() {
                return (
                    super.获取名称() +
                    (this.自定义数据.get("攻击目标数") > 1
                        ? " [范围武器]"
                        : "")
                );
            }

            get 攻击力() {
                return (
                    this.自定义数据.get("基础攻击力") +
                    (this.强化 ? 2 : 0) + 玩家属性.攻击加成 +
                    (this.自定义数据.get("附魔").find((item) => item.种类 === "锋利附魔")?.等级 * 2 || 0)
                );
            }
            get 耐久消耗() {
                if (this.自定义数据.get("不可破坏")) return 0;
                if (this.自定义数据.get("附魔").find((item) => item.种类 === "耐久附魔")?.等级 > 0) return 1 / (this.自定义数据.get("附魔").find((item) => item.种类 === "耐久附魔")?.等级 + 1);
                return 1;
            }
        }
        class 卷轴类 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "卷轴",
                    名称: 配置.名称 || "魔法卷轴",
                    效果描述: 配置.效果描述 || "未知效果",
                    图标: 配置.图标 || 图标映射.卷轴,
                    品质: 配置.品质 || 3,
                    颜色索引: 配置.品质 - 1 || 2,
                    堆叠数量: 配置.堆叠数量 || 1,
                    强化: 配置.强化 || false,
                    最大堆叠数量: 1,
                    数据: {

                        能量消耗: 配置.能量消耗 || 2,
                        已解锁: 配置.已解锁 || false,
                        ...配置.数据,
                    },
                });
            }
            安全销毁() {
                if (当前激活卷轴列表.has(this)) 当前激活卷轴列表.delete(this);
                let ret = super.安全销毁();
                document.getElementById("卷轴按钮").style.display = [
                    ...玩家装备.values(),
                ].some((item) => item.类型 === "卷轴")
                    ? "flex"
                    : "none";
                return ret;
            }
            使用() {
                // 具体效果由子类实现
                return false;
            }
            获取名称() {
                return this.自定义数据.get("已解锁")
                    ? `${this.名称} [${this.品质} 级]` +
                    (this.强化 ? " [强化]" : "")
                    : "卷轴";
            }
            消耗能量() {
                if (当前天气效果.includes("诡魅")) {
                    显示通知("不论如何念咒，卷轴依然无法启用...")
                    return false;
                }
                return 卷轴扣除能量(this.最终能量消耗);
            }
            get 最终能量消耗() {
                return Math.max(
                    this.自定义数据.get("能量消耗") - (this.强化 ? 2 : 0),
                    0
                );
            }
            get 显示图标() {
                return this.自定义数据.get("已解锁")
                    ? this.图标
                    : 图标映射.卷轴;
            }
            get 显示名称() {
                return this.自定义数据.get("已解锁") ? this.名称 : "卷轴";
            }
            生成显示元素(用途 = "背包") {
                let 元素 = super.生成显示元素(用途);
                this.装备按钮.onclick = (e) => {
                    e.stopPropagation();
                    this.isActive = true;
                    元素.classList.add("active");
                    document.querySelectorAll(".物品条目").forEach((el) => {
                        if (el !== 元素 && el.__物品实例) {
                            el.classList.remove("active");
                            el.__物品实例.isActive = false;
                        }
                    });
                    if (this.已装备) {
                        this.取消装备();
                        显示通知("已卸下", "成功");
                    } else {
                        if (this.装备()) {
                            显示通知("已装备", "成功");
                        } else {
                            显示通知("装备槽已满！", "错误");
                        }
                    }
                    this.装备按钮.style.background = this.已装备
                        ? "#f44336"
                        : "#FF9800";
                    更新装备显示();
                    更新背包显示();
                    if (this instanceof 卷轴类) {
                        document.getElementById("卷轴按钮").style.display =
                            [...玩家装备.values()].some(
                                (item) => item.类型 === "卷轴"
                            )
                                ? "flex"
                                : "none";
                    }
                    document.getElementById("浮动提示框").style.display =
                        "none";
                };

                return 元素;
            }
            取消装备() {
                if (!this.已装备) return false;
                if (当前激活卷轴列表.has(this)) {
                    恢复卷轴模式();
                    当前激活卷轴列表.delete(this);
                    this.卸下();
                }
                let ret = super.取消装备();
                document.getElementById("卷轴按钮").style.display = [
                    ...玩家装备.values(),
                ].some((item) => item.类型 === "卷轴")
                    ? "flex"
                    : "none";
                return ret;
            }
            卸下() {
                return true;
            }
            获取提示() {
                if (this.自定义数据.get("已解锁")) {
                    return [
                        `${this.获取名称()} `,
                        `品质：${"★".repeat(this.品质)} `,
                        `能量消耗：${this.最终能量消耗} `,
                        `效果描述：${this.效果描述} `,
                    ].join("\n");
                } else {
                    return "古老的卷轴，似乎透露着什么秘密...";
                }
            }
        }
        class 防御装备类 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "防御装备",
                    名称: 配置.名称 || "护甲模板",
                    图标: 配置.图标 || "🛡️",
                    品质: 配置.品质 || 2,
                    颜色索引: 配置.品质 - 1 || 1,
                    最大堆叠数量: 1,
                    堆叠数量: 配置.堆叠数量 || 1,
                    效果描述: 配置.效果描述 || null,
                    强化: 配置.强化 || false,
                    数据: {

                        防御力: 配置.防御力 || 1,
                        耐久: 配置.耐久 || 100,
                        原耐久: 配置.耐久 || 100,
                        不可破坏: 配置.不可破坏 || false,
                        附魔: [],
                        ...配置.数据,
                    },
                });
            }
            使用() {
                return false;
            }
            get 最终防御力() {
                return this.自定义数据.get("防御力") + (this.强化 ? 2 : 0) + (this.自定义数据.get("附魔").find((item) => item.种类 === "保护附魔")?.等级 || 0);
            }
            get 耐久消耗() {
                if (this.自定义数据.get("不可破坏")) return 0;
                if (this.自定义数据.get("附魔").find((item) => item.种类 === "耐久附魔")?.等级 > 0) return 1 / (this.自定义数据.get("附魔").find((item) => item.种类 === "耐久附魔")?.等级 + 1) * (this.强化 ? 0.5 : 1);
                return this.强化 ? 0.5 : 1;
            }
            get 反伤() {
                if (this.自定义数据.get("附魔").find((item) => item.种类 === "荆棘附魔")?.等级 > 0) {
                    return this.自定义数据.get("附魔").find((item) => item.种类 === "荆棘附魔")?.等级 * 1.5;
                }
                return 0;
            }
            当被攻击(原始攻击力, 来源 = null) {
                // 基础防御计算
                let 最终伤害 = Math.max(0, 原始攻击力 - this.最终防御力);
                if (来源 === "炸弹" && this.自定义数据.get("附魔").some((item) => item.种类 === "爆炸保护附魔" && item.等级 > 0)) {
                    最终伤害 = Math.max(0, 原始攻击力 - (this.自定义数据.get("附魔").find((item) => item.种类 === "爆炸保护附魔")?.等级 * 5));
                }
                if (来源 instanceof 怪物 && this.自定义数据.get("附魔").some((item) => item.种类 === "火焰附魔" && item.等级 > 0)) {
                    const 火焰状态 = new 状态效果("火焰", "#CC5500", "火", this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔")?.等级, null, null, 来源);
                }

                if (最终伤害 <= 0) 最终伤害 = Math.round(Math.random() * 100) / 100;

                // 耐久消耗
                this.自定义数据.set(
                    "耐久",
                    this.自定义数据.get("耐久") - this.耐久消耗
                );
                if (this.反伤 > 0 && 来源 instanceof 怪物) {
                    来源.受伤(this.反伤, "玩家");
                    添加日志(`${this.名称} 因荆棘造成了 ${this.反伤} 点伤害！`, "成功");
                }
                // 自动销毁逻辑
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }

                return 最终伤害;
            }

            获取提示() {
                if (this.效果描述 !== null) {
                    return [
                        `${this.获取名称()} `,
                        `防御力：${this.最终防御力} `,
                        `耐久：${this.自定义数据.get("耐久")} `,
                        `效果描述：${this.效果描述} `,
                        获取附魔描述(this.自定义数据.get("附魔")),
                        this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                    ].join("\n");
                } else {
                    return [
                        `${this.获取名称()} `,
                        `防御力：${this.最终防御力} `,
                        `耐久：${this.自定义数据.get("耐久")} `,
                        `品质：${"★".repeat(this.品质)} `,
                        获取附魔描述(this.自定义数据.get("附魔")),
                        this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                    ].join("\n");
                }
            }
        }
        class 吸血剑 extends 武器类 {
            constructor(配置) {
                super({
                    名称: "吸血剑",
                    图标: 图标映射.吸血剑,
                    品质: 2,
                    基础攻击力: 6,
                    冷却回合: 3,
                    攻击范围: 1,
                    耐久: 配置?.耐久 || 80,
                    强化: 配置?.强化 || false,
                    效果描述: "攻击时有概率恢复造成伤害一定比例的生命值。",
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {
                        // --- 吸血特定数据 ---
                        吸血概率: 0.7,
                        吸血比例: 0.25,
                    },
                });
            }

            使用(目标怪物列表, 目标路径) {
                const 总有效伤害 = super.使用(目标怪物列表, 目标路径);
                if (总有效伤害 > 0) {
                    // 执行吸血逻辑
                    if (Math.random() < this.自定义数据.get('吸血概率')) {
                        const 吸血量 = Math.ceil(总有效伤害 * this.自定义数据.get('吸血比例'));
                        const 生命条 = document.querySelector(".health-bar");
                        const 当前宽度 = parseFloat(生命条.style.width) || 0;
                        const 新宽度 = Math.min(100, 当前宽度 + 吸血量);
                        if (新宽度 > 当前宽度) {
                            生命条.style.width = `${新宽度}%`;
                            显示通知(`${this.名称} 吸取了 ${吸血量.toFixed(0)} 点生命！`, "成功");
                            触发HUD显示();
                        }
                    }
                    return true;
                }

                return false;
            }

            获取提示() {
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `范围：${this.自定义数据.get("攻击范围")} 格`,
                    `效果：${(this.自定义数据.get('吸血概率') * 100).toFixed(0)}%概率吸取造成伤害${(this.自定义数据.get('吸血比例') * 100).toFixed(0)}%的生命`,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 棋子 extends 物品 {
            constructor(配置) {
                super({
                    类型: "棋子",
                    名称: 配置.名称 || "棋子",
                    图标: 配置.图标,
                    品质: 1,
                    颜色索引: 2,
                    最大堆叠数量: 1,
                    效果描述: "使用可以在玩家位置落子，按互动键可以提子",
                    ...配置,
                });
                this.能否拾起 = true;
            }


            可攻击位置(x, y, 棋盘) {
                return [];
            }
            使用(玩家使用 = true, x0 = 0, y0 = 0) {
                super.使用();
                if (玩家使用) {
                    if (房间列表[房间地图[玩家.y][玩家.x]].类型 === "解谜棋盘") {
                        let ret = 玩家放置物品(this, false);
                        更新装备显示();
                        更新背包显示();
                        检查解谜是否成功(房间列表[房间地图[玩家.y][玩家.x]].棋子数量);
                        显示通知("落子成功", "成功")
                        return ret;
                    }

                }
                return false;
            }
        }

        class 国际象棋车 extends 棋子 {
            constructor(配置 = {}) {
                super({
                    名称: "国际象棋车",
                    图标: "♜",
                    ...配置,
                });
            }
            可攻击位置(x, y, 棋盘) {
                const 攻击位置 = [];
                const 棋盘大小 = 棋盘.length;


                for (let i = 0; i < 棋盘大小; i++) {
                    if (i !== x) 攻击位置.push({ x: i, y: y });
                }


                for (let j = 0; j < 棋盘大小; j++) {
                    if (j !== y) 攻击位置.push({ x: x, y: j });
                }

                return 攻击位置;
            }

        }

        class 国际象棋马 extends 棋子 {
            constructor(配置 = {}) {
                super({
                    名称: "国际象棋马",
                    图标: "♞",
                    ...配置,
                });
            }

            可攻击位置(x, y, 棋盘) {
                const 攻击位置 = [];
                const 棋盘大小 = 棋盘.length;
                const dx = [-2, -2, -1, -1, 1, 1, 2, 2];
                const dy = [-1, 1, -2, 2, -2, 2, -1, 1];
                for (let i = 0; i < 8; i++) {
                    const 新x = x + dx[i];
                    const 新y = y + dy[i];
                    if (新x >= 0 && 新x < 棋盘大小 && 新y >= 0 && 新y < 棋盘大小) {
                        攻击位置.push({ x: 新x, y: 新y });
                    }
                }
                return 攻击位置;
            }
        }

        class 国际象棋象 extends 棋子 {
            constructor(配置 = {}) {
                super({
                    名称: "国际象棋象",
                    图标: "♝",
                    ...配置,
                });
            }

            可攻击位置(x, y, 棋盘) {
                const 攻击位置 = [];
                const 棋盘大小 = 棋盘.length;


                const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (const [dx, dy] of directions) {
                    for (let i = 1; i < 棋盘大小; i++) {
                        const 新x = x + i * dx;
                        const 新y = y + i * dy;

                        if (新x >= 0 && 新x < 棋盘大小 && 新y >= 0 && 新y < 棋盘大小) {
                            攻击位置.push({ x: 新x, y: 新y });
                        } else {
                            break;
                        }
                    }
                }

                return 攻击位置;
            }
        }

        class 中国象棋炮 extends 棋子 {
            constructor(配置 = {}) {
                super({
                    名称: "中国象棋炮",
                    图标: "♚",
                    ...配置,
                });
            }

            可攻击位置(x, y, 棋盘) {
                const 攻击位置 = [];
                const 棋盘大小 = 棋盘.length;


                const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                for (const [dx, dy] of directions) {
                    let 隔子 = false;
                    for (let i = 1; i < 棋盘大小; i++) {
                        const 新x = x + i * dx;
                        const 新y = y + i * dy;

                        if (新x >= 0 && 新x < 棋盘大小 && 新y >= 0 && 新y < 棋盘大小) {
                            if (棋盘[新y][新x] !== 0) {
                                if (!隔子) {
                                    隔子 = true;
                                } else {
                                    攻击位置.push({ x: 新x, y: 新y });
                                    break;
                                }
                            } else if (!隔子) {
                                攻击位置.push({ x: 新x, y: 新y });
                            }
                        } else {
                            break;
                        }
                    }
                }

                return 攻击位置;
            }
        }
        class 药水类 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "药水",
                    名称: 配置.名称 || "基础药水",
                    图标: 配置.图标 || 图标映射.药水,
                    品质: 配置.品质 || 3,
                    颜色索引: 效果名称编号映射[配置.效果类型] || 0,
                    堆叠数量: 配置.堆叠数量 || 1,
                    最大堆叠数量: 16,
                    效果描述: 配置.效果描述 || null,
                    强化: 配置.强化 || false,
                    数据: {

                        基础持续时间: 配置.持续时间 || 3,
                        效果强度: 配置.效果强度 || 1,
                        效果类型: 配置.效果类型 || null,
                        ...配置.数据,
                    },
                });
                this.激活中 = false;
                this.状态效果 = null;
            }
            获取名称() {
                let 基础名称 = super.获取名称();
                if (this.自定义数据?.get("是否冻结")) {
                    基础名称 += " [冻]";
                }
                return 基础名称;
            }
            使用() {
                if (this.自定义数据?.get("是否冻结")) {
                    return false;
                }
                this.是否隐藏 = true;
                if (this.激活中) {
                    显示通知(
                        `${this.自定义数据.get("效果类型")} 效果已存在`,
                        "错误"
                    );
                    return false;
                }

                // 应用效果
                this.激活中 = true;

                this.状态效果 = new 状态效果(this.自定义数据.get("效果类型"), this.获取药水颜色(), this.图标, this.持续时间, this.持续时间, this);

                // 应用实际效果
                this.应用效果();
                绘制();
                显示通知(`${this.名称} 效果生效！`, "成功");
                return true;
            }

            获取药水颜色() {
                return 效果颜色编号映射[this.颜色索引] || "#FFFFFF";
            }

            应用效果() {
                // 子类在这实现自定义效果...
                return;
            }

            移除效果() {
                //只考虑药水具有单一效果
                this.激活中 = false;
                super.使用();
                // 移除HUD元素
                // 子类在这还原效果...
                return;
            }

            获取提示() {
                return [
                    super.获取提示(),
                    `效果类型: ${this.自定义数据.get("效果类型")} `,
                    `持续时间: ${this.持续时间} 回合`,
                    `强度: +${this.强度} `,
                ].join("\n");
            }
            get 强度() {
                return (
                    this.自定义数据.get("效果强度") + (this.强化 ? 2 : 0)
                );
            }
            get 持续时间() {
                return (
                    this.自定义数据.get("基础持续时间") +
                    (this.强化 ? 2 : 0)
                );
            }
            get 颜色表() {
                return 效果颜色编号映射;
            }
        }

        class 治疗药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "治疗药水",
                    效果类型: "治疗",
                    持续时间: 5,
                    效果强度: 2,
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                const 当前生命 =
                    parseFloat(
                        document.querySelector(".health-bar").style.width
                    ) || 0;
                document.querySelector(
                    ".health-bar"
                ).style.width = `${Math.min(
                    100,
                    当前生命 + 4 * this.强度 //实际强度由getter决定
                )
                }% `;
                return;
            }
            移除效果() {
                super.移除效果();
                return;
            }
        }

        class 能量药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "能量药水",
                    效果类型: "能量",
                    持续时间: 5,
                    效果强度: 2,
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                const 当前能量 =
                    parseFloat(
                        document.querySelector(".power-bar").style.width
                    ) || 0;
                document.querySelector(
                    ".power-bar"
                ).style.width = `${Math.min(
                    100,
                    当前能量 + 5 * this.强度
                )
                }% `;
                return;
            }
            移除效果() {
                super.移除效果();
                return;
            }
        }
        class 狂暴药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "狂暴药水",
                    效果类型: "狂暴",
                    持续时间: 10,
                    效果强度: 1,
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                玩家属性.攻击加成 = 2 + 5 * this.强度;
                return;
            }
            移除效果() {
                玩家属性.攻击加成 = 0;
                super.移除效果();
                return;
            }
        }
        class 神龟药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "神龟药水",
                    效果类型: "神龟",
                    持续时间: 20,
                    效果强度: 1,
                    效果描述: "给予你赛尔达飞艇级别的防御",
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                玩家属性.防御加成 = 2 + 5 * this.强度;
                return;
            }
            移除效果() {
                玩家属性.防御加成 = 0;
                super.移除效果();
                return;
            }
        }
        class 隐身药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "隐身药水",
                    效果类型: "隐身",
                    持续时间: 35,
                    效果强度: 1,
                    效果描述: "悄悄滴进村，打枪滴不要。怪物视距全部变为 1",
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                处理怪物回合();
                return; // 在 处理怪物回合 中检测了 玩家状态 来实现
            }
            移除效果() {
                super.移除效果();
                return;
            }
        }
        class 透视药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "透视药水",
                    效果类型: "透视",
                    持续时间: 50,
                    效果强度: 1,
                    效果描述: "透过迷雾，看清房内的陷阱",
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                玩家属性.透视 = true;
                绘制();
                return;
            }
            移除效果() {
                玩家属性.透视 = false;
                super.移除效果();
                return;
            }
        }
        class 冰霜法杖 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "冰霜法杖",
                    图标: 图标映射.冰霜法杖,
                    品质: 3,
                    基础攻击力: 6,
                    冷却回合: 7,
                    攻击范围: 3,
                    耐久: 配置?.耐久 || 45,
                    强化: 配置?.强化 || false,
                    效果描述: "释放一圈冰霜能量，对范围内的敌人造成伤害并有几率冻结。",
                    攻击目标数: 99,
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {

                        冻结几率: 0.75 + (配置?.强化 ? 0.15 : 0),
                        冻结回合: 2,
                        ...配置.数据,
                    },
                });
            }

            使用(目标怪物列表) {
                if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return 0;

                const 范围 = this.自定义数据.get("攻击范围");
                const 击中怪物 = new Set();
                let 总有效伤害 = 0;
                const 影响格子分层 = Array.from({ length: 范围 + 1 }, () => []);

                const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0 }];
                const 已访问 = new Set();
                影响格子分层[0].push();

                while (队列.length > 0) {
                    const 当前 = 队列.shift();
                    if (当前.距离 >= 范围) continue;

                    const 方向 = [{ dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 }];

                    for (const { dx, dy } of 方向) {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;
                        const 位置键 = `${新X},${新Y}`;

                        if (新X >= 0 && 新X < 地牢大小 && 新Y >= 0 && 新Y < 地牢大小 && !已访问.has(位置键)) {
                            if (检查视线(玩家.x, 玩家.y, 新X, 新Y, 范围 + 1)) {
                                已访问.add(位置键);
                                const 新距离 = 当前.距离 + 1;
                                影响格子分层[新距离].push({ x: 新X, y: 新Y });
                                队列.push({ x: 新X, y: 新Y, 距离: 新距离 });

                                const 单元格 = 地牢[新Y][新X];
                                if (单元格?.关联怪物 instanceof 怪物 && 单元格.关联怪物.当前生命值 > 0) {
                                    const 怪物 = 单元格.关联怪物;
                                    if (!击中怪物.has(怪物)) {
                                        击中怪物.add(怪物);
                                        const 原始血量 = 怪物.当前生命值;
                                        怪物.受伤(this.攻击力, "玩家");
                                        const 实际伤害 = 原始血量 - 怪物.当前生命值;
                                        if (实际伤害 > 0) 总有效伤害 += 实际伤害;

                                        if (怪物.当前生命值 > 0 && Math.random() < this.自定义数据.get("冻结几率")) {
                                            new 状态效果("冻结", "#2196F3", "冻", this.自定义数据.get("冻结回合"), null, null, 怪物);
                                            添加日志(`${怪物.类型} 被冰霜法杖冻结了！`, '警告');
                                        }
                                    }
                                } else if (单元格.关联物品 instanceof 炸弹) {
                                    if (!单元格.关联物品.能否拾起) {
                                        单元格.关联物品.自定义数据.set("倒计时", 单元格.关联物品.自定义数据.get("爆炸时间"));
                                        单元格.关联物品.能否拾起 = true;
                                        所有计时器 = 所有计时器.filter((item) => item !== 单元格.关联物品);
                                        单元格.关联物品.x = null;
                                        单元格.关联物品.y = null;
                                        添加日志("炸弹已被熄灭！", "信息");
                                    }
                                } else if (单元格.关联物品 instanceof 火焰物品) {
                                    单元格.关联物品 = null;
                                    单元格.类型 = null;
                                    单元格.颜色索引 = 颜色表.length;
                                }
                            }
                        }
                    }
                }

                影响格子分层.forEach((层内格子, 层级) => {
                    if (层内格子.length > 0) {
                        setTimeout(() => {
                            计划显示格子特效(层内格子, 'ADD8E6', 0);
                        }, 层级 * 80);
                    }
                });


                this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }
                this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));

                if (击中怪物.size > 0) {
                    显示通知(`${this.名称} 释放了冰霜！击中 ${击中怪物.size} 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");
                    const 所有击中怪物 = Array.from(击中怪物);

                    if (总有效伤害 > 0) {
                        this.触发通用附魔(所有击中怪物);
                    }
                } else {
                    显示通知(`${this.名称} 释放了冰霜！`, "信息");
                }
                绘制();
                更新装备显示();
                return 总有效伤害;
            }

            触发通用附魔(目标怪物列表) {
                if (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级) {
                    const 火焰等级 = this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔").等级;
                    目标怪物列表.forEach(怪物 => {
                        if (怪物.当前生命值 > 0) {
                            new 状态效果("火焰", "#CC5500", "火", 火焰等级, null, null, 怪物);
                        }
                    });
                }
                const 连锁附魔 = this.自定义数据.get("附魔")?.find(item => item.种类 === "连锁附魔");
                if (连锁附魔) {
                    const 连锁距离 = 连锁附魔.等级;
                    目标怪物列表.forEach(初始目标 => {
                        if (初始目标.当前生命值 > 0) {
                            this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                        }
                    });
                }
            }

            获取提示() {
                const 范围 = this.自定义数据.get("攻击范围");
                const 冻结几率 = this.自定义数据.get('冻结几率');
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `范围：${范围} 格半径`,
                    `冻结几率：${(冻结几率 * 100).toFixed(0)}%`,
                    `效果：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 荆棘种子 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "消耗品",
                    名称: "荆棘种子",
                    图标: 图标映射.荆棘种子,
                    品质: 1,
                    颜色索引: 0, // 绿色系
                    堆叠数量: 配置.数量 || Math.ceil(Math.random() * 5),
                    最大堆叠数量: 16,
                    效果描述: "在相邻空格子播种，生成持续数回合的荆棘丛。",
                    强化: 配置.强化 || false, // 强化可能增加荆棘伤害或持续时间
                    数据: {
                        荆棘持续时间: 5 + (配置.强化 ? 3 : 0),
                        荆棘伤害: 3 + (配置.强化 ? 2 : 0),
                        减速概率: 0.6 + (配置.强化 ? 0.1 : 0),
                        减速回合: 7,
                        ...配置.数据,
                    },
                    ...配置
                });
            }

            使用() {
                if (this.堆叠数量 <= 0) return false;

                const 方向数组 = [{ dx: 0, dy: 0 }, { dx: 0, dy: -1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }];
                let 放置成功 = false;
                let 目标X = -1, 目标Y = -1;

                // 查找玩家周围可放置的格子
                for (const { dx, dy } of 方向数组) {
                    const 检查X = 玩家.x + dx;
                    const 检查Y = 玩家.y + dy;
                    if (检查X >= 0 && 检查X < 地牢大小 && 检查Y >= 0 && 检查Y < 地牢大小 &&
                        位置是否可用(检查X, 检查Y, false) ||
                        !检查直线移动可行性(玩家.x, 玩家.y, 检查X, 检查Y, true)) // 检查格子是否为空地
                    {
                        目标X = 检查X;
                        目标Y = 检查Y;
                        放置成功 = true;
                        break; // 找到第一个可用格子就放置
                    }
                }

                if (!放置成功) {
                    显示通知("周围没有合适的地方播种！", "错误");
                    return false;
                }

                // 创建荆棘丛实例
                const 荆棘丛实例 = new 荆棘丛({
                    倒计时: this.自定义数据.get("荆棘持续时间"),
                    爆炸时间: this.自定义数据.get("荆棘持续时间"), // 复用
                    伤害: this.自定义数据.get("荆棘伤害"),
                    减速概率: this.自定义数据.get("减速概率"),
                    减速回合: this.自定义数据.get("减速回合"),
                    强化: this.强化 // 传递强化状态给荆棘丛
                });

                // 放置荆棘丛到地牢
                if (放置物品到单元格(荆棘丛实例, 目标X, 目标Y)) {
                    荆棘丛实例.x = 目标X; // 确保实例有坐标
                    荆棘丛实例.y = 目标Y;
                    所有计时器.push(荆棘丛实例); // 加入计时器列表使其能自动消失
                    显示通知(`在 (${目标X}, ${目标Y}) 种下了荆棘丛！`, "成功");

                    // 消耗种子
                    this.堆叠数量 -= 1;

                    计划显示格子特效([{ x: 目标X, y: 目标Y }], "228B22"); // 深绿色特效
                    return true;
                } else {
                    显示通知("无法放置荆棘丛！", "错误");
                    return false;
                }
            }

            获取提示() {
                return [
                    `${this.获取名称()} `,
                    `类型：${this.类型}`,
                    `品质：${"★".repeat(this.品质)}`,
                    `堆叠：${this.堆叠数量} / ${this.最大堆叠数量}`,
                    `效果：${this.效果描述}`,
                    `荆棘持续：${this.自定义数据.get('荆棘持续时间')} 回合`,
                    `进入伤害：${this.自定义数据.get('荆棘伤害')} 点`,
                    `减速几率：${(this.自定义数据.get('减速概率') * 100).toFixed(0)}% (${this.自定义数据.get('减速回合')}回合)`,
                ].join("\n");
            }
        }

        class 荆棘丛 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "地形", // 标记为地形，不可交互
                    名称: "荆棘丛",
                    图标: 图标映射.荆棘丛, // 仙人掌图标
                    品质: 1,
                    颜色索引: 0,
                    最大堆叠数量: 1,
                    能否拾起: false,
                    阻碍怪物: false, // 不阻挡移动
                    是否正常物品: false,
                    是否为隐藏物品: false, // 地图上可见
                    效果描述: "进入时会受到伤害并可能减速。",
                    数据: {
                        倒计时: 配置.倒计时 ?? 7,
                        爆炸时间: 配置.倒计时 ?? 7, // 复用计时器接口
                        伤害: 配置.伤害 ?? 3,
                        减速概率: 配置.减速概率 ?? 0.3,
                        减速回合: 配置.减速回合 ?? 2,
                        // 可以添加一个 '来源玩家' 标记，避免玩家自己被自己的荆棘伤害？
                    },
                    ...配置
                });
                // 创建时自动加入计时器 (由荆棘种子类负责)
            }

            使用() { return false; } // 不能使用

            // 当玩家或其他实体“尝试收集”（即进入）时触发
            当被收集(进入者) { // 参数现在代表进入的实体
                // 检查进入者类型，应用效果
                const 伤害量 = this.自定义数据.get('伤害');
                if (进入者 === 玩家) {
                    伤害玩家(伤害量, this.名称);
                    添加日志("你踩进了荆棘丛！", "错误");
                    // 概率触发减速
                    if (Math.random() < this.自定义数据.get('减速概率')) {
                        new 状态效果("缓慢", 效果颜色编号映射[效果名称编号映射.缓慢], 图标映射.缓慢, this.自定义数据.get('减速回合'), null, null, null, 1);
                        添加日志("你被荆棘缠绕，移动变慢了！", "错误");
                    }
                }
                // 注意：怪物的效果在 怪物.处理地形效果 中处理

                return false; // 不可被收集
            }

            更新倒计时() {
                const 剩余回合 = this.自定义数据.get("倒计时");
                if (剩余回合 <= 0) {
                    this.移除自身();
                } else {
                    this.自定义数据.set("倒计时", 剩余回合 - 1);
                }
            }

            移除自身() {
                if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
                    地牢[this.y][this.x].关联物品 = null;
                    if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品) 地牢[this.y][this.x].类型 = null;
                    地牢[this.y][this.x].颜色索引 = 颜色表.length; // 重置颜色
                }
                所有计时器 = 所有计时器.filter(item => item !== this);
                绘制(); // 更新画面
            }

            获取提示() {
                return [
                    `${this.获取名称()}`,
                    `类型：${this.类型}`,
                    `剩余时间：${this.自定义数据.get("倒计时")} 回合`,
                    `进入伤害：${this.自定义数据.get('伤害')} 点`,
                    `减速几率：${(this.自定义数据.get('减速概率') * 100).toFixed(0)}% (${this.自定义数据.get('减速回合')}回合)`,
                    `${this.效果描述}`,
                ].join("\n");
            }
        }



        // --- 实现 能量熔炉 类 ---
        class 能量熔炉 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "工具",
                    名称: "能量熔炉",
                    图标: "⚙️",
                    品质: 3,
                    颜色索引: 4,
                    最大堆叠数量: 1,
                    效果描述: "消耗能量，少量修复所有已装备物品的耐久。",
                    强化: 配置.强化 || false, // 强化降低消耗或增加修复量
                    数据: {
                        能量消耗: 90 - (配置.强化 ? 15 : 0),
                        修复比例: 0.1 + (配置.强化 ? 0.05 : 0), // 修复最大耐久的10%，强化+5%
                        固定修复量: 5 + (配置.强化 ? 3 : 0), // 或至少修复5点，强化+3
                    },
                    ...配置
                });
            }

            使用() {

                if (!卷轴扣除能量(this.自定义数据.get('能量消耗'))) { // 调用基类卷轴的能量消耗方法
                    显示通知("能量不足！", "错误");
                    return false;
                }

                let 修复发生 = false;
                玩家装备.forEach(装备 => {
                    if (装备.自定义数据?.has("耐久") && 装备.自定义数据?.has("原耐久")) {
                        const 当前耐久 = 装备.自定义数据.get("耐久");
                        const 最大耐久 = 装备.自定义数据.get("原耐久");
                        if (当前耐久 < 最大耐久) {
                            const 按比例修复 = Math.ceil(最大耐久 * this.自定义数据.get("修复比例"));
                            const 实际修复量 = Math.max(this.自定义数据.get("固定修复量"), 按比例修复);
                            const 新耐久 = Math.min(最大耐久, 当前耐久 + 实际修复量);
                            if (新耐久 > 当前耐久) {
                                装备.自定义数据.set("耐久", 新耐久);
                                修复发生 = true;
                                添加日志(`${装备.获取名称()} 被修复了 ${新耐久 - 当前耐久} 点耐久。`, "成功");
                            }
                        }
                    }
                });

                if (修复发生) {
                    显示通知(`${this.获取名称()} 修复了装备！`, "成功");
                    更新装备显示(); // 更新UI
                } else {
                    显示通知(`${this.获取名称()} 发动了，但没有装备需要修复。`, "信息");
                }


                更新装备显示(); // 更新冷却显示（如果装备栏显示冷却）
                return true;
            }


            获取提示() {
                let 基础提示 = super.获取提示();
                基础提示 = 基础提示.replace(/堆叠：.*\n/, ''); // 移除堆叠信息
                const 能量消耗 = this.自定义数据.get('能量消耗');
                const 修复比例 = (this.自定义数据.get('修复比例') * 100).toFixed(0);
                const 固定修复 = this.自定义数据.get('固定修复量');

                return [
                    基础提示,
                    `---`,
                    `能量消耗：${能量消耗}`,
                    `修复效果：恢复最大耐久${修复比例}% (至少${固定修复}点)`,
                ].join("\n");
            }
        }
        class 引雷针护符 extends 防御装备类 {
            constructor(配置 = {}) {
                super({
                    名称: "引雷针护符",
                    图标: 图标映射.引雷针护符,
                    品质: 2,
                    颜色索引: 3,
                    防御力: 1,
                    耐久: 配置.耐久 || 35 + (配置.强化 ? 10 : 0),
                    原耐久: 配置.原耐久 || 35 + (配置.强化 ? 10 : 0),
                    强化: 配置.强化 || false,
                    不可破坏: false,
                    数据: {
                        充能概率: 0.6 + (配置.强化 ? 0.15 : 0),
                        充能持续时间: 3 + (配置.强化 ? 2 : 0),
                        充能攻击加成值: 2 + (配置.强化 ? 2 : 0), // 存储具体加成值
                        能量恢复量: 15 + (配置.强化 ? 15 : 0),
                    },
                    ...配置
                });
            }

            当被攻击(原始攻击力, 来源 = null) {
                if (来源 === "雷暴" && this.自定义数据.get("耐久") > 0) {
                    super.当被攻击(原始攻击力, 来源);
                    添加日志(`${this.名称} 吸收了落雷！`, "成功");
                    const 现有效果 = 玩家状态.find(s => s.来源 === this && s.类型 === '充能');
                    // 概率触发充能或恢复能量
                    if (Math.random() < this.自定义数据.get("充能概率") && !现有效果) {
                        const 持续时间 = this.自定义数据.get("充能持续时间");
                        const 加成值 = this.自定义数据.get("充能攻击加成值");
                        // 如果没有，创建新的状态效果
                        const 新效果 = new 状态效果(
                            "充能",
                            效果颜色编号映射[效果名称编号映射.充能],
                            "⚡",
                            持续时间,
                            null,
                            this, // 来源是护符实例
                            null, // 关联玩家
                            加成值 // 强度代表加成值，但主要由护符的 应用/移除 逻辑使用
                        );
                        玩家属性.攻击加成 += 加成值;
                        显示通知("你感到了电流的涌动，攻击力提升！", "成功");
                    } else {
                        // 恢复能量 (逻辑不变)
                        const 恢复量 = this.自定义数据.get("能量恢复量");
                        const 能量条 = document.querySelector(".power-bar");
                        const 当前能量 = parseFloat(能量条.style.width) || 0;
                        能量条.style.width = `${Math.min(100, 当前能量 + 恢复量)}%`;
                        显示通知(`护符转化雷电，恢复了 ${恢复量} 点能量！`, "成功");
                        触发HUD显示();
                    }
                    return 0; // 拦截成功
                }
                return super.当被攻击(原始攻击力, 来源);
            }
            应用效果(){
            return;
            }
            移除效果() {
                const 加成值 = this.自定义数据.get("充能攻击加成值");
                const 对应效果 = 玩家状态.find(s => s.来源 === this && s.类型 === '充能');
                if (对应效果 && 加成值 > 0) {
                    玩家属性.攻击加成 -= 加成值;
                }
            }

            获取提示() {
                let 基础提示 = super.获取提示();
                基础提示 = 基础提示.replace(/防御力：.*\n/, '');
                基础提示 = 基础提示.replace(/效果描述：.*\n/, '');

                const 充能概率 = (this.自定义数据.get('充能概率') * 100).toFixed(0);
                const 攻击加成 = this.自定义数据.get('充能攻击加成值');
                const 持续 = this.自定义数据.get('充能持续时间');
                const 能量恢复 = this.自定义数据.get('能量恢复量');
                // 查找当前是否有此护符产生的效果来显示剩余时间
                const 当前效果 = 玩家状态.find(s => s.来源 === this && s.类型 === '充能');
                const 剩余 = 当前效果 ? 当前效果.剩余回合 : 0;

                let 效果详情 = `---\n`;
                效果详情 += `拦截落雷消耗 1 耐久\n`;
                效果详情 += `${充能概率}%几率获得[充能](${持续}回合, +${攻击加成}攻击力)\n`;
                效果详情 += `否则恢复 ${能量恢复} 能量`;
                if (剩余 > 0) {
                    效果详情 += `\n充能剩余：${剩余}回合`;
                }

                return [
                    基础提示,
                    效果详情
                ].join("\n");
            }
        }
        class 重力锤 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "重力锤",
                    图标: 图标映射.重力锤,
                    品质: 4,
                    基础攻击力: 12,
                    冷却回合: 11,
                    攻击范围: 3 + (配置.强化 ? 2 : 0),
                    耐久: 配置?.耐久 || 60,
                    强化: 配置?.强化 || false,
                    效果描述: "猛击地面，将范围内的敌人拉向自己，然后造成范围伤害。",
                    攻击目标数: 99,
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {

                        伤害范围: 1 + (配置.强化 ? 2 : 0),
                        ...配置.数据,
                    },
                });
            }

            使用(目标怪物列表) {
                if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return 0;

                const 拉取范围 = this.自定义数据.get("攻击范围");
                const 伤害范围 = this.自定义数据.get("伤害范围");
                const 被拉取怪物 = new Set();
                const 拉取路径可视化 = [];

                for (let dx = -拉取范围; dx <= 拉取范围; dx++) {
                    for (let dy = -拉取范围; dy <= 拉取范围; dy++) {
                        const x = 玩家.x + dx;
                        const y = 玩家.y + dy;

                        if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
                            const 单元格 = 地牢[y][x];
                            const 怪物 = 单元格?.关联怪物;
                            if (怪物 && 怪物.当前生命值 > 0 && 怪物.状态 === 怪物状态.活跃) {
                                let 拉到X = 玩家.x;
                                let 拉到Y = 玩家.y;
                                let 最近距离 = Infinity;
                                let 找到位置 = false;
                                let 移动路径 = null;

                                for (let pdx = -1; pdx <= 1; pdx++) {
                                    for (let pdy = -1; pdy <= 1; pdy++) {
                                        if (pdx === 0 && pdy === 0) continue;
                                        const 目标X = 玩家.x + pdx;
                                        const 目标Y = 玩家.y + pdy;
                                        if (目标X >= 0 && 目标X < 地牢大小 && 目标Y >= 0 && 目标Y < 地牢大小 &&
                                            位置是否可用(目标X, 目标Y, true) &&
                                            检查视线(怪物.x, 怪物.y, 目标X, 目标Y, 拉取范围 + 2)) {
                                            const 距离 = Math.abs(目标X - 怪物.x) + Math.abs(目标Y - 怪物.y);
                                            if (距离 < 最近距离) {
                                                const 路径 = 广度优先搜索路径(怪物.x, 怪物.y, 目标X, 目标Y, 拉取范围 + 2, true);
                                                if (路径 && 路径.length > 1) {
                                                    最近距离 = 距离;
                                                    拉到X = 目标X;
                                                    拉到Y = 目标Y;
                                                    移动路径 = 路径;
                                                    找到位置 = true;
                                                }
                                            }
                                        }
                                    }
                                }

                                if (找到位置 && !(怪物.x === 拉到X && 怪物.y === 拉到Y)) {
                                    被拉取怪物.add(怪物);
                                    拉取路径可视化.push(移动路径.slice(1));

                                    怪物.恢复背景类型();
                                    怪物.x = 拉到X;
                                    怪物.y = 拉到Y;
                                    怪物.保存新位置类型(拉到X, 拉到Y);
                                    地牢[拉到Y][拉到X].类型 = 单元格类型.怪物;
                                    地牢[拉到Y][拉到X].关联怪物 = 怪物;
                                }
                            }
                        }
                    }
                }
                if (拉取路径可视化.length <= 0) return 0;
                拉取路径可视化.forEach((路径, index) => {
                    setTimeout(() => {
                        计划显示格子特效(路径.slice().reverse(), '9400D3');
                    }, index * 50);
                });


                let 总有效伤害 = 0;
                const 击中怪物 = new Set();
                const 伤害格子 = [];

                setTimeout(() => {
                    for (let ddx = -伤害范围; ddx <= 伤害范围; ddx++) {
                        for (let ddy = -伤害范围; ddy <= 伤害范围; ddy++) {
                            const dmgX = 玩家.x + ddx;
                            const dmgY = 玩家.y + ddy;
                            if (dmgX >= 0 && dmgX < 地牢大小 && dmgY >= 0 && dmgY < 地牢大小) {
                                if (检查视线(玩家.x, 玩家.y, dmgX, dmgY, 伤害范围 + 1)) {
                                    伤害格子.push({ x: dmgX, y: dmgY });
                                    const 单元格 = 地牢[dmgY][dmgX];
                                    if (单元格?.关联怪物 && 单元格.关联怪物.当前生命值 > 0) {
                                        const 怪物 = 单元格.关联怪物;
                                        if (!击中怪物.has(怪物)) {
                                            击中怪物.add(怪物);
                                            const 原始血量 = 怪物.当前生命值;
                                            怪物.受伤(this.攻击力, "玩家");
                                            const 实际伤害 = 原始血量 - 怪物.当前生命值;
                                            if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    setTimeout(() => {
                        计划显示格子特效(伤害格子, 'FFA500', 0);
                    }, 拉取路径可视化[0].length * 50);


                    this.自定义数据.set("耐久", (this.自定义数据.get("耐久") - this.耐久消耗 * (被拉取怪物.size > 0 ? 1.2 : 1)).toFixed(1));
                    if (this.自定义数据.get("耐久") <= 0) {
                        处理销毁物品(this.唯一标识, true);
                        显示通知(`${this.名称} 已损坏！`, "警告");
                    }
                    this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));

                    if (被拉取怪物.size > 0 || 击中怪物.size > 0) {
                        let 消息 = `${this.名称} 发动！`;
                        if (被拉取怪物.size > 0) 消息 += ` 拉近了 ${被拉取怪物.size} 个目标。`;
                        if (击中怪物.size > 0) 消息 += ` 震击了 ${击中怪物.size} 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`;
                        显示通知(消息, "成功");

                        const 所有影响怪物 = Array.from(new Set([...被拉取怪物, ...击中怪物]));

                        if (总有效伤害 > 0) {
                            this.触发通用附魔(所有影响怪物);
                        }
                    } else {
                        显示通知(`${this.名称} 发动了，但未影响任何目标。`, "信息");
                    }

                    更新装备显示();
                    绘制();

                }, 拉取路径可视化.length * 50 + 100);


                return 1;
            }

            触发通用附魔(目标怪物列表) {
                if (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级) {
                    const 火焰等级 = this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔").等级;
                    目标怪物列表.forEach(怪物 => {
                        if (怪物.当前生命值 > 0) {
                            new 状态效果("火焰", "#CC5500", "火", 火焰等级, null, null, 怪物);
                        }
                    });
                }
                const 连锁附魔 = this.自定义数据.get("附魔")?.find(item => item.种类 === "连锁附魔");
                if (连锁附魔) {
                    const 连锁距离 = 连锁附魔.等级;
                    目标怪物列表.forEach(初始目标 => {
                        if (初始目标.当前生命值 > 0) {
                            this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                        }
                    });
                }
            }

            获取提示() {
                const 拉取范围 = this.自定义数据.get("攻击范围");
                const 伤害范围 = this.自定义数据.get("伤害范围");
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `震击攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `拉取范围：${拉取范围} 格`,
                    `震击范围：周围 ${伤害范围} 格`,
                    `效果：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 旋风物品 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "地形",
                    名称: "旋风气流",
                    图标: 图标映射.旋风物品,
                    品质: 1,
                    颜色索引: 1,
                    最大堆叠数量: 1,
                    能否拾起: false, // 不能主动拾取
                    阻碍怪物: false, // 怪物可以穿过
                    效果描述: "不稳定的气流，接触会头晕。",
                    数据: {
                        倒计时: 5, // 存在5回合
                        爆炸时间: 5, // 同上，用于计时器
                        眩晕回合: 2,
                    },
                    ...配置 // 允许覆盖默认配置
                });
            }

            使用() {
                return false;
            }

            触发爆炸() {
                this.移除自身();
            }

            当被收集(玩家) {
                new 状态效果("眩晕", 效果颜色编号映射[效果名称编号映射.眩晕], 图标映射.眩晕, this.自定义数据.get("眩晕回合"));
                显示通知("你卷入了气流，感到头晕目眩！", "警告");
                return false;
            }

            移除自身() {
                // 从地牢格子中移除
                if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
                    地牢[this.y][this.x].关联物品 = null;
                    if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品) 地牢[this.y][this.x].类型 = null; // 恢复原始格子类型
                }
                所有计时器 = 所有计时器.filter(item => item !== this);
                绘制(); // 更新画面
            }

            更新倒计时() {
                const 剩余回合 = this.自定义数据.get("倒计时");
                if (剩余回合 <= 0) { // 用 <= 0 更安全
                    this.触发爆炸(); // 时间到，移除物品
                } else {
                    this.自定义数据.set("倒计时", 剩余回合 - 1);
                }
            }
        }
        class 剧毒匕首 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "剧毒匕首",
                    图标: 图标映射.剧毒匕首,
                    品质: 1,
                    基础攻击力: 3,
                    冷却回合: 2,
                    攻击范围: 1,
                    耐久: 配置?.耐久 || 90,
                    强化: 配置?.强化 || false,
                    效果描述: "攻击附加可叠加的中毒效果，持续造成伤害。",
                    攻击目标数: 1,
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {

                        中毒强度: 2 + (配置?.强化 ? 1 : 0),
                        中毒持续时间: 5,
                        ...配置.数据,
                    },
                });
            }

            使用(目标怪物列表) {
                if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return 0;

                const 目标怪物 = 目标怪物列表[0];
                if (!目标怪物 || 目标怪物.当前生命值 <= 0) return 0;

                let 总有效伤害 = 0;
                const 原始血量 = 目标怪物.当前生命值;
                目标怪物.受伤(this.攻击力, "玩家");
                const 实际伤害 = 原始血量 - 目标怪物.当前生命值;
                if (实际伤害 > 0) 总有效伤害 += 实际伤害;

                if (目标怪物.当前生命值 > 0) {
                    new 状态效果(
                        "中毒",
                        效果颜色编号映射[效果名称编号映射.中毒],
                        "☠️",
                        this.自定义数据.get("中毒持续时间"),
                        null,
                        null,
                        目标怪物,
                        this.自定义数据.get("中毒强度")
                    );
                    添加日志(`${目标怪物.类型} 中毒了！`, '警告');
                }

                const 攻击路径 = 广度优先搜索路径(玩家.x, 玩家.y, 目标怪物.x, 目标怪物.y, this.自定义数据.get("攻击范围"), true);
                if (攻击路径 && 攻击路径.length > 1) {
                    计划显示格子特效(攻击路径.slice(1), '008000');
                }


                this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }
                this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));

                let 消息 = `${this.名称} 造成 ${总有效伤害.toFixed(1)} 点伤害`;
                if (目标怪物.当前生命值 > 0 && 怪物状态表.get(目标怪物)?.类型 === '中毒') {
                    消息 += ` 并附加了中毒效果！`;
                } else {
                    消息 += `！`;
                }
                显示通知(消息, "成功");

                [...玩家装备.values()].forEach(装备 => {
                    if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                        装备.当玩家攻击([目标怪物]);
                    }
                });
                if (总有效伤害 > 0) {
                    this.触发通用附魔([目标怪物]);
                }

                更新装备显示();
                return 总有效伤害;
            }

            触发通用附魔(目标怪物列表) {
                if (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级) {
                    const 火焰等级 = this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔").等级;
                    目标怪物列表.forEach(怪物 => {
                        if (怪物.当前生命值 > 0) {
                            new 状态效果("火焰", "#CC5500", "火", 火焰等级, null, null, 怪物);
                        }
                    });
                }
                const 连锁附魔 = this.自定义数据.get("附魔")?.find(item => item.种类 === "连锁附魔");
                if (连锁附魔) {
                    const 连锁距离 = 连锁附魔.等级;
                    目标怪物列表.forEach(初始目标 => {
                        if (初始目标.当前生命值 > 0) {
                            this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                        }
                    });
                }
            }

            获取提示() {
                const 毒强度 = this.自定义数据.get('中毒强度');
                const 毒持续 = this.自定义数据.get('中毒持续时间');
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `毒性：${毒强度}点/回合`,
                    `持续：${毒持续}回合`,
                    `效果：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 荆棘鞭 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "荆棘鞭",
                    图标: 图标映射.荆棘鞭,
                    品质: 1,
                    基础攻击力: 2,
                    冷却回合: 3,
                    攻击范围: 2,
                    耐久: 配置?.耐久 || 70,
                    强化: 配置?.强化 || false,
                    // 修改效果描述
                    效果描述: "甩出长鞭，将近处的单个敌人直线甩飞并造成少量伤害。",
                    攻击目标数: 1,
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {

                        甩飞距离: 3 + (配置?.强化 ? 1 : 0),
                        ...配置.数据,
                    },
                });
            }

            // 新增辅助函数：计算特定方向的最大甩飞距离和终点
            计算最大甩飞距离(起始X, 起始Y, 方向DX, 方向DY, 最大距离) {
                let 可行终点 = { x: 起始X, y: 起始Y };
                for (let i = 1; i <= 最大距离; i++) {
                    const 尝试X = 起始X + 方向DX * i;
                    const 尝试Y = 起始Y + 方向DY * i;

                    if (尝试X < 0 || 尝试X >= 地牢大小 || 尝试Y < 0 || 尝试Y >= 地牢大小) break;

                    // 检查从 *怪物原始位置* 到 *尝试点* 的直线路径是否通畅
                    if (!快速直线检查(起始X, 起始Y, 尝试X, 尝试Y, i)) break;

                    // 检查目标点是否可放置怪物
                    if (位置是否可用(尝试X, 尝试Y, true)) {
                        可行终点 = { x: 尝试X, y: 尝试Y };
                    }
                }
                return 可行终点;
            }


            使用(目标怪物列表) {
                if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return 0;

                if (!目标怪物列表 || 目标怪物列表.length === 0) {
                    显示通知("附近没有可甩飞的目标！", "警告");
                    return 0;
                }

                const 目标怪物 = 目标怪物列表[0];
                if (目标怪物.当前生命值 <= 0) return 0;

                const 路径 = 获取直线路径(玩家.x, 玩家.y, 目标怪物.x, 目标怪物.y);
                if (路径.length === 0 || 路径.length > this.自定义数据.get("攻击范围") + 1) {
                    显示通知("目标太远或路径被阻挡！", "警告");
                    return 0;
                }

                const dx = 目标怪物.x - 玩家.x;
                const dy = 目标怪物.y - 玩家.y;
                const 甩飞距离 = this.自定义数据.get("甩飞距离");
                let 最终X = 目标怪物.x;
                let 最终Y = 目标怪物.y;
                let 选择方向DX = 0;
                let 选择方向DY = 0;

                if (dx === 0) { // 垂直方向
                    选择方向DY = dy > 0 ? 1 : -1;
                } else if (dy === 0) { // 水平方向
                    选择方向DX = dx > 0 ? 1 : -1;
                } else { // 对角线方向
                    // 计算水平甩飞终点和距离
                    const 水平方向DX = dx > 0 ? 1 : -1;
                    const 水平终点 = this.计算最大甩飞距离(目标怪物.x, 目标怪物.y, 水平方向DX, 0, 甩飞距离);
                    const 水平距离玩家 = Math.abs(水平终点.x - 玩家.x) + Math.abs(水平终点.y - 玩家.y);

                    // 计算垂直甩飞终点和距离
                    const 垂直方向DY = dy > 0 ? 1 : -1;
                    const 垂直终点 = this.计算最大甩飞距离(目标怪物.x, 目标怪物.y, 0, 垂直方向DY, 甩飞距离);
                    const 垂直距离玩家 = Math.abs(垂直终点.x - 玩家.x) + Math.abs(垂直终点.y - 玩家.y);

                    // 选择距离玩家更远的方向
                    if (水平距离玩家 >= 垂直距离玩家) { // 水平优先或相等时选水平
                        选择方向DX = 水平方向DX;
                        选择方向DY = 0;
                    } else {
                        选择方向DX = 0;
                        选择方向DY = 垂直方向DY;
                    }
                }

                // 根据选定方向计算最终落点
                const 最终落点 = this.计算最大甩飞距离(目标怪物.x, 目标怪物.y, 选择方向DX, 选择方向DY, 甩飞距离);
                最终X = 最终落点.x;
                最终Y = 最终落点.y;


                // --- 造成伤害 ---
                let 总有效伤害 = 0;
                const 原始血量 = 目标怪物.当前生命值;
                目标怪物.受伤(this.攻击力, "玩家");

                const 实际伤害 = 原始血量 - 目标怪物.当前生命值;
                if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                if (目标怪物.当前生命值 <= 0) return 总有效伤害;

                // --- 移动怪物 (如果落点不同) ---
                if (最终X !== 目标怪物.x || 最终Y !== 目标怪物.y) {
                    目标怪物.恢复背景类型();
                    目标怪物.x = 最终X;
                    目标怪物.y = 最终Y;
                    目标怪物.保存新位置类型(最终X, 最终Y);
                    地牢[最终Y][最终X].类型 = 单元格类型.怪物;
                    地牢[最终Y][最终X].关联怪物 = 目标怪物;
                    目标怪物.处理地形效果();
                    目标怪物.绘制血条();
                    绘制();
                    显示通知(`${this.名称} 将 ${目标怪物.类型} 甩飞了，造成 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");
                } else {
                    显示通知(`${this.名称} 击中了 ${目标怪物.类型} 但未能将其甩飞，造成 ${总有效伤害.toFixed(1)} 点伤害！`, "信息");
                }

                // --- 处理消耗和冷却 ---
                this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }
                this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));

                // --- 宠物协同和附魔 ---
                if (总有效伤害 > 0) {
                    [...玩家装备.values()].forEach(装备 => {
                        if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                            装备.当玩家攻击([目标怪物]);
                        }
                    });
                    this.触发通用附魔([目标怪物]);
                }

                更新装备显示();
                return 总有效伤害;
            }

            触发通用附魔(目标怪物列表) {
                if (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级) {
                    const 火焰等级 = this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔").等级;
                    目标怪物列表.forEach(怪物 => {
                        if (怪物.当前生命值 > 0) {
                            new 状态效果("火焰", "#CC5500", "火", 火焰等级, null, null, 怪物);
                        }
                    });
                }
                const 连锁附魔 = this.自定义数据.get("附魔")?.find(item => item.种类 === "连锁附魔");
                if (连锁附魔) {
                    const 连锁距离 = 连锁附魔.等级;
                    目标怪物列表.forEach(初始目标 => {
                        if (初始目标.当前生命值 > 0) {
                            this.触发连锁(初始目标, 连锁距离, 目标怪物列表);
                        }
                    });
                }
            }

            获取提示() {
                const 范围 = this.自定义数据.get("攻击范围");
                const 甩飞距离 = this.自定义数据.get("甩飞距离");
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `作用范围：${范围} 格`,
                    `甩飞距离：${甩飞距离} 格`,
                    `效果：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 回旋镖 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "回旋镖",
                    图标: 图标映射.回旋镖,
                    品质: 2,
                    基础攻击力: 4,
                    冷却回合: 2,
                    攻击范围: 5 + (配置?.强化 ? 2 : 0), // 现在代表固定的投掷距离
                    耐久: 配置?.耐久 || 60,
                    强化: 配置?.强化 || false,
                    // 修改效果描述
                    效果描述: "沿直线投掷固定距离后返回，对路径上的敌人造成两次伤害。会被墙壁阻挡。",
                    攻击目标数: 5, // 最多穿透目标数
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {
                        ...配置.数据,
                    },
                });
            }
            // 新增：获取固定距离轴向路径并检查碰撞
            获取固定距离轴向路径(startX, startY, targetX, targetY) {
                const path = [];
                const fixedDistance = this.自定义数据.get("攻击范围");
                const dxTotal = targetX - startX;
                const dyTotal = targetY - startY;

                let currentX = startX;
                let currentY = startY;
                let dirX = 0;
                let dirY = 0;

                // 确定主方向（只允许水平或垂直）
                if (Math.abs(dxTotal) >= Math.abs(dyTotal)) { // 优先水平
                    dirX = Math.sign(dxTotal) || (Math.random() < 0.5 ? 1 : -1); // 如果目标在同列，随机左右
                    dirY = 0;
                } else { // 优先垂直
                    dirX = 0;
                    dirY = Math.sign(dyTotal) || (Math.random() < 0.5 ? 1 : -1); // 如果目标在同行，随机上下
                }

                if (dirX === 0 && dirY === 0) return []; // 无法确定方向（目标在原地？）

                for (let i = 0; i < fixedDistance; i++) {
                    const nextX = currentX + dirX;
                    const nextY = currentY + dirY;

                    // 边界检查
                    if (nextX < 0 || nextX >= 地牢大小 || nextY < 0 || nextY >= 地牢大小) {
                        break; // 撞到地图边界
                    }

                    // 墙壁或单元格墙检查
                    if (!检查移动可行性(currentX, currentY, nextX, nextY)) {
                        break; // 撞墙
                    }
                    // 检查目标单元格是否是墙壁（虽然检查移动可行性已包含，双重保险）
                    if (地牢[nextY][nextX].背景类型 === 单元格类型.墙壁) {
                        break;
                    }


                    path.push({ x: nextX, y: nextY });
                    currentX = nextX;
                    currentY = nextY;
                }

                return path;
            }

            寻找直线方向目标() {
                const 方向列表 = [
                    { dx: 0, dy: -1, 名称: "上" }, // 上
                    { dx: 0, dy: 1, 名称: "下" }, // 下
                    { dx: -1, dy: 0, 名称: "左" }, // 左
                    { dx: 1, dy: 0, 名称: "右" }  // 右
                ];
                let 最近目标坐标 = null;
                let 最小距离 = Infinity;
                const 搜索距离 = 20;

                for (const 方向 of 方向列表) {
                    let 当前X = 玩家.x;
                    let 当前Y = 玩家.y;

                    for (let i = 1; i <= 搜索距离; i++) {
                        const 检查X = 玩家.x + 方向.dx * i;
                        const 检查Y = 玩家.y + 方向.dy * i;

                        if (检查X < 0 || 检查X >= 地牢大小 || 检查Y < 0 || 检查Y >= 地牢大小) break;

                        // 只检查路径，不检查终点类型，因为只用于确定方向
                        if (!检查移动可行性(当前X, 当前Y, 检查X, 检查Y)) break;
                        if (地牢[检查Y][检查X].背景类型 === 单元格类型.墙壁) break;


                        const 单元格 = 地牢[检查Y][检查X];
                        if (单元格?.关联怪物 && 单元格.关联怪物.状态 === 怪物状态.活跃) {
                            const 距离 = i;
                            if (距离 < 最小距离) {
                                最小距离 = 距离;
                                最近目标坐标 = { x: 检查X, y: 检查Y };
                            }
                        }
                        当前X = 检查X;
                        当前Y = 检查Y;
                    }
                }
                return 最近目标坐标;
            }
            使用(目标怪物列表) { // 目标怪物列表仅用于确定初始方向

                if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return 0;

                const 目标坐标 = this.寻找直线方向目标(); // 扩大范围寻找方向目标，距离不重要
                let targetDirX, targetDirY
                if (目标坐标) {
                    targetDirX = 目标坐标.x;
                    targetDirY = 目标坐标.y;
                } else {
                    显示通知("攻击范围内无可攻击怪物", "错误");
                    return 0;
                }
                // 获取实际飞出路径（已处理碰撞）
                const 实际飞出路径 = this.获取固定距离轴向路径(玩家.x, 玩家.y, targetDirX, targetDirY);

                if (实际飞出路径.length === 0) {
                    显示通知("回旋镖无法掷出（前方有障碍）！", "警告");
                    // 即使无法掷出，也消耗冷却和耐久
                    this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗 * 0.5); // 无法掷出消耗减半
                    if (this.自定义数据.get("耐久") <= 0) 处理销毁物品(this.唯一标识, true);
                    this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));
                    更新装备显示();
                    return 0;
                }

                let 总有效伤害 = 0;
                const 击中怪物_去程 = new Set();
                const 击中怪物_回程 = new Set();

                // --- 去程伤害 ---
                for (const 节点 of 实际飞出路径) {
                    const 单元格 = 地牢[节点.y]?.[节点.x];
                    if (单元格?.关联怪物 && 单元格.关联怪物.当前生命值 > 0 && !击中怪物_去程.has(单元格.关联怪物)) {
                        const 怪物实例 = 单元格.关联怪物;
                        const 原始血量 = 怪物实例.当前生命值;
                        怪物实例.受伤(this.攻击力, "玩家");
                        const 实际伤害 = 原始血量 - 怪物实例.当前生命值;
                        if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                        击中怪物_去程.add(怪物实例);
                        if (击中怪物_去程.size >= this.自定义数据.get("攻击目标数")) break;
                    }
                    // 去程撞到墙或障碍物时，循环会在获取路径时提前停止
                }

                // --- 回程路径与伤害 ---
                const 实际返回路径 = [];
                let 回程当前X = 实际飞出路径.length > 0 ? 实际飞出路径[实际飞出路径.length - 1].x : 玩家.x;
                let 回程当前Y = 实际飞出路径.length > 0 ? 实际飞出路径[实际飞出路径.length - 1].y : 玩家.y;

                for (let i = 实际飞出路径.length - 1; i >= 0; i--) {
                    const 目标节点 = 实际飞出路径[i]; // 回程目标是路径上的前一个点或玩家
                    const 回程步X = 目标节点.x;
                    const 回程步Y = 目标节点.y;

                    // 检查回程路径是否被阻挡
                    if (!检查移动可行性(回程当前X, 回程当前Y, 回程步X, 回程步Y)) {
                        break; // 回程路径被阻挡
                    }
                    // 检查目标单元格是否是墙壁
                    if (地牢[回程步Y][回程步X].类型 === 单元格类型.墙壁) {
                        break;
                    }

                    实际返回路径.push({ x: 回程步X, y: 回程步Y }); // 记录有效的回程点

                    const 单元格 = 地牢[回程步Y]?.[回程步X];
                    if (单元格?.关联怪物 && 单元格.关联怪物.当前生命值 > 0 && !击中怪物_回程.has(单元格.关联怪物)) {
                        const 怪物实例 = 单元格.关联怪物;
                        const 伤害系数 = 击中怪物_去程.has(怪物实例) ? 0.8 : 1;
                        const 原始血量 = 怪物实例.当前生命值;
                        怪物实例.受伤(this.攻击力 * 伤害系数, "玩家");
                        const 实际伤害 = 原始血量 - 怪物实例.当前生命值;
                        if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                        击中怪物_回程.add(怪物实例);
                        if (击中怪物_回程.size >= this.自定义数据.get("攻击目标数")) break; // 回程也受穿透限制
                    }
                    回程当前X = 回程步X;
                    回程当前Y = 回程步Y;
                }


                // --- 显示攻击特效 ---
                计划显示格子特效(实际飞出路径, '00FF00'); // 绿色去程
                if (实际返回路径.length > 0) {
                    setTimeout(() => {
                        // 反转回程路径用于视觉效果从远处回来
                        计划显示格子特效(实际返回路径.slice(), 'FFFF00'); // 黄色回程
                    }, 450); // 稍微延迟显示回程
                }


                // --- 处理耐久和冷却 ---
                this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }
                this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));

                // --- 结果通知，此处无需与宠物协同，因为使用装备槽函数已经帮我们协同了 ---
                const 总击中数 = new Set([...击中怪物_去程, ...击中怪物_回程]).size;
                if (总击中数 > 0) {
                    显示通知(`${this.名称} 击中了 ${总击中数} 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");

                    if (总有效伤害 > 0) {
                        const 所有击中怪物 = Array.from(击中怪物_去程);
                        [...玩家装备.values()].forEach(装备 => {
                            if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                                装备.当玩家攻击(所有击中怪物);
                            }
                        });
                        this.触发通用附魔(所有击中怪物);
                    }
                } else if (实际飞出路径.length > 0) {
                    显示通知(`${this.名称} 未击中任何目标。`, "信息");
                }

                更新装备显示();
                return 总有效伤害;
            }

            // 触发通用附魔效果
            触发通用附魔(目标怪物列表) {
                // --- 火焰附魔 ---
                if (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级) {
                    const 火焰等级 = this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔").等级;
                    目标怪物列表.forEach(怪物 => {
                        if (怪物.当前生命值 > 0) {
                            new 状态效果("火焰", "#CC5500", "火", 火焰等级, null, null, 怪物);
                        }
                    });
                }
                // --- 连锁附魔 ---
                const 连锁附魔 = this.自定义数据.get("附魔")?.find(item => item.种类 === "连锁附魔");
                if (连锁附魔) {
                    const 连锁距离 = 连锁附魔.等级;
                    目标怪物列表.forEach(初始目标 => {
                        if (初始目标.当前生命值 > 0) {
                            this.触发连锁(初始目标, 连锁距离, 目标怪物列表); // 使用基类的方法
                        }
                    });
                }
            }

            获取提示() {
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `攻击力：${this.攻击力} (每次命中)`,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `投掷距离：${this.自定义数据.get("攻击范围")} 格`,
                    `穿透上限：${this.自定义数据.get("攻击目标数")} 个`,
                    `效果：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 闪电链法杖 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "闪电链法杖",
                    图标: 图标映射.闪电链法杖,
                    品质: 3,
                    基础攻击力: 7, // 初始目标伤害
                    冷却回合: 3,
                    攻击范围: 3, // 初始目标选择范围
                    耐久: 配置?.耐久 || 35,
                    强化: 配置?.强化 || false,
                    效果描述: "释放一道闪电链，攻击一个目标后弹射到附近其他敌人，每次弹射伤害递减。",
                    攻击目标数: 1, // 初始只打一个
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {

                        最大弹射次数: 3 + (配置?.强化 ? 1 : 0),
                        弹射范围: 3,
                        伤害衰减系数: 0.7,
                        ...配置.数据,
                    },
                });
            }

            使用(目标怪物列表) { // 目标怪物列表用于初始目标
                if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return 0;

                const 初始目标 = 目标怪物列表[0]; // 选择最近的作为初始目标
                if (!初始目标 || 初始目标.当前生命值 <= 0) return 0; // 目标无效

                let 总有效伤害 = 0;
                const 已攻击怪物 = new Set([初始目标]);
                let 当前目标 = 初始目标;
                let 当前伤害 = this.攻击力;
                const 弹射路径可视化 = []; // 用于显示特效

                // --- 初始攻击 ---
                const 初始攻击路径 = 获取直线路径(玩家.x, 玩家.y, 初始目标.x, 初始目标.y);
                初始攻击路径.shift();
                计划显示格子特效(初始攻击路径, '00FFFF'); // 青色闪电

                const 初始原始血量 = 初始目标.当前生命值;
                初始目标.受伤(当前伤害, "玩家");
                const 初始实际伤害 = 初始原始血量 - 初始目标.当前生命值;
                if (初始实际伤害 > 0) 总有效伤害 += 初始实际伤害;

                // --- 弹射逻辑 ---
                let 剩余弹射次数 = this.自定义数据.get("最大弹射次数");
                while (剩余弹射次数 > 0 && 当前目标.当前生命值 > 0) { // 当前目标存活才能弹射
                    const 下一个目标信息 = this.寻找下一个弹射目标(当前目标, 已攻击怪物);
                    if (!下一个目标信息) break; // 没有可弹射的目标

                    const { 目标: 下一个目标, 路径: 弹射路径 } = 下一个目标信息;

                    当前伤害 *= this.自定义数据.get("伤害衰减系数"); // 伤害衰减
                    if (当前伤害 < 1) break; // 伤害过低停止弹射

                    弹射路径可视化.push(弹射路径); // 记录弹射路径

                    const 原始血量 = 下一个目标.当前生命值;
                    下一个目标.受伤(Math.round(当前伤害), "玩家"); // 取整伤害
                    const 实际伤害 = 原始血量 - 下一个目标.当前生命值;
                    if (实际伤害 > 0) 总有效伤害 += 实际伤害;

                    已攻击怪物.add(下一个目标);
                    当前目标 = 下一个目标;
                    剩余弹射次数--;
                }

                // --- 统一显示弹射路径特效 ---
                弹射路径可视化.forEach((路径段, index) => {
                    setTimeout(() => {
                        计划显示格子特效(路径段, 'FFFF00'); // 黄色弹射
                    }, 100 + index * 100); // 延迟显示弹射路径
                });

                // --- 处理消耗和冷却 ---
                this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗 * (已攻击怪物.size > 1 ? 1.5 : 1)); // 弹射消耗更多耐久
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }
                this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));

                // --- 结果通知，此处无需与宠物协同，因为使用装备槽函数已经帮我们协同了 ---
                if (已攻击怪物.size > 0) {
                    显示通知(`${this.名称} 攻击了 ${已攻击怪物.size} 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");

                    // --- 处理附魔 ---
                    if (总有效伤害 > 0) {
                        const 所有击中怪物 = Array.from(已攻击怪物);
                        this.触发通用附魔(所有击中怪物);
                    }
                }

                更新装备显示();
                return 总有效伤害;
            }

            // 寻找下一个弹射目标
            寻找下一个弹射目标(当前怪物, 已攻击集合) {
                const 范围 = this.自定义数据.get("弹射范围");
                let 最近目标 = null;
                let 最短路径 = null;
                let 最小距离 = Infinity;

                for (let dx = -范围; dx <= 范围; dx++) {
                    for (let dy = -范围; dy <= 范围; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const x = 当前怪物.x + dx;
                        const y = 当前怪物.y + dy;

                        if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
                            const 单元格 = 地牢[y][x];
                            const 潜在目标 = 单元格?.关联怪物;
                            if (潜在目标 && 潜在目标.当前生命值 > 0 && !已攻击集合.has(潜在目标) && 潜在目标.状态 === 怪物状态.活跃) {
                                const 路径 = 广度优先搜索路径(当前怪物.x, 当前怪物.y, x, y, 范围, true);
                                if (路径 && 路径.length > 1 && 路径.length <= 范围 + 1) { // 确保路径有效且在范围内 (+1因为包含起点)
                                    const 距离 = 路径.length - 1;
                                    if (距离 < 最小距离) {
                                        最小距离 = 距离;
                                        最近目标 = 潜在目标;
                                        最短路径 = 路径.slice(1); // 移除起点
                                    }
                                }
                            }
                        }
                    }
                }
                return 最近目标 ? { 目标: 最近目标, 路径: 最短路径 } : null;
            }

            获取提示() {
                const 弹射次数 = this.自定义数据.get('最大弹射次数');
                const 衰减 = this.自定义数据.get('伤害衰减系数');
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `初始攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `范围：${this.自定义数据.get("攻击范围")} 格`,
                    `最大弹射：${弹射次数} 次`,
                    `弹射范围：${this.自定义数据.get('弹射范围')} 格`,
                    `伤害衰减：x${衰减.toFixed(2)} /次`,
                    `效果：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 大地猛击锤 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "大地猛击锤",
                    图标: 图标映射.大地猛击锤,
                    品质: 3,
                    基础攻击力: 10,
                    冷却回合: 5,
                    攻击范围: 2 + (配置?.强化 ? 2 : 0), // 攻击范围定义为效果半径
                    耐久: 配置?.耐久 || 80,
                    强化: 配置?.强化 || false,
                    效果描述: "猛击地面，对自身周围小范围内的所有敌人造成伤害并有几率眩晕。",
                    攻击目标数: 99, // 范围攻击
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {

                        眩晕几率: 0.3,
                        眩晕回合: 2,
                        ...配置.数据,
                    },
                });
            }
            使用(目标怪物列表) {
                if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return 0;

                const 范围 = this.自定义数据.get("攻击范围") - 1;
                const 影响格子 = [];
                const 击中怪物 = new Set();
                let 总有效伤害 = 0;

                // --- 计算影响范围并造成伤害 ---
                for (let dx = -范围; dx <= 范围; dx++) {
                    for (let dy = -范围; dy <= 范围; dy++) {
                        // 计算到中心的距离（可选，如果想做圆形范围）
                        // if (Math.sqrt(dx * dx + dy * dy) > 范围) continue;

                        const x = 玩家.x + dx;
                        const y = 玩家.y + dy;

                        if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
                            // 检查视线或路径，确保是可触及的格子（避免穿墙）
                            if (检查视线(玩家.x, 玩家.y, x, y, 范围 + 1)) {
                                影响格子.push({ x, y }); // 用于特效显示
                                const 单元格 = 地牢[y][x];
                                if (单元格?.关联怪物 && 单元格.关联怪物.当前生命值 > 0) {
                                    const 怪物 = 单元格.关联怪物;
                                    击中怪物.add(怪物);
                                    const 原始血量 = 怪物.当前生命值;
                                    怪物.受伤(this.攻击力, "玩家");
                                    const 实际伤害 = 原始血量 - 怪物.当前生命值;
                                    if (实际伤害 > 0) 总有效伤害 += 实际伤害;

                                    // --- 处理眩晕 ---
                                    if (怪物.当前生命值 > 0 && Math.random() < this.眩晕几率) {
                                        new 状态效果("冻结", "#FFA500", "晕", this.自定义数据.get("眩晕回合"), null, null, 怪物); // 借用冻结效果模拟眩晕
                                        添加日志(`${怪物.类型} 被大地猛击锤眩晕了！`, "警告");
                                    }
                                }
                            }
                        }
                    }
                }

                // --- 显示特效 ---
                if (影响格子.length > 0) {
                    // 可以设计一个更符合“震击”的特效，或者分层显示
                    影响格子.forEach((格, index) => {
                        const dist = Math.abs(格.x - 玩家.x) + Math.abs(格.y - 玩家.y);
                        // 延迟基于距离，中心先亮
                        setTimeout(() => 计划显示格子特效([格], 'A0522D'), dist * 50); // 棕色特效
                    });
                }


                // --- 处理消耗和冷却 ---
                this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗 * (击中怪物.size > 2 ? 1.5 : 1)); // 击中多消耗多
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }
                this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));

                // --- 结果通知和宠物协同 ---
                if (击中怪物.size > 0) {
                    显示通知(`${this.名称} 震击了 ${击中怪物.size} 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");
                    const 所有击中怪物 = Array.from(击中怪物);
                    [...玩家装备.values()].forEach(装备 => {
                        if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                            装备.当玩家攻击(所有击中怪物);
                        }
                    });
                    // --- 处理附魔 ---
                    if (总有效伤害 > 0) {
                        this.触发通用附魔(所有击中怪物);
                    }
                } else {
                    显示通知(`${this.名称} 发动了震击！`, "信息");
                }

                更新装备显示();
                return 总有效伤害;
            }
            get 眩晕几率() {
                return this.自定义数据.get('眩晕几率') + (this.强化 ? 0.15 : 0);
            }
            获取提示() {
                const 范围 = this.自定义数据.get("攻击范围");
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `范围：周围 ${范围} 格`,
                    `眩晕几率：${(this.眩晕几率 * 100).toFixed(0)}%`,
                    `效果：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 穿云箭 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "穿云箭",
                    图标: 图标映射.穿云箭,
                    品质: 2,
                    基础攻击力: 5,
                    冷却回合: 3,
                    攻击范围: 8 + (配置?.强化 ? 2 : 0), // 代表固定飞行距离
                    耐久: 配置?.耐久 || 50,
                    强化: 配置?.强化 || false,
                    效果描述: "射出一支能够穿透多个敌人的箭矢，飞行固定距离。",
                    攻击目标数: 3 + (配置?.强化 ? 1 : 0), // 穿透数量
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {
                        ...配置.数据,
                    },
                });

            }

            寻找直线方向目标() {
                const 方向列表 = [
                    { dx: 0, dy: -1, 名称: "上" }, // 上
                    { dx: 0, dy: 1, 名称: "下" }, // 下
                    { dx: -1, dy: 0, 名称: "左" }, // 左
                    { dx: 1, dy: 0, 名称: "右" }  // 右
                ];
                let 最近目标坐标 = null;
                let 最小距离 = Infinity;
                const 搜索距离 = 20;

                for (const 方向 of 方向列表) {
                    let 当前X = 玩家.x;
                    let 当前Y = 玩家.y;

                    for (let i = 1; i <= 搜索距离; i++) {
                        const 检查X = 玩家.x + 方向.dx * i;
                        const 检查Y = 玩家.y + 方向.dy * i;

                        if (检查X < 0 || 检查X >= 地牢大小 || 检查Y < 0 || 检查Y >= 地牢大小) break;

                        // 只检查路径，不检查终点类型，因为只用于确定方向
                        if (!检查移动可行性(当前X, 当前Y, 检查X, 检查Y)) break;
                        if (地牢[检查Y][检查X].背景类型 === 单元格类型.墙壁) break;


                        const 单元格 = 地牢[检查Y][检查X];
                        if (单元格?.关联怪物 && 单元格.关联怪物.状态 === 怪物状态.活跃) {
                            const 距离 = i;
                            if (距离 < 最小距离) {
                                最小距离 = 距离;
                                最近目标坐标 = { x: 检查X, y: 检查Y };
                            }
                        }
                        当前X = 检查X;
                        当前Y = 检查Y;
                    }
                }
                return 最近目标坐标;
            }

            // 新增：获取固定距离直线路径并检查碰撞
            获取固定距离直线路径(startX, startY, targetX, targetY) {
                const path = [];
                const fixedDistance = this.自定义数据.get("攻击范围");
                const dxTotal = targetX - startX;
                const dyTotal = targetY - startY;

                let currentX = startX;
                let currentY = startY;
                let dirX = 0;
                let dirY = 0;

                // 确定主方向（只允许水平或垂直）
                if (Math.abs(dxTotal) >= Math.abs(dyTotal) && dxTotal !== 0) {
                    dirX = Math.sign(dxTotal);
                    dirY = 0;
                } else if (Math.abs(dyTotal) > Math.abs(dxTotal) && dyTotal !== 0) {
                    dirX = 0;
                    dirY = Math.sign(dyTotal);
                } else {
                    const lastMove = 移动历史[移动历史.length - 1];
                    if (lastMove === "右") { dirX = 1; dirY = 0; }
                    else if (lastMove === "左") { dirX = -1; dirY = 0; }
                    else if (lastMove === "下") { dirX = 0; dirY = 1; }
                    else if (lastMove === "上") { dirX = 0; dirY = -1; }
                    else { // 随机方向
                        if (Math.random() < 0.5) {
                            dirX = (Math.random() < 0.5 ? 1 : -1); dirY = 0;
                        } else {
                            dirX = 0; dirY = (Math.random() < 0.5 ? 1 : -1);
                        }
                    }
                }
                if (dirX === 0 && dirY === 0) return [];

                for (let i = 0; i < fixedDistance; i++) {
                    const nextX = currentX + dirX;
                    const nextY = currentY + dirY;

                    if (nextX < 0 || nextX >= 地牢大小 || nextY < 0 || nextY >= 地牢大小) break;
                    if (!检查移动可行性(currentX, currentY, nextX, nextY)) break;
                    if (地牢[nextY][nextX].背景类型 === 单元格类型.墙壁) break;

                    path.push({ x: nextX, y: nextY });
                    currentX = nextX;
                    currentY = nextY;
                }
                return path;
            }
            使用(目标怪物列表) { // 目标怪物列表在此处不再直接使用

                if (this.堆叠数量 <= 0 || this.自定义数据.get("冷却剩余") > 0) return 0;

                // 1. 确定射击方向
                let targetX, targetY;
                const 方向目标坐标 = this.寻找直线方向目标();

                if (方向目标坐标) {
                    targetX = 方向目标坐标.x;
                    targetY = 方向目标坐标.y;
                } else {
                    显示通知("攻击范围内无可攻击怪物", "错误");
                    return 0;
                }

                // 2. 获取实际飞行路径（已处理碰撞和距离）
                const 实际飞行路径 = this.获取固定距离直线路径(玩家.x, 玩家.y, targetX, targetY);

                if (实际飞行路径.length === 0) {
                    显示通知("箭矢无法射出（前方有障碍）！", "警告");
                    // 即使无法射出，也消耗冷却和耐久
                    this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗 * 0.5);
                    if (this.自定义数据.get("耐久") <= 0) 处理销毁物品(this.唯一标识, true);
                    this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));
                    更新装备显示();
                    return 0;
                }

                // 3. 计算伤害和穿透
                let 总有效伤害 = 0;
                const 击中怪物 = new Set();
                let 穿透计数 = 0;

                for (const 节点 of 实际飞行路径) {
                    if (穿透计数 >= this.自定义数据.get("攻击目标数")) break;

                    const 单元格 = 地牢[节点.y]?.[节点.x];
                    if (单元格?.关联怪物 && 单元格.关联怪物.当前生命值 > 0 && !击中怪物.has(单元格.关联怪物)) {
                        const 怪物 = 单元格.关联怪物;
                        击中怪物.add(怪物);
                        穿透计数++;

                        const 原始血量 = 怪物.当前生命值;
                        怪物.受伤(this.攻击力, "玩家");
                        const 实际伤害 = 原始血量 - 怪物.当前生命值;
                        if (实际伤害 > 0) 总有效伤害 += 实际伤害;
                    }
                }

                // 4. 显示特效
                计划显示格子特效(实际飞行路径, 'C0C0C0'); // 银色箭矢

                // 5. 处理消耗和冷却
                this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }
                this.自定义数据.set("冷却剩余", this.自定义数据.get("冷却回合"));

                // 6. 结果通知和宠物协同
                if (击中怪物.size > 0) {
                    显示通知(`${this.名称} 穿透了 ${击中怪物.size} 个目标，共造成 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");
                    const 所有击中怪物 = Array.from(击中怪物);
                    [...玩家装备.values()].forEach(装备 => {
                        if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                            装备.当玩家攻击(所有击中怪物);
                        }
                    });
                    if (总有效伤害 > 0) {
                        this.触发通用附魔(所有击中怪物);
                    }
                } else if (实际飞行路径.length > 0) {
                    显示通知(`${this.名称} 未击中任何目标。`, "信息");
                }

                更新装备显示();
                return 总有效伤害;
            }

            // 触发通用附魔效果
            触发通用附魔(目标怪物列表) {
                // --- 火焰附魔 ---
                if (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级) {
                    const 火焰等级 = this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔").等级;
                    目标怪物列表.forEach(怪物 => {
                        if (怪物.当前生命值 > 0) {
                            new 状态效果("火焰", "#CC5500", "火", 火焰等级, null, null, 怪物);
                        }
                    });
                }
                // --- 连锁附魔 ---
                const 连锁附魔 = this.自定义数据.get("附魔")?.find(item => item.种类 === "连锁附魔");
                if (连锁附魔) {
                    const 连锁距离 = 连锁附魔.等级;
                    目标怪物列表.forEach(初始目标 => {
                        if (初始目标.当前生命值 > 0) {
                            this.触发连锁(初始目标, 连锁距离, 目标怪物列表); // 使用基类的方法
                        }
                    });
                }
            }

            获取提示() {
                const 穿透数 = this.自定义数据.get('攻击目标数');
                const 飞行距离 = this.自定义数据.get("攻击范围");
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `飞行距离：${飞行距离} 格`,
                    `穿透上限：${穿透数} 个`,
                    `效果：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 钢制长剑 extends 武器类 {
            constructor(配置) {
                super({
                    名称: "钢制长剑",
                    图标: 图标映射.钢制长剑,
                    基础攻击力: 6,
                    冷却回合: 2,
                    攻击范围: 2,
                    耐久: 配置.耐久 || 50,
                    强化: 配置.强化 || false,
                    不可破坏: 配置.不可破坏 || false,
                });
            }
        }
        class 橡木法杖 extends 武器类 {
            constructor(配置) {
                super({
                    名称: "橡木法杖",
                    图标: 图标映射.橡木法杖,
                    品质: 3,
                    基础攻击力: 8,
                    攻击范围: 5,
                    冷却回合: 3,
                    攻击目标数: 5,
                    耐久: 配置.耐久 || 40,
                    强化: 配置.强化 || false,
                    不可破坏: 配置.不可破坏 || false,
                });
            }
        }

        class 秘银锁甲 extends 防御装备类 {
            constructor(配置) {
                super({
                    名称: "秘银锁甲",
                    图标: 图标映射.秘银锁甲,
                    品质: 3,
                    防御力: 3,
                    耐久: 配置.耐久 || 150,
                    强化: 配置.强化 || false,
                    不可破坏: 配置.不可破坏 || false,
                });
            }
        }
        class 迅捷卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "迅捷卷轴",
                    品质: 3,
                    效果描述: "激活后增加移动步数，效果可叠加，消耗能量",
                    能量消耗: 4,
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
                this.速度加成值 = 2;
            }

            计算总迅捷加成() {
                let 激活的迅捷卷轴数量 = 0;
                if (typeof 当前激活卷轴列表 !== 'undefined' && 当前激活卷轴列表 instanceof Set) {
                    当前激活卷轴列表.forEach(卷轴 => {
                        if (卷轴 instanceof 迅捷卷轴) {
                            激活的迅捷卷轴数量++;
                        }
                    });
                } else {
                    console.warn("迅捷卷轴：无法访问或类型错误的 当前激活卷轴列表，无法计算加成。");
                    return 0;
                }
                return 激活的迅捷卷轴数量 * this.速度加成值;
            }

            使用() {
                const 总加成 = this.计算总迅捷加成();
                玩家属性.移动步数 = 初始玩家属性.移动步数 + 总加成;
                return true;
            }

            卸下() {
                const 总加成 = this.计算总迅捷加成();
                const 计算后的步数 = 初始玩家属性.移动步数 + 总加成;
                玩家属性.移动步数 = Math.max(初始玩家属性.移动步数, 计算后的步数);
                return true;
            }
        }
        class 神秘卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "神秘卷轴",
                    品质: 3,
                    效果描述: "浪费能量的空白卷轴",
                    能量消耗: 15,
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
            }
            //使用时不卸下即视为每回合消耗能量，消耗能量在卷轴基类处理
            使用() {
                return true;
            }
            卸下() {
                return true;
            }
        }
        class 贪婪卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "贪婪卷轴",
                    品质: 3,
                    效果描述: "赌狗！将怪物掉落率/装备耐久提高一倍吧！",
                    能量消耗: 15,
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                if (!this.消耗能量()) return false;
                玩家属性.掉落倍率 = 2;
                return true;
            }
            卸下() {
                玩家属性.掉落倍率 = 1;
                return true;
            }
        }
        class 清净卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "清净卷轴",
                    品质: 3,
                    效果描述: "消耗大量能量，激活后去除自身所有效果",
                    能量消耗: 40,
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                if (!this.消耗能量()) return false;
                玩家状态.forEach((item) => {
                    item.移除状态();
                });
                当前激活卷轴列表.delete(this);
                恢复卷轴模式();
                显示通知("卷轴成功发挥作用", "成功");
                绘制();
                return true;
            }
        }
        class 金币手枪 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "金币手枪",
                    图标: 图标映射.金币手枪,
                    品质: 3,
                    颜色索引: 2,
                    效果描述: "发射直线子弹，中弹怪物会麻木，每发消耗2金币",
                    基础攻击力: 1,
                    冷却回合: 1,
                    攻击范围: 40,
                    耐久: 配置.耐久 || 75,
                    强化: 配置.强化 || false,
                    不可破坏: 配置.不可破坏 || false,
                    数据: {
                        金币消耗: 2
                    }
                })
            }
            使用() {
                const 金币列表 = [...玩家背包.values()].filter((i) => i instanceof 金币);
                const 总金币 = 金币列表.reduce((sum, i) => sum + i.堆叠数量, 0);
                if (总金币 < this.自定义数据.get("金币消耗")) {
                    显示通知("金币不足！", "错误");
                    return false
                }
                const 攻击结果 = this.寻找直线目标();
                if (!攻击结果) {
                    return false
                }

                if (!扣除金币(this.自定义数据.get("金币消耗"))) return false;

                super.使用([攻击结果.怪物]);
                更新背包显示();
                攻击结果.怪物.受伤冻结回合剩余 = 2;
                计划显示格子特效(攻击结果.路径);
                return true
            }
            寻找直线目标() {
                const 方向列表 = [{
                    dx: 0,
                    dy: -1,
                    名称: "上"
                }, {
                    dx: 0,
                    dy: 1,
                    名称: "下"
                }, {
                    dx: -1,
                    dy: 0,
                    名称: "左"
                }, {
                    dx: 1,
                    dy: 0,
                    名称: "右"
                }];
                let 最近目标 = null;
                let 最小距离 = Infinity;
                if (地牢[玩家.y][玩家.x].类型 === 单元格类型.怪物) {
                    return {
                        怪物: 地牢[玩家.y][玩家.x].关联怪物,
                        路径: [{ x: 玩家.x, y: 玩家.y }],
                    };
                }
                方向列表.forEach(方向 => {
                    let 当前X = 玩家.x + 方向.dx;
                    let 当前Y = 玩家.y + 方向.dy;
                    let 路径 = [];
                    for (let i = 0; i < 9999; i++) {
                        if (!检查移动可行性(当前X - 方向.dx, 当前Y - 方向.dy, 当前X, 当前Y)) break;
                        const 单元格 = 地牢[当前Y]?.[当前X];
                        if (单元格?.关联怪物 && 单元格.类型 === 单元格类型.怪物 && 单元格.关联怪物?.状态 === 怪物状态.活跃) {
                            const 距离 = Math.abs(当前X - 玩家.x) + Math.abs(当前Y - 玩家.y);
                            if (距离 < 最小距离) {
                                最近目标 = {
                                    怪物: 单元格.关联怪物,
                                    路径: 获取直线路径(玩家.x, 玩家.y, 当前X, 当前Y)
                                };
                                最小距离 = 距离
                            }
                            break;
                        }
                        路径.push({
                            x: 当前X,
                            y: 当前Y
                        });
                        当前X += 方向.dx;
                        当前Y += 方向.dy
                    }
                });
                return 最近目标;
            }
        }
        class 附魔卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "附魔卷轴",
                    品质: 配置.品质 || 1,
                    效果描述: "为装备附加附魔",
                    能量消耗: 30,
                    已解锁: 配置.已解锁 || false,
                    强化: 配置.强化 || false,
                });
                this.可用次数 = 配置.可用次数 || 1; // 可附魔次数
                this.附魔池 = [
                    this.火焰附魔,
                    this.保护附魔,
                    this.耐久附魔,
                    this.锋利附魔,
                    this.爆炸保护附魔,
                    this.连锁附魔,
                    this.荆棘附魔,
                ];
                this.效果名 = [
                    "火焰附魔",
                    "保护附魔",
                    "耐久附魔",
                    "锋利附魔",
                    "爆炸保护附魔",
                    "连锁附魔",
                    "荆棘附魔",
                ];
                const 效果索引 = Math.floor(Math.random() * this.附魔池.length);
                this.附魔效果 = this.附魔池[效果索引]
                if (!配置.品质) {
                    this.品质 = Math.floor(Math.random() * 6) || 1;
                    this.颜色索引 = this.品质 - 1;
                }
                this.效果描述 = "为装备附加" + this.效果名[效果索引] + "(附魔等级由品质决定)";
            }

            使用() {
                this.显示附魔界面();
                return true;
            }

            显示附魔界面() {
                玩家属性.允许移动 = false;
                const 弹窗 = this.创建附魔弹窗();
                this.添加装备到弹窗(弹窗);
                this.添加确认按钮(弹窗);
            }

            添加确认按钮(弹窗) {
                const 确认按钮 = document.createElement("button");
                确认按钮.className = "附魔确认按钮";
                确认按钮.innerHTML = "开始附魔";
                确认按钮.addEventListener("click", () => {
                    const 选中装备 = 弹窗.querySelector(".可附魔.active");
                    if (选中装备) {
                        this.执行附魔(选中装备.__物品实例, 弹窗, 选中装备);
                    } else {
                        显示通知("请选择要附魔物品", "错误");
                    }
                });
                弹窗.querySelector(".附魔装备容器").after(确认按钮);
            }

            创建附魔弹窗() {
                const 弹窗 = document.createElement("div");
                弹窗.className = "附魔弹窗";
                弹窗.innerHTML = `
            <div class="附魔头" >
                <span class="附魔标题">选择要附魔的装备</span>
                <button class="关闭按钮" click>×</button>
            </div >
            <div class="附魔装备容器"></div>
            <div class="附魔特效"></div>
        `;
                弹窗.querySelector(".关闭按钮").addEventListener("click", () => {
                    弹窗.classList.add("关闭中"); // 先触发动画
                    setTimeout(() => {
                        玩家属性.允许移动 = true;
                        弹窗.remove();
                        当前激活卷轴列表.delete(this);
                        恢复卷轴模式();
                    }, 300); // 等动画完成再移除
                });
                document.body.appendChild(弹窗);
                return 弹窗;
            }

            添加装备到弹窗(弹窗) {
                const 容器 = 弹窗.querySelector(".附魔装备容器");
                [...玩家装备.values()].forEach(装备 => {
                    const 克隆元素 = 装备.生成显示元素("装备").cloneNode(true);
                    克隆元素.style.margin = "-5px 0";
                    克隆元素.classList.remove("active");
                    克隆元素.classList.remove("hover");
                    克隆元素.removeAttribute("data-quality");
                    克隆元素.__物品实例 = 装备;
                    克隆元素.classList.add("可附魔");
                    克隆元素.addEventListener("click", (e) => {
                        克隆元素.classList.add("active");
                        容器.querySelectorAll(".物品条目").forEach((el) => {
                            if (el !== 克隆元素) {
                                el.classList.remove("active");
                            }
                        });
                    });
                    ["丢弃按钮", "使用按钮", "装备按钮"].forEach(
                        (className) => {
                            克隆元素.querySelector(
                                `.${className} `
                            )?.remove();
                        }
                    );
                    容器.appendChild(克隆元素);
                });
            }

            执行附魔(装备, 弹窗, 元素) {
                const 成功 = this.附魔效果.call(this, 装备);

                if (成功) {
                    元素.classList.add("附魔成功");
                    setTimeout(() => 元素.classList.remove("附魔成功"), 1500);

                    this.播放附魔特效(装备, 弹窗, 元素);
                    this.可用次数--;
                    if (this.可用次数 <= 0) {
                        处理销毁物品(this.唯一标识, true);
                    }
                    显示通知("附魔成功！装备绽放出神秘光芒", "成功");
                    弹窗.classList.add("关闭中");
                    当前激活卷轴列表.delete(this);
                    恢复卷轴模式();
                    setTimeout(() => {
                        弹窗.remove();
                        玩家属性.允许移动 = true;
                    }, 2000);
                } else {
                    显示通知("无法应用附魔！", "错误");
                }
            }

            火焰附魔(装备) {
                return this.添加附魔(装备, "火焰附魔", ["武器", "防御装备"]);
            }
            耐久附魔(装备) {
                return this.添加附魔(装备, "耐久附魔", ["武器", "防御装备"]);
            }
            保护附魔(装备) {
                return this.添加附魔(装备, "保护附魔", ["防御装备"]);
            }
            锋利附魔(装备) {
                return this.添加附魔(装备, "锋利附魔", ["武器"]);
            }
            连锁附魔(装备) {
                return this.添加附魔(装备, "连锁附魔", ["武器"]);
            }
            爆炸保护附魔(装备) {
                return this.添加附魔(装备, "爆炸保护附魔", ["防御装备"]);
            }
            荆棘附魔(装备) {
                return this.添加附魔(装备, "荆棘附魔", ["防御装备"]);
            }
            添加附魔(装备, 附魔种类, 允许装备列表) {
                if (装备.自定义数据.get("附魔")) {
                    if (!装备.自定义数据.get("附魔").some((附魔) => 附魔.种类 === 附魔种类 && 附魔.等级 >= this.品质) && 允许装备列表.includes(装备.类型)) {
                        if (!this.消耗能量()) {
                            显示通知("能量不足！", "错误");
                            return false;
                        }
                        let 成功附魔 = false;
                        装备.自定义数据.get("附魔").forEach((item, index, arr) => {
                            if (item.种类 === 附魔种类 && item.等级 < this.品质) {
                                arr[index] = { 种类: 附魔种类, 等级: this.品质 };
                                成功附魔 = true;
                            }
                        });
                        if (!成功附魔) {
                            装备.自定义数据.get("附魔").push({ 种类: 附魔种类, 等级: this.品质 });
                        }
                        return true;
                    }
                }
                return false;
            }
            播放附魔特效(装备, 弹窗, 装备元素) {
                const 装备位置 = 装备元素.getBoundingClientRect();
                const 中心X = 装备位置.left + 装备位置.width / 2;
                const 中心Y = 装备位置.top + 装备位置.height / 2;

                const 特效容器 = document.createElement("div");
                特效容器.style = `
        position: fixed;
        left: ${中心X}px;
        top: ${中心Y}px;
        pointer-events: none;
        z-index: 10001;
        `;

                document.body.appendChild(特效容器);

                const 粒子数 = 12;

                const 基础色相 = 260;

                for (let i = 0; i < 粒子数; i++) {
                    const 粒子 = document.createElement("div");
                    粒子.className = "魔幻粒子";

                    const 角度 = Math.random() * Math.PI * 2;
                    const 距离 = 120 + Math.random() * 80;
                    const 目标X = Math.cos(角度) * 距离;
                    const 目标Y = Math.sin(角度) * 距离;
                    const 大小 = 12 + Math.random() * 16;
                    const 旋转 = Math.random() * 720;
                    const 色相偏移 = (Math.random() - 0.5) * 40;
                    const 亮度曲线 = 60 + Math.random() * 30;

                    粒子.style = `
        --target-x: ${目标X}px;
        --target-y: ${目标Y}px;
        --size: ${大小}px;
        --hue: ${基础色相 + 色相偏移};
        transform: translateZ(0);
        --lightness: ${亮度曲线}%;
        --rotate: ${旋转}deg;
        --delay: ${Math.random() * 0.4}s;
        `;

                    特效容器.appendChild(粒子);
                }

                setTimeout(() => 特效容器.remove(), 2000);
            }
        }

        class 跃迁卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "跃迁卷轴",
                    品质: 3,
                    效果描述: "随机传送到未访问房间，并解锁目标房间所有门",
                    强化: 配置.强化 || false,
                    能量消耗: 67,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                if (!this.消耗能量()) return false;

                // 获取所有有效房间
                const 有效房间 = 房间列表.filter(
                    (r) =>
                        r.id !== 房间地图[玩家.y][玩家.x] && // 排除当前房间
                        (!已访问房间.has(r.id)) // 排除访问过
                );

                if (有效房间.length === 0) {
                    const 有效房间 = 房间列表.filter(
                        (r) =>
                            r.id !== 房间地图[玩家.y][玩家.x]// 仅排除当前房间
                    );
                    显示通知("没有可传送的未访问房间", "警告");
                }

                const 目标房间 =
                    有效房间[Math.floor(Math.random() * 有效房间.length)];

                // 解锁关联门
                门实例列表.forEach((门) => {
                    if (门.房间ID === 目标房间.id) {
                        地牢[门.所在位置.y][门.所在位置.x].背景类型 =
                            单元格类型.门;
                    }
                });

                // 传送到房间中心
                玩家.x = 目标房间.x + Math.floor(目标房间.w / 2);
                玩家.y = 目标房间.y + Math.floor(目标房间.h / 2);
                已访问房间.add(目标房间.id); // 刷新
                更新视口();
                绘制();
                处理怪物回合();
                显示通知(
                    `一阵风刮来，被传送到了 ${目标房间.id} 号房间`,
                    "成功"
                );
                当前激活卷轴列表.delete(this);
                恢复卷轴模式();
                return true;
            }
        }

        class 真言卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "真言卷轴",
                    图标: 图标映射.真言卷轴,
                    品质: 4,
                    强化: 配置.强化 || false,
                    效果描述: "揭示装备中所有卷轴的奥秘，每个卷轴 30 能量",
                    能量消耗: 30,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                const 能量条 = document.querySelector(".power-bar");
                let 当前能量 = Math.max(Math.min(parseFloat(能量条.style.width), 100), 0);

                let 解密数量 = 0;
                const 每次解密消耗 = 30;

                // 遍历玩家装备，尝试解锁卷轴
                [...玩家装备.values()].forEach(item => {
                    if (item instanceof 卷轴类 && !item.自定义数据.get("已解锁")) {
                        if (当前能量 >= 每次解密消耗) {
                            当前能量 -= 每次解密消耗; // 扣除能量
                            item.自定义数据.set("已解锁", true); // 解锁卷轴
                            解密数量++;
                        }
                    }
                });
                卷轴扣除能量(Math.max(Math.min(parseFloat(能量条.style.width), 100), 0) - 当前能量);
                更新装备显示();
                更新背包显示();
                if (解密数量 > 0) {
                    显示通知(`解密了 ${解密数量} 个神秘卷轴`, "成功");
                } else {
                    显示通知(`没有可解密的卷轴`, "信息");
                }

                当前激活卷轴列表.delete(this);
                恢复卷轴模式();
                return 解密数量 > 0;
            }

            获取提示() {
                return this.自定义数据.get("已解锁")
                    ? super.获取提示()
                    : "布满古老符文的卷轴，散发着神秘能量...";
            }
        }

        class 湮灭卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "湮灭卷轴",
                    品质: 3,
                    效果描述: "销毁所有已装备物品",
                    能量消耗: 0,
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                if (!this.消耗能量()) return false;
                let 销毁列表 = [...玩家装备.values()];

                销毁列表.forEach((item) => {
                    // 传奇自爆兵
                    const 槽位 = document.getElementById(
                        `装备槽${item.装备槽位} `
                    );
                    const 烟花容器 = document.createElement("div");
                    烟花容器.style.position = "fixed";
                    烟花容器.style.left = `${槽位.getBoundingClientRect().left + 40
                        } px`;
                    烟花容器.style.top = `${槽位.getBoundingClientRect().top + 40
                        } px`;
                    烟花容器.style.zIndex = 99999;
                    document.body.appendChild(烟花容器);

                    // 生成12个粒子
                    for (let i = 0; i < 12; i++) {
                        const 粒子 = document.createElement("div");
                        粒子.className = "烟花粒子";
                        粒子.innerHTML = [
                            "✨",
                            "❄️",
                            "⚡",
                            "⭐",
                            "💥",
                            "🔥",
                        ][i % 6];
                        粒子.style.color = "#fff";
                        粒子.style.setProperty(
                            "--tx",
                            Math.cos((i * 30 * Math.PI) / 180)
                        );
                        粒子.style.setProperty(
                            "--ty",
                            Math.sin((i * 30 * Math.PI) / 180)
                        );
                        烟花容器.appendChild(粒子);
                    }
                    setTimeout(() => 烟花容器.remove(), 800);
                    item.取消装备();
                    处理销毁物品(item.唯一标识, true);
                });
                玩家装备.clear();
                处理销毁物品(this.唯一标识, true);
                更新背包显示();
                更新装备显示();
                显示通知(`湮灭了${销毁列表.length} 件装备`, "错误");
                return true;
            }
        }
        class 背包扩容祭坛 extends 物品 {
            constructor(配置) {
                super({
                    类型: "祭坛",
                    名称: "背包扩容祭坛",
                    图标: 图标映射.祭坛,
                    是否正常物品: false,
                    品质: 4, // 最高品质
                    颜色索引: 4, // 红色或特殊颜色
                    能否拾起: false,
                    效果描述: "献祭大量生命，永久扩展你的背包容量！(每次+2，最多扩展到24)",
                    数据: {
                        已使用: 配置?.数据?.已使用 || false, // 祭坛只能用一次
                        扩容量: 2,
                        最大扩展至: 24,
                        生命消耗: 85, // 极高消耗
                    }
                });
            }

            尝试互动() {
                if (this.自定义数据.get("已使用")) {
                    显示通知("这个祭坛的力量已经耗尽。", "信息");
                    return false;
                }

                if (最大背包容量 >= this.自定义数据.get("最大扩展至")) {
                    显示通知("你的背包已经足够大了，无法再扩展。", "信息");
                    return false;
                }

                const 当前生命百分比 = parseFloat(document.querySelector(".health-bar").style.width) || 0;

                if (当前生命百分比 < this.自定义数据.get("生命消耗")) {
                    显示通知("生命力不足，无法激活祭坛！", "错误");
                    return false;
                }

                if (confirm(`是否献祭 ${this.自定义数据.get("生命消耗")}% 生命来永久扩展 ${this.自定义数据.get("扩容量")} 个背包格子？（当前容量 ${最大背包容量} / ${this.自定义数据.get("最大扩展至")}）`)) {
                    // 扣除生命
                    伤害玩家(this.自定义数据.get("生命消耗"), this.名称); // 直接调用伤害函数模拟扣血

                    // 增加背包容量 (修改全局变量)
                    最大背包容量 = Math.min(this.自定义数据.get("最大扩展至"), 最大背包容量 + this.自定义数据.get("扩容量"));

                    // 更新UI显示
                    document.getElementById("最大容量").textContent = 最大背包容量;
                    更新背包显示(); // 确保容量更新

                    // 标记祭坛已使用
                    this.自定义数据.set("已使用", true);

                    显示通知(`背包容量已扩展至 ${最大背包容量}！`, "成功");

                    return true;
                }
                return false;
            }

            获取提示() {
                const 状态 = this.自定义数据.get("已使用") ? "已耗尽" : "可献祭";
                return [
                    `${this.名称} [${状态}]`,
                    `类型：${this.类型}`,
                    `品质：${"★".repeat(this.品质)}`,
                    `${this.效果描述}`,
                    `消耗：${this.自定义数据.get("生命消耗")}% 生命值`,
                    `效果：+${this.自定义数据.get("扩容量")} 背包容量 (上限 ${this.自定义数据.get("最大扩展至")})`
                ].join('\n');
            }
        }
        class 钢制板甲 extends 防御装备类 {
            constructor(配置) {
                super({
                    名称: "钢制板甲",
                    图标: 图标映射.钢制板甲,
                    品质: 2,
                    强化: 配置.强化 || false,
                    防御力: 1,
                    耐久: 配置.耐久 || 200,
                    不可破坏: 配置.不可破坏 || false,
                });
            }
        }
        class 冰盾 extends 防御装备类 {
            constructor(配置) {
                super({
                    名称: "冰盾",
                    图标: 图标映射.冰盾,
                    效果描述: "iDefender 会帮你以 80% 概率保卫电脑 3 回合。",
                    品质: 3,
                    强化: 配置.强化 || false,
                    防御力: 2,
                    耐久: 配置.耐久 || 100,
                    不可破坏: 配置.不可破坏 || false,
                    数据: {
                        冻结概率: 0.8,
                        冻结回合: 3
                    }
                });
            }

            当被攻击(原始攻击力, 来源 = null) {
                // 基础防御计算
                const 最终伤害 = super.当被攻击(原始攻击力, 来源);

                // 概率触发冻结
                if (Math.random() < this.自定义数据.get("冻结概率") && 来源 instanceof 怪物) {
                    const 攻击者 = 来源;
                    if (攻击者) {
                        const 冻结状态 = new 状态效果("冻结", "#2196F3", "冻", this.自定义数据.get("冻结回合"), null, null, 攻击者);
                    }
                }

                return 最终伤害;
            }
        }
        class 重铸台 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "工具",
                    名称: "重铸台",
                    图标: 图标映射.重铸台,
                    品质: 4,
                    颜色索引: 3,
                    最大堆叠数量: 1,
                    效果描述: `将同名装备的耐久融合\n耐久：${配置.耐久 || 5} /${配置.耐久 || 5}`,
                    数据: {
                        耐久: 配置.耐久 || 5,
                        最大耐久: 5,
                        基础消耗: 30,
                        强化折扣: -0.2
                    }
                });
            }

            使用() {
                if (this.自定义数据.get("耐久") <= 0) {
                    显示通知("重铸台已损坏！", "错误");
                    return false;
                }
                this.显示重铸界面();
                return true;
            }

            显示重铸界面() {
                if (界面可见性.背包) 切换背包显示();
                玩家属性.允许移动 = false;
                const 遮罩 = document.createElement("div");
                遮罩.className = "重铸遮罩";
                const 弹窗 = document.createElement("div");
                弹窗.className = "重铸弹窗";
                弹窗.innerHTML = `
      <div class="重铸弹窗-header">
        <h3>重铸台（耐久：${this.自定义数据.get("耐久")}/${this.自定义数据.get("最大耐久")} | 金币：<span id="repairCost">0</span>）</h3>
        <button class="关闭按钮" onclick="关闭重铸界面()">×</button>
      </div>
      <div style="display: flex; gap: 20px;">
        <div class="重铸弹窗-column">
          <h4>待修复装备</h4>
          <div class="重铸弹窗-items" id="sourceItems"></div>
        </div>
        <div class="重铸弹窗-column">
          <h4>材料装备</h4>
          <div class="重铸弹窗-items" id="materialItems"></div>
        </div>
      </div>
      <button class="附魔确认按钮" style="margin-top:15px;" onclick="执行重铸()">开始重铸</button>
    `;

                遮罩.appendChild(弹窗);
                document.body.appendChild(遮罩);

                // 添加进场动画
                setTimeout(() => {
                    弹窗.style.transform = "translate(-50%, -50%) scale(1)";
                }, 10);

                this.填充可选物品(弹窗.querySelector("#sourceItems"), "source");
                this.填充可选物品(弹窗.querySelector("#materialItems"), "material");
                window.当前重铸台 = this;
                window.当前重铸遮罩 = 遮罩; //懒得写进全局变量了...
                弹窗.querySelectorAll(".重铸弹窗-items").forEach(容器 => {
                    容器.addEventListener("click", () => this.更新消耗显示());
                });
            }
            计算消耗(源物品, 材料物品) {
                if (!源物品 || !材料物品) {
                    return "-";
                }
                if (源物品 === 材料物品) {
                    return "-";
                }
                if (源物品.名称 !== 材料物品.名称) {
                    return "-";
                }
                let 基础消耗 = this.自定义数据.get("基础消耗");
                const 折扣率 = this.自定义数据.get("强化折扣");
                const 当前耐久 = 源物品.自定义数据.get("耐久");
                const 最大耐久 = 源物品.自定义数据.get("原耐久");
                const 可用空间 = 最大耐久 - 当前耐久;
                const 可转移量 = Math.min(材料物品.自定义数据.get("耐久"), 可用空间);
                基础消耗 += Math.floor(可转移量 / 最大耐久 * 基础消耗)
                // 任一物品强化即打折（虽然是负折扣
                const 有强化 = 源物品.强化 || 材料物品?.强化;
                if (有强化) 基础消耗 *= (1 - 折扣率);

                return Math.floor(基础消耗);
            }
            更新消耗显示() {
                const 源物品 = document.querySelector("#sourceItems .selected")?.__物品实例;
                const 材料物品 = document.querySelector("#materialItems .selected")?.__物品实例;

                if (!源物品 || !材料物品) {
                    document.getElementById("repairCost").textContent = "0";
                    return;
                }

                let 消耗 = this.计算消耗(源物品, 材料物品);
                document.getElementById("repairCost").textContent = 消耗;
                if (消耗 === "-") 消耗 = 10000;
                // 根据玩家金币改变颜色
                const 玩家金币 = [...玩家背包.values()]
                    .filter(i => i instanceof 金币)
                    .reduce((sum, i) => sum + i.堆叠数量, 0);

                document.getElementById("repairCost").style.color =
                    玩家金币 >= 消耗 ? "#4CAF50" : "#F44336";
            }

            填充可选物品(容器, 类型) {
                容器.innerHTML = "";
                const 有效物品 = [...玩家背包.values()].filter(item =>
                    (item instanceof 武器类 || item instanceof 防御装备类) &&
                    item.自定义数据?.has("耐久") &&
                    item !== this
                );

                有效物品.forEach(item => {
                    const 元素 = document.createElement("div");
                    元素.className = "重铸物品";
                    元素.innerHTML = `
      ${item.强化 ? '<div class="重铸台强化标识">★</div>' : ''}
        <div class="物品图标">${item.图标}</div>
        <div class="物品名称">${item.名称}</div>
        <div class="重铸台耐久标签">耐久 ${item.自定义数据.get("耐久")}/${item.自定义数据.get("原耐久")}</div>
      `;

                    // 直接绑定实例引用
                    元素.__物品实例 = item;
                    元素.addEventListener("click", () => this.选择物品(元素, 类型));
                    容器.appendChild(元素);
                });
            }

            选择物品(元素, 类型) {
                document.querySelectorAll(`.重铸物品[data-type="${类型}"]`).forEach(el => {
                    el.classList.remove("selected");
                    el.style.transform = "scale(1)";
                });
                元素.classList.add("selected");
                元素.style.transform = "scale(1.05)";
                元素.dataset.type = 类型;
            }
        }
        class 火把 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "工具",
                    名称: "火把",
                    图标: 图标映射.火焰,
                    品质: 1,
                    颜色索引: 2,
                    堆叠数量: 配置.数量 || 1,
                    最大堆叠数量: 1,
                    效果描述: "照亮周围，提供视野。装备可增加视野范围，丢在地上可照亮一小片区域。每回合消耗耐久。",
                    强化: 配置.强化 || false,
                    数据: {
                        耐久: 配置.耐久 || 125 + (配置.强化 ? 125 : 0),
                        原耐久: 125 + (配置.强化 ? 125 : 0),
                        光照范围: 3 + (配置.强化 ? 1 : 0),
                        视野加成: 2 + (配置.强化 ? 1 : 0),
                        倒计时: 配置.耐久 || 50 + (配置.强化 ? 25 : 0),
                        爆炸时间: 配置.耐久 || 50 + (配置.强化 ? 25 : 0),
                        不可破坏: false,
                        ...配置.数据,
                    },
                });


            }
            生成显示元素(用途 = "背包") {
                const 元素 = super.生成显示元素(用途);

                if (this.自定义数据.has("耐久") && this.自定义数据.has("原耐久") && 用途 === "装备") {

                    let 耐久标签 = 元素.querySelector('.耐久标签');
                    if (!耐久标签) {
                        耐久标签 = document.createElement("div");
                        耐久标签.className = "耐久标签";
                        元素.appendChild(耐久标签);
                    }

                    耐久标签.textContent = `耐久:${this.自定义数据.get("耐久")}`;
                }
                return 元素;
            }

            装备() {
                const 装备成功 = super.装备();
                if (装备成功) {
                    if (!所有计时器.some(t => t.唯一标识 === this.唯一标识)) {
                        所有计时器.push(this);
                    }
                    解冻药水();
                }
                return 装备成功;
            }

            取消装备() {
                const 卸下成功 = super.取消装备();
                if (卸下成功) {

                    所有计时器 = 所有计时器.filter(t => t.唯一标识 !== this.唯一标识);
                }
                return 卸下成功;
            }


            更新倒计时() {
                let 当前耐久 = this.自定义数据.get("倒计时");
                当前耐久--;
                if (当前天气效果.includes("严寒")) {
                    当前耐久--;
                }
                this.自定义数据.set("倒计时", 当前耐久);
                this.自定义数据.set("耐久", 当前耐久);

                if (当前耐久 <= 0) {
                    this.触发爆炸();
                }

                if (this.已装备) {
                    更新装备显示();
                }

            }


            触发爆炸() {
                显示通知(`${this.名称} 燃尽熄灭了。`, "信息");

                if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
                    地牢[this.y][this.x].关联物品 = null;
                    地牢[this.y][this.x].类型 = 地牢[this.y][this.x].背景类型;
                }
                所有计时器 = 所有计时器.filter(t => t.唯一标识 !== this.唯一标识);


                if (玩家背包.has(this.唯一标识)) {
                    处理销毁物品(this.唯一标识, true);
                }
                绘制();
            }


            使用() {

                if (!this.已装备) {
                    if (this.装备()) {
                        显示通知(`装备了 ${this.名称}`, "成功");
                        更新背包显示();
                        更新装备显示();
                        return true;
                    } else {
                        显示通知("装备槽已满！", "错误");
                        return false;
                    }
                } else {
                    显示通知("火把已装备", "信息");
                    return false;
                }
            }

            获取提示() {
                const data = this.自定义数据;
                return [
                    `${this.获取名称()}`,
                    `类型：${this.类型}`,
                    `品质：${"★".repeat(this.品质)}`,
                    `耐久：${data.get("耐久")} / ${data.get("原耐久")}`,
                    `地上光照范围：${data.get("光照范围")} 格`,
                    `装备视野加成：+${data.get("视野加成")} 格`,
                    `${this.效果描述}`,
                ].join("\n");
            }


            当被丢弃(x, y) {
                this.x = x;
                this.y = y;

                if (this.自定义数据.get("耐久") > 0 && !所有计时器.some(t => t.唯一标识 === this.唯一标识)) {
                    所有计时器.push(this);
                }
                return true;
            }
            当被收集(玩家) {
                所有计时器 = 所有计时器.filter(t => t.唯一标识 !== this.唯一标识);
                return true;
            }
        }
        class 喷火枪 extends 武器类 {
            constructor(配置) {
                super({
                    名称: "喷火枪",
                    图标: 图标映射.喷火枪,
                    品质: 4,
                    基础攻击力: 4,
                    冷却回合: 4,
                    攻击范围: 3,
                    耐久: 配置?.耐久 || 100,
                    强化: 配置?.强化 || false,
                    效果描述: "向四个方向喷射火焰，对距离3格的直线敌人造成范围伤害。",
                    攻击目标数: 1,
                    不可破坏: 配置?.不可破坏 || false,
                    附魔: 配置?.数据?.附魔 || [],
                    数据: {
                        火焰范围: 2,
                    },
                });
            }


            使用(目标怪物) {
                if (
                    this.堆叠数量 <= 0 ||
                    this.自定义数据.get("冷却剩余") > 0
                )
                    return 0;
                if (
                    当前天气效果.includes("严寒")
                ) {
                    if (目标怪物) 显示通知("温度过低，武器打不着火了！", "警告")
                    return 0;
                }
                const 总攻击力 = this.攻击力;
                let 总有效伤害 = 0;
                const 击中怪物列表 = new Set();
                const 火焰影响区域 = [];


                const 火焰范围 = this.自定义数据.get('火焰范围');

                const 目标X = 玩家.x;
                const 目标Y = 玩家.y;


                if (目标X < 0 || 目标X >= 地牢大小 || 目标Y < 0 || 目标Y >= 地牢大小) return;


                const 当前方向火焰区 = [];
                for (let 偏移 = -火焰范围; 偏移 <= 火焰范围; 偏移++) {
                    const 格子Y = 目标Y + 偏移;
                    if (格子Y >= 0 && 格子Y < 地牢大小) {

                        if (快速直线检查(玩家.x, 玩家.y, 目标X, 格子Y, Math.abs(偏移))) {
                            当前方向火焰区.push({ x: 目标X, y: 格子Y });
                        }
                    }
                }
                for (let 偏移 = -火焰范围; 偏移 <= 火焰范围; 偏移++) {
                    const 格子X = 目标X + 偏移;
                    if (格子X >= 0 && 格子X < 地牢大小) {
                        if (快速直线检查(玩家.x, 玩家.y, 格子X, 目标Y, Math.abs(偏移))) {
                            当前方向火焰区.push({ x: 格子X, y: 目标Y });
                        }
                    }
                }



                当前方向火焰区.forEach(({ x, y }) => {
                    火焰影响区域.push({ x, y });
                    const 单元格 = 地牢[y][x];
                    if (单元格 && 单元格.关联怪物 && 单元格.关联怪物.当前生命值 > 0 && !击中怪物列表.has(单元格.关联怪物)) {
                        const 怪物 = 单元格.关联怪物;
                        const 原始血量 = 怪物.当前生命值;
                        怪物.受伤(总攻击力, "玩家");
                        const 实际伤害 = 原始血量 - 怪物.当前生命值;
                        if (实际伤害 > 0) {
                            总有效伤害 += 实际伤害;
                            击中怪物列表.add(怪物);
                        }
                    }
                });


                火焰影响区域.forEach(格子 => 计划显示格子特效([格子], "FFA500"));


                this.自定义数据.set("耐久", this.自定义数据.get("耐久") - this.耐久消耗);
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }
                this.自定义数据.set(
                    "冷却剩余",
                    Math.max(this.自定义数据.get("冷却回合") - (this.强化 ? 1 : 0), 0)
                );


                if (总有效伤害 > 0) {
                    显示通知(`${this.名称} 对 ${击中怪物列表.size} 个目标造成共 ${总有效伤害.toFixed(1)} 点伤害！`, "成功");
                } else if (火焰影响区域.length > 0) {
                    显示通知(`${this.名称} 喷射了火焰！`, "信息");
                } else {
                    显示通知(`${this.名称} 未能喷射火焰！`, "警告");
                    return 0;
                }



                if (总有效伤害 > 0) {
                    const 受击怪物数组 = Array.from(击中怪物列表);

                    const 火焰等级 = (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级 || 0) + 2;
                    受击怪物数组.forEach(怪物 => {
                        if (怪物.当前生命值 > 0) {
                            new 状态效果("火焰", "#CC5500", "火", 火焰等级, null, null, 怪物);
                        }
                    });

                    const 连锁附魔 = this.自定义数据.get("附魔")?.find(item => item.种类 === "连锁附魔");
                    if (连锁附魔) {
                        const 连锁距离 = 连锁附魔.等级;
                        受击怪物数组.forEach(初始目标 => {
                            if (初始目标.当前生命值 > 0) {
                                this.触发连锁(初始目标, 连锁距离, 受击怪物数组);
                            }
                        });
                    }
                }


                return 总有效伤害;
            }


            获取提示() {
                return [
                    `${this.获取名称()} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} / ${this.自定义数据.get("原耐久")}`,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `范围：十字喷射`,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
        }
        class 神秘商人 extends 物品 {
            constructor(配置) {
                super({
                    类型: "NPC",
                    名称: "神秘商人",
                    图标: 图标映射.神秘商人,
                    品质: 4,
                    颜色索引: 3,
                    能否拾起: false, // 不可拾取
                    效果描述: "毫无卵用的奸商",
                    数据: {
                        库存: 配置.库存 || [],
                        刷新次数: 3 // 可交易次数
                    }
                });
                this.能否拾起 = false;
                this.生成库存(当前层数);
            }
            使用() {
                打开交易窗口(this);
                return true;
            }
            生成库存(层数) {
                this.自定义数据.set("库存", []);
                const 品质权重 = [
                    { 品质: 1, 权重: 50 - 层数 * 5 },
                    { 品质: 2, 权重: 30 + 层数 * 3 },
                    { 品质: 3, 权重: 15 + 层数 * 2 },
                    { 品质: 4, 权重: 5 + 层数 * 1 }
                ].filter((w) => w.权重 > 0);
                let 已选中 = false;
                let 尝试次数 = 0;
                for (let i = 0; i < 3; i++) {
                    while (!已选中 && 尝试次数 < 100) {
                        const 选中品质 = 加权随机选择(品质权重);
                        const 候选物品 = Object.values(物品池)
                            .flat()
                            .filter((item) => item.品质 == 选中品质.品质 && 层数 >= item.最小层); // 我知道这里可以改进，但是我的snippet已经跳出来了

                        if (候选物品.length > 0) {
                            const 模板 = 候选物品[Math.floor(Math.random() * 候选物品.length)];
                            const 物品实例 = new 模板.类({
                                数量: 1,
                                强化: Math.random() < Math.min(0.85, 层数 * 0.15), // 层数越高强化概率越大
                                已解锁: true,
                                品质: 2 + Math.floor(Math.random() * 4),
                            });
                            if (!this.自定义数据.get("库存").some((item) => item.名称 === 物品实例.名称) && 物品实例.是否正常物品) {
                                this.自定义数据.get("库存").push(物品实例);
                                已选中 = true;
                            }
                        }
                        尝试次数++
                    }
                    已选中 = false;
                    尝试次数 = 0;
                }
            }

            获取价格(物品) {
                return Math.max(物品.品质 * 20 + (物品.强化 ? 20 : 0) + Math.floor(Math.random() * 15) - 当前层数 * 2, 30);
            }
        }
        class 探险家 extends 物品 {
            constructor(配置) {
                super({
                    类型: "NPC",
                    名称: "探险家",
                    图标: 图标映射.探险家,
                    品质: 3,
                    颜色索引: 3,
                    能否拾起: false,
                    是否正常物品: false, // 不直接出现在掉落池
                    效果描述: "一位经验丰富的探险家，愿意用金币换取你的发现。",
                    数据: {
                        收购需求: [], // { 名称: "钢制长剑", 品质下限: 1, 强化需求: false, 数量: 1 }
                        交易次数: 5 + Math.floor(Math.random() * 6) // 随机交易次数
                    }
                });
                this.生成收购需求(当前层数);
            }

            生成收购需求(层数) {
                this.自定义数据.set('收购需求', []);
                const 需求数量 = 9 + Math.floor(Math.random() * 4);

                const 可选物品池 = Object.values(物品池)
                    .flat()
                    // 排除非卖品
                    .filter(itemTmpl => {
                        if (itemTmpl.类.name !== '探险家') {
                            const tempInstance = new itemTmpl.类({});
                            return tempInstance.是否正常物品 &&
                                tempInstance.类型 !== '钥匙' &&
                                tempInstance.类型 !== '金币' &&
                                tempInstance.类型 !== 'NPC' &&
                                tempInstance.类型 !== '祭坛' &&
                                tempInstance.类型 !== '工具' &&
                                tempInstance.类型 !== '折跃门';
                        }
                    });

                if (可选物品池.length === 0) return;

                const 已选名称 = new Set();

                for (let i = 0; i < 需求数量; i++) {
                    let 尝试次数 = 0;
                    while (尝试次数 < 50) {
                        const 随机物品模板 = 可选物品池[Math.floor(Math.random() * 可选物品池.length)];
                        const 临时实例 = new 随机物品模板.类({});

                        if (已选名称.has(临时实例.名称)) {
                            尝试次数++;
                            continue;
                        }

                        const 强化需求 = 随机物品模板.品质 >= 3 && Math.random() < 0.3 + 当前层数 * 0.05;

                        this.自定义数据.get('收购需求').push({
                            名称: 临时实例.名称,
                            强化需求: 强化需求,
                            图标: 临时实例.图标,
                            颜色索引: 临时实例.颜色索引,
                            类名: 随机物品模板.类.name
                        });
                        已选名称.add(临时实例.名称);
                        break;
                    }
                }
            }


            计算收购价格(物品实例, 需求) {
                let 基础价格 = (物品实例.品质 * 20 + (需求.强化需求 ? 15 : 0)) * 0.8; // 比商人售价低一些


                if (物品实例.强化 && (!需求.强化需求 || 需求.强化需求)) {
                    基础价格 += 10;
                } else if (!物品实例.强化 && 需求.强化需求) {
                    return 0;
                }



                if (物品实例.自定义数据?.has('耐久') && 物品实例.自定义数据?.has('原耐久')) {
                    const 耐久比例 = 物品实例.自定义数据.get('耐久') / 物品实例.自定义数据.get('原耐久');
                    基础价格 *= (0.5 + 耐久比例 * 0.5);
                }


                if (物品实例.自定义数据?.has('附魔')) {
                    const 附魔数量 = (物品实例.自定义数据.get('附魔') || []).length;
                    const 附魔等级总和 = (物品实例.自定义数据.get('附魔') || []).reduce((sum, e) => sum + e.等级, 0);
                    基础价格 += 附魔数量 * 2 + 附魔等级总和 * 1.5;
                }


                if (物品实例 instanceof 卷轴类 && 物品实例.自定义数据?.get('已解锁')) {
                    基础价格 *= 1.3;
                }

                if (物品实例 instanceof 宠物 && 物品实例.自定义数据?.has('等级')) {
                    基础价格 += 物品实例.自定义数据.get('等级') * 3;
                }



                return Math.max(1, Math.floor(基础价格 * (0.9 + Math.random() * 0.2))); // 90%-110% 浮动，最低1金币
            }


            使用() {
                if (this.自定义数据.get('交易次数') <= 0) {
                    显示通知("我已经收够今天想要的东西了，下次再见！", "信息");
                    return false;
                }
                打开收购窗口(this);
                return true;
            }
        }
        class 物品祭坛 extends 物品 {
            constructor(配置) {
                super({
                    类型: "祭坛",
                    名称: "物品祭坛",
                    图标: 图标映射.祭坛,
                    是否正常物品: false,
                    品质: 4,
                    颜色索引: 3,
                    能否拾起: false,
                    数据: {
                        库存: 配置.库存 || [],
                    }

                });
                let 已选中 = false;
                let 尝试次数 = 0;
                while (!已选中 && 尝试次数 < 100) {
                    已选中 = this.生成库存();
                    尝试次数++
                }
            }
            尝试互动() {
                const 当前生命 =
                    parseFloat(
                        document.querySelector(".health-bar").style.width
                    ) || 0;

                if (this.自定义数据.get("库存").length <= 0) {
                    显示通知("祭坛已无效！", "错误");
                    return false;
                }
                if (当前生命 > 75) {
                    let 库存 = this.自定义数据.get("库存").shift()
                    if (尝试收集物品(库存, false)) {
                        if (是否为教程层) {
                            显示通知("居然还有这么多血！？", "成功");
                        } else {
                            显示通知("物品祭坛献祭成功！", "成功");
                        }
                        伤害玩家(75, this.名称);
                        return true;
                    } else {
                        this.自定义数据.get("库存").push(库存);
                    }
                } else {
                    显示通知("血量不足，无法献祭！", "错误");
                    return false;
                }
                return false;
            }
            生成库存() {
                this.自定义数据.set("库存", []);
                const 候选物品 = Object.values(物品池)
                    .flat()
                const 物品实例 = new 候选物品[Math.floor(Math.random() * 候选物品.length)].类({ 强化: true, 已解锁: true });
                if (物品实例.是否正常物品 && !(物品实例 instanceof 神秘商人)) {
                    this.自定义数据.get("库存").push(物品实例);
                    return true;
                }
                return false;
            }
        }
        class 灵能盾牌 extends 防御装备类 {
            constructor(配置 = {}) {
                super({
                    名称: "灵能盾牌",
                    图标: "🛡️",
                    品质: 3,
                    颜色索引: 4,
                    防御力: 1 + (配置.强化 ? 1 : 0),
                    耐久: 配置.耐久 || 80 + (配置.强化 ? 40 : 0),
                    原耐久: 配置.原耐久 || 80 + (配置.强化 ? 40 : 0),
                    强化: 配置.强化 || false,
                    效果描述: "受击时概率恢复能量或闪避攻击。",
                    不可破坏: 配置.不可破坏 || false,
                    附魔: 配置.附魔 || [],
                    数据: {
                        能量恢复概率: 0.25 + (配置.强化 ? 0.1 : 0),
                        能量恢复量: 10 + (配置.强化 ? 5 : 0),
                        闪避触发概率: 0.15 + (配置.强化 ? 0.1 : 0),
                    },
                    ...配置
                });
            }


            当被攻击(原始攻击力, 来源 = null) {

                let 剩余伤害 = super.当被攻击(原始攻击力, 来源);
                if (Math.random() < this.自定义数据.get("能量恢复概率")) {
                    const 恢复量 = this.自定义数据.get("能量恢复量");
                    const 能量条 = document.querySelector(".power-bar");
                    const 当前能量 = parseFloat(能量条.style.width) || 0;
                    能量条.style.width = `${Math.min(100, 当前能量 + 恢复量)}%`;
                    触发HUD显示();
                }


                if (Math.random() < this.自定义数据.get("闪避触发概率")) {
                    显示通知("灵能盾牌闪避！", "成功");
                    添加日志(`成功闪避了来自 ${来源 instanceof 怪物 ? 来源.类型 : (来源 || '未知来源')} 的攻击！`, "成功");
                    触发HUD显示();
                    return 0;
                }


                return 剩余伤害;
            }

            获取提示() {
                const 能量概率 = (this.自定义数据.get('能量恢复概率') * 100).toFixed(0);
                const 能量恢复 = this.自定义数据.get('能量恢复量');
                const 闪避概率 = (this.自定义数据.get('闪避触发概率') * 100).toFixed(0);

                return [
                    super.获取提示(),
                    `--- 特殊效果 ---`,
                    `能量恢复：${能量概率}%几率恢复 ${能量恢复} 点`,
                    `灵体闪避：${闪避概率}%几率完全闪避攻击`,
                ].join("\n");
            }
        }
        class 耐久祭坛 extends 物品 {
            constructor(配置) {
                super({
                    类型: "祭坛",
                    名称: "耐久祭坛",
                    图标: 图标映射.祭坛,
                    是否正常物品: false,
                    品质: 4,
                    颜色索引: 3,
                    能否拾起: false,
                    数据: {
                        使用次数: 0,
                    }

                });
            }
            get 使用次数() {
                return this.自定义数据.get("使用次数");
            }
            set 使用次数(item) {
                this.自定义数据.set("使用次数", item);
            }
            尝试互动() {
                const 当前生命 =
                    parseFloat(
                        document.querySelector(".health-bar").style.width
                    ) || 0;
                if (this.使用次数 >= 3) {
                    显示通知("祭坛已无效！", "错误");
                    return false;
                }
                if (当前生命 > 75) {
                    伤害玩家(75, this.名称);
                    [...玩家装备.values()].forEach((装备) => {
                        if (装备.自定义数据.get("原耐久")) 装备.自定义数据.set("耐久", 装备.自定义数据.get("原耐久"))
                    });
                    显示通知("耐久祭坛献祭成功！", "成功");
                    更新装备显示();
                    this.使用次数++;
                    return true;
                } else {
                    显示通知("血量不足，无法献祭！", "错误");
                    return false;
                }
            }
        }
        class 宠物 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "宠物",
                    名称: 配置.名称 || "宠物",
                    图标: 配置.图标 || 图标映射.宠物,
                    品质: 配置.品质 || 3,
                    颜色索引: 配置.颜色索引 || 2,
                    最大堆叠数量: 1,
                    堆叠数量: 配置.堆叠数量 || 1,
                    效果描述: 配置.效果描述 || "一只忠诚的伙伴。",
                    强化: 配置.强化 || false,
                    数据: {

                        等级: 配置.等级 || 1,
                        当前生命值: 配置.当前生命值 || (配置.最大生命值 || 100),
                        最大生命值: 配置.最大生命值 || 100,
                        基础攻击力: 配置.基础攻击力 || 5,
                        基础防御力: 配置.基础防御力 || 2,
                        经验值: 配置.经验值 || 0,
                        升级所需经验: 配置.升级所需经验 || 20,
                        升级所需金币: 配置.升级所需金币 || 30,
                        技能: 配置.技能 || [], // { 名称: "", 等级: 1, 描述: "" }
                        装备: {}, // "武器": 物品实例, "防具": 物品实例
                        休眠中: false,
                        每移动恢复量: 配置.每移动恢复量 || 1,
                        ...配置.数据,
                    },
                });
                if (this.强化) {
                    this.自定义数据.set("升级所需金币", Math.round(this.自定义数据.get("升级所需金币") * 0.5));
                    this.自定义数据.set("升级所需经验", Math.round(this.自定义数据.get("升级所需经验") * 0.5));
                }
            }

            当玩家攻击(目标怪物列表) {
                if (this.自定义数据.get("休眠中")) return;

                this.攻击(目标怪物列表);

                const 武器 = this.自定义数据.get("装备")?.武器;
                if (
                    武器 &&
                    武器.堆叠数量 > 0 &&
                    武器.自定义数据.get("冷却剩余") == 0
                ) {
                    const { 怪物, 路径 } = 获取周围怪物(
                        武器.自定义数据.get("攻击目标数"),
                        武器.自定义数据.get("攻击范围")
                    );
                    if (怪物 !== null) {

                        if (武器.使用(怪物, 路径)) {
                            路径.forEach((攻击路径) => 计划显示格子特效(攻击路径));
                        }
                    }
                }
                this.触发技能("攻击", 目标怪物列表);
            }

            攻击(目标怪物列表) {
                const 总伤害 = this.自定义数据.get("基础攻击力");
                目标怪物列表.forEach(怪物 => {
                    if (怪物.当前生命值 > 0) 怪物.受伤(总伤害, this); // 伤害来源改为宠物实例
                });
                显示通知(`${this.名称}发起攻击，造成了${总伤害}点伤害`, "成功");
            }


            // 当玩家被攻击时触发 (需要传入攻击力和攻击来源)
            当玩家被攻击(原始攻击力, 来源) {
                if (this.自定义数据.get("休眠中")) return 原始攻击力;

                let 最终攻击力 = 原始攻击力;

                // 宠物装备的防具效果
                const 防具 = this.自定义数据.get("装备")?.防具;
                if (防具) {
                    最终攻击力 = 防具.当被攻击(最终攻击力, 来源);
                }

                // 宠物自身防御
                最终攻击力 = Math.max(0, 最终攻击力 - this.自定义数据.get("基础防御力"));
                if (最终攻击力 <= 0) 最终攻击力 = Math.round(Math.random() * 100) / 100;

                const 承担比例 = 0.3;
                const 宠物承担伤害 = Math.ceil(最终攻击力 * 承担比例);
                this.受伤(宠物承担伤害);

                // 触发宠物技能 (被攻击时)
                this.触发技能("被攻击", 来源);
                return 最终攻击力 * (1 - 承担比例);
            }

            受伤(伤害值) {
                let 当前生命值 = this.自定义数据.get("当前生命值");
                当前生命值 = Math.max(0, 当前生命值 - 伤害值);
                this.自定义数据.set("当前生命值", 当前生命值);
                this.更新宠物管理窗口();
                if (当前生命值 <= 0) {
                    this.进入休眠();
                }
            }

            进入休眠() {
                this.自定义数据.set("休眠中", true);
                显示通知(`${this.名称}生命值过低，进入休眠！`, "警告");
            }

            // 移动玩家调用
            恢复生命值() {
                if (!this.自定义数据.get("休眠中")) return;

                let 当前生命值 = this.自定义数据.get("当前生命值");
                const 最大生命值 = this.自定义数据.get("最大生命值");
                const 恢复量 = this.自定义数据.get("每移动恢复量");

                当前生命值 = Math.min(最大生命值, 当前生命值 + 恢复量);
                this.自定义数据.set("当前生命值", 当前生命值);
                this.更新宠物管理窗口();
                if (当前生命值 >= 最大生命值 && this.自定义数据.get("休眠中")) {
                    this.自定义数据.set("休眠中", false);
                    显示通知(`${this.名称}已恢复，退出休眠！`, "成功");
                }
            }
            //子类自行升级技能
            升级() {
                const 当前等级 = this.自定义数据.get("等级");
                const 升级所需金币 = this.自定义数据.get("升级所需金币");
                if (this.自定义数据.get("升级所需经验") <= this.自定义数据.get("经验值")) {
                    if (扣除金币(升级所需金币)) {
                        this.自定义数据.set("等级", 当前等级 + 1);
                        this.自定义数据.set("最大生命值", this.自定义数据.get("最大生命值") + 20);
                        this.自定义数据.set("当前生命值", this.自定义数据.get("最大生命值")); // 升级后回满血
                        this.自定义数据.set("基础攻击力", this.自定义数据.get("基础攻击力") + 2);
                        this.自定义数据.set("基础防御力", this.自定义数据.get("基础防御力") + 1);

                        // 增加升级所需经验和金币
                        this.自定义数据.set("升级所需经验", Math.floor(this.自定义数据.get("升级所需经验") * 1.5));
                        this.自定义数据.set("升级所需金币", Math.floor(this.自定义数据.get("升级所需金币") * 1.2));
                        显示通知(`${this.名称}升级成功！`, "成功");
                        this.更新宠物管理窗口();
                        return true;
                    } else {
                        显示通知("金币不足，无法升级！", "错误");
                        return false;
                    }
                } else {
                    显示通知("经验不足，无法升级！", "错误");
                    return false;
                }
            }

            获得经验(经验值) {
                let 当前经验 = this.自定义数据.get("经验值") + 经验值;
                this.自定义数据.set("经验值", 当前经验);
            }

            装备物品(物品, 槽位) {
                if (槽位 !== "武器" && 槽位 !== "防具") {
                    显示通知("无效的宠物装备槽位", "错误");
                    return;
                }
                if ((槽位 === "武器" && !(物品 instanceof 武器类)) || (槽位 === "防具" && !(物品 instanceof 防御装备类))) {
                    显示通知("该物品不能装备到此槽位", "错误");
                    return;
                }

                // 该槽位已有装备，先卸下
                if (this.自定义数据.get("装备")[槽位]) {
                    this.卸下装备(槽位);
                }
                物品.是否隐藏 = true;
                卸下装备槽物品(物品.装备槽位); //内部会调用 更新背包显示

                this.自定义数据.get("装备")[槽位] = 物品;
                显示通知(`${this.名称}装备了${物品.获取名称()}`, "成功");
                this.更新宠物管理窗口();

            }

            卸下装备(槽位) {
                const 装备 = this.自定义数据.get("装备");
                if (装备 && 装备[槽位] && [...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0) < 最大背包容量) {
                    const 卸下物品 = 装备[槽位];
                    装备[槽位] = null;
                    卸下物品.是否隐藏 = false;
                    显示通知(`${this.名称}卸下了${卸下物品.获取名称()}`, "成功");
                    this.自定义数据.set("装备", 装备);
                    this.更新宠物管理窗口();
                    更新背包显示();
                } else {
                    显示通知("背包已满！", "错误")
                }
            }

            // (时机: "攻击" 或 "被攻击")
            触发技能(时机, 额外参数) {
                const 技能列表 = this.自定义数据.get("技能");
                if (!技能列表) return;

                技能列表.forEach(技能 => {
                    if (技能.时机 === 时机 && Math.random() > 0.5) {
                        this.技能效果[技能.索引](this, 额外参数);
                    }
                });
            }

            使用() {
                this.打开宠物管理窗口();
                return true;
            }

            打开宠物管理窗口() {
                if (界面可见性.背包) 切换背包显示();
                玩家属性.允许移动 = false;
                if (window.宠物管理窗口) {
                    显示通知("一次只能打开一个宠物管理窗口", "错误");
                    return;
                }
                const 窗口 = document.createElement("div");
                窗口.className = "宠物管理窗口";
                window.宠物管理窗口 = 窗口;

                const 基本信息面板 = this.创建基本信息面板();
                const 装备面板 = this.创建装备面板();
                const 技能面板 = this.创建技能面板();

                const 升级按钮 = document.createElement("button");
                升级按钮.className = "通用按钮"; // 使用通用按钮样式
                升级按钮.textContent = `升级宠物（${this.自定义数据.get("升级所需金币")} 金币 ${this.自定义数据.get("升级所需经验")} EXP）`;
                升级按钮.addEventListener("click", () => {
                    this.升级();
                    this.更新基本信息面板(基本信息面板); // 更新信息
                    升级按钮.textContent = `升级宠物（${this.自定义数据.get("升级所需金币")} 金币 ${this.自定义数据.get("升级所需经验")} EXP）`;
                });

                const 关闭按钮 = document.createElement("button");
                关闭按钮.className = "关闭按钮";
                关闭按钮.textContent = "×";
                关闭按钮.onclick = () => {
                    // 添加关闭动画
                    窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
                    窗口.style.opacity = 0;
                    setTimeout(() => {
                        玩家属性.允许移动 = true;
                        窗口.remove();
                    }, 300);
                    window.宠物管理窗口 = null;
                };

                窗口.appendChild(关闭按钮);
                窗口.appendChild(基本信息面板);
                窗口.appendChild(装备面板);
                窗口.appendChild(技能面板);
                窗口.appendChild(升级按钮);

                document.body.appendChild(窗口);
            }

            更新宠物管理窗口() {
                if (!window.宠物管理窗口) return;
                const 基本信息面板 = window.宠物管理窗口.querySelector(".宠物基本信息面板");
                if (基本信息面板) this.更新基本信息面板(基本信息面板);
                const 装备面板 = window.宠物管理窗口.querySelector(".宠物装备面板");
                if (装备面板) {
                    装备面板.innerHTML = "";
                    装备面板.appendChild(this.创建装备面板());
                }
            }

            创建基本信息面板() {
                const 面板 = document.createElement("div");
                面板.className = "宠物基本信息面板";
                this.更新基本信息面板(面板);
                return 面板;
            }

            更新基本信息面板(面板) {
                const data = this.自定义数据;
                面板.innerHTML = `
            <h3>${this.名称} (等级 ${data.get("等级")})</h3>
            <p>生命值: ${data.get("当前生命值")} / ${data.get("最大生命值")}</p>
            <p>攻击力: ${this.自定义数据.get("基础攻击力")}</p>
            <p>防御力: ${this.自定义数据.get("基础防御力")}</p>
            <p>经验值: ${data.get("经验值")} / ${data.get("升级所需经验")}</p>
            <P>升级所需金币：${data.get("升级所需金币")}</P>
            <p>状态: ${data.get("休眠中") ? "休眠中" : "活跃"}</p>
        `;
            }

            创建装备面板() {
                const 面板 = document.createElement("div");
                面板.className = "宠物装备面板";
                面板.innerHTML = "<h4>装备</h4>";

                const 武器槽 = this.创建装备槽("武器");
                const 防具槽 = this.创建装备槽("防具");

                面板.appendChild(武器槽);
                面板.appendChild(防具槽);
                return 面板;
            }

            创建装备槽(槽位类型) {
                const 槽 = document.createElement("div");
                槽.className = "宠物装备槽";
                槽.dataset.槽位 = 槽位类型;

                const 槽位名 = document.createElement("span");
                槽位名.className = "宠物装备槽位名";
                槽位名.textContent = 槽位类型;
                槽.appendChild(槽位名);

                const 已装备物品 = this.自定义数据.get("装备")[槽位类型];
                if (已装备物品) {
                    const 物品元素 = this.创建装备物品元素(已装备物品);
                    槽.appendChild(物品元素);
                } else {
                    const 选择按钮 = document.createElement("button");
                    选择按钮.className = "通用按钮";
                    选择按钮.textContent = `选择${槽位类型}`;
                    选择按钮.addEventListener("click", () => this.显示装备选择(槽位类型));
                    槽.appendChild(选择按钮);
                }
                return 槽;
            }

            创建装备物品元素(物品) {
                const 元素 = document.createElement("div");
                元素.className = "宠物已装备物品";

                const 图标 = document.createElement("span");
                图标.className = "宠物装备图标";
                图标.textContent = 物品.图标;
                图标.style.color = 物品.颜色表[物品.颜色索引];

                const 名称 = document.createElement("span");
                名称.className = "宠物装备名称";
                名称.textContent = 物品.获取名称();

                const 卸下按钮 = document.createElement("button");
                卸下按钮.className = "通用按钮";
                卸下按钮.textContent = "卸下";
                卸下按钮.addEventListener("click", () => {
                    this.卸下装备(物品.类型 === "武器" ? "武器" : "防具"); // 卸下装备
                    this.更新宠物管理窗口();
                });

                元素.appendChild(图标);
                元素.appendChild(名称);
                元素.appendChild(卸下按钮);
                return 元素;
            }

            显示装备选择(槽位类型) {
                const 遮罩 = document.createElement("div");
                遮罩.className = "宠物装备选择遮罩";

                const 弹窗 = document.createElement("div");
                弹窗.className = "宠物装备选择弹窗";

                const 标题 = document.createElement("h4");
                标题.textContent = `选择${槽位类型}`;
                弹窗.appendChild(标题);

                const 物品列表 = document.createElement("div");
                物品列表.className = "宠物装备选择列表";

                const 可用装备 = [...玩家背包.values()].filter(物品 =>
                    (槽位类型 === "武器" && 物品 instanceof 武器类) ||
                    (槽位类型 === "防具" && 物品 instanceof 防御装备类)
                );

                if (可用装备.length === 0) {
                    const 提示 = document.createElement("div");
                    提示.className = "无装备提示";
                    提示.textContent = `无可用${槽位类型}装备`;
                    物品列表.appendChild(提示);
                } else {
                    可用装备.forEach(物品 => {
                        const 物品元素 = this.创建可选装备元素(物品, 槽位类型);
                        物品列表.appendChild(物品元素);
                    });
                }

                弹窗.appendChild(物品列表);

                const 关闭按钮 = document.createElement("button");
                关闭按钮.className = "关闭按钮";
                关闭按钮.textContent = "×";
                关闭按钮.onclick = () => {
                    弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
                    弹窗.style.opacity = 0;
                    setTimeout(() => {
                        遮罩.remove();
                    }, 300);
                };
                弹窗.appendChild(关闭按钮);

                遮罩.appendChild(弹窗);
                document.querySelector(".宠物管理窗口").appendChild(遮罩);
            }

            创建可选装备元素(物品, 槽位类型) {
                const 元素 = document.createElement("div");
                元素.className = "宠物可选装备";

                const 图标 = document.createElement("span");
                图标.className = "宠物可选装备图标";
                图标.textContent = 物品.图标;
                图标.style.color = 物品.颜色表[物品.颜色索引];

                const 名称 = document.createElement("span");
                名称.className = "宠物可选装备名称";
                名称.textContent = 物品.获取名称();

                const 选择按钮 = document.createElement("button");
                选择按钮.className = "宠物装备选择确认按钮";
                选择按钮.textContent = "选择";
                选择按钮.addEventListener("click", () => {
                    this.装备物品(物品, 槽位类型);
                    let 弹窗 = document.querySelector(".宠物装备选择弹窗");
                    弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
                    弹窗.style.opacity = 0;
                    setTimeout(() => {
                        document.querySelector(".宠物装备选择遮罩").remove();
                    }, 300);
                    更新装备显示();
                    更新背包显示();
                });

                元素.appendChild(图标);
                元素.appendChild(名称);
                元素.appendChild(选择按钮);
                return 元素;
            }

            创建技能面板() {
                const 面板 = document.createElement("div");
                面板.className = "宠物技能面板";
                面板.innerHTML = "<h4>技能</h4>";

                const 技能列表 = this.自定义数据.get("技能");
                if (技能列表 && 技能列表.length > 0) {
                    技能列表.forEach(技能 => {
                        const 技能元素 = document.createElement("div");
                        技能元素.className = "宠物技能";
                        技能元素.innerHTML = `
                    <p><strong>${技能.名称}</strong> (等级 ${技能.等级})</p>
                    <p>${技能.描述}</p>
                `;
                        面板.appendChild(技能元素);
                    });
                } else {
                    面板.innerHTML += "<p>暂无技能</p>";
                }
                return 面板;
            }

            获取提示() {
                const data = this.自定义数据;
                const 装备 = data.get("装备");
                const 武器 = 装备?.武器 ? 装备.武器.获取名称() : "无";
                const 防具 = 装备?.防具 ? 装备.防具.获取名称() : "无";

                return [
                    `${this.获取名称()} (等级 ${data.get("等级")})`,
                    `类型：${this.类型}`,
                    `品质：${"★".repeat(this.品质)}`,
                    `生命值: ${data.get("当前生命值")} / ${data.get("最大生命值")}`,
                    `武器: ${武器}`,
                    `防具: ${防具}`,
                    `${this.效果描述}`,
                ].join("\n");
            }
        }
        class 熊猫 extends 宠物 {
            constructor(配置 = {}) {
                super({
                    名称: "熊猫",
                    图标: 图标映射.熊猫,
                    品质: 3,
                    颜色索引: 2,
                    效果描述: "来自神秘竹林的守护者，擅长竹叶飞刀和强力防御。",
                    基础攻击力: 1,
                    基础防御力: 2,
                    最大生命值: 30,
                    强化: 配置.强化 || false,
                    技能: [
                        {
                            名称: "竹叶飞刀",
                            等级: 1,
                            描述: "投掷锋利的竹叶，对单个敌人造成伤害。伤害随技能等级提升。",
                            时机: "攻击",
                            索引: 0,
                        },
                        {
                            名称: "金钟罩",
                            等级: 1,
                            描述: "受到攻击时有几率触发金钟罩，使攻击来源攻击力下降。抵挡比例随技能等级提升。",
                            时机: "被攻击",
                            索引: 1,
                        },
                    ],
                });
                this.技能效果 = [function (宠物, 目标怪物列表) {
                    if (!目标怪物列表 || 目标怪物列表.length === 0) return;
                    const 技能等级 = 宠物.自定义数据.get("技能")[0].等级; // 获取第一个技能的等级
                    const 基础伤害 = 1;
                    const 伤害 = 基础伤害 + 技能等级 * 3;

                    // 随机选择一个目标
                    const 目标 = 目标怪物列表[Math.floor(Math.random() * 目标怪物列表.length)];
                    目标.受伤(伤害, 宠物);
                    添加日志(`${宠物.名称}使用了竹叶飞刀！造成了 ${伤害} 点伤害`, "成功");
                }, function (宠物, 来源) {
                    const 技能等级 = 宠物.自定义数据.get("技能")[1].等级; // 获取第二个技能的等级
                    const 基础格挡率 = 0.15;
                    const 格挡率 = Math.min(0.85, 基础格挡率 + (技能等级 - 1) * 0.05);

                    if (Math.random() < 格挡率 && 来源 instanceof 怪物) {
                        // 触发格挡
                        const 基础减伤 = 0.8;
                        const 减伤比例 = Math.min(0, 基础减伤 - 技能等级 * 0.05);
                        来源.基础攻击力 = Math.floor(来源.基础攻击力 * 减伤比例) //修改攻击者的基础攻击力
                        添加日志(`${宠物.名称}触发了金钟罩！`, "成功");
                    }
                }]
            }

            升级() {
                const 升级成功 = super.升级();
                if (升级成功) {
                    const 技能列表 = this.自定义数据.get("技能");
                    if (技能列表) {
                        // 随机升级一个技能
                        const 随机技能索引 = Math.floor(Math.random() * 技能列表.length);
                        技能列表[随机技能索引].等级 += 1;
                        显示通知(`${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`, "成功");
                        window.宠物管理窗口.querySelector(".宠物技能面板").innerHTML = '';
                        window.宠物管理窗口.querySelector(".宠物技能面板").appendChild(this.创建技能面板());
                    }
                }
                return 升级成功;
            }

            当玩家被攻击(原始攻击力, 来源) {
                if (this.自定义数据.get("休眠中")) return 原始攻击力;

                let 最终攻击力 = 原始攻击力;

                // 宠物装备的防具效果
                const 防具 = this.自定义数据.get("装备")?.防具;
                if (防具) {
                    最终攻击力 = 防具.当被攻击(最终攻击力, 来源);
                }

                最终攻击力 = Math.max(0, 最终攻击力 - this.自定义数据.get("基础防御力"));
                if (最终攻击力 <= 0) 最终攻击力 = Math.round(Math.random() * 100) / 100;
                const 承担比例 = 0.3;
                const 宠物承担伤害 = Math.floor(最终攻击力 * 承担比例);
                this.受伤(宠物承担伤害);
                最终攻击力 -= 宠物承担伤害;

                this.触发技能("被攻击", 来源);
                return 最终攻击力;
            }
        }
        class 水母 extends 宠物 {
            constructor(配置 = {}) {
                super({
                    名称: "水母",
                    图标: 图标映射.水母,
                    品质: 4,
                    颜色索引: 3,
                    效果描述: "来自虚空的神秘生物，可以扭曲空间，并拥有强大的精神控制力。",
                    基础攻击力: 2,
                    基础防御力: 2,
                    最大生命值: 10,
                    强化: 配置.强化 || false,
                    技能: [
                        {
                            名称: "空间扭曲",
                            等级: 1,
                            描述: "被攻击时有几率扭曲空间，使攻击者传送回其原始位置。",
                            时机: "被攻击",
                            索引: 0,
                        },
                        {
                            名称: "精神控制",
                            等级: 1,
                            描述: "攻击时有几率魅惑一个敌人，使其在短时间内为你作战。",
                            时机: "攻击",
                            索引: 1,
                        }
                    ],
                });
                this.技能效果 = [function (宠物, 来源) {
                    if (!(来源 instanceof 怪物)) return;
                    const 技能等级 = 宠物.自定义数据.get("技能")[0].等级;
                    const 触发几率 = Math.min(0.85, 0.1 + (技能等级 - 1) * 0.05); // 初始10%几率, 每级增加5%

                    if (Math.random() < 触发几率) {
                        // 记录原始位置
                        if (!来源.原始位置) {
                            来源.原始位置 = { x: 来源.x, y: 来源.y }
                            return;
                        }
                        if (来源.原始位置 &&
                            来源.原始位置.x >= 0 && 来源.原始位置.x < 地牢大小 &&
                            来源.原始位置.y >= 0 && 来源.原始位置.y < 地牢大小
                        ) {
                            来源.恢复背景类型();
                            来源.x = 来源.原始位置.x;
                            来源.y = 来源.原始位置.y;
                            地牢[来源.y][来源.x].类型 = 单元格类型.怪物;
                            地牢[来源.y][来源.x].关联怪物 = 来源;
                            显示通知(`${宠物.名称}发动了空间扭曲！`, "成功");
                            绘制();
                        }

                    }
                }, function (宠物, 目标怪物列表) {
                    if (!目标怪物列表 || 目标怪物列表.length === 0) return;
                    const 技能等级 = 宠物.自定义数据.get("技能")[1].等级;
                    let 触发几率 = Math.min(0.85, 0.1 + (技能等级 - 1) * 0.05);
                    //触发几率 = 1;
                    if (Math.random() < 触发几率) {
                        const 目标 = 目标怪物列表[Math.floor(Math.random() * 目标怪物列表.length)];

                        if (怪物状态表.get(目标)?.类型 !== "魅惑" && !(目标 instanceof 炸弹怪物) && !(目标 instanceof 大魔法师)) {
                            const 持续回合 = 2 + 技能等级; // 基础2回合，每级+1回合
                            const 控制状态 = new 状态效果("魅惑", "#8e44ad", "魅", 持续回合, null, null, 目标);

                            添加日志(`${宠物.名称}控制了${目标.类型}!`, "成功");
                        }
                    }
                }
                ];
            }
            升级() {
                const 升级成功 = super.升级();
                if (升级成功) {
                    const 技能列表 = this.自定义数据.get("技能");
                    if (技能列表) {
                        // 随机升级
                        const 随机技能索引 = Math.floor(Math.random() * 技能列表.length);
                        技能列表[随机技能索引].等级 += 1;
                        显示通知(`${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`, "成功");
                        window.宠物管理窗口.querySelector(".宠物技能面板").innerHTML = '';
                        window.宠物管理窗口.querySelector(".宠物技能面板").appendChild(this.创建技能面板());
                    }
                }
                return 升级成功;
            }
        }
        class 火焰物品 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "地形", // 特殊类型，非普通物品
                    名称: "火焰",
                    图标: 图标映射.火焰,
                    品质: 1, // 品质意义不大
                    颜色索引: 效果名称编号映射.火焰, // 使用火焰效果的颜色索引
                    最大堆叠数量: 1,
                    能否拾起: false,      // 关键：不可拾取
                    阻碍怪物: false,      // 关键：不阻碍怪物
                    是否正常物品: false,  // 不参与常规掉落/交易
                    是否为隐藏物品: false,// 在地图上可见
                    效果描述: "灼热的火焰，触碰会被点燃。",
                    数据: {
                        倒计时: 配置.倒计时 ?? 10,         // 默认存在10回合
                        爆炸时间: 配置.倒计时 ?? 10,       // 复用计时器接口
                        火焰强度: 配置.火焰强度 ?? 3,     // 每回合伤害
                        火焰持续: 配置.火焰持续 ?? 3,     // 施加给玩家的燃烧效果持续回合数
                        光照范围: 配置.光照范围 ?? 2,     // 照亮范围
                        ...配置.数据, // 允许覆盖
                    },
                    ...配置 // 允许覆盖父类属性
                });
                // 火焰物品创建时自动加入计时器
                if (!所有计时器.some(t => t.唯一标识 === this.唯一标识)) {
                    所有计时器.push(this);
                }
                if (
                    当前天气效果.includes("严寒") && !配置.倒计时
                ) {
                    this.自定义数据.set("爆炸时间", 5);
                    this.自定义数据.set("倒计时", 5);
                }
            }

            // 火焰不能被主动使用
            使用() {
                return false;
            }

            // 玩家接触火焰时触发 (不能被收集，但会触发效果)
            当被收集(玩家) {
                const 效果 = new 状态效果(
                    "火焰",                           // 效果类型
                    this.获取火焰颜色(),            // 颜色
                    图标映射.火焰,                       // 图标
                    this.自定义数据.get("火焰持续"), // 效果持续回合数
                    null,                           // 剩余回合（从持续时间开始）
                    null,                           // 来源（火焰本身，或null）
                    null,                           // 关联怪物 (null代表玩家)
                    this.自定义数据.get("火焰强度")  // 效果强度（每回合伤害）
                );
                添加日志("你接触了火焰，被点燃了！", "错误");
                return false; // 返回 false 表示无法被收集（移除）
            }

            // 更新倒计时 (每回合调用)
            更新倒计时() {
                const 剩余回合 = this.自定义数据.get("倒计时");
                if (剩余回合 <= 0) {
                    this.熄灭(); // 时间到，火焰熄灭
                } else {
                    this.自定义数据.set("倒计时", 剩余回合 - 1);
                }
            }

            // 火焰熄灭 (代替原来的触发爆炸)
            熄灭() {
                // 从地牢格子中移除
                if (this.x !== null && this.y !== null && 地牢[this.y]?.[this.x]?.关联物品 === this) {
                    地牢[this.y][this.x].关联物品 = null;

                    if (地牢[this.y]?.[this.x]?.类型 === 单元格类型.物品) 地牢[this.y][this.x].类型 = null;
                }
                // 从计时器列表中移除
                所有计时器 = 所有计时器.filter(item => item !== this);
                绘制(); // 更新画面，移除火焰图标
            }

            获取提示() {
                return [
                    `${this.获取名称()}`,
                    `类型：${this.类型}`,
                    `剩余时间：${this.自定义数据.get("倒计时")} 回合`,
                    `${this.效果描述}`,
                ].join("\n");
            }

            获取火焰颜色() {
                return 效果颜色编号映射[this.颜色索引] || "#CC5500";
            }
        }
        class 寻宝戒指 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "戒指",
                    名称: "寻宝戒指",
                    图标: 图标映射.寻宝戒指,
                    品质: 3,
                    颜色索引: 2,
                    最大堆叠数量: 1,
                    效果描述: "装备后，会为你指出隐藏大门的位置",
                    数据: {

                        生效层数: 配置.生效层数 || 当前层数, // 指定生效的层数
                        已生成折跃门: false,
                        ...配置.数据,
                    },
                });
            }
            生成显示元素(用途 = "背包") {
                const 元素 = super.生成显示元素(用途);
                if (用途 === "装备") {
                    const 标签 = document.createElement("div");
                    标签.className = "耐久标签";
                    标签.textContent = `当前层:${当前层数}`;
                    元素.appendChild(标签);
                }
                return 元素;
            }
            使用() {
                显示通知("装备不能被使用！", "错误");
                return false;
            }
            装备() {
                if (!super.装备()) return false;
                // 触发检查和生成折跃门逻辑
                if (this.自定义数据.get("生效层数") === 当前层数 && !this.自定义数据.get("已生成折跃门")) {
                    this.尝试生成折跃门();
                }

                更新装备显示();
                return true;
            }

            取消装备() {
                if (!this.已装备) return false;
                // 移除折跃门指示器（如果存在）
                const 指示器 = document.querySelector(".折跃门指示器");
                if (指示器) {
                    指示器.remove();
                }
                玩家装备.delete(this.装备槽位);
                this.已装备 = false;
                this.装备槽位 = null;
                更新装备显示();
                return true;
            }

            尝试生成折跃门() {
                const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
                if (可用房间.length === 0) return; // 没有可用房间
                const 随机房间 = 可用房间[Math.floor(Math.random() * 房间列表.length)];
                const 放置折跃门 = new 折跃门({ 目标房间: 房间列表.find((item) => item.类型 === "boss房间" || item.类型 === "解谜棋盘") }); // 假设目标房间是起始房间
                if (放置物品到房间(放置折跃门, 随机房间, 单元格类型.物品, false, true)) {
                    this.自定义数据.set("已生成折跃门", true);
                    this.自定义数据.set("折跃门位置", { x: 放置折跃门.x, y: 放置折跃门.y })
                    更新物体指示器();
                }
            }

            获取提示() {
                return [
                    `${this.获取名称()}`,
                    `类型：${this.类型}`,
                    `生效层数：${this.自定义数据.get("生效层数")}`,
                    `效果描述：${this.效果描述}`,
                ].join("\n");
            }
        }

        class 折跃门 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "折跃门",
                    名称: "折跃门",
                    品质: 1,
                    颜色索引: 2,
                    能否拾起: false,
                    是否正常物品: false,
                    是否为隐藏物品: true,
                    数据: {
                        目标房间: 配置.目标房间 || null, // 目标房间的配置
                    },
                });
            }

            使用() {
                // 将玩家传送到目标房间的中心
                if (this.自定义数据.get("目标房间")) {
                    玩家.x = this.自定义数据.get("目标房间").x + Math.floor(this.自定义数据.get("目标房间").w / 2);
                    玩家.y = this.自定义数据.get("目标房间").y + Math.floor(this.自定义数据.get("目标房间").h / 2);
                    const 目标房间ID = 房间地图[玩家.y][玩家.x];
                    if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
                        moveQueue = [];
                        已访问房间.add(目标房间ID);
                    }
                    更新视口();
                    绘制();
                    显示通知("你被传送到了一个神秘的房间！", "成功");
                    return true;
                }
                return false;
            }
        }
        //下面这个物品！！！闪亮登场！
        class 炸弹 extends 物品 {
            constructor(配置) {
                super({
                    类型: "炸弹",
                    名称: "炸弹",
                    图标: 图标映射.炸弹,
                    品质: 3,
                    颜色索引: (配置.颜色索引 === undefined) ? 2 : 配置.颜色索引,
                    堆叠数量: 配置.数量 || 1,
                    能否拾起: 配置.能否拾起 === undefined ? true : 配置.能否拾起,
                    数据: {
                        效果描述: "无法对爆炸怪物造成伤害",
                        倒计时: 配置.倒计时 || 2, //不可以指定为 0
                        爆炸时间: 配置.爆炸时间 || 2,
                        爆炸范围: 配置.爆炸范围 || 3,
                    },
                });
            }
            获取提示() {
                return [
                    super.获取提示(),
                    `效果描述：${this.自定义数据.get("效果描述")}`,
                ].join("\n");
            }
            使用(玩家使用 = true, x0 = 0, y0 = 0) {
                if (
                    当前天气效果.includes("严寒")
                ) {
                    显示通知("温度过低，炸弹打不着火了！", "警告")
                    return 0;
                }
                super.使用();
                if (玩家使用) {
                    this.自定义数据.set("倒计时", this.自定义数据.get("爆炸时间"));
                    const { x, y, 新物品 } = 玩家放置物品(this, false);
                    if (x === null || y === null || 新物品 === null) return false;
                    新物品.x = x;
                    新物品.y = y;
                    所有计时器.push(新物品);
                    return true;
                }
                this.x = x0;
                this.y = y0;
                所有计时器.push(this);
                return true;
            }
            更新倒计时() {
                const 剩余回合 = this.自定义数据.get("倒计时");

                if (剩余回合 <= 0) {
                    this.触发爆炸();
                    所有计时器 = 所有计时器.filter((item) => item !== this);

                }
                this.自定义数据.set("倒计时", 剩余回合 - 1);
            }

            触发爆炸() {
                // BFS遍历爆炸范围
                const 爆炸范围 = this.计算爆炸范围();
                this.显示爆炸效果(爆炸范围);
                this.处理爆炸效果(爆炸范围);
            }

            计算爆炸范围() {
                const 可到达格子 = [];
                const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
                const 已访问 = new Set([`${this.x},${this.y}`]);

                while (队列.length > 0) {
                    const 当前 = 队列.shift();
                    可到达格子.push(当前);

                    if (当前.距离 >= this.自定义数据.get("爆炸范围"))
                        continue; // 最大3格

                    // 四方向扩散
                    const 方向 = [
                        { dx: 1, dy: 0 },
                        { dx: -1, dy: 0 },
                        { dx: 0, dy: 1 },
                        { dx: 0, dy: -1 },
                    ];

                    方向.forEach(({ dx, dy }) => {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;
                        const 位置键 = `${新X},${新Y}`;

                        if (
                            新X >= 0 &&
                            新X < 地牢大小 &&
                            新Y >= 0 &&
                            新Y < 地牢大小 &&
                            !已访问.has(位置键)
                        ) {
                            // 检查路径可行性
                            if (
                                this.检查路径可行性(
                                    当前.x,
                                    当前.y,
                                    新X,
                                    新Y
                                )
                            ) {
                                已访问.add(位置键);
                                队列.push({
                                    x: 新X,
                                    y: 新Y,
                                    距离: 当前.距离 + 1,
                                });
                            }
                        }
                    });
                }
                return 可到达格子;
            }

            检查路径可行性(fromX, fromY, toX, toY) {
                const 移动方向 = 获取移动方向(fromX, fromY, toX, toY);

                const 当前单元格 = 地牢[fromY][fromX];
                const 目标单元格 = 地牢[toY][toX];

                // 检查墙壁阻挡
                if (
                    当前单元格.墙壁[移动方向.当前墙] ||
                    目标单元格.墙壁[移动方向.反方向墙]
                ) {
                    return false;
                }

                // 检查目标单元格类型
                return [
                    单元格类型.房间,
                    单元格类型.走廊,
                    单元格类型.门,
                    单元格类型.上锁的门,
                ].includes(目标单元格.背景类型);
            }

            显示爆炸效果(爆炸范围) {
                if (moveQueue.length > 0) {
                    moveQueue = [];
                    isAutoMoving = false;
                }
                爆炸范围.sort((a, b) => a.距离 - b.距离);
                待显示爆炸范围 = { 爆炸范围: 爆炸范围, 范围: this.自定义数据.get("爆炸范围") }; //实际效果在 动画帧() 实现
            }

            处理爆炸效果(爆炸范围) {
                const 是否强化炸弹 = this.强化; // 获取强化状态

                爆炸范围.forEach(({ x, y }) => {
                    const 当前单元格 = 地牢[y]?.[x];
                    if (!当前单元格) return;

                    // --- 修改：条件化玩家伤害 ---
                    if (!是否强化炸弹 && 玩家.x === x && 玩家.y === y) {
                        伤害玩家(30, this.名称);
                        // --- 新增：非强化炸弹炸到玩家也给火焰效果 ---
                        const 火焰强度玩家 = 5; // 炸弹火焰更强?
                        const 火焰持续玩家 = 4;
                        new 状态效果("火焰", 效果颜色编号映射[效果名称编号映射.火焰], 图标映射.火焰, 火焰持续玩家, null, null, null, 火焰强度玩家);
                    }
                    // --- 结束修改 ---

                    // 对怪物造成伤害 (强化炸弹也造成伤害)
                    if (当前单元格.关联怪物) {
                        if (当前单元格.关联怪物.类型 !== "炸弹怪物" && 当前单元格.关联怪物.类型 !== "大魔法师") {
                            当前单元格.关联怪物.受伤(30, "炸弹");
                            const 火焰强度怪物 = 5;
                            const 火焰持续怪物 = 4;
                            new 状态效果("火焰", 效果颜色编号映射[效果名称编号映射.火焰], "火", 火焰持续怪物, null, null, 当前单元格.关联怪物, 火焰强度怪物);
                            添加日志(`${当前单元格.关联怪物.类型} 被爆炸点燃了！`, "警告");
                        }
                    }

                    // --- 修改：条件化物品清除 ---
                    if (!是否强化炸弹 && 当前单元格.关联物品) { // 只有非强化炸弹才清物品
                        const 被毁物品 = 当前单元格.关联物品;
                        const 计时器索引 = 所有计时器.findIndex(t => t.唯一标识 === 被毁物品.唯一标识);
                        if (计时器索引 !== -1) {
                            所有计时器.splice(计时器索引, 1);
                        }
                        添加日志(`${被毁物品.名称} 被炸毁了！`, "警告");
                        当前单元格.关联物品 = null;
                        当前单元格.类型 = null;
                    }
                    // --- 结束修改 ---

                    // 解锁门 (保持不变)
                    if (当前单元格.背景类型 === 单元格类型.上锁的门) {
                        当前单元格.背景类型 = 单元格类型.门;
                    }
                });

                // 移除炸弹自身引用
                if (地牢[this.y]?.[this.x]) {
                    地牢[this.y][this.x].关联物品 = null;
                    地牢[this.y][this.x].类型 = null;
                }

                // --- 新增：随机放置火焰 ---
                const 爆炸半径 = this.自定义数据.get('爆炸范围') ?? 3;
                const 火焰数量 = Math.floor(Math.random() * (爆炸半径 * 2)) + 1; // 随机1到爆炸半径*2个火焰
                const 可放火焰格子 = 爆炸范围.filter(({ x, y, 距离 }) =>
                    距离 > 0 && // 不在中心点放
                    地牢[y]?.[x] &&
                    !地牢[y][x].关联物品 && // 格子现在是空的（物品已清或强化弹没清）
                    !地牢[y][x].关联怪物 && // 没有怪物
                    [单元格类型.房间, 单元格类型.走廊, 单元格类型.门].includes(地牢[y][x].背景类型)
                );

                可放火焰格子.sort(() => Math.random() - 0.5);
                const 实际放置火焰数 = Math.min(火焰数量, 可放火焰格子.length);

                for (let i = 0; i < 实际放置火焰数; i++) {
                    const { x, y } = 可放火焰格子[i];
                    const 火焰 = new 火焰物品({ 强化: 是否强化炸弹 });
                    放置物品到单元格(火焰, x, y);
                }
                if (实际放置火焰数 > 0) {
                    添加日志(`爆炸产生了 ${实际放置火焰数} 处火焰！`, "信息");
                }
                // --- 结束：放置火焰 ---

                绘制(); // 最后绘制
            }
        }

        // 基类：界面元素
        class 界面元素基类 {
            constructor() {
                this.元素标识 = `元素_${Date.now()}_${Math.random()
                    .toString(36)
                    .substr(2, 9)}`;
                this.容器元素 = document.createElement("div");
                this.容器元素.className = "hud-item";
                this.容器元素.dataset.元素标识 = this.元素标识;
                document.querySelector(".hud").appendChild(this.容器元素);
            }

            销毁() {
                this.容器元素.remove();
                this.容器元素 = null;
            }

            更新(参数) {
                throw new Error("必须实现更新方法");
            }
        }

        // 文本行元素
        class 文本元素 extends 界面元素基类 {
            constructor(配置) {
                super();
                this.图标元素 = null;
                this.文本元素 = null;
                this.初始化(配置);
            }

            初始化({ 图标, 内容 }) {
                const 行容器 = document.createElement("div");
                行容器.className = "界面文本行";

                if (图标) {
                    this.图标元素 = document.createElement("span");
                    this.图标元素.className = "hud-icon";
                    this.图标元素.textContent = 图标;
                    行容器.appendChild(this.图标元素);
                }

                this.文本元素 = document.createElement("span");
                this.文本元素.className = "hud-label";
                this.文本元素.textContent = 内容;
                行容器.appendChild(this.文本元素);

                this.容器元素.appendChild(行容器);
                触发HUD显示();
            }

            更新({ 内容, 图标 }) {
                if (this.文本元素.textContent == 内容) return;
                if (内容) this.文本元素.textContent = 内容;
                if (图标) this.图标元素.textContent = 图标;
                触发HUD显示();
            }
        }

        // 进度条元素
        class 进度条元素 extends 界面元素基类 {
            constructor(配置) {
                super();
                this.进度条元素 = null;
                this.标签元素 = null;
                this.初始化(配置);
            }

            初始化({ 图标, 颜色, 初始值, 标签 }) {
                this.容器元素.innerHTML = `
                                                                        <span class="hud-icon">${图标 ||
                    "⚡"
                    }</span>
                                                                        <div class="hud-bar-container">
                                                                            <div class="hud-bar" style="width: ${初始值 ||
                    100
                    }%">
                                                                                <div class="进度条标签">${标签 ||
                    ""
                    }</div>
                                                                            </div>
                                                                        </div>
                                                                    `;

                this.进度条元素 = this.容器元素.querySelector(".hud-bar");
                this.标签元素 =
                    this.进度条元素.querySelector(".进度条标签");

                if (颜色) {
                    this.进度条元素.style.background = 颜色;
                }
                触发HUD显示();
            }

            更新({ 数值, 标签, 颜色 }) {
                if (
                    this.标签元素.textContent == 标签 &&
                    this.进度条元素.style.width == `${数值}%`
                )
                    return;
                if (数值 !== undefined) {
                    this.进度条元素.style.width = `${数值}%`;

                    // 自动添加低数值警告
                    if (数值 <= 20) {
                        this.进度条元素.classList.add("低数值警告");
                    } else {
                        this.进度条元素.classList.remove("低数值警告");
                    }
                }

                // 动态调整标签位置
                if (标签) {
                    this.标签元素.textContent = 标签;
                }

                if (颜色) {
                    this.进度条元素.style.background = 颜色;
                }
                触发HUD显示();
            }
        }

        // 使用示例：
        //const 药水条 = new 进度条元素({
        //图标: '🧪',
        //颜色: 'linear-gradient(to right, #00ff88, #00ccff)',
        //初始值: 80,
        //标签: '强化药水 80%'
        //});

        //const 任务提示 = new 文本元素({
        //    图标: '📜',
        //    内容: '主线任务：寻找古代遗物'
        //});

        // 更新元素示例
        //药水条.更新({ 数值: 15, 标签: '药水剩余 15%' });
        //任务提示.更新({ 内容: '紧急任务：击败守护者' });

        const 怪物追踪提示 = new 文本元素({
            内容: `追踪怪物：0`,
        });
        const 击杀提示 = new 文本元素({
            内容: `已击杀怪物：${已击杀怪物数}`,
        });

        // 单元格类
        class 单元格 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.类型 = 单元格类型.墙壁;
                this.墙壁 = { 上: false, 右: false, 下: false, 左: false };
                this.钥匙ID = null;
                this.颜色索引 = 颜色表.length;
                this.关联物品 = null;
                this.关联怪物 = null;
                this.背景类型 = 单元格类型.墙壁;
            }

            绘制() {
                // 绘制战争迷雾
                // 计算带小数偏移的屏幕坐标
                const 小数偏移X = (当前相机X % 1) * 单元格大小;
                const 小数偏移Y = (当前相机Y % 1) * 单元格大小;
                const 屏幕X = (this.x - 视口偏移X) * 单元格大小 - 小数偏移X;
                const 屏幕Y = (this.y - 视口偏移Y) * 单元格大小 - 小数偏移Y;
                const 房间ID = 房间地图[this.y][this.x];

                // 单元格属于某个房间且该房间未被访问过，没有特殊效果，则绘制迷雾
                if (当前天气效果.includes('深夜')) {
                    if (!是否在光源范围内(this.x, this.y)) {
                        ctx.fillStyle = "#000000"; // 深夜的纯黑
                        ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
                        return;
                    }
                }
                if (房间ID !== -1 && !已访问房间.has(房间ID) && !玩家属性.透视) {
                    ctx.fillStyle = "rgba(0, 0, 0)";
                    ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
                } else {
                    switch (this.背景类型) {
                        case 单元格类型.房间:
                            ctx.fillStyle = "#3a506b";
                            break;
                        case 单元格类型.走廊:
                            ctx.fillStyle = "#2b2d42";
                            break;
                        case 单元格类型.门:
                            ctx.fillStyle = "#8b4513";
                            break;
                        case 单元格类型.上锁的门:
                            ctx.fillStyle = 颜色表[this.颜色索引]; // 使用颜色索引
                            break;
                        case 单元格类型.楼梯下楼:
                        case 单元格类型.楼梯上楼:
                            ctx.fillStyle = "#3a506b";
                            ctx.fillRect(
                                屏幕X,
                                屏幕Y,
                                单元格大小,
                                单元格大小
                            );
                            this.绘制物品(屏幕X, 屏幕Y);
                            break;
                        default:
                            ctx.fillStyle = "#1a1a1a";
                    }
                    if (
                        this.背景类型 !== 单元格类型.物品 &&
                        this.背景类型 !== 单元格类型.楼梯下楼 &&
                        this.背景类型 !== 单元格类型.楼梯上楼
                    ) {
                        ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
                    }
                    ctx.strokeStyle =
                        this.背景类型 === 单元格类型.上锁的门
                            ? "#ffd700"
                            : "#e0e0e0";
                    ctx.lineWidth = 2;

                    // 绘制门（水平方向）
                    if (
                        this.墙壁.上 &&
                        (this.背景类型 === 单元格类型.门 ||
                            this.背景类型 === 单元格类型.上锁的门)
                    ) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X + 单元格大小 / 3, 屏幕Y);
                        ctx.lineTo(屏幕X + (单元格大小 * 2) / 3, 屏幕Y);
                        ctx.stroke();
                    } else if (this.墙壁.上) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X, 屏幕Y);
                        ctx.lineTo(屏幕X + 单元格大小, 屏幕Y);
                        ctx.stroke();
                    }

                    // 绘制普通墙壁
                    ctx.strokeStyle = "#e0e0e0";
                    if (this.墙壁.右) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X + 单元格大小, 屏幕Y);
                        ctx.lineTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小);
                        ctx.stroke();
                    }
                    if (this.墙壁.下) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小);
                        ctx.lineTo(屏幕X, 屏幕Y + 单元格大小);
                        ctx.stroke();
                    }
                    if (this.墙壁.左) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X, 屏幕Y + 单元格大小);
                        ctx.lineTo(屏幕X, 屏幕Y);
                        ctx.stroke();
                    }

                    if (this.关联物品) {
                        this.绘制物品(屏幕X, 屏幕Y);
                    }
                    if (this.关联怪物) {
                        ctx.fillStyle = "#FFFFFF";
                        ctx.font = `${单元格大小 * 0.8}px color-emoji`;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        if (this.关联怪物.隐身中) {
                            return;
                        }
                        this.关联怪物.绘制血条();
                        if (this.关联怪物.受击动画) {
                            ctx.fillStyle = "#FF0000"; // 受击时变红
                        } else {
                            ctx.fillStyle = this.关联怪物.颜色 || "#FFFFFF";
                        }
                        ctx.fillText(
                            this.关联怪物.图标,
                            (this.关联怪物.x - 当前相机X) * 单元格大小 +
                            单元格大小 / 2,
                            (this.关联怪物.y - 当前相机Y) * 单元格大小 +
                            单元格大小 / 2
                        );
                        if (怪物状态表.get(this.关联怪物)) {
                            ctx.fillStyle = 怪物状态表.get(this.关联怪物)?.颜色;
                            ctx.font = `${单元格大小 * 0.5}px Arial`;
                            ctx.fillText(
                                怪物状态表.get(this.关联怪物)?.图标,
                                (this.x - 当前相机X) * 单元格大小 + 单元格大小 * 0.7, // 右上角位置...暂时没想好单怪物多效果...
                                (this.y - 当前相机Y) * 单元格大小 + 单元格大小 * 0.3
                            );
                        } else if (this.关联怪物.强化) {
                            ctx.fillStyle = "#FF0000";
                            ctx.font = `${单元格大小 * 0.5}px Arial`;
                            ctx.fillText(
                                "强",
                                (this.关联怪物.x - 当前相机X) * 单元格大小 + 单元格大小 * 0.7,
                                (this.关联怪物.y - 当前相机Y) * 单元格大小 + 单元格大小 * 0.3
                            );
                        }
                    }
                }
            }
            绘制物品(屏幕X, 屏幕Y) {
                // 通用物品绘制逻辑
                if (this.关联物品) {
                    if (this.关联物品.是否为隐藏物品) {
                        return;//被隐藏的物品
                    }
                    ctx.font = `${单元格大小 * 0.8}px color-emoji`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    if (this.获取物品颜色() !== "#FFFFFF") {
                        ctx.fillStyle = this.获取物品颜色();
                    } else {
                        //alert(this.关联物品.图标);
                        ctx.fillStyle = "#000";
                    }
                    if (this.关联物品.类型 === "药水") {
                        ctx.fillStyle = this.关联物品.获取药水颜色();
                    }
                    if (this.关联物品.类型 === "金币") {
                        ctx.fillStyle = 颜色表[2];
                    }
                    ctx.fillText(
                        this.关联物品.显示图标,
                        屏幕X + 单元格大小 / 2,
                        屏幕Y + 单元格大小 / 2
                    );

                    // 添加物品光晕
                    if (this.颜色索引 < 颜色表.length) {
                        ctx.shadowColor = this.获取物品颜色();
                        if (this.关联物品.类型 === "药水") {
                            ctx.shadowColor = this.关联物品.获取药水颜色();
                        }
                        if (this.关联物品.类型 === "金币") {
                            ctx.shadowColor = 颜色表[2];
                        }
                        ctx.shadowBlur = 15;
                    }
                    if (this.关联物品 instanceof 火把 && this.关联物品.自定义数据.get("耐久") > 0) {
                        // 可以加一点简单的动画或效果
                        const 闪烁强度 = Math.abs(Math.sin(Date.now() / 200)); // 简单闪烁
                        ctx.shadowColor = `rgba(255, 165, 0, ${0.5 + 闪烁强度 * 0.4})`; // 橙黄色光晕
                        ctx.shadowBlur = 8 + 闪烁强度 * 5;
                    }
                    ctx.fillText(
                        this.关联物品.显示图标,
                        屏幕X + 单元格大小 / 2,
                        屏幕Y + 单元格大小 / 2
                    );
                    ctx.shadowBlur = 0;
                    if (this.关联物品.堆叠数量 > 1) {
                        ctx.font = `${单元格大小 * 0.4}px Arial`;
                        ctx.fillStyle = "#FFFFFF"; // 文字填充颜色为白色
                        ctx.strokeStyle = "#000000"; // 描边颜色为黑色
                        ctx.lineWidth = 2;
                        ctx.textAlign = "right";
                        ctx.textBaseline = "bottom";

                        // 先绘制描边，再绘制填充文字
                        ctx.strokeText( // 描边
                            this.关联物品.堆叠数量,
                            屏幕X + 单元格大小 - 4,
                            屏幕Y + 单元格大小 - 4
                        );
                        ctx.fillText( // 填充
                            this.关联物品.堆叠数量,
                            屏幕X + 单元格大小 - 4,
                            屏幕Y + 单元格大小 - 4
                        );
                    }
                    if (this.关联物品.是否被丢弃) {
                        ctx.save(); // 保存当前绘图状态
                        ctx.font = `${单元格大小 * 0.4}px Arial`; // 更小的字体
                        ctx.fillStyle = "#AAAAAA"; // 灰色文字
                        ctx.textAlign = "right";
                        ctx.textBaseline = "top";
                        ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; // 添加阴影
                        ctx.shadowBlur = 2;
                        ctx.shadowOffsetX = 1;
                        ctx.shadowOffsetY = 1;
                        ctx.fillText(
                            "丢", // 使用 "丢" 字
                            屏幕X + 单元格大小 - 3, // 右上角X
                            屏幕Y + 3  // 右上角Y
                        );
                        ctx.restore();
                    }
                    if (this.关联物品 instanceof 火把) {
                        const 耐久百分比 = this.关联物品.自定义数据.get("耐久") / this.关联物品.自定义数据.get("原耐久");
                        ctx.fillStyle = 'rgba(0,0,0,0.6)';
                        ctx.fillRect(屏幕X + 单元格大小 * 0.1, 屏幕Y + 单元格大小 * 0.85, 单元格大小 * 0.8, 单元格大小 * 0.1);
                        ctx.fillStyle = 耐久百分比 > 0.5 ? '#FFD700' : (耐久百分比 > 0.2 ? '#FFA500' : '#FF4500'); // 根据耐久变色
                        ctx.fillRect(屏幕X + 单元格大小 * 0.1, 屏幕Y + 单元格大小 * 0.85, 单元格大小 * 0.8 * 耐久百分比, 单元格大小 * 0.1);
                    }
                }
            }

            获取物品颜色() {
                // 根据物品类型返回颜色
                if (
                    this.类型 === 单元格类型.楼梯下楼 ||
                    this.类型 === 单元格类型.楼梯上楼
                )
                    return "#000";
                return this.关联物品
                    ? this.关联物品.颜色表[this.关联物品.颜色索引] ||
                    "#FFFFFF"
                    : "#FFFFFF";
            }
        }

        function drawPath(path) {
            if (path.length < 2) return;

            ctx.save();
            ctx.beginPath();

            // 设置线条样式
            ctx.strokeStyle = 'rgba(255, 50, 50, 0.5)';
            ctx.lineWidth = 2 * window.devicePixelRatio; // 适应高清屏
            ctx.setLineDash([5, 15]);
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            const startX = (玩家.x - 当前相机X + 0.5) * 单元格大小;
            const startY = (玩家.y - 当前相机Y + 0.5) * 单元格大小;
            ctx.moveTo(startX, startY);

            // 连接后续点
            for (let i = 1; i < path.length; i++) {
                const { x, y } = path[i];
                const pointX = (x - 当前相机X + 0.5) * 单元格大小;
                const pointY = (y - 当前相机Y + 0.5) * 单元格大小;
                ctx.lineTo(pointX, pointY);
            }

            ctx.stroke();
            ctx.restore();
        }
        物品池 = 创建物品池();
        怪物池 = 创建怪物池();

        // 屏幕方向检测
        let resizeTimer;
        function handleResize() {
            if (window.matchMedia("(orientation: portrait)").matches) {
                //canvas.style.transform = "scale(1)";
            } else {
                //canvas.style.transform = "scale(1.2)";
            }
            if (window.innerWidth < 769) {
                if (显示模式 === "装备") {
                    document.getElementById("小地图容器")?.classList.add("隐藏");
                    document.querySelector(".装备栏")?.classList.remove("隐藏");
                } else {
                    document.getElementById("小地图容器")?.classList.remove("隐藏");
                    document.querySelector(".装备栏")?.classList.add("隐藏");
                }
            } else {
                document.getElementById("小地图容器")?.classList.remove("隐藏");
                document.querySelector(".装备栏")?.classList.remove("隐藏");
            }
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                初始化canvas();
                更新物体指示器();
                绘制();
            }, 200); // 防抖处理
        }

        window.addEventListener("resize", handleResize);
        handleResize();

        function 开始移动() {

            控制键处理移动(true);
        }

        function 控制键处理移动(PC = false) {

            clearTimeout(移动定时器);
            clearTimeout(单击移动定时器); // 清除之前的 单击移动定时器

            const 立即移动 = () => {
                const dx = 移动状态.left ? -玩家属性.移动步数 : 移动状态.right ? 玩家属性.移动步数 : 0;
                const dy = 移动状态.up ? -玩家属性.移动步数 : 移动状态.down ? 玩家属性.移动步数 : 0;

                if (dx !== 0 || dy !== 0) {
                    移动玩家(dx, dy);
                }
            };

            const 持续移动 = () => {
                if (!移动状态.left && !移动状态.right && !移动状态.up && !移动状态.down) return;

                const now = Date.now();
                if (now - 最后移动时间 >= 移动间隔) {
                    长按移动 = true;
                    立即移动();
                    最后移动时间 = now;
                }
                移动定时器 = requestAnimationFrame(持续移动);
            };

            立即移动();
            if (PC) {
                长按移动 = true;
                最后移动时间 = Date.now();
                移动定时器 = setTimeout(() => {
                    cancelAnimationFrame(移动定时器);
                    移动定时器 = requestAnimationFrame(持续移动);
                }, 0);
            } else {
                最后移动时间 = Date.now();

                // 如果是长按，则在 首次移动延迟 后开始持续移动
                移动定时器 = setTimeout(() => {
                    cancelAnimationFrame(移动定时器);
                    移动定时器 = requestAnimationFrame(持续移动);
                }, 首次移动延迟);
            }

        }
        function 停止移动() {
            clearTimeout(移动定时器);
            clearTimeout(单击移动定时器);
            clearTimeout(开始移动定时器);
            移动状态 = { up: false, down: false, left: false, right: false, };
            长按移动 = false;
        }
        function 显示HUD() {
            if (hud模式 === "常隐") return;
            if (hud模式 === "默认") {
                if (显示HUD计时器) clearTimeout(显示HUD计时器);
                document.querySelector(".hud").classList.add("可见");
                显示HUD计时器 = setTimeout(() => {
                    隐藏HUD();
                }, 700);
            } else {
                document.querySelector(".hud").classList.add("可见");
            }
        }

        function 隐藏HUD() {
            if (hud模式 !== "默认") return;
            document.querySelector(".hud").classList.remove("可见");
        }

        function 切换HUD模式() {
            const 模式顺序 = ["默认", "常显", "常隐"];
            const 当前索引 = 模式顺序.indexOf(hud模式);
            hud模式 = 模式顺序[(当前索引 + 1) % 3];

            // 更新按钮图标
            const 按钮图标映射 = {
                默认: 图标映射.HUD智能,
                常显: 图标映射.HUD常显,
                常隐: 图标映射.HUD常隐,
            };
            document.getElementById("hudToggle").textContent =
                按钮图标映射[hud模式];

            // 立即应用新模式
            if (hud模式 === "常显") {
                document.querySelector(".hud").classList.add("可见");
            } else if (hud模式 === "常隐") {
                document.querySelector(".hud").classList.remove("可见");
            } else {
                隐藏HUD(); // 恢复默认模式隐藏
            }
        }
        function 触发HUD显示() {
            if (hud模式 === "默认") {
                if (显示HUD计时器) clearTimeout(显示HUD计时器);
                document.querySelector(".hud").classList.add("可见");
                显示HUD计时器 = setTimeout(() => {
                    隐藏HUD();
                }, 700);
            }
        }

        // 防止长按触发文字选择
        document.addEventListener("contextmenu", (e) => e.preventDefault());

        const 添加控制事件 = (元素, 方向) => {
            const 事件类型 = {
                start:
                    "ontouchstart" in window ? "touchstart" : "mousedown",
                end: "ontouchend" in window ? "touchend" : "mouseup",
            };

            元素.addEventListener(事件类型.start, (e) => {
                e.preventDefault();
                移动状态[方向] = true;
                控制键处理移动();
            });

            元素.addEventListener(事件类型.end, () => {
                移动状态[方向] = false;
                停止移动();
            });
        };

        添加控制事件(upBtn, "up");
        添加控制事件(leftBtn, "left");
        添加控制事件(rightBtn, "right");
        添加控制事件(downBtn, "down");
        function 深度比较(a, b) {
            if (a === b) return true;
            if (
                typeof a !== "object" ||
                typeof b !== "object" ||
                a === null ||
                b === null
            )
                return false;

            const aKeys = Object.keys(a);
            const bKeys = Object.keys(b);
            if (aKeys.length !== bKeys.length) return false;

            for (const key of aKeys) {
                if (!b.hasOwnProperty(key)) return false;
                if (!深度比较(a[key], b[key])) return false;
            }
            return true;
        }

        // 更新HUD显示
        function 更新界面状态() {
            document.getElementById("roomCount").textContent =
                已访问房间.size;
        }

        function 初始化canvas() {
            画布宽度 = Math.min(
                window.innerWidth - 20,
                window.innerHeight - 100
            ); // 动态宽度
            画布高度 = 画布宽度; // 动态高度

            // 保持单元格比例
            const 单元格宽 = 画布宽度 / 相机显示边长;
            const 单元格高 = 画布高度 / 相机显示边长;

            单元格大小 = Math.min(单元格宽, 单元格高);
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            const dpr = window.devicePixelRatio;
            const width = 单元格大小 * 相机显示边长, height = 单元格大小 * 相机显示边长;
            // 重新设置 canvas 自身宽高大小和 css 大小。放大 canvas；css 保持不变，因为我们需要那么多的点
            canvas.width = Math.round(width * dpr);
            canvas.height = Math.round(height * dpr);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            // 直接用 scale 放大整个坐标系，相对来说就是放大了每个绘制操作
            ctx.scale(dpr, dpr);
            // 初始化小地图
            const 小地图 = document.getElementById("小地图");
            小地图.width = 地牢大小 * 小地图缩放;
            小地图.height = 地牢大小 * 小地图缩放;
            小地图Ctx = 小地图.getContext("2d");
        }

        function 生成地牢() {
            地牢 = Array(地牢大小).fill().map((_, y) => Array(地牢大小).fill().map((_, x) => new 单元格(x, y)));

            let 已连接房间对 = new Set();

            let 房间宽度 = 房间尺寸范围[0] + 2 * Math.floor((Math.random() * (房间尺寸范围[1] - 房间尺寸范围[0])) / 2);
            let 房间高度 = 房间尺寸范围[0] + 2 * Math.floor((Math.random() * (房间尺寸范围[1] - 房间尺寸范围[0])) / 2);
            let 房间起始X = Math.floor(地牢大小 / 2 - 房间宽度 / 2);
            let 房间起始Y = Math.floor(地牢大小 / 2 - 房间高度 / 2);
            房间列表.push({ x: 房间起始X, y: 房间起始Y, w: 房间宽度, h: 房间高度, id: 0, 门: [], });
            放置房间(房间列表[0]);
            let 回溯 = false;
            for (let i = 1; i < 最大房间数; i++) {
                let 放置成功 = false;
                let 尝试次数 = 0;

                while (!放置成功 && 尝试次数 < 300) {
                    尝试次数++;
                    let 上一个房间 = 房间列表[i - 1];
                    if (回溯) 上一个房间 = 房间列表[i - Math.floor(Math.max(0, 尝试次数 - 10) / 40 * (房间列表.length - 2)) - 1];
                    房间宽度 = 房间尺寸范围[0] + 2 * Math.floor((Math.random() * (房间尺寸范围[1] - 房间尺寸范围[0])) / 2);
                    房间高度 = 房间尺寸范围[0] + 2 * Math.floor((Math.random() * (房间尺寸范围[1] - 房间尺寸范围[0])) / 2);

                    const 方向 = Math.floor(Math.random() * 4);

                    const 扩展距离 = Math.floor(Math.random() * Math.max(0, 尝试次数 - 10)) + 房间尺寸范围[1] + 2;

                    switch (方向) {
                        case 0:
                            房间起始X = 上一个房间.x + Math.floor((上一个房间.w - 房间宽度) / 2);
                            房间起始Y = 上一个房间.y - 房间高度 - 扩展距离;
                            break;
                        case 1:
                            房间起始X = 上一个房间.x + 上一个房间.w + 扩展距离;
                            房间起始Y = 上一个房间.y + Math.floor((上一个房间.h - 房间高度) / 2);
                            break;
                        case 2:
                            房间起始X = 上一个房间.x + Math.floor((上一个房间.w - 房间宽度) / 2);
                            房间起始Y = 上一个房间.y + 上一个房间.h + 扩展距离;
                            break;
                        case 3:
                            房间起始X = 上一个房间.x - 房间宽度 - 扩展距离;
                            房间起始Y = 上一个房间.y + Math.floor((上一个房间.h - 房间高度) / 2);
                            break;
                    }

                    房间起始X = Math.max(5, Math.min(房间起始X, 地牢大小 - 房间宽度 - 5));
                    房间起始Y = Math.max(5, Math.min(房间起始Y, 地牢大小 - 房间高度 - 5));

                    if (区域是否空闲(房间起始X, 房间起始Y, 房间宽度, 房间高度)) {
                        const 新房间 = { x: 房间起始X, y: 房间起始Y, w: 房间宽度, h: 房间高度, id: i, 门: [] };
                        房间列表.push(新房间);
                        放置房间(新房间);
                        const 房间对ID = [房间列表[i - 1].id, 新房间.id].sort().join('-');
                        // 检查是否已经连接过
                        if (!已连接房间对.has(房间对ID)) {
                            let 路径 = 连接房间(房间列表[i - 1], 新房间);
                            if (路径) {
                                生成走廊(路径);
                                已连接房间对.add(房间对ID);
                            }
                        }

                        放置成功 = true;
                    }
                }
                回溯 = false;
                if (!放置成功) {
                    console.log(`第${i}个房间多次尝试后仍然放置失败`);
                    回溯 = true;
                }
            }
            添加额外走廊(房间列表, 5, 已连接房间对);
            let has特殊房间生成 = false
            if (Math.random() < 0.5) {
                生成特殊房间();
                has特殊房间生成 = true;
            }
            const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            生成墙壁();

            const 第一个房间 = 房间列表[0];
            玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
            玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
            玩家.x = 玩家初始位置.x;
            玩家.y = 玩家初始位置.y;

            if (房间列表.length > 4) {
                处理上锁的门();
                生成钥匙();
            }
            if (has特殊房间生成) 生成寻宝戒指();
            生成金币();
            生成物品();
            生成怪物();
            if (当前层数 === 0) {
                const 初始武器 = new 钢制长剑({ 不可破坏: true }); //初始装备
                放置物品到房间(初始武器, 房间列表[0]);
            }
            更新视口();
            已访问房间.add(第一个房间.id); // 标记为已访问
            房间列表.forEach((房间) => 更新房间墙壁(房间));

            const 距离图 = 计算距离图(玩家初始位置.x, 玩家初始位置.y);

            // 寻找最远的可达房间（非特殊、非起点）
            let 最远距离 = -1;
            let 最远房间 = null;
            const 可用房间放楼梯 = 房间列表.filter(房间 =>
                房间.id !== 0 && 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间"
            );

            可用房间放楼梯.forEach(房间 => {
                const 中心X = 房间.x + Math.floor(房间.w / 2);
                const 中心Y = 房间.y + Math.floor(房间.h / 2);
                const 距离 = 距离图[中心Y]?.[中心X]; // 使用中心点距离

                if (距离 !== undefined && 距离 !== Infinity && 距离 > 最远距离) {
                    最远距离 = 距离;
                    最远房间 = 房间;
                }
            });

            if (!最远房间 && 可用房间放楼梯.length > 0) {
                最远房间 = 可用房间放楼梯[Math.floor(Math.random() * 可用房间放楼梯.length)];
                console.warn("未能通过距离找到最远房间放置楼梯，已随机选择。");
            }
            放置楼梯(最远房间, 楼梯图标.下楼, 单元格类型.楼梯下楼);
            if (当前层数 > 0) {
                放置楼梯(第一个房间, 楼梯图标.上楼, 单元格类型.楼梯上楼);
            }
            更新界面状态();
            return;
        }
        function 计算距离图(起始X, 起始Y) {
            const 距离图 = Array(地牢大小).fill(null).map(() => Array(地牢大小).fill(Infinity));
            const 队列 = [[起始X, 起始Y, 0]]; // x, y, 距离
            距离图[起始Y][起始X] = 0;
            const 已访问 = new Set([`${起始X},${起始Y}`]);
            const 方向 = [
                { dx: 0, dy: -1, 当前墙: "上", 反方向墙: "下" },
                { dx: 0, dy: 1, 当前墙: "下", 反方向墙: "上" },
                { dx: -1, dy: 0, 当前墙: "左", 反方向墙: "右" },
                { dx: 1, dy: 0, 当前墙: "右", 反方向墙: "左" },
            ];

            while (队列.length > 0) {
                const [x, y, 距离] = 队列.shift();

                for (const dir of 方向) {
                    const 新X = x + dir.dx;
                    const 新Y = y + dir.dy;

                    if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;

                    const 位置键 = `${新X},${新Y}`;
                    if (已访问.has(位置键)) continue;

                    const 当前单元格 = 地牢[y]?.[x];
                    const 下一单元格 = 地牢[新Y]?.[新X];

                    // 检查移动是否有效（非墙、非锁门、路径通畅）
                    if (当前单元格 && 下一单元格 &&
                        ![单元格类型.墙壁, 单元格类型.上锁的门].includes(下一单元格.背景类型) &&
                        !当前单元格.墙壁[dir.当前墙] && !下一单元格.墙壁[dir.反方向墙]) {
                        距离图[新Y][新X] = 距离 + 1;
                        已访问.add(位置键);
                        队列.push([新X, 新Y, 距离 + 1]);
                    }
                }
            }
            return 距离图;
        }
        function 生成特殊房间() {
            let 房间宽度 = 7;
            let 房间高度 = 7;
            let 房间起始X, 房间起始Y;
            let 放置成功 = false;
            let 尝试次数 = 0;

            while (!放置成功 && 尝试次数 < 100) {
                尝试次数++;
                房间起始X = Math.floor(Math.random() * (地牢大小 - 房间宽度 - 2)) + 1; // 边缘留空
                房间起始Y = Math.floor(Math.random() * (地牢大小 - 房间高度 - 2)) + 1;

                if (区域是否空闲(房间起始X, 房间起始Y, 房间宽度, 房间高度)) {
                    const 新房间 = {
                        x: 房间起始X,
                        y: 房间起始Y,
                        w: 房间宽度,
                        h: 房间高度,
                        id: 房间列表.length,
                        门: [],
                        已连接: false,
                        类型: Math.random() < 0.5 ? "解谜棋盘" : "boss房间" // 随机选择类型
                    };
                    房间列表.push(新房间);
                    放置房间(新房间);

                    // 根据房间类型执行特定逻辑
                    if (新房间.类型 === "解谜棋盘") {
                        生成解谜棋盘(新房间);
                    } else {
                        放置怪物到单元格(new 大魔法师({ 强化: true, 状态: 怪物状态.休眠 }), 新房间.x + 2, 新房间.y + 2);
                    }
                    放置成功 = true;
                }
            }
        }
        function 生成寻宝戒指() {
            // 排除已经作为特殊房间的房间
            const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            if (可用房间.length === 0) return; // 没有可用房间则不生成

            const 目标房间 = 可用房间[Math.floor(Math.random() * 可用房间.length)];
            const 新戒指 = new 寻宝戒指({ 生效层数: 当前层数 });
            放置物品到房间(新戒指, 目标房间);
        }

        function 连接特殊房间(特殊房间) {
            let 最近房间 = null;
            let 最小距离 = Infinity;

            for (const 房间 of 房间列表) {
                if (房间 === 特殊房间 || 房间.已连接) continue; // 排除特殊房间本身和已连接的房间

                const 距离 = Math.abs(特殊房间.x - 房间.x) + Math.abs(特殊房间.y - 房间.y);
                if (距离 < 最小距离) {
                    最小距离 = 距离;
                    最近房间 = 房间;
                }
            }
            if (最近房间) {
                let 路径 = 连接房间(特殊房间, 最近房间);

                if (路径) {
                    生成走廊(路径);
                    特殊房间.已连接 = true; // 标记为已连接
                } else {
                    添加日志(`无法将特殊房间连接到地牢！房间 ID: ${特殊房间.id}`, `错误`);
                }
            } else {
                添加日志(`没有找到可连接的房间！房间 ID: ${特殊房间.id}`, `错误`);
            }
        }
        function 生成墙壁() {
            for (let y = 0; y < 地牢大小; y++) {
                for (let x = 0; x < 地牢大小; x++) {
                    const 当前单元格 = 地牢[y][x];
                    if (当前单元格.背景类型 !== 单元格类型.墙壁) {
                        if ([单元格类型.墙壁, 单元格类型.走廊, 单元格类型.房间].includes(当前单元格.背景类型)) {
                            地牢[y][x].墙壁 = {
                                上: (y > 0 && 地牢[y - 1][x].背景类型 !== 地牢[y][x].背景类型 && [单元格类型.墙壁, 单元格类型.走廊, 单元格类型.房间].includes(地牢[y - 1][x].背景类型)),
                                下: (y < 地牢大小 - 1 && 地牢[y + 1][x].背景类型 !== 地牢[y][x].背景类型 && [单元格类型.墙壁, 单元格类型.走廊, 单元格类型.房间].includes(地牢[y + 1][x].背景类型)),
                                左: (x > 0 && 地牢[y][x - 1].背景类型 !== 地牢[y][x].背景类型 && [单元格类型.墙壁, 单元格类型.走廊, 单元格类型.房间].includes(地牢[y][x - 1].背景类型)),
                                右: (x < 地牢大小 - 1 && 地牢[y][x + 1].背景类型 !== 地牢[y][x].背景类型 && [单元格类型.墙壁, 单元格类型.走廊, 单元格类型.房间].includes(地牢[y][x + 1].背景类型)),
                            };
                        } else {
                            地牢[y][x].墙壁 = {
                                上: (y > 0 && 地牢[y - 1][x].背景类型 === 单元格类型.墙壁),
                                下: (y < 地牢大小 - 1 && 地牢[y + 1][x].背景类型 === 单元格类型.墙壁),
                                左: (x > 0 && 地牢[y][x - 1].背景类型 === 单元格类型.墙壁),
                                右: (x < 地牢大小 - 1 && 地牢[y][x + 1].背景类型 === 单元格类型.墙壁),
                            };
                        }
                        const directions = [
                            { dx: 0, dy: -1, 墙: "上", 反向墙: "下" },
                            { dx: 0, dy: 1, 墙: "下", 反向墙: "上" },
                            { dx: -1, dy: 0, 墙: "左", 反向墙: "右" },
                            { dx: 1, dy: 0, 墙: "右", 反向墙: "左" },
                        ];

                        directions.forEach(dir => {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;

                            if (nx >= 0 && nx < 地牢大小 && ny >= 0 && ny < 地牢大小) {
                                if (地牢[ny][nx].背景类型 === 单元格类型.墙壁) {
                                    地牢[y][x].墙壁[dir.墙] = true;           // 当前单元格
                                    地牢[ny][nx].墙壁[dir.反向墙] = true;    // 相邻单元格
                                }
                            }
                        });
                    }
                }
            }
        }
        function 添加额外走廊(房间列表, 数量, 已连接房间对) {
            let 添加次数 = 0;
            let 尝试次数 = 0;

            while (添加次数 < 数量 && 尝试次数 < 100) {
                尝试次数++;

                const 房间A = 房间列表[Math.floor(Math.random() * 房间列表.length)];
                const 房间B = 房间列表[Math.floor(Math.random() * 房间列表.length)];
                if (房间A === 房间B) continue;

                const 房间对ID = [房间A.id, 房间B.id].sort().join('-');
                if (已连接房间对.has(房间对ID)) {
                    continue;
                }

                const 路径 = 连接房间(房间A, 房间B);

                if (路径) {
                    已连接房间对.add(房间对ID);
                    生成走廊(路径);
                    添加次数++;
                }

            }
        }
        function 玩家死亡() {
            if (死亡界面已显示) return;
            死亡界面已显示 = true;

            const 死亡遮罩 = document.createElement("div");
            死亡遮罩.id = "死亡遮罩";
            死亡遮罩.innerHTML = `
                                                                    <div class="死亡内容容器">
                                                                        <div class="骷髅容器">
                                                                            <div class="动态骷髅">${图标映射.死亡图标}</div>
                                                                        </div>
                                                                        <div class="重生选项">
                                                                            <button class="重生按钮" id="保留重生">
                                                                                <span class="按钮图标">⚡</span>
                                                                                从本层重生（保留物品）
                                                                            </button>
                                                                            <button class="重生按钮" id="重新开始">
                                                                                <span class="按钮图标">🔄</span>
                                                                                全新开始（第0层）
                                                                            </button>
                                                                        </div>
                                                                    </div>
                                                                `;
            if (!是否为教程层) {
                let 死亡凭证 = 生成死亡凭证(当前层数);
                添加日志(`您已死亡，但您曾经到达 ${当前层数} 层，您的凭证是：` + 死亡凭证, "信息");
                CopyTextToClipboard(死亡凭证);
            }

            // 添加粒子效果
            const 粒子容器 = document.createElement("div");
            粒子容器.className = "死亡粒子";
            死亡遮罩.appendChild(粒子容器);
            生成死亡粒子(粒子容器);

            // 按钮交互
            死亡遮罩.querySelectorAll(".重生按钮").forEach((按钮) => {
                按钮.addEventListener("click", function () {
                    if (按钮.id === "保留重生") {
                        处理重生(true);
                    } else {
                        处理重生(false);
                    }
                    this.style.transform = "scale(0.95)";
                    setTimeout(() => (this.style.transform = ""), 500);
                });

                按钮.addEventListener("mouseenter", () => {
                    按钮.style.background =
                        "linear-gradient(145deg, rgba(120,0,0,0.9), rgba(180,0,0,0.7))";
                });

                按钮.addEventListener("mouseleave", () => {
                    按钮.style.background = "";
                });
            });

            document.body.appendChild(死亡遮罩);
        }

        function 生成物品(生成房间 = null) {
            const 当前层数权重 = Math.min(Math.floor(当前层数 / 2), 1); // 每2层提升品质
            let 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            if (生成房间) 可用房间 = 生成房间
            可用房间.forEach((房间) => {
                const 是否上锁 = 上锁房间列表.some((r) => r.id === 房间.id);
                const 房间类型 = 是否上锁 ? "上锁房间" : "普通房间";
                const 基础概率 = 是否上锁
                    ? 物品生成配置.基础概率.上锁房间
                    : 物品生成配置.基础概率.普通房间;

                // 计算实际生成概率
                let 实际概率 = 基础概率;
                if (是否上锁) 实际概率 += 0.1 + 当前层数 * 0.05;
                实际概率 = Math.min(实际概率, 0.85);

                if (Math.random() > 实际概率) return;
                let 物品数量 = 1;
                if (是否上锁) {

                    while (Math.random() < 0.8) {
                        物品数量++;
                    }
                    物品数量 = Math.min(物品数量, 5);
                }
                for (let i = 0; i < 物品数量; i++) {
                    // 计算品质分布
                    const 品质分布 = Object.entries(
                        物品生成配置.品质权重
                    ).reduce((acc, [品质, 权重]) => {
                        const 总权重 = 权重[0] + 权重[1] * 当前层数权重;
                        if (总权重 > 0)
                            acc.push({ 品质: parseInt(品质), 权重: 总权重 });
                        return acc;
                    }, []);

                    // 选择物品类型
                    const 类型分布 = 物品生成配置.类型分布[房间类型];
                    const 选中类型 = 加权随机选择(类型分布);

                    // 过滤可用物品
                    const 可用物品 = 物品池[选中类型["类型"]].filter(
                        (item) =>
                            当前层数 >= item.最小层 &&
                            品质分布.some((q) => q.品质 === item.品质)
                    );

                    if (可用物品.length === 0) return;

                    // 加权选择品质
                    const 目标品质 = 加权随机选择(
                        品质分布.map((q) => ({
                            值: q.品质,
                            权重: q.权重,
                        }))
                    );

                    // 筛选符合品质的物品
                    const 候选物品 = 可用物品.filter(
                        (item) => item.品质 === 目标品质
                    );
                    if (候选物品.length === 0) return;

                    // 创建物品实例
                    const 选中物品配置 =
                        候选物品[
                        Math.round(Math.random() * (候选物品.length - 1))
                        ];
                    const 新物品 = new 选中物品配置.类({});

                    if (是否上锁) {
                        新物品.强化 = true;
                    }

                    // 尝试放置物品
                    if (!放置物品到房间(新物品, 房间)) {
                        console.log("物品放置失败，位置被占用");
                    }
                }
            });
        }
        function 生成怪物() {
            const 当前层数权重 = Math.floor(当前层数 / 3); // 每3层上上强度
            const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            可用房间.forEach((房间) => {
                if (房间.id === 0) return;//原来js不能用countinue (误)
                const 是否上锁 = 上锁房间列表.some((r) => r.id === 房间.id);
                const 房间类型 = 是否上锁 ? "上锁房间" : "普通房间";

                const 候选怪物 = 怪物池[房间类型].filter(
                    m => 当前层数 >= m.最小层
                );

                if (候选怪物.length === 0) return;

                const 最大生成数 = 是否上锁 ? 最大怪物数 + 2 : 最大怪物数;
                let 生成数量 = Math.round(Math.random() * Math.random() * Math.random() * 最大生成数 + 当前层数权重);

                for (let i = 0; i < 生成数量; i++) {
                    const 总权重 = 候选怪物.reduce((sum, m) => sum + m.权重, 0);
                    let 随机值 = Math.random() * 总权重;
                    let 选中配置 = null;

                    for (const m of 候选怪物) {
                        if (随机值 <= m.权重) {
                            选中配置 = m;
                            break;
                        }
                        随机值 -= m.权重;
                    }

                    let 生成成功 = false;
                    for (let 尝试次数 = 0; 尝试次数 < 10; 尝试次数++) {
                        const x = 房间.x + Math.floor(Math.random() * 房间.w);
                        const y = 房间.y + Math.floor(Math.random() * 房间.h);

                        if (地牢[y][x].背景类型 === 单元格类型.房间 && !地牢[y][x].关联怪物 && !地牢[y][x].关联物品) {
                            const 新怪物 = new 选中配置.类({
                                x: x,
                                y: y,
                                房间ID: 房间.id,
                                强化: 是否上锁,
                                基础攻击力: 3 + 当前层数权重,
                            });
                            新怪物.基础生命值 += 当前层数权重 * 3;
                            新怪物.当前生命值 += 当前层数权重 * 3;
                            放置怪物到单元格(新怪物, x, y);
                            生成成功 = true;
                            break;
                        }
                    }
                }
            });
        }

        function 加权随机选择(选项列表) {
            const 乱序列表 = [...选项列表].sort(() => Math.random() - 0.5);

            // 计算累计权重
            let 累计权重 = 0;
            const 累计列表 = 乱序列表.map((opt) => {
                累计权重 += opt.权重;
                return { ...opt, 累计权重 };
            });

            const 随机值 = Math.random() * 累计权重;

            // 进行一个二分
            let left = 0;
            let right = 累计列表.length - 1;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                if (随机值 <= 累计列表[mid].累计权重) {
                    if (mid === 0 || 随机值 > 累计列表[mid - 1].累计权重) {
                        return 累计列表[mid].值 || 累计列表[mid];
                    }
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }

            return 累计列表[0]?.值 || 累计列表[0];
        }

        function 生成死亡粒子(容器) {
            const 粒子数量 = 30;
            const 颜色 = ["#ff0000", "#ff4444", "#ff8888"];

            for (let i = 0; i < 粒子数量; i++) {
                const 粒子 = document.createElement("div");
                粒子.className = "死亡粒子";
                粒子.style.cssText = `
                                                                        position: absolute;
                                                                        width: ${Math.random() *
                    4 +
                    2
                    }px;
                                                                        height: ${Math.random() *
                    4 +
                    2
                    }px;
                                                                        background: ${颜色[
                    Math.floor(
                        Math.random() *
                        颜色.length
                    )
                    ]
                    };
                                                                        border-radius: 50%;
                                                                        left: ${Math.random() *
                    100
                    }%;
                                                                        top: ${Math.random() *
                    100
                    }%;
                                                                        animation: 粒子飘落 ${Math.random() *
                    3 +
                    2
                    }s linear infinite;
                                                                        opacity: ${Math.random() *
                    0.6 +
                    0.4
                    };
                                                                    `;
                容器.appendChild(粒子);
            }
        }
        function 处理重生(保留物品) {

            if (当前天气效果.includes("诡魅")) {
                处理诡魅房间刷新(玩家.x, 玩家.y, 玩家初始位置.x, 玩家初始位置.y);
            }
            // 重置玩家状态
            const 生命条 = document.querySelector(".health-bar");
            生命条.style.width = "100%";
            document.querySelector(".power-bar").style.width = `100%`;
            玩家状态.forEach((m) => {
                m.移除状态();
            });
            if (当前激活卷轴列表.size > 0) {
                当前激活卷轴列表.forEach(卷轴 => {
                    当前激活卷轴列表.delete(卷轴);
                    卷轴.卸下();

                });
                恢复卷轴模式();
            }
            玩家属性 = { ...初始玩家属性 };
            玩家状态 = [];
            if (保留物品) {
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;
                玩家背包.forEach((item) => {
                    if (
                        item.类型 === "武器" &&
                        item.自定义数据.get("冷却剩余") > 0
                    ) {
                        item.自定义数据.set("冷却剩余", 0);
                    }
                });

                更新装备显示();
            } else {
                玩家背包.clear();
                玩家装备.clear();
                所有地牢层.clear();
                已访问房间.clear(); // 好像没必要 Orz..
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;

                地牢 = [];
                房间列表 = [];
                所有计时器 = []; //Q：为什么不清理所有怪物 A：这是属于切换楼层的事
                if (当前层数 !== null) {
                    切换楼层(0, true);
                } else {
                    进入教程层();
                }
                更新背包显示();
                更新装备显示();

                更新界面状态();
                更新物体指示器();
            }
            document.getElementById("卷轴按钮").style.display = [
                ...玩家装备.values(),
            ].some((item) => item.类型 === "卷轴")
                ? "flex"
                : "none";
            // 恢复控制
            const 死亡遮罩 = document.getElementById("死亡遮罩");
            if (死亡遮罩) 死亡遮罩.remove();
            死亡界面已显示 = false;
            更新视口();
            所有怪物.forEach((m) => {
                m.绘制血条();
            });
        }
        function 切换楼层(新层数, 完全重生 = false, 目标坐标 = null) {
            const 遮罩 = document.getElementById("transitionMask");
            const 标题 = document.getElementById("floorTitle");

            // 第一阶段：淡出+标题动画
            遮罩.style.opacity = 1;
            标题.textContent = `地牢 ${新层数 < 0 ? 当前层数 - 1 : 新层数}`; // 修正负层数显示

            setTimeout(() => {
                标题.style.opacity = 1;
                标题.style.transform = "scale(1)";
            }, 200);

            // 第二阶段：切换数据
            setTimeout(() => {
                // 保存离开的楼层数据 (包括其天气)
                const 当前数据 = {
                    地牢数组: 地牢,
                    房间列表: 房间列表,
                    门实例列表: 门实例列表,
                    玩家位置: { x: 玩家.x, y: 玩家.y },
                    上锁房间列表: 上锁房间列表,
                    已访问房间: 已访问房间,
                    房间地图: 房间地图,
                    所有怪物: 所有怪物,
                    玩家初始位置: { x: 玩家初始位置.x, y: 玩家初始位置.y },
                    所有计时器: 所有计时器,
                    当前天气效果: [...当前天气效果], // 保存离开楼层的天气
                };
                所有怪物.forEach((m) => { m.绘制血条(true); }); // 清理旧怪物显示
                if (当前层数 !== null && !完全重生) {
                    所有地牢层.set(当前层数, 当前数据);
                }
                

                // 设置新层数
                当前层数 = 新层数;

                // 加载或生成新楼层
                if (所有地牢层.has(新层数)) {
                    // 加载已存在的楼层数据
                    const 新地牢数据 = 所有地牢层.get(新层数);
                    地牢 = 新地牢数据.地牢数组;
                    房间列表 = 新地牢数据.房间列表;
                    门实例列表 = 新地牢数据.门实例列表;
                    if (目标坐标 && 位置是否可用(目标坐标.x, 目标坐标.y, false)) { // 检查传送目标点是否有效
                        玩家.x = 目标坐标.x;
                        玩家.y = 目标坐标.y;
                    } else {
                             玩家.x = 新地牢数据.玩家位置.x;
                             玩家.y = 新地牢数据.玩家位置.y;
                         }
                    上锁房间列表 = 新地牢数据.上锁房间列表;
                    已访问房间 = 新地牢数据.已访问房间;
                    房间地图 = 新地牢数据.房间地图;
                    所有怪物 = 新地牢数据.所有怪物;
                    所有计时器 = 新地牢数据.所有计时器;
                    玩家初始位置 = 新地牢数据.玩家初始位置;
                    当前天气效果 = 新地牢数据.当前天气效果 || []; // 加载新楼层的天气到全局变量
                } else {
                    // 生成新楼层
                    
                    房间列表 = [];
                    上锁房间列表 = [];
                    所有怪物 = [];
                    所有计时器 = [];
                    已访问房间 = new Set();
                    房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
                    门实例列表 = new Map();

                    // 在生成地牢内容之前确定天气
                    if (当前层数 !== null && 当前层数 % 3 === 0 && 当前层数 !== 0) {
                        生成天气效果(); // 生成的天气会放入全局 当前天气效果
                    } else {
                        当前天气效果 = []; // 无天气
                    }
                    生成地牢(); // 生成地牢内容
                    // 新生成楼层的天气已在全局 当前天气效果 中，将在下次切换楼层时存入 所有地牢层
                }

                // 更新UI和游戏状态
                更新视口();
                绘制(); // 绘制新楼层
                更新界面状态();
                更新物体指示器();
                所有怪物.forEach((m) => { m.绘制血条(); }); // 绘制新怪物的血条
                移动玩家(0, 0); //刷新回合，处理新楼层的怪物等

                // 第三阶段：淡入+标题消失
                标题.style.opacity = 0;
                标题.style.transform = "scale(0.5)";
                遮罩.style.opacity = 0;
            }, 1500);
        }
function 保存传送点() {
            if (传送点列表.length >= 最大传送点数量) {
                显示通知(`最多只能保存 ${最大传送点数量} 个传送点！`, "错误");
                return;
            }

            const 当前位置标识 = `${当前层数}-${玩家.x}-${玩家.y}`;
            // 检查是否已在完全相同的位置保存过
            if (传送点列表.some(点 => `${点.层数}-${点.x}-${点.y}` === 当前位置标识)) {
                 显示通知("当前位置已存在传送点！", "警告");
                 return;
            }


            // 允许玩家输入名称，或者使用默认名称
            let 传送点名称 = prompt(`为传送点命名（可选，当前：第 ${当前层数} 层 (${玩家.x}, ${玩家.y})）：`, `第 ${当前层数} 层 (${玩家.x}, ${玩家.y})`);
            if (传送点名称 === null) return; // 用户取消
            if (传送点名称.trim() === "") {
                 传送点名称 = `第 ${当前层数} 层 (${玩家.x}, ${玩家.y})`; // 默认名称
            }

            const 新传送点 = {
                id: Date.now().toString() + Math.random().toString(36).substring(2, 7), // 简单唯一ID
                名称: 传送点名称,
                层数: 当前层数,
                x: 玩家.x,
                y: 玩家.y,
            };

            传送点列表.push(新传送点);
            显示通知(`传送点 "${新传送点.名称}" 已保存！`, "成功");
            关闭设置菜单(); // 保存后关闭设置菜单
             console.log("当前传送点列表:", 传送点列表);
        }

        /**
         * 打开传送点选择菜单
         */
        function 打开传送菜单() {
            if (当前天气效果.includes("诡魅")) {
                 显示通知("诡异的气息干扰了空间传送！", "错误");
                 return;
            }
            const 遮罩 = document.getElementById("传送点遮罩");
            const 菜单 = document.getElementById("传送点菜单");
            const 列表容器 = document.getElementById("传送点列表容器");

            列表容器.innerHTML = ""; // 清空旧列表

            if (传送点列表.length === 0) {
                列表容器.innerHTML = "<p style='text-align: center; color: #888;'>没有已保存的传送点。</p>";
            } else {
                传送点列表.forEach(点 => {
                    const 条目元素 = document.createElement("div");
                    条目元素.className = "重铸物品"; // 复用样式
                    条目元素.style.display = "flex"; // 改为flex布局方便按钮排列
                    条目元素.style.justifyContent = "space-between";
                    条目元素.style.alignItems = "center";
                    条目元素.style.padding = "10px 15px"; // 调整内边距

                    const 名称元素 = document.createElement("span");
                    名称元素.textContent = `${点.名称}`; // 只显示名称，更简洁
                    名称元素.style.flexGrow = "1"; // 让名称占据更多空间
                    名称元素.style.marginRight = "10px"; // 和按钮间加点距离

                    const 操作容器 = document.createElement("div");
                    操作容器.style.display = "flex";
                    操作容器.style.gap = "5px"; // 按钮间距

                    const 传送按钮 = document.createElement("button");
                    传送按钮.textContent = "传送";
                    传送按钮.className = "通用按钮"; // 复用按钮样式
                     传送按钮.style.padding = "4px 8px"; // 按钮小一点
                     传送按钮.style.fontSize = "0.9em";
                    传送按钮.onclick = (事件) => {
                        事件.stopPropagation(); // 防止触发外层div的点击（如果外层也加了事件）
                        执行传送(点.id);
                    };

                    const 删除按钮 = document.createElement("button");
                    删除按钮.textContent = "删除";
                    删除按钮.className = "通用按钮";
                     删除按钮.style.padding = "4px 8px";
                     删除按钮.style.fontSize = "0.9em";
                     删除按钮.style.background = "linear-gradient(145deg, #e57373, #f44336)"; // 红色系
                     删除按钮.style.borderColor = "#e53935";
                    删除按钮.onclick = (事件) => {
                         事件.stopPropagation();
                         删除传送点(点.id);
                    };

                    操作容器.appendChild(传送按钮);
                    操作容器.appendChild(删除按钮);

                    条目元素.appendChild(名称元素);
                    条目元素.appendChild(操作容器);
                    列表容器.appendChild(条目元素);
                });
            }

            遮罩.style.display = "block";
            // 触发菜单的入场动画 (如果需要，可以添加类似重铸弹窗的动画)
            菜单.style.opacity = 0;
            菜单.style.transform = "translate(-50%, -50%) scale(0.9)";
            requestAnimationFrame(() => {
                 菜单.style.transition = 'opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)';
                 菜单.style.opacity = 1;
                 菜单.style.transform = "translate(-50%, -50%) scale(1)";
            });

            关闭设置菜单(); // 打开传送菜单后关闭设置菜单
        }

        /**
         * 关闭传送点菜单
         */
        function 关闭传送菜单() {
            const 遮罩 = document.getElementById("传送点遮罩");
            const 菜单 = document.getElementById("传送点菜单");
            菜单.style.transition = 'opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55)';
            菜单.style.opacity = 0;
            菜单.style.transform = "translate(-50%, -50%) scale(0.9)";
            setTimeout(() => {
                 遮罩.style.display = "none";
            }, 300); // 等待动画完成
        }

        /**
         * 执行传送到指定点
         * @param {string} 目标点标识 - 要传送到的点的唯一ID
         */
        function 执行传送(目标点标识) {
             if (当前天气效果.includes("诡魅")) {
                 显示通知("诡异的气息干扰了空间传送！", "错误");
                 关闭传送菜单();
                 return;
            }

            const 目标点 = 传送点列表.find(点 => 点.id === 目标点标识);
            if (!目标点) {
                显示通知("传送目标点无效！", "错误");
                return;
            }

             // 添加传送冷却或消耗（可选）
             // if (!玩家有足够资源或冷却未到) { 显示通知("无法传送！", "错误"); return; }
             // 消耗资源...

            关闭传送菜单(); // 先关闭菜单

             // 延迟执行传送，给菜单关闭动画时间
             setTimeout(() => {
                 if (目标点.层数 === 当前层数) {
                     // --- 同层传送 ---
                     // 检查目标位置是否可行（只检查背景类型，忽略怪物等临时障碍）
                     const 目标单元格 = 地牢[目标点.y]?.[目标点.x];
                     if (目标单元格 && ![单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.背景类型)) {
                         玩家.x = 目标点.x;
                         玩家.y = 目标点.y;
                         添加日志(`已传送到 ${目标点.名称}`, "信息");
                         更新视口(); // 立即更新相机目标
                         绘制();     // 立即重绘
                         处理怪物回合(); // 传送后触发怪物回合
                         更新物体指示器();
                     } else {
                         显示通知("目标位置无法传送！可能已被阻挡。", "错误");
                     }
                 } else {
                     // --- 跨层传送 ---
                     // 修改切换楼层函数以接受目标坐标
                     切换楼层(目标点.层数, false, { x: 目标点.x, y: 目标点.y });
                     添加日志(`已传送到 ${目标点.名称}`, "信息");
                 }
             }, 350); // 略长于菜单关闭动画的时间

        }

        /**
         * 删除指定的传送点
         * @param {string} 目标点标识 - 要删除的点的唯一ID
         */
        function 删除传送点(目标点标识) {
            const 索引 = 传送点列表.findIndex(点 => 点.id === 目标点标识);
            if (索引 !== -1) {
                const 删除的名称 = 传送点列表[索引].名称;
                传送点列表.splice(索引, 1);
                显示通知(`传送点 "${删除的名称}" 已删除。`, "成功");
                // 重新渲染菜单列表
                打开传送菜单(); // 调用此函数会重新生成列表内容
            }
        }
        function 放置楼梯(房间, 图标, 类型) {
            const 楼梯 = {
                类型: "楼梯",
                图标: 图标,
                显示图标: 图标,
                颜色索引: 颜色表.length,
                使用: () => {
                    const 目标层数 =
                        类型 === 单元格类型.楼梯下楼
                            ? 当前层数 + 1
                            : 当前层数 - 1;
                    切换楼层(目标层数);
                },
                唯一标识: Symbol(`楼梯_${类型}`),
                获取名称: () => (类型 === 单元格类型.楼梯下楼 ? "下楼楼梯" : "上楼楼梯"),
                自定义数据: new Map(),
                品质: 1,
                能否拾起: false,
                是否正常物品: false,
                是否隐藏: false,
                是否为隐藏物品: false,
                效果描述: null,
                已装备: false,
                装备槽位: null,
                堆叠数量: 1,
                最大堆叠数量: 1,
                颜色表: 颜色表,
            };
            放置物品到房间(楼梯, 房间, 类型);
        }

        function 生成金币() {
            const 普通房间生成概率 = 0.3;
            const 上锁房间生成概率 = 0.7;
            const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            可用房间.forEach((房间) => {
                let 生成概率 = 普通房间生成概率;
                let 最大数量 = 9 + 当前层数;

                // 上锁房间生成更多金币
                if (上锁房间列表.some((r) => r.id === 房间.id)) {
                    生成概率 = 上锁房间生成概率;
                    最大数量 = 22 + 当前层数;
                }

                if (Math.random() < 生成概率) {
                    const 数量 = Math.min(Math.floor(Math.random() * 最大数量) + 1, 最大堆叠数);
                    const 金币实例 = new 金币({ 数量 });
                    放置物品到房间(金币实例, 房间);
                }
            });
        }
        function 区域是否空闲(x, y, w, h) {
            for (let i = y; i < y + h; i++) {
                for (let j = x; j < x + w; j++) {
                    if (
                        i >= 地牢大小 ||
                        j >= 地牢大小 ||
                        地牢[i][j].背景类型 !== 单元格类型.墙壁
                    ) {
                        return false;
                    }
                }
            }

            // 计算缓冲区范围
            const 缓冲距离 = 2;
            const xStart = Math.max(0, x - 缓冲距离);
            const xEnd = Math.min(地牢大小 - 1, x + w - 1 + 缓冲距离);
            const yStart = Math.max(0, y - 缓冲距离);
            const yEnd = Math.min(地牢大小 - 1, y + h - 1 + 缓冲距离);

            for (let yi = yStart; yi <= yEnd; yi++) {
                for (let xi = xStart; xi <= xEnd; xi++) {
                    // 计算到房间边缘的最小曼哈顿距离
                    let dx = 0,
                        dy = 0;
                    if (xi < x) dx = x - xi;
                    else if (xi >= x + w) dx = xi - (x + w - 1);

                    if (yi < y) dy = y - yi;
                    else if (yi >= y + h) dy = yi - (y + h - 1);

                    const 总距离 = dx + dy;

                    // 如果曼哈顿距离≤2且单元格非墙壁，则区域被占用
                    if (
                        总距离 <= 缓冲距离 &&
                        地牢[yi][xi].背景类型 !== 单元格类型.墙壁
                    ) {
                        return false;
                    }
                }
            }

            return true;
        }

        function 放置房间(房间) {
            for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                    const 单元格 = 地牢[y][x];
                    单元格.背景类型 = 单元格类型.房间;
                    房间地图[y][x] = 房间.id;
                    单元格.墙壁 = {
                        上: y === 房间.y,
                        下: y === 房间.y + 房间.h - 1,
                        左: x === 房间.x,
                        右: x === 房间.x + 房间.w - 1,
                    };
                }
            }
            房间.已解锁 = false;
            return true;
        }

        function 更新房间墙壁(房间) {
            房间.门.forEach((门) => {
                const { x, y } = 门;
                if (y + 1 < 地牢大小) 地牢[y + 1][x].墙壁.上 = false;
                if (y - 1 >= 0) 地牢[y - 1][x].墙壁.下 = false;
                if (x + 1 < 地牢大小) 地牢[y][x + 1].墙壁.左 = false;
                if (x - 1 >= 0) 地牢[y][x - 1].墙壁.右 = false;
            });
        }

        function 处理上锁的门() {
            // 计算房间 ID 的 50% 分位点
            const 上锁起始索引 = Math.floor(房间列表.length * 0.5);

            const 候选房间 = 房间列表.filter(
                (房间) => 房间.门.length > 1 && 房间.id >= 上锁起始索引
            );

            const 上锁数量 = Math.floor((Math.random() * 候选房间.length));

            for (let i = 0; i < 上锁数量; i++) {
                if (候选房间.length === 0) break;

                const 目标房间 = 候选房间.splice(
                    Math.floor(Math.random() * 候选房间.length),
                    1
                )[0];

                if (目标房间.id !== 0) {
                    const 颜色索引 = i % 颜色表.length;
                    目标房间.门.forEach((门) => {
                        const 单元格 = 地牢[门.y][门.x];
                        门实例列表.get(单元格.标识).类型 = "上锁的门";
                        if (单元格.背景类型 === 单元格类型.门) {
                            单元格.背景类型 = 单元格类型.上锁的门;
                            单元格.钥匙ID = 目标房间.id;
                            单元格.颜色索引 = 颜色索引;
                        }
                    });
                    上锁房间列表.push({ ...目标房间, 颜色索引 });
                }
            }

            上锁房间列表.forEach((房间) => (房间.已解锁 = false));
        }

        function 生成钥匙() {
            // 计算房间 ID 的 50% 分位点
            const 钥匙放置截止索引 = Math.floor(房间列表.length * 0.5);

            上锁房间列表.forEach((上锁房间) => {
                const 新钥匙 = new 钥匙({
                    对应门ID: 上锁房间.id,
                    颜色索引: 上锁房间.颜色索引,
                    地牢层数: 当前层数,
                });

                // 只在房间 ID 小于 80% 分位点的房间中生成钥匙
                const 可用房间 = 房间列表.filter(
                    (r) =>
                        !上锁房间列表.some((锁房) => 锁房.id === r.id) && r.id < 钥匙放置截止索引
                );

                const 目标房间 =
                    可用房间.length > 0
                        ? 可用房间[Math.floor(Math.random() * 可用房间.length)]
                        : null; // 确保有可用房间

                if (目标房间 && 放置物品到房间(新钥匙, 目标房间)) {
                    // 放置成功
                }
            });
        }

        function 寻找房间入口(房间, 避开方向 = {}) {
            const { x, y, w, h } = 房间;
            const 候选入口 = [];

            if (!避开方向.上 && y > 0) {
                for (let i = x + 1; i < x + w - 1; i++) {
                    if (地牢[y - 1][i].类型 === 单元格类型.墙壁) {
                        候选入口.push({ x: i, y: y - 1 });
                    }
                }
            }
            if (!避开方向.下 && y + h < 地牢大小 - 1) {
                for (let i = x + 1; i < x + w - 1; i++) {
                    if (地牢[y + h][i].类型 === 单元格类型.墙壁) {
                        候选入口.push({ x: i, y: y + h });
                    }
                }
            }
            if (!避开方向.左 && x > 0) {
                for (let i = y + 1; i < y + h - 1; i++) {
                    if (地牢[i][x - 1].类型 === 单元格类型.墙壁) {
                        候选入口.push({ x: x - 1, y: i });
                    }
                }
            }
            if (!避开方向.右 && x + w < 地牢大小 - 1) {
                for (let i = y + 1; i < y + h - 1; i++) {
                    if (地牢[i][x + w].类型 === 单元格类型.墙壁) {
                        候选入口.push({ x: x + w, y: i });
                    }
                }
            }
            return 候选入口; // 直接返回数组
        }

        function 连接房间(房间A, 房间B, 尝试 = 0) {
            if (!房间A || !房间B) return;
            if (尝试 >= 6) {
                房间A =
                    房间列表[
                    Math.floor(Math.random() * (房间列表.length - 2))
                    ];
            }
            if (尝试 >= 12) return;
            const 相对位置 = {
                左: 房间A.x < 房间B.x,
                右: 房间A.x > 房间B.x,
                上: 房间A.y < 房间B.y,
                下: 房间A.y > 房间B.y,
            };

            const 避开方向 = {
                起始: {
                    左: 相对位置.左,
                    右: 相对位置.右,
                    上: 相对位置.上,
                    下: 相对位置.下,
                },
                结束: {
                    左: 相对位置.右,
                    右: 相对位置.左,
                    上: 相对位置.下,
                    下: 相对位置.上,
                },
            };

            const 起始候选 = 寻找房间入口(房间A, 避开方向.起始);
            const 结束候选 = 寻找房间入口(房间B, 避开方向.结束);

            if (!起始候选 || !结束候选) return;


            let 起始 = null;
            let 结束 = null;
            let 最小距离 = Infinity;

            for (const 房间起始 of 起始候选) {
                for (const 房间结束 of 结束候选) {
                    const 距离 = Math.abs(房间起始.x - 房间结束.x) + Math.abs(房间起始.y - 房间结束.y);
                    if (距离 < 最小距离) {
                        最小距离 = 距离;
                        起始 = 房间起始;
                        结束 = 房间结束;
                    }
                }
            }

            if (!起始 || !结束) {
                return;
            }

            let 当前 = { x: 起始.x, y: 起始.y };
            let 路径 = [当前];
            let 门 = [];
            let 在房间内 = false;
            let 进入的房间 = null;

            门.push({ x: 起始.x, y: 起始.y, 进入的房间: 房间A });

            const x轴优先 =
                Math.abs(结束.x - 起始.x) > Math.abs(结束.y - 起始.y);

            let 上一个节点 = 当前;
            while (当前.x !== 结束.x || 当前.y !== 结束.y) {
                const dx = 结束.x - 当前.x;
                const dy = 结束.y - 当前.y;

                if (x轴优先 && dx !== 0) {
                    当前.x += dx > 0 ? 1 : -1;
                } else if (dy !== 0) {
                    当前.y += dy > 0 ? 1 : -1;
                } else if (!x轴优先 && dx !== 0) {
                    当前.x += dx > 0 ? 1 : -1;
                }

                let 附近的门数量 = [
                    { x: 当前.x, y: 当前.y - 1 },
                    { x: 当前.x, y: 当前.y + 1 },
                    { x: 当前.x - 1, y: 当前.y },
                    { x: 当前.x + 1, y: 当前.y },
                ].reduce((数量, pos) => {
                    if (
                        pos.x >= 0 &&
                        pos.x < 地牢大小 &&
                        pos.y >= 0 &&
                        pos.y < 地牢大小
                    ) {
                        return (
                            数量 +
                            (地牢[pos.y][pos.x].背景类型 === 单元格类型.门)
                        );
                    }
                    return 数量;
                }, 0);

                const 碰撞房间 = 房间列表.find(
                    (房间) =>
                        当前.x >= 房间.x &&
                        当前.x <= 房间.x + 房间.w - 1 &&
                        当前.y >= 房间.y &&
                        当前.y <= 房间.y + 房间.h - 1 &&
                        房间 !== 房间A
                );
                if (碰撞房间 && !在房间内) {
                    在房间内 = true;
                    进入的房间 = 碰撞房间;
                    门.push({ x: 上一个节点.x, y: 上一个节点.y, 进入的房间: 进入的房间, });
                    附近的门数量 -= 1;
                } else if (!碰撞房间 && 在房间内) {
                    if (当前.x !== 结束.x && 当前.y !== 结束.y) {
                        门.push({
                            x: 当前.x,
                            y: 当前.y,
                            进入的房间: 进入的房间,
                        });
                        路径.push({ x: 当前.x, y: 当前.y });
                        在房间内 = false;
                    }
                    附近的门数量 -= 1;
                }
                if (
                    地牢[当前.y][当前.x].背景类型 === 单元格类型.门 ||
                    附近的门数量 > 1
                ) {
                    let 路径 = [];
                    let 门 = [];
                    return 连接房间(房间A, 房间B, 尝试 + 1);
                }
                if (
                    路径.length === 0 &&
                    地牢[当前.y][当前.x].类型 === 单元格类型.走廊
                ) {
                    let 路径 = [];
                    let 门 = [];
                    return 连接房间(房间A, 房间B, 尝试 + 1);
                }
                if (!在房间内) {
                    路径.push({ x: 当前.x, y: 当前.y });
                }
                上一个节点 = { x: 当前.x, y: 当前.y };
            }

            if (!在房间内) {
                门.push({ x: 结束.x, y: 结束.y, 进入的房间: 房间B });
                路径.push(结束);
            }
            门.forEach((door) => {
                放置门(door.x, door.y, door.进入的房间);
            });
            return 路径;
        }

        function 生成走廊(路径) {
            for (let i = 0; i < 路径.length; i++) {
                const { x, y } = 路径[i];
                if (是否在任意房间内(x, y)) continue;

                if (
                    x < 地牢大小 &&
                    y < 地牢大小 &&
                    地牢[y][x].背景类型 !== 单元格类型.门
                ) {
                    地牢[y][x].背景类型 = 单元格类型.走廊;
                    地牢[y][x].墙壁 = {
                        上: false,
                        右: false,
                        下: false,
                        左: false,
                    };
                }
            }
        }

        function 是否在任意房间内(x, y) {
            return 房间列表.some(
                (房间) =>
                    x >= 房间.x &&
                    x < 房间.x + 房间.w &&
                    y >= 房间.y &&
                    y < 房间.h
            );//可改为直接判断单元格类型
        }

        function 放置门(x, y, 目标房间) {
            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return;
            const 新门 = new 门({
                关联房间ID: 目标房间.id,
                位置: { x, y },
            });
            地牢[y][x].标识 = 新门.唯一标识; // 绑定门标识
            地牢[y][x].关联物品 = null;
            地牢[y][x].背景类型 = 单元格类型.门;
            地牢[y][x].墙壁 = {
                上: false,
                右: false,
                下: false,
                左: false,
            };

            const 方向 = [
                { dx: 0, dy: -1, 墙: "下" },
                { dx: 0, dy: 1, 墙: "上" },
                { dx: -1, dy: 0, 墙: "右" },
                { dx: 1, dy: 0, 墙: "左" },
            ];

            方向.forEach((dir) => {
                const adjX = x + dir.dx;
                const adjY = y + dir.dy;
                if (
                    adjX >= 0 &&
                    adjX < 地牢大小 &&
                    adjY >= 0 &&
                    adjY < 地牢大小
                ) {
                    地牢[adjY][adjX].墙壁[dir.墙] = false;
                }
            });

            if (目标房间) {
                目标房间.门.push({ x, y });
            }
        }

        function 放置物品到房间(
            物品实例,
            目标房间,
            放置物体 = 单元格类型.物品,
            禁用光晕 = false,
            特效 = false,
        ) {
            // 寻找有效放置位置
            let 放置成功 = false;
            for (let 尝试次数 = 0; 尝试次数 < 20; 尝试次数++) {
                // 计算房间有效区域
                const 最小x = 目标房间.x;
                const 最大x = 目标房间.x + 目标房间.w - 1;
                const 最小y = 目标房间.y;
                const 最大y = 目标房间.y + 目标房间.h - 1;

                // 生成随机坐标
                const x =
                    最小x + Math.floor(Math.random() * (最大x - 最小x + 1));
                const y =
                    最小y + Math.floor(Math.random() * (最大y - 最小y + 1));

                // 验证位置有效性
                if (位置是否可用(x, y)) {
                    地牢[y][x].类型 = 放置物体;
                    地牢[y][x].关联物品 = 物品实例;
                    if (物品实例.颜色索引 === null || 禁用光晕) {
                        物品实例.颜色索引 = 物品实例.颜色表.length;
                    }
                    物品实例.x = x;
                    物品实例.y = y;
                    地牢[y][x].颜色索引 = 物品实例.颜色索引;
                    放置成功 = true;
                    if (特效) 计划显示格子特效([{ x: x, y: y }], 物品实例.颜色表[物品实例.颜色索引].slice(1));
                    break;
                }
            }
            return 放置成功;
        }
        function 放置物品到单元格(
            物品实例,
            x,
            y,
            放置物体 = 单元格类型.物品,
            禁用光晕 = false
        ) {
            // 验证位置有效性
            if (位置是否可用(x, y, false)) {
                地牢[y][x].类型 = 放置物体;
                地牢[y][x].关联物品 = 物品实例;
                if (物品实例.颜色索引 === null || 禁用光晕) {
                    物品实例.颜色索引 = 物品实例.颜色表.length;
                }
                物品实例.x = x;
                物品实例.y = y;
                地牢[y][x].颜色索引 = 物品实例.颜色索引;
                绘制();
                return true;
            }
            return false;
        }

        function 位置是否可用(x, y, 考虑玩家 = true) {
            // 边界检查
            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
                return false;
            if (考虑玩家 && 玩家.x === x && 玩家.y === y) return false;
            const 单元格 = 地牢[y][x];

            // 必须是房间地板且没有其他物品
            return (
                [单元格类型.房间, 单元格类型.走廊, 单元格类型.门].includes(单元格.背景类型) &&
                !单元格.关联物品 &&
                !单元格.关联怪物
            );
        }


        //修改时记得同步修改使用背包物品
        function 尝试互动() {
            let 互动 = false;
            if (互动冷却) return;
            互动冷却 = true;
            setTimeout(() => (互动冷却 = false), 500);

            // 优先处理玩家所在格子的互动
            const 玩家所在单元格 = 地牢[玩家.y][玩家.x];
            //注意修改时要同时修改两个地方
            if (玩家所在单元格.类型 === 单元格类型.物品) {
                if (玩家所在单元格.关联物品?.类型 === "棋子") { //这里的奇怪逻辑是历史问题...
                    玩家所在单元格.关联物品.能否拾起 = true;
                    if (尝试收集物品(玩家所在单元格.关联物品)) {
                        玩家所在单元格.类型 = null;
                        玩家所在单元格.关联物品 = null;
                        绘制();
                        互动 = true;
                    }
                } else if (尝试收集物品(玩家所在单元格.关联物品)) {
                    玩家所在单元格.类型 = null;
                    玩家所在单元格.关联物品 = null;
                    绘制();
                    互动 = true;
                } else if (玩家所在单元格.关联物品?.类型 === "NPC" && !NPC互动中) {
                    玩家所在单元格.关联物品.使用();
                    NPC互动中 = true;
                    互动 = true;
                } else if (玩家所在单元格.关联物品?.类型 === "祭坛") {
                    if (confirm("是否献祭 75 血量给祭坛？")) 互动 = 玩家所在单元格.关联物品.尝试互动();
                }
            }
            if (互动) return;

            const 方向 = [
                { dx: 0, dy: -1 }, // 上
                { dx: 1, dy: 0 }, // 右
                { dx: 0, dy: 1 }, // 下
                { dx: -1, dy: 0 }, // 左
            ];

            for (const { dx, dy } of 方向) {
                const 目标X = 玩家.x + dx;
                const 目标Y = 玩家.y + dy;

                if (目标X < 0 || 目标X >= 地牢大小 || 目标Y < 0 || 目标Y >= 地牢大小) continue;

                const 单元格 = 地牢[目标Y][目标X];

                // 处理上锁的门
                if (单元格.背景类型 === 单元格类型.上锁的门) {
                    const 对应门 = 门实例列表.get(单元格.标识);
                    const 对应钥匙 = [...玩家背包.values()].find((item) => item.可交互目标(对应门));
                    if (对应钥匙) {
                        房间列表.find((房间) => 房间.id === 对应门.房间ID)?.门?.forEach((item) => {
                            房间门 = 门实例列表.get(地牢[item.y][item.x].标识);
                            互动 = 房间门.尝试解锁(玩家背包);
                            if (互动) 地牢[房间门.所在位置.y][房间门.所在位置.x].背景类型 = 单元格类型.门;
                        });
                        绘制();
                    }
                    if (互动) {
                        处理销毁物品(对应钥匙.唯一标识, true);
                        显示通知("解锁成功！", "成功");
                        break; // 互动成功，跳出循环
                    }
                } else if (快速直线检查(玩家.x, 玩家.y, 目标X, 目标Y, 1)) { //注意，此处未与本格互动成功才检测周围
                    if (单元格.类型 === 单元格类型.物品) {
                        if (单元格.关联物品?.类型 === "棋子") {
                            单元格.关联物品.能否拾起 = true;
                            单元格.关联物品.isActive = false;
                            if (尝试收集物品(单元格.关联物品)) {
                                单元格.类型 = null;
                                单元格.关联物品 = null;
                                绘制();
                                互动 = true;
                            }
                        } else if (尝试收集物品(单元格.关联物品)) {
                            单元格.类型 = null;
                            单元格.关联物品 = null;
                            绘制();
                            互动 = true;
                        } else if (单元格.关联物品?.类型 === "NPC" && !NPC互动中) {
                            单元格.关联物品.使用();
                            NPC互动中 = true;
                            互动 = true;
                            break;
                        } else if (单元格.关联物品?.类型 === "祭坛") {
                            if (confirm("是否献祭 75 血量给祭坛？")) {
                                互动 = 单元格.关联物品.尝试互动();
                                if (互动) break;
                            }
                        }
                    }
                }
            }
            if (互动) return;
            const 武器 = [...玩家装备.values()].filter(
                (i) =>
                    i.类型 === "武器" &&
                    i.堆叠数量 > 0 &&
                    i.自定义数据.get("冷却剩余") == 0
            );
            if (武器) {
                let maxCount = 0;
                let maxRange = 0;
                let 目标怪物, 目标路径 = [];
                武器.forEach((可用武器) => {
                    maxCount = Math.max(maxCount, 可用武器.自定义数据.get("攻击目标数"));
                    if (!(可用武器 instanceof 金币手枪)) maxRange = Math.max(maxRange, 可用武器.自定义数据.get("攻击范围"));
                })
                let { 怪物, 路径 } = 获取周围怪物(
                    maxCount,
                    maxRange
                );
                if (怪物 && 路径) {
                    武器.forEach((可用武器) => {
                        路径 = 路径.filter((item, index) => 怪物[index].当前生命值 > 0);
                        怪物 = 怪物.filter((item) => item.当前生命值 > 0);
                        目标路径 = [];
                        目标怪物 = [];
                        路径.forEach((item) => {
                            if (item.length <= 可用武器.自定义数据.get("攻击范围") + 1) {
                                目标路径.push(item)
                            }
                        });
                        目标怪物 = 怪物.slice(0, Math.min(目标路径.length, 可用武器.自定义数据.get("攻击目标数"))); //左闭右开
                        目标路径 = 路径.slice(0, Math.min(目标路径.length, 可用武器.自定义数据.get("攻击目标数")));
                        if (目标怪物 !== null) {
                            if (可用武器.使用(目标怪物, 目标路径)) {

                                [...玩家装备.values()].forEach(装备 => {
                                    if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                                        装备.当玩家攻击(目标怪物);
                                    }
                                });
                                更新装备显示();
                                绘制();
                                互动 = true;
                            }
                        }
                    });
                }
            }

            if (!互动) 显示通知("周围没有可互动物体了...", "信息");
            return;
        }
        function 克隆物品(原始物品) {
            if (!原始物品 || typeof 原始物品 !== 'object') {
                return 原始物品;
            }

            const 克隆实例 = Object.create(Object.getPrototypeOf(原始物品));

            for (const 键 in 原始物品) {
                if (Object.hasOwnProperty.call(原始物品, 键)) {
                    if (键 === '自定义数据' && 原始物品.自定义数据 instanceof Map) {
                        克隆实例.自定义数据 = new Map(原始物品.自定义数据);
                    } else {
                        克隆实例[键] = 原始物品[键];
                    }
                }
            }

            克隆实例.isActive = false;
            克隆实例.显示元素 = null;
            克隆实例.已装备 = false;
            克隆实例.装备槽位 = null;
            克隆实例.唯一标识 = Symbol(Date.now().toString() + Math.random().toString());
            return 克隆实例;
        }
        function 获取周围怪物(数量 = 1, 范围 = null) {
            if (当前天气效果.includes("诡魅") && 范围 > 2) { // 假设范围>1表示远程
                范围 = 2;

            }
            let 攻击范围 = 0;
            if (范围 === null) {
                const 当前武器 = [...玩家装备.values()].find(
                    (i) =>
                        i.类型 === "武器" &&
                        i.堆叠数量 > 0 &&
                        i.自定义数据.get("冷却剩余") === 0
                );
                if (!当前武器) return { 路径: null, 怪物: null };
                攻击范围 = 当前武器.自定义数据.get("攻击范围");
            } else {
                攻击范围 = 范围;
            }
            const 候选怪物 = [];
            for (let dx = -攻击范围; dx <= 攻击范围; dx++) {
                for (let dy = -攻击范围; dy <= 攻击范围; dy++) {
                    const x = 玩家.x + dx;
                    const y = 玩家.y + dy;
                    if (
                        x >= 0 &&
                        x < 地牢大小 &&
                        y >= 0 &&
                        y < 地牢大小 &&
                        地牢[y][x].关联怪物?.状态 === 怪物状态.活跃 &&
                        怪物状态表.get(地牢[y][x].关联怪物)?.类型 !== "魅惑"
                    ) {
                        const 怪物实例 = 地牢[y][x].关联怪物;
                        if (检查视线(玩家.x, 玩家.y, x, y, 攻击范围)) {
                            候选怪物.push({
                                怪物: 怪物实例,
                                距离: Math.abs(dx) + Math.abs(dy),
                                x: x,
                                y: y,
                            });
                        }
                    }
                }
            }
            const 排序后 = 候选怪物.sort((a, b) => a.距离 - b.距离);
            const 结果 = 排序后.slice(0, 数量);
            const 路径数组 = [];
            const 怪物数组 = [];
            for (const item of 结果) {
                let 路径 = [];
                if (快速直线检查(玩家.x, 玩家.y, item.x, item.y, 攻击范围)) {
                    路径 = 获取直线路径(玩家.x, 玩家.y, item.x, item.y);
                } else {
                    路径 = 广度优先搜索路径(
                        玩家.x,
                        玩家.y,
                        item.x,
                        item.y,
                        攻击范围,
                        true
                    );
                }
                if (路径) {
                    路径.shift();
                    路径数组.push(路径);
                    怪物数组.push(item.怪物);
                }
            }
            return 路径数组.length > 0 ? { 路径: 路径数组, 怪物: 怪物数组 } : { 路径: null, 怪物: null };
        }
        function 获取直线路径(startX, startY, endX, endY) {
            const path = [];
            let currentX = startX;
            let currentY = startY;
            const dx = endX - startX;
            const dy = endY - startY;
            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            const xInc = dx / steps;
            const yInc = dy / steps;
            for (let i = 0; i <= steps; i++) {
                const x = Math.round(currentX);
                const y = Math.round(currentY);
                path.push({ x: x, y: y });
                currentX += xInc;
                currentY += yInc;
            }
            return path;
        }
        // BFS U ARE MY GOD
        function 广度优先搜索路径(
            startX,
            startY,
            endX,
            endY,
            maxSteps,
            返回路径 = false
        ) {
            const 最小步数记录 = new Array(地牢大小)
                .fill()
                .map(() => new Array(地牢大小).fill(Infinity));
            const 前驱节点 = new Array(地牢大小)
                .fill(null)
                .map(() => new Array(地牢大小).fill(null));
            const 队列 = [[startX, startY, 0]];
            最小步数记录[startY][startX] = 0;
            const 方向 = [
                { dx: 0, dy: -1, 当前墙: "上", 反方向墙: "下" },
                { dx: 0, dy: 1, 当前墙: "下", 反方向墙: "上" },
                { dx: -1, dy: 0, 当前墙: "左", 反方向墙: "右" },
                { dx: 1, dy: 0, 当前墙: "右", 反方向墙: "左" },
            ];
            while (队列.length > 0) {
                const [x, y, step] = 队列.shift();
                if (x === endX && y === endY) {
                    if (返回路径) {
                        return 从终点回溯路径(前驱节点, endX, endY);
                    }
                    return true;
                }
                if (step >= maxSteps) continue;
                for (const dir of 方向) {
                    const 新X = x + dir.dx;
                    const 新Y = y + dir.dy;
                    const 新步数 = step + 1;
                    if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小)
                        continue;
                    if (新步数 >= 最小步数记录[新Y][新X]) continue;
                    const 当前单元格 = 地牢[y][x];
                    const 下一单元格 = 地牢[新Y][新X];
                    if (当前单元格.墙壁[dir.当前墙] || 下一单元格.墙壁[dir.反方向墙])
                        continue;

                    if (
                        [单元格类型.墙壁, 单元格类型.上锁的门].includes(下一单元格.背景类型)
                    )
                        continue;
                    最小步数记录[新Y][新X] = 新步数;
                    前驱节点[新Y][新X] = { x: x, y: y };
                    队列.push([新X, 新Y, 新步数]);
                }
            }
            return 返回路径 ? [] : false;
        }
        function 从终点回溯路径(前驱节点, endX, endY) {
            const 路径 = [];
            let currentX = endX;
            let currentY = endY;
            while (前驱节点[currentY][currentX] !== null) {
                路径.push({ x: currentX, y: currentY });
                const tempX = 前驱节点[currentY][currentX].x;
                const tempY = 前驱节点[currentY][currentX].y;
                currentX = tempX;
                currentY = tempY;
            }
            路径.push({ x: currentX, y: currentY });
            return 路径.reverse();
        }
        function 检查视线(startX, startY, endX, endY, maxSteps = Infinity) {
            const 曼哈顿距离 = Math.abs(endX - startX) + Math.abs(endY - startY);
            if (曼哈顿距离 > maxSteps) return false;
            if (startX === endX && startY === endY) return true;
            if (快速直线检查(startX, startY, endX, endY, maxSteps)) {
                return true;
            }
            return 广度优先搜索路径(startX, startY, endX, endY, maxSteps);
        }
        function 快速直线检查(startX, startY, endX, endY, maxSteps) {
            let currentX = startX;
            let currentY = startY;
            const dx = endX - startX;
            const dy = endY - startY;
            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            if (steps > maxSteps) return false;
            const xInc = dx / steps;
            const yInc = dy / steps;
            for (let i = 0; i <= steps; i++) {
                const x = Math.round(currentX);
                const y = Math.round(currentY);
                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return false;
                if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(地牢[y][x].背景类型))
                    return false;
                if (i > 0) {
                    const prevX = Math.round(currentX - xInc);
                    const prevY = Math.round(currentY - yInc);
                    const dirs = [];
                    if (x > prevX) dirs.push("右");
                    if (x < prevX) dirs.push("左");
                    if (y > prevY) dirs.push("下");
                    if (y < prevY) dirs.push("上");
                    for (const dir of dirs) {
                        const mapping = {
                            右: { 当前墙: "左", 反方向墙: "右" },
                            左: { 当前墙: "右", 反方向墙: "左" },
                            下: { 当前墙: "上", 反方向墙: "下" },
                            上: { 当前墙: "下", 反方向墙: "上" },
                        }[dir];
                        if (
                            地牢[y][x].墙壁[mapping.当前墙] ||
                            地牢[prevY][prevX].墙壁[mapping.反方向墙]
                        ) {
                            return false;
                        }
                    }
                }
                currentX += xInc;
                currentY += yInc;
            }
            return true;
        }
        function 获取移动方向(fromX, fromY, toX, toY) {
            const dx = toX - fromX;
            const dy = toY - fromY;
            const 主要方向 =
                Math.abs(dx) > Math.abs(dy)
                    ? dx > 0
                        ? "右"
                        : "左"
                    : dy > 0
                        ? "下"
                        : "上";
            return {
                右: { 当前墙: "右", 反方向墙: "左" },
                左: { 当前墙: "左", 反方向墙: "右" },
                下: { 当前墙: "下", 反方向墙: "上" },
                上: { 当前墙: "上", 反方向墙: "下" },
            }[主要方向];
        }

        function 计划显示格子特效(路径数组, 颜色 = 'FF0000', 间隔 = 100) { // 增加颜色参数，默认为红色
            if (长按移动) {
                return;
            }
            const 可见路径 = 路径数组.filter((节点) => {
                return 节点.x >= 视口偏移X &&
                    节点.x < 视口偏移X + 相机显示边长 &&
                    节点.y >= 视口偏移Y &&
                    节点.y < 视口偏移Y + 相机显示边长
            });
            if (可见路径.length > 0) {
                玩家属性.允许移动 = false;
                相机锁定 = true;
                if (moveQueue.length > 0) {
                    moveQueue = [];
                    isAutoMoving = false;
                }
                待显示格子特效队列.push({
                    路径: 可见路径,
                    颜色: 颜色,
                    间隔: 间隔
                });
            }
        }
        function 显示格子特效(路径, 颜色 = 'FF0000', 间隔 = 100) {

            const 画布Rect = canvas.getBoundingClientRect();
            路径.forEach((节点, index) => {
                const 屏幕X = (节点.x - 相机目标X) * 单元格大小;
                const 屏幕Y = (节点.y - 相机目标Y) * 单元格大小;

                const 特效 = document.createElement("div");
                特效.className = "攻击路径特效";
                特效.style.cssText = `
    position: absolute;
    left: ${屏幕X + 画布Rect.left}px;
    top: ${屏幕Y + 画布Rect.top}px;
    width: ${单元格大小}px;
    height: ${单元格大小}px;
    background: radial-gradient(circle, 
        ${hexToRgba(颜色, 0)} 0%,
        ${hexToRgba(颜色, 0.3)} 70%,
        transparent 100%
    );
    opacity: 0.7;
    pointer-events: none;
    z-index: 998;
`;

                setTimeout(function () {
                    document.body.appendChild(特效);
                }, index * 间隔);
                setTimeout(function () {
                    特效.remove();

                }, 200 + index * 间隔);
            });

        }
        function 尝试进入特殊房间(x, y) {
            const 房间ID = 房间地图[y][x];
            if (房间ID === -1) return;
            const 房间 = 房间列表[房间ID];
            if (房间 && !房间.已连接 && (房间.类型 === "解谜棋盘" || 房间.类型 === "boss房间")) {
                连接特殊房间(房间);
                生成墙壁();
                const 待销毁戒指 = [];
                玩家背包.forEach(item => {
                    if (item instanceof 寻宝戒指 && item.自定义数据.get("生效层数") === 当前层数) {
                        待销毁戒指.push(item.唯一标识);
                    }
                })
                待销毁戒指.forEach(id => {
                    处理销毁物品(id, true);
                })
                移动玩家(0, 0);
                绘制();
            }
        }
        function 尝试执行吹动(实例, 移动计划, 已执行, 风向DX, 风向DY) {
            // 基本情况：已处理过 或 无需移动
            if (已执行.has(实例)) return true; // 已经移动过了
            if (!移动计划.has(实例)) return true; // 本来就没计划移动

            const { 新X, 新Y, 旧X, 旧Y, 类型 } = 移动计划.get(实例);

            // 1. 检查目标格子基本有效性（边界、墙壁）
            if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小 ||
                !检查直线移动可行性(旧X, 旧Y, 新X, 新Y, true) || // 检查直线路径
                [单元格类型.墙壁, 单元格类型.上锁的门].includes(地牢[新Y][新X]?.背景类型)) {
                // 标记为执行过（虽然失败了），防止无限递归
                已执行.add(实例);
                return false; // 目标无效，移动失败
            }

            // 2. 检查目标格子占用情况
            const 占用单元格 = 地牢[新Y]?.[新X];
            const 占用者 = 占用单元格?.关联物品 || 占用单元格?.关联怪物;

            if (占用者) {
                // 检查占用者是否是不可移动类型
                const 不可移动类型列表 = ['楼梯', '地形', '祭坛', '折跃门']; // '工具' 通常指重铸台等
                const 物品是否不可移动 = 占用者 instanceof 物品 && (不可移动类型列表.includes(占用者.类型));

                if (物品是否不可移动) {
                    已执行.add(实例);
                    if (占用者 instanceof 火焰物品) {
                        if (地牢[旧Y]?.[旧X]?.关联物品 === 实例) {
                            地牢[旧Y][旧X].关联物品 = null;
                            if (地牢[旧Y]?.[旧X]?.类型 === 单元格类型.物品) 地牢[旧Y][旧X].类型 = null;
                            地牢[旧Y][旧X].颜色索引 = 颜色表.length;
                        }
                        添加日志(`${实例.名称} 被吹向火焰，烧毁了！`, "信息");
                        return true;
                    }
                    return false;
                }


                // 检查占用者是否也在移动计划中
                if (移动计划.has(占用者)) {
                    // 递归尝试移动占用者
                    const 占用者移动成功 = 尝试执行吹动(占用者, 移动计划, 已执行, 风向DX, 风向DY);
                    if (!占用者移动成功) {
                        已执行.add(实例); // 占用者移动失败，当前实例也失败
                        return false;
                    }
                    // 占用者成功移开后，目标格子现在应该是空的了
                } else {
                    // 目标格子被一个不在移动计划中的东西占用了（可能是后来生成的或其他情况）
                    已执行.add(实例); // 标记为执行过（失败）
                    return false; // 移动失败
                }
            }
            // 4. 执行移动
            try {
                if (类型 === '物品') {
                    // 清理旧格子
                    if (地牢[旧Y]?.[旧X]?.关联物品 === 实例) {
                        地牢[旧Y][旧X].关联物品 = null;
                        if (地牢[旧Y]?.[旧X]?.类型 === 单元格类型.物品) 地牢[旧Y][旧X].类型 = null;
                        地牢[旧Y][旧X].颜色索引 = 颜色表.length;
                    }
                    // 更新物品实例坐标
                    实例.x = 新X;
                    实例.y = 新Y;
                    // 更新新格子
                    地牢[新Y][新X].类型 = 单元格类型.物品;
                    地牢[新Y][新X].关联物品 = 实例;
                    地牢[新Y][新X].颜色索引 = 实例.颜色索引;

                    添加日志(`${实例.名称} 被大风吹到了 (${新X},${新Y})！`, "信息");
                } else if (类型 === '怪物') {
                    实例.恢复背景类型(); // 清理旧格子
                    实例.x = 新X;
                    实例.y = 新Y;
                    实例.保存新位置类型(新X, 新Y); // 保存新格子背景
                    地牢[新Y][新X].类型 = 单元格类型.怪物; // 标记新格子
                    地牢[新Y][新X].关联怪物 = 实例;
                    添加日志(`${实例.类型} 被大风吹到了 (${新X},${新Y})！`, "信息");
                    实例.处理地形效果(); // 处理新位置地形效果
                }
                已执行.add(实例); // 标记为成功执行
                return true;
            } catch (错误) {
                console.error(`执行移动实例 ${实例?.名称 || '未知'} 到 (${新X}, ${新Y}) 时出错: `, 错误);
                已执行.add(实例); // 出错也标记为已处理
                return false;
            }
        }

        function 处理大风效果() {
            // 1. 确定本回合风向
            const 方向列表 = [{ dx: 0, dy: -1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }];
            const { dx: 风向DX, dy: 风向DY } = 方向列表[Math.floor(Math.random() * 4)];
            添加日志(`狂风向 ${获取方向中文(风向DX, 风向DY)} 吹拂！`, "信息");

            // 2. 获取视口范围 (同前)
            const 画布 = document.getElementById("dungeonCanvas");
            const 画布Rect = 画布.getBoundingClientRect();
            const 视口起始X = Math.floor(当前相机X);
            const 视口起始Y = Math.floor(当前相机Y);
            const 视口宽度格 = Math.ceil(画布Rect.width / 单元格大小);
            const 视口高度格 = Math.ceil(画布Rect.height / 单元格大小);
            const 视口结束X = Math.min(地牢大小 - 1, 视口起始X + 视口宽度格);
            const 视口结束Y = Math.min(地牢大小 - 1, 视口起始Y + 视口高度格);

            // 3. 规划阶段：确定哪些实体 *可能* 被吹动
            const 移动计划 = new Map(); // 存储 { 实例: { 新X, 新Y, 旧X, 旧Y, 类型 } }
            const 不可移动类型列表 = ['楼梯', '地形', '祭坛', '折跃门'];

            // 3.1 规划物品移动
            for (let y = 视口起始Y; y <= 视口结束Y; y++) {
                for (let x = 视口起始X; x <= 视口结束X; x++) {
                    const 物品 = 地牢[y]?.[x]?.关联物品;
                    if (物品 && !(不可移动类型列表.includes(物品.类型)) && (已访问房间.has(房间地图[y][x]) || 房间地图[y][x] === -1)) {
                        if (Math.random() < 大风吹动概率) {
                            const 新X = x + 风向DX;
                            const 新Y = y + 风向DY;
                            // 基础检查：界内 & 非阻挡背景 & 直线路径
                            if (新X >= 0 && 新X < 地牢大小 && 新Y >= 0 && 新Y < 地牢大小 &&
                                !([单元格类型.墙壁, 单元格类型.上锁的门].includes(地牢[新Y][新X]?.背景类型)) &&
                                检查直线移动可行性(x, y, 新X, 新Y, true) && (已访问房间.has(房间地图[y][x]) || 房间地图[y][x] === -1)) {
                                移动计划.set(物品, { 新X, 新Y, 旧X: x, 旧Y: y, 类型: '物品' });
                            }
                        }
                    }
                }
            }

            // 3.2 规划怪物移动
            所有怪物.forEach(怪物 => {
                const { x, y } = 怪物;
                if (怪物.状态 === 怪物状态.活跃 &&
                    x >= 视口起始X && x <= 视口结束X &&
                    y >= 视口起始Y && y <= 视口结束Y) {
                    if (Math.random() < 大风吹动概率) {
                        const 新X = x + 风向DX;
                        const 新Y = y + 风向DY;
                        // 基础检查：界内 & 非阻挡背景 & 直线路径
                        if (新X >= 0 && 新X < 地牢大小 && 新Y >= 0 && 新Y < 地牢大小 &&
                            !([单元格类型.墙壁, 单元格类型.上锁的门].includes(地牢[新Y][新X]?.背景类型)) &&
                            检查直线移动可行性(x, y, 新X, 新Y, true)) {
                            移动计划.set(怪物, { 新X, 新Y, 旧X: x, 旧Y: y, 类型: '怪物' });
                        }
                    }
                }
            });

            // 3.3 规划玩家移动
            if (玩家.x >= 视口起始X && 玩家.x <= 视口结束X &&
                玩家.y >= 视口起始Y && 玩家.y <= 视口结束Y) {
                if (Math.random() < 大风吹动概率) {
                    const 新X = 玩家.x + 风向DX;
                    const 新Y = 玩家.y + 风向DY;
                    // 基础检查：界内 & 非阻挡背景 & 直线路径
                    if (新X >= 0 && 新X < 地牢大小 && 新Y >= 0 && 新Y < 地牢大小 &&
                        !([单元格类型.墙壁, 单元格类型.上锁的门].includes(地牢[新Y][新X]?.背景类型)) &&
                        检查直线移动可行性(玩家.x, 玩家.y, 新X, 新Y, true)) {
                        移动计划.set(玩家, { 新X, 新Y, 旧X: 玩家.x, 旧Y: 玩家.y, 类型: '玩家' });
                    }
                }
            }


            // --- 4. 执行阶段：使用递归函数处理移动和碰撞 ---
            const 已执行 = new Set();
            const 待处理实例列表 = Array.from(移动计划.keys()); // 获取所有计划移动的实例

            // 先处理物品，再处理怪物，减少物品被怪物意外覆盖的可能
            待处理实例列表.filter(实例 => 实例 instanceof 物品).forEach(物品实例 => {
                尝试执行吹动(物品实例, 移动计划, 已执行, 风向DX, 风向DY);
            });

            待处理实例列表.filter(实例 => 实例 instanceof 怪物).forEach(怪物实例 => {
                尝试执行吹动(怪物实例, 移动计划, 已执行, 风向DX, 风向DY);
            });


            // --- 5. 单独处理玩家移动（最后执行，覆盖一切） ---
            let 玩家被吹动 = false;
            let 玩家目标X = 玩家.x;
            let 玩家目标Y = 玩家.y;

            if (移动计划.has(玩家) && !已执行.has(玩家)) { // 检查玩家是否计划移动且未被其他逻辑阻止
                const { 新X, 新Y } = 移动计划.get(玩家);

                // 最终检查玩家目标格子是否有效（可能被不可移动物品阻挡）
                const 最终目标单元格 = 地牢[新Y]?.[新X];
                const 最终占用者 = 最终目标单元格?.关联物品;
                const 最终占用者不可移动 = 最终占用者 && (不可移动类型列表.includes(最终占用者.类型) || 最终占用者.能否拾起 === false);

                if (!最终占用者不可移动) {
                    玩家.x = 新X;
                    玩家.y = 新Y;
                    玩家被吹动 = true;
                    玩家目标X = 新X;
                    玩家目标Y = 新Y;
                    添加日志("你被大风吹动了！", "警告");
                    已执行.add(玩家); // 标记玩家已处理
                } else {
                    添加日志("你试图被风吹动，但撞到了障碍物！", "信息");
                }
            }


            // --- 6. 玩家移动后的交互处理 (同前) ---
            if (玩家被吹动) {
                const 目标单元格 = 地牢[玩家目标Y]?.[玩家目标X];
                if (目标单元格) {
                    // 拾取物品
                    if (目标单元格.关联物品 && 目标单元格.类型 === 单元格类型.物品 && 目标单元格.关联物品.能否拾起 !== false) {
                        if (尝试收集物品(目标单元格.关联物品)) {
                            目标单元格.类型 = null;
                            目标单元格.关联物品 = null;
                        }
                    }
                    // 使用楼梯
                    else if ([单元格类型.楼梯下楼, 单元格类型.楼梯上楼].includes(目标单元格.类型)) {
                        if (目标单元格.关联物品?.使用) {
                            目标单元格.关联物品.使用();
                            return; // 切换楼层会中断后续逻辑
                        }
                    }
                    // 使用折跃门
                    else if (目标单元格.关联物品 instanceof 折跃门) {
                        目标单元格.关联物品.使用();
                        return; // 传送可能中断后续逻辑
                    }
                    // 进入新房间
                    const 目标房间ID = 房间地图[玩家目标Y][玩家目标X];
                    if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
                        moveQueue = [];
                        已访问房间.add(目标房间ID);
                    }
                }
            }

            // --- 7. 更新UI ---
            更新物体指示器();
            所有怪物.forEach(m => m.绘制血条()); // 确保所有怪物血条位置更新
        }

        function 获取方向中文(dx, dy) {
            if (dx === 1) return "东";
            if (dx === -1) return "西";
            if (dy === 1) return "南";
            if (dy === -1) return "北";
            return "原地";
        }
        async function 移动玩家(dx, dy, 冷却 = true) {
            if (!玩家属性.允许移动 || 死亡界面已显示) return false;
            if (冷却) {
                const now = Date.now();
                if (now - 上次移动 < 50) return; // 强制50ms移动间隔 just appreciate more , fidget less
                上次移动 = now;
            }
            const 能量条 = document.querySelector(".power-bar");
            const 当前能量 = parseFloat(能量条.style.width) || 100;
            const 眩晕状态 = 玩家状态.some(s => s.类型 === "眩晕"); // 检查眩晕状态
            const 冻结状态 = 玩家状态.some(s => s.类型 === "冻结");
            const 缓慢状态 = 玩家状态.some(s => s.类型 === "缓慢");

            let 移动方向X = dx;
            let 移动方向Y = dy;

            // 如果眩晕，随机化移动方向
            if (眩晕状态 && (dx !== 0 || dy !== 0)) {
                添加日志("你晕头转向，胡乱移动！", "警告");
                const 随机方向 = Math.floor(Math.random() * 4);
                switch (随机方向) {
                    case 0: dx = 0; dy = -1; break; // 上
                    case 1: dx = 1; dy = 0; break; // 右
                    case 2: dx = 0; dy = 1; break; // 下
                    case 3: dx = -1; dy = 0; break; // 左
                }
                // 确保移动步数正确应用到随机方向
                dx *= 玩家属性.移动步数;
                dy *= 玩家属性.移动步数;
                // 如果缓慢，只移动一格
                if (缓慢状态) {
                    dx = Math.sign(dx);
                    dy = Math.sign(dy);
                }
            } else {
                if (缓慢状态) {
                    dx = Math.sign(dx);
                    dy = Math.sign(dy);
                }
            }

            let 新X = 玩家.x + dx;
            let 新Y = 玩家.y + dy;
            if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小 || (dy !== 0 && dx !== 0))
                return;
            相机锁定 = false;
            let 剩余步数 = 缓慢状态 ? 1 : 玩家属性.移动步数;
            let 实际移动 = 0;
            let 目标X, 目标Y = 0;
            while (剩余步数 > 0 && !冻结状态 && (玩家.x !== 新X || 玩家.y !== 新Y)) {
                目标X = 玩家.x + Math.sign(dx);
                目标Y = 玩家.y + Math.sign(dy);
                let 目标单元格 = 地牢[目标Y][目标X];
                let 当前单元格 = 地牢[玩家.y][玩家.x];
                if (!检查移动可行性(玩家.x, 玩家.y, 目标X, 目标Y)) break;
                if (!目标单元格) {
                    // 更新视口和状态
                    更新视口();
                    绘制();
                    return;
                }
                if (
                    [单元格类型.楼梯下楼, 单元格类型.楼梯上楼].includes(
                        目标单元格.类型
                    )
                ) {
                    if (是否为教程层) {
                        是否为教程层 = false;
                        所有怪物.forEach((m) => {
                            m.绘制血条(true);
                            地牢[m.y][m.x].关联怪物 = null;
                        });
                        所有怪物 = [];
                        document.getElementById("跳过教程按钮").style.display = "none";
                        重置玩家状态();
                        切换楼层(0);
                        return;
                    } else {
                        目标单元格.关联物品.使用();
                    }

                    // 更新视口和状态
                    更新视口();
                    更新界面状态();
                    绘制();
                    return;
                }
                if (
                    目标单元格.关联物品 &&
                    目标单元格.类型 === 单元格类型.物品 &&
                    !目标单元格.关联物品.是否被丢弃
                ) {
                    if (尝试收集物品(目标单元格.关联物品)) {
                        目标单元格.类型 = null;
                        目标单元格.关联物品 = null;
                    }

                }


                玩家.x = 目标X;
                玩家.y = 目标Y;
                实际移动++;
                剩余步数--;
                // 消耗能量检查
                if (当前激活卷轴列表.size > 0 && 实际移动 > 0) {
                    当前激活卷轴列表.forEach(卷轴 => {
                        卷轴.消耗能量();
                    });
                }

                const 目标房间ID = 房间地图[目标Y][目标X];
                if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
                    moveQueue = [];
                    已访问房间.add(目标房间ID);
                    能量条.style.width = `${Math.min(100, 当前能量 + 7)}%`;
                    if (是否为教程层) {
                        教程阶段 = 目标房间ID;
                        教程提示已显示 = false;
                        显示教程提示();
                    }
                }
            }
            if (地牢[玩家.y][玩家.x].关联物品 instanceof 折跃门) {
                地牢[玩家.y][玩家.x].关联物品.使用();
            }
            尝试进入特殊房间(玩家.x, 玩家.y);
            if (实际移动 > 0 || 冻结状态) {
                const 方向 =
                    Math.sign(dy) === -1 ? "上" :
                        Math.sign(dy) === 1 ? "下" :
                            Math.sign(dx) === -1 ? "左" :
                                Math.sign(dx) === 1 ? "右" : "";
                移动历史.push(方向);

                // 保持历史长度不超过序列长度
                if (移动历史.length > 调试序列.length) {
                    移动历史.shift();
                }
                [...玩家装备.values()].forEach(item => {
                    if (item instanceof 寻宝戒指) {
                        if (item.自定义数据.get("生效层数") === 当前层数 && !item.自定义数据.get("已生成折跃门")) {
                            item.尝试生成折跃门();
                        }
                    }
                });


                // 检测序列
                if (移动历史.join(",") === 调试序列.join(",")) {
                    const 当前房间ID = 房间地图[玩家.y][玩家.x];
                    if (当前房间ID !== -1) {
                        const 迅捷卷轴测试 = new 迅捷卷轴({});
                        放置物品到房间(迅捷卷轴测试, 房间列表[当前房间ID]);

                        const 秘银锁甲测试 = new 秘银锁甲({});
                        放置物品到房间(秘银锁甲测试, 房间列表[当前房间ID]);

                        const 跃迁卷轴测试 = new 跃迁卷轴({});
                        放置物品到房间(跃迁卷轴测试, 房间列表[当前房间ID]);

                        const 真言卷轴测试 = new 真言卷轴({});
                        放置物品到房间(真言卷轴测试, 房间列表[当前房间ID]);

                        const 湮灭卷轴测试 = new 湮灭卷轴({});
                        放置物品到房间(湮灭卷轴测试, 房间列表[当前房间ID]);

                        const 贪婪卷轴测试 = new 贪婪卷轴({});
                        放置物品到房间(贪婪卷轴测试, 房间列表[当前房间ID]);

                        const 附魔卷轴测试 = new 附魔卷轴({});
                        放置物品到房间(附魔卷轴测试, 房间列表[当前房间ID]);

                        const 回旋镖测试 = new 回旋镖({});
                        放置物品到房间(回旋镖测试, 房间列表[当前房间ID]);

                        const 冰霜法杖测试 = new 冰霜法杖({});
                        放置物品到房间(冰霜法杖测试, 房间列表[当前房间ID]);

                        const 剧毒匕首测试 = new 剧毒匕首({});
                        放置物品到房间(剧毒匕首测试, 房间列表[当前房间ID]);

                        const 重力锤测试 = new 重力锤({});
                        放置物品到房间(重力锤测试, 房间列表[当前房间ID]);

                        const 闪电链法杖测试 = new 闪电链法杖({});
                        放置物品到房间(闪电链法杖测试, 房间列表[当前房间ID]);

                        const 大地猛击锤测试 = new 大地猛击锤({});
                        放置物品到房间(大地猛击锤测试, 房间列表[当前房间ID]);

                        const 穿云箭测试 = new 穿云箭({});
                        放置物品到房间(穿云箭测试, 房间列表[当前房间ID]);

                        const 荆棘鞭测试 = new 荆棘鞭({});
                        放置物品到房间(荆棘鞭测试, 房间列表[当前房间ID]);

                        const 能量药水测试 = new 能量药水({});
                        放置物品到房间(能量药水测试, 房间列表[当前房间ID]);

                        const 狂暴药水测试 = new 狂暴药水({});
                        放置物品到房间(狂暴药水测试, 房间列表[当前房间ID]);

                        const 神龟药水测试 = new 神龟药水({});
                        放置物品到房间(神龟药水测试, 房间列表[当前房间ID]);

                        const 治疗药水测试 = new 治疗药水({});
                        放置物品到房间(治疗药水测试, 房间列表[当前房间ID]);

                        const 透视药水测试 = new 透视药水({});
                        放置物品到房间(透视药水测试, 房间列表[当前房间ID]);

                        const 隐身药水测试 = new 隐身药水({});
                        放置物品到房间(隐身药水测试, 房间列表[当前房间ID]);

                        const 橡木法杖测试 = new 橡木法杖({});
                        放置物品到房间(橡木法杖测试, 房间列表[当前房间ID]);

                        const 金币手枪测试 = new 金币手枪({});
                        放置物品到房间(金币手枪测试, 房间列表[当前房间ID]);

                        const 寻宝戒指测试 = new 寻宝戒指({});
                        放置物品到房间(寻宝戒指测试, 房间列表[当前房间ID]);

                        const 炸弹测试 = new 炸弹({});
                        放置物品到房间(炸弹测试, 房间列表[当前房间ID]);

                        const 冰盾测试 = new 冰盾({});
                        放置物品到房间(冰盾测试, 房间列表[当前房间ID]);

                        const 重铸台测试 = new 重铸台({});
                        放置物品到房间(重铸台测试, 房间列表[当前房间ID]);

                        const 神秘商人测试 = new 神秘商人({});
                        放置物品到房间(神秘商人测试, 房间列表[当前房间ID]);

                        const 探险家测试 = new 探险家({});
                        放置物品到房间(探险家测试, 房间列表[当前房间ID]);

                        const 喷火枪测试 = new 喷火枪({});
                        放置物品到房间(喷火枪测试, 房间列表[当前房间ID]);

                        const 背包扩容祭坛测试 = new 背包扩容祭坛({});
                        放置物品到房间(背包扩容祭坛测试, 房间列表[当前房间ID]);

                        const 宠物测试 = new 水母({});
                        放置物品到房间(宠物测试, 房间列表[当前房间ID]);

                        const 金币测试 = new 金币({ 数量: 64 });
                        放置物品到房间(金币测试, 房间列表[当前房间ID]);
                        if (!彩蛋3触发) {
                            显示通知("你被加强了，快上！", "信息", true)
                            彩蛋3触发 = true;
                        }
                    }
                    移动历史 = []; // 重置以防重复触发
                }
                // 更新视口和状态

                更新武器冷却();
                处理怪物回合();
                处理天气效果();
                更新视口();
                if (当前天气效果.includes("诡魅")) {
                    处理诡魅房间刷新(玩家.x - dx, 玩家.y - dy, 玩家.x, 玩家.y); // 传入移动前的玩家位置
                }
                更新物体指示器();
                if (当前能量<70) {
                能量条.style.width = `${Math.min(70, 当前能量 + 1)}%`;
                }
                玩家状态.forEach((item) => {
                    item.更新状态();
                });
                所有计时器.forEach((item) => {
                    item.更新倒计时();
                });
                [...玩家装备.values()].forEach(装备 => {
                    if (装备 instanceof 宠物) {
                        装备.恢复生命值();
                    }
                });
            }
            if (isAutoMoving && (玩家.x !== 新X || 玩家.y !== 新Y)) {
                moveQueue = []; // 移动被阻挡则停止
                isAutoMoving = false;
            }

            更新界面状态();
            绘制();
        }
        function 卷轴扣除能量(能量) {
            const 能量条 = document.querySelector(".power-bar");
            let 当前能量 = Math.max(
                Math.min(parseFloat(能量条.style.width), 100),
                0
            );
            当前能量 -= 能量;
            if (当前能量 <= 0) {
                if (当前激活卷轴列表.size > 0) {
                    当前激活卷轴列表.forEach(卷轴 => {
                        当前激活卷轴列表.delete(卷轴);
                        卷轴.卸下();

                    });
                    恢复卷轴模式();
                    当前能量 = 0;
                }
                更新装备显示();
                显示通知("能量不足，已自动取消卷轴效果", "信息");
                return false;
            }
            能量条.style.width = `${Math.max(0, 当前能量)}%`;
            触发HUD显示();
            return true;
        }
        function 检查移动可行性(fromX, fromY, toX, toY, 未解锁房间视作障碍 = false) {
            if (toX < 0 || toX >= 地牢大小 || toY < 0 || toY >= 地牢大小)
                return false;

            const dx = toX - fromX;
            const dy = toY - fromY;
            const 方向 = {
                dx: dx !== 0 ? (dx > 0 ? 1 : -1) : 0,
                dy: dy !== 0 ? (dy > 0 ? 1 : -1) : 0,
            };
            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                // 多格移动需要直线路径
                if (dx !== 0 && dy !== 0) return false; // 禁止斜向多格移动
                return 快速直线检查(fromX, fromY, toX, toY, Math.max(Math.abs(dx), Math.abs(dy)));
            }
            // 检查路径上的每个单元格
            let currentX = fromX;
            let currentY = fromY;

            while (currentX !== toX || currentY !== toY) {
                currentX += 方向.dx;
                currentY += 方向.dy;

                const 当前单元格 = 地牢[currentY][currentX];
                const 前一单元格 =
                    地牢[currentY - 方向.dy][currentX - 方向.dx];

                // 检查物理障碍
                const 垂直移动 = 方向.dy !== 0;
                const 墙方向 = 垂直移动
                    ? 方向.dy > 0
                        ? "下"
                        : "上"
                    : 方向.dx > 0
                        ? "右"
                        : "左";

                if (垂直移动) {
                    if (
                        前一单元格.墙壁[方向.dy > 0 ? "下" : "上"] ||
                        当前单元格.墙壁[方向.dy > 0 ? "上" : "下"]
                    ) {
                        return false;
                    }
                } else {
                    if (
                        前一单元格.墙壁[方向.dx > 0 ? "右" : "左"] ||
                        当前单元格.墙壁[方向.dx > 0 ? "左" : "右"]
                    ) {
                        return false;
                    }
                }

                // 检查单元格类型
                if (
                    [单元格类型.墙壁, 单元格类型.上锁的门].includes(
                        当前单元格.背景类型
                    )
                ) {
                    return false;
                }
                if (房间地图[currentY][currentX] !== 0 && 房间地图[currentY][currentX] !== -1 && !已访问房间.has(房间地图[currentY][currentX]) && 未解锁房间视作障碍) return false;
            }
            return true;
        }
        function 处理丢弃物品(唯一标识) {

            const 物品实例 = 玩家背包.get(唯一标识);
            if (!物品实例) return false;

            let 目标X = 玩家.x;
            let 目标Y = 玩家.y;
            let 可用 = false;

            if (位置是否可用(目标X, 目标Y, false)) {
                可用 = true;
            } else {
                const 方向 = [[0, -1], [0, 1], [-1, 0], [1, 0], [1, -1], [1, 1], [-1, 1], [-1, -1]];
                for (const [dx, dy] of 方向) {
                    const 新X = 玩家.x + dx;
                    const 新Y = 玩家.y + dy;

                    if (新X >= 0 && 新X < 地牢大小 && 新Y >= 0 && 新Y < 地牢大小 &&
                        位置是否可用(新X, 新Y) &&
                        检查移动可行性(玩家.x, 玩家.y, 新X, 新Y)
                    ) {
                        目标X = 新X;
                        目标Y = 新Y;
                        可用 = true;
                        break;
                    }
                }
            }


            if (!可用) {
                显示通知("周围没有空间丢弃物品！", "错误");
                return false;
            }
            if (!物品实例.当被丢弃(目标X, 目标Y)) {
                return false;
            }
            玩家背包.delete(唯一标识);
            if (物品实例.已装备) {
                玩家装备.delete(物品实例.装备槽位);
                物品实例.已装备 = false;
                物品实例.装备槽位 = null;
            }

            物品实例.是否被丢弃 = true;
            物品实例.isActive = false;
            放置物品到单元格(物品实例, 目标X, 目标Y);

            更新背包显示();
            更新装备显示();
            显示通知(`丢弃了 ${物品实例.获取名称()}`, "信息");
            document.getElementById("浮动提示框").style.display = "none";

            return true;
        }
        function 处理天气效果() {
            if (当前天气效果.includes("雷暴")) {
                处理雷暴效果();
            }
            if (当前天气效果.includes("大风")) {
                处理大风效果();
            }
            if (当前天气效果.includes("严寒")) {
                处理严寒效果();
            } else {
                解冻药水();
            }
        }
        function 是否靠近火源(目标X, 目标Y) {

            if (目标X === 玩家.x && 目标Y === 玩家.y) {
                if (玩家状态.some(s => s.类型 === '火焰')) return true;
                if ([...玩家装备.values()].some(装备 =>
                    装备 instanceof 火把 && 装备.自定义数据?.get("耐久") > 0
                )) return true;
            }

            const 方向数组 = [[0, 0], [0, -1], [0, 1], [-1, 0], [1, 0], [-1, -1], [1, -1], [-1, 1], [1, 1]];
            for (const [dx, dy] of 方向数组) {
                const 检查X = 目标X + dx;
                const 检查Y = 目标Y + dy;
                if (检查X >= 0 && 检查X < 地牢大小 && 检查Y >= 0 && 检查Y < 地牢大小) {
                    const 单元格 = 地牢[检查Y]?.[检查X];
                    const 怪物实例 = 单元格?.关联怪物;
                    if (单元格?.关联物品 instanceof 火焰物品 && 单元格.关联物品.自定义数据.get("倒计时") > 0) {
                        return true;
                    }

                    else if (单元格?.关联物品 instanceof 火把 && 单元格.关联物品.自定义数据.get("耐久") > 0 && 单元格.关联物品.是否被丢弃) {
                        return true;
                    } else if (怪物实例 && 怪物状态表.get(怪物实例)?.类型 === '火焰') {
                        return true;
                    }

                }
            }
            return false;
        }
        function 解冻药水() {
            let 解冻发生标志 = false;
            玩家背包.forEach(物品实例 => {

                if (物品实例 instanceof 药水类 && 物品实例.自定义数据.get("是否冻结")) {
                    物品实例.自定义数据.set("是否冻结", false);

                    解冻发生标志 = true;
                }
            });
            if (解冻发生标志) {
                添加日志("背包里的药水解冻了。", "信息");
                更新背包显示();
            }
        }

        function 处理严寒效果() {

            if (!玩家状态.some(s => s.类型 === '冻结') && !是否靠近火源(玩家.x, 玩家.y)) {
                if (Math.random() < 0.1) {
                    new 状态效果("冻结", "#2196F3", 图标映射.冰冻怪物, 2, null, null, null, 1);
                    添加日志("你被严寒冻结了！", "错误");
                }
            }


            let 有药水被冻结 = false;
            玩家背包.forEach(物品实例 => {

                if (物品实例 instanceof 药水类 && !物品实例.自定义数据.get("是否冻结")) {

                    if (!是否靠近火源(玩家.x, 玩家.y)) {
                        物品实例.自定义数据.set("是否冻结", true);
                        有药水被冻结 = true;
                        添加日志(`${物品实例.获取名称()} 被冻结了！`, "警告");
                    }
                }
            });
            if (有药水被冻结) {
                更新背包显示();
            }
            if (是否靠近火源(玩家.x, 玩家.y)) {
                解冻药水();
            }

        }
        function 处理雷暴效果() {
            if (Math.random() < 0.1) {
                const 玩家房间ID = 房间地图[玩家.y][玩家.x];
                if (玩家房间ID === -1) return;

                const 玩家所在房间 = 房间列表[玩家房间ID];
                if (!玩家所在房间 || 玩家所在房间.w < 2 || 玩家所在房间.h < 2) return;

                const rx = 玩家所在房间.x + Math.floor(Math.random() * (玩家所在房间.w - 1));
                const ry = 玩家所在房间.y + Math.floor(Math.random() * (玩家所在房间.h - 1));

                const 闪电坐标 = [
                    { x: rx, y: ry },
                    { x: rx + 1, y: ry },
                    { x: rx, y: ry + 1 },
                    { x: rx + 1, y: ry + 1 },
                ];

                计划显示格子特效(闪电坐标, "FFFF00", 50);

                闪电坐标.forEach(坐标 => {
                    if (坐标.x < 0 || 坐标.x >= 地牢大小 || 坐标.y < 0 || 坐标.y >= 地牢大小) return;
                    const 单元格 = 地牢[坐标.y]?.[坐标.x];
                    if (!单元格) return;


                    if (单元格.关联物品 && 单元格.关联物品?.类型 !== "楼梯") {

                        const 被毁物品 = 单元格.关联物品;
                        添加日志(`${被毁物品.名称} 被闪电摧毁了！`, "警告");
                        const 计时器索引 = 所有计时器.findIndex(t => t.唯一标识 === 被毁物品.唯一标识);
                        if (计时器索引 !== -1) {
                            所有计时器.splice(计时器索引, 1);
                        }
                        if (玩家背包.has(被毁物品.唯一标识)) {
                            处理销毁物品(被毁物品.唯一标识, true);
                        }
                        单元格.关联物品 = null;
                        单元格.类型 = 单元格.背景类型;
                    }


                    if (单元格.关联怪物) {
                        const 怪物 = 单元格.关联怪物;
                        let 被击中日志 = `${怪物.类型} 被闪电击中`;
                        if (怪物.强化) {
                            怪物.受伤(15, "雷暴");
                            被击中日志 += `，损失了 15 点生命！`;
                        } else {
                            怪物.强化 = true;
                            怪物.绘制血条();
                            显示通知(`${怪物.类型} 被闪电强化了！`, "警告");
                            被击中日志 += `，并被强化了！`;
                            绘制();
                        }
                        const 火焰强度 = 3;
                        const 火焰持续 = 3;
                        new 状态效果("火焰", 效果颜色编号映射[效果名称编号映射.火焰], "火", 火焰持续, null, null, 怪物, 火焰强度);
                        被击中日志 += ` 还着火了！`;

                        添加日志(被击中日志, "警告");
                    }


                    if (玩家.x === 坐标.x && 玩家.y === 坐标.y) {
                        伤害玩家(15, "雷暴");
                        显示通知("你被闪电击中了！", "错误");

                        const 火焰强度玩家 = 3;
                        const 火焰持续玩家 = 3;
                        new 状态效果("火焰", 效果颜色编号映射[效果名称编号映射.火焰], 图标映射.火焰, 火焰持续玩家, null, null, null, 火焰强度玩家);
                        添加日志("你被闪电点燃了！", "错误");

                    }



                    if (位置是否可用(坐标.x, 坐标.y, false)) {
                        const 火焰 = new 火焰物品({ 强化: Math.random() < 0.1 });
                        if (!放置物品到单元格(火焰, 坐标.x, 坐标.y)) {
                            console.warn(`未能放置火焰物品在 (${坐标.x}, ${坐标.y})`);
                        }
                    }
                });
                绘制();
            }
        }
        function 伤害玩家(原始攻击力, 伤害来源 = null) {
            let 最终攻击力 = 原始攻击力;
            if (伤害来源 instanceof 怪物) {
                伤害来源_ = 伤害来源.类型;
            } else {
                伤害来源_ = 伤害来源;
            }
            [...玩家装备.values()].forEach((装备) => {
                if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                    最终攻击力 = 装备.当玩家被攻击(最终攻击力, 伤害来源);
                }
                if (
                    装备 instanceof 防御装备类
                ) {
                    最终攻击力 = 装备.当被攻击(最终攻击力, 伤害来源);
                }
            });
            最终攻击力 = Math.max(0, 最终攻击力 - 玩家属性.防御加成);
            更新装备显示();
            触发扣血特效();

            const 生命条 = document.querySelector(".health-bar");
            const 当前宽度 = parseFloat(生命条.style.width) || 100;
            const 新宽度 = Math.max(0, 当前宽度 - 最终攻击力);
            生命条.style.width = `${新宽度}%`;
            添加日志(
                `受到了 ${伤害来源_} 的伤害！损失了 ${最终攻击力} 点血量！`,
                `警告`
            );
            // 显示通知(`受到了 ${this.图标} 的攻击！造成了 ${this.最终攻击力} 点伤害！`,`警告`);
            // console.log(新宽度);
            触发HUD显示();

            if (新宽度 <= 0) {
                玩家死亡();
            }
        }
        function 更新武器冷却() {
            玩家背包.forEach((item) => {
                if (
                    item.类型 === "武器" &&
                    item.自定义数据.get("冷却剩余") > 0
                ) {
                    item.自定义数据.set(
                        "冷却剩余",
                        item.自定义数据.get("冷却剩余") - 1
                    );
                }
            });
            更新装备显示();
        }

        function 处理怪物回合() {
            // 激活当前房间怪物
            const 当前房间ID = 房间地图[玩家.y][玩家.x];
            跟踪玩家怪物数 = 0;
            所有怪物.forEach((m) => {
                if (房间地图[m.y][m.x] === 当前房间ID) {
                    m.状态 = 怪物状态.活跃;
                }
            });

            // 处理每个活跃怪物
            所有怪物.forEach((m) => {
                if (m.状态 === 怪物状态.活跃) {

                    let { x, y } = m.选择目标();
                    m.目标路径 = m.计算路径(x, y);
                    if (m.目标路径) {
                        m.通向目标路径 = m.计算目标路径(m.目标.x, m.目标.y);
                        if (m.通向目标路径) {
                            if (m.目标路径.length > 0 && !(m.通向目标路径.length > 1 && 玩家状态.some(s => s.类型 === "隐身") && 怪物状态表.get(m)?.类型 !== "魅惑")) {
                                m.追击玩家中 = true;
                                m.尝试移动(); //可能有bug：当玩家远离怪物时，药水效果不会正常被处理。

                            } else {
                                m.追击玩家中 = false;
                            }
                        } else {
                            m.追击玩家中 = false;
                        }
                        m.通向目标路径 = m.计算目标路径(m.目标.x, m.目标.y);
                        if (m.通向目标路径) {
                            if (!(m.通向目标路径.length > 1 && 玩家状态.some(s => s.类型 === "隐身") && 怪物状态表.get(m)?.类型 !== "魅惑")) {
                                m.尝试攻击();
                            } else {
                                m.绘制血条();
                            }
                        }
                        const 我的状态 = 怪物状态表.get(m);
                        我的状态?.更新状态();
                        if (m instanceof 大魔法师) {
                            m.更新技能冷却();
                        }
                    } else {
                        m.追击玩家中 = false;
                    }
                }
            });
            const 提示元素 =
                怪物追踪提示.容器元素.querySelector(".hud-label");
            if (跟踪玩家怪物数 > 3) {
                提示元素.classList.add("怪物数量警告");
            } else {
                提示元素.classList.remove("怪物数量警告");
            }
            怪物追踪提示.更新({
                内容: `追踪怪物：${跟踪玩家怪物数}`,
            }); //图标: 跟踪玩家怪物数 > 0 ? "🔥" : "👹"  删去，太唐了
        }
        function 切换日志显示() {
            日志面板可见 = !日志面板可见;
            const 按钮 = document.querySelector("#设置菜单 button:nth-child(1)"); // 第一个按钮
            if (日志面板可见) {
                document.querySelector(".日志面板").classList.add("可见");
                按钮.textContent = "关闭日志界面"; // 更新按钮文本
            } else {
                document.querySelector(".日志面板").classList.remove("可见");
                按钮.textContent = "打开日志界面"; // 更新按钮文本
            }
        }
        function 切换背包显示() {
            const 弹窗 = document.querySelector(".背包弹窗");
            const 当前状态 = 弹窗.classList.contains("显示中");
            // 关闭背包时清除所有选中状态
            if (当前状态) {
                document.querySelectorAll(".物品条目").forEach((el) => {
                    el.classList.remove("active");
                    if (el.__物品实例) {
                        el.__物品实例.isActive = false;
                    }
                });
            }
            // 更新全局状态
            界面可见性.背包 = !当前状态;

            弹窗.classList.toggle("显示中", !当前状态);
        }
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && 界面可见性.背包) {
                切换背包显示();
            }
        });
        document.addEventListener("click", (e) => {
            const 弹窗 = document.querySelector(".背包弹窗");
            const 背包区域 = document.querySelector(".背包弹窗 .物品容器");
            if (
                界面可见性.背包 &&
                !e.target.closest(".背包弹窗") &&
                !e.target.closest("#背包按钮")
            ) {
                切换背包显示();
            } else if (教程提示已显示 && !e.target.closest("#教程提示窗口")) {
                关闭教程提示();
            } else if (document.getElementById("设置菜单").classList.contains("显示") &&
                !e.target.closest("#设置按钮")) {
                切换设置菜单();
            } else if (document.getElementById('教程回放窗口').style.display === 'block' &&
                !e.target.closest(".教程提示窗口") &&
                !e.target.closest("#回放教程按钮")) {
                关闭教程回放窗口();
            }
            if (!e.target.closest(".物品条目") && 界面可见性.背包) {
                document.querySelectorAll(".物品条目").forEach((el) => {
                    el.classList.remove("active");
                    if (el.__物品实例) {
                        el.__物品实例.isActive = false;
                        //console.log(el.__物品实例.类型);
                    }
                });
            }
        });

        // 键盘事件监听
        document.addEventListener("keydown", (e) => {
            const keyMap = {
                'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                'ArrowDown': 'down', 's': 'down', 'S': 'down',
                'ArrowRight': 'right', 'd': 'right', 'D': 'right'
            };
            if (keyMap[e.key] && 玩家属性.允许移动) {
                const direction = keyMap[e.key];

                // 不重复触发
                if (移动状态[direction]) return;

                移动状态[direction] = true;
                const dx = 移动状态.left ? -玩家属性.移动步数 : 移动状态.right ? 玩家属性.移动步数 : 0;
                const dy = 移动状态.up ? -玩家属性.移动步数 : 移动状态.down ? 玩家属性.移动步数 : 0;

                if (dx !== 0 || dy !== 0) {
                    移动玩家(dx, dy);
                }
                // 延迟调用
                clearTimeout(开始移动定时器);
                开始移动定时器 = setTimeout(开始移动, 250);

                e.preventDefault(); // 阻止默认行为
            } else if (功能键映射[e.key]) {
                功能键映射[e.key]();
            } else if (e.key === "Escape" && 界面可见性.背包) {
                切换背包显示();
            }
        });

        document.addEventListener("keyup", (e) => {
            const keyMap = {
                'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                'ArrowDown': 'down', 's': 'down', 'S': 'down',
                'ArrowRight': 'right', 'd': 'right', 'D': 'right'
            };
            if (keyMap[e.key]) {
                const direction = keyMap[e.key];
                移动状态[direction] = false; // 清除移动状态
                clearTimeout(开始移动定时器); // 重要！清除 开始移动 定时器
                停止移动();
                e.preventDefault();
            }
        });
        function 获取玩家视野范围() {
            const 画布 = document.getElementById("dungeonCanvas");
            const 画布Rect = 画布.getBoundingClientRect();
            if (!当前天气效果.includes("深夜")) return Math.floor(画布Rect.width / 单元格大小 / 2);
            let 基础视野 = 3; // 默认视野范围
            let 视野加成 = 0;
            玩家装备.forEach(物品 => {
                if (物品 instanceof 火把) {
                    视野加成 += 物品.自定义数据.get("视野加成") || 0;
                }

            });
            return 基础视野 + 视野加成;
        }

        function 是否在光源范围内(目标X, 目标Y) {
            const 目标单元格 = 地牢[目标Y]?.[目标X];
            if (!目标单元格) return false; // 无效目标格

            // 检查玩家自身光源
            const 玩家距离 = Math.abs(目标X - 玩家.x) + Math.abs(目标Y - 玩家.y);
            const 玩家视野 = 获取玩家视野范围();
            if (玩家距离 <= 玩家视野) {
                if (检查视线(玩家.x, 玩家.y, 目标X, 目标Y, 玩家视野) || 目标单元格.背景类型 === 单元格类型.上锁的门) {
                    return true;
                }
            }

            // 检查地上的火把光源 和 新增的火焰光源
            const 检查范围 = 5; // 假设光源最大范围不超过5
            for (let dy = -检查范围; dy <= 检查范围; dy++) {
                for (let dx = -检查范围; dx <= 检查范围; dx++) {
                    const checkX = 目标X + dx;
                    const checkY = 目标Y + dy;

                    if (checkX >= 0 && checkX < 地牢大小 && checkY >= 0 && checkY < 地牢大小) {
                        const 单元格 = 地牢[checkY]?.[checkX];
                        if (单元格?.关联物品 && 单元格.关联物品.自定义数据?.has("光照范围")) { // 检查是否有光照范围属性
                            const 光源物品 = 单元格.关联物品;
                            const 光照范围 = 光源物品.自定义数据.get("光照范围");
                            const 怪物实例 = 单元格.关联怪物;
                            let 光源有效 = false;

                            if (光源物品 instanceof 火把 && 光源物品.自定义数据.get("耐久") > 0 && 光源物品.是否被丢弃) {
                                光源有效 = true;
                            } else if (光源物品 instanceof 火焰物品) {
                                光源有效 = true;
                            } else if (怪物实例 && 怪物状态表.get(怪物实例)?.类型 === '火焰') {
                                光源有效 = true;
                            }

                            if (光源有效) {
                                const 距离光源 = Math.abs(目标X - 光源物品.x) + Math.abs(目标Y - 光源物品.y);
                                if (距离光源 <= 光照范围) {
                                    if (检查视线(光源物品.x, 光源物品.y, 目标X, 目标Y, 光照范围) || 目标单元格.背景类型 === 单元格类型.上锁的门) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false; // 不在任何光源范围内
        }
        function 切换中文模式() {
            图标映射 = 中文对照图标映射;
            楼梯图标 = {
                下楼: 图标映射.下楼楼梯,
                上楼: 图标映射.上楼楼梯,
            };
            document
                .querySelector("#背包按钮").innerHTML = `${图标映射.背包按钮}`;
            document
                .querySelector("#互动按钮").innerHTML = `${图标映射.互动按钮}`;
            document
                .querySelector("#卷轴按钮").innerHTML = `${图标映射.卷轴按钮}`;
            document.querySelector("#设置菜单 button:nth-child(2)").remove();
            中文模式 = true;
            切换HUD模式();
            return;
        }
        function 使用装备槽物品(槽位编号) {
            const 物品实例 = [...玩家装备.values()].find(item => item.装备槽位 === 槽位编号);

            if (!物品实例) return;

            // 无需考虑堆叠
            if (物品实例.类型 === "武器") {
                if (
                    物品实例.堆叠数量 > 0 &&
                    物品实例.自定义数据.get("冷却剩余") == 0
                ) {
                    const { 怪物, 路径 } = 获取周围怪物(
                        物品实例.自定义数据.get("攻击目标数"),
                        物品实例.自定义数据.get("攻击范围")
                    );
                    if (怪物 !== null) {

                        if (物品实例.使用(怪物, 路径)) {
                            [...玩家装备.values()].forEach(装备 => {
                                if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                                    装备.当玩家攻击(怪物);
                                }
                            });
                            更新装备显示();
                            绘制();
                            return true;
                        }
                        //失败后回退到 物品实例.使用()
                    } else {
                        if (当前天气效果.includes("诡魅")) {
                            显示通知("太远了...看不清怪物的真实位置了...", "错误");
                        } else {
                            显示通知("附近没有目标", "错误");
                        }

                        return false;
                    }
                } else {
                    显示通知("武器还未准备好", "错误");
                    return false;
                }
            }
            if (物品实例.类型 === "卷轴") {
                显示通知("请使用卷轴键使用该物品", "错误");
                return false;
            }
            if (物品实例.使用()) {
                if (物品实例.堆叠数量 <= 0) {
                    if (物品实例.装备槽位)
                        玩家装备.delete(物品实例.装备槽位);
                    玩家背包.delete(物品实例.唯一标识);
                }
                更新背包显示();
                更新装备显示();
                显示通知("已使用物品", "成功");
                return true;

            } else {
                if (物品实例.类型 !== "武器") {
                    显示通知("无法使用该物品", "错误");
                }
            }
            return false;
        }


        function 卸下装备槽物品(槽位编号) {
            const 当前物品 = [...玩家装备.values()].find(item => item.装备槽位 === 槽位编号);

            if (当前物品) {
                当前物品.取消装备();
                显示通知("已卸下", "成功");
                更新装备显示();
                更新背包显示();


                const 槽位 = document.getElementById(`装备槽${槽位编号}`);
                槽位.style.transform = "scale(0.95)";
                setTimeout(() => (槽位.style.transform = "scale(1)"), 200);
            }
        }
        function 处理销毁物品(唯一标识, 直接清理 = false) {
            const 目标物品 = 玩家背包.get(唯一标识);
            if (!直接清理) {
                if (!confirm("确定要销毁这个物品吗？")) return false;
            }
            if (!目标物品) return false;

            const 物品元素 = 目标物品.显示元素;
            document.getElementById("浮动提示框").style.display = "none";
            if (!直接清理) {

                const 烟花容器 = document.createElement("div");
                烟花容器.style.position = "fixed";
                烟花容器.style.left = `${物品元素.getBoundingClientRect().left + 40
                    }px`;
                烟花容器.style.top = `${物品元素.getBoundingClientRect().top + 40
                    }px`;
                烟花容器.style.zIndex = 99999;
                document.body.appendChild(烟花容器);


                for (let i = 0; i < 12; i++) {
                    const 粒子 = document.createElement("div");
                    粒子.className = "烟花粒子";
                    粒子.innerHTML = ["✨", "❄️", "⚡", "⭐", "💥", "🔥"][
                        i % 6
                    ];
                    粒子.style.color =
                        目标物品.颜色表[目标物品.颜色索引] || "#fff";
                    粒子.style.setProperty(
                        "--tx",
                        Math.cos((i * 30 * Math.PI) / 180)
                    );
                    粒子.style.setProperty(
                        "--ty",
                        Math.sin((i * 30 * Math.PI) / 180)
                    );
                    烟花容器.appendChild(粒子);
                }
                // 同步执行销毁
                setTimeout(() => {
                    烟花容器.remove();
                    if (目标物品.安全销毁()) {
                        [...玩家背包.values()].forEach(item => {
                            if (item instanceof 宠物) {
                                for (let 槽位 in item.自定义数据.get("装备")) {
                                    if (item.自定义数据.get("装备")[槽位] === 目标物品) {
                                        item.自定义数据.get("装备")[槽位] = null;
                                        item.更新宠物管理窗口();
                                    }
                                }
                            }
                        });
                        if (目标物品.装备槽位) 玩家装备.delete(物品实例.装备槽位);
                        玩家背包.delete(唯一标识);
                        更新背包显示();
                        更新装备显示();
                    }
                }, 800);
            } else {
                if (目标物品.安全销毁()) {
                    [...玩家背包.values()].forEach(item => {
                        if (item instanceof 宠物) {
                            for (let 槽位 in item.自定义数据.get("装备")) {
                                if (item.自定义数据.get("装备")[槽位] === 目标物品) {
                                    item.自定义数据.get("装备")[槽位] = null;
                                    item.更新宠物管理窗口();
                                }
                            }
                        }
                    });
                    if (目标物品.装备槽位) 玩家装备.delete(物品实例.装备槽位);
                    玩家背包.delete(唯一标识);
                    更新背包显示();
                    更新装备显示();
                }
                return
            }
            // 立即隐藏原物品
            物品元素.style.opacity = "0";
            物品元素.style.transition = "opacity 0.2s";
            return true;
        }
        function 尝试收集物品(新物品, 直接收集 = false) {
            if (!新物品.当被收集(玩家)) {
                return false;
            }
            if (!新物品.能否拾起) return false;

            // 查找可堆叠物品
            const 现有物品 = [...玩家背包.values()].find((item) =>
                item.可堆叠于(新物品)
            );

            // 处理可堆叠情况
            if (现有物品) {
                if (现有物品.堆叠数量 < 现有物品.最大堆叠数量) {
                    if (现有物品.堆叠数量 + 新物品.堆叠数量 >= 现有物品.最大堆叠数量) {
                        新物品.堆叠数量 -= 现有物品.最大堆叠数量 - 现有物品.堆叠数量;
                        现有物品.堆叠数量 = 现有物品.最大堆叠数量;
                        return 尝试收集物品(新物品, 直接收集);
                    } else {
                        现有物品.堆叠数量 += 新物品.堆叠数量;
                        更新背包显示();
                        更新装备显示();
                        const 特效元素 = document.createElement("div");
                        特效元素.className = "收集特效";
                        特效元素.style.cssText = `
   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
 `;
                        if (新物品.类型 === "金币") {
                            特效元素.style.cssText = `
   --辉光颜色: ${颜色表[2]};
   color: ${颜色表[2]};
 `;
                        }
                        特效元素.innerHTML = 新物品.显示图标;
                        if (!直接收集) {
                            document.body.appendChild(特效元素);
                        }
                        setTimeout(() => 特效元素.remove(), 1100);
                        return true;
                    }
                }
                // 当前堆叠已满则创建新堆叠
            }

            // 处理新物品，需要考虑该函数会被递归调用，故需要刷新（刷新准没错（（（
            if ([...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0) >= 最大背包容量) {
                更新背包显示();
                更新装备显示();
                显示通知("背包已满！", "错误");
                return false;
            }
            if (新物品.堆叠数量 > 0) {
                玩家背包.set(新物品.唯一标识, 新物品);
                添加日志(`已收集物品 ${新物品.获取名称()}`, "信息");
            }
            更新背包显示();
            更新装备显示();
            const 特效元素 = document.createElement("div");
            特效元素.className = "收集特效";
            特效元素.style.cssText = `
   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
 `;
            if (新物品.类型 === "金币") {
                特效元素.style.cssText = `
   --辉光颜色: ${颜色表[2]};
   color: ${颜色表[2]};
 `;
            }
            特效元素.innerHTML = 新物品.显示图标;
            if (!直接收集) {
                document.body.appendChild(特效元素);
            }
            setTimeout(() => 特效元素.remove(), 1100);
            return true;
        }

        function 使用背包物品(物品标识) {
            const 物品实例 = 玩家背包.get(物品标识);
            if (!物品实例) return false;
            if (物品实例.类型 === "武器") {
                if (
                    物品实例.堆叠数量 > 0 &&
                    物品实例.自定义数据.get("冷却剩余") == 0
                ) {
                    const { 怪物, 路径 } = 获取周围怪物(
                        物品实例.自定义数据.get("攻击目标数"),
                        物品实例.自定义数据.get("攻击范围")
                    );
                    if (怪物 !== null) {
                        if (物品实例.使用(怪物, 路径)) {
                            [...玩家装备.values()].forEach(装备 => {
                                if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                                    装备.当玩家攻击(怪物);
                                }
                            });
                            更新装备显示();
                            绘制();
                            互动 = true;
                            return true;
                        }
                        //失败后回退到 物品实例.使用()
                    } else {
                        if (当前天气效果.includes("诡魅")) {
                            显示通知("太远了...看不清怪物的真实位置了...", "错误");
                        } else {
                            显示通知("附近没有目标", "错误");
                        }
                        return false;
                    }
                } else {
                    显示通知("武器还未准备好", "错误");
                    return false;
                }
            }
            if (物品实例.类型 === "卷轴") {
                显示通知("请在装备栏中使用该物品", "错误");
                return false;
            }
            if (物品实例.使用()) {
                document.getElementById("浮动提示框").style.display =
                    "none";
                if (物品实例.堆叠数量 <= 0) {
                    if (物品实例.装备槽位)
                        玩家装备.delete(物品实例.装备槽位);
                    玩家背包.delete(物品标识);
                    物品实例.isActive = false;
                }
                更新背包显示();
                更新装备显示();
                显示通知("已使用物品", "成功");
                return true;
            } else {
                显示通知("无法使用该物品", "错误");
            }
            return false;
        }

        function 更新背包显示() {
            const 容器 = document.getElementById("背包物品栏");
            容器.innerHTML = "";

            玩家背包.forEach((item) => {
                if (!item.是否隐藏) {
                    const 元素 = item.生成显示元素();
                    if (item.isActive) {
                        元素.classList.add("active");
                    }
                    容器.appendChild(元素);
                }
            });

            document.getElementById("当前容量").textContent = [...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0);
        }

        function 初始化装备系统() {
            document.querySelectorAll(".装备槽").forEach((槽位, index) => {

                槽位.addEventListener("click", (e) => {
                    const 槽位编号 = index + 1;
                    const 当前物品 = [...玩家装备.values()].find(
                        (item) => item.装备槽位 === 槽位编号
                    );

                    if (当前物品) {
                        if (卷轴模式激活 && 当前物品 instanceof 卷轴类) {
                            //AI Says...
                            当前激活卷轴列表.add(当前物品);
                            if (当前物品.使用()) 显示通知("已启用卷轴", "成功");;
                            恢复卷轴模式();
                            document
                                .querySelectorAll(".装备槽")
                                .forEach((槽位) => {
                                    const 物品 =
                                        槽位.querySelector(".物品条目");
                                    if (物品?.__物品实例 instanceof 卷轴类) {
                                        if (当前激活卷轴列表.has(物品?.__物品实例)) {
                                            物品.classList.add("卷轴闪烁");
                                        }
                                    }
                                });

                            return;
                        }
                        if (
                            当前物品 instanceof 卷轴类 &&
                            当前激活卷轴列表.has(当前物品) &&
                            !卷轴模式激活
                        ) {
                            当前激活卷轴列表.delete(当前物品);
                            document
                                .querySelectorAll(".装备槽")
                                .forEach((槽位) => {
                                    const 物品 =
                                        槽位.querySelector(".物品条目");
                                    if (物品?.__物品实例 instanceof 卷轴类) {
                                        if (物品?.__物品实例 === 当前物品) {
                                            物品.classList.remove("卷轴闪烁");
                                            物品?.__物品实例.卸下();
                                        }
                                    }
                                });

                            显示通知("已禁用卷轴", "成功");
                            return;
                        }
                        使用装备槽物品(槽位编号);
                    }

                });


                if ('ontouchstart' in window) {
                    let 长按计时器;
                    槽位.addEventListener("touchstart", (e) => {
                        //e.preventDefault()
                        长按计时器 = setTimeout(() => {
                            卸下装备槽物品(index + 1);
                        }, 500); // 长按时长 500ms
                    });
                    槽位.addEventListener("touchend", () => {
                        clearTimeout(长按计时器);
                    });
                    槽位.addEventListener("touchcancel", () => {
                        clearTimeout(长按计时器);
                    });
                } else { // 鼠标设备
                    槽位.addEventListener("contextmenu", (e) => {
                        e.preventDefault();
                        卸下装备槽物品(index + 1);
                    });
                }
            });
        }
        function 更新装备显示() {
            for (let i = 1; i <= 4; i++) {
                const 槽位 = document.getElementById(`装备槽${i}`);

                const 装备物品 = [...玩家装备.values()].find(
                    (item) => item.装备槽位 === i
                );

                if (装备物品) {
                    const 克隆元素 = 装备物品
                        .生成显示元素("装备")
                        .cloneNode(true);
                    克隆元素.style.transform =
                        "scale(0.75) translateY(-3px)";
                    克隆元素.style.margin = "-5px 0";
                    克隆元素.classList.remove("active");
                    克隆元素.classList.remove("hover");
                    克隆元素.__物品实例 = 装备物品;
                    克隆元素.removeAttribute("data-quality");


                    ["丢弃按钮", "使用按钮", "装备按钮"].forEach(
                        (className) => {
                            克隆元素.querySelector(
                                `.${className}`
                            )?.remove();
                        }
                    );
                    if (装备物品.类型 === "武器" && (装备物品.自定义数据.get("冷却剩余") > 0 || 槽位.querySelector(`.冷却遮罩`))) {
                        if (槽位.innerHTML === "") {
                            const 耐久标签 = document.createElement("div");
                            耐久标签.className = "耐久标签";
                            耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
                                "耐久"
                            )}`;
                            克隆元素.appendChild(耐久标签);
                            槽位.appendChild(克隆元素);
                        }//考虑武器冷却过程中被装备的情况
                        let 遮罩 = 槽位.querySelector(`.冷却遮罩`);
                        if (!遮罩) {
                            遮罩 = document.createElement("div");
                        }
                        遮罩.className = "冷却遮罩";
                        const 进度 = 1 - (装备物品.自定义数据.get("冷却剩余") /
                            装备物品.自定义数据.get("冷却回合"));
                        遮罩.style.clipPath = `inset(0 0 ${进度 * 100}% 0)`;
                        if (!槽位.querySelector(`.冷却遮罩`)) {
                            槽位.appendChild(遮罩);
                        }
                        if (进度 === 1) {
                            setTimeout(() => 遮罩.remove(), 220);
                        }
                        continue;
                    }
                    if (装备物品.类型 === "防御装备" || (装备物品.类型 === "武器" && !槽位.querySelector(`.冷却遮罩`))) {
                        const 耐久标签 = document.createElement("div");
                        耐久标签.className = "耐久标签";
                        耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
                            "耐久"
                        )}`;
                        克隆元素.appendChild(耐久标签);
                    }

                    if (装备物品.类型 === "卷轴" && 卷轴模式激活) {
                        克隆元素.classList.add("卷轴闪烁");
                    }
                    if (装备物品 instanceof 宠物) {
                        const 血量标签 = document.createElement("div");
                        血量标签.className = "宠物血量标签";
                        血量标签.textContent = `HP: ${装备物品.自定义数据.get("当前生命值")} / ${装备物品.自定义数据.get("最大生命值")}`;
                        克隆元素.appendChild(血量标签);
                    }
                    当前激活卷轴列表.forEach(卷轴 => {
                        if (克隆元素.__物品实例 === 卷轴) {
                            克隆元素.classList.add('卷轴闪烁');
                        }
                    });
                    槽位.innerHTML = "";
                    槽位.appendChild(克隆元素);
                } else {
                    槽位.innerHTML = "";
                }
            }
        }
        function 怪物放置物品(物品, x, y, 能否拾起 = false) {
            let 目标X = x;
            let 目标Y = y;
            let 可用 = false;
            if (位置是否可用(目标X, 目标Y, false)) {
                可用 = true;
            } else {
                const 主要方向 = [
                    [0, -1],
                    [0, 1],
                    [-1, 0],
                    [1, 0],
                ];

                const 次要方向 = [
                    [1, -1],
                    [1, 1],
                    [-1, 1],
                    [-1, -1],
                ];

                for (const [dx, dy] of 主要方向) {
                    const 新X = x + dx;
                    const 新Y = y + dy;

                    if (
                        新X < 0 ||
                        新X >= 地牢大小 ||
                        新Y < 0 ||
                        新Y >= 地牢大小
                    )
                        continue;
                    if (位置是否可用(新X, 新Y)) {
                        目标X = 新X;
                        目标Y = 新Y;
                        可用 = true;
                        break;
                    }
                }

                if (!可用) {
                    for (const [dx, dy] of 次要方向) {
                        const 新X = x + dx;
                        const 新Y = y + dy;

                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            continue;
                        if (位置是否可用(新X, 新Y)) {
                            目标X = 新X;
                            目标Y = 新Y;
                            可用 = true;
                            break;
                        }
                    }
                }
            }
            if (!可用) {
                添加日志("怪物放置物品：没有可放置的位置");
                return { x: null, y: null, 新物品: null };
            }
            let 放置物品 = 物品;
            放置物品.堆叠数量 = 1;
            放置物品.能否拾起 = 能否拾起;
            放置怪物到单元格(放置物品, 目标X, 目标Y);
            return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
        }

        function 玩家放置物品(物品, 能否拾起 = false) {
            let 目标X = 玩家.x;
            let 目标Y = 玩家.y;
            let 可用 = false;
            if (位置是否可用(目标X, 目标Y, false)) {
                可用 = true;
            } else {
                const 主要方向 = [
                    [0, -1],
                    [0, 1],
                    [-1, 0],
                    [1, 0],
                ];

                const 次要方向 = [
                    [1, -1],
                    [1, 1],
                    [-1, 1],
                    [-1, -1],
                ];

                for (const [dx, dy] of 主要方向) {
                    const 新X = 玩家.x + dx;
                    const 新Y = 玩家.y + dy;

                    if (
                        新X < 0 ||
                        新X >= 地牢大小 ||
                        新Y < 0 ||
                        新Y >= 地牢大小
                    )
                        continue;
                    if (位置是否可用(新X, 新Y)) {
                        目标X = 新X;
                        目标Y = 新Y;
                        可用 = true;
                        break;
                    }
                }

                if (!可用) {
                    for (const [dx, dy] of 次要方向) {
                        const 新X = 玩家.x + dx;
                        const 新Y = 玩家.y + dy;

                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            continue;
                        if (位置是否可用(新X, 新Y)) {
                            目标X = 新X;
                            目标Y = 新Y;
                            可用 = true;
                            break;
                        }
                    }
                }
            }
            if (!可用) {
                添加日志("玩家放置物品：没有可放置的位置");
                return { x: null, y: null, 新物品: null };
            }
            let 放置物品 = 克隆物品(物品);
            放置物品.堆叠数量 = 1;
            放置物品.能否拾起 = 能否拾起;
            放置物品到单元格(放置物品, 目标X, 目标Y);
            return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
        }
        function 放置怪物到单元格(怪物, x, y) {
            if (位置是否可用(x, y) || 地牢[y][x].关联物品?.阻碍怪物) {
                地牢[y][x].类型 = 单元格类型.怪物;
                地牢[y][x].关联怪物 = 怪物;
                怪物.x = x
                怪物.y = y;
                怪物.房间ID = 房间地图[y][x];
                所有怪物.push(怪物);
                绘制();
                return true;
            }
            return false;
        }
        function 生成奖励(房间) {
            const 奖励数量 = 3;
            const 奖励物品 = [];
            const 层数 = 当前层数;
            const 品质权重 = [
                { 品质: 3, 权重: 40 + 层数 * 5 },
                { 品质: 4, 权重: 35 + 层数 * 3 },
                { 品质: 5, 权重: 25 + 层数 * 2 },
            ].filter((w) => w.权重 > 0);

            let 已选中 = false;
            let 尝试次数 = 0;
            for (let i = 0; i < 奖励数量; i++) {
                while (!已选中 && 尝试次数 < 100) {
                    const 选中品质 = 加权随机选择(品质权重);
                    const 候选物品 = Object.values(物品池).flat().filter((item) => item.品质 == 选中品质.品质);
                    if (候选物品.length > 0) {
                        const 模板 = 候选物品[Math.floor(Math.random() * 候选物品.length)];
                        const 物品实例 = new 模板.类({
                            数量: 1,
                            强化: Math.random() < Math.min(0.95, 层数 * 0.2),
                            已解锁: true,
                            品质: 选中品质.品质
                        });
                        if (!奖励物品.some((item) => item.名称 === 物品实例.名称) && 物品实例.是否正常物品) {
                            奖励物品.push(物品实例);
                            已选中 = true;
                        }
                    }
                    尝试次数++;
                }
                已选中 = false;
                尝试次数 = 0;
            }


            奖励物品.forEach(物品 => {
                放置物品到房间(物品, 房间, 单元格类型.物品, false, true);
            });
        }
        function 解谜成功(房间) {

            for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                    if (地牢[y][x].类型 === 单元格类型.物品 && 地牢[y][x].关联物品 instanceof 棋子) {
                        地牢[y][x].类型 = null;
                        地牢[y][x].关联物品 = null;
                    }
                }
            }
            生成奖励(房间);
            显示通知("解谜成功！获得了丰厚奖励！", "成功");
            绘制();
        }
        function 检查解谜是否成功(棋子数量) {
            const 当前房间ID = 房间地图[玩家.y][玩家.x];
            if (当前房间ID === -1) return false;

            const 当前房间 = 房间列表[当前房间ID];
            if (当前房间.类型 !== "解谜棋盘") return false;
            let 棋子现存数量 = 0;
            const 棋盘宽度 = 当前房间.w;
            const 棋盘高度 = 当前房间.h;
            const 棋盘 = Array(棋盘高度).fill(null).map(() => Array(棋盘宽度).fill(0));
            const 棋子列表 = [];


            for (let y = 当前房间.y; y < 当前房间.y + 当前房间.h; y++) {
                for (let x = 当前房间.x; x < 当前房间.x + 当前房间.w; x++) {
                    if (地牢[y][x].类型 === 单元格类型.物品 && 地牢[y][x].关联物品 instanceof 棋子) {
                        棋盘[y - 当前房间.y][x - 当前房间.x] = 地牢[y][x].关联物品;
                        棋子列表.push({ x: x - 当前房间.x, y: y - 当前房间.y, 棋子: 地牢[y][x].关联物品 });
                        棋子现存数量++;
                    }
                }
            }
            if (棋子现存数量 >= 棋子数量) {

                for (const 棋子信息 of 棋子列表) {
                    const 攻击位置 = 棋子信息.棋子.可攻击位置(棋子信息.x, 棋子信息.y, 棋盘);
                    for (const 其他棋子信息 of 棋子列表) {
                        if (棋子信息 === 其他棋子信息) continue;
                        if (攻击位置.some(pos => pos.x === 其他棋子信息.x && pos.y === 其他棋子信息.y)) {
                            return false;
                        }
                    }
                }


                解谜成功(当前房间);
                return true;
            }
            return false;
        }
        function 生成解谜棋盘(房间) {
            const 棋盘大小 = Math.min(房间.w, 房间.h);
            const 棋盘 = Array(棋盘大小).fill(null).map(() => Array(棋盘大小).fill(0));
            const 棋子种类 = {
                "A": [国际象棋车, 国际象棋象],
                "B": [国际象棋马, 中国象棋炮],
            };


            const 首个棋子层级 = Math.random() < 0.6 ? "A" : "B";
            const 首个棋子类 = 棋子种类[首个棋子层级][Math.floor(Math.random() * 棋子种类[首个棋子层级].length)];
            棋盘[0][0] = new 首个棋子类({});

            for (let y = 0; y < 棋盘大小; y++) {
                for (let x = 0; x < 棋盘大小; x++) {
                    if (x === 0 && y === 0) continue;
                    if (棋盘[y][x]) continue;

                    let 当前层级 = "A";
                    while (当前层级) {
                        const 可放置棋子 = [];
                        for (const 棋子类 of 棋子种类[当前层级]) {
                            if (可以放置(x, y, 棋子类, 棋盘)) {
                                可放置棋子.push(棋子类);
                            }
                        }

                        if (可放置棋子.length > 0) {

                            const 权重 = 可放置棋子.map(棋子类 => {
                                const 威胁数 = 计算新增威胁格子数(x, y, 棋子类, 棋盘);
                                return 1 / (威胁数 + 1);
                            });


                            const 最小权重 = Math.min(...权重);


                            if (当前层级 === "A") {
                                可放置棋子.push("下一层");
                                权重.push(最小权重);
                            }


                            const 总权重 = 权重.reduce((sum, w) => sum + w, 0);
                            let 随机数 = Math.random() * 总权重;
                            let 选中棋子类 = null;
                            for (let i = 0; i < 可放置棋子.length; i++) {
                                if (随机数 < 权重[i]) {
                                    选中棋子类 = 可放置棋子[i];
                                    break;
                                }
                                随机数 -= 权重[i];
                            }


                            if (选中棋子类) {
                                if (选中棋子类 === "下一层") {
                                    当前层级 = "B";
                                } else {
                                    棋盘[y][x] = new 选中棋子类({});
                                    break;
                                }
                            }
                        } else {

                            if (当前层级 === "A") {
                                当前层级 = "B";
                            } else {
                                break;
                            }
                        }
                    }
                }
            }
            const 棋子 = [];
            房间.棋子数量 = 0;
            for (let i = 0; i < 棋盘大小; i++) {
                for (let j = 0; j < 棋盘大小; j++) {
                    if (棋盘[j][i]) {
                        棋子.push(棋盘[j][i]);
                    }
                }
            }
            棋子.forEach(棋子 => {
                放置物品到房间(棋子, 房间);
                房间.棋子数量++;
            });
            return { 棋盘 };
        }

        function 可以放置(x, y, 棋子类, 棋盘) {
            if (棋盘[y][x]) return false;


            for (let i = 0; i < 棋盘.length; i++) {
                for (let j = 0; j < 棋盘[i].length; j++) {
                    const 已放置棋子 = 棋盘[j][i];
                    if (已放置棋子) {
                        const 攻击位置 = 已放置棋子.可攻击位置(i, j, 棋盘);
                        if (攻击位置.some(pos => pos.x === x && pos.y === y)) {
                            return false;
                        }
                    }
                }
            }


            const 临时棋盘 = 棋盘.map(row => row.map(cell => cell ? new (cell.constructor)() : null));
            临时棋盘[y][x] = new 棋子类();
            const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(x, y, 临时棋盘);
            for (let i = 0; i < 棋盘.length; i++) {
                for (let j = 0; j < 棋盘.length; j++) {
                    if (临时棋盘[j][i] && (i !== x || j !== y)) {
                        if (新棋子攻击位置.some(pos => pos.x === i && pos.y === j)) {
                            return false;
                        }
                    }
                }
            }


            for (let i = 0; i < 棋盘.length; i++) {
                for (let j = 0; j < 棋盘.length; j++) {
                    if (临时棋盘[j][i] instanceof 中国象棋炮) {
                        const 炮的攻击位置 = 临时棋盘[j][i].可攻击位置(i, j, 临时棋盘);
                        for (let m = 0; m < 棋盘.length; m++) {
                            for (let n = 0; n < 棋盘.length; n++) {
                                if (临时棋盘[n][m] && (m !== i || n !== j)) {
                                    if (炮的攻击位置.some(pos => pos.x === m && pos.y === n)) {
                                        return false;
                                    }

                                }
                            }
                        }
                    }
                }
            }
            return true;
        }


        function 计算新增威胁格子数(x, y, 棋子类, 棋盘) {
            const 临时棋盘 = 棋盘.map(row => row.map(cell => cell ? new (cell.constructor)() : null));
            临时棋盘[y][x] = new 棋子类();
            const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(x, y, 临时棋盘);

            let 新增威胁数 = 0;

            for (let i = 0; i < 棋盘.length; i++) {
                for (let j = 0; j < 棋盘[i].length; j++) {
                    if (临时棋盘[j][i] === null) {
                        if (新棋子攻击位置.some(pos => pos.x === i && pos.y === j) ||
                            !可以放置(i, j, 棋子类, 临时棋盘)) {
                            新增威胁数++;
                        }
                    }
                }
            }
            return 新增威胁数;
        }
        function 激活卷轴模式() {
            if (!卷轴模式激活) {
                const 装备卷轴 = [...玩家装备.values()].filter(
                    (i) => i instanceof 卷轴类
                );
                if (装备卷轴.length === 0) return;

                卷轴模式激活 = true;
                const 提示遮罩 = document.createElement("div");
                提示遮罩.style.cssText = `
                                                                    position: fixed;
                                                                    top: 0;
                                                                    left: 0;
                                                                    width: 100%;
                                                                    height: 100%;
                                                                    background: rgba(0,0,0,0.5);
                                                                    z-index: 9999;
                                                                    display: flex;
                                                                    align-items: center;
                                                                    justify-content: center;
                                                                    font-size: 2em;
                                                                    color: gold;
                                                                    pointer-events: none;
                                                                `;
                提示遮罩.innerHTML = "点击闪烁的卷轴装备槽使用！";
                //document.body.appendChild(提示遮罩);
                //有点烦人，删去...
                setTimeout(() => 提示遮罩.remove(), 1000);
                // 添加闪烁效果
                document.querySelectorAll(".装备槽").forEach((槽位) => {
                    const 物品 = 槽位.querySelector(".物品条目");
                    if (物品?.__物品实例 instanceof 卷轴类) {
                        物品.classList.add("卷轴闪烁");
                    }
                });
            } else {
                恢复卷轴模式();
                document.querySelectorAll(".装备槽").forEach((槽位) => {
                    const 物品 = 槽位.querySelector(".物品条目");
                    if (物品?.__物品实例 instanceof 卷轴类) {
                        if (当前激活卷轴列表.has(物品?.__物品实例)) {
                            物品.classList.add("卷轴闪烁");
                        }
                    }
                });
            }
        }

        function 恢复卷轴模式() {
            卷轴模式激活 = false;


            document
                .querySelectorAll(".装备槽")
                .forEach((槽位) => {
                    const 物品 =
                        槽位.querySelector(".物品条目");
                    if (物品?.__物品实例 instanceof 卷轴类) {
                        if (!当前激活卷轴列表.has(物品?.__物品实例)) {
                            物品.classList.remove("卷轴闪烁");
                        }
                    }
                });
        }
        function 显示通知(内容, 类型 = "信息", 强制显示 = false, 持续时间 = 1500) {
            添加日志(内容, 类型);
            if (!是否显示通知 && !强制显示) {
                return;
            }


            const 容器 = document.querySelector(".通知容器") || document.createElement("div");
            容器.className = "通知容器";


            const 当前通知列表 = 容器.querySelectorAll('.通知条目');
            if (当前通知列表.length >= 2) {

                const 可移除通知 = Array.from(当前通知列表).find(n =>
                    !n.classList.contains('持久')
                );
                if (可移除通知) 隐藏通知(可移除通知);
            }


            const 图标表 = {
                信息: "ℹ️",
                成功: 图标映射.成功,
                警告: "⚠️",
                错误: 图标映射.错误,
            };
            const 通知 = document.createElement("div");
            通知.className = `通知条目 ${类型} ${强制显示 ? '持久' : ''}`;
            通知.innerHTML = `
    <span class="通知图标">${图标表[类型]}</span>
    <span class="通知内容">${内容}</span>
    <button class="关闭按钮">×</button>
  `;


            通知.querySelector('.关闭按钮').addEventListener('click', () => {
                隐藏通知(通知);
                cancelAnimationFrame(通知._timer);
            });
            通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
            通知.addEventListener('mouseenter', () => clearTimeout(通知._timer));
            通知.addEventListener('mouseleave', () => {
                通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
            });

            if (!document.body.contains(容器)) document.body.appendChild(容器);
            容器.appendChild(通知);


            const 第一个通知 = 容器.firstElementChild;
            if (第一个通知) {
                const rect = 第一个通知.getBoundingClientRect();
                if (rect.bottom > window.innerHeight) {
                    容器.style.bottom = `${rect.height + 20}px`;
                }
            }
        }
        function 生成天气效果() {
            当前天气效果 = [];

            const 乱序天气列表 = [...所有天气列表].sort(() => Math.random() - 0.5);


            const 要选择的数量 = Math.random() < 0.5 ? 1 : Math.min(2, 乱序天气列表.length);

            当前天气效果 = 乱序天气列表.slice(0, 要选择的数量);


            if (当前天气效果.includes('深夜')) {
                显示通知("夜幕降临，周围变得一片漆黑...", "警告");
            }
            if (当前天气效果.includes('雷暴')) {
                显示通知("乌云密布，雷声滚滚...", "警告");
            }
            if (当前天气效果.includes('大风')) {
                显示通知("狂风呼啸，站稳脚跟！", "警告");
            }
            if (当前天气效果.includes('严寒')) {
                显示通知("严冬将至...", "警告");
            }
            if (当前天气效果.includes('诡魅')) {
                显示通知("空气中弥漫着诡异的气息，你的感知似乎受到了干扰...", "警告");

            }
        }
        function 处理诡魅房间刷新(旧玩家X, 旧玩家Y, 玩家X, 玩家Y) {
            const 旧视野房间ID集合 = 获取视野内房间ID(旧玩家X, 旧玩家Y);
            const 新视野房间ID集合 = 获取视野内房间ID(玩家X, 玩家Y);


            房间列表.forEach(房间 => {

                if (房间.类型 === "解谜棋盘" || 房间.类型 === "boss房间" ||
                    !已访问房间.has(房间.id) || 新视野房间ID集合.has(房间.id) || 房间.id === 0) {
                    return;
                }


                if (旧视野房间ID集合.has(房间.id)) {
                    刷新房间内容(房间);
                }
            });
        }


        function 获取视野内房间ID(中心X, 中心Y) {
            const 视野范围 = 获取玩家视野范围() + 2;
            const 房间ID集合 = new Set();
            const 检查范围 = 视野范围;

            for (let dy = -检查范围; dy <= 检查范围; dy++) {
                for (let dx = -检查范围; dx <= 检查范围; dx++) {
                    const 检查X = 中心X + dx;
                    const 检查Y = 中心Y + dy;

                    if (检查X >= 0 && 检查X < 地牢大小 && 检查Y >= 0 && 检查Y < 地牢大小) {
                        const 距离 = Math.abs(dx) + Math.abs(dy);
                        if (距离 <= 视野范围) {
                            const 房间ID = 房间地图[检查Y][检查X];
                            if (房间ID !== -1) {

                                房间ID集合.add(房间ID);

                            }
                        }
                    }
                }
            }
            return 房间ID集合;
        }


        function 刷新房间内容(房间) {
            添加日志(`房间 ${房间.id} 的气息变得混乱不清...`, "警告");
            已访问房间.delete(房间.id);


            for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                    const 单元格 = 地牢[y]?.[x];
                    if (!单元格) continue;


                    if (单元格.关联物品) {
                        const 物品实例 = 单元格.关联物品;

                        所有计时器 = 所有计时器.filter(计时器 => 计时器.唯一标识 !== 物品实例.唯一标识);

                        if (玩家背包.has(物品实例.唯一标识)) {
                            处理销毁物品(物品实例.唯一标识, true);
                        } else {

                        }
                        单元格.关联物品 = null;
                        单元格.类型 = 单元格.背景类型;
                        单元格.颜色索引 = 颜色表.length;
                    }


                    if (单元格.关联怪物) {
                        const 怪物实例 = 单元格.关联怪物;

                        所有怪物 = 所有怪物.filter(m => m !== 怪物实例);

                        怪物状态表.delete(怪物实例);

                        怪物实例.血条元素?.remove();
                        单元格.关联怪物 = null;

                    }
                }
            }





            const 怪物数量 = Math.floor(Math.random() * 3) + 1;
            const 候选怪物 = 怪物池["普通房间"].filter(m => 当前层数 >= m.最小层);
            if (候选怪物.length > 0) {
                for (let i = 0; i < 怪物数量; i++) {
                    const 总权重 = 候选怪物.reduce((sum, m) => sum + m.权重, 0);
                    let 随机值 = Math.random() * 总权重;
                    let 选中配置 = 候选怪物[0];
                    for (const m of 候选怪物) {
                        if (随机值 <= m.权重) { 选中配置 = m; break; }
                        随机值 -= m.权重;
                    }

                    let 放置成功 = false;
                    for (let 尝试 = 0; 尝试 < 10; 尝试++) {
                        const x = 房间.x + Math.floor(Math.random() * 房间.w);
                        const y = 房间.y + Math.floor(Math.random() * 房间.h);
                        if (位置是否可用(x, y, false)) {
                            const 新怪物 = new 选中配置.类({ x: x, y: y, 房间ID: 房间.id, 强化: Math.random() < 0.1 });
                            放置怪物到单元格(新怪物, x, y);
                            放置成功 = true;
                            break;
                        }
                    }
                }
            }


            if (Math.random() < 0.5) {
                const 数量 = Math.floor(Math.random() * (5 + 当前层数)) + 1;
                放置物品到房间(new 金币({ 数量: 数量 }), 房间);
            } else if (Math.random() < 0.3) {
                生成物品([房间]);
            }
        }
        function 隐藏通知(通知元素) {
            if (!通知元素 || !通知元素.parentElement) return;

            通知元素.classList.add('离场');
            通知元素.addEventListener('animationend', () => {
                通知元素.remove();

                const 容器 = document.querySelector(".通知容器");
                if (容器 && 容器.children.length === 0) {
                    容器.remove();
                }
            });
        }
        function 添加日志(内容, 类型 = "信息") {
            const 时间戳 = new Date().toLocaleTimeString();
            const 条目 = document.createElement("div");
            条目.className = `日志条目 ${类型}`;
            条目.innerHTML = `<span class="日志时间">[${时间戳}]</span> ${内容}`;

            document.getElementById("logContent").appendChild(条目);

            条目.scrollIntoView({ behavior: "smooth" });
            日志历史.push({ 时间戳, 内容, 类型 });
        }
        function 收纳通知() {
            是否显示通知 = !是否显示通知;
            let 按钮 = document.querySelector("#设置菜单 button:nth-child(3)");
            if (中文模式) 按钮 = document.querySelector("#设置菜单 button:nth-child(2)");
            if (是否显示通知) {
                按钮.innerHTML = "收纳通知";
                显示通知("已重新显示通知", "信息");
                按钮.textContent = "收纳通知";
            } else {
                按钮.innerHTML = "显示通知";
                显示通知("已将通知收纳入日志中", "信息");
                按钮.textContent = "显示通知";
            }
        }
        function 关闭重铸界面() {
            const 弹窗 = document.querySelector(".重铸弹窗");
            if (!弹窗) return;


            弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
            弹窗.style.opacity = 0;


            document.querySelectorAll(".重铸物品").forEach(el => {
                el.__物品实例 = null;
            });

            setTimeout(() => {
                弹窗.parentElement?.remove();
                更新背包显示();
                玩家属性.允许移动 = true;
            }, 300);
        }

        function 执行重铸() {
            const 源元素 = document.querySelector("#sourceItems .selected");
            const 材料元素 = document.querySelector("#materialItems .selected");


            const 源物品 = 源元素?.__物品实例;
            const 材料物品 = 材料元素?.__物品实例;

            if (!源物品 || !材料物品) {
                显示通知("需要选择两个有效装备", "错误");
                return;
            }
            if (源物品 === 材料物品) {
                显示通知("需要选择两个不同装备", "错误");
                return;
            }
            if (源物品.名称 !== 材料物品.名称) {
                显示通知("装备名称不一致", "错误");
                return;
            }

            const 当前耐久 = 源物品.自定义数据.get("耐久");
            const 最大耐久 = 源物品.自定义数据.get("原耐久");
            const 可用空间 = 最大耐久 - 当前耐久;
            const 可转移量 = Math.min(材料物品.自定义数据.get("耐久"), 可用空间);

            if (可转移量 <= 0) {
                显示通知(可用空间 <= 0 ? "目标已满耐久" : "材料无可用耐久", "错误");
                return;
            }
            const 消耗金币 = 当前重铸台.计算消耗(源物品, 材料物品);
            if (!扣除金币(消耗金币)) {
                显示通知("金币不足！", "错误");
                return false;
            }


            源物品.自定义数据.set("耐久", 当前耐久 + 可转移量);
            处理销毁物品(材料物品.唯一标识, true);


            const 剩余耐久 = 当前重铸台.自定义数据.get("耐久") - 1;
            当前重铸台.自定义数据.set("耐久", 剩余耐久);
            当前重铸台.效果描述 = `将同名装备的耐久融合\n剩余耐久：${剩余耐久}/${当前重铸台.自定义数据.get("最大耐久")}`;

            显示通知(`消耗 ${消耗金币} 金币成功修复！`, "成功");
            关闭重铸界面();
        }
        function 扣除金币(数量) {
            const 玩家金币 = [...玩家背包.values()]
                .filter(i => i instanceof 金币)
                .reduce((sum, i) => sum + i.堆叠数量, 0);

            if (玩家金币 < 数量) {
                return false;
            }
            const 金币列表 = [...玩家背包.values()].filter(i => i instanceof 金币);
            let 剩余扣除 = 数量;

            for (const 金币 of 金币列表) {
                const 扣除量 = Math.min(金币.堆叠数量, 剩余扣除);
                金币.堆叠数量 -= 扣除量;
                剩余扣除 -= 扣除量;
                if (金币.堆叠数量 === 0) {
                    处理销毁物品(金币.唯一标识, true);
                }
                if (剩余扣除 === 0) break;
            }

            return 剩余扣除 === 0;
        }

        function 触发扣血特效() {
            const 特效 = document.getElementById("扣血特效");
            特效.style.animation = "none";
            特效.offsetHeight;
            特效.style.animation = "扣血脉冲 0.8s ease-out";
        }

        let 指示器缓存 = new Map();

        function 计算精确边缘位置(怪物) {
            const 画布 = document.getElementById("dungeonCanvas");
            const 画布Rect = 画布.getBoundingClientRect();


            const 视口左边界 = 当前相机X;
            const 视口右边界 =
                当前相机X + Math.floor(画布Rect.width / 单元格大小) - 1;
            const 视口上边界 = 当前相机Y;
            const 视口下边界 =
                当前相机Y + Math.floor(画布Rect.height / 单元格大小) - 1;


            if (
                怪物.x >= 视口左边界 &&
                怪物.x <= 视口右边界 &&
                怪物.y >= 视口上边界 &&
                怪物.y <= 视口下边界
            ) {
                return null;
            }

            const 玩家像素X =
                (玩家.x - 当前相机X) * 单元格大小 + 单元格大小 / 2;
            const 玩家像素Y =
                (玩家.y - 当前相机Y) * 单元格大小 + 单元格大小 / 2;

            const dx =
                (怪物.x - 当前相机X) * 单元格大小 +
                单元格大小 / 2 -
                玩家像素X;
            const dy =
                (怪物.y - 当前相机Y) * 单元格大小 +
                单元格大小 / 2 -
                玩家像素Y;

            // 计算射线方向向量
            const 方向长度 = Math.sqrt(dx * dx + dy * dy);
            if (方向长度 === 0) return null;
            const dirX = dx / 方向长度;
            const dirY = dy / 方向长度;

            // 计算与画布边界的交点（使用视口实际尺寸）
            const 画布左 = 0;
            const 画布右 = 画布Rect.width;
            const 画布上 = 0;
            const 画布下 = 画布Rect.height;

            let t = Infinity;

            if (dirX < 0) {
                const tLeft = (画布左 - 玩家像素X) / dirX;
                const y = 玩家像素Y + dirY * tLeft;
                if (y >= 画布上 && y <= 画布下) t = tLeft;
            }

            if (dirX > 0) {
                const tRight = (画布右 - 玩家像素X) / dirX;
                const y = 玩家像素Y + dirY * tRight;
                if (y >= 画布上 && y <= 画布下) t = Math.min(t, tRight);
            }

            if (dirY < 0) {
                const tTop = (画布上 - 玩家像素Y) / dirY;
                const x = 玩家像素X + dirX * tTop;
                if (x >= 画布左 && x <= 画布右) t = Math.min(t, tTop);
            }

            if (dirY > 0) {
                const tBottom = (画布下 - 玩家像素Y) / dirY;
                const x = 玩家像素X + dirX * tBottom;
                if (x >= 画布左 && x <= 画布右) t = Math.min(t, tBottom);
            }

            if (t === Infinity) return null;

            // 计算最终交点位置（页面坐标）
            return {
                x: 玩家像素X + dirX * t + 画布Rect.left,
                y: 玩家像素Y + dirY * t + 画布Rect.top,
            };
        }

        function 更新物体指示器() {
            const 容器 = document.getElementById("怪物指示器容器");
            const 可见怪物 = new Set();

            所有怪物.forEach((怪物, index) => {
                if (怪物.状态 !== 怪物状态.活跃) return;
                if (!怪物.追击玩家中) return;

                // 计算精确位置，其内部会处理怪物不可见情况
                const 位置 = 计算精确边缘位置(怪物);
                if (!位置) {
                    if (指示器缓存.has(index))
                        指示器缓存.get(index).remove();
                    return;
                }

                // 创建/更新指示器
                let 指示器 = 指示器缓存.get(index);
                if (!指示器) {
                    指示器 = document.createElement("div");
                    指示器.className = "怪物指示器";
                    容器.appendChild(指示器);
                    指示器缓存.set(index, 指示器);
                }

                指示器.style.transform = `translate(${位置.x}px, ${位置.y}px)`;
                可见怪物.add(index);
            });

            // 清理不可见指示器
            指示器缓存.forEach((指示器, key) => {
                if (!可见怪物.has(key)) {
                    指示器.remove();
                    指示器缓存.delete(key);
                }
            });
            const 玩家寻宝戒指列表 = [...玩家装备.values()].filter(item => item instanceof 寻宝戒指);
            let 玩家寻宝戒指 = null;
            if (玩家寻宝戒指列表) {
                玩家寻宝戒指 = 玩家寻宝戒指列表.find(item => item.自定义数据.get("生效层数") === 当前层数);
            } else {
                const 指示器 = document.querySelector(".折跃门指示器");
                if (指示器) {
                    指示器.style.display = "none"; // 隐藏
                }
            }
            if (玩家寻宝戒指) {
                const 折跃门位置 = 玩家寻宝戒指.自定义数据.get("折跃门位置");
                if (折跃门位置) {
                    const 屏幕位置 = 计算精确边缘位置({ x: 折跃门位置.x, y: 折跃门位置.y });

                    let 指示器 = document.querySelector(".折跃门指示器");
                    if (!指示器) {
                        指示器 = document.createElement("div");
                        指示器.className = "怪物指示器 折跃门指示器"; // 添加额外的类名
                        指示器.style.background = 'gold';
                        指示器.style.boxShadow = "0 0 8px gold";
                        容器.appendChild(指示器);
                    }
                    if (屏幕位置) {
                        指示器.style.transform = `translate(${屏幕位置.x}px, ${屏幕位置.y}px)`;
                        指示器.style.display = "block"; // 确保显示
                    } else {
                        指示器.style.display = "none"; // 隐藏
                    }
                } else {
                    const 指示器 = document.querySelector(".折跃门指示器");
                    if (指示器) {
                        指示器.style.display = "none"; // 隐藏
                    }
                }
            } else {
                const 指示器 = document.querySelector(".折跃门指示器");
                if (指示器) {
                    指示器.style.display = "none"; // 隐藏
                }
            }
        }
        function hexToRgba(hex, alpha) {
            let r = parseInt(hex.slice(0, 2), 16),
                g = parseInt(hex.slice(2, 4), 16),
                b = parseInt(hex.slice(4, 6), 16);

            if (alpha) {
                return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
            } else {
                return "rgb(" + r + ", " + g + ", " + b + ")";
            }
        }
        // Hex转RGB
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                (num >> 16) & 0xff,
                (num >> 8) & 0xff,
                num & 0xff
            ];
        }
        function blendColors(hexArray) {
            if (hexArray.length === 0) return '#000000'; // 处理空数组情况



            // RGB转HSL
            function rgbToHsl(r, g, b) {
                r /= 255, g /= 255, b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h *= 60;
                }
                return [h, s, l];
            }

            // HSL转RGB
            function hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l; // 灰色
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h / 360 + 1 / 3);
                    g = hue2rgb(p, q, h / 360);
                    b = hue2rgb(p, q, h / 360 - 1 / 3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            // RGB转Hex
            function rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }

            // 处理每个Hex颜色
            const hslArray = hexArray.map(hex => {
                const [r, g, b] = hexToRgb(hex);
                return rgbToHsl(r, g, b);
            });

            // 计算平均H（向量平均）
            let sumSin = 0, sumCos = 0;
            for (const [h] of hslArray) {
                const radians = (h * Math.PI) / 180;
                sumSin += Math.sin(radians);
                sumCos += Math.cos(radians);
            }
            const avgH = (Math.atan2(sumSin / hexArray.length, sumCos / hexArray.length) * 180) / Math.PI;
            const normalizedH = (avgH + 360) % 360; // 确保在0-360度之间

            // 计算平均S和L
            const avgS = hslArray.reduce((sum, [, s]) => sum + s, 0) / hexArray.length;
            const avgL = hslArray.reduce((sum, [, , l]) => sum + l, 0) / hexArray.length;

            // 转换回RGB并转为Hex
            const [r, g, b] = hslToRgb(normalizedH, avgS, avgL);
            return rgbToHex(r, g, b);
        }
        function 打开收购窗口(npc) {
            if (界面可见性.背包) 切换背包显示();
            玩家属性.允许移动 = false;
            NPC互动中 = true; // 标记互动中
            当前NPC = npc; // 保存当前NPC引用

            const 窗口 = document.getElementById("收购窗口");
            const 需求列表容器 = document.getElementById("收购需求列表");
            const 玩家列表容器 = document.getElementById("玩家可售列表");
            const 金币显示 = document.getElementById("收购窗口金币");

            需求列表容器.innerHTML = "";
            玩家列表容器.innerHTML = "";

            金币显示.textContent = [...玩家背包.values()]
                .filter(i => i instanceof 金币)
                .reduce((sum, i) => sum + i.堆叠数量, 0);

            // 显示收购需求
            const 需求 = npc.自定义数据.get('收购需求') || [];
            需求.forEach(req => {
                const 元素 = document.createElement("div");
                元素.className = "收购需求条目";
                元素.innerHTML = `
                     <span class="需求图标" style="color:${物品池[Object.keys(物品池).find(key => 物品池[key].some(item => item.类.name === req.类名))]?.find(item => item.类.name === req.类名)?.类?.prototype?.颜色表?.[req.颜色索引] ?? '#FFF'}">${req.图标}</span>
                     <span class="需求名称">${req.名称}${req.强化需求 ? ' [强]' : ''} </span>
                     <span class="需求价格">??? 金币</span> <!-- 价格在点击玩家物品时计算 -->
                 `;
                需求列表容器.appendChild(元素);
            });

            // 显示玩家可出售物品
            玩家背包.forEach(item => {
                // 检查是否满足任一收购需求
                const 匹配需求 = 需求.find(req =>
                    item.名称 === req.名称 &&
                    (req.强化需求 ? item.强化 === true : true) // 强化需求匹配
                );

                if (匹配需求) {
                    const 价格 = npc.计算收购价格(item, 匹配需求);
                    if (价格 > 0) { // 价格为0表示不满足强化需求等硬性条件
                        const 元素 = document.createElement("div");
                        元素.className = "玩家可售条目";
                        元素.innerHTML = `
                            <span class="物品图标" style="color:${item.颜色表[item.颜色索引] ?? '#FFF'}">${item.图标}</span>
                            <span class="物品名称">${item.获取名称()} ${item.堆叠数量 > 1 ? `x${item.堆叠数量}` : ''}</span>
                            <span class="出售价格">${价格} 金币</span>
                        `;
                        元素.onclick = () => 尝试出售(item, 价格, npc);
                        玩家列表容器.appendChild(元素);
                    }
                }
            });

            窗口.style.display = "flex"; // 使用 flex 以便内部布局生效
        }

        function 关闭收购窗口() {
            const 窗口 = document.getElementById("收购窗口");
            窗口.classList.add("关闭中");
            setTimeout(() => {
                窗口.style.display = "none";
                窗口.classList.remove("关闭中");
                玩家属性.允许移动 = true;
            }, 300);
            NPC互动中 = false; // 结束互动
            当前NPC = null;

        }

        function 尝试出售(物品实例, 价格, npc) {
            if (npc.自定义数据.get('交易次数') <= 0) {
                显示通知("探险家已经不想再收购了。", "警告");
                关闭收购窗口();
                return;
            }

            // 1. 预计算出售后的背包容量变化
            let 潜在空格子 = 0;
            if (物品实例.堆叠数量 === 1) {
                潜在空格子 = 1; // 如果物品完全移除，会空出一个格子
            }
            const 当前物品数量 = [...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0);
            const 预计出售后物品数量 = 当前物品数量 - 潜在空格子;

            // 2. 检查是否有足够的空间放金币
            const 金币实例 = [...玩家背包.values()].find(i => i instanceof 金币);
            let 需要的金币格子 = 0;
            if (金币实例) {
                const 可堆叠空间 = 最大堆叠数 - 金币实例.堆叠数量;
                const 剩余金币 = 价格 - Math.min(价格, 可堆叠空间);
                if (剩余金币 > 0) {
                    需要的金币格子 = Math.ceil(剩余金币 / 最大堆叠数); // 计算需要多少个新格子放剩余金币
                }
            } else {
                需要的金币格子 = Math.ceil(价格 / 最大堆叠数); // 没有金币实例，计算需要多少新格子
            }

            // 比较预计的背包占用和最大容量
            if (预计出售后物品数量 + 需要的金币格子 > 最大背包容量) {
                显示通知("背包空间不足，无法完成交易！", "错误");
                return; // 出售失败
            }
            if (物品实例.堆叠数量 > 1) {
                物品实例.堆叠数量 -= 1;
            } else {
                玩家背包.delete(物品实例.唯一标识);
                if (物品实例.已装备) {
                    玩家装备.delete(物品实例.装备槽位);
                    物品实例.已装备 = false;
                    物品实例.装备槽位 = null;
                }
            }


            尝试收集物品(new 金币({ 数量: 价格 }), true); // 直接收集


            npc.自定义数据.set('交易次数', npc.自定义数据.get('交易次数') - 1);

            // 6. 刷新收购窗口内容
            打开收购窗口(npc); // 重新打开以刷新列表和金币

            // 7. 更新UI
            更新背包显示();
            更新装备显示();
            显示通知(`成功出售 ${物品实例.名称}，获得 ${价格} 金币！`, "成功");

            // 8. 如果交易次数用完，自动关闭窗口
            if (npc.自定义数据.get('交易次数') <= 0) {
                显示通知("探险家满意地离开了。", "信息");
                关闭收购窗口();
            }
        }
        function 打开交易窗口(npc) {
            if (npc.自定义数据.get("刷新次数") === 0) {
                显示通知("货物已告罄", "信息");
                return;
            }
            玩家属性.允许移动 = false;
            当前NPC = npc;
            const 窗口 = document.getElementById("交易窗口");
            窗口.querySelector("#交易次数").textContent = npc.自定义数据.get("刷新次数");
            窗口.querySelector("#当前金币").textContent = [...玩家背包.values()]
                .filter((i) => i instanceof 金币)
                .reduce((sum, i) => sum + i.堆叠数量, 0);

            const 库存容器 = 窗口.querySelector(".库存列表");
            库存容器.innerHTML = "";

            npc.自定义数据.get("库存").forEach(物品 => {
                const 元素 = document.createElement("div");
                元素.className = "交易物品条目";
                元素.innerHTML = `
            <div class="物品头">
                <span style="color:${物品.颜色表[物品.颜色索引]}; font-family: color-emoji">${物品.图标}</span>
                ${物品.获取名称()}
                <span class="物品价格">${npc.获取价格(物品)} 金币</span>
            </div>
            <div class="物品描述">${物品.效果描述 || "神秘物品"}</div>
        `;

                元素.addEventListener("click", () => 尝试购买(物品));
                库存容器.appendChild(元素);
            });

            窗口.style.display = "block";
            窗口.classList.remove("关闭中");
            document.body.appendChild(窗口);
        }

        function 尝试购买(物品) {
            const npc = 当前NPC;
            const 价格 = npc.获取价格(物品);
            const 金币列表 = [...玩家背包.values()].filter((i) => i instanceof 金币);
            const 总金币 = 金币列表.reduce((sum, i) => sum + i.堆叠数量, 0);

            if (总金币 < 价格) {
                显示通知("金币不足！", "错误");
                return;
            }
            // 添加物品
            if (物品.类型 === "NPC" && !彩蛋2触发) {
                显示通知("就是你小子在酒吧里点了一个酒吧!?", "信息", true);
                彩蛋2触发 = true;
            }
            const 新物品 = 克隆物品(物品);
            if (!尝试收集物品(新物品, true)) { //注意：如果购买物品数量多，则会出现部分成功收集并返回false的情况
                return;
            }

            if (!扣除金币(价格)) {
                显示通知("金币不足！", "错误");
                return;
            }

            // 更新NPC状态
            npc.自定义数据.set("刷新次数", npc.自定义数据.get("刷新次数") - 1);

            更新背包显示();
            显示通知(`购买 ${物品.名称} 成功！`, "成功");
            关闭交易窗口();
        }

        function 关闭交易窗口() {
            document.getElementById("交易窗口").classList.add("关闭中");
            setTimeout(() => {
                document.getElementById("交易窗口").style.display = "none";
                玩家属性.允许移动 = true;
            }, 700);

            当前NPC = null;
            NPC互动中 = false;
        }

        function 进入教程层() {
            是否为教程层 = true;
            教程阶段 = 0;
            教程提示已显示 = false;
            document.getElementById("跳过教程按钮").style.display = "block";
            生成教程地牢();
            setTimeout(() => {
                显示教程提示();
            }, 200);
            // 确保其他 UI 元素正确显示或隐藏
            更新物体指示器();
            所有怪物.forEach((m) => { m.绘制血条(); });
            绘制();
        }

        function 跳过教程() {
            是否为教程层 = false;
            document.getElementById("跳过教程按钮").style.display = "none";
            所有怪物.forEach((m) => {
                m.绘制血条(true);
                if (地牢[m.y] && 地牢[m.y][m.x]) 地牢[m.y][m.x].关联怪物 = null;
            }); // 隐藏教程层怪物血条
            所有怪物 = [];
            重置玩家状态();
            最高教程阶段 = 6; // 跳过后默认解锁所有教程阶段以供回放（如果需要）
            切换楼层(0); // 切换到正常地牢的第 0 层
        }

        function 重置玩家状态() {
            最大背包容量 = 12;
            玩家背包.clear();
            玩家装备.clear();
            玩家状态.forEach((m) => {
                m.移除状态();
            });
            玩家状态 = [];
            // 重置 HUD
            document.querySelector(".health-bar").style.width = "100%";
            document.querySelector(".power-bar").style.width = "100%";
            document.getElementById("卷轴按钮").style.display = [
                ...玩家装备.values(),
            ].some((item) => item.类型 === "卷轴")
                ? "flex"
                : "none";
            更新装备显示();
            更新背包显示();
        }

        function 生成教程地牢() {
            地牢 = Array(地牢大小).fill().map((_, y) => Array(地牢大小).fill().map((_, x) => new 单元格(x, y)));
            房间列表 = [];
            上锁房间列表 = [];
            所有怪物 = [];
            门实例列表 = new Map();
            房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
            已访问房间 = new Set();

            const 教程房间配置 = [
                { x: 10, y: 10, w: 7, h: 5, id: 0, 门: [] },  // 初始房间：移动教学
                { x: 20, y: 10, w: 7, h: 5, id: 1, 门: [] },  // 背包、装备教学：钢制长剑
                { x: 30, y: 10, w: 7, h: 5, id: 2, 门: [] },  // 战斗、HUD、互动教学：普通怪物
                { x: 40, y: 10, w: 7, h: 5, id: 3, 门: [] },  // 上锁房间、药水、强化：上锁的门，房间内有狂暴药水
                { x: 50, y: 10, w: 7, h: 5, id: 4, 门: [] },  // 卷轴、冰冻怪物：冰冻怪物，清净卷轴（未鉴定）
                { x: 60, y: 10, w: 7, h: 5, id: 5, 门: [] }, // 新物品：商人、祭坛、宠物
                { x: 70, y: 10, w: 7, h: 5, id: 6, 门: [] },  // 下楼
            ];

            for (const 房间配置 of 教程房间配置) {
                房间列表.push(房间配置);
                放置房间(房间配置);
            }


            for (let i = 0; i < 房间列表.length - 1; i++) {
                let 路径 = 连接房间(房间列表[i], 房间列表[i + 1]);
                if (路径) {
                    生成走廊(路径);
                }
            }
            生成墙壁();


            const 颜色索引 = 3 % 颜色表.length;
            房间列表[3].门.forEach((门) => {
                const 单元格 = 地牢[门.y][门.x];
                门实例列表.get(单元格.标识).类型 = "上锁的门";
                if (单元格.背景类型 === 单元格类型.门) {
                    单元格.背景类型 = 单元格类型.上锁的门;
                    单元格.钥匙ID = 房间列表[3].id;
                    单元格.颜色索引 = 颜色索引;
                }
            });
            上锁房间列表.push({ ...房间列表[3], 颜色索引 });


            const 第一个房间 = 房间列表[0];
            玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
            玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
            玩家.x = 玩家初始位置.x;
            玩家.y = 玩家初始位置.y;
            已访问房间.add(第一个房间.id);


            放置物品到房间(new 钢制长剑({ 不可破坏: true }), 房间列表[1]);
            放置怪物到单元格(new 怪物({ 掉落概率: 1, 基础攻击力: 1, 基础生命值: 15, 掉落物: new 钥匙({ 对应门ID: 上锁房间列表[0].id, 颜色索引: 上锁房间列表[0].颜色索引, 地牢层数: -1, }) }), 房间列表[2].x + 3, 房间列表[2].y + 2);

            放置怪物到单元格(new 怪物({ 基础攻击力: 1, 基础生命值: 15, 强化: true, 掉落物: new 金币({ 数量: 64 }) }), 房间列表[3].x + 3, 房间列表[3].y + 2);
            放置物品到房间(new 清净卷轴({ 已解锁: false, 强化: true }), 房间列表[3]);
            放置物品到房间(new 狂暴药水({ 强化: true }), 房间列表[3]);


            放置怪物到单元格(new 冰冻怪物({ 基础攻击力: 3, 基础生命值: 45, 掉落物: new 冰盾({}), 掉落概率: 1 }), 房间列表[4].x + 2, 房间列表[4].y + 2);
            放置物品到房间(new 神秘商人({}), 房间列表[5]);
            放置物品到房间(new 物品祭坛({}), 房间列表[5]);
            放置物品到房间(new 宠物({}), 房间列表[5]);
            //生成解谜棋盘(房间列表[1]);
            //房间列表[1].类型 = "解谜棋盘"
            放置楼梯(房间列表[房间列表.length - 1], 楼梯图标.下楼, 单元格类型.楼梯下楼);
            房间列表.forEach((房间) => 更新房间墙壁(房间));
            更新视口();
            绘制();
        }
        function 显示教程提示(强制 = false) {
            if (教程提示已显示 && !强制) return;

            const 提示窗口 = document.getElementById("教程提示窗口");
            const 提示内容元素 = document.getElementById("教程提示内容");


            if (教程阶段 > 最高教程阶段) {
                最高教程阶段 = 教程阶段;
            }

            let 提示文本 = 获取教程文本(教程阶段);

            if (提示文本 === "未知教程阶段") {
                提示窗口.style.display = "none";
                return;
            }

            提示内容元素.innerHTML = 提示文本;
            提示窗口.style.display = "block";
            教程提示已显示 = true;
        }


        function 打开教程回放窗口() {
            if (教程提示已显示) 关闭教程提示();
            const 回放窗口 = document.getElementById("教程回放窗口");
            当前回放阶段 = 0;
            显示回放教程页(当前回放阶段);
            回放窗口.style.display = "block";
            玩家属性.允许移动 = false;


            document.getElementById("上一页教程按钮").onclick = () => {
                if (当前回放阶段 > 0) {
                    当前回放阶段 = 获取上一个有效阶段(当前回放阶段);
                    显示回放教程页(当前回放阶段);
                }
            };
            document.getElementById("下一页教程按钮").onclick = () => {
                const 下一阶段 = 获取下一个有效阶段(当前回放阶段);
                if (下一阶段 !== null && 下一阶段 <= 最高教程阶段) {
                    当前回放阶段 = 下一阶段;
                    显示回放教程页(当前回放阶段);
                }
            };
        }

        function 获取上一个有效阶段(当前阶段) {
            let 上一阶段 = 当前阶段;
            do {
                if (上一阶段 === 2.5) 上一阶段 = 2;
                else 上一阶段 = Math.floor(上一阶段 - 1);
            } while (上一阶段 > 0 && 获取教程文本(上一阶段) === "未知教程阶段");
            return Math.max(0, 上一阶段);
        }


        function 获取下一个有效阶段(当前阶段) {
            let 下一阶段 = 当前阶段;
            do {
                if (下一阶段 === 2) 下一阶段 = 2.5;
                else 下一阶段 = Math.ceil(下一阶段 + 1);
            } while (获取教程文本(下一阶段) === "未知教程阶段" && 下一阶段 <= 6); // 假设最大阶段是6

            return 下一阶段 <= 6 ? 下一阶段 : null; // 如果超过最大阶段，返回null
        }

        function 显示回放教程页(阶段) {
            const 内容元素 = document.getElementById("教程回放内容");
            const 页码元素 = document.getElementById("教程页码");
            const 上一页按钮 = document.getElementById("上一页教程按钮");
            const 下一页按钮 = document.getElementById("下一页教程按钮");

            内容元素.innerHTML = 获取教程文本(阶段);


            let 当前页码 = 1;
            let 总页数 = 1;
            let temp阶段 = 0;
            while (temp阶段 < 最高教程阶段) {
                const 下一阶段 = 获取下一个有效阶段(temp阶段);
                if (下一阶段 === null || 下一阶段 > 最高教程阶段) break;
                总页数++;
                if (下一阶段 <= 阶段) 当前页码++;
                temp阶段 = 下一阶段;
            }


            页码元素.textContent = `${当前页码} / ${总页数}`;


            上一页按钮.disabled = (阶段 <= 0);
            const 下一阶段 = 获取下一个有效阶段(阶段);
            下一页按钮.disabled = (下一阶段 === null || 下一阶段 > 最高教程阶段);
        }


        function 关闭教程回放窗口() {
            const 回放窗口 = document.getElementById("教程回放窗口");
            回放窗口.classList.add("关闭中"); // 复用关闭动画类
            setTimeout(() => {
                回放窗口.style.display = "none";
                回放窗口.classList.remove("关闭中");
            }, 300);
            玩家属性.允许移动 = true;
        }
        function 获取教程文本(阶段) {
            let 提示文本 = "";
            const isMobile = window.innerWidth < 769;

            switch (阶段) {
                case 0:
                    提示文本 = isMobile ? `欢迎来到中文地牢！<br>
                <b>基础移动：</b><br>
                - 长按方向键可以连续移动。<br>
                - 直接点击地图上的目标位置，角色会自动寻路。<br>
                <br>
                <b>注意：</b>长按移动会忽略攻击和互动，适合快速探索。<br>
                <b>兼容模式:</b>如果 emoji 无法显示，可以点击设置按钮⚙️再点击'切换为中文模式'按钮` :
                        `欢迎来到中文地牢！<br>
                <b>基础移动：</b><br>
                - 使用 W (上)、A (左)、S (下)、D (右) 键 或 ↑↓←→ 方向键移动。<br>
                - 直接点击地图上的目标位置，角色会自动寻路。<br>
                <br>
                <b>兼容模式:</b>如果 emoji 无法显示，可以按 - 键切换成汉字模式`;
                    break;
                case 1:
                    提示文本 = isMobile ? `<b>背包与装备：</b><br>
                - 打开背包：点击屏幕下方的背包图标 ${图标映射.背包按钮}。<br>
                - 背包功能：<br>
                    - 点击物品：使用、丢弃或装备物品。丢弃的物品按互动键可以捡回。<br>
                    - 装备武器：点击武器，再点击“装备”按钮（${图标映射.装备按钮}）。<br>
                   
                - 装备栏 (屏幕右下角的“田”字格)：<br>
                    - 单击装备槽内物品以使用，长按卸下<br>
                请尝试打开背包，装备上你找到的钢制长剑。` :
                        `<b>背包与装备：</b><br>
                - 打开背包：按 E 键。<br>
                - 背包功能：<br>
                    - 点击物品：使用、丢弃或装备物品。丢弃的物品按互动键可以捡回。<br>
                    - 装备武器：点击武器，再点击“装备”按钮（${图标映射.装备按钮}）。<br>
                  
                - 装备栏 (屏幕右下角的“田”字格)：<br>
                    - 使用数字键 1-4 使用对应槽位物品，右键卸下。<br>
                请尝试打开背包，装备上你找到的钢制长剑。`;
                    break;
                case 2: // 进入房间时的提示
                    提示文本 = isMobile ? `<b>战斗与HUD：</b><br>
                - HUD（屏幕左上角）：<br>
                     - 显示/隐藏：点击眼睛图标 ${图标映射.HUD智能} 按钮。<br>
                    - ❤️ 生命条：显示你的生命值。<br>
                    - ⚡ 能量条：显示你的能量值（使用卷轴等特殊物品会消耗）。<br>
                - 武器有冷却时间与耐久，耐久即将耗尽时可以停止使用，后续等待机会修补<br>
                <b>战斗：</b><br>
                - 靠近怪物，使用已装备的武器攻击它（点击装备栏中武器）。<br>
                - 击败怪物可获得战利品。<br>` :
                        `<b>战斗与HUD：</b><br>
                - HUD（屏幕左上角）：<br>
                    - 显示/隐藏：按 Q 键。<br>
                    - ❤️ 生命条：显示你的生命值。<br>
                    - ⚡ 能量条：显示你的能量值（使用卷轴等特殊物品会消耗）。<br>
                 - 武器有冷却时间与耐久，耐久即将耗尽时可以停止使用，后续等待机会修补<br>
                <b>战斗：</b><br>
                - 靠近怪物，使用已装备的武器攻击它（按对应数字键）。<br>
                - 击败怪物可获得战利品。<br>`;
                    break;

                case 2.5: // 击败怪物后的提示
                    提示文本 = isMobile ? `<b>互动：</b><br>
                - 点击屏幕下方的互动按钮 ${图标映射.互动按钮}。<br>
                - 互动功能：<br>
                    - 拾取周围的物品（直接走到物品的格子上也可以拾取）。<br>
                    - 打开上锁的门（需要拥有对应颜色的钥匙）。<br>
                    - 与 NPC、祭坛等互动。<br>
                    - 自动选择武器并攻击范围内的敌人。<br>
                 <b>提示：</b>掉落的钥匙有光晕，门的颜色和钥匙发出的光晕的颜色要一致才能解锁。<br>
                 请使用互动键拾取钥匙,并尝试打开下一道门.` :
                        `<b>互动：</b><br>
                - 按 F 键。<br>
                - 互动功能：<br>
                    - 拾取周围的物品（直接走到物品的格子上也可以拾取）。<br>
                    - 打开上锁的门（需要拥有对应颜色的钥匙）。<br>
                    - 与 NPC、祭坛等互动。<br>
                    - 自动选择武器并攻击范围内的敌人。<br>
                <b>提示：</b>掉落的钥匙有光晕，门的颜色和钥匙发出的光晕的颜色要一致才能解锁。<br>
                 请使用互动键拾取钥匙,并尝试打开下一道门.`;
                    break;
                case 3:
                    提示文本 = `你成功打开了上锁的房间！<br>
                <b>强化物品：</b><br>
                - 上锁房间内通常有更高品质的物品，它们带有强化效果，属性更强。<br>
                - 注意：怪物也会被强化！<br>
                <br>
                <b>药水：</b><br>
                - 药水有持续时间，效果会在一定回合后消失。<br>
                - 在关键时候打开背包使用药水,它可以救你一命！`;
                    break;
                case 4:
                    提示文本 = isMobile ? `<b>卷轴与能量：</b><br>
                - 卷轴是强大的消耗品，但使用需要消耗能量，能量条在左上角的HUD中显示，并随玩家移动恢复。<br>
                - 卷轴使用方法：<br>
                    1. 装备：打开背包(${图标映射.背包按钮})，点击卷轴，再点击“装备”按钮(${图标映射.装备按钮})。<br>
                    2. 激活：点击屏幕下方的卷轴图标 ${图标映射.卷轴按钮} 按钮,再点击装备栏中高亮的卷轴。<br>
                - 你获得的清净卷轴可以移除自身的所有状态效果。<br>
                - 卷轴需要使用特殊卷轴解读后才能知道效果。<br>
                - 激活后再点击装备槽中高亮的卷轴可以取消激活` :
                        `<b>卷轴与能量：</b><br>
                - 卷轴是强大的消耗品，但使用需要消耗能量，能量条在左上角的HUD中显示。玩家移动/探索房间/击杀怪物均可恢复能量，但是只依靠玩家移动恢复能量是不可取的。<br>
                - 卷轴使用方法：<br>
                    1. 装备：打开背包(E)，点击卷轴，再点击“装备”按钮(${图标映射.装备按钮})。<br>
                    2. 激活：按 R 键。<br>
                 - 你获得的清净卷轴可以移除自身的所有状态效果。<br>
                - 卷轴需要使用特殊卷轴解读后才能知道效果。<br>
                - 激活后再点击装备槽中高亮的卷轴可以取消激活`;
                    break;

                case 5:
                    提示文本 = `<b>探索更多：</b><br>
               这个房间里有一些特殊的物品，为你展示地牢物品的多样。<br>
                如果背包已满，你可以尝试丢掉一些物品或将它们装备给宠物。<br>
                如果装备槽已满，长按或右键已装备物品可以将其卸下<br>
                遇到未知物品尝试与其互动 或 拾起后在背包中使用。`;
                    break;
                case 6:
                    提示文本 = isMobile ? `<b>开始游戏：</b><br>
                点击设置⚙️可以打开功能菜单<br>
                - 地牢有很多层，每层都有不同的怪物和宝藏。<br>
                - 找到并走下楼梯 ${图标映射.下楼楼梯} 即可进入下一层，开始你的冒险！` :
                        `<b>开始游戏：</b><br>
                按 G 键可以打开日志界面。<br>
                按 Z 键可以导出存档。<br>
                - 地牢有很多层，每层都有不同的怪物和宝藏。<br>
                - 找到并走下楼梯 ${图标映射.下楼楼梯} 即可进入下一层，开始你的冒险！`;
                    break;
                default:
                    提示文本 = "未知教程阶段"; // 或者返回空字符串
            }
            return 提示文本;
        }
        function 关闭教程提示() {
            const 提示窗口 = document.getElementById("教程提示窗口");
            if (提示窗口) {
                提示窗口.classList.add("关闭中");
                教程提示已显示 = false;
                setTimeout(() => {
                    提示窗口.style.display = "none";
                    提示窗口.classList.remove("关闭中");
                }, 300);
            }
        }

        const 安全参数 = {
            方程组: [{
                a: 7,
                b: 3,
                c: 2,
                d: 5
            },
            {
                a: 4,
                b: 9,
                c: 6,
                d: 8
            }
            ],
            模数: 9973
        }

        function 生成死亡凭证(L) {
            let R;
            do {
                // R ≡ (L^2 + 1) mod 13
                const 基础值 = (L * L + 1) % 13;
                R = 基础值 + Math.floor(Math.random() * (安全参数.模数 - 基础值)) * 13;
            } while (R >= 安全参数.模数 || R === 0);


            const 方程计算 = (系数, L, R) => {
                const 项1 = 系数.a * L;
                const 项2 = 系数.b * R * R;
                const 项3 = 系数.c * L * R;
                const 项4 = 系数.d * R * R * R;
                return (项1 + 项2 + 项3 + 项4) % 安全参数.模数;
            };

            const C1 = 方程计算(安全参数.方程组[0], L, R);
            const C2 = 方程计算(安全参数.方程组[1], L, R);


            const 组件 = [
                L.toString().padStart(3, '0'),
                R.toString().padStart(4, '0'),
                (C1 + C2).toString().padStart(3, '0')
            ];

            return 组件.join('-');
        }

        function 验证死亡凭证(凭证, 待验层数) {
            const [L部分, R部分, C部分] = 凭证.split('-');
            const L = parseInt(L部分);
            const R = parseInt(R部分);
            const 总校验码 = parseInt(C部分);

            if (L !== 待验层数 || R <= 0 || R >= 安全参数.模数) return false;

            // R ≡ (L² +1) mod 13 
            if ((R % 13) !== ((L * L + 1) % 13)) return false;


            const 方程计算 = (系数, L, R) => {
                const 计算值 = 系数.a * L + 系数.b * R * R + 系数.c * L * R + 系数.d * R * R * R;
                return 计算值 % 安全参数.模数;
            };

            const 真实C1 = 方程计算(安全参数.方程组[0], L, R);
            const 真实C2 = 方程计算(安全参数.方程组[1], L, R);

            return (真实C1 + 真实C2) === 总校验码;
        }

        function CopyTextToClipboard(val) {
            const textArea = document.createElement('textArea')
            textArea.value = val
            textArea.style.width = 0
            textArea.style.position = 'fixed'
            textArea.style.left = '-999px'
            textArea.style.top = '10px'
            textArea.setAttribute('readonly', 'readonly')
            document.body.appendChild(textArea)

            textArea.select()
            document.execCommand('copy')
            document.body.removeChild(textArea)
        }
        function 获取附魔描述(enchantments) {

            const numberToRoman = (num) => {
                const romanMap = {
                    1: 'I',
                    2: 'II',
                    3: 'III',
                    4: 'IV',
                    5: 'V',
                    6: 'VI',
                    7: 'VII',
                    8: 'VIII',
                    9: 'IX',
                    10: 'X'
                };
                return romanMap[num] || '';
            };

            return enchantments
                .map(enchant => {
                    const romanLevel = numberToRoman(enchant.等级);
                    return `[${enchant.种类}] ${romanLevel}级`;
                })
                .join('\n');
        }

        function 切换设置菜单() {
            const 菜单 = document.getElementById("设置菜单");
            if (菜单.classList.contains("显示")) {
                菜单.classList.remove("显示");
                菜单.classList.add("隐藏"); // 添加隐藏类以触发动画
                setTimeout(() => {
                    菜单.classList.remove("隐藏");
                }, 300)
            } else {
                菜单.classList.remove("隐藏");
                菜单.classList.add("显示");
            }
        }


        function 关闭设置菜单() {
            const 菜单 = document.getElementById("设置菜单");
            菜单.classList.remove("显示");
            菜单.classList.add("隐藏"); // 添加隐藏类以触发动画
            setTimeout(() => {
                菜单.classList.remove("隐藏");
            }, 300)
        }

        function 切换显示模式() {
            const 装备栏 = document.querySelector(".装备栏");
            const 小地图容器 = document.getElementById("小地图容器");
            const 按钮 = document.getElementById("切换显示按钮");

            if (显示模式 === "装备") {
                装备栏.classList.add("隐藏");
                小地图容器.classList.remove("隐藏");
                显示模式 = "小地图";
                按钮.textContent = "装备栏";
            } else {
                装备栏.classList.remove("隐藏");
                小地图容器.classList.add("隐藏");
                显示模式 = "装备";
                按钮.textContent = "地图";
            }
        }
        function 更新视口() {
            if (相机锁定) return;

            let 原始目标X = 玩家.x - 7
            let 原始目标Y = 玩家.y - 7

            原始目标X = Math.max(0, Math.min(原始目标X, 地牢大小 - 15));
            原始目标Y = Math.max(0, Math.min(原始目标Y, 地牢大小 - 15));

            // 缓动更新目标
            if (相机目标X !== 原始目标X || 相机目标Y !== 原始目标Y) {
                相机锁定 = true;
                相机目标X = 原始目标X;
                相机目标Y = 原始目标Y;

            }
        }
        function 动画帧() {
            // 插值
            const dx = 相机目标X - 当前相机X;
            const dy = 相机目标Y - 当前相机Y;

            当前相机X += dx * 相机移动速度;
            当前相机Y += dy * 相机移动速度;

            // 检测移动完成
            if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1 && 相机锁定) {
                当前相机X = 相机目标X;
                当前相机Y = 相机目标Y;

                更新物体指示器();
                所有怪物.forEach((m) => {
                    m.绘制血条();
                });

                let maxPauseTime = 0; // 最大停顿时间

                // 处理攻击路径显示
                if (待显示格子特效队列.length > 0) {
                    // 玩家属性.允许移动 = false; // 移动到循环外面
                    for (let i = 待显示格子特效队列.length - 1; i >= 0; i--) {
                        const 路径数据 = 待显示格子特效队列[i];
                        显示格子特效(路径数据.路径, 路径数据.颜色, 路径数据.间隔);

                        // 计算当前路径的停顿时间
                        const 路径停顿时间 = 100 + 路径数据.路径.length * 路径数据.间隔;
                        maxPauseTime = Math.max(maxPauseTime, 路径停顿时间);
                    }
                    待显示格子特效队列 = [];
                }

                // 处理爆炸范围显示
                if (待显示爆炸范围.爆炸范围.length > 0) {
                    // 玩家属性.允许移动 = false; // 移动到循环外面
                    const 画布Rect = canvas.getBoundingClientRect();
                    待显示爆炸范围.爆炸范围.forEach(({ x, y, 距离 }) => {
                        const 屏幕X = (x - 当前相机X) * 单元格大小;
                        const 屏幕Y = (y - 当前相机Y) * 单元格大小;

                        const 特效 = document.createElement("div");
                        特效.style.cssText = `
                    position: absolute;
                    left: ${屏幕X + 画布Rect.left}px;
                    top: ${屏幕Y + 画布Rect.top}px;
                    width: ${单元格大小}px;
                    height: ${单元格大小}px;
                    background: ${获取爆炸颜色(距离)};
                    opacity: 0.7;
                    animation: 爆炸闪烁 ${0.4 + (距离 / 待显示爆炸范围.范围) * 0.1}s;
                    pointer-events: none;
                    z-index: 999;
                `;
                        document.body.appendChild(特效);

                        setTimeout(() => 特效.remove(), 500);
                    });

                    // 计算爆炸的停顿时间
                    const 爆炸停顿时间 = 500; // 爆炸动画时间
                    maxPauseTime = Math.max(maxPauseTime, 爆炸停顿时间);

                    待显示爆炸范围 = { 爆炸范围: [], 爆炸距离: null };
                }

                // 统一设置禁止移动和恢复移动
                if (maxPauseTime > 0) {
                    玩家属性.允许移动 = false;
                    setTimeout(() => {
                        玩家属性.允许移动 = true;
                        更新视口();
                    }, maxPauseTime);
                }

                相机锁定 = false;
            }

            // 更新整数视口
            视口偏移X = Math.floor(当前相机X);
            视口偏移Y = Math.floor(当前相机Y);

            绘制();
            requestAnimationFrame(动画帧);
        }
        function 获取爆炸颜色(距离) {
            const 渐变 = [
                "radial-gradient(circle, #ff0000 0%, #ff4500 70%, transparent 100%)",
                "radial-gradient(circle, #ff4500 0%, #ff8c00 70%, transparent 100%)",
                "radial-gradient(circle, #ff8c00 0%, #ffd700 70%, transparent 100%)",
            ];
            return 渐变[Math.min(距离, 2)];
        }
        function 绘制() {

            const 缓冲区域 = 2;
            const 起始X = Math.max(0, Math.floor(当前相机X - 缓冲区域));
            const 结束X = Math.min(地牢大小, 起始X + 相机显示边长 + 缓冲区域 * 2);
            const 起始Y = Math.max(0, Math.floor(当前相机Y - 缓冲区域));
            const 结束Y = Math.min(地牢大小, 起始Y + 相机显示边长 + 缓冲区域 * 2);
            const 清理X = (起始X - 当前相机X) * 单元格大小 - 单元格大小;
            const 清理Y = (起始Y - 当前相机Y) * 单元格大小 - 单元格大小;
            const 清理宽 = (结束X - 起始X + 2) * 单元格大小;
            const 清理高 = (结束Y - 起始Y + 2) * 单元格大小;
            ctx.clearRect(清理X, 清理Y, 清理宽, 清理高);

            const 小数偏移X = (当前相机X % 1) * 单元格大小;
            const 小数偏移Y = (当前相机Y % 1) * 单元格大小;

            for (let y = 起始Y; y < 结束Y; y++) {
                for (let x = 起始X; x < 结束X; x++) {
                    if (地牢.length > 0) {
                        地牢[y][x]?.绘制();
                    }
                }
            }

            const 玩家屏幕X = (玩家.x - 当前相机X + 0.5) * 单元格大小;
            const 玩家屏幕Y = (玩家.y - 当前相机Y + 0.5) * 单元格大小;
            if (moveQueue.length > 0) {
                drawPath(moveQueue);
            }
            const hexArray_ = [];
            if (玩家状态.length > 0) {
                玩家状态.forEach((item) => {
                    hexArray_.push(item.颜色);
                });
                ctx.fillStyle = blendColors(hexArray_);
            } else {
                ctx.fillStyle = "#ff4444";
            }
            ctx.beginPath();
            ctx.arc(
                玩家屏幕X,
                玩家屏幕Y,
                单元格大小 / 3,
                0,
                Math.PI * 2
            );

            ctx.fill();
            ctx.stroke();
            绘制小地图();
        }
        function 绘制小地图() {
            if (当前天气效果.includes("诡魅")) {
                小地图Ctx.fillStyle = "#000000"; // 全黑
                小地图Ctx.fillRect(0, 0, 小地图.width, 小地图.height);
                // 可以选择绘制一个干扰图案或文字
                小地图Ctx.fillStyle = "#555";
                小地图Ctx.font = "20px Arial";
                小地图Ctx.textAlign = "center";
                小地图Ctx.textBaseline = "middle";
                小地图Ctx.fillText("地图干扰", 小地图.width / 2, 小地图.height / 2);
                return;
            }
            const 缩放比例 = 3;
            小地图Ctx.fillStyle = "#1a1a1a";
            小地图Ctx.fillRect(0, 0, 小地图.width, 小地图.height);
            if (地牢.length > 0) {
                // 绘制走廊
                for (let y = 0; y < 地牢大小; y++) {
                    for (let x = 0; x < 地牢大小; x++) {
                        if (地牢[y][x]?.背景类型 === 单元格类型.走廊) {
                            小地图Ctx.strokeStyle = "#666666";

                            小地图Ctx.strokeRect(x * 缩放比例, y * 缩放比例, 缩放比例, 缩放比例);
                        }
                    }
                }
            }

            // 绘制房间
            房间列表.forEach(房间 => {
                const 已访问 = 已访问房间.has(房间.id);
                const 是上锁房间 = 上锁房间列表.some(r => r.id === 房间.id);

                // 设置房间颜色
                if (是上锁房间) {
                    const 颜色索引 = 上锁房间列表.find(r => r.id === 房间.id).颜色索引;
                    小地图Ctx.strokeStyle = 颜色表[颜色索引] || "#FFD700";
                } else {
                    小地图Ctx.strokeStyle = 已访问 ? "#4caf50" : "#666666";
                }

                小地图Ctx.strokeRect(
                    房间.x * 缩放比例,
                    房间.y * 缩放比例,
                    房间.w * 缩放比例,
                    房间.h * 缩放比例
                );

                if (已访问) {
                    小地图Ctx.fillStyle = "#4caf5022";
                    小地图Ctx.fillRect(
                        房间.x * 缩放比例,
                        房间.y * 缩放比例,
                        房间.w * 缩放比例,
                        房间.h * 缩放比例
                    );
                }
            });

            // 玩家位置
            小地图Ctx.fillStyle = "#ff0000";
            小地图Ctx.beginPath();
            小地图Ctx.arc(
                玩家.x * 缩放比例,
                玩家.y * 缩放比例,
                Math.max(3, 缩放比例 / 2),
                0,
                Math.PI * 2
            );
            小地图Ctx.fill();
            小地图Ctx.strokeStyle = "#ffffff";
            小地图Ctx.lineWidth = 2;
            小地图Ctx.stroke();

            // 修正视野框位置（以玩家为中心）
            const 视野半径 = Math.floor(相机显示边长 / 2);
            const 视野框X = (玩家.x - 视野半径) * 缩放比例;
            const 视野框Y = (玩家.y - 视野半径) * 缩放比例;
            const 视野框尺寸 = 相机显示边长 * 缩放比例;

            小地图Ctx.strokeStyle = "#ffd700";
            小地图Ctx.lineWidth = 1;
            小地图Ctx.strokeRect(视野框X, 视野框Y, 视野框尺寸, 视野框尺寸);
        }
        async function startAutoMove() {
            if (moveQueue.length === 0) return;
            const moveInterval = setInterval(() => {
                if (moveQueue.length === 0) {
                    clearInterval(moveInterval);
                    return;
                }
                if (玩家属性.允许移动) {
                    let targetIndex = Math.min(玩家属性.移动步数 - 1, moveQueue.length - 1);
                    let validMove = true;
                    // 检查直线可行性
                    for (let i = 0; i <= targetIndex; i++) {
                        if (!检查直线移动可行性(玩家.x, 玩家.y, moveQueue[i].x, moveQueue[i].y)) {
                            targetIndex = i - 1;
                            validMove = false;
                            break;
                        }
                    }
                    if (targetIndex >= 0 && validMove) {
                        const target = moveQueue[targetIndex];
                        移动玩家(target.x - 玩家.x, target.y - 玩家.y, false);
                        moveQueue = moveQueue.slice(targetIndex + 1);
                    } else {
                        // 无法多格移动时单格移动
                        const target = moveQueue.shift();
                        移动玩家(target.x - 玩家.x, target.y - 玩家.y, false);
                    }
                }
            }, 移动间隔); // 间隔时间
        }

        function 检查直线移动可行性(fromX, fromY, toX, toY, 未解锁房间视作障碍 = false) {
            const dx = toX - fromX;
            const dy = toY - fromY;

            if (dx !== 0 && dy !== 0) return false; // 禁止斜向移动

            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            const dirX = dx > 0 ? 1 : dx < 0 ? -1 : 0;
            const dirY = dy > 0 ? 1 : dy < 0 ? -1 : 0;

            for (let i = 1; i <= steps; i++) {
                const x = fromX + dirX * i;
                const y = fromY + dirY * i;

                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return false;
                if (!检查移动可行性(x - dirX, y - dirY, x, y, 未解锁房间视作障碍)) return false;
            }

            return true;
        }
        const 主菜单容器 = document.getElementById("主菜单容器");
        const 新建游戏按钮 = document.getElementById("新建游戏按钮");
        const 读取存档按钮 = document.getElementById("读取存档按钮");
        const 图鉴按钮 = document.getElementById("图鉴按钮");
        const 读凭证按钮 = document.getElementById("读凭证按钮");

        // --- 菜单控制函数 ---
        function 显示主菜单() {
            游戏状态 = "主菜单";
            document.body.classList.remove("游戏进行中");
            主菜单容器.style.opacity = 1;
            主菜单容器.style.pointerEvents = 'auto';

            const 死亡遮罩 = document.getElementById("死亡遮罩");
            if (死亡遮罩) 死亡遮罩.remove();
            死亡界面已显示 = false; // 重置死亡状态
        }

        function 隐藏主菜单() {
            游戏状态 = "游戏中";
            document.body.classList.add("游戏进行中");
            主菜单容器.style.opacity = 0;
            主菜单容器.style.pointerEvents = 'none';
        }

        // --- 游戏启动函数 ---
        function 启动游戏(存档数据 = null) {

            if (存档数据) {
                console.log("正在加载存档...", 存档数据);
                try {
                    恢复游戏状态(存档数据);
                    初始化canvas();
                    初始化装备系统();
                    更新视口();
                    更新背包显示();
                    更新装备显示();
                    更新界面状态();
                    更新物体指示器();

                    最高教程阶段 = 存档数据.教程?.最高阶段 || 6;
                    是否为教程层 = false;
                    document.getElementById("跳过教程按钮").style.display = "none";
                    document.getElementById("卷轴按钮").style.display = [
                        ...玩家装备.values(),
                    ].some((item) => item.类型 === "卷轴")
                        ? "flex"
                        : "none";
                    动画帧();
                    显示通知("存档加载成功！", "成功");
                    绘制();
                } catch (错误) {
                    console.error("加载存档失败:", 错误);
                    显示通知("加载存档失败", "错误");
                    显示主菜单(); // 加载失败，返回主菜单
                }

            } else {
                重置所有游戏状态();
                初始化canvas();
                初始化装备系统();
                if (window.innerWidth < 769) {
                    document.getElementById("小地图容器").classList.add("隐藏");
                }
                当前层数 = null;
                进入教程层();
                动画帧();
            }

            隐藏主菜单();

        }


        function 重置所有游戏状态() {
            所有怪物.forEach((m) => { m.绘制血条(true); });
            地牢 = [];
            房间列表 = [];
            上锁房间列表 = [];
            所有怪物 = [];
            所有计时器 = [];
            玩家背包 = new Map();
            玩家装备 = new Map();
            门实例列表 = new Map();
            已访问房间 = new Set();
            房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
            玩家初始位置 = { x: 0, y: 0 };
            玩家.x = 0;
            玩家.y = 0;
            当前层数 = 0; // 不进入教程
            玩家属性 = { ...初始玩家属性 };
            玩家状态.forEach((m) => {
                m.移除状态();
            });
            if (当前激活卷轴列表.size > 0) {
                当前激活卷轴列表.forEach(卷轴 => {
                    当前激活卷轴列表.delete(卷轴);
                    卷轴.卸下();

                });
                恢复卷轴模式();
            }
            玩家属性 = { ...初始玩家属性 };
            玩家状态 = [];
            移动历史 = [];
            已击杀怪物数 = 0;
            NPC互动中 = false;
            当前NPC = null;
            死亡界面已显示 = false;
            教程阶段 = 0;
            最高教程阶段 = 0;
            是否为教程层 = false;
            日志历史 = [];
            最大背包容量 = 12;

            document.getElementById("背包物品栏").innerHTML = '';
            document.querySelectorAll(".装备槽").forEach(槽 => 槽.innerHTML = '');
            document.getElementById("logContent").innerHTML = ''; // 清空日志面板内容

            document.querySelector(".health-bar").style.width = "100%";
            document.querySelector(".power-bar").style.width = "100%";
            怪物追踪提示.更新({ 内容: `追踪怪物：0` });
            击杀提示.更新({ 内容: `已击杀怪物：0` });

            界面可见性 = { hud: false, 背包: false };
        }

        /**
         * 序列化地牢单元格
         * @param {单元格} 单元格实例
         * @param {Map<Symbol, string>} 物品标识映射 - 用于转换物品引用
         * @param {Map<怪物, number>} 怪物索引映射 - 用于转换怪物引用
         * @returns {object | null}
         */
        function 序列化单元格(单元格实例, 物品标识映射, 怪物索引映射) {
            if (!单元格实例) return null;
            try {
                let 关联物品标识 = null;
                let 关联物品图标 = null; // Store icon specifically for stairs

                // --- Special Handling for Stairs ---
                if (单元格实例.类型 === 单元格类型.楼梯下楼 || 单元格实例.类型 === 单元格类型.楼梯上楼) {
                    关联物品标识 = null; // Don't serialize the simple stair object via ID
                    关联物品图标 = 单元格实例.关联物品?.图标; // Save the icon
                }
                // --- Handle Regular Items ---
                else if (单元格实例.关联物品) {
                    关联物品标识 = 物品标识映射.get(单元格实例.关联物品.唯一标识);
                    if (!关联物品标识) {
                        console.warn(`单元格 (${单元格实例.x},${单元格实例.y}) 关联物品未在标识映射中找到:`, 单元格实例.关联物品);
                        // Attempt to serialize on the fly (might be problematic if it depends on global state)
                        const serializedItem = 序列化物品(单元格实例.关联物品);
                        if (serializedItem) {
                            关联物品标识 = serializedItem.唯一标识符串;
                            // Ensure the global map is updated if this item wasn't already there
                            if (!物品标识映射.has(单元格实例.关联物品.唯一标识)) {
                                物品标识映射.set(单元格实例.关联物品.唯一标识, 关联物品标识);
                            }
                        }
                    }
                }

                let 关联怪物索引 = null;
                if (单元格实例.关联怪物) {
                    关联怪物索引 = 怪物索引映射.get(单元格实例.关联怪物);
                    if (关联怪物索引 === undefined) {
                        console.warn(`单元格 (${单元格实例.x},${单元格实例.y}) 关联怪物未在索引映射中找到:`, 单元格实例.关联怪物);
                    }
                }


                return {
                    类型: 单元格实例.类型,
                    背景类型: 单元格实例.背景类型,
                    墙壁: { ...单元格实例.墙壁 },
                    钥匙ID: 单元格实例.钥匙ID,
                    颜色索引: 单元格实例.颜色索引,
                    关联物品标识: 关联物品标识,
                    关联物品图标: 关联物品图标, // Save stair icon
                    关联怪物索引: 关联怪物索引,
                    标识符串: 单元格实例.标识 ? 单元格实例.标识.toString() : null
                };
            } catch (e) {
                console.error(`序列化单元格 (${单元格实例.x}, ${单元格实例.y}) 失败:`, e);
                return null;
            }
        }
        /**
         * 保存完整的游戏状态到 localStorage
         * @returns {string | null} JSON 字符串格式的存档数据, 或在失败时返回 null
         */
        function 保存游戏状态() {
            console.log("开始打包游戏状态...");
            try {
                // 0. 创建全局物品标识映射 (背包 + 装备)
                const 全局物品标识映射 = new Map();
                [...玩家背包.values(), ...玩家装备.values()].forEach(物品实例 => { // 使用中文变量名
                    if (物品实例) {
                        全局物品标识映射.set(物品实例.唯一标识, 物品实例.唯一标识.toString());
                    }
                });


                // 1. 序列化玩家背包和装备
                const 序列化玩家背包 = Array.from(玩家背包.values())
                    .map(序列化物品) // 假设 序列化物品 已是中文风格或内部变量已处理
                    .filter(物品数据 => 物品数据 != null);

                const 序列化玩家装备 = Array.from(玩家装备.entries())
                    .map(([槽位, 物品实例]) => 物品实例 ? { 槽位: 槽位, 唯一标识符串: 全局物品标识映射.get(物品实例.唯一标识) } : null)
                    .filter(装备数据 => 装备数据 != null);

                // 2. 序列化玩家状态
                const 序列化玩家状态 = 玩家状态.map(状态实例 => { // 使用中文变量名
                    let 来源标识符串 = null;
                    if (状态实例.来源 && 状态实例.来源.唯一标识) {
                        来源标识符串 = 全局物品标识映射.get(状态实例.来源.唯一标识);
                        if (!来源标识符串) {
                            console.warn("玩家状态来源物品未在全局映射中找到:", 状态实例.来源);
                        }
                    }
                    return {
                        类型: 状态实例.类型,
                        颜色: 状态实例.颜色,
                        图标: 状态实例.图标,
                        持续时间: 状态实例.持续时间,
                        剩余回合: 状态实例.剩余回合,
                        强度: 状态实例.强度,
                        来源类名: 状态实例.来源?.constructor.name,
                        来源标识符串: 来源标识符串
                    };
                }).filter(状态数据 => 状态数据 != null);


                // 3. 序列化当前激活卷轴列表
                const 序列化激活卷轴 = Array.from(当前激活卷轴列表)
                    .map(卷轴实例 => 全局物品标识映射.get(卷轴实例.唯一标识)) // 使用中文变量名
                    .filter(标识符串 => 标识符串 != null);


                // 4. 打包当前楼层数据
                const 当前楼层临时数据 = {
                    地牢数组: 地牢, 房间列表: 房间列表, 上锁房间列表: 上锁房间列表,
                    已访问房间: 已访问房间, 房间地图: 房间地图, 门实例列表: 门实例列表,
                    所有怪物: 所有怪物, 所有计时器: 所有计时器, 玩家初始位置: 玩家初始位置,
                    玩家位置: 玩家, 当前天气效果: 当前天气效果,
                };


                // 5. 序列化所有楼层数据 (包括当前层)
                const 序列化所有楼层数据 = {};
                for (const [层号, 楼层数据] of 所有地牢层.entries()) {
                    if (层号 !== 当前层数) 序列化所有楼层数据[层号] = 序列化楼层(层号, 楼层数据, 全局物品标识映射);
                }
                if (当前层数 !== null) {
                    序列化所有楼层数据[当前层数] = 序列化楼层(当前层数, 当前楼层临时数据, 全局物品标识映射);
                }

                // 获取当前血量和能量百分比
                const 当前生命值百分比 = parseFloat(document.querySelector(".health-bar")?.style.width) || 100;
                const 当前能量值百分比 = parseFloat(document.querySelector(".power-bar")?.style.width) || 100;

                // 6. 组装最终存档对象
                const 存档数据 = {
                    版本: 存档版本, // 版本号保持或更新
                    保存时间: new Date().toISOString(),
                    当前层数: 当前层数,
                    玩家: {
                        x: 玩家.x, y: 玩家.y, 属性: { ...玩家属性 }, 最大背包容量: 最大背包容量,
                        背包: 序列化玩家背包, 装备: 序列化玩家装备, 状态: 序列化玩家状态,
                        当前生命值百分比: 当前生命值百分比, 当前能量值百分比: 当前能量值百分比,
                    },
                    教程: { 阶段: 教程阶段, 最高阶段: 最高教程阶段, 是否教程层: 是否为教程层 },
                    UI: {
                        hud模式: hud模式, 显示模式: 显示模式, 卷轴模式激活: 卷轴模式激活,
                        激活卷轴列表: 序列化激活卷轴, 日志历史: 日志历史.slice(-100)
                    },
                    游戏统计: { 已击杀怪物数: 已击杀怪物数 },
                    所有地牢层数据: 序列化所有楼层数据,
                    传送点列表: 传送点列表.map(点 => ({ ...点 })),
                };

                // 7. 序列化为 JSON 字符串
                const 序列化数据 = JSON.stringify(存档数据, null, 2); // 格式化输出

                // 8. 移除 localStorage 存储
                // localStorage.setItem('dungeonSaveData_v2', 序列化数据);
                // 显示通知("游戏状态已保存！", "成功"); // 移动到 导出存档

                console.log("游戏状态打包完成！");
                return 序列化数据; // 只返回字符串

            } catch (错误) {
                console.error("打包游戏状态失败:", 错误);
                显示通知("打包游戏状态失败！", "错误");
                return null;
            }
        }
        /**
         * 从 localStorage 读取游戏状态
         * @returns {object | null} 解析后的存档对象, 或在失败时返回 null
         */
        function 读取游戏状态() {
            console.log("开始读取游戏状态...");
            const 序列化数据 = localStorage.getItem('dungeonSaveData_v2');
            if (!序列化数据) {
                console.log("未找到存档数据。");
                return null;
            }

            try {
                const 存档数据 = JSON.parse(序列化数据);
                // 版本检查 (可选但推荐)
                if (存档数据.版本 !== 存档版本) {
                    console.warn(`存档版本不匹配 (${存档数据.版本})，可能导致加载问题。`);
                    // 可以选择拒绝加载或尝试兼容性处理
                    // return null;
                }
                console.log("存档数据读取成功！");
                return 存档数据;
            } catch (错误) {
                console.error("读取或解析存档数据失败:", 错误);
                显示通知("读取存档数据失败！", "错误");
                return null;
            }
        }


        /**
         * 恢复单个单元格状态
         * @param {object} 单元格数据
         * @param {number} x
         * @param {number} y
         * @param {Map<string, 物品>} 全局物品实例映射 - 通过物品标识符串查找实例
         * @param {Map<number, 怪物>} 怪物实例映射 - 通过怪物索引查找实例
         * @param {Map<string, 门>} 门实例映射 - 通过门标识符串查找实例
         * @returns {单元格}
         */
        function 恢复单元格(单元格数据, x, y, 全局物品实例映射, 怪物实例映射, 门实例映射) {
            const 单元格实例 = new 单元格(x, y);
            if (!单元格数据) return 单元格实例;

            单元格实例.类型 = 单元格数据.类型 ?? 单元格类型.墙壁;
            单元格实例.背景类型 = 单元格数据.背景类型 ?? 单元格实例.类型;
            单元格实例.墙壁 = { ...(单元格数据.墙壁 || { 上: false, 右: false, 下: false, 左: false }) };
            单元格实例.钥匙ID = 单元格数据.钥匙ID ?? null;
            单元格实例.颜色索引 = 单元格数据.颜色索引 ?? 颜色表.length;

            // --- Restore Association ---
            单元格实例.关联物品 = null; // Default to null
            单元格实例.关联怪物 = null;

            // --- Special Handling for Stairs ---
            if (单元格实例.类型 === 单元格类型.楼梯下楼 || 单元格实例.类型 === 单元格类型.楼梯上楼) {
                const 图标 = 单元格数据.关联物品图标 || (单元格实例.类型 === 单元格类型.楼梯下楼 ? 楼梯图标.下楼 : 楼梯图标.上楼);
                单元格实例.关联物品 = { // Recreate the simple object
                    类型: "楼梯",
                    图标: 图标,
                    显示图标: 图标,
                    颜色索引: 颜色表.length,
                    唯一标识: Symbol(`楼梯_${单元格实例.类型}`), // Consistent Symbol
                    获取名称: () => (单元格实例.类型 === 单元格类型.楼梯下楼 ? "下楼楼梯" : "上楼楼梯"),
                    自定义数据: new Map(),
                    品质: 1,
                    能否拾起: false,
                    是否正常物品: false,
                    是否隐藏: false,
                    是否为隐藏物品: false,
                    效果描述: null,
                    已装备: false,
                    装备槽位: null,
                    堆叠数量: 1,
                    最大堆叠数量: 1,
                    颜色表: 颜色表,
                    使用: () => {
                        const 目标层数 =
                            单元格实例.类型 === 单元格类型.楼梯下楼
                                ? 当前层数 + 1
                                : 当前层数 - 1;
                        切换楼层(目标层数);
                    },
                };
            }
            // --- Restore Regular Items ---
            else if (单元格数据.关联物品标识) {
                const 物品实例 = 全局物品实例映射.get(单元格数据.关联物品标识);
                if (物品实例) {
                    单元格实例.关联物品 = 物品实例;
                    物品实例.x = x; // Ensure coordinates are set
                    物品实例.y = y;
                } else {
                    console.warn(`单元格 (${x},${y}) 关联物品标识 ${单元格数据.关联物品标识} 未找到对应实例`);
                }
            }

            // Restore monster association (still temporary index)
            if (单元格数据.关联怪物索引 !== null && 单元格数据.关联怪物索引 !== undefined) {
                单元格实例.关联怪物 = 单元格数据.关联怪物索引; // Store index for later linking
            }

            // Restore door association
            if (单元格数据.标识符串) {
                const 门实例 = 门实例映射.get(单元格数据.标识符串);
                if (门实例) {
                    单元格实例.标识 = 门实例.唯一标识;
                } else {
                    单元格实例.临时门标识符串 = 单元格数据.标识符串;
                    console.warn(`单元格 (${x},${y}) 的门标识 ${单元格数据.标识符串} 对应的门实例尚未恢复`);
                }
            }

            return 单元格实例;
        }
        /**
         * 序列化单个物品实例 - 扩展版
         * @param {物品} 物品实例
         * @returns {object | null} 可序列化的物品数据，如果物品无效则返回 null
         */
        function 序列化物品(物品实例) {
            if (!物品实例 || !物品实例.constructor) {
                console.warn("尝试序列化无效物品", 物品实例);
                return null;
            }
            try {
                const 类名 = 物品实例.constructor.name;
                const 配置 = { // 包含核心状态和构造所需参数
                    类型: 物品实例.类型,
                    名称: 物品实例.名称,
                    图标: 物品实例.图标,
                    品质: 物品实例.品质,
                    数量: 物品实例.堆叠数量,
                    最大堆叠数量: 物品实例.最大堆叠数量,
                    颜色索引: 物品实例.颜色索引,
                    强化: 物品实例.强化,
                    能否拾起: 物品实例.能否拾起,
                    是否正常物品: 物品实例.是否正常物品,
                    是否隐藏: 物品实例.是否隐藏,
                    是否为隐藏物品: 物品实例.是否为隐藏物品,
                    效果描述: 物品实例.效果描述,
                    已装备: 物品实例.已装备,
                    装备槽位: 物品实例.装备槽位,
                    x: 物品实例.x,
                    y: 物品实例.y,
                    是否被丢弃: 物品实例.是否被丢弃 || false,
                    阻碍怪物: 物品实例.阻碍怪物,
                    数据: 物品实例.自定义数据 ? Object.fromEntries(物品实例.自定义数据) : {}
                };

                // --- 特殊物品类处理 ---

                // 武器类 & 防御装备类: 保存附魔 (自定义数据已包含)
                if (物品实例 instanceof 武器类 || 物品实例 instanceof 防御装备类) {
                    // 配置.数据.附魔 在 Object.fromEntries(物品实例.自定义数据) 中已处理
                    // 需要确保 冷却剩余 被保存 (武器类)
                    if (物品实例 instanceof 武器类) {
                        配置.数据.冷却剩余 = 物品实例.自定义数据.get('冷却剩余') ?? 0;
                    }
                }

                // 卷轴类: 保存已解锁状态 (自定义数据已包含)

                // 附魔卷轴: 保存可用次数和效果名
                if (物品实例 instanceof 附魔卷轴) {
                    配置.数据.可用次数 = 物品实例.可用次数;
                    // 找到效果名用于恢复
                    const 效果索引 = 物品实例.附魔池.findIndex(func => func === 物品实例.附魔效果);
                    if (效果索引 !== -1) {
                        配置.数据.附魔效果名 = 物品实例.效果名[效果索引];
                    } else {
                        console.warn("无法找到附魔卷轴的效果名:", 物品实例);
                    }
                }

                // 神秘商人 / 物品祭坛: 序列化库存
                if (物品实例 instanceof 神秘商人 || 物品实例 instanceof 物品祭坛) {
                    配置.数据.库存序列化 = (物品实例.自定义数据.get('库存') || [])
                        .map(序列化物品)
                        .filter(item => item !== null);
                    // 从原始数据中移除库存，避免重复和循环引用
                    delete 配置.数据.库存;
                }

                // 宠物: 序列化装备标识和技能，以及其他状态
                if (物品实例 instanceof 宠物) {
                    const 宠物装备 = 物品实例.自定义数据.get('装备') || {};
                    配置.数据.装备标识 = {}; // 使用新字段存储标识
                    for (const 槽位 in 宠物装备) {
                        if (宠物装备[槽位] && 宠物装备[槽位].唯一标识) {
                            配置.数据.装备标识[槽位] = 宠物装备[槽位].唯一标识.toString();
                        } else {
                            配置.数据.装备标识[槽位] = null;
                        }
                    }
                    // 技能通常是简单对象数组，可以直接序列化
                    配置.数据.技能 = JSON.parse(JSON.stringify(物品实例.自定义数据.get('技能') || [])); // 深拷贝确保安全
                    // 其他宠物特定状态已在自定义数据中

                    // 从原始数据中移除复杂对象，避免循环引用
                    delete 配置.数据.装备;
                }

                // 折跃门: 保存目标房间ID
                if (物品实例 instanceof 折跃门) {
                    const 目标房间 = 物品实例.自定义数据.get('目标房间');
                    配置.数据.目标房间ID = 目标房间 ? 目标房间.id : null;
                }

                // 钥匙: (自定义数据已包含)
                // 炸弹: (自定义数据已包含)

                return {
                    类名: 类名,
                    唯一标识符串: 物品实例.唯一标识.toString(),
                    配置: 配置
                };
            } catch (e) {
                console.error(`序列化物品 ${物品实例?.名称} (${类名}) 失败:`, e);
                return null;
            }
        }

        /**
        * 序列化单个怪物实例 - 扩展版
        * @param {怪物} 怪物实例
        * @param {number} 怪物索引
        * @param {Array<怪物>} 当前楼层所有怪物列表 - 用于查找引用索引
        * @returns {object | null} 可序列化的怪物数据
        */
        function 序列化怪物(怪物实例, 怪物索引, 当前楼层所有怪物列表) {
            if (!怪物实例 || !怪物实例.constructor) {
                console.warn("尝试序列化无效怪物", 怪物实例);
                return null;
            }
            const 类名 = 怪物实例.constructor.name;
            try {
                let 仇恨目标标识 = null;
                if (怪物实例.仇恨 === 玩家) {
                    仇恨目标标识 = "玩家";
                } else if (怪物实例.仇恨 instanceof 怪物) {
                    const 仇恨索引 = 当前楼层所有怪物列表.findIndex(m => m === 怪物实例.仇恨);
                    if (仇恨索引 !== -1) {
                        仇恨目标标识 = `怪物_${仇恨索引}`;
                    } else {
                        console.warn(`怪物 ${怪物索引} 的仇恨目标未在当前楼层找到:`, 怪物实例.仇恨);
                    }
                }

                const 状态效果数据 = 怪物状态表.get(怪物实例);
                let 序列化状态 = null;
                if (状态效果数据) {
                    序列化状态 = {
                        类型: 状态效果数据.类型,
                        颜色: 状态效果数据.颜色,
                        图标: 状态效果数据.图标,
                        持续时间: 状态效果数据.持续时间,
                        剩余回合: 状态效果数据.剩余回合,
                        强度: 状态效果数据.强度,
                    };
                }

                const 配置 = {
                    x: 怪物实例.x,
                    y: 怪物实例.y,
                    图标: 怪物实例.图标,
                    房间ID: 怪物实例.房间ID,
                    当前生命值: 怪物实例.当前生命值,
                    状态: 怪物实例.状态,
                    强化: 怪物实例.强化,
                    攻击冷却剩余: 怪物实例.攻击冷却回合剩余,
                    受伤冻结回合剩余: 怪物实例.受伤冻结回合剩余,
                    仇恨目标标识: 仇恨目标标识,
                    // --- 特定怪物属性保存 ---
                    基础攻击力: 怪物实例.基础攻击力, // 保存基础值，因为强化可能影响计算后的攻击力
                    基础生命值: 怪物实例.基础生命值,
                    移动率: 怪物实例.移动率,
                    基础移动距离: 怪物实例.基础移动距离,
                    基础攻击范围: 怪物实例.基础攻击范围,
                    跟踪距离: 怪物实例.跟踪距离,
                    攻击冷却: 怪物实例.攻击冷却, // 保存基础冷却回合
                    受伤冻结回合: 怪物实例.受伤冻结回合, // 保存基础冻结回合
                    掉落概率: 怪物实例.掉落概率, // 保存掉落概率
                    当前格: 怪物实例.当前格,
                };

                // --- 特定怪物类处理 ---
                if (怪物实例 instanceof 腐蚀怪物) {
                    配置.腐蚀强度 = 怪物实例.腐蚀强度;
                    配置.腐蚀持续 = 怪物实例.腐蚀持续;
                }
                if (怪物实例 instanceof 盗贼怪物) {
                    配置.偷窃几率 = 怪物实例.偷窃几率;
                    配置.偷窃武器几率 = 怪物实例.偷窃武器几率;
                    配置.偷到的金币 = 怪物实例.偷到的金币;
                    配置.偷到的武器列表序列化 = 怪物实例.偷到的武器列表.map(序列化物品).filter(i => i != null);
                }
                if (怪物实例 instanceof 吸能怪物) {
                    配置.吸能比例 = 怪物实例.吸能比例;
                    配置.最小吸能 = 怪物实例.最小吸能;
                }
                if (怪物实例 instanceof 剧毒云雾怪物) {
                    配置.毒云范围 = 怪物实例.毒云范围;
                    配置.毒云持续 = 怪物实例.毒云持续;
                    配置.毒云强度 = 怪物实例.毒云强度;
                }
                if (怪物实例 instanceof 召唤师怪物) {
                    配置.召唤冷却剩余 = 怪物实例.召唤冷却剩余;
                    配置.最大召唤物数量 = 怪物实例.最大召唤物数量;
                    配置.召唤物类名 = 怪物实例.召唤物类.name;
                    配置.当前召唤物索引列表 = 怪物实例.当前召唤物列表
                        .map(仆从 => 当前楼层所有怪物列表.findIndex(m => m === 仆从))
                        .filter(index => index !== -1);
                }
                if (怪物实例 instanceof 幽灵仆从) {
                    配置.生命周期 = 怪物实例.生命周期;
                    const 召唤者索引 = 当前楼层所有怪物列表.findIndex(m => m === 怪物实例.召唤者);
                    配置.召唤者索引 = 召唤者索引 !== -1 ? 召唤者索引 : null;
                }
                if (怪物实例 instanceof 萨满怪物) {
                    配置.治疗冷却剩余 = 怪物实例.治疗冷却剩余;
                    // 其他属性是构造时确定的，无需重复保存
                }
                if (怪物实例 instanceof 大史莱姆怪物) {
                    // 分裂数量是构造时确定的
                }
                if (怪物实例 instanceof 瞬移怪物) {
                    配置.瞬移几率 = 怪物实例.瞬移几率;
                    配置.受击瞬移几率 = 怪物实例.受击瞬移几率;
                }
                if (怪物实例 instanceof 伪装怪物) {
                    配置.伪装状态 = 怪物实例.伪装状态;
                    配置.伪装图标 = 怪物实例.伪装图标;
                    配置.真实图标 = 怪物实例.真实图标;
                    // 触发距离是构造时确定的
                }
                if (怪物实例 instanceof 炸弹怪物) {
                    配置.携带炸弹 = 怪物实例.携带炸弹;
                }
                if (怪物实例 instanceof 大魔法师) {
                    配置.技能冷却 = 怪物实例.技能冷却;
                    配置.隐身中 = 怪物实例.隐身中;
                    配置.isClone = 怪物实例.isClone;
                    // 分身引用需要特殊处理，在恢复阶段链接
                    const 分身索引 = 怪物实例.分身 ? 当前楼层所有怪物列表.findIndex(m => m === 怪物实例.分身) : -1;
                    配置.分身索引 = 分身索引 !== -1 ? 分身索引 : null;
                }
                if (怪物实例 instanceof 旋风怪物) { // 新增
                    配置.召唤冷却剩余 = 怪物实例.召唤冷却剩余;
                    配置.最大召唤物数量 = 怪物实例.最大召唤物数量;
                    // 保存召唤物索引列表
                    配置.当前召唤物索引列表 = 怪物实例.当前召唤物列表
                        .map(旋 => 当前楼层所有怪物列表.findIndex(m => m === 旋))
                        .filter(index => index !== -1);
                }
                if (怪物实例 instanceof 旋风) { // 新增
                    配置.生命周期 = 怪物实例.生命周期;
                }

                const 掉落物序列化 = 怪物实例.掉落物 ? 序列化物品(怪物实例.掉落物) : null;

                return {
                    类名: 类名,
                    怪物索引: 怪物索引,
                    配置: 配置,
                    掉落物: 掉落物序列化,
                    状态效果: 序列化状态
                };
            } catch (e) {
                console.error(`序列化怪物 ${怪物实例?.类型} (${类名}) 失败:`, e);
                return null;
            }
        }

        // 序列化炸弹 和 序列化单元格 函数保持不变，因为它们依赖于 序列化物品 和 序列化怪物

        /**
         * 序列化整个楼层的数据 - 扩展版
         * @param {number} 层号
         * @param {object} 楼层原始数据
         * @param {Map<Symbol, string>} 全局物品标识映射
         * @returns {object | null}
         */
        function 序列化楼层(层号, 楼层原始数据, 全局物品标识映射) {
            console.log(`开始序列化楼层 ${层号}`);
            if (!楼层原始数据) {
                console.warn(`楼层 ${层号} 数据不存在，跳过序列化`);
                return null;
            }
            try {
                // 解构时使用默认值防止楼层数据不完整导致错误
                const { 地牢数组 = [], 房间列表 = [], 上锁房间列表 = [], 已访问房间 = new Set(), 房间地图 = [], 门实例列表 = new Map(), 所有怪物 = [], 所有计时器 = [], 玩家初始位置 = { x: 0, y: 0 }, 玩家位置 = 玩家位置, 当前天气效果 = [] } = 楼层原始数据;

                // 1. 创建当前楼层的地上物品列表及更新全局映射
                const 地上物品列表 = [];
                for (let y = 0; y < 地牢数组.length; y++) {
                    for (let x = 0; x < 地牢数组[y]?.length; x++) { // 添加检查确保行存在
                        const 物品 = 地牢数组[y][x]?.关联物品;
                        // 排除宠物，宠物只应在背包或装备中序列化一次
                        if (物品) {
                            地上物品列表.push(物品);
                            if (!全局物品标识映射.has(物品.唯一标识)) {
                                全局物品标识映射.set(物品.唯一标识, 物品.唯一标识.toString());
                            }
                        }
                    }
                }
                const 序列化地上物品 = 地上物品列表.map(序列化物品).filter(i => i != null);

                // 2. 创建当前楼层的怪物索引映射 及 序列化怪物列表
                const 怪物索引映射 = new Map();
                const 序列化怪物列表 = 所有怪物.map((怪物, 索引) => {
                    怪物索引映射.set(怪物, 索引); // 先存映射
                    return 序列化怪物(怪物, 索引, 所有怪物); // 再序列化，传入所有怪物列表
                }).filter(m => m != null);

                // 3. 序列化地牢格子 (使用物品标识和怪物索引)
                const 序列化地牢格子 = 地牢数组.map(行 =>
                    行.map(单元格 => 序列化单元格(单元格, 全局物品标识映射, 怪物索引映射)).filter(g => g != null)
                );

                // 4. 序列化炸弹 (并更新全局映射)
                const 序列化物品列表 = 所有计时器.map(序列化物品).filter(b => b != null);
                序列化物品列表.forEach(炸弹数据 => {
                    if (炸弹数据) {
                        const 符号 = Symbol(炸弹数据.唯一标识符串.slice(7, -1)); // 从字符串恢复 Symbol
                        if (!全局物品标识映射.has(符号)) {
                            全局物品标识映射.set(符号, 炸弹数据.唯一标识符串);
                        }
                    }
                });

                // 5. 序列化门实例列表
                const 序列化门实例 = Array.from(门实例列表.values()).map(门 => ({
                    唯一标识符串: 门.唯一标识.toString(),
                    类型: 门.类型,
                    是否上锁: 门.是否上锁,
                    房间ID: 门.房间ID,
                    所在位置: { ...门.所在位置 }
                }));

                console.log(`楼层 ${层号} 序列化完成`);
                return {
                    玩家位置: 玩家位置,
                    玩家初始位置: { ...玩家初始位置 },
                    房间列表: 房间列表.map(r => ({ ...r, 门: r.门 ? [...r.门] : [] })), // 深拷贝房间列表和门数组
                    上锁房间列表: 上锁房间列表.map(r => ({ ...r, 门: r.门 ? [...r.门] : [] })), // 深拷贝
                    已访问房间数组: Array.from(已访问房间 || new Set()),
                    房间地图: 房间地图.map(row => [...row]), // 深拷贝二维数组
                    序列化地上物品: 序列化地上物品,
                    序列化怪物列表: 序列化怪物列表,
                    序列化物品列表: 序列化物品列表,
                    序列化地牢格子: 序列化地牢格子,
                    序列化门实例: 序列化门实例,
                    当前天气效果: [...当前天气效果],

                };
            } catch (e) {
                console.error(`序列化楼层 ${层号} 失败:`, e);
                return null;
            }
        }

        // --- 恢复辅助函数 ---

        /**
         * 恢复单个物品实例 - 扩展版
         * @param {object} 物品数据
         * @param {Map<string, Symbol>} 全局物品标识映射 - string -> symbol
         * @returns {物品 | null}
         */
        function 恢复物品(物品数据, 全局物品标识映射) {
            if (!物品数据 || !物品数据.类名) return null;
            const 类构造器 = window[物品数据.类名];
            if (!类构造器 || typeof 类构造器 !== 'function') {
                console.warn(`未找到物品类构造器: ${物品数据.类名}`);
                return null;
            }
            try {
                const 配置 = { ...物品数据.配置 };
                const 标识符串 = 物品数据.唯一标识符串;
                let 唯一标识 = 全局物品标识映射.get(标识符串); // 尝试从全局映射获取 Symbol

                if (!唯一标识) {
                    // 如果全局映射没有，根据规则创建或查找 Symbol
                    if (物品数据.类名 === '钥匙') {
                        配置.对应门ID = 配置.数据?.对应门ID; // 注意：数据可能还未转为Map
                        配置.地牢层数 = 配置.数据?.地牢层数;
                        if (配置.对应门ID !== undefined && 配置.地牢层数 !== undefined) {
                            唯一标识 = Symbol.for(`${配置.地牢层数}层${配置.对应门ID}`);
                        } else {
                            console.warn("钥匙缺少门ID或层数信息，无法恢复Symbol.for:", 配置);
                            唯一标识 = Symbol(标识符串);
                        }
                    } else if (标识符串 && 标识符串.startsWith('Symbol(')) {
                        const description = 标识符串.slice(7, -1);
                        唯一标识 = Symbol(description);
                    } else {
                        console.warn("物品缺少有效唯一标识符串，生成新Symbol:", 物品数据);
                        唯一标识 = Symbol(`恢复_${物品数据.类名}_${Date.now()}`);
                    }
                    全局物品标识映射.set(标识符串, 唯一标识); // 加入全局映射
                }

                // 恢复 Map 类型的自定义数据
                if (配置.数据) {
                    配置.数据 = new Map(Object.entries(配置.数据));
                } else {
                    配置.数据 = new Map(); // 确保数据属性存在
                }

                // 创建实例
                const 实例 = new 类构造器({ ...配置, 唯一标识: 唯一标识 });
                实例.自定义数据 = 配置.数据;
                实例.是否隐藏 = 配置.是否隐藏;
                实例.堆叠数量 = 配置.数量
                // --- 特殊物品类恢复 ---

                // 武器类/防御装备类: 恢复附魔 (已在自定义数据中), 恢复冷却剩余
                if (实例 instanceof 武器类) {
                    实例.自定义数据.set('冷却剩余', 配置.数据.get('冷却剩余') ?? 0);
                }
                // 卷轴类: 恢复已解锁 (已在自定义数据中)

                // 附魔卷轴: 恢复可用次数和效果函数
                if (实例 instanceof 附魔卷轴) {
                    实例.可用次数 = 配置.数据.get('可用次数') ?? 1;
                    const 效果名 = 配置.数据.get('附魔效果名');
                    const 效果索引 = 实例.效果名.indexOf(效果名);
                    if (效果索引 !== -1) {
                        实例.附魔效果 = 实例.附魔池[效果索引];
                    } else {
                        console.warn(`无法恢复附魔卷轴效果: ${效果名}`);
                        // 可以设置一个默认效果或标记为无效
                    }
                }

                // 神秘商人 / 物品祭坛: 库存将在恢复楼层后处理 (需要全局物品映射完整)

                // 宠物: 装备和技能将在恢复楼层/游戏状态后处理

                // 折跃门: 目标房间将在恢复楼层后处理

                // 炸弹: 倒计时等在自定义数据中

                // 恢复地上物品的位置和状态
                实例.x = 配置.x ?? null;
                实例.y = 配置.y ?? null;
                实例.是否被丢弃 = 配置.是否被丢弃 ?? false;

                // 恢复装备状态（将在恢复玩家装备时处理）
                实例.已装备 = false;
                实例.装备槽位 = null;


                return 实例;
            } catch (e) {
                console.error(`恢复物品 ${物品数据.类名} 失败:`, e);
                return null;
            }
        }

        /**
         * 恢复单个怪物实例 - 扩展版
         * @param {object} 怪物数据
         * @param {Map<string, 物品>} 全局物品实例映射
         * @param {Map<number, 怪物>} 当前楼层怪物映射 (用于存储恢复的实例)
         * @returns {怪物 | null}
         */
        function 恢复怪物(怪物数据, 全局物品实例映射, 当前楼层怪物映射) {
            if (!怪物数据 || !怪物数据.类名) return null;
            const 类构造器 = window[怪物数据.类名];
            if (!类构造器 || typeof 类构造器 !== 'function') {
                console.warn(`未找到怪物类构造器: ${怪物数据.类名}`);
                return null;
            }
            try {
                const 配置 = { ...怪物数据.配置 }; // 复制配置

                // 恢复掉落物
                let 掉落物实例 = null;
                if (怪物数据.掉落物) {
                    const 临时物品标识映射 = new Map(); // 掉落物用临时映射
                    掉落物实例 = 恢复物品(怪物数据.掉落物, 临时物品标识映射);
                    if (掉落物实例) {
                        // 如果掉落物是全局物品（如玩家背包中的），确保使用全局实例
                        const 全局实例 = 全局物品实例映射.get(怪物数据.掉落物.唯一标识符串);
                        if (全局实例) 掉落物实例 = 全局实例;
                        else 全局物品实例映射.set(怪物数据.掉落物.唯一标识符串, 掉落物实例.唯一标识); // 添加到全局
                    }
                }
                配置.掉落物 = 掉落物实例;

                // --- 恢复基础属性 ---
                // 构造函数可能依赖基础属性，先恢复它们
                const 实例 = new 类构造器({
                    // 传递构造函数可能需要的核心参数
                    x: 配置.x,
                    y: 配置.y,
                    房间ID: 配置.房间ID,
                    强化: 配置.强化,
                    掉落物: 配置.掉落物, // 传递恢复的掉落物实例
                    // ... 其他构造函数可能需要的参数 ...
                });


                // --- 恢复状态 ---
                实例.图标 = 配置.图标 ?? 实例.图标;
                实例.基础生命值 = 配置.基础生命值 ?? 实例.生命值;
                实例.基础攻击力 = 配置.基础攻击力 ?? 实例.生命值;
                实例.当前生命值 = 配置.当前生命值 ?? 实例.生命值;
                实例.状态 = 配置.状态 ?? 怪物状态.休眠;
                实例.攻击冷却回合剩余 = 配置.攻击冷却剩余 ?? 0;
                实例.受伤冻结回合剩余 = 配置.受伤冻结回合剩余 ?? 0;
                实例.移动率 = 配置.移动率 ?? 实例.移动率; // 使用保存的值或默认值
                实例.基础移动距离 = 配置.基础移动距离 ?? 实例.基础移动距离;
                实例.基础攻击范围 = 配置.基础攻击范围 ?? 实例.基础攻击范围;
                实例.跟踪距离 = 配置.跟踪距离 ?? 实例.跟踪距离;
                实例.攻击冷却 = 配置.攻击冷却 ?? 实例.攻击冷却;
                实例.受伤冻结回合 = 配置.受伤冻结回合 ?? 实例.受伤冻结回合;
                实例.掉落概率 = 配置.掉落概率 ?? 实例.掉落概率;

                // --- 恢复特定怪物状态 ---
                if (实例 instanceof 腐蚀怪物) {
                    实例.腐蚀强度 = 配置.腐蚀强度 ?? 1;
                    实例.腐蚀持续 = 配置.腐蚀持续 ?? 4;
                }
                if (实例 instanceof 盗贼怪物) {
                    实例.偷窃几率 = 配置.偷窃几率 ?? 0.5;
                    实例.偷窃武器几率 = 配置.偷窃武器几率 ?? 0.15;
                    实例.偷到的金币 = 配置.偷到的金币 ?? 0;
                    实例.偷到的武器列表 = (配置.偷到的武器列表序列化 || [])
                        .map(wData => 恢复物品(wData, 全局物品实例映射)) // 使用全局映射恢复
                        .filter(w => w != null);
                }
                if (实例 instanceof 吸能怪物) {
                    实例.吸能比例 = 配置.吸能比例 ?? 0.3;
                    实例.最小吸能 = 配置.最小吸能 ?? 5;
                }
                if (实例 instanceof 剧毒云雾怪物) {
                    实例.毒云范围 = 配置.毒云范围 ?? 1;
                    实例.毒云持续 = 配置.毒云持续 ?? 3;
                    实例.毒云强度 = 配置.毒云强度 ?? 2;
                }
                if (实例 instanceof 召唤师怪物) {
                    实例.召唤冷却剩余 = 配置.召唤冷却剩余 ?? 0;
                    实例.最大召唤物数量 = 配置.最大召唤物数量 ?? 2;
                    实例.召唤物类 = window[配置.召唤物类名] || 幽灵仆从; // 恢复类引用
                    // 召唤物列表将在恢复楼层后链接
                    实例.临时召唤物索引列表 = 配置.当前召唤物索引列表 || [];
                }
                if (实例 instanceof 幽灵仆从) {
                    实例.生命周期 = 配置.生命周期 ?? 8;
                    // 召唤者将在恢复楼层后链接
                    实例.临时召唤者索引 = 配置.召唤者索引;
                }
                if (实例 instanceof 萨满怪物) {
                    实例.治疗冷却剩余 = 配置.治疗冷却剩余 ?? 0;
                    // 其他是常量
                }
                if (实例 instanceof 瞬移怪物) {
                    实例.瞬移几率 = 配置.瞬移几率 ?? 0.6;
                    实例.受击瞬移几率 = 配置.受击瞬移几率 ?? 0.4;
                }
                if (实例 instanceof 伪装怪物) {
                    实例.伪装状态 = 配置.伪装状态 ?? false; // 默认非伪装
                }
                if (实例 instanceof 炸弹怪物) {
                    实例.携带炸弹 = 配置.携带炸弹 ?? true;
                }
                if (实例 instanceof 大魔法师) {
                    实例.技能冷却 = 配置.技能冷却 ?? { 隐身术: 0, 分身术: 0, 火球术: 0, 冰冻术: 0, 传送术: 0, 召唤术: 0 };
                    实例.隐身中 = 配置.隐身中 ?? false;
                    实例.isClone = 配置.isClone ?? false;
                    // 分身将在恢复楼层后链接
                    实例.临时分身索引 = 配置.分身索引;
                }
                if (实例 instanceof 旋风怪物) { // 新增
                    实例.召唤冷却剩余 = 配置.召唤冷却剩余 ?? 0;
                    实例.最大召唤物数量 = 配置.最大召唤物数量 ?? 1;
                    // 暂存召唤物索引，待链接
                    实例.临时召唤物索引列表 = 配置.当前召唤物索引列表 || [];
                }
                if (实例 instanceof 旋风) { // 新增
                    实例.生命周期 = 配置.生命周期 ?? 10;
                }
                // 存入怪物映射
                if (怪物数据.怪物索引 !== undefined) {
                    当前楼层怪物映射.set(怪物数据.怪物索引, 实例);
                }

                // 恢复状态效果 (创建效果，但不立即应用)
                if (怪物数据.状态效果) {
                    const 效果 = new 状态效果(
                        怪物数据.状态效果.类型,
                        怪物数据.状态效果.颜色,
                        怪物数据.状态效果.图标,
                        怪物数据.状态效果.持续时间,
                        怪物数据.状态效果.剩余回合,
                        null, 实例, // 关联怪物
                        怪物数据.状态效果.强度
                    );
                    // 效果的 应用/更新/移除 将在游戏循环中处理，这里只需创建并让 怪物状态表 知道它
                    // 怪物状态表 在恢复楼层完成后统一填充
                }
                实例.临时状态效果 = 怪物数据.状态效果; // 暂存

                // 暂存仇恨标识，待所有怪物恢复后处理
                实例.临时仇恨目标标识 = 配置.仇恨目标标识;


                return 实例;
            } catch (e) {
                console.error(`恢复怪物 ${怪物数据.类名} 失败:`, e);
                return null;
            }
        }

        // 恢复炸弹 和 恢复单元格 函数保持不变，依赖于恢复物品和恢复怪物

        /**
         * 恢复单个楼层的数据 - 扩展版
         * @param {number} 层号
         * @param {object} 楼层存档数据
         * @param {Map<string, 物品>} 全局物品实例映射 - string -> instance
         * @param {Map<string, Symbol>} 全局物品标识映射 - string -> symbol
         * @returns {object | null}
         */
        function 恢复楼层(层号, 楼层存档数据, 全局物品实例映射, 全局物品标识映射) {
            console.log(`开始恢复楼层 ${层号}`);
            if (!楼层存档数据) {
                console.warn(`楼层 ${层号} 存档数据无效，跳过恢复`);
                return null;
            }
            try {
                const 楼层数据 = {
                    玩家位置: 楼层存档数据.玩家位置,
                    玩家初始位置: { ...(楼层存档数据.玩家初始位置 || { x: 0, y: 0 }) },
                    房间列表: [...(楼层存档数据.房间列表 || [])],
                    上锁房间列表: [...(楼层存档数据.上锁房间列表 || [])],
                    已访问房间: new Set(楼层存档数据.已访问房间数组 || []),
                    房间地图: [...(楼层存档数据.房间地图 || [])],
                    地牢数组: [],
                    所有怪物: [],
                    所有计时器: [],
                    门实例列表: new Map(),
                    当前天气效果: [...(楼层存档数据.当前天气效果 || [])],
                };

                // 1. 恢复地上物品实例 (并更新全局映射)
                const 地上物品实例映射 = new Map(); // 当前楼层地上物品 string -> instance
                if (楼层存档数据.序列化地上物品) {
                    楼层存档数据.序列化地上物品.forEach(物品数据 => {
                        // 尝试从全局映射获取或恢复新实例
                        let 实例 = 全局物品实例映射.get(物品数据.唯一标识符串);
                        if (!实例) {
                            实例 = 恢复物品(物品数据, 全局物品标识映射);
                            if (实例) {
                                全局物品实例映射.set(物品数据.唯一标识符串, 实例);
                            }
                        }
                        if (实例) {
                            地上物品实例映射.set(物品数据.唯一标识符串, 实例);
                            实例.x = 物品数据.配置?.x ?? null;
                            实例.y = 物品数据.配置?.y ?? null;
                        }
                    });
                }

                // 2. 恢复门实例
                const 门实例映射 = new Map(); // string -> instance
                if (楼层存档数据.序列化门实例) {
                    楼层存档数据.序列化门实例.forEach(门数据 => {
                        let 唯一标识;
                        const 现有符号 = 全局物品标识映射.get(门数据.唯一标识符串); // 门也用物品映射？或者单独的门映射？暂时用物品
                        if (现有符号) {
                            唯一标识 = 现有符号;
                        } else {
                            唯一标识 = Symbol(门数据.唯一标识符串.slice(7, -1));
                            全局物品标识映射.set(门数据.唯一标识符串, 唯一标识); // 如果没有，添加到全局
                        }

                        const 实例 = new 门({ 关联房间ID: 门数据.房间ID, 位置: { ...门数据.所在位置 } });
                        实例.唯一标识 = 唯一标识;
                        实例.类型 = 门数据.类型;
                        实例.是否上锁 = 门数据.是否上锁;
                        楼层数据.门实例列表.set(唯一标识, 实例);
                        门实例映射.set(门数据.唯一标识符串, 实例);
                    });
                }

                // 3. 恢复地牢格子 (关联物品和门)
                楼层数据.地牢数组 = Array(地牢大小).fill().map((_, y) =>
                    Array(地牢大小).fill().map((_, x) => {
                        const 单元格数据 = 楼层存档数据.序列化地牢格子?.[y]?.[x];
                        return 恢复单元格(单元格数据, x, y, 全局物品实例映射, new Map(), 门实例映射); // 传入全局物品映射
                    })
                );
                // 链接门的标识
                for (let y = 0; y < 地牢大小; y++) {
                    for (let x = 0; x < 地牢大小; x++) {
                        const 单元格 = 楼层数据.地牢数组[y][x];
                        if (单元格.临时门标识符串) {
                            const 门实例 = 门实例映射.get(单元格.临时门标识符串);
                            if (门实例) {
                                单元格.标识 = 门实例.唯一标识;
                            } else {
                                console.warn(`单元格 (${x},${y}) 的临时门标识 ${单元格.临时门标识符串} 仍然无法解析`);
                            }
                            delete 单元格.临时门标识符串;
                        }
                    }
                }

                // 4. 恢复怪物列表
                const 当前楼层怪物映射 = new Map(); // index -> instance
                if (楼层存档数据.序列化怪物列表) {
                    楼层数据.所有怪物 = 楼层存档数据.序列化怪物列表
                        .map(怪物数据 => 恢复怪物(怪物数据, 全局物品实例映射, 当前楼层怪物映射))
                        .filter(m => m != null);
                }

                // 5. 链接怪物到地牢格子 & 恢复怪物引用 (仇恨, 召唤物, 召唤者, 分身) & 状态效果
                楼层数据.所有怪物.forEach((怪物实例, 索引) => {
                    // 链接到格子
                    if (怪物实例.x !== null && 怪物实例.y !== null) {
                        const 单元格 = 楼层数据.地牢数组[怪物实例.y]?.[怪物实例.x];
                        if (单元格) {
                            if (!(单元格.关联怪物 instanceof 怪物)) { // 确保格子没被占用
                                单元格.关联怪物 = 怪物实例;
                                单元格.类型 = 单元格类型.怪物; // 确保类型正确
                            } else {
                                console.warn(`尝试将怪物 ${索引} 放置到已被占用的格子 (${怪物实例.x}, ${怪物实例.y})`);
                            }
                        } else {
                            console.warn(`怪物 ${索引} 的坐标 (${怪物实例.x}, ${怪物实例.y}) 无效`);
                        }
                    } else {
                        console.warn(`怪物 ${索引} 缺少坐标信息`);
                    }

                    // 恢复引用关系
                    if (怪物实例.临时仇恨目标标识) {
                        const 标识 = 怪物实例.临时仇恨目标标识;
                        if (标识 === "玩家") {
                            怪物实例.仇恨 = 玩家;
                        } else if (标识.startsWith("怪物_")) {
                            const 仇恨索引 = parseInt(标识.split('_')[1]);
                            怪物实例.仇恨 = 当前楼层怪物映射.get(仇恨索引) || null;
                            if (!怪物实例.仇恨) console.warn(`怪物 ${索引} 的仇恨目标索引 ${仇恨索引} 未找到`);
                        }
                        delete 怪物实例.临时仇恨目标标识;
                    }
                    if (怪物实例 instanceof 召唤师怪物 && 怪物实例.临时召唤物索引列表) {
                        怪物实例.当前召唤物列表 = 怪物实例.临时召唤物索引列表
                            .map(召唤索引 => 当前楼层怪物映射.get(召唤索引))
                            .filter(仆从 => 仆从 != null);
                        delete 怪物实例.临时召唤物索引列表;
                    }
                    if (怪物实例 instanceof 幽灵仆从 && 怪物实例.临时召唤者索引 !== undefined) {
                        怪物实例.召唤者 = 当前楼层怪物映射.get(怪物实例.临时召唤者索引) || null;
                        if (怪物实例.临时召唤者索引 !== null && !怪物实例.召唤者) console.warn(`幽灵仆从 ${索引} 的召唤者索引 ${怪物实例.临时召唤者索引} 未找到`);
                        delete 怪物实例.临时召唤者索引;
                    }
                    if (怪物实例 instanceof 大魔法师 && 怪物实例.临时分身索引 !== undefined) {
                        怪物实例.分身 = 当前楼层怪物映射.get(怪物实例.临时分身索引) || null;
                        if (怪物实例.临时分身索引 !== null && !怪物实例.分身) console.warn(`大魔法师 ${索引} 的分身索引 ${怪物实例.临时分身索引} 未找到`);
                        delete 怪物实例.临时分身索引;
                    }
                    if (怪物实例 instanceof 旋风怪物 && 怪物实例.临时召唤物索引列表) {
                        怪物实例.当前召唤物列表 = 怪物实例.临时召唤物索引列表
                            .map(召唤索引 => 当前楼层怪物映射.get(召唤索引))
                            .filter(旋 => 旋 instanceof 旋风); // 确保是旋风类型
                        delete 怪物实例.临时召唤物索引列表;
                    }

                    // 恢复状态效果到全局表
                    if (怪物实例.临时状态效果) {
                        const 状态数据 = 怪物实例.临时状态效果;
                        new 状态效果(
                            状态数据.类型, 状态数据.颜色, 状态数据.图标,
                            状态数据.持续时间, 状态数据.剩余回合,
                            null, 怪物实例, 状态数据.强度
                        ); // 这会添加到 怪物状态表
                        delete 怪物实例.临时状态效果;
                    }
                });


                // 6. 恢复炸弹列表 并 链接到地牢
                if (楼层存档数据.序列化物品列表) {
                    楼层数据.所有计时器 = 楼层存档数据.序列化物品列表
                        .map(炸弹数据 => {
                            let 实例 = 全局物品实例映射.get(炸弹数据.唯一标识符串);
                            if (!实例) {
                                实例 = 恢复物品(炸弹数据, 全局物品标识映射);
                                if (实例) 全局物品实例映射.set(炸弹数据.唯一标识符串, 实例);
                            }
                            return 实例;
                        })
                        .filter(b => b != null);
                }

                // 7. 恢复特殊物品引用 (宠物装备, 折跃门目标房间)
                for (const 物品实例 of 全局物品实例映射.values()) {
                    // 恢复宠物装备
                    if (物品实例 instanceof 宠物) {
                        const 装备标识 = 物品实例.自定义数据.get('装备标识') || {};
                        const 恢复后装备 = {};
                        for (const 槽位 in 装备标识) {
                            const 标识符串 = 装备标识[槽位];
                            if (标识符串) {
                                const 装备物品实例 = 全局物品实例映射.get(标识符串);
                                if (装备物品实例 && ((槽位 === '武器' && 装备物品实例 instanceof 武器类) || (槽位 === '防具' && 装备物品实例 instanceof 防御装备类))) {
                                    恢复后装备[槽位] = 装备物品实例;
                                } else {
                                    console.warn(`宠物 ${物品实例.名称} 的装备槽 ${槽位} 物品 ${标识符串} 未找到或类型不匹配`);
                                    恢复后装备[槽位] = null;
                                }
                            } else {
                                恢复后装备[槽位] = null;
                            }
                        }
                        物品实例.自定义数据.set('装备', 恢复后装备);
                        // delete 物品实例.自定义数据.get('装备标识'); // 可选：清理临时数据
                    }
                    // 恢复折跃门目标
                    else if (物品实例 instanceof 折跃门) {
                        const 目标房间ID = 物品实例.自定义数据.get('目标房间ID');
                        if (目标房间ID !== null && 目标房间ID !== undefined) {
                            const 目标房间 = 楼层数据.房间列表.find(r => r.id === 目标房间ID);
                            if (目标房间) {
                                物品实例.自定义数据.set('目标房间', 目标房间);
                            } else {
                                console.warn(`折跃门 ${物品实例.名称} 的目标房间ID ${目标房间ID} 未在本层找到`);
                                物品实例.自定义数据.set('目标房间', null);
                            }
                        } else {
                            物品实例.自定义数据.set('目标房间', null);
                        }
                        // delete 物品实例.自定义数据.get('目标房间ID'); // 可选
                    }
                    // 恢复商人/祭坛库存
                    else if (物品实例 instanceof 神秘商人 || 物品实例 instanceof 物品祭坛) {
                        const 库存序列化 = 物品实例.自定义数据.get('库存序列化') || [];
                        const 恢复后库存 = [];
                        库存序列化.forEach(物品数据 => {
                            let 库存物品实例 = 全局物品实例映射.get(物品数据.唯一标识符串);
                            if (!库存物品实例) {
                                库存物品实例 = 恢复物品(物品数据, 全局物品标识映射);
                                if (库存物品实例) 全局物品实例映射.set(物品数据.唯一标识符串, 库存物品实例);
                            }
                            if (库存物品实例) {
                                恢复后库存.push(库存物品实例);
                            }
                        });
                        物品实例.自定义数据.set('库存', 恢复后库存);
                        // delete 物品实例.自定义数据.get('库存序列化'); // 可选
                    }
                }


                console.log(`楼层 ${层号} 恢复完成`);
                return 楼层数据;

            } catch (e) {
                console.error(`恢复楼层 ${层号} 失败:`, e);
                return null;
            }
        }

        /**
        * 根据读取的存档数据恢复游戏状态 - 扩展版
        * @param {object} 存档数据
        */
        function 恢复游戏状态(存档数据) {
            console.log("开始恢复游戏状态...");
            if (!存档数据) {
                console.error("无效的存档数据，无法恢复。");
                显示通知("存档数据损坏，无法加载！", "错误");
                return;
            }

            // 0. 重置当前状态
            重置所有游戏状态();

            try {
                // 1. 恢复简单状态
                当前层数 = 存档数据.当前层数 ?? 0;
                玩家属性 = { ...初始玩家属性, ...(存档数据.玩家?.属性 || {}) };
                最大背包容量 = 存档数据.玩家?.最大背包容量 ?? 12;
                教程阶段 = 存档数据.教程?.阶段 ?? 0;
                最高教程阶段 = 存档数据.教程?.最高阶段 ?? 0;
                是否为教程层 = 存档数据.教程?.是否教程层 ?? false;
                hud模式 = 存档数据.UI?.hud模式 ?? "默认";
                显示模式 = 存档数据.UI?.显示模式 ?? "装备";
                卷轴模式激活 = 存档数据.UI?.卷轴模式激活 ?? false;
                已击杀怪物数 = 存档数据.游戏统计?.已击杀怪物数 ?? 0;
                日志历史 = 存档数据.UI?.日志历史 || [];

                日志历史.forEach(log => 添加日志(log.内容, log.类型));
                击杀提示.更新({ 内容: `已击杀怪物: ${已击杀怪物数}` });

                // 2. 准备全局映射
                const 全局物品实例映射 = new Map(); // string -> instance
                const 全局物品标识映射 = new Map(); // string -> symbol

                // 3. 恢复背包物品实例
                玩家背包 = new Map();
                if (存档数据.玩家?.背包) {
                    存档数据.玩家.背包.forEach(物品数据 => {
                        const 实例 = 恢复物品(物品数据, 全局物品标识映射);
                        if (实例) {
                            玩家背包.set(实例.唯一标识, 实例);
                            全局物品实例映射.set(物品数据.唯一标识符串, 实例);
                        }
                    });
                }

                // 4. 恢复装备物品 (链接引用)
                玩家装备 = new Map();
                if (存档数据.玩家?.装备) {
                    存档数据.玩家.装备.forEach(装备数据 => {
                        const 实例 = 全局物品实例映射.get(装备数据.唯一标识符串);
                        if (实例) {
                            实例.已装备 = true;
                            实例.装备槽位 = 装备数据.槽位;
                            玩家装备.set(实例.装备槽位, 实例);
                        } else {
                            console.warn(`装备槽 ${装备数据.槽位} 的物品 ${装备数据.唯一标识符串} 未恢复`);
                        }
                    });
                }

                // 5. 恢复所有楼层数据
                所有地牢层 = new Map();
                if (存档数据.所有地牢层数据) {
                    for (const [层号Str, 楼层存档] of Object.entries(存档数据.所有地牢层数据)) {
                        const 层号 = parseInt(层号Str);
                        if (!isNaN(层号) && 楼层存档) {
                            const 恢复后楼层 = 恢复楼层(层号, 楼层存档, 全局物品实例映射, 全局物品标识映射);
                            if (恢复后楼层) {
                                所有地牢层.set(层号, 恢复后楼层);
                            }
                        }
                    }
                }

                传送点列表 = 存档数据.传送点列表 || [];
                // 6. 加载当前楼层数据
                if (所有地牢层.has(当前层数)) {
                    const 当前楼层数据 = 所有地牢层.get(当前层数);
                    地牢 = 当前楼层数据.地牢数组;
                    房间列表 = 当前楼层数据.房间列表;
                    上锁房间列表 = 当前楼层数据.上锁房间列表;
                    已访问房间 = 当前楼层数据.已访问房间;
                    房间地图 = 当前楼层数据.房间地图;
                    门实例列表 = 当前楼层数据.门实例列表;
                    所有怪物 = 当前楼层数据.所有怪物;
                    所有计时器 = 当前楼层数据.所有计时器;
                    玩家初始位置 = 当前楼层数据.玩家初始位置;
                    当前天气效果 = 当前楼层数据.当前天气效果;
                    // 恢复玩家位置
                    玩家.x = 存档数据.玩家?.x ?? 玩家初始位置.x;
                    玩家.y = 存档数据.玩家?.y ?? 玩家初始位置.y;

                    // 填充怪物状态表
                    怪物状态表 = new WeakMap(); // 重置状态表
                    所有怪物.forEach(怪物 => {
                        const 怪物存档数据 = 存档数据.所有地牢层数据[当前层数]?.序列化怪物列表?.find(m => 怪物.x === m.配置.x && 怪物.y === m.配置.y); // 简陋匹配
                        if (怪物存档数据?.状态效果) {
                            const 效果 = new 状态效果(
                                怪物存档数据.状态效果.类型, 怪物存档数据.状态效果.颜色, 怪物存档数据.状态效果.图标,
                                怪物存档数据.状态效果.持续时间, 怪物存档数据.状态效果.剩余回合,
                                null, 怪物, 怪物存档数据.状态效果.强度
                            );
                            // 添加到 WeakMap (状态效果构造函数会自动处理)
                        }
                    });

                } else {
                    // 存档中没有当前层数据，重新生成
                    console.warn(`存档中未找到当前层 ${当前层数} 的数据，将重新生成！`);
                    房间列表 = []; 上锁房间列表 = []; 所有怪物 = []; 所有计时器 = [];
                    已访问房间 = new Set(); 门实例列表 = new Map();
                    房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
                    生成地牢();
                    玩家.x = 玩家初始位置.x;
                    玩家.y = 玩家初始位置.y;
                    if (房间列表.length > 0) 已访问房间.add(房间列表[0].id);
                }


                // 7. 恢复玩家状态 (现在全局物品映射完整)
                玩家状态 = [];
                if (存档数据.玩家?.状态) {
                    存档数据.玩家.状态.forEach(状态数据 => {
                        let 来源实例 = null;
                        if (状态数据.来源标识符串) {
                            来源实例 = 全局物品实例映射.get(状态数据.来源标识符串);
                            if (!来源实例) console.warn(`玩家状态 ${状态数据.类型} 的来源 ${状态数据.来源标识符串} 未找到`);
                        }
                        const 效果 = new 状态效果(
                            状态数据.类型, 状态数据.颜色, 状态数据.图标,
                            状态数据.持续时间, 状态数据.剩余回合,
                            来源实例, null, 状态数据.强度
                        );
                    });
                }


                // 8. 恢复当前激活卷轴 (现在全局物品映射完整)
                当前激活卷轴列表 = new Set();
                if (存档数据.UI?.激活卷轴列表) {
                    存档数据.UI.激活卷轴列表.forEach(标识符串 => {
                        const 实例 = 全局物品实例映射.get(标识符串);
                        if (实例 instanceof 卷轴类) {
                            当前激活卷轴列表.add(实例);
                            // 应用卷轴的持续效果 (如果需要)
                            实例.使用(); // 假设 use() 会应用效果并且不消耗资源（因为是恢复）
                        } else {
                            console.warn(`激活卷轴列表中的标识 ${标识符串} 实例无效或不是卷轴`);
                        }
                    });
                }
                const 保存的生命百分比 = 存档数据.玩家?.当前生命值百分比 ?? 100;
                const 保存的能量百分比 = 存档数据.玩家?.当前能量值百分比 ?? 100;
                const healthBar = document.querySelector(".health-bar");
                const powerBar = document.querySelector(".power-bar");
                if (healthBar) {
                    healthBar.style.width = `${Math.max(0, Math.min(100, 保存的生命百分比))}%`;
                    // 恢复低血量警告状态
                    if (保存的生命百分比 <= 20) healthBar.classList.add("低数值警告");
                    else healthBar.classList.remove("低数值警告");
                }
                if (powerBar) {
                    powerBar.style.width = `${Math.max(0, Math.min(100, 保存的能量百分比))}%`;
                    // 恢复低能量警告状态 (如果需要)
                    if (保存的能量百分比 <= 20) powerBar.classList.add("低数值警告");
                    else powerBar.classList.remove("低数值警告");
                }
                // 9. 刷新UI和游戏画面
                初始化canvas();
                更新视口();
                更新背包显示(); // 现在物品状态完整
                更新装备显示(); // 现在装备状态完整
                更新界面状态();
                更新物体指示器(); // 现在怪物位置和状态完整
                所有怪物.forEach(m => m.绘制血条());
                绘制();
                动画帧();

                // 恢复 UI 状态
                const 按钮图标映射 = { 默认: 图标映射.HUD智能, 常显: 图标映射.HUD常显, 常隐: 图标映射.HUD常隐 };
                document.getElementById("hudToggle").textContent = 按钮图标映射[hud模式] || 图标映射.HUD智能;
                if (hud模式 === "常显") document.querySelector(".hud").classList.add("可见");
                else if (hud模式 === "常隐") document.querySelector(".hud").classList.remove("可见");

                const 切换按钮 = document.getElementById("切换显示按钮");
                if (显示模式 === '小地图') 切换按钮.textContent = "装备栏";
                else 切换按钮.textContent = "小地图";
                if (window.innerWidth < 769) {
                    if (显示模式 === "装备") {
                        document.getElementById("小地图容器")?.classList.add("隐藏");
                        document.querySelector(".装备栏")?.classList.remove("隐藏");
                    } else {
                        document.getElementById("小地图容器")?.classList.remove("隐藏");
                        document.querySelector(".装备栏")?.classList.add("隐藏");
                    }
                } else {
                    document.getElementById("小地图容器")?.classList.remove("隐藏");
                    document.querySelector(".装备栏")?.classList.remove("隐藏");
                }
                // 恢复卷轴按钮的闪烁状态
                document.querySelectorAll(".装备槽").forEach((槽位) => {
                    const 物品元素 = 槽位.querySelector(".物品条目");
                    if (物品元素 && 物品元素.__物品实例 instanceof 卷轴类) {
                        if (当前激活卷轴列表.has(物品元素.__物品实例)) {
                            物品元素.classList.add("卷轴闪烁");
                        } else {
                            物品元素.classList.remove("卷轴闪烁");
                        }
                    }
                });


                console.log("游戏状态恢复完成 ！");

            } catch (错误) {
                console.error("恢复游戏状态时发生严重错误:", 错误);
                显示通知("加载存档时发生严重错误，将开始新游戏。", "错误");
                显示主菜单();
            }
        }

        function 导出存档() {
            if (是否为教程层) {
                显示通知("不支持在教程关卡导出存档", "错误");
                return;
            }
            const 存档字符串 = 保存游戏状态(); // 调用只返回字符串的版本
            if (存档字符串) {
                const 数据块 = new Blob([存档字符串], { type: 'application/json' });
                const 下载链接 = URL.createObjectURL(数据块);
                const 链接元素 = document.createElement('a');
                链接元素.href = 下载链接;
                // 文件名包含日期和时间戳
                const 时间戳 = new Date().toISOString().replace(/[:.]/g, '-');
                链接元素.download = `中文地牢存档_${时间戳}.json`;
                document.body.appendChild(链接元素);
                链接元素.click(); // 模拟点击下载
                document.body.removeChild(链接元素); // 清理 DOM
                URL.revokeObjectURL(下载链接); // 释放对象 URL
                显示通知("存档已导出为文件。", "成功"); // 导出成功提示
            } else {
                显示通知("导出存档失败！", "错误"); // 保存失败时提示
            }
        }

        function 导入存档(存档字符串) {
            try {
                const 存档数据 = JSON.parse(存档字符串);
                // 在这里可以添加更严格的存档数据结构验证
                if (存档数据 && 存档数据.版本) {
                    if (存档数据.版本 === 存档版本) {
                        启动游戏(存档数据);
                    } else {
                        显示通知("存档版本不匹配！", "错误");
                    }
                } else {
                    显示通知("存档数据无效或缺少版本信息！", "错误");
                }
            } catch (错误) {
                console.error("导入存档失败:", 错误);
                显示通知("导入存档失败，数据格式错误或损坏！", "错误");
            }
        }
        // --- 菜单按钮事件监听 ---
        新建游戏按钮.addEventListener('click', () => {
            启动游戏();
        });

        读取存档按钮.addEventListener('click', () => {
            const 文件输入控件 = document.getElementById('存档文件输入');
            文件输入控件.value = ''; // 清空，确保 change 事件触发
            文件输入控件.click(); // 打开文件选择对话框
        });
        // 启用按钮
        读取存档按钮.disabled = false;

        // --- 新增：处理文件选择 ---
        const 存档文件输入控件 = document.getElementById('存档文件输入');
        存档文件输入控件.addEventListener('change', (事件) => {
            const 选择的文件 = 事件.target.files[0];
            if (!选择的文件) {
                return; // 用户取消
            }

            if (!选择的文件.name.toLowerCase().endsWith('.json')) {
                显示通知("请选择有效的 JSON 存档文件！", "错误");
                return;
            }

            const 文件阅读器 = new FileReader();

            文件阅读器.onload = (读取事件) => {
                const 存档字符串 = 读取事件.target.result;
                导入存档(存档字符串); // 调用导入函数处理文件内容
            };

            文件阅读器.onerror = (错误事件) => {
                console.error("读取文件时出错:", 错误事件);
                显示通知("读取存档文件失败！", "错误");
            };

            文件阅读器.readAsText(选择的文件); // 读取文件内容为文本
        });

        读凭证按钮.addEventListener('click', () => {
            const 凭证 = prompt("请输入死亡凭证:");
            if (凭证) {
                const parts = 凭证.split('-');
                if (parts.length === 3) {
                    const L = parseInt(parts[0]);
                    if (!isNaN(L) && 验证死亡凭证(凭证, L)) {
                        alert(`凭证有效！记录最高层数：${L}`);

                    } else {
                        alert("无效的死亡凭证！");
                    }
                } else {
                    alert("凭证格式错误！");
                }

            }
        });

        图鉴按钮.addEventListener('click', () => {
            显示通知("图鉴功能正在开发中...", "信息");

        });

        //初始化canvas();
        //初始化装备系统();
        if (window.innerWidth < 769) {
            document.getElementById("小地图容器").classList.add("隐藏");
        }
        当前层数 = null;
        显示主菜单();
        注册全局类();
        //进入教程层();
        //切换楼层(0);
        //更新背包显示();
        //更新界面状态();
        //动画帧(); // 启动动画循环
    </script>
</body>

</html>