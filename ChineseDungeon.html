<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, minimum-scale=0.5" />
    <title>Dungeon Game</title>
    <style>
        /*或哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈*/
        /* General Styles */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            margin: 0;
            padding-top: 5vh;
            background: linear-gradient(160deg, #0a0a0a 0%, #1a1a1a 100%);
            background-color: #1a1a1a;
            overflow: hidden;
            justify-content: flex-start;
        }

        /*隐藏滚轮*/
        ::-webkit-scrollbar {
            display: none;
        }

        /* 不可选中 */
        .不可选中 {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Dungeon Canvas */
        #dungeonCanvas {
            border: 2px solid #2e2e2e;
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
            margin-bottom: 5vh;
            transition: transform 0.15s ease-out;
            filter:
                contrast(1.1) brightness(1.1);
        }

        /* --- HUD --- */
        .hud {
            position: absolute;
            top: 5px;
            left: 5px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px;
            border-radius: 8px;
            font-family: Arial;
            display: flex;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            min-width: 180px;
            flex-direction: column;
        }

        .hud.可见 {
            opacity: 1;
            pointer-events: auto;
        }

        /* --- 地图实体 --- */
        .怪物图标 {
            position: absolute;
            font-size: 1.2em;
            text-shadow: 0 0 8px #ff0000;
            transition: transform 0.2s;
        }

        /* 扣血特效 */
        .扣血遮罩 {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            animation: 扣血脉冲 0.8s ease-out;
        }

        @keyframes 扣血脉冲 {
            0% {
                opacity: 0.8;
            }

            100% {
                opacity: 0;
            }
        }

        .怪物指示器 {
            position: fixed;
            left: 0;
            top: 0;
            width: 12px;
            height: 12px;
            background: #ff4444;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.8);
            pointer-events: none;
            transition: transform 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            z-index: 1000;
        }

        /* 调整触发按钮样式 */
        #hudToggle {
            width: 6vmin;
            height: 6vmin;
            font-size: 3vmin;
            background: #2196f3;
            position: absolute;
            left: 48%;
            transform: translateX(-50%);
            bottom: 120%;
            z-index: 1000;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            /* 增加条目间距 */
        }

        .hud-icon {
            font-family: "color-emoji";
            font-size: 1.2em;
            width: 24px;
            text-align: center;
        }

        .hud-bar-container {
            position: relative;
            flex-grow: 1;
            height: 14px;
            margin-top: 4px;
            /* 进度条与图标间距 */
            height: 18px;
            /* 增大容器高度 */
        }

        .health-bar {
            background: linear-gradient(to right, #ff4444, #ff7676);
        }

        .power-bar {
            background: linear-gradient(to right, #1554db, #2c73f7);
        }

        .hud-label {
            color: #4caf50;
            font-size: 0.9em;
        }

        .怪物数量警告 {
            color: #ff4444;
        }

        .界面文本行 {
            color: #4caf50;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
        }

        .进度条标签 {
            position: absolute;
            left: 4px;
            /* 改为左侧定位 */
            white-space: nowrap;
            bottom: 1px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.75em;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            z-index: 2;
            /* 确保文字在上层 */
        }

        .hud-bar {
            position: relative;
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        @keyframes 进度条呼吸 {
            0% {
                opacity: 0.9;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 0.9;
            }
        }

        .低数值警告 {
            animation: 进度条呼吸 1.5s ease infinite;
        }

        /* --- Control Panel --- */
        .control-pad {
            position: fixed;
            left: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Directional Buttons Container */
        #方向键容器 {
            position: fixed;
            left: 20px;
            top: 50%;
            display: flex;
            /* Added for better button arrangement */
            gap: 1rem;
            /* Added for spacing between buttons */
        }

        .control-row {
            display: flex;
            justify-content: center;
            margin: 5px 0;
            gap: 1.2rem;
        }

        .control-btn {
            font-family: "color-emoji";
            width: 15vmin;
            height: 15vmin;
            border-radius: 3vmin;
            margin: 0 2px;
            font-size: 4vmin;
            background: linear-gradient(145deg,
                    rgba(76, 175, 80, 0.9) 30%,
                    rgba(67, 160, 71, 0.9) 100%);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
            color: white;
            border: 2px solid #fff;
            opacity: 0.95;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .control-btn:active {
            background: #45a049;
            transform: scale(0.9);
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.8);
        }

        #upBtn {
            margin-bottom: -12px;
            z-index: 2;
        }

        #leftBtn,
        #rightBtn {
            margin-left: -64px;
            margin: 0 1rem;
        }

        #downBtn {
            margin-top: -12px;
            z-index: 1;
        }

        #背包按钮 {
            /* Backpack Button */
            background: #2196f3;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
        }

        /* --- Inventory (背包) --- */
        .背包弹窗 {
            /* Inventory Popup */
            position: fixed;
            bottom: -600px;
            left: 50%;
            transform: translateX(-50%);
            width: 80vmin;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 12px;
            padding: 15px;
            transition: bottom 0.3s ease;
            z-index: 1001;
            max-height: 50vh;
            display: flex;
            flex-direction: column;
        }

        .背包弹窗.显示中 {
            bottom: 12vh;
        }

        .弹窗头部 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .弹窗头部 h3 {
            color: #4caf50;
            margin: 0;
            font-size: 1.2em;
        }

        .关闭按钮 {
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            padding: 8px;
        }

        .物品容器 {
            flex: 1;
            overflow-y: auto;
            padding: 5px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 8px;
        }

        .物品条目 {
            position: relative;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hover:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .物品图标 {
            font-family: "color-emoji";
            font-size: 2em;
            text-align: center;
            margin-bottom: 8px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
            transition: transform 0.3s;
        }

        .汉字图标 {
            font-family: "Microsoft YaHei", sans-serif;
            font-weight: bold;
            font-size: 1.2em;
        }

        .hover:hover .物品图标 {
            transform: scale(1.2) rotate(-15deg);
        }

        .物品名称 {
            font-size: 0.9em;
            text-align: center;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .物品堆叠 {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: linear-gradient(45deg,
                    rgba(0, 0, 0, 0.6),
                    rgba(50, 50, 50, 0.8));
            color: #fff;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .装备按钮,
        .销毁按钮,
        .使用按钮 {
            font-family: "color-emoji";
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: none;
            color: white;
            cursor: pointer;
            opacity: 0;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .装备按钮 {
            bottom: 3px;
            left: 3px;
            background: #ff9800;
        }

        .销毁按钮 {
            top: 3px;
            right: 3px;
            background: #ff4444;
        }

        .销毁按钮 {
            z-index: 3;
            width: 24px !important; //js说使用!important是个坏习惯,正好我也是个坏人
            height: 24px !important;
            font-size: 16px !important;
            padding: 0 !important;
            display: flex !important;
            align-items: center;
            justify-content: center;
        }

        .使用按钮 {
            top: 3px;
            left: 3px;
            background: #4caf50;
        }

        .物品条目:hover .装备按钮,
        .物品条目:hover .销毁按钮,
        .物品条目:hover .使用按钮 {
            opacity: 1;
        }

        .物品条目.active .物品图标 {
            transform: scale(1.2) rotate(-15deg);
        }

        .冷却标签 {
            position: absolute;
            bottom: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8em;
        }

        .耐久标签 {
            position: absolute;
            bottom: 2px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8em;
            z-index: 2;
        }

        /* 怪物血条 */
        .怪物血条 {
            position: fixed;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            pointer-events: none;
            z-index: 100;
        }

        .血条背景 {
            height: 100%;
            background: #444;
        }

        .当前血量 {
            height: 100%;
            background: #f00;
            transition: width 0.3s;
        }

        /* 死亡动画 */
        .骷髅图标 {
            font-family: "color-emoji";
            font-size: 80px;
            animation: 骷髅抖动 1s infinite;
        }

        .死亡文字 {
            color: white;
            font-size: 40px;
            text-shadow: 0 0 10px red;
            margin-top: 20px;
        }

        .重生选项 {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .重生按钮 {
            font-family: "color-emoji";
            padding: 12px 24px;
            font-size: 18px;
            border: 2px solid #fff;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .重生按钮:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .死亡内容 {
            text-align: center;
            animation: 死亡浮现 1s ease-out;
        }

        #死亡遮罩 {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(45deg,
                    rgba(20, 0, 0, 0.9) 0%,
                    rgba(60, 0, 0, 0.95) 100%);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            animation: 界面浮现 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes 界面浮现 {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .死亡内容容器 {
            font-family: "color-emoji";
            background: rgba(10, 0, 0, 0.8);
            border: 2px solid #ff444480;
            border-radius: 16px;
            padding: 40px 60px;
            box-shadow: 0 0 40px rgba(255, 50, 50, 0.3);
            text-align: center;
        }

        .骷髅容器 {
            position: relative;
            margin-bottom: 30px;
        }

        .动态骷髅 {
            font-size: 6rem;
            text-shadow: 0 0 30px #ff0000;
            animation: 骷髅呼吸 2s ease-in-out infinite;
            display: inline-block;
        }

        @keyframes 骷髅呼吸 {
            0% {
                transform: scale(1) rotate(-5deg);
                opacity: 0.9;
            }

            50% {
                transform: scale(1.1) rotate(5deg);
                opacity: 1;
            }

            100% {
                transform: scale(1) rotate(-5deg);
                opacity: 0.9;
            }
        }

        .重生选项 {
            font-family: "color-emoji";
            display: grid;
            gap: 20px;
            margin-top: 30px;
        }

        .重生按钮 {
            font-family: "color-emoji";
            padding: 16px 32px;
            font-size: 1.2rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(145deg,
                    rgba(100, 0, 0, 0.8),
                    rgba(150, 0, 0, 0.6));
            color: #fff;
            position: relative;
            overflow: hidden;
            border: 1px solid #ff4444;
        }

        .重生按钮::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(255, 255, 255, 0.2),
                    transparent);
            transition: 0.5s;
        }

        .重生按钮:hover::before {
            left: 100%;
        }

        .重生按钮:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 50, 50, 0.4);
        }

        .重生按钮:active {
            transform: translateY(1px);
        }

        #重新开始 {
            background: linear-gradient(145deg,
                    rgba(50, 50, 50, 0.8),
                    rgba(30, 30, 30, 0.6));
            border-color: #666;
        }

        @keyframes 粒子飘落 {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 0.8;
            }

            100% {
                transform: translate(${Math.random() * 100 - 50}px, 100vh) scale(0);
                opacity: 0;
            }
        }

        /* 添加点击态样式 */
        .物品条目.active {
            background: rgba(255, 255, 255, 0.2) !important;
            transform: translateY(-2px) !important;
        }

        .物品条目.active .装备按钮,
        .物品条目.active .销毁按钮,
        .物品条目.active .使用按钮 {
            opacity: 1 !important;
        }

        .物品条目[data-quality="1"] {
            border: 1px solid #00ff00;
        }

        .物品条目[data-quality="2"] {
            border: 1px solid #0000ff;
        }

        .物品条目[data-quality="3"] {
            border: 1px solid #ffff00;
        }

        .物品条目[data-quality="4"] {
            animation: 紫光脉动 2s infinite;
        }

        @keyframes 紫光脉动 {

            0%,
            100% {
                box-shadow: 0 0 12px rgba(224, 64, 251, 0.3);
            }

            50% {
                box-shadow: 0 0 24px rgba(224, 64, 251, 0.6);
            }
        }

        .物品条目[data-quality="5"] {
            animation: 红光脉动 2s infinite;
        }

        @keyframes 红光脉动 {

            0%,
            100% {
                box-shadow: 0 0 12px #ff0000;
            }

            50% {
                box-shadow: 0 0 24px #ff0000;
            }
        }


        .装备栏 {
            transition: opacity 0.3s ease;
            position: fixed;
            right: 20px;
            top: 75%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 12px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            z-index: 1000;
        }

        .装备槽 {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .冷却遮罩 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            clip-path: inset(0 0 100% 0);
            transition: clip-path 0.22s linear;
            pointer-events: none;
        }

        .装备槽 .物品条目 {
            transform: scale(0.75) translateY(-3px);
            margin: -5px 0;
        }

        .装备槽:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* --- Staircase (楼梯) --- */
        .楼梯 {
            background-color: #4a4a4a;
            font-size: 1.5em;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* --- Tooltip (浮动提示框) --- */
        #浮动提示框 {
            /* Tooltip */
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-family: Arial;
            font-size: 12px;
            max-width: 200px;
            pointer-events: none;
            z-index: 1002;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: none;
            line-height: 1.4;
        }

        #浮动提示框 br {
            margin: 4px 0;
            content: "";
            display: block;
        }

        /* --- Level Transition (楼层过渡遮罩) --- */
        .楼层过渡遮罩 {
            /* Level Transition Overlay */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .层数标题 {
            /* Level Number Title */
            color: #ffffff;
            font-size: 4em;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            opacity: 0;
            transform: scale(3);
            transition: all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            font-family: "Arial Black", sans-serif;
            letter-spacing: 4px;
        }

        /* --- Notifications (通知) --- */
        .通知容器 {
            /* Notification Container */
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 99999;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            font-family: Arial, "微软雅黑";
        }

        .通知条目 {
            /* Notification Item */
            background: rgba(40, 40, 40, 0.95);
            color: #e0e0e0;
            padding: 12px 24px;
            border-radius: 6px;
            min-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border-left: 4px solid;
            opacity: 0;
            transform: translateY(-30px);
            animation: 通知入场 0.3s ease-out forwards;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.2s linear;
            display: flex;
            align-items: center;
            gap: 12px;
            backdrop-filter: blur(5px);
        }

        .通知条目.离场 {
            /* Leaving Notification */
            animation: 通知离场 0.3s ease-in forwards;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                opacity 0.2s linear;
        }

        @keyframes 通知入场 {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes 通知离场 {
            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        .通知条目.成功 {
            border-color: #4caf50;
        }

        .通知条目.警告 {
            border-color: #ff9800;
        }

        .通知条目.错误 {
            border-color: #f44336;
        }

        .通知条目.信息 {
            border-color: #2196f3;
        }

        .通知图标 {
            font-family: "color-emoji";
            width: 24px;
            height: 24px;
            flex-shrink: 0;
        }

        .关闭按钮 {
            font-family: "color-emoji";
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            margin-left: auto;
            padding-left: 20px;
            transition: color 0.2s;
        }

        .关闭按钮:hover {
            color: #fff;
        }

        /* --- Responsive Design --- */
        #小地图容器 {
            position: absolute;
            transform: translateY(-50%);
            transition: opacity 0.3s ease, transform 0.3s ease;
            mix-blend-mode: lighten;
        }

        #小地图容器:hover {
            mix-blend-mode: normal;
        }

        #跳过教程按钮 {
            font-size: 0.8em;
            display: block;
            position: fixed;
            top: 185px;
            right: 22px;
            height: 5vmin;
        }

        @media (min-width: 769px) {
            .control-pad {
                display: none;
            }

            .control-btn {
                display: none;
            }

            .control-row {
                display: none;
            }

            #小地图容器 {
                position: fixed;
                top: 20px;
                right: 20px;
                transform: none;
            }

            #跳过教程按钮 {
                top: 185px;
            }

            .装备栏 {
                position: fixed;
                right: 20px;
                top: 75%;
                transform: translateY(-50%);
            }
        }

        @media (max-width: 768px) {
            .control-pad {
                display: flex;
            }

            .control-btn {
                display: flex;
            }

            .control-row {
                display: flex;
            }

            #跳过教程按钮 {
                top: 10px;
            }

            #小地图容器,
            .装备栏 {
                right: 20px;
                top: 75%;
            }
        }

        canvas {
            mix-blend-mode: lighten;
        }

        /* 烟花动画 */
        @keyframes 烟花炸裂 {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translate(calc(var(--tx) * 100px),
                        calc(var(--ty) * 100px)) scale(0);
                opacity: 0;
            }
        }

        .烟花粒子 {
            font-family: "color-emoji";
            position: fixed;
            z-index: 99999;
            font-size: 1.2em;
            animation: 烟花炸裂 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            pointer-events: none;
        }

        @keyframes 收集脉冲 {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
                opacity: 1;
                text-shadow:
                    0 0 30px var(--辉光颜色),
                    0 0 40px var(--辉光颜色);
            }

            100% {
                transform: scale(1);
                opacity: 0;
                text-shadow:
                    0 0 10px var(--辉光颜色),
                    0 0 20px var(--辉光颜色);
            }
        }

        .收集特效 {
            font-family: "color-emoji";
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            z-index: 99998;
            animation: 收集脉冲 1.1s ease-out forwards;
            text-shadow: 0 0 10px var(--辉光颜色);
        }

        /*卷轴类待点击动画*/
        .卷轴闪烁 {
            animation: 卷轴脉冲 0.8s ease-in-out infinite;
            position: relative;
        }

        @keyframes 卷轴脉冲 {
            0% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
                background: rgba(255, 215, 0, 0.1);
            }

            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
                background: rgba(255, 215, 0, 0.3);
            }

            100% {
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
                background: rgba(255, 215, 0, 0.1);
            }
        }

        .卷轴闪烁::after {
            content: "";
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border-radius: 8px;
            background: linear-gradient(45deg,
                    rgba(255, 215, 0, 0.3) 0%,
                    rgba(255, 215, 0, 0.1) 50%,
                    rgba(255, 215, 0, 0.3) 100%);
            z-index: -1;
            animation: 光晕扩散 1.2s infinite;
        }

        @keyframes 光晕扩散 {
            0% {
                opacity: 0.8;
            }

            100% {
                opacity: 0;
            }
        }

        /* 日志容器 */
        .日志面板 {
            position: fixed;
            right: 20px;
            bottom: -600px;
            width: 250px;
            height: 200px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 8px;
            padding: 12px;
            transition: bottom 0.3s ease;
            color: #c0c0c0;
            display: flex;
            flex-direction: column;
        }

        .日志内容 {
            flex: 1;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.4;
            scrollbar-width: thin;
            scrollbar-color: #4caf50 #2a2a2a;
        }

        .日志面板.可见 {
            bottom: 135px;
        }

        .日志内容 .成功 {
            color: green;
        }

        .日志内容 .错误 {
            color: red;
        }

        .日志内容 .警告 {
            color: yellow;
        }

        /* 滚动条样式 */
        .日志内容::-webkit-scrollbar {
            width: 6px;
        }

        .日志内容::-webkit-scrollbar-track {
            background: #2a2a2a;
        }

        .日志内容::-webkit-scrollbar-thumb {
            background: #4caf50;
            border-radius: 3px;
        }

        @keyframes 爆炸闪烁 {
            0% {
                transform: scale(0);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }

            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        /* NPC-------流浪奸商 */
        #交易窗口 {
            background: rgba(0, 0, 0, 0.9);
            display: none;
            border: 2px solid #4a4a4a;
            color: #e0e0e0;
            width: 400px;
            position: fixed;
            z-index: 101;
            /* 怪物血条Z:100 */
        }

        .库存列表 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 10px;
        }

        .交易物品条目 {
            background: #1a1a1a;
            padding: 10px;
            border: 1px solid #2b2b2b;
            cursor: pointer;
            transition: all 0.2s;
        }

        .交易物品条目:hover {
            border-color: #4a90e2;
            background: #2b2b2b;
        }

        .物品价格 {
            color: #ffd700;
            font-size: 0.9em;
        }

        .交易底部 {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-top: 1px solid #333;
        }

        /* 附魔系统 */
        .附魔弹窗 {
            font-family: "color-emoji";
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #2a0a3a 0%, #1a1a2f 100%);
            border: 2px solid #634b7d;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 40px #6b2fa070;
            z-index: 10000;
            min-width: 400px;
            max-width: 90vw;
            backdrop-filter: blur(5px);
            animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .附魔弹窗.关闭中 {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            pointer-events: none;
        }

        @keyframes 弹窗浮现 {
            from {
                opacity: 0;
                transform: translate(-50%, -45%) scale(0.9);
                /* 初始缩小并偏移 */
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
                /* 恢复原大小和位置 */
            }
        }

        .附魔头 {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #4a3560;
        }

        .附魔标题 {
            color: #c792ea;
            font-size: 1.4em;
            text-shadow: 0 0 10px #c792ea80;
            font-family: '微软雅黑', sans-serif;
        }

        .附魔装备容器 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 20px;
        }

        .可附魔 {
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            background: #2d1b3c;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #4a3560;
        }

        .可附魔:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 25px #c792ea80;
            background: #3a254d;
        }

        .可附魔:hover .物品图标 {
            animation: 装备浮动 1.5s ease-in-out infinite;
        }

        @keyframes 装备浮动 {
            0% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-5px);
            }

            100% {
                transform: translateY(0);
            }
        }

        .附魔特效 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .魔幻粒子 {
            will-change: transform, opacity;
            filter: blur(2px);
            mix-blend-mode: screen;
            position: absolute;
            width: var(--size);
            height: var(--size);
            border-radius: 50%;
            background: hsla(var(--hue), 80%, var(--lightness), 0.8);
            animation:
                粒子脉动 1.2s var(--delay) both,
                光晕闪烁 1.4s var(--delay) linear infinite;
        }

        @keyframes 粒子脉动 {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(0.3);
            }

            100% {
                opacity: 0;
                transform: translate(var(--target-x), var(--target-y)) scale(0.2);
            }
        }

        @keyframes 光晕闪烁 {

            0%,
            100% {
                box-shadow: 0 0 15px 3px hsl(var(--hue), 100%, 60%);
            }

            50% {
                box-shadow: 0 0 25px 6px hsl(var(--hue), 100%, 70%);
            }
        }


        .附魔确认按钮 {
            background: linear-gradient(145deg, #c792ea, #9c27b0);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.1em;
            margin-top: 20px;
            display: block;
            width: 100%;
        }

        .附魔确认按钮:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #c792ea80;
        }

        /* 关闭按钮优化 */
        .附魔弹窗 .关闭按钮 {
            background: none;
            border: none;
            color: #c792ea;
            font-size: 1.8em;
            cursor: pointer;
            transition: all 0.3s;
            padding: 5px;
            line-height: 1;
        }

        .附魔弹窗 .关闭按钮:hover {
            color: #ff4081;
            transform: rotate(90deg);
        }

        /* 移动端适配 */
        @media (max-width: 768px) {
            .附魔弹窗 {
                min-width: 300px;
                padding: 15px;
            }

            .附魔标题 {
                font-size: 1.2em;
            }

            .附魔装备容器 {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* 状态提示动画 */
        @keyframes 成功闪光 {
            0% {
                background-color: #4CAF5050;
            }

            50% {
                background-color: #4CAF5020;
            }

            100% {
                background-color: transparent;
            }
        }

        .附魔成功 {
            animation: 成功闪光 1.5s ease-out;
        }

        .重铸弹窗 {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1ae6;
            border: 2px solid #4a4a4a;
            border-radius: 12px;
            padding: 20px;
            width: 80vmin;
            max-width: 600px;
            color: #e0e0e0;
            z-index: 10000;
            box-shadow: 0 0 30px #00000080;
            animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transition:
                opacity 0.3s ease,
                transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }

        .重铸弹窗-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .重铸弹窗-column {
            flex: 1;
            padding: 10px;
        }

        .重铸弹窗-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            max-height: 50vh;
            overflow-y: auto;
            gap: 10px;
        }

        .重铸物品 {
            border: 1px solid #444;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            transform-origin: center;
            position: relative;
        }

        .重铸物品.selected {
            border-color: #4caf50;
            background: #2b2b2b;
            transform: scale(1.1);
            z-index: 1;
        }

        .重铸台耐久标签 {
            font-size: 0.8em;
            color: #888;
        }

        .重铸物品:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .重铸遮罩 {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(3px);
            z-index: 9999;
        }

        #repairCost {
            font-family: 'Arial Black';
            text-shadow: 0 0 5px currentColor;
            transition: color 0.3s ease;
        }

        /* 强化标识 */
        .重铸台强化标识 {
            position: absolute;
            top: 2px;
            right: 2px;
            color: #FFD700;
            font-size: 0.8em;
            text-shadow: 0 0 3px #FFD700;
        }

        /*------小地图-------*/
        #小地图 {
            position: relative;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #4caf50;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            background: rgba(0, 0, 0, 0.9);
            z-index: 999;
            image-rendering: pixelated;
        }

        #小地图:hover {
            mix-blend-mode: normal
        }

        .宠物管理窗口 {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1ae6;
            border: 2px solid #4a4a4a;
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 500px;
            color: #e0e0e0;
            z-index: 10000;
            box-shadow: 0 0 30px #00000080;
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            max-height: 80vh;
            overflow-y: auto;
        }

        .宠物遮罩 {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: 9999;
        }

        .宠物状态栏 {
            margin: 15px 0;
        }

        .条容器,
        .宠物经验条容器 {
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
        }

        .宠物血量条 {
            height: 100%;
            background: linear-gradient(90deg, #f44336, #ff7043);
            border-radius: 10px;
            transition: width 0.3s;
        }

        .宠物经验条 {
            height: 100%;
            background: linear-gradient(90deg, #2196f3, #4dabf5);
            border-radius: 10px;
            transition: width 0.3s;
        }

        .宠物血量文本,
        .宠物经验文本 {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 0.9em;
        }

        .宠物属性 {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            color: #ddd;
            font-size: 0.9em;
        }

        .宠物装备格子容器 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .宠物装备格子 {
            border: 1px solid #555;
            padding: 10px;
            border-radius: 5px;
            position: relative;
            min-height: 80px;
            background: #2b2b2b;
        }

        .宠物装备槽位名 {
            position: relative;
            top: 4px;
            left: 10px;
            padding: 0 5px;
            font-size: 0.8em;
            color: #aaa;
        }

        .宠物装备选择按钮,
        .宠物装备卸下按钮 {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.3);
            color: #fff;
            border: 2px solid #fff;
            opacity: 0.95;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            color: white;
            cursor: pointer;
            transition: background 0.2s;
            font-family: inherit;
        }

        .宠物装备卸下按钮 {
            background: linear-gradient(145deg, rgba(244, 67, 54, 0.9) 30%, rgba(206, 61, 49, 0.9) 100%);
            box-shadow: 0 4px 20px rgba(244, 67, 54, 0.3);
            position: absolute;
            bottom: 5px;
            right: 5px;
        }

        .宠物技能容器 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .宠物技能 {
            border: 1px solid #555;
            padding: 10px;
            border-radius: 5px;
            background-color: #333;
        }

        .宠物装备选择弹窗 {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1ae6;
            border: 2px solid #4a4a4a;
            border-radius: 12px;
            padding: 20px;
            width: 80%;
            max-width: 400px;
            color: #e0e0e0;
            z-index: 10001;
            box-shadow: 0 0 30px #00000080;
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            max-height: 75vh;
            overflow: scroll;
        }

        .可装备物品容器 {
            max-height: 60vh;
            overflow-y: auto;
            /* 滚动 */
            padding: 10px;
        }

        /* 可选装备样式 */
        .宠物可选装备 {
            display: flex;
            align-items: center;
            padding: 8px;
            border: 1px solid #2c3e50;
            border-radius: 6px;
            margin-bottom: 5px;
            background-color: #41586b;
            transition: background-color 0.2s;
        }

        .宠物可选装备:hover {
            background-color: #546e7a;
        }

        .宠物装备名称 {
            position: relative;
            top: 4px;
            left: 2px;
            padding: 0 5px;
            font-size: 0.8em;
            color: #aaa;
        }

        .宠物可选装备图标 {
            font-family: "color-emoji";
            margin-right: 10px;
            font-size: 1.2em;
        }

        .宠物装备图标 {
            font-family: "color-emoji";
        }

        .宠物装备选择弹窗 .关闭按钮 {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: #e74c3c;
            cursor: pointer;
            padding: 5px;
            z-index: 1;
        }

        .宠物装备选择确认按钮 {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
            color: #fff;
            border: none;
            border-radius: 5px;
            padding: 6px 12px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            font-family: inherit;
            margin-left: auto;
        }

        .宠物装备选择确认按钮:hover {
            background: linear-gradient(145deg, rgba(67, 160, 71, 0.9) 30%, rgba(58, 140, 62, 0.9) 100%);
            transform: translateY(-2px);
            /* 上浮效果 */
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
        }

        .通用按钮:hover {
            background: linear-gradient(145deg, rgba(67, 160, 71, 0.9) 30%, rgba(58, 140, 62, 0.9) 100%);
            transform: translateY(-2px);
            /* 上浮效果 */
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
        }

        .宠物装备选择确认按钮:active {
            transform: scale(0.95);
        }

        .宠物可选装备 {
            padding: 10px;
        }

        .可装备物品容器 {
            max-height: 65vh;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 10px;
        }

        .宠物管理窗口,
        .宠物装备选择弹窗 {
            animation: 弹窗浮现 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .宠物可选装备 {
            justify-content: space-between;
        }

        .宠物基本信息面板 p,
        .宠物技能面板 p {
            line-height: 1.6;
        }

        .宠物已装备物品 {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        /* 无装备提示 */
        .无装备提示,
        .无技能提示 {
            color: #aaa;
            text-align: center;
            padding: 20px;
        }

        .宠物管理窗口 .关闭按钮 {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            color: #e74c3c;
            cursor: pointer;
            transition: transform 0.3s;
            padding: 5px;
        }

        .宠物管理窗口 .关闭按钮:hover {
            color: #ff4081;
            transform: rotate(90deg);
            /* 旋转动画 */
        }

        .宠物管理窗口 .通用按钮 {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 4px 20px #4caf504d;
            color: #fff;
            border: 2px solid #fff;
            opacity: .95;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            font-family: inherit;
            margin-top: 10px;
            width: 100%;
        }

        .宠物血量标签 {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            white-space: nowrap;
            z-index: 1;
        }

        /* --------------教程---------------*/
        .教程提示窗口 {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #282828f2, #3a3a3af2);
            color: #e0e0e0;
            padding: 20px 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
            z-index: 10002;
            width: 85%;
            text-align: center;
            border: 2px solid #4caf50;
            animation: 弹窗浮现 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: none;
            font-family: "HarmonyOS Sans SC", "MiSans", system-ui, 'color-emoji';
        }

        .教程提示窗口 p {
            font-size: 1.1em;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .教程提示窗口 .关闭按钮 {
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 2px 8px #4caf5066;
            color: #fff;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-family: inherit;
        }

        .教程提示窗口 .关闭按钮:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px #4caf5080;
            background: linear-gradient(145deg, rgba(67, 160, 71, 0.9) 30%, rgba(58, 140, 62, 0.9) 100%);
        }

        .教程提示窗口.关闭中 {
            animation: 弹窗消失 0.3s ease-out forwards;
        }

        @keyframes 弹窗消失 {
            to {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
        }

        /* -----------设置----------*/
        .设置菜单 {
            position: fixed;
            bottom: -300px;
            left: 68%;
            transform: translateX(-50%);
            background: #000000e5;
            border-radius: 12px;
            padding: 15px;
            transition: bottom 0.3s ease;
            z-index: 1003;
            text-align: center;
        }


        .设置菜单 button {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 10px;
            background: linear-gradient(145deg, rgba(76, 175, 80, 0.9) 30%, rgba(67, 160, 71, 0.9) 100%);
            box-shadow: 0 4px 20px #4caf504d;
            color: #fff;
            border: 2px solid #fff;
            opacity: 0.95;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1em;
        }

        .设置菜单 button:active {
            background: #45a049;
            transform: scale(0.9);
            box-shadow: 0 0 5px #4caf50cc
        }

        .设置菜单.显示 {
            bottom: 110px;
        }

        .设置菜单.隐藏 {
            animation: 弹窗消失 0.3s ease-out forwards;
        }

        #小地图容器.隐藏,
        .装备栏.隐藏 {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-50%) scale(0.8);
        }

        @keyframes 扭曲 {
            0% {
                transform: scale(1) skew(0deg);
            }

            25% {
                transform: scale(1.1) skew(5deg);
            }

            50% {
                transform: scale(0.9) skew(-5deg);
            }

            75% {
                transform: scale(1.05) skew(2deg);
            }

            100% {
                transform: scale(1) skew(0deg);
                opacity: 0;
            }
        }

        /* -----------优化字体适配------------- */
        body,
        .hud,
        .控制按钮 {
            font-family: "HarmonyOS Sans SC", "MiSans", system-ui, "color-emoji";
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        @font-face {
            font-family: "color-emoji";
            src: local("Apple Color Emoji"),
                url('./AppleColorEmoji.woff') format('woff'),
                local("Segoe UI Emoji"),
                local("Segoe UI Symbol"),
                local("Noto Color Emoji"),
                local("Arial");
        }
    </style>
</head>

<body>
    <canvas id="dungeonCanvas"></canvas>
    <div id="教程提示窗口" class="教程提示窗口">
        <p id="教程提示内容"></p>
        <button class="关闭按钮" onclick="关闭教程提示()">我知道了</button>
    </div>
    <button id="跳过教程按钮" class="control-btn" onclick="跳过教程()">跳过</button>
    <div id="扣血特效" class="扣血遮罩"></div>
    <div id="怪物指示器容器"></div>
    <div class="装备栏">
        <div class="装备槽" id="装备槽1"></div>
        <div class="装备槽" id="装备槽2"></div>
        <div class="装备槽" id="装备槽3"></div>
        <div class="装备槽" id="装备槽4"></div>
    </div>
    <div class="control-pad 不可选中" style="z-index: 1000">
        <!-- 日志浮窗Z:1002 大于 悬浮提示Z:1002 背包Z：1001 控制钮Z：1000 设置钮Z：999-->
        <div class="control-row">
            <div class="control-btn" id="upBtn">↑</div>
        </div>
        <div class="control-row">
            <div class="control-btn" id="leftBtn">←</div>
            <div class="control-btn" id="rightBtn">→</div>
        </div>
        <div class="control-row">
            <div class="control-btn" id="downBtn">↓</div>
        </div>
        <div class="control-row">
            <button id="背包按钮" onclick="切换背包显示()" class="control-btn">
                🎒
            </button>
            <button class="control-btn" id="互动按钮" onclick="尝试互动()">
                ⚡
            </button>
            <button id="卷轴按钮" class="control-btn" onclick="激活卷轴模式()" style="
                        display: none;
                        background: linear-gradient(145deg, #ffd700, #ffaa00);
                        box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
                    ">
                📜
            </button>
            <button id="hudToggle" class="control-btn" style="position: absolute; bottom: 110%" onclick=切换HUD模式()>
                👁️
            </button>
        </div>
    </div>
    <div class=control-row style=right:23px;position:fixed;bottom:20px;z-index:999>
        <button id="设置按钮" class="control-btn" onclick="切换设置菜单()" style="font-size: 1em;">⚙️</button>
        <button id="切换显示按钮" class="control-btn" onclick="切换显示模式()" style="font-size: 1em;">小地图</button>
    </div>
    <div id="浮动提示框"></div>
    <div id="设置菜单" class="设置菜单">
        <button onclick="切换日志显示()">打开日志菜单</button>
        <button onclick="收纳通知()">收纳通知</button>
    </div>

    <div id="小地图容器">
        <canvas id="小地图"></canvas>
    </div>
    <div class="hud">
        <div class="hud-item">
            <span class="hud-icon">♥️</span>
            <div class="hud-bar-container">
                <div class="hud-bar health-bar" style="width: 100%"></div>
            </div>
        </div>
        <div class="hud-item">
            <span class="hud-icon">⚡︎</span>
            <div class="hud-bar-container">
                <div class="hud-bar power-bar" style="width: 100%"></div>
            </div>
        </div>
        <div class="hud-item">
            <div class="界面文本行">
                <span class="hud-label">已探索房间：<span id="roomCount">0</span></span>
            </div>
        </div>
    </div>
    <div class="背包弹窗">
        <div class="弹窗头部">
            <h3>
                背包 (容量：<span id="当前容量">0</span>/<span id="最大容量">12</span>)
            </h3>
            <button onclick="切换背包显示()" class="关闭按钮">×</button>
        </div>
        <div id="背包物品栏" class="物品容器"></div>
    </div>
    <div id="transitionMask" class="楼层过渡遮罩">
        <div id="floorTitle" class="层数标题"></div>
    </div>
    <div class="日志面板" id="日志面板" style="z-index: 1002">
        <div class="日志内容" id="logContent"></div>
    </div>
    <div id="交易窗口" class="游戏窗口">
        <div class="窗口标题">神秘商人（剩余交易次数：<span id="交易次数">3</span>）</div>
        <div class="库存列表"></div>
        <div class="交易底部">
            <div class="玩家金币">持有金币：<span id="当前金币">0</span></div>
            <button onclick="关闭交易窗口()" class="按钮">离开</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById("dungeonCanvas");
        const ctx = canvas.getContext("2d");

        // 常量 好吧有些已经变成变量了
        let 单元格大小 = 30;
        let 画布宽度 = Math.min(
            window.innerWidth - 20,
            window.innerHeight - 20
        ); // 动态宽度
        let 画布高度 = 画布宽度; // 动态高度
        const 房间尺寸范围 = [5, 9];
        const 最大房间数 = 15;
        let 相机显示边长 = 15;
        const 最大堆叠数 = 64;
        const 地牢大小 = 100;
        let 互动冷却 = false;

        const 调试序列 = ["上", "上", "下", "下", "左", "右", "左", "右"];
        // 单元格类型枚举
        let 当前层数 = 0;
        const 所有地牢层 = new Map(); // 保存各层地牢数据

        let 图标映射 = {
            // 物品
            药水: "🧪",
            钢制长剑: "🗡️",
            橡木法杖: "🪄",
            卷轴: "📜",
            钥匙: "🔑",
            金币: "🪙",
            秘银锁甲: "🥼",
            真言卷轴: "📖",
            钢制板甲: "🥋",
            金币手枪: "🔫",
            下楼楼梯: "⬇️",
            上楼楼梯: "⬆️",
            怪物: "👾",
            炸弹怪物: "💣",
            盔甲怪物: "💂",
            炸弹: "💣",
            敏捷怪物: "🏃",
            远攻怪物: "👼",
            仙人掌怪物: "🌵",
            大魔法师: "🧙",
            寻宝戒指: "💍",
            装备按钮: "🛡",
            死亡图标: "💀",
            错误: "❌",
            成功: "✅",
            冰冻怪物: "🧊",
            冰盾: "❄",
            重铸台: "⚒️",
            神秘商人: "🧙",
            祭坛: "🛐",
            互动按钮: "⚡",
            背包按钮: "🎒",
            卷轴按钮: "📜",
            HUD常显: "👀",
            HUD智能: "👁️",
            HUD常隐: "😑",
            宠物: "🐾",
            熊猫: "🐼",
            水母: "🪼",
        };
        const 中文对照图标映射 = {
            药水: "药",
            钢制长剑: "剑",
            橡木法杖: "法",
            卷轴: "卷",
            钥匙: "钥",
            金币: "金",
            秘银锁甲: "翈",
            真言卷轴: "视",
            钢制板甲: "甲",
            金币手枪: "枪",
            下楼楼梯: "下",
            上楼楼梯: "上",
            怪物: "怪",
            炸弹怪物: "爆",
            炸弹: "炸",
            盔甲怪物: "魁",
            敏捷怪物: "速",
            远攻怪物: "远",
            仙人掌怪物: "刺",
            大魔法师: "师",
            寻宝戒指: "戒",
            装备按钮: "装",
            死亡图标: "☠︎",
            错误: "✘",
            成功: "✔",
            冰冻怪物: "㓕",
            冰盾: "栤",
            重铸台: "铸",
            神秘商人: "商",
            祭坛: "坛",
            互动按钮: "互",
            背包按钮: "背",
            卷轴按钮: "卷",
            HUD常显: "显",
            HUD智能: "䚐",
            HUD常隐: "隐",
            宠物: "宠",
            熊猫: "態",
            水母: "鲝",
        };
        // 单元格类型枚举
        const 单元格类型 = {
            墙壁: 0,
            房间: 1,
            走廊: 2,
            门: 3,
            上锁的门: 4,
            物品: 5,
            楼梯下楼: 6,
            楼梯上楼: 7,
            怪物: 8,
        };
        const 怪物状态 = {
            休眠: 0,
            活跃: 1,
            攻击: 2,
        };
        const 颜色表 = [
            "#00FF00", // 绿色
            "#0000FF", // 蓝色
            "#FFFF00", // 黄色
            "#FF00FF", // 品红
            "#FF0000", // 红色
        ];
        const 效果颜色编号映射 = [
            "#ff0000",
            "#00ff00",
            "#2196F3",
            "#FF9800",
            "#808080",
            "#9C27B0",
        ];
        const 效果名称编号映射 = {
            治疗: 0,
            能量: 1,
            神龟: 2,
            狂暴: 3,
            隐身: 4,
            透视: 5,
        };
        const 颜色名表 = ["绿", "蓝", "黄", "品红", "红"];
        let 楼梯图标 = { 下楼: 图标映射.下楼楼梯, 上楼: 图标映射.上楼楼梯 };
        const 功能键映射 = {
            "1": () => 使用装备槽物品(1),
            "2": () => 使用装备槽物品(2),
            "3": () => 使用装备槽物品(3),
            "4": () => 使用装备槽物品(4),
            "q": () => { // 原逻辑
                界面可见性.hud = !界面可见性.hud;
                hud模式 = 界面可见性.hud ? "常显" : "常隐";
                document
                    .querySelector(".hud")
                    .classList.toggle("可见", 界面可见性.hud);
            },
            "f": () => {  // 互动按钮
                if (NPC互动中) {
                    if (当前NPC.名称 === "神秘商人") {
                        关闭交易窗口();
                    }
                } else {
                    尝试互动();
                }
            },
            "e": () => { // 背包按钮
                界面可见性.背包 = !界面可见性.背包;
                切换背包显示();
            },
            "r": () => { // 卷轴互动
                if (
                    document.getElementById("卷轴按钮").style //卷轴互动按钮，此处依赖 卷轴按钮 是否显示来检测，电脑端实际上因为 卷轴按钮 父容器不显示而 卷轴按钮 自身属性无意义
                        .display === "flex"
                )
                    激活卷轴模式();
            },
            "-": 切换中文模式,
            "g": 切换日志显示,
        };
        const 物品生成配置 = {
            基础概率: {
                普通房间: 0.4,
                上锁房间: 0.7,
            },
            品质权重: {
                1: [60, 0], // 品质: [基础刷新概率,随层数增长的附加刷新概率]
                2: [25, 20],
                3: [10, 30],
                4: [5, 40],
                5: [0, 10],
            },
            类型分布: {
                普通房间: [
                    { 类型: "武器", 权重: 40 },
                    { 类型: "防具", 权重: 30 },
                    { 类型: "药水", 权重: 20 },
                    { 类型: "卷轴", 权重: 10 },
                    { 类型: "工具", 权重: 25 },
                    { 类型: "宠物", 权重: 10 },
                ],
                上锁房间: [
                    { 类型: "卷轴", 权重: 30 },
                    { 类型: "武器", 权重: 30 },
                    { 类型: "药水", 权重: 25 },
                    { 类型: "防具", 权重: 15 },
                    { 类型: "工具", 权重: 25 },
                    { 类型: "宠物", 权重: 10 },
                ],
            },
        };


        const 创建物品池 = () => ({
            武器: [
                { 类: 橡木法杖, 品质: 2, 最小层: 3 },
                { 类: 钢制长剑, 品质: 1, 最小层: 0 },
                { 类: 炸弹, 品质: 2, 最小层: 1 },
                { 类: 金币手枪, 品质: 3, 最小层: 2 },
                { 类: 神秘商人, 品质: 1, 最小层: 1 }, // 奸商武力值要高，所以在武器类（确信）

            ],
            工具: [
                { 类: 物品祭坛, 品质: 1, 最小层: 0 },
                { 类: 耐久祭坛, 品质: 2, 最小层: 0 },
                { 类: 重铸台, 品质: 3, 最小层: 2 },
            ],
            防具: [
                { 类: 钢制板甲, 品质: 2, 最小层: 0 },
                { 类: 秘银锁甲, 品质: 4, 最小层: 2 },
                { 类: 冰盾, 品质: 1, 最小层: 1 },
            ],
            药水: [
                { 类: 治疗药水, 品质: 2, 最小层: 0 },
                { 类: 狂暴药水, 品质: 2, 最小层: 0 },
                { 类: 神龟药水, 品质: 3, 最小层: 1 },
                { 类: 能量药水, 品质: 4, 最小层: 1 },
                { 类: 隐身药水, 品质: 3, 最小层: 2 },
                { 类: 透视药水, 品质: 3, 最小层: 1 },
            ],
            卷轴: [
                { 类: 迅捷卷轴, 品质: 2, 最小层: 0 },
                { 类: 清净卷轴, 品质: 2, 最小层: 0 },
                { 类: 跃迁卷轴, 品质: 3, 最小层: 2 },
                { 类: 真言卷轴, 品质: 4, 最小层: 4 },
                { 类: 湮灭卷轴, 品质: 1, 最小层: 0 },
                { 类: 贪婪卷轴, 品质: 3, 最小层: 3 },
                { 类: 神秘卷轴, 品质: 1, 最小层: 0 },
                { 类: 附魔卷轴, 品质: 1, 最小层: 1 },
            ],
            宠物: [
                { 类: 熊猫, 品质: 3, 最小层: 2 },
                { 类: 水母, 品质: 4, 最小层: 2 },
            ],
        });

        const 创建怪物池 = () => ({
            普通房间: [
                { 类: 怪物, 权重: 45, 最小层: 0 },
                { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
                { 类: 敏捷怪物, 权重: 15, 最小层: 2 },
                { 类: 远攻怪物, 权重: 25, 最小层: 1 },
                { 类: 炸弹怪物, 权重: 15, 最小层: 3 },
                { 类: 冰冻怪物, 权重: 15, 最小层: 2 },
                { 类: 仙人掌怪物, 权重: 25, 最小层: 1 },
            ],
            上锁房间: [
                { 类: 炸弹怪物, 权重: 35, 最小层: 1 },
                { 类: 远攻怪物, 权重: 30, 最小层: 3 },
                { 类: 敏捷怪物, 权重: 35, 最小层: 2 },
                { 类: 冰冻怪物, 权重: 15, 最小层: 0 },
                { 类: 盔甲怪物, 权重: 30, 最小层: 0 },
                { 类: 仙人掌怪物, 权重: 30, 最小层: 1 },
            ]
        });

        // 全局变量
        let 地牢 = [];
        let 房间列表 = [];
        let 玩家装备 = new Map(); // 以装备槽位为索引，目前有 4 个槽位，索引从 1 开始
        let 玩家 = { x: 0, y: 0 };
        let 小地图Ctx;
        const 小地图缩放 = 3;
        const 小地图Offset = 10;
        let 视口偏移X = 0,
            视口偏移Y = 0;
        let 跟踪玩家怪物数 = 0;
        let 房间地图 = Array(地牢大小)
            .fill()
            .map(() => Array(地牢大小).fill(-1)); // 记录每个单元格所属房间ID
        let 上锁房间列表 = []; // 存储被锁定房间对象
        let 已访问房间 = new Set(); // 记录已访问过的房间
        let 显示HUD计时器 = null;
        let hud模式 = "默认";
        let 背包可见 = false;
        let 玩家背包 = new Map(); // 以物品唯一标识为索引
        const 最大背包容量 = 12;
        let 门实例列表 = new Map();
        const 通知队列 = [];
        let 移动历史 = [];
        let 上次移动 = 0;
        let 移动状态 = {
            up: false,
            down: false,
            left: false,
            right: false,
        };
        let hud显示 = false;
        let 界面可见性 = {
            hud: false,
            背包: false,
        };
        let 所有怪物 = [];
        const 怪物生成概率 = 0.7;
        const 最大怪物数 = 5; //一个房间内的怪物生成上限
        let 玩家初始位置 = { x: 0, y: 0 };
        let 死亡界面已显示 = false;
        let 单击移动定时器 = null;
        let 开始移动定时器 = null;
        let 长按移动 = false;
        let 当前激活卷轴列表 = new Set();
        let 卷轴模式激活 = false; //是否点击了卷轴按钮
        let 移动间隔 = 100; // 长按连续移动间隔
        let 首次移动延迟 = 250; // 首次移动后的延迟
        let 最后移动时间 = 0;
        let 移动定时器 = null;
        let 教程阶段 = 0;
        let 教程提示已显示 = false;
        let 是否为教程层 = false;
        let 玩家属性 = {
            移动步数: 1,
            攻击加成: 0,
            防御加成: 0,
            掉落倍率: 1,
            透视: false,
            允许移动: true,
        };
        let 初始玩家属性 = {
            移动步数: 1,
            攻击加成: 0,
            防御加成: 0,
            掉落倍率: 1,
            透视: false,
            允许移动: true,
        };
        let 相机目标X = 视口偏移X;
        let 相机目标Y = 视口偏移Y;
        let 当前相机X = 视口偏移X;
        let 当前相机Y = 视口偏移Y;
        let 相机锁定 = false; // 防止中途更新目标
        const 相机移动速度 = 0.2;
        let 显示模式 = "装备"; // 默认显示装备槽
        let 日志历史 = [];
        let 是否显示通知 = true;
        let 日志面板可见 = false;
        let 所有炸弹 = [];
        let 玩家状态 = [];
        let NPC互动中 = false;
        let 当前NPC = null;
        let 已击杀怪物数 = 0;
        let 怪物状态表 = new WeakMap(); //好耶！WeakMap！
        let 彩蛋1触发, 彩蛋2触发, 彩蛋3触发 = false; //卑鄙的人，彩蛋要靠自己寻找才有意义
        let 待显示格子特效队列 = [];
        let 待显示爆炸范围 = { 爆炸范围: [], 爆炸距离: null };
        let 物品池;
        let 怪物池;
        let moveQueue = [];
        let isAutoMoving = false;
        canvas.addEventListener('touchstart', 处理地图点击);
        canvas.addEventListener('click', 处理地图单击); // 兼容PC端点击

        function 处理地图点击(e) {
            e.preventDefault();
            const touch = e.touches[0];
            处理点击(touch.clientX, touch.clientY);
        }

        function 处理地图单击(e) {
            处理点击(e.clientX, e.clientY);
        }

        //来源对象需要提供应用效果与移除效果（可选）函数
        class 状态效果 {
            constructor(类型, 颜色, 图标, 持续时间, 剩余回合 = null, 来源 = null, 关联怪物 = null) {
                this.类型 = 类型;
                this.剩余回合 = 剩余回合 || 持续时间;
                this.来源 = 来源;
                this.持续时间 = 持续时间;
                this.关联怪物 = 关联怪物;
                this.颜色 = 颜色;
                this.图标 = 图标;

                if (!this.关联怪物) {
                    玩家状态.push(this);
                    this.进度条实例 = new 进度条元素({
                        图标: 图标,
                        颜色: 颜色,
                        初始值: 100,
                        标签: `${this.类型} ${this.剩余回合}回合`,
                    });
                }
                if (this.关联怪物) {
                    怪物状态表.set(this.关联怪物, this);
                    this.关联怪物.获得效果(this);
                }
            }
            更新状态() {
                let 剩余回合 = this.剩余回合;
                剩余回合 = Math.max(0, 剩余回合 - 1);
                this.剩余回合 = 剩余回合;
                if (!this.关联怪物) {
                    // 更新进度条
                    const 百分比 = (剩余回合 / this.持续时间) * 100;
                    this.进度条实例.更新({
                        数值: 百分比,
                        标签: `${this.类型} ${剩余回合}回合`,
                    });
                }
                if (剩余回合 === 0) {
                    this.移除状态();
                } else {
                    this.来源?.应用效果();
                }
            }
            移除状态() {
                if (!this.关联怪物) 玩家状态 = 玩家状态.filter((item) => item !== this);
                if (this.关联怪物) 怪物状态表.delete(this.关联怪物);
                // 移除HUD元素
                if (this.进度条实例) this.进度条实例.销毁();
                this.来源?.移除效果();
                return;
            }
        }



        function 处理点击(clientX, clientY) {
            if (
                界面可见性.背包
            ) {
                切换背包显示();
                document.getElementById("浮动提示框").style.display =
                    "none";
                return;
            } else if (教程提示已显示) {
                关闭教程提示();
                return;
            } else if (document.getElementById("设置菜单").classList.contains("显示")) {
                切换设置菜单()
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const gridX = 视口偏移X + Math.floor(x / (单元格大小));
            const gridY = 视口偏移Y + Math.floor(y / (单元格大小));

            const 全路径 = 广度优先搜索路径(
                玩家.x,
                玩家.y,
                gridX,
                gridY,
                30,
                true
            );
            const 截断路径 = [];
            for (const 节点 of 全路径) {
                const 房间ID = 房间地图[节点.y][节点.x];
                // 记录进入未探索房间的第一个格子
                if (房间ID !== -1 && !已访问房间.has(房间ID)) {
                    截断路径.push(节点);
                    break;
                }
                截断路径.push(节点);
            }
            截断路径.shift();
            if (截断路径.length > 0) {
                moveQueue = 截断路径;
                startAutoMove();
            }
        }


        class 门 {
            constructor(配置) {
                this.唯一标识 = Symbol("门标识");
                this.类型 = "门"; //常驻类型
                this.是否上锁 = false;
                this.房间ID = 配置.关联房间ID;
                this.所在位置 = 配置.位置; // {x, y}

                // 自动注册到全局列表
                门实例列表.set(this.唯一标识, this); // 注册逻辑
            }

            尝试解锁(玩家背包) {
                return [...玩家背包.values()].some((item) =>
                    item.可交互目标(this)
                );
            }
        }

        class 怪物 {
            constructor(配置 = {}) {
                this.房间ID = (配置.房间ID === undefined) ? null : 配置.房间ID;
                this.x = (配置.x === undefined) ? null : 配置.x;
                this.y = (配置.y === undefined) ? null : 配置.y;
                this.目标路径 = [];
                this.状态 = 配置.状态 || 怪物状态.休眠;
                this.基础生命值 = 配置.基础生命值 || 25;
                this.基础攻击力 = 配置.基础攻击力 || 3;
                this.移动率 = 配置.移动率 || 0.7;
                this.图标 = 配置.图标 || 图标映射.怪物; //图标即名称
                this.类型 = 配置.类型 || "怪物";
                this.掉落物 =
                    配置.掉落物 ||
                    new 金币({ 数量: Math.floor(Math.random() * 5) + 1 });
                this.掉落概率 = 配置.掉落概率 || 1,
                    this.血条元素 = null;
                this.受击动画 = false;
                this.基础攻击范围 = 配置.基础攻击范围 || 1;
                this.受伤冻结回合 = 配置.受伤冻结回合 || 1;
                this.基础移动距离 = 配置.基础移动距离 || 1;

                this.跟踪距离 = 配置.跟踪距离 || 15;
                this.基础颜色 = 配置.颜色 || "#FFFFFF";
                this.强化 = 配置.强化 || false;

                this.当前生命值 = 配置.当前生命值 || this.生命值;//我觉得没有人会想要生成一只残血的怪物 //冰冻怪物：你好，有的
                this.攻击冷却 = 配置.攻击冷却 || 0;
                this.受伤冻结回合剩余 = 0;
                this.攻击冷却回合剩余 = 0;
                if (this.房间ID === null && this.y !== null && this.x !== null) {
                    this.房间ID = 房间地图[this.y][this.x];
                }
                this.仇恨 = null;

            }
            计算路径(目标X, 目标Y) {
                this.目标 = { x: 目标X, y: 目标Y };
                const 目标距离 = Math.floor(this.攻击范围 / 2);
                const 玩家距离图 = this.生成玩家距离图(目标X, 目标Y);

                // 当前已在有效攻击位置
                if (玩家距离图[this.y][this.x] === 目标距离) {
                    跟踪玩家怪物数++;
                    return [];
                }

                const 开放列表 = [];
                const 关闭列表 = new Set();
                const 方向映射表 = [
                    { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                    { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                    { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                    { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" }
                ];

                const 起点节点 = {
                    x: this.x,
                    y: this.y,
                    g: 0,
                    parent: null,
                };
                开放列表.push(起点节点);
                关闭列表.add(`${起点节点.x},${起点节点.y}`);

                while (开放列表.length > 0) {
                    let 当前节点 = 开放列表.shift();
                    if (玩家距离图[当前节点.y][当前节点.x] === 目标距离) {
                        const 路径 = [];
                        let 节点 = 当前节点;
                        while (节点.parent) {
                            路径.push(节点);
                            节点 = 节点.parent;
                        }
                        return 路径.reverse();
                    }

                    // 扩展相邻节点
                    方向映射表.forEach(方向 => {
                        const 新X = 当前节点.x + 方向.dx;
                        const 新Y = 当前节点.y + 方向.dy;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) return;

                        const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                        const 目标单元格 = 地牢[新Y][新X];

                        if (当前单元格.墙壁[方向.当前墙] ||
                            目标单元格.墙壁[方向.目标墙] ||
                            目标单元格.类型 === 单元格类型.墙壁 ||
                            目标单元格.类型 === 单元格类型.上锁的门) return;

                        const 位置键 = `${新X},${新Y}`;
                        if (!关闭列表.has(位置键)) {
                            关闭列表.add(位置键);
                            开放列表.push({
                                x: 新X,
                                y: 新Y,
                                g: 当前节点.g + 1,
                                parent: 当前节点
                            });
                        }
                    });
                }
                return [];
            }

            // 生成玩家实际路径距离图?什么是效率问题,我不懂
            生成玩家距离图(玩家X, 玩家Y) {
                const 距离图 = Array.from({ length: 地牢大小 }, () =>
                    Array(地牢大小).fill(Infinity)
                );
                const 队列 = [];
                const 方向映射表 = [
                    { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                    { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                    { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                    { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" }
                ];

                // 初始化玩家起始位置
                距离图[玩家Y][玩家X] = 0;
                队列.push({ x: 玩家X, y: 玩家Y });

                while (队列.length > 0) {
                    const 当前 = 队列.shift();

                    方向映射表.forEach(方向 => {
                        const 新X = 当前.x + 方向.dx;
                        const 新Y = 当前.y + 方向.dy;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) return;

                        const 当前单元格 = 地牢[当前.y][当前.x];
                        const 目标单元格 = 地牢[新Y][新X];

                        // 使用与怪物相同的移动规则
                        if (当前单元格.墙壁[方向.当前墙] ||
                            目标单元格.墙壁[方向.目标墙] ||
                            目标单元格.类型 === 单元格类型.墙壁 ||
                            目标单元格.类型 === 单元格类型.上锁的门) return;

                        // 找到更短路径
                        if (距离图[新Y][新X] > 距离图[当前.y][当前.x] + 1) {
                            距离图[新Y][新X] = 距离图[当前.y][当前.x] + 1;
                            队列.push({ x: 新X, y: 新Y });
                        }
                    });
                }

                return 距离图;
            }
            计算目标路径(目标X, 目标Y) {

                const 开放列表 = [];
                const 关闭列表 = new Set();
                const 方向映射表 = [
                    {
                        dx: 1,
                        dy: 0,
                        当前墙: "右",
                        目标墙: "左",
                    },
                    {
                        dx: -1,
                        dy: 0,
                        当前墙: "左",
                        目标墙: "右",
                    },
                    {
                        dx: 0,
                        dy: 1,
                        当前墙: "下",
                        目标墙: "上",
                    },
                    {
                        dx: 0,
                        dy: -1,
                        当前墙: "上",
                        目标墙: "下",
                    },
                ];

                const 起点节点 = {
                    x: this.x,
                    y: this.y,
                    g: 0,
                    parent: null,
                };
                开放列表.push(起点节点);

                while (开放列表.length > 0) {
                    let 当前节点 = 开放列表.shift();

                    if (当前节点.x === 目标X && 当前节点.y === 目标Y) {
                        const 路径 = [];
                        while (当前节点.parent) {
                            路径.push(当前节点);
                            当前节点 = 当前节点.parent;
                        }
                        return 路径.reverse();
                    }

                    // 探索四个方向
                    方向映射表.forEach((方向) => {
                        const 新X = 当前节点.x + 方向.dx;
                        const 新Y = 当前节点.y + 方向.dy;
                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            return;
                        const 当前单元格 = 地牢[当前节点.y][当前节点.x];
                        const 目标单元格 = 地牢[新Y][新X];
                        const 当前墙阻挡 = 当前单元格.墙壁[方向.当前墙];
                        const 目标墙阻挡 = 目标单元格.墙壁[方向.目标墙];
                        const 硬阻挡 =
                            目标单元格.类型 === 单元格类型.墙壁 ||
                            目标单元格.类型 === 单元格类型.上锁的门;

                        if (当前墙阻挡 || 目标墙阻挡 || 硬阻挡) return;

                        // 检查是否已访问
                        const 位置键 = `${新X},${新Y}`;
                        if (!关闭列表.has(位置键)) {
                            开放列表.push({
                                x: 新X,
                                y: 新Y,
                                g: 当前节点.g + 1,//听别人说g值怎么怎么样，也就那样
                                parent: 当前节点,
                            });
                            关闭列表.add(位置键);
                        }
                    });
                }
                return null;
            }
            选择目标() {
                if (怪物状态表.get(this)?.类型 === "魅惑") {
                    return this.寻找最近怪物目标();
                }
                if (this.仇恨 instanceof 怪物) {
                    return { x: this.仇恨.x, y: this.仇恨.y };
                }
                return { x: 玩家.x, y: 玩家.y }; // 默认目标为玩家
            }

            寻找最近怪物目标() {
                let 最近距离 = Infinity;
                let 最近目标 = null;

                所有怪物.forEach(其他怪物 => {
                    if (其他怪物 === this || 其他怪物.当前生命值 <= 0 || 其他怪物.状态 === 怪物状态.休眠 || ["冻结", "魅惑"].includes(怪物状态表.get(其他怪物)?.类型) || 其他怪物 instanceof 大魔法师) return;

                    const 距离 = Math.abs(this.x - 其他怪物.x) + Math.abs(this.y - 其他怪物.y);
                    if (距离 < 最近距离 && 检查视线(this.x, this.y, 其他怪物.x, 其他怪物.y)) {
                        最近距离 = 距离;
                        最近目标 = 其他怪物;
                    }
                });
                this.魅惑目标怪物 = 最近目标;
                return 最近目标 ? { x: 最近目标.x, y: 最近目标.y } : { x: this.x, y: this.y };
            }

            尝试移动() {
                let 移动率 = this.移动率;
                const 我的状态 = 怪物状态表.get(this);
                switch (我的状态?.类型) {
                    case "冻结":
                        return;
                    case "火焰":
                        this.受伤(3, null);
                        this.受伤冻结回合剩余 = 0;
                        break;
                    case "魅惑":
                        移动率 = 1;
                        break;
                }
                if (this.当前生命值 <= 0) return;
                if (房间地图[玩家.y][玩家.x]===0) return;
                if (this.受伤冻结回合剩余 > 0) {
                    this.受伤冻结回合剩余 -= 1;
                } else {
                    if (this.跟踪距离 >= this.目标路径.length && 怪物状态表.get(this)?.类型 !== "魅惑") {
                        跟踪玩家怪物数++;
                    }
                    if (
                        this.目标路径.length === 0 ||
                        Math.random() > 移动率 ||
                        this.跟踪距离 < this.目标路径.length
                    ) {
                        this.追击玩家中=false;
                        return;
                    }
                    //this.目标路径 = this.计算路径(this.目标.x,this.目标.y);
                    // 获取下一个移动方向
                    const 下一步 = this.目标路径[Math.min(this.移动距离 - 1, this.目标路径.length - 1)];
                    if (下一步) {
                        const dx = 下一步.x - this.x;
                        const dy = 下一步.y - this.y;

                        // 规划实际可移动位置
                        const 最终位置 = this.规划移动路径(dx, dy);
                        if (!最终位置) return;
                        if (this instanceof 大魔法师 && 房间地图[最终位置.y][最终位置.x] === -1) return;
                        this.恢复原始类型();
                        this.保存新位置类型(最终位置.x, 最终位置.y);
                        this.x = 最终位置.x;
                        this.y = 最终位置.y;
                        地牢[this.y][this.x].类型 = 单元格类型.怪物;
                        地牢[this.y][this.x].关联怪物 = this;
                    }

                }
                this.绘制血条();
            }

            规划移动路径() {
                let 当前位置 = { x: this.x, y: this.y };
                let 有效位置 = null;
                let 可行距离 = this.移动距离 + 3;
                for (
                    let i = 0;
                    i < Math.min(this.目标路径.length, 可行距离);
                    i++
                ) {
                    const 节点 = this.目标路径[i];

                    const nextX = 节点.x;
                    const nextY = 节点.y;
                    if (地牢[nextY][nextX].类型 === 单元格类型.怪物) {
                        可行距离 = this.移动距离 + 1; //防止怪物团结一心变身 Bolt
                    }
                    if (
                        this.检查移动可行性(
                            当前位置.x,
                            当前位置.y,
                            nextX,
                            nextY
                        )
                    ) {
                        if (this.位置合法(nextX, nextY)) {
                            有效位置 = { x: nextX, y: nextY };
                        }
                    } else {
                        this.目标路径 = this.目标路径.slice(i);
                        return 当前位置;
                    }
                    当前位置 = { x: nextX, y: nextY };

                    if (有效位置 && i >= Math.min(this.移动距离, this.目标路径.length) - 1) {
                        this.目标路径 = this.目标路径.slice(i);
                        return 有效位置;
                    }
                }
                return null;
            }

            检查移动可行性(fromX, fromY, toX, toY) {
                const dx = toX - fromX;
                const dy = toY - fromY;
                const steps = Math.max(Math.abs(dx), Math.abs(dy));
                const xStep = dx / steps;
                const yStep = dy / steps;

                let currentX = fromX;
                let currentY = fromY;

                for (let i = 0; i <= steps; i++) {
                    const x = Math.round(currentX);
                    const y = Math.round(currentY);

                    if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
                        return false;

                    if (i > 0) {
                        const prevX = Math.round(currentX - xStep);
                        const prevY = Math.round(currentY - yStep);
                        const 移动方向 = 获取移动方向(prevX, prevY, x, y);

                        const 当前单元格 = 地牢[y][x];
                        const 前单元格 = 地牢[prevY][prevX];

                        if (
                            当前单元格.墙壁[移动方向.反方向墙] ||
                            前单元格.墙壁[移动方向.当前墙]
                        ) {
                            return false;
                        }
                    }

                    if (x === toX && y === toY) break;

                    currentX += xStep;
                    currentY += yStep;
                }
                return true;
            }
            位置合法(x, y) {
                return [
                    单元格类型.房间,
                    单元格类型.走廊,
                    单元格类型.门,
                ].includes(地牢[y][x].类型);
            }

            恢复原始类型() {
                地牢[this.y][this.x].类型 = 地牢[this.y][this.x].原始类型;
                地牢[this.y][this.x].关联怪物 = null;
                地牢[this.y][this.x].原始类型 = null;
            }

            保存新位置类型(x, y) {
                地牢[y][x].原始类型 = 地牢[y][x].类型; // 原始类型备份
            }

            尝试攻击() {
                if (怪物状态表.get(this)?.类型 === "冻结") return;
                if (this.攻击冷却回合剩余 > 0) {
                    this.攻击冷却回合剩余 -= 1;
                    return false;
                }

                if (this.通向目标路径.length > this.攻击范围) return false;


                if (怪物状态表.get(this)?.类型 === "魅惑") {
                    if (this.魅惑目标怪物 !== this && this.魅惑目标怪物 !== null) {
                        this.魅惑目标怪物?.受伤(this.攻击力, this)
                        this.攻击冷却回合剩余 = this.攻击冷却;
                        计划显示格子特效(this.通向目标路径);
                        return true;
                    } else {
                        return false;
                    }
                }
                if (this.仇恨 instanceof 怪物) {
                    if (this.仇恨 !== this && this.仇恨 !== null) {
                        if (this.仇恨.当前生命值 <= 0) {
                            this.仇恨 = null;
                            return false;
                        }
                        this.仇恨?.受伤(this.攻击力, this)
                        this.攻击冷却回合剩余 = this.攻击冷却;
                        计划显示格子特效(this.通向目标路径);
                        return true;
                    } else {
                        return false;
                    }
                }
                伤害玩家(this.攻击力, this);
                this.攻击冷却回合剩余 = this.攻击冷却;
                计划显示格子特效(this.通向目标路径);


                return true;
            }
            get 攻击范围() {
                return this.基础攻击范围 + (this.强化 ? 1 : 0); // + (this.远程武器 ? 3 : 0);
            }
            get 攻击力() {
                return this.基础攻击力;
                +(this.强化 ? this.基础攻击力 : 0); //+ (this.武器.攻击力 ? 3 : 0);
            }
            get 颜色() {
                if (怪物状态表.get(this)) {
                    return 怪物状态表.get(this)?.颜色; // 药水颜色
                }
                return this.强化 ? "#ff0000" : this.基础颜色;
            }
            get 移动距离() {
                return this.基础移动距离 + (this.强化 ? 1 : 0)
            }
            get 生命值() {
                return this.基础生命值 + (this.强化 ? 30 : 0);
            }
            获得效果(状态效果) {
                return true;
            }
            受伤(伤害, 来源 = null) {
                if (this.当前生命值 > 0) {
                    this.当前生命值 -= 伤害;
                    if (!(来源 instanceof 怪物)) {
                        this.受伤冻结回合剩余 = this.受伤冻结回合;
                    } else {
                        if (!(来源 instanceof 大魔法师)) this.仇恨 = 来源;
                    }
                    this.触发受击动画();
                    if (this.当前生命值 <= 0) {
                        if (来源 === "玩家") { //炸弹炸死不算数
                            已击杀怪物数++;
                            击杀提示.更新({ 内容: `已击杀怪物：${已击杀怪物数}` });
                            const 装备宠物列表 = [...玩家装备.values()].filter(装备 => 装备 instanceof 宠物);
                            装备宠物列表.forEach(宠物 => {
                                // 获得的经验与怪物基础生命值相关
                                const 经验值 = Math.floor(this.基础生命值 / 10);
                                宠物.获得经验(经验值);
                            });
                        }
                        if (来源 instanceof 宠物) {
                            const 经验值 = Math.floor(this.基础生命值 / 10);
                            来源.获得经验(经验值);
                        }
                        this.恢复原始类型();
                        this.血条元素.remove();
                        所有怪物 = 所有怪物.filter((m) => m !== this);
                        if (Math.random() <= this.掉落概率 * 玩家属性.掉落倍率) {
                            if (this.掉落物.自定义数据.get("耐久")) this.掉落物.自定义数据.set("耐久", Math.floor(Math.min(this.掉落物.自定义数据.get("耐久"), this.掉落物.自定义数据.get("耐久") * 玩家属性.掉落倍率 * Math.random() * Math.random())))
                            放置物品到单元格(this.掉落物, this.x, this.y);
                        }
                        const 玩家单元格 = 地牢[玩家.y][玩家.x];
                        if (
                            玩家单元格.关联物品 &&
                            玩家单元格.类型 === 单元格类型.物品
                        ) {
                            if (尝试收集物品(玩家单元格.关联物品)) {
                                玩家单元格.类型 = 玩家单元格.原始类型;
                                玩家单元格.关联物品 = null;
                            }
                        }
                        if (是否为教程层 && this.房间ID === 2) {
                            教程阶段 = 2.5; // 推进到2.5
                            教程提示已显示 = false;
                            setTimeout(() => {
                                显示教程提示();
                            }, 200);
                        }
                        //绘制应该由调用者处理
                        return;
                    }
                    this.绘制血条();
                }
            }
            绘制血条(隐藏血条 = false) {
                if (隐藏血条) {
                    if (this.血条元素) {
                        this.血条元素.style.display = "none";
                        this.血条元素 = null;
                        return;
                    }
                }
                const 画布Rect = canvas.getBoundingClientRect();
                const 小数偏移X = (当前相机X % 1) * 单元格大小;
                const 小数偏移Y = (当前相机Y % 1) * 单元格大小;
                const 屏幕X = (this.x - 视口偏移X) * 单元格大小 - 小数偏移X;
                const 屏幕Y = (this.y - 视口偏移Y) * 单元格大小 - 小数偏移Y;
                const 宽度 = 单元格大小;
                // 判断是否在屏幕可见区域
                const 在视口内 =
                    屏幕X + 单元格大小 > 0 &&
                    屏幕X + 单元格大小 < 画布Rect.width &&
                    屏幕Y + 单元格大小 > 0 &&
                    屏幕Y + 单元格大小 < 画布Rect.height;

                if (this.状态 === 怪物状态.活跃 && 在视口内) {
                    if (!this.血条元素) {
                        this.血条元素 = document.createElement("div");
                        this.血条元素.className = "怪物血条";
                        document.body.appendChild(this.血条元素);
                    }

                    this.血条元素.style.cssText = `
                                                                        left: ${屏幕X +
                        画布Rect.left
                        }px;
                                                                        top: ${屏幕Y -
                        12 +
                        画布Rect.top
                        }px;
                                                                        width: ${宽度}px;
                                                                        display: block;
                                                                    `;

                    const 血量百分比 = Math.max(
                        0,
                        this.当前生命值 / this.生命值 * 100
                    );
                    this.血条元素.innerHTML = `
                                                                        <div class="血条背景">
                                                                            <div class="当前血量" style="width:${血量百分比}%"></div>
                                                                        </div>
                                                                    `;
                } else {
                    if (this.血条元素) {
                        this.血条元素.style.display = "none";
                    }
                }
            }
            触发受击动画() {
                this.受击动画 = true;
                绘制();
                setTimeout(() => {
                    this.受击动画 = false;
                    绘制();
                }, 200);
            }
        }

        class 大魔法师 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.大魔法师,
                    类型: "大魔法师",
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.活跃,
                    基础生命值: 配置.基础生命值 || 55,
                    基础攻击力: 配置.基础攻击力 || 8,
                    强化: 配置.强化 || false,
                    移动率: 配置.移动率 || 0.8,
                    基础攻击范围: 4,
                    跟踪距离: 20,
                    攻击冷却: 1,
                    受伤冻结回合: 1,
                    掉落物: new 真言卷轴({ 品质: 4, 已解锁: true, 强化: true }),
                    掉落概率: 1,
                    ...配置,
                });
                this.当前生命值 = 配置.当前生命值 || this.生命值
                this.技能冷却 = {
                    隐身术: 0,
                    分身术: 0,
                    火球术: 0,
                    冰冻术: 0,
                    传送术: 0,
                    召唤术: 0,
                };
                this.每回合恢复量 = 2;
                this.隐身中 = false;
                this.逃离目标 = null;
                this.原始移动距离 = this.基础移动距离;
                this.isClone = false
                this.隐身提示间隔 = 2;
                this.隐身提示计数 = 0;
            }

            尝试移动() {
                if (this.隐身中) {
                    this.隐身移动();
                    return;
                }

                if (this.当前生命值 <= 0) return;
                super.尝试移动();

                this.绘制血条();
            }

            选择逃离目标() {
                const 最大距离 = this.跟踪距离; // 最大逃离距离
                const 可达点 = [];

                const 队列 = [{ x: 玩家.x, y: 玩家.y, 距离: 0 }];
                const 已访问 = new Set([`${this.x},${this.y}`]);
                const 已在房间中 = 房间地图[this.y][this.x] !== -1;
                const 已在房间 = 房间地图[this.y][this.x];

                while (队列.length > 0) {
                    const 当前 = 队列.shift();

                    const 房间ID = 房间地图[当前.y][当前.x];
                    if (已访问房间.has(房间ID)) {
                    if (!已在房间中) {
                        可达点.push({ x: 当前.x, y: 当前.y, 距离: 当前.距离 }); // 记录距离
                    } else {
                    if (房间ID === 已在房间) 可达点.push({ x: 当前.x, y: 当前.y, 距离: 当前.距离 });
                    }
                    }


                    if (当前.距离 > 最大距离) continue;

                    const 方向 = [
                        { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                        { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                        { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                        { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
                    ];

                    for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;
                        const 位置键 = `${新X},${新Y}`;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;
                        const 当前单元格 = 地牢[当前.y][当前.x];
                        const 目标单元格 = 地牢[新Y][新X];
                        if (当前单元格.墙壁[当前墙] || 目标单元格.墙壁[目标墙]) continue;
                        if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.类型)) continue;


                        if (!已访问.has(位置键) && this.位置合法(新X, 新Y)) {
                            已访问.add(位置键);
                            队列.push({ x: 新X, y: 新Y, 距离: 当前.距离 + 1 });
                        }
                    }
                }

                let 最远点 = null;
                let 最大自身距离 = -1;


                for (const 点 of 可达点) {

                    if (点.距离 > 最大自身距离) {
                        最大自身距离 = 点.距离;
                        最远点 = 点;
                    }
                }

                return 最远点;
            }

            隐身移动() {
                if (this.当前生命值 < this.生命值) {
                    this.当前生命值 = Math.min(this.生命值, this.当前生命值 + this.每回合恢复量);
                    this.绘制血条();
                } else {
                    this.隐身中 = false;
                    this.基础移动距离 = this.原始移动距离;
                    添加日志(`${this.类型} 现形了!`, "信息");
                    显示通知("使用分身迷惑你后，隐身的大魔法师缓缓现出真身...")
                    this.绘制血条();
                    return;
                }

                if (!this.逃离目标) {
                    this.逃离目标 = this.选择逃离目标();
                }
                this.目标路径 = this.计算目标路径(this.逃离目标.x, this.逃离目标.y);
                if (this.目标路径) {
                    const 下一步 = this.目标路径[Math.min(this.移动距离 - 1, this.目标路径.length - 1)]
                    const 最终位置 = this.规划移动路径();
                    if (!最终位置 || (this.y === this.逃离目标.y && this.x === this.逃离目标.x)) {

                        this.逃离目标 = null;
                        return;
                    }
                    this.恢复原始类型();
                    this.保存新位置类型(最终位置.x, 最终位置.y);
                    this.x = 最终位置.x;
                    this.y = 最终位置.y;
                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
                    地牢[this.y][this.x].关联怪物 = this;
                } else {
                    this.逃离目标 = null;
                }

                this.绘制血条();
                this.隐身提示计数++;
                if (this.隐身提示计数 >= this.隐身提示间隔) {
                    this.隐身提示计数 = 0;

                    const 画布Rect = canvas.getBoundingClientRect();
                    let 屏幕X = (this.x - 相机目标X) * 单元格大小;
                    let 屏幕Y = (this.y - 相机目标Y) * 单元格大小;
                    if (屏幕X + 单元格大小 < 0 || 屏幕X > 画布Rect.width || 屏幕Y + 单元格大小 < 0 || 屏幕Y > 画布Rect.height) {
                        return;
                    }
                    计划显示格子特效([{ x: this.x, y: this.y }], "000000");
                }
            }

            尝试攻击() {
                if (怪物状态表.get(this)?.类型 === "冻结") return;

                if (this.攻击冷却回合剩余 > 0) {
                    this.攻击冷却回合剩余 -= 1;
                    return false;
                }
                if (this.通向目标路径.length > this.攻击范围) return false;
                if (!this.isClone) {
                    if (this.当前生命值 < this.生命值 * 0.3 && !this.隐身中) {
                        this.隐身术();
                        this.分身术();
                        添加日志(`${this.类型} 负伤逃跑了!`, "信息");

                        return true;
                    } else if (this.隐身中) {
                        return true;
                    }
                }


                if (Math.random() < 0.5) {
                    const 技能列表 = ["火球术", "冰冻术", "传送术", "召唤术"];
                    const 随机技能 = 技能列表[Math.floor(Math.random() * 技能列表.length)];

                    switch (随机技能) {
                        case "火球术":
                            if (!this.火球术()) {
                                this.普通攻击();
                                this.攻击冷却回合剩余 = this.攻击冷却;
                            }
                            break;
                        case "冰冻术":
                            if (!this.冰冻术()) {
                                this.普通攻击();
                                this.攻击冷却回合剩余 = this.攻击冷却;
                            }
                            break;
                        case "传送术":
                            this.传送术();
                            break;
                        case "召唤术":
                            if (!this.召唤术()) {
                                this.普通攻击();
                                this.攻击冷却回合剩余 = this.攻击冷却;
                            }
                            break;
                    }
                    return true;
                } else {
                    this.普通攻击();
                    this.攻击冷却回合剩余 = this.攻击冷却
                    return true;
                }
            }
            普通攻击() {
                const 攻击模式 = Math.floor(Math.random() * 4);
                let 方向列表 = [];

                switch (攻击模式) {
                    case 0:
                        方向列表 = [
                            { dx: 0, dy: -1 },
                            { dx: 0, dy: 1 },
                            { dx: -1, dy: 0 },
                            { dx: 1, dy: 0 },
                        ];
                        break;
                    case 1:
                        方向列表 = [
                            { dx: -1, dy: -1 },
                            { dx: 1, dy: -1 },
                            { dx: -1, dy: 1 },
                            { dx: 1, dy: 1 },
                        ];
                        break;
                    case 2:
                    case 3:
                        const 基本方向 = [
                            { dx: 0, dy: -1 },
                            { dx: 1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: -1, dy: 0 },
                        ];

                        const 顺时针方向变化 = [
                            { dx: 1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: -1, dy: 0 },
                            { dx: 0, dy: -1 },
                        ];

                        const 逆时针方向变化 = [
                            { dx: 0, dy: -1 },
                            { dx: -1, dy: 0 },
                            { dx: 0, dy: 1 },
                            { dx: 1, dy: 0 },
                        ];

                        基本方向.forEach(起始方向 => {
                            let 当前方向 = 起始方向;
                            let 当前X = this.x;
                            let 当前Y = this.y;
                            let 路径 = [];

                            let 层数 = 0;
                            while (Math.abs(当前X - this.x) + Math.abs(当前Y - this.y) <= this.攻击范围) {
                                层数++;
                                let 步数 = 层数 * 2 - 1;

                                if (层数 > 1) {

                                    const 方向变化 = 攻击模式 === 2 ? 顺时针方向变化 : 逆时针方向变化;
                                    let 方向索引 = 方向变化.findIndex(d => d.dx === 当前方向.dx && d.dy === 当前方向.dy);


                                    方向索引 = (方向索引 + 1) % 4;
                                    当前方向 = 方向变化[方向索引];


                                    当前X += 当前方向.dx;
                                    当前Y += 当前方向.dy;
                                    if (!检查移动可行性(当前X - 当前方向.dx, 当前Y - 当前方向.dy, 当前X, 当前Y)) break;

                                    const 单元格 = 地牢[当前Y]?.[当前X];
                                    if (单元格?.关联怪物 && 单元格.类型 === 单元格类型.怪物 && 单元格.关联怪物?.状态 === 怪物状态.活跃 && !(单元格.关联怪物 instanceof 大魔法师)) {
                                        单元格.关联怪物.受伤(this.攻击力, this);

                                    } else if (当前X === 玩家.x && 当前Y === 玩家.y) {
                                        伤害玩家(this.攻击力, this);
                                    }

                                    路径.push({ x: 当前X, y: 当前Y });
                                    步数--;

                                }



                                for (let i = 0; i < 步数; i++) {
                                    当前X += 当前方向.dx;
                                    当前Y += 当前方向.dy;

                                    if (!检查移动可行性(当前X - 当前方向.dx, 当前Y - 当前方向.dy, 当前X, 当前Y)) break;

                                    const 单元格 = 地牢[当前Y]?.[当前X];

                                    if (单元格?.关联怪物 && 单元格.类型 === 单元格类型.怪物 && 单元格.关联怪物?.状态 === 怪物状态.活跃) {
                                        单元格.关联怪物.受伤(this.攻击力, this);
                                    } else if (当前X === 玩家.x && 当前Y === 玩家.y) {
                                        伤害玩家(this.攻击力, this);
                                    }
                                    路径.push({ x: 当前X, y: 当前Y });

                                }
                                if (Math.abs(当前X - this.x) + Math.abs(当前Y - this.y) > this.攻击范围) break;
                            }

                            计划显示格子特效(路径);
                        });
                        return;
                }

                方向列表.forEach(方向 => {
                    let 当前X = this.x + 方向.dx;
                    let 当前Y = this.y + 方向.dy;
                    let 路径 = [];

                    while (Math.abs(当前X - this.x) + Math.abs(当前Y - this.y) <= this.攻击范围) {
                        if (!检查移动可行性(当前X - 方向.dx, 当前Y - 方向.dy, 当前X, 当前Y)) break;

                        const 单元格 = 地牢[当前Y]?.[当前X];


                        if (单元格?.关联怪物 && 单元格.类型 === 单元格类型.怪物 && 单元格.关联怪物?.状态 === 怪物状态.活跃) {
                            单元格.关联怪物.受伤(this.攻击力, this);
                            break;
                        }

                        else if (当前X === 玩家.x && 当前Y === 玩家.y) {
                            伤害玩家(this.攻击力, this);
                            break;
                        }

                        路径.push({ x: 当前X, y: 当前Y });
                        当前X += 方向.dx;
                        当前Y += 方向.dy;
                    }
                    计划显示格子特效(路径);
                });
            }

            召唤术() {
                if (this.技能冷却.召唤术 > 0) return false;
                const 方向 = [
                    { dx: -1, dy: -1 },
                    { dx: 1, dy: -1 },
                    { dx: -1, dy: 1 },
                    { dx: 1, dy: 1 },
                ];
                let 召唤位置 = null;
                for (const { dx, dy } of 方向) {
                    const x = this.x + dx;
                    const y = this.y + dy;
                    if (this.位置合法(x, y) && !地牢[y][x].关联怪物 && !地牢[y][x].关联物品) {
                        召唤位置 = { x, y };
                        break;
                    }
                }
                if (!召唤位置) {
                    添加日志(`${this.类型} 尝试召唤，但周围没有可用空间！`, "信息");
                    return false;
                }
                const 追踪数 = 跟踪玩家怪物数;
                let 召唤数量 = 2;
                if (追踪数 >= 5) {
                    return false;
                } else if (追踪数 >= 3) {
                    召唤数量 = 1;
                }
                const 可召唤怪物 = [];
                for (let 房间类型 in 怪物池) {
                    怪物池[房间类型].forEach(怪物配置 => {
                        if (怪物配置.类 !== 大魔法师) {
                            可召唤怪物.push(怪物配置);
                        }
                    });
                }
                for (let i = 0; i < 召唤数量; i++) {
                    const 总权重 = 可召唤怪物.reduce((sum, m) => sum + m.权重, 0);
                    let 随机值 = Math.random() * 总权重;
                    let 选中配置 = null;

                    for (const m of 可召唤怪物) {
                        if (随机值 <= m.权重) {
                            选中配置 = m;
                            break;
                        }
                        随机值 -= m.权重;
                    }
                    const 新怪物 = new 选中配置.类({
                        x: 召唤位置.x,
                        y: 召唤位置.y,
                        房间ID: 房间地图[召唤位置.y][召唤位置.x],
                        状态: 怪物状态.活跃,
                    });
                    放置怪物到单元格(新怪物, 召唤位置.x, 召唤位置.y);

                    计划显示格子特效([{ x: 召唤位置.x, y: 召唤位置.y }], "800080");
                    for (const { dx, dy } of 方向) {
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (this.位置合法(x, y) && !地牢[y][x].关联怪物 && !地牢[y][x].关联物品) {
                            召唤位置 = { x, y };
                            break;
                        }
                    }
                }
                显示通知(`${this.类型} 使用了召唤术！`, "信息");
                this.技能冷却.召唤术 = 8;
                return true;
            }

            隐身术() {
                if (this.隐身中) return;

                this.逃离目标 = this.选择逃离目标();
                this.隐身中 = true;
                this.基础移动距离 = 2;
                this.绘制血条(true);
                添加日志(`${this.类型} 使用了隐身术!`, "信息");
            }


            分身术() {
                if (this.技能冷却.分身术 > 0 || this.分身?.当前生命值 > 0 || this.isClone) return;
                if (this.分身?.当前生命值 > 0) {
                    this.分身.恢复原始类型();
                    this.分身.血条元素.remove();
                    所有怪物 = 所有怪物.filter((m) => m !== this.分身);
                }
                let x = this.x;
                let y = this.y;
                const 分身 = new 大魔法师({
                    x: x,
                    y: y,
                    当前生命值: this.当前生命值,
                    房间ID: this.房间ID,
                });
                this.分身 = 分身;
                分身.isClone = true;
                let 放置 = 怪物放置物品(分身, x, y);
                if (放置.x === null) {
                    this.分身.当前生命值 = 0;
                }
                this.尝试移动();
                添加日志(`${this.类型} 使用了分身术!`, "信息");
                this.技能冷却.分身术 = 10;
            }

            火球术() {
                if (this.技能冷却.火球术 > 0) return false;

                const 最大距离 = 8;
                const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;


                if (玩家距离 > 0 && 玩家距离 <= 最大距离) {

                    const 攻击路径 = this.计算目标路径(玩家.x, 玩家.y);
                    if (攻击路径) {
                        计划显示格子特效(攻击路径);

                        const 扔出炸弹 = new 炸弹({ 能否拾起: false, 颜色索引: 4 });
                        let 目标 = {};
                        目标 = 玩家放置物品(扔出炸弹);
                        if (目标.x !== null || 目标.y !== null) {
                            扔出炸弹.使用(false, 目标.x, 目标.y);
                        }
                        添加日志(`${this.类型} 使用了火球术!`, "信息");
                        this.技能冷却.火球术 = 4;
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }

            冰冻术() {
                if (this.技能冷却.冰冻术 > 0) return false;
                const 玩家距离 = this.计算目标路径(玩家.x, 玩家.y).length;
                const 范围 = 2;
                if (玩家距离 > 范围) return false;
                for (let dx = -范围; dx <= 范围; dx++) {
                    for (let dy = -范围; dy <= 范围; dy++) {
                        const x = this.x + dx;
                        const y = this.y + dy;
                        if (x >= 0 && x < 地牢大小 && y >= 0 && y < 地牢大小) {
                            const 单元格 = 地牢[y][x];

                            if (单元格.关联怪物 && 单元格.关联怪物.类型 !== "冰冻怪物" && 单元格.关联怪物.类型 !== "大魔法师") {
                                new 状态效果("冻结", "#2196F3", "冻", 3, null, null, 单元格.关联怪物);
                            }
                            if (x === 玩家.x && y === 玩家.y && ![...玩家装备.values()].some((item) => item.名称 === '冰盾')) {
                                伤害玩家(this.攻击力, this);
                                new 状态效果("冻结", "#2196F3", 图标映射.冰冻怪物, 3, 3);
                            }
                            if (单元格.关联物品 instanceof 炸弹) {
                                if (!单元格.关联物品.能否拾起) {
                                    单元格.关联物品.自定义数据.set("倒计时", 单元格.关联物品.自定义数据.get("爆炸时间"));
                                    单元格.关联物品.能否拾起 = true;
                                    所有炸弹 = 所有炸弹.filter((item) => item !== 单元格.关联物品);
                                    单元格.关联物品.x = null;
                                    单元格.关联物品.y = null;
                                    显示通知("炸弹已被熄灭！", "信息");
                                    绘制();
                                }
                            }
                        }
                        if (单元格.关联怪物?.类型 !== "大魔法师") {
                            计划显示格子特效([{ x: x, y: y }], "0000DD");
                        }

                    }
                }
                添加日志(`${this.类型} 使用了冰冻术!`, "信息");
                this.技能冷却.冰冻术 = 6;
                return true;
            }
            传送术() {
                if (this.技能冷却.传送术 > 0) return;

                const 最小距离 = 5;
                const 最大距离 = 10;


                const 可达点 = [];
                const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
                const 已访问 = new Set([`${this.x},${this.y} `]);

                const 方向 = [
                    { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                    { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                    { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                    { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" },
                ];

                while (队列.length > 0) {
                    const 当前 = 队列.shift();


                    if (当前.距离 >= 最小距离 && 当前.距离 <= 最大距离 && 已访问房间.has(房间地图[当前.y][当前.x])) {
                        可达点.push({ x: 当前.x, y: 当前.y });
                    }

                    if (当前.距离 > 最大距离) continue;


                    for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;
                        const 位置键 = `${新X},${新Y} `;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;
                        const 当前单元格 = 地牢[当前.y][当前.x];
                        const 目标单元格 = 地牢[新Y][新X];
                        if (当前单元格.墙壁[当前墙] || 目标单元格.墙壁[目标墙]) continue;
                        if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(目标单元格.类型)) continue;


                        if (!已访问.has(位置键) && this.位置合法(新X, 新Y)) {
                            已访问.add(位置键);
                            队列.push({ x: 新X, y: 新Y, 距离: 当前.距离 + 1 });
                        }
                    }
                }


                if (可达点.length > 0) {
                    const 目标点 = 可达点[Math.floor(Math.random() * 可达点.length)];
                    this.恢复原始类型();
                    this.保存新位置类型(目标点.x, 目标点.y);
                    this.x = 目标点.x;
                    this.y = 目标点.y;
                    地牢[this.y][this.x].类型 = 单元格类型.怪物;
                    地牢[this.y][this.x].关联怪物 = this;
                    添加日志(`${this.类型} 使用了传送术!`, "信息");
                    this.技能冷却.传送术 = 7;
                    绘制();
                }
            }
            受伤(伤害, 来源 = null) {
                if (this.当前生命值 > 0) {
                    this.当前生命值 -= 伤害;
                    if (!(来源 instanceof 怪物)) {
                        this.受伤冻结回合剩余 = this.受伤冻结回合;
                    }
                    this.触发受击动画();

                    if (this.当前生命值 <= 0) {
                        if (来源 === "玩家") {
                            已击杀怪物数++;
                            击杀提示.更新({ 内容: `已击杀怪物：${已击杀怪物数} ` });
                            const 装备宠物列表 = [...玩家装备.values()].filter(装备 => 装备 instanceof 宠物);
                            装备宠物列表.forEach(宠物 => {

                                const 经验值 = Math.floor(this.基础生命值 / 10);
                                宠物.获得经验(经验值);
                            });
                        }
                        if (来源 instanceof 宠物) {
                            const 经验值 = Math.floor(this.基础生命值 / 10);
                            来源.获得经验(经验值);
                        }

                        this.恢复原始类型();
                        this.血条元素.remove();
                        所有怪物 = 所有怪物.filter((m) => m !== this);


                        if (this.isClone !== true && Math.random() <= this.掉落概率 * 玩家属性.掉落倍率) {
                            if (this.掉落物.自定义数据.get("耐久")) this.掉落物.自定义数据.set("耐久", Math.floor(Math.min(this.掉落物.自定义数据.get("耐久"), this.掉落物.自定义数据.get("耐久") * 玩家属性.掉落倍率 * Math.random() * Math.random())))
                            if (房间地图[this.y][this.x] === -1) {
                                放置物品到单元格(this.掉落物, this.x, this.y);
                            } else if (房间列表[房间地图[this.y][this.x]]) {
                                生成奖励(房间列表[房间地图[this.y][this.x]]);
                                显示通知("大魔法师被彻底抹除了...")
                            }

                        }

                        const 玩家单元格 = 地牢[玩家.y][玩家.x];
                        if (
                            玩家单元格.关联物品 &&
                            玩家单元格.类型 === 单元格类型.物品
                        ) {
                            if (尝试收集物品(玩家单元格.关联物品)) {
                                玩家单元格.类型 = 玩家单元格.原始类型;
                                玩家单元格.关联物品 = null;
                            }
                        }
                        return;
                    }
                    this.绘制血条();
                }
            }

            更新技能冷却() {
                for (const 技能 in this.技能冷却) {
                    if (this.技能冷却[技能] > 0) {
                        this.技能冷却[技能]--;
                    }
                }
            }
            绘制血条(隐藏血条 = false) {
                if (this.隐身中) {
                    this.血条元素.style.display = "none";
                    return;
                }
                super.绘制血条(隐藏血条);
            }

        }

        class 炸弹怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    基础移动距离: 2,
                    图标: 图标映射.炸弹怪物,
                    类型: "炸弹怪物",
                    掉落物: new 炸弹({
                        数量: Math.floor(Math.random() * 5) + 1,
                    }),
                    房间ID: 配置.房间ID || null,
                    强化: 配置.强化 || false,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    生命值: 配置.基础生命值 || 45,
                    基础攻击力: 配置.基础攻击力 || 3,
                    移动率: 配置.移动率 || 0.7,
                });
                this.携带炸弹 = true;
            }

            尝试移动() {
                super.尝试移动();
                if (this.携带炸弹) {

                    const 距离 =
                        Math.abs(this.x - 玩家.x) +
                        Math.abs(this.y - 玩家.y); //不想增加魅惑逻辑了...
                    if (距离 <= this.攻击范围) {
                        this.放置炸弹();
                        this.携带炸弹 = false;
                        this.基础移动距离 = 1; // 恢复普通怪物
                        this.图标 = 图标映射.怪物;
                    }
                }
            }

            放置炸弹() {
                const 扔出炸弹 = new 炸弹({ 能否拾起: false, 颜色索引: 4 });
                let 目标 = {};
                目标 = 玩家放置物品(扔出炸弹);
                if (目标.x !== null || 目标.y !== null) {
                    扔出炸弹.使用(false, 目标.x, 目标.y);
                }
            }
        }
        class 盔甲怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.盔甲怪物,
                    类型: "盔甲怪物",
                    强化: 配置.强化 || false,
                    掉落物: new 钢制板甲({
                        数量: 1,
                    }),
                    掉落概率: 0.5,
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    生命值: 配置.基础生命值 || 35,
                });
            }
        }
        class 敏捷怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    基础移动距离: 3,
                    跟踪距离: 40,
                    图标: 图标映射.敏捷怪物,
                    类型: "敏捷怪物",
                    强化: 配置.强化 || false,
                    掉落物: new 迅捷卷轴({
                        数量: 1,
                    }),
                    掉落概率: 0.3,
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    生命值: 配置.基础生命值 || 30,
                    基础攻击力: 配置.基础攻击力 || 4,
                    移动率: 配置.移动率 || 0.85,
                });
            }
        }
        class 远攻怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.远攻怪物,
                    类型: "远攻怪物",
                    掉落物: new 橡木法杖({
                        数量: 1,
                    }),
                    掉落概率: 0.3,
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    强化: 配置.强化 || false,
                    生命值: 配置.基础生命值 || 35,
                    基础攻击力: 配置.基础攻击力 || 3,
                    移动率: 配置.移动率 || 0.7,
                    基础攻击范围: 3,
                    跟踪距离: 25,
                });
            }
        }
        class 仙人掌怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.仙人掌怪物,
                    类型: "仙人掌怪物",
                    掉落概率: 0.3,
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    强化: 配置.强化 || false,
                    生命值: 配置.基础生命值 || 30,
                    基础攻击力: 配置.基础攻击力 || 3,
                    移动率: 配置.移动率 || 0.7,
                });
            }
            受伤(伤害, 来源 = null) {
                if (来源 === "玩家") {
                    伤害玩家(this.攻击力, this);
                }
                super.受伤(伤害, 来源);
            }
        }
        class 冰冻怪物 extends 怪物 {
            constructor(配置 = {}) {
                super({
                    图标: 图标映射.冰冻怪物,
                    类型: "冰冻怪物",
                    掉落物: new 冰盾({
                        数量: 1,
                    }),
                    掉落概率: 配置.掉落概率 || 0.3,
                    房间ID: 配置.房间ID || null,
                    x: 配置.x || null,
                    y: 配置.y || null,
                    状态: 配置.状态 || 怪物状态.休眠,
                    强化: 配置.强化 || false,
                    生命值: 配置.基础生命值 || 25,
                    基础攻击力: 配置.基础攻击力 || 3,
                    移动率: 配置.移动率 || 0.7,
                    基础攻击范围: 1,
                    跟踪距离: 25,
                    攻击冷却: 4,
                });
            }
            尝试攻击() {
                if (玩家状态.some(s => s.类型 === "冻结") && this.攻击冷却回合剩余 === 0) {//倘若已有效果则不攻击，缓冲攻击冷却给其它怪物起辅助作用
                    return false;
                }
                if (super.尝试攻击()) {
                    if (怪物状态表.get(this)?.类型 === "魅惑") {
                        new 状态效果("冻结", "#2196F3", "冻", 3, null, null, this.魅惑目标怪物);
                    } else if (![...玩家装备.values()].some(
                        (item) => item.名称 === '冰盾')) {
                        new 状态效果("冻结", "#2196F3", 图标映射.冰冻怪物, 3, 3); // 添加冻结效果
                    }
                }
            }
            获得效果(状态效果) {
                if (状态效果.类型 === "冻结") {
                    状态效果.移除状态();
                    return false;
                }
                if (状态效果.类型 === "火焰") {
                    this.恢复原始类型();
                    this.血条元素.remove();
                    所有怪物 = 所有怪物.filter((m) => m !== this);
                    const 新怪物 = new 怪物({
                        x: this.x,
                        y: this.y,
                        当前生命值: this.当前生命值,
                    });
                    放置怪物到单元格(新怪物, this.x, this.y);
                }
                return true;
            }
        }
        class 物品 {
            constructor(配置 = {}) {
                this.类型 = 配置.类型 || "其他物品";
                this.名称 = 配置.名称 || "未命名物品";
                this.图标 = 配置.图标 || "◎";
                this.品质 = 配置.品质 || 1;
                this.堆叠数量 = 配置.堆叠数量 || 1;
                this.最大堆叠数量 = 配置.最大堆叠数量 || 最大堆叠数;
                this.颜色索引 = 配置.颜色索引 || 0;
                this.自定义数据 = new Map(Object.entries(配置.数据 || {}));
                const date = new Date();
                this.唯一标识 = 配置.唯一标识 || Symbol(date.toString);
                this.已装备 = 配置.已装备 || false;
                this.装备槽位 = 配置.已装备 || null;
                this.x = 配置.x || null;
                this.y = 配置.y || null;
                this.显示元素 = null;
                this.isActive = false; //屎山莫动
                this.强化 = 配置.强化 || false;
                this.能否拾起 = (配置.能否拾起 === undefined) ? true : 配置.能否拾起;
                this.是否正常物品 = (配置.是否正常物品 === undefined) ? true : 配置.是否正常物品; // 用于配置是否是只能存在于地图上被玩家使用的物品
                this.效果描述 = 配置.效果描述 || null;
                this.是否隐藏 = 配置.是否隐藏 || false; //是否在背包中显示
                this.是否为隐藏物品 = 配置.是否为隐藏物品 || false; //是否在地图上显示
            }
            装备() {
                if (this.已装备) return false;

                // 寻找空装备槽
                const 空槽 = [1, 2, 3, 4].find(
                    (id) =>
                        ![...玩家装备.values()].some(
                            (item) => item.装备槽位 === id
                        )
                );

                if (空槽) {
                    this.已装备 = true;
                    this.装备槽位 = 空槽;
                    玩家装备.set(this.装备槽位, this);
                    更新装备显示();
                    return true;
                }
                return false;
            }

            取消装备() {
                if (!this.已装备) return false;
                玩家装备.delete(this.装备槽位);
                this.已装备 = false;
                this.装备槽位 = null;
                更新装备显示();
                return true;
            }
            // 通用方法：获取显示名称（可被子类覆盖）
            获取名称() {
                return (
                    `${this.名称} [${this.品质} 级]` +
                    (this.强化 ? ` [强化]` : ``)
                );
            }

            // 通用方法：使用物品（返回能否使用该物品，需要自己处理物品消耗，不用处理物品移除）
            使用() {
                this.堆叠数量 -= 1;
                return true;
            }

            // 通用方法：能否与目标交互（如开门、攻击等）
            可交互目标(目标) {
                return false; // 默认无交互
            }
            刷新显示() {
                //你应该在打开背包界面时使用它
                this.显示元素.innerHTML = `
            < div class="物品图标" > ${this
                        .图标
                    }</div >
            <div class="物品名称">${this.获取名称()}</div>
                                                                        ${this
                        .堆叠数量 >
                        1
                        ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
                        : ""
                    }
        `;
            }

            // 通用方法：获取悬停提示信息
            获取提示() {
                if (this.效果描述 !== null) {
                    return [
                        `${this.获取名称()} `,
                        `类型：${this.类型} `,
                        `品质：${"★".repeat(this.品质)} `,
                        `堆叠：${this.堆叠数量} `,
                        `效果描述：${this.效果描述} `,
                    ].join("\n");
                } else {
                    return [
                        `${this.获取名称()} `,
                        `类型：${this.类型} `,
                        `品质：${"★".repeat(this.品质)} `,
                        `堆叠：${this.堆叠数量} `,
                    ].join("\n");
                }

            }
            安全销毁() {
                this.取消装备();
                this.自定义数据.clear();
                this.唯一标识 = null;
                return true;
            }
            get 显示图标() {
                return this.图标; // 子类可以覆写此方法来修改背包内图标
            }
            get 显示名称() {
                return this.名称; // 子类可以覆写此方法来修改显示元素内名称，防止装备栏显示名称过长
            }
            get 颜色表() {
                return 颜色表;
            }
            // 通用方法：生成显示元素
            生成显示元素(用途 = "背包") {
                const 元素 = document.createElement("div");
                元素.className = "物品条目 hover";
                元素.setAttribute("data-quality", this.品质);
                if (用途 === "背包") {
                    元素.innerHTML = `
                                                                        <div class="物品图标">${this
                            .显示图标
                        }</div>
                                                                        <div class="物品名称">${this.获取名称()}</div>
                                                                        ${this
                            .堆叠数量 >
                            1
                            ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
                            : ""
                        }
                                                                    `;
                    this.显示元素 = 元素;
                } else if (用途 === "装备") {
                    元素.innerHTML = `
                                                                        <div class="物品图标">${this
                            .显示图标
                        }</div>
                                                                        <div class="物品名称">${this
                            .显示名称
                        }</div>
                                                                        ${this
                            .堆叠数量 >
                            1
                            ? `<div class="物品堆叠">x${this.堆叠数量}</div>`
                            : ""
                        }
                                                                    `;
                }
                if (this.isActive) {
                    元素.classList.add("active");
                }

                元素.addEventListener("click", () => {
                    this.isActive = true;
                    元素.classList.add("active");

                    // 点击时其他元素取消激活
                    document.querySelectorAll(".物品条目").forEach((el) => {
                        if (el !== 元素 && el.__物品实例) {
                            el.classList.remove("active");
                            el.__物品实例.isActive = false;
                        }
                    });
                });
                元素.__物品实例 = this;
                // 图标样式
                const 图标元素 = 元素.querySelector(".物品图标");
                图标元素.style = `
                                                                        color: ${this
                        .颜色表[
                    this
                        .颜色索引
                    ]
                    };
                                                                        font-size: 2.5em;
                                                                        text-shadow: 0 0 8px ${this
                        .颜色表[
                    this
                        .颜色索引
                    ]
                    };
                                                                    `;

                // 销毁按钮
                const 销毁按钮 = document.createElement("button");
                销毁按钮.className = "销毁按钮";
                销毁按钮.innerHTML = "×";
                销毁按钮.addEventListener("click", (e) => {
                    e.stopPropagation();
                    处理销毁物品(this.唯一标识);
                });
                元素.prepend(销毁按钮);

                // 使用按钮
                const 使用按钮 = document.createElement("button");
                使用按钮.className = "使用按钮";
                使用按钮.innerHTML = "⚡";
                使用按钮.onclick = (e) => {
                    e.stopPropagation();
                    this.isActive = true;
                    使用背包物品(this.唯一标识);
                };
                元素.prepend(使用按钮);

                元素.addEventListener("mousemove", (e) => {
                    const 提示框 = document.getElementById("浮动提示框");
                    提示框.innerHTML = this.获取提示().replace(
                        /\n/g,
                        "<br>"
                    );
                    提示框.style.left = `${e.pageX + 15}px`;
                    提示框.style.top = `${e.pageY + 15}px`;
                    提示框.style.display = "block";
                });

                元素.addEventListener("mouseleave", () => {
                    document.getElementById("浮动提示框").style.display =
                        "none";
                    if (元素.__物品实例) {
                        元素.classList.remove("active");
                        元素.__物品实例.isActive = false;
                    }
                });
                this.装备按钮 = null;
                this.装备按钮 = document.createElement("button");
                this.装备按钮.className = "装备按钮";
                this.装备按钮.innerHTML = 图标映射.装备按钮;
                this.装备按钮.onclick = (e) => {
                    e.stopPropagation();
                    this.isActive = true;
                    if (this.已装备) {
                        this.取消装备();
                        显示通知("已卸下", "成功");
                    } else {
                        if (this.装备()) {
                            显示通知("已装备", "成功");
                        } else {
                            显示通知("槽位已满", "错误");
                        }
                    }
                    this.装备按钮.style.background = this.已装备
                        ? "#f44336"
                        : "#FF9800";
                    更新装备显示();
                    更新背包显示();

                    document.getElementById("浮动提示框").style.display =
                        "none";
                };
                this.装备按钮.style.background = this.已装备
                    ? "#f44336"
                    : "#FF9800";
                元素.prepend(this.装备按钮);
                return 元素;
            }
            可堆叠于(其他物品) {
                if (
                    this.堆叠数量 >= this.最大堆叠数量 ||
                    this.堆叠数量 >= 最大堆叠数
                )
                    return false;
                // 基础属性比较
                const 基础相同 =
                    this.类型 === 其他物品.类型 &&
                    this.名称 === 其他物品.名称 &&
                    this.图标 === 其他物品.图标 &&
                    this.品质 === 其他物品.品质 &&
                    this.强化 === 其他物品.强化 &&
                    this.获取名称() === 其他物品.获取名称();
                //this.获取提示() === 其他物品.获取提示();

                // 自定义数据比较
                const 数据相同 = this.比较自定义数据(其他物品.自定义数据);

                return 基础相同 && 数据相同;
            }
            比较自定义数据(其他数据) {
                if (this.自定义数据.size !== 其他数据.size) return false;

                for (const [键, 值] of this.自定义数据) {
                    if (!其他数据.has(键)) return false;

                    const 其他值 = 其他数据.get(键);
                    if (typeof 值 === "object" && 值 !== null) {
                        if (!深度比较(值, 其他值)) return false;
                    } else if (值 !== 其他值) {
                        return false;
                    }
                }
                return true;
            }
        }
        class 钥匙 extends 物品 {
            constructor(配置) {
                let 钥匙唯一标识 = Symbol.for(
                    配置.地牢层数.toString() + "层" + 配置.门ID.toString()
                );
                super({
                    类型: "钥匙",
                    名称: "钥匙",
                    图标: 图标映射.钥匙,
                    品质: 2,
                    颜色索引: 配置.颜色索引,
                    唯一标识: 钥匙唯一标识,
                    数据: {
                        对应门ID: 配置.门ID,
                        地牢层数: 配置.地牢层数,
                    },
                });
            }

            获取名称() {
                const 颜色名 = 颜色名表[this.颜色索引] || "未知";
                return `${颜色名} 铜钥匙`;
            }

            可交互目标(门实例) {
                if (
                    门实例.类型 == "上锁的门" &&
                    (this.自定义数据.get("地牢层数") == 当前层数 || this.自定义数据.get("地牢层数") == -1)
                ) {
                    return (
                        this.自定义数据.get("对应门ID") === 门实例.房间ID
                    );
                }
            }
            获取提示() {
                return [
                    `类型：${this.类型} `,
                    `品质：${"★".repeat(this.品质)} `,
                    `房间 ID：${this.自定义数据.get("对应门ID")} `,
                    `层数：${this.自定义数据.get("地牢层数")} `,
                ].join("\n");
            }
            使用() {
                显示通知("请使用互动键来使用钥匙", "错误");
                return false;
            }
        }
        class 金币 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "金币",
                    名称: "金币",
                    图标: 图标映射.金币,
                    品质: 1,
                    颜色索引: 2,
                    堆叠数量: 配置.数量 || 1,
                });
            }

            获取名称() {
                return `${this.名称} `;
            }
            使用() {
                return false;
            }
        }

        class 武器类 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "武器",
                    名称: 配置.名称 || "铁剑",
                    图标: 配置.图标 || "⚔️",
                    品质: 配置.品质 || 1,
                    颜色索引: 配置.品质 - 1 || 0,
                    堆叠数量: 配置.堆叠数量 || 1,
                    最大堆叠数量: 1,
                    效果描述: 配置.效果描述 || null,
                    强化: 配置.强化 || false,
                    数据: {
                        ...配置.数据,
                        基础攻击力: 配置.基础攻击力 || 3,
                        冷却回合: 配置.冷却回合 || 1,
                        冷却剩余: 0,
                        攻击范围: 配置.攻击范围 || 1,
                        耐久: 配置.耐久 || 30,
                        原耐久: 配置.耐久 || 30,
                        不可破坏: 配置.不可破坏 || false,
                        攻击目标数: 配置.攻击目标数 || 1,
                        附魔: [],
                    },
                });
            }

            使用(目标怪物) {
                if (
                    this.堆叠数量 <= 0 ||
                    this.自定义数据.get("冷却剩余") > 0
                )
                    return false;

                const 总伤害 = this.攻击力;

                目标怪物.forEach((怪物) => {
                    if (怪物.当前生命值 > 0) 怪物.受伤(总伤害, "玩家");
                });

                this.自定义数据.set(
                    "耐久",
                    this.自定义数据.get("耐久") - this.耐久消耗
                );
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }
                if (目标怪物.length > 1) {
                    if (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级) {
                        目标怪物.forEach((目标) => {
                            const 火焰状态 = new 状态效果("火焰", "#CC5500", "火", this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔")?.等级, null, null, 目标);
                        });
                    }
                    显示通知(
                        `${this.名称} 造成 ${目标怪物.length}x${总伤害} 点伤害！`,
                        "成功"
                    );
                    if (目标怪物.length >= 5 && !彩蛋1触发) {
                        显示通知('哦...那可真是实打实的能打', '成功', true);
                        彩蛋1触发 = true;
                    }
                } else {
                    if (this.自定义数据.get("附魔")?.find((item) => item.种类 === "火焰附魔")?.等级) {
                        const 火焰状态 = new 状态效果("火焰", "#CC5500", "火", this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔")?.等级, null, null, 目标怪物.shift());
                    }
                    显示通知(
                        `${this.名称} 造成 ${总伤害} 点伤害！`,
                        "成功"
                    );
                }
                const 连锁附魔 = this.自定义数据.get("附魔")?.find(item => item.种类 === "连锁附魔");
                if (连锁附魔) {
                    const 连锁距离 = 连锁附魔.等级;
                    目标怪物.forEach(初始目标 => {
                        this.触发连锁(初始目标, 连锁距离, [初始目标]);
                    });
                }
                this.自定义数据.set(
                    "冷却剩余",
                    Math.max(
                        this.自定义数据.get("冷却回合") -
                        (this.强化 ? 1 : 0),
                        0
                    )
                );
                return true;
            }
            触发连锁(当前目标, 连锁距离, 已攻击过的怪物 = []) {
                let 第一层 = false
                if (this.访问过 === undefined) {
                    this.访问过 = [];
                    第一层 = true;
                }
                if (this.访问过.includes(当前目标)) return;
                this.访问过.push(当前目标)
                if (连锁距离 <= 0) return;
                const 可连锁目标 = this.寻找连锁目标(当前目标, 连锁距离, this.访问过);
                for (const 新目标 of 可连锁目标) {
                    计划显示格子特效(新目标.路径);
                    this.使用([新目标.怪物]);
                    添加日志(`连锁附魔击中了 ${新目标.怪物.类型}！`, "成功");
                }
                if (第一层) this.访问过 = undefined
            }
            寻找连锁目标(中心怪物, 连锁距离, 已攻击过的怪物) {
                const 开放列表 = [{ x: 中心怪物.x, y: 中心怪物.y, 距离: 0, 路径: [] }];
                const 已访问 = new Set([`${中心怪物.x},${中心怪物.y} `]);
                const 可连锁目标 = [];

                for (const 怪物 of 已攻击过的怪物) {
                    已访问.add(`${怪物.x},${怪物.y} `);
                }

                const 方向 = [
                    { dx: 1, dy: 0, 当前墙: "右", 目标墙: "左" },
                    { dx: -1, dy: 0, 当前墙: "左", 目标墙: "右" },
                    { dx: 0, dy: 1, 当前墙: "下", 目标墙: "上" },
                    { dx: 0, dy: -1, 当前墙: "上", 目标墙: "下" }
                ];

                while (开放列表.length > 0) {
                    const 当前 = 开放列表.shift();

                    if (当前.距离 >= 连锁距离) continue;

                    for (const { dx, dy, 当前墙, 目标墙 } of 方向) {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;

                        if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小) continue;

                        const 位置键 = `${新X},${新Y} `;
                        if (已访问.has(位置键)) continue;

                        const 当前单元格 = 地牢[当前.y][当前.x];
                        const 目标单元格 = 地牢[新Y][新X];

                        if (当前单元格.墙壁[当前墙] || 目标单元格.墙壁[目标墙] || 目标单元格.类型 === 单元格类型.墙壁 || 目标单元格.类型 === 单元格类型.上锁的门) continue;

                        const 新路径 = [...当前.路径, { x: 新X, y: 新Y }];

                        if (目标单元格.类型 === 单元格类型.怪物 && 目标单元格.关联怪物?.状态 === 怪物状态.活跃) {
                            可连锁目标.push({ 怪物: 目标单元格.关联怪物, 路径: 新路径 });
                            已访问.add(位置键);
                        }
                        已访问.add(位置键);
                        开放列表.push({ x: 新X, y: 新Y, 距离: 当前.距离 + 1, 路径: 新路径 });
                    }
                }

                return 可连锁目标;
            }
            获取提示() {
                return this.效果描述 === null ? [`${this.获取名称()} `,
                `品质：${"★".repeat(this.品质)} `,
                `攻击力：${this.攻击力} `,
                `耐久：${this.自定义数据.get("耐久")} `,
                `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                `范围：${this.自定义数据.get("攻击范围")} 格`,
                获取附魔描述(this.自定义数据.get("附魔")),
                this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n") : [
                    `${this.获取名称()} `,
                    `攻击力：${this.攻击力} `,
                    `耐久：${this.自定义数据.get("耐久")} `,
                    `冷却：${this.自定义数据.get("冷却剩余")} 回合`,
                    `范围：${this.自定义数据.get("攻击范围")} 格`,
                    `效果描述：${this.效果描述} `,
                    获取附魔描述(this.自定义数据.get("附魔")),
                    this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                ].join("\n");
            }
            获取名称() {
                return (
                    super.获取名称() +
                    (this.自定义数据.get("攻击目标数") > 1
                        ? " [范围武器]"
                        : "")
                );
            }
            get 攻击力() {
                return (
                    this.自定义数据.get("基础攻击力") +
                    this.品质 +
                    (this.强化 ? 2 : 0) + 玩家属性.攻击加成 +
                    (this.自定义数据.get("附魔").find((item) => item.种类 === "锋利附魔")?.等级 * 2 || 0)
                );
            }
            get 耐久消耗() {
                if (this.自定义数据.get("不可破坏")) return 0;
                if (this.自定义数据.get("附魔").find((item) => item.种类 === "耐久附魔")?.等级 > 0) return 1 / (this.自定义数据.get("附魔").find((item) => item.种类 === "耐久附魔")?.等级 + 1);
                return 1;
            }
        }
        class 卷轴类 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "卷轴",
                    名称: 配置.名称 || "魔法卷轴",
                    效果描述: 配置.效果描述 || "未知效果",
                    图标: 配置.图标 || 图标映射.卷轴,
                    品质: 配置.品质 || 3,
                    颜色索引: 配置.品质 - 1 || 2,
                    堆叠数量: 配置.堆叠数量 || 1,
                    强化: 配置.强化 || false,
                    最大堆叠数量: 1,
                    数据: {
                        ...配置.数据,
                        能量消耗: 配置.能量消耗 || 2,
                        已解锁: 配置.已解锁 || false,
                    },
                });
            }
            安全销毁() {
                if (当前激活卷轴列表.has(this)) 当前激活卷轴列表.delete(this);
                let ret = super.安全销毁();
                document.getElementById("卷轴按钮").style.display = [
                    ...玩家装备.values(),
                ].some((item) => item.类型 === "卷轴")
                    ? "flex"
                    : "none";
                return ret;
            }
            使用() {
                // 具体效果由子类实现
                return false;
            }
            获取名称() {
                return this.自定义数据.get("已解锁")
                    ? `${this.名称} [${this.品质} 级]` +
                    (this.强化 ? " [强化]" : "")
                    : "卷轴";
            }
            消耗能量() {
                return 卷轴扣除能量(this.最终能量消耗);
            }
            get 最终能量消耗() {
                return Math.max(
                    this.自定义数据.get("能量消耗") - (this.强化 ? 2 : 0),
                    0
                );
            }
            get 显示图标() {
                return this.自定义数据.get("已解锁")
                    ? this.图标
                    : 图标映射.卷轴;
            }
            get 显示名称() {
                return this.自定义数据.get("已解锁") ? this.名称 : "卷轴";
            }
            生成显示元素(用途 = "背包") {
                let 元素 = super.生成显示元素(用途);
                this.装备按钮.onclick = (e) => {
                    e.stopPropagation();
                    this.isActive = true;
                    if (this.已装备) {
                        this.取消装备();
                        显示通知("已卸下", "成功");
                    } else {
                        if (this.装备()) {
                            显示通知("已装备", "成功");
                        } else {
                            显示通知("装备槽已满！", "错误");
                        }
                    }
                    this.装备按钮.style.background = this.已装备
                        ? "#f44336"
                        : "#FF9800";
                    更新装备显示();
                    更新背包显示();
                    if (this instanceof 卷轴类) {
                        document.getElementById("卷轴按钮").style.display =
                            [...玩家装备.values()].some(
                                (item) => item.类型 === "卷轴"
                            )
                                ? "flex"
                                : "none";
                    }
                    document.getElementById("浮动提示框").style.display =
                        "none";
                };

                return 元素;
            }
            取消装备() {
                if (!this.已装备) return false;
                if (当前激活卷轴列表.has(this)) {
                    恢复卷轴模式();
                    当前激活卷轴列表.delete(this);
                    this.卸下();
                }
                let ret = super.取消装备();
                document.getElementById("卷轴按钮").style.display = [
                    ...玩家装备.values(),
                ].some((item) => item.类型 === "卷轴")
                    ? "flex"
                    : "none";
                return ret;
            }
            卸下() {
                return true;
            }
            获取提示() {
                if (this.自定义数据.get("已解锁")) {
                    return [
                        `${this.获取名称()} `,
                        `品质：${"★".repeat(this.品质)} `,
                        `能量消耗：${this.最终能量消耗} `,
                        `效果描述：${this.效果描述} `,
                    ].join("\n");
                } else {
                    return "古老的卷轴，似乎透露着什么秘密...";
                }
            }
        }
        class 防御装备类 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "防御装备",
                    名称: 配置.名称 || "护甲模板",
                    图标: 配置.图标 || "🛡️",
                    品质: 配置.品质 || 2,
                    颜色索引: 配置.品质 - 1 || 1,
                    最大堆叠数量: 1,
                    堆叠数量: 配置.堆叠数量 || 1,
                    效果描述: 配置.效果描述 || null,
                    强化: 配置.强化 || false,
                    数据: {
                        ...配置.数据,
                        防御力: 配置.防御力 || 1,
                        耐久: 配置.耐久 || 100,
                        原耐久: 配置.耐久 || 100,
                        不可破坏: 配置.不可破坏 || false,
                        附魔: [],
                    },
                });
            }
            使用() {
                return false;
            }
            get 最终防御力() {
                return this.自定义数据.get("防御力") + (this.强化 ? 2 : 0) + (this.自定义数据.get("附魔").find((item) => item.种类 === "保护附魔")?.等级 || 0);
            }
            get 耐久消耗() {
                if (this.自定义数据.get("不可破坏")) return 0;
                if (this.自定义数据.get("附魔").find((item) => item.种类 === "耐久附魔")?.等级 > 0) return 1 / (this.自定义数据.get("附魔").find((item) => item.种类 === "耐久附魔")?.等级 + 1) * (this.强化 ? 0.5 : 1);
                return this.强化 ? 0.5 : 1;
            }
            get 反伤() {
                if (this.自定义数据.get("附魔").find((item) => item.种类 === "荆棘附魔")?.等级 > 0) {
                    return this.自定义数据.get("附魔").find((item) => item.种类 === "荆棘附魔")?.等级 * 1.5;
                }
                return 0;
            }
            当被攻击(原始攻击力, 来源 = null) {
                // 基础防御计算
                let 最终伤害 = Math.max(0, 原始攻击力 - this.最终防御力);
                if (来源 === "炸弹" && this.自定义数据.get("附魔").some((item) => item.种类 === "爆炸保护附魔" && item.等级 > 0)) {
                    最终伤害 = Math.max(0, 原始攻击力 - (this.自定义数据.get("附魔").find((item) => item.种类 === "爆炸保护附魔")?.等级 * 5));
                }
                if (来源 instanceof 怪物 && this.自定义数据.get("附魔").some((item) => item.种类 === "火焰附魔" && item.等级 > 0)) {
                    const 火焰状态 = new 状态效果("火焰", "#CC5500", "火", this.自定义数据.get("附魔").find((item) => item.种类 === "火焰附魔")?.等级, null, null, 来源);
                }

                if (最终伤害 <= 0) 最终伤害 = Math.round(Math.random() * 100) / 100;

                // 耐久消耗
                this.自定义数据.set(
                    "耐久",
                    this.自定义数据.get("耐久") - this.耐久消耗
                );
                if (this.反伤 > 0 && 来源 instanceof 怪物) {
                    来源.受伤(this.反伤, "玩家");
                    添加日志(`${this.名称} 因荆棘造成了 ${this.反伤} 点伤害！`, "成功");
                }
                // 自动销毁逻辑
                if (this.自定义数据.get("耐久") <= 0) {
                    处理销毁物品(this.唯一标识, true);
                    显示通知(`${this.名称} 已损坏！`, "警告");
                }

                return 最终伤害;
            }

            获取提示() {
                if (this.效果描述 !== null) {
                    return [
                        `${this.获取名称()} `,
                        `防御力：${this.最终防御力} `,
                        `耐久：${this.自定义数据.get("耐久")} `,
                        `效果描述：${this.效果描述} `,
                        获取附魔描述(this.自定义数据.get("附魔")),
                        this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                    ].join("\n");
                } else {
                    return [
                        `${this.获取名称()} `,
                        `防御力：${this.最终防御力} `,
                        `耐久：${this.自定义数据.get("耐久")} `,
                        `品质：${"★".repeat(this.品质)} `,
                        获取附魔描述(this.自定义数据.get("附魔")),
                        this.自定义数据.get("不可破坏") ? '不可破坏' : '',
                    ].join("\n");
                }
            }
        }
        class 棋子 extends 物品 {
            constructor(配置) {
                super({
                    类型: "棋子",
                    名称: 配置.名称 || "棋子",
                    图标: 配置.图标,
                    品质: 1,
                    颜色索引: 2,
                    最大堆叠数量: 1,
                    效果描述: "使用可以在玩家位置落子，按互动键可以提子",
                    ...配置,
                });
                this.能否拾起 = true;
            }


            可攻击位置(x, y, 棋盘) {
                return [];
            }
            使用(玩家使用 = true, x0 = 0, y0 = 0) {
                super.使用();
                if (玩家使用) {
                    if (房间列表[房间地图[玩家.y][玩家.x]].类型 === "解谜棋盘") {
                        let ret = 玩家放置物品(this, false);
                        更新装备显示();
                        更新背包显示();
                        检查解谜是否成功(房间列表[房间地图[玩家.y][玩家.x]].棋子数量);
                        显示通知("落子成功", "成功")
                        return ret;
                    }

                }
                return false;
            }
        }

        class 国际象棋车 extends 棋子 {
            constructor(配置 = {}) {
                super({
                    名称: "国际象棋车",
                    图标: "♜",
                    ...配置,
                });
            }
            可攻击位置(x, y, 棋盘) {
                const 攻击位置 = [];
                const 棋盘大小 = 棋盘.length;


                for (let i = 0; i < 棋盘大小; i++) {
                    if (i !== x) 攻击位置.push({ x: i, y: y });
                }


                for (let j = 0; j < 棋盘大小; j++) {
                    if (j !== y) 攻击位置.push({ x: x, y: j });
                }

                return 攻击位置;
            }

        }

        class 国际象棋马 extends 棋子 {
            constructor(配置 = {}) {
                super({
                    名称: "国际象棋马",
                    图标: "♞",
                    ...配置,
                });
            }

            可攻击位置(x, y, 棋盘) {
                const 攻击位置 = [];
                const 棋盘大小 = 棋盘.length;
                const dx = [-2, -2, -1, -1, 1, 1, 2, 2];
                const dy = [-1, 1, -2, 2, -2, 2, -1, 1];
                for (let i = 0; i < 8; i++) {
                    const 新x = x + dx[i];
                    const 新y = y + dy[i];
                    if (新x >= 0 && 新x < 棋盘大小 && 新y >= 0 && 新y < 棋盘大小) {
                        攻击位置.push({ x: 新x, y: 新y });
                    }
                }
                return 攻击位置;
            }
        }

        class 国际象棋象 extends 棋子 {
            constructor(配置 = {}) {
                super({
                    名称: "国际象棋象",
                    图标: "♝",
                    ...配置,
                });
            }

            可攻击位置(x, y, 棋盘) {
                const 攻击位置 = [];
                const 棋盘大小 = 棋盘.length;


                const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (const [dx, dy] of directions) {
                    for (let i = 1; i < 棋盘大小; i++) {
                        const 新x = x + i * dx;
                        const 新y = y + i * dy;

                        if (新x >= 0 && 新x < 棋盘大小 && 新y >= 0 && 新y < 棋盘大小) {
                            攻击位置.push({ x: 新x, y: 新y });
                        } else {
                            break;
                        }
                    }
                }

                return 攻击位置;
            }
        }

        class 中国象棋炮 extends 棋子 {
            constructor(配置 = {}) {
                super({
                    名称: "中国象棋炮",
                    图标: "♚",
                    ...配置,
                });
            }

            可攻击位置(x, y, 棋盘) {
                const 攻击位置 = [];
                const 棋盘大小 = 棋盘.length;


                const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                for (const [dx, dy] of directions) {
                    let 隔子 = false;
                    for (let i = 1; i < 棋盘大小; i++) {
                        const 新x = x + i * dx;
                        const 新y = y + i * dy;

                        if (新x >= 0 && 新x < 棋盘大小 && 新y >= 0 && 新y < 棋盘大小) {
                            if (棋盘[新y][新x] !== 0) {
                                if (!隔子) {
                                    隔子 = true;
                                } else {
                                    攻击位置.push({ x: 新x, y: 新y });
                                    break;
                                }
                            } else if (!隔子) {
                                攻击位置.push({ x: 新x, y: 新y });
                            }
                        } else {
                            break;
                        }
                    }
                }

                return 攻击位置;
            }
        }
        class 药水类 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "药水",
                    名称: 配置.名称 || "基础药水",
                    图标: 配置.图标 || 图标映射.药水,
                    品质: 配置.品质 || 3,
                    颜色索引: 效果名称编号映射[配置.效果类型] || 0,
                    堆叠数量: 配置.堆叠数量 || 1,
                    最大堆叠数量: 16,
                    效果描述: 配置.效果描述 || null,
                    强化: 配置.强化 || false,
                    数据: {
                        ...配置.数据,
                        基础持续时间: 配置.持续时间 || 3,
                        效果强度: 配置.效果强度 || 1,
                        效果类型: 配置.效果类型 || null,
                    },
                });
                this.激活中 = false;
                this.状态效果 = null;
            }

            使用() {
                super.使用();
                if (this.激活中) {
                    显示通知(
                        `${this.自定义数据.get("效果类型")} 效果已存在`,
                        "错误"
                    );
                    return false;
                }

                // 应用效果
                this.激活中 = true;

                this.状态效果 = new 状态效果(this.自定义数据.get("效果类型"), this.获取药水颜色(), this.图标, this.持续时间, this.持续时间, this);

                // 应用实际效果
                this.应用效果();
                绘制();
                显示通知(`${this.名称} 效果生效！`, "成功");
                return true;
            }

            获取药水颜色() {
                return 效果颜色编号映射[this.颜色索引] || "#FFFFFF";
            }

            应用效果() {
                // 子类在这实现自定义效果...
                return;
            }

            移除效果() {
                //只考虑药水具有单一效果
                this.激活中 = false;
                // 移除HUD元素
                // 子类在这还原效果...
                return;
            }

            获取提示() {
                return [
                    super.获取提示(),
                    `效果类型: ${this.自定义数据.get("效果类型")} `,
                    `持续时间: ${this.持续时间} 回合`,
                    `强度: +${this.强度} `,
                ].join("\n");
            }
            get 强度() {
                return (
                    this.自定义数据.get("效果强度") + (this.强化 ? 2 : 0)
                );
            }
            get 持续时间() {
                return (
                    this.自定义数据.get("基础持续时间") +
                    (this.强化 ? 2 : 0)
                );
            }
            get 颜色表() {
                return 效果颜色编号映射;
            }
        }

        class 治疗药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "治疗药水",
                    效果类型: "治疗",
                    持续时间: 5,
                    效果强度: 2,
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                const 当前生命 =
                    parseFloat(
                        document.querySelector(".health-bar").style.width
                    ) || 0;
                document.querySelector(
                    ".health-bar"
                ).style.width = `${Math.min(
                    100,
                    当前生命 + 4 * this.强度 //实际强度由getter决定
                )
                }% `;
                return;
            }
            移除效果() {
                super.移除效果();
                return;
            }
        }

        class 能量药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "能量药水",
                    效果类型: "能量",
                    持续时间: 5,
                    效果强度: 2,
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                const 当前能量 =
                    parseFloat(
                        document.querySelector(".power-bar").style.width
                    ) || 0;
                document.querySelector(
                    ".power-bar"
                ).style.width = `${Math.min(
                    100,
                    当前能量 + 5 * this.强度
                )
                }% `;
                return;
            }
            移除效果() {
                super.移除效果();
                return;
            }
        }
        class 狂暴药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "狂暴药水",
                    效果类型: "狂暴",
                    持续时间: 10,
                    效果强度: 1,
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                玩家属性.攻击加成 = 2 + 5 * this.强度;
                return;
            }
            移除效果() {
                玩家属性.攻击加成 = 0;
                super.移除效果();
                return;
            }
        }
        class 神龟药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "神龟药水",
                    效果类型: "神龟",
                    持续时间: 20,
                    效果强度: 1,
                    效果描述: "给予你赛尔达飞艇级别的防御",
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                玩家属性.防御加成 = 2 + 5 * this.强度;
                return;
            }
            移除效果() {
                玩家属性.防御加成 = 0;
                super.移除效果();
                return;
            }
        }
        class 隐身药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "隐身药水",
                    效果类型: "隐身",
                    持续时间: 35,
                    效果强度: 1,
                    效果描述: "悄悄滴进村，打枪滴不要。怪物视距全部变为 1",
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                处理怪物回合();
                return; // 在 处理怪物回合 中检测了 玩家状态 来实现
            }
            移除效果() {
                super.移除效果();
                return;
            }
        }
        class 透视药水 extends 药水类 {
            constructor(配置) {
                super({
                    名称: "透视药水",
                    效果类型: "透视",
                    持续时间: 50,
                    效果强度: 1,
                    效果描述: "透过迷雾，看清房内的陷阱",
                    堆叠数量: 配置.数量 || 1,
                    强化: 配置.强化 || false,
                });
            }
            应用效果() {
                玩家属性.透视 = true;
                绘制();
                return;
            }
            移除效果() {
                玩家属性.透视 = false;
                super.移除效果();
                return;
            }
        }
        class 钢制长剑 extends 武器类 {
            constructor(配置) {
                super({
                    名称: "钢制长剑",
                    图标: 图标映射.钢制长剑,
                    基础攻击力: 5,
                    冷却回合: 2,
                    攻击范围: 2,
                    耐久: 配置.耐久 || 50,
                    强化: 配置.强化 || false,
                    不可破坏: 配置.不可破坏 || false,
                });
            }
        }
        class 橡木法杖 extends 武器类 {
            constructor(配置) {
                super({
                    名称: "橡木法杖",
                    图标: 图标映射.橡木法杖,
                    品质: 3,
                    基础攻击力: 8,
                    攻击范围: 5,
                    冷却回合: 3,
                    攻击目标数: 5,
                    耐久: 配置.耐久 || 40,
                    强化: 配置.强化 || false,
                    不可破坏: 配置.不可破坏 || false,
                });
            }
        }

        class 秘银锁甲 extends 防御装备类 {
            constructor(配置) {
                super({
                    名称: "秘银锁甲",
                    图标: 图标映射.秘银锁甲,
                    品质: 3,
                    防御力: 3,
                    耐久: 配置.耐久 || 150,
                    强化: 配置.强化 || false,
                    不可破坏: 配置.不可破坏 || false,
                });
            }
        }
        class 迅捷卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "迅捷卷轴",
                    品质: 3,
                    效果描述: "激活后每次移动可跨越三格，消耗能量",
                    能量消耗: 2, // 每次使用消耗2%能量
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                玩家属性.移动步数 += 2;
                return true;
            }
            卸下() {
                玩家属性.移动步数 -= 2;
                return true;
            }
        }
        class 神秘卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "神秘卷轴",
                    品质: 3,
                    效果描述: "浪费能量的空白卷轴",
                    能量消耗: 15,
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
            }
            //使用时不卸下即视为每回合消耗能量，消耗能量在卷轴基类处理
            使用() {
                return true;
            }
            卸下() {
                return true;
            }
        }
        class 贪婪卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "贪婪卷轴",
                    品质: 3,
                    效果描述: "赌狗！将怪物掉落率/装备耐久提高一倍吧！",
                    能量消耗: 15,
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                if (!this.消耗能量()) return false;
                玩家属性.掉落倍率 = 2;
                return true;
            }
            卸下() {
                玩家属性.掉落倍率 = 1;
                return true;
            }
        }
        class 清净卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "清净卷轴",
                    品质: 3,
                    效果描述: "消耗大量能量，激活后去除自身所有效果",
                    能量消耗: 40,
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                if (!this.消耗能量()) return false;
                玩家状态.forEach((item) => {
                    item.移除状态();
                });
                当前激活卷轴列表.delete(this);
                恢复卷轴模式();
                显示通知("卷轴成功发挥作用", "成功");
                绘制();
                return true;
            }
        }
        class 金币手枪 extends 武器类 {
            constructor(配置 = {}) {
                super({
                    名称: "金币手枪",
                    图标: 图标映射.金币手枪,
                    品质: 3,
                    颜色索引: 2,
                    效果描述: "发射直线子弹，中弹怪物会麻木，每发消耗2金币",
                    基础攻击力: 1,
                    冷却回合: 1,
                    攻击范围: 40,
                    耐久: 配置.耐久 || 75,
                    强化: 配置.强化 || false,
                    不可破坏: 配置.不可破坏 || false,
                    数据: {
                        金币消耗: 2
                    }
                })
            }
            使用() {
                const 金币列表 = [...玩家背包.values()].filter((i) => i instanceof 金币);
                const 总金币 = 金币列表.reduce((sum, i) => sum + i.堆叠数量, 0);
                if (总金币 < this.自定义数据.get("金币消耗")) {
                    显示通知("金币不足！", "错误");
                    return false
                }
                const 攻击结果 = this.寻找直线目标();
                if (!攻击结果) {
                    return false
                }

                if (!扣除金币(this.自定义数据.get("金币消耗"))) return false;

                super.使用([攻击结果.怪物]);
                更新背包显示();
                攻击结果.怪物.受伤冻结回合剩余 = 2;
                计划显示格子特效(攻击结果.路径);
                return true
            }
            寻找直线目标() {
                const 方向列表 = [{
                    dx: 0,
                    dy: -1,
                    名称: "上"
                }, {
                    dx: 0,
                    dy: 1,
                    名称: "下"
                }, {
                    dx: -1,
                    dy: 0,
                    名称: "左"
                }, {
                    dx: 1,
                    dy: 0,
                    名称: "右"
                }];
                let 最近目标 = null;
                let 最小距离 = Infinity;
                if (地牢[玩家.y][玩家.x].类型 === 单元格类型.怪物) {
                    return {
                        怪物: 地牢[玩家.y][玩家.x].关联怪物,
                        路径: [{ x: 玩家.x, y: 玩家.y }],
                    };
                }
                方向列表.forEach(方向 => {
                    let 当前X = 玩家.x + 方向.dx;
                    let 当前Y = 玩家.y + 方向.dy;
                    let 路径 = [];
                    for (let i = 0; i < 9999; i++) {
                        if (!检查移动可行性(当前X - 方向.dx, 当前Y - 方向.dy, 当前X, 当前Y)) break;
                        const 单元格 = 地牢[当前Y]?.[当前X];
                        if (单元格?.关联怪物 && 单元格.类型 === 单元格类型.怪物 && 单元格.关联怪物?.状态 === 怪物状态.活跃) {
                            const 距离 = Math.abs(当前X - 玩家.x) + Math.abs(当前Y - 玩家.y);
                            if (距离 < 最小距离) {
                                最近目标 = {
                                    怪物: 单元格.关联怪物,
                                    路径: 获取直线路径(玩家.x, 玩家.y, 当前X, 当前Y)
                                };
                                最小距离 = 距离
                            }
                            break;
                        }
                        路径.push({
                            x: 当前X,
                            y: 当前Y
                        });
                        当前X += 方向.dx;
                        当前Y += 方向.dy
                    }
                });
                return 最近目标;
            }
        }
        class 附魔卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "附魔卷轴",
                    品质: 配置.品质 || 1,
                    效果描述: "为装备附加附魔",
                    能量消耗: 30,
                    已解锁: 配置.已解锁 || false,
                    强化: 配置.强化 || false,
                });
                this.可用次数 = 配置.可用次数 || 1; // 可附魔次数
                this.附魔池 = [
                    this.火焰附魔,
                    this.保护附魔,
                    this.耐久附魔,
                    this.锋利附魔,
                    this.爆炸保护附魔,
                    this.连锁附魔,
                    this.荆棘附魔,
                ];
                this.效果名 = [
                    "火焰附魔",
                    "保护附魔",
                    "耐久附魔",
                    "锋利附魔",
                    "爆炸保护附魔",
                    "连锁附魔",
                    "荆棘附魔",
                ];
                const 效果索引 = Math.floor(Math.random() * this.附魔池.length);
                this.附魔效果 = this.附魔池[效果索引]
                if (!配置.品质) {
                    this.品质 = Math.floor(Math.random() * 6) || 1;
                    this.颜色索引 = this.品质 - 1;
                }
                this.效果描述 = "为装备附加" + this.效果名[效果索引] + "(附魔等级由品质决定)";
            }

            使用() {
                this.显示附魔界面();
                return true;
            }

            显示附魔界面() {
                玩家属性.允许移动 = false;
                const 弹窗 = this.创建附魔弹窗();
                this.添加装备到弹窗(弹窗);
                this.添加确认按钮(弹窗);
            }

            添加确认按钮(弹窗) {
                const 确认按钮 = document.createElement("button");
                确认按钮.className = "附魔确认按钮";
                确认按钮.innerHTML = "开始附魔";
                确认按钮.addEventListener("click", () => {
                    const 选中装备 = 弹窗.querySelector(".可附魔.active");
                    if (选中装备) {
                        this.执行附魔(选中装备.__物品实例, 弹窗, 选中装备);
                    } else {
                        显示通知("请选择要附魔物品", "错误");
                    }
                });
                弹窗.querySelector(".附魔装备容器").after(确认按钮);
            }

            创建附魔弹窗() {
                const 弹窗 = document.createElement("div");
                弹窗.className = "附魔弹窗";
                弹窗.innerHTML = `
            < div class="附魔头" >
                <span class="附魔标题">选择要附魔的装备</span>
                <button class="关闭按钮" click>×</button>
            </div >
            <div class="附魔装备容器"></div>
            <div class="附魔特效"></div>
        `;
                弹窗.querySelector(".关闭按钮").addEventListener("click", () => {
                    弹窗.classList.add("关闭中"); // 先触发动画
                    setTimeout(() => {
                        玩家属性.允许移动 = true;
                        弹窗.remove();
                        当前激活卷轴列表.delete(this);
                        恢复卷轴模式();
                    }, 300); // 等动画完成再移除
                });
                document.body.appendChild(弹窗);
                return 弹窗;
            }

            添加装备到弹窗(弹窗) {
                const 容器 = 弹窗.querySelector(".附魔装备容器");
                [...玩家装备.values()].forEach(装备 => {
                    const 克隆元素 = 装备.生成显示元素("装备").cloneNode(true);
                    克隆元素.style.margin = "-5px 0";
                    克隆元素.classList.remove("active");
                    克隆元素.classList.remove("hover");
                    克隆元素.removeAttribute("data-quality");
                    克隆元素.__物品实例 = 装备;
                    克隆元素.classList.add("可附魔");
                    克隆元素.addEventListener("click", (e) => {
                        克隆元素.classList.add("active");
                        容器.querySelectorAll(".物品条目").forEach((el) => {
                            if (el !== 克隆元素) {
                                el.classList.remove("active");
                            }
                        });
                    });
                    ["销毁按钮", "使用按钮", "装备按钮"].forEach(
                        (className) => {
                            克隆元素.querySelector(
                                `.${className} `
                            )?.remove();
                        }
                    );
                    容器.appendChild(克隆元素);
                });
            }

            执行附魔(装备, 弹窗, 元素) {
                const 成功 = this.附魔效果.call(this, 装备);

                if (成功) {
                    元素.classList.add("附魔成功");
                    setTimeout(() => 元素.classList.remove("附魔成功"), 1500);

                    this.播放附魔特效(装备, 弹窗, 元素);
                    this.可用次数--;
                    if (this.可用次数 <= 0) {
                        处理销毁物品(this.唯一标识, true);
                    }
                    显示通知("附魔成功！装备绽放出神秘光芒", "成功");
                    弹窗.classList.add("关闭中");
                    当前激活卷轴列表.delete(this);
                    恢复卷轴模式();
                    setTimeout(() => {
                        弹窗.remove();
                        玩家属性.允许移动 = true;
                    }, 2000);
                } else {
                    显示通知("无法应用附魔！", "错误");
                }
            }

            火焰附魔(装备) {
                return this.添加附魔(装备, "火焰附魔", ["武器", "防御装备"]);
            }
            耐久附魔(装备) {
                return this.添加附魔(装备, "耐久附魔", ["武器", "防御装备"]);
            }
            保护附魔(装备) {
                return this.添加附魔(装备, "保护附魔", ["防御装备"]);
            }
            锋利附魔(装备) {
                return this.添加附魔(装备, "锋利附魔", ["武器"]);
            }
            连锁附魔(装备) {
                return this.添加附魔(装备, "连锁附魔", ["武器"]);
            }
            爆炸保护附魔(装备) {
                return this.添加附魔(装备, "爆炸保护附魔", ["防御装备"]);
            }
            荆棘附魔(装备) {
                return this.添加附魔(装备, "荆棘附魔", ["防御装备"]);
            }
            添加附魔(装备, 附魔种类, 允许装备列表) {
                if (装备.自定义数据.get("附魔")) {
                    if (!装备.自定义数据.get("附魔").some((附魔) => 附魔.种类 === 附魔种类 && 附魔.等级 >= this.品质) && 允许装备列表.includes(装备.类型)) {
                        if (!this.消耗能量()) {
                            显示通知("能量不足！", "错误");
                            return false;
                        }
                        let 成功附魔 = false;
                        装备.自定义数据.get("附魔").forEach((item, index, arr) => {
                            if (item.种类 === 附魔种类 && item.等级 < this.品质) {
                                arr[index] = { 种类: 附魔种类, 等级: this.品质 };
                                成功附魔 = true;
                            }
                        });
                        if (!成功附魔) {
                            装备.自定义数据.get("附魔").push({ 种类: 附魔种类, 等级: this.品质 });
                        }
                        return true;
                    }
                }
                return false;
            }
            播放附魔特效(装备, 弹窗, 装备元素) {
                const 装备位置 = 装备元素.getBoundingClientRect();
                const 中心X = 装备位置.left + 装备位置.width / 2;
                const 中心Y = 装备位置.top + 装备位置.height / 2;

                const 特效容器 = document.createElement("div");
                特效容器.style.cssText = `
        position: fixed;
        left: ${中心X} px;
        top: ${中心Y} px;
        pointer - events: none;
        z - index: 10001;
        `;

                document.body.appendChild(特效容器);

                const 粒子数 = 12;

                const 基础色相 = 260;

                for (let i = 0; i < 粒子数; i++) {
                    const 粒子 = document.createElement("div");
                    粒子.className = "魔幻粒子";

                    const 角度 = Math.random() * Math.PI * 2;
                    const 距离 = 120 + Math.random() * 80;
                    const 目标X = Math.cos(角度) * 距离;
                    const 目标Y = Math.sin(角度) * 距离;
                    const 大小 = 12 + Math.random() * 16;
                    const 旋转 = Math.random() * 720;
                    const 色相偏移 = (Math.random() - 0.5) * 40;
                    const 亮度曲线 = 60 + Math.random() * 30;

                    粒子.style.cssText = `
        --target - x: ${目标X} px;
        --target - y: ${目标Y} px;
        --size: ${大小} px;
        --hue: ${基础色相 + 色相偏移};
        transform: translateZ(0);
        --lightness: ${亮度曲线}%;
        --rotate: ${旋转} deg;
        --delay: ${Math.random() * 0.4} s;
        `;

                    // 添加光晕闪烁效果
                    粒子.style.animation += ", 光晕闪烁 1.4s linear infinite";

                    特效容器.appendChild(粒子);
                }

                setTimeout(() => 特效容器.remove(), 2000);
            }
        }

        class 跃迁卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "跃迁卷轴",
                    品质: 3,
                    效果描述: "随机传送到未访问房间，并解锁目标房间所有门",
                    强化: 配置.强化 || false,
                    能量消耗: 15,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                if (!this.消耗能量()) return false;
                // 获取所有有效房间
                const 有效房间 = 房间列表.filter(
                    (r) =>
                        r.id !== 房间地图[玩家.y][玩家.x] && // 排除当前房间
                        (!已访问房间.has(r.id)) // 排除访问过
                );

                if (有效房间.length === 0) {
                    const 有效房间 = 房间列表.filter(
                        (r) =>
                            r.id !== 房间地图[玩家.y][玩家.x]// 仅排除当前房间
                    );
                    显示通知("没有可传送的未访问房间", "警告");
                }

                const 目标房间 =
                    有效房间[Math.floor(Math.random() * 有效房间.length)];

                // 解锁关联门
                门实例列表.forEach((门) => {
                    if (门.房间ID === 目标房间.id) {
                        地牢[门.所在位置.y][门.所在位置.x].类型 =
                            单元格类型.门;
                    }
                });

                // 传送到房间中心
                玩家.x = 目标房间.x + Math.floor(目标房间.w / 2);
                玩家.y = 目标房间.y + Math.floor(目标房间.h / 2);
                已访问房间.add(目标房间.id); // 刷新
                更新视口();
                绘制();
                显示通知(
                    `一阵风刮来，被传送到了 ${目标房间.id} 号房间`,
                    "成功"
                );
                当前激活卷轴列表.delete(this);
                恢复卷轴模式();
                return true;
            }
        }

        class 真言卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "真言卷轴",
                    图标: 图标映射.真言卷轴,
                    品质: 4,
                    强化: 配置.强化 || false,
                    效果描述: "揭示装备中所有卷轴的奥秘，每个卷轴 30 能量",
                    能量消耗: 30,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                const 能量条 = document.querySelector(".power-bar");
                let 当前能量 = Math.max(Math.min(parseFloat(能量条.style.width), 100), 0);

                let 解密数量 = 0;
                const 每次解密消耗 = 30;

                // 遍历玩家装备，尝试解锁卷轴
                [...玩家装备.values()].forEach(item => {
                    if (item instanceof 卷轴类 && !item.自定义数据.get("已解锁")) {
                        if (当前能量 >= 每次解密消耗) {
                            当前能量 -= 每次解密消耗; // 扣除能量
                            item.自定义数据.set("已解锁", true); // 解锁卷轴
                            解密数量++;
                        }
                    }
                });
                卷轴扣除能量(Math.max(Math.min(parseFloat(能量条.style.width), 100), 0) - 当前能量);
                更新装备显示();
                更新背包显示();
                if (解密数量 > 0) {
                    显示通知(`解密了 ${解密数量} 个神秘卷轴`, "成功");
                } else {
                    显示通知(`没有可解密的卷轴`, "信息");
                }

                当前激活卷轴列表.delete(this);
                恢复卷轴模式();
                return 解密数量 > 0;
            }

            获取提示() {
                return this.自定义数据.get("已解锁")
                    ? super.获取提示()
                    : "布满古老符文的卷轴，散发着神秘能量...";
            }
        }

        class 湮灭卷轴 extends 卷轴类 {
            constructor(配置) {
                super({
                    名称: "湮灭卷轴",
                    品质: 3,
                    效果描述: "销毁所有已装备物品",
                    能量消耗: 0,
                    强化: 配置.强化 || false,
                    已解锁: 配置.已解锁 || false,
                });
            }

            使用() {
                if (!this.消耗能量()) return false;
                let 销毁列表 = [...玩家装备.values()];

                销毁列表.forEach((item) => {
                    // 传奇自爆兵
                    const 槽位 = document.getElementById(
                        `装备槽${item.装备槽位} `
                    );
                    const 烟花容器 = document.createElement("div");
                    烟花容器.style.position = "fixed";
                    烟花容器.style.left = `${槽位.getBoundingClientRect().left + 40
                        } px`;
                    烟花容器.style.top = `${槽位.getBoundingClientRect().top + 40
                        } px`;
                    烟花容器.style.zIndex = 99999;
                    document.body.appendChild(烟花容器);

                    // 生成12个粒子
                    for (let i = 0; i < 12; i++) {
                        const 粒子 = document.createElement("div");
                        粒子.className = "烟花粒子";
                        粒子.innerHTML = [
                            "✨",
                            "❄️",
                            "⚡",
                            "⭐",
                            "💥",
                            "🔥",
                        ][i % 6];
                        粒子.style.color = "#fff";
                        粒子.style.setProperty(
                            "--tx",
                            Math.cos((i * 30 * Math.PI) / 180)
                        );
                        粒子.style.setProperty(
                            "--ty",
                            Math.sin((i * 30 * Math.PI) / 180)
                        );
                        烟花容器.appendChild(粒子);
                    }
                    setTimeout(() => 烟花容器.remove(), 800);
                    item.取消装备();
                    处理销毁物品(item.唯一标识, true);
                });
                玩家装备.clear();
                处理销毁物品(this.唯一标识, true);
                更新背包显示();
                更新装备显示();
                显示通知(`湮灭了${销毁列表.length} 件装备`, "错误");
                return true;
            }
        }
        class 钢制板甲 extends 防御装备类 {
            constructor(配置) {
                super({
                    名称: "钢制板甲",
                    图标: 图标映射.钢制板甲,
                    品质: 2,
                    强化: 配置.强化 || false,
                    防御力: 1,
                    耐久: 配置.耐久 || 200,
                    不可破坏: 配置.不可破坏 || false,
                });
            }
        }
        class 冰盾 extends 防御装备类 {
            constructor(配置) {
                super({
                    名称: "冰盾",
                    图标: 图标映射.冰盾,
                    效果描述: "iDefender 会帮你以 80% 概率保卫电脑 3 回合。",
                    品质: 3,
                    强化: 配置.强化 || false,
                    防御力: 2,
                    耐久: 配置.耐久 || 100,
                    不可破坏: 配置.不可破坏 || false,
                    数据: {
                        冻结概率: 0.8,
                        冻结回合: 3
                    }
                });
            }

            当被攻击(原始攻击力, 来源 = null) {
                // 基础防御计算
                const 最终伤害 = super.当被攻击(原始攻击力, 来源);

                // 概率触发冻结
                if (Math.random() < this.自定义数据.get("冻结概率") && 来源 instanceof 怪物) {
                    const 攻击者 = 来源;
                    if (攻击者) {
                        const 冻结状态 = new 状态效果("冻结", "#2196F3", "冻", this.自定义数据.get("冻结回合"), null, null, 攻击者);
                    }
                }

                return 最终伤害;
            }
        }
        class 重铸台 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "工具",
                    名称: "重铸台",
                    图标: 图标映射.重铸台,
                    品质: 4,
                    颜色索引: 3,
                    最大堆叠数量: 1,
                    效果描述: `将同名装备的耐久融合\n剩余耐久：${配置.耐久 || 5} /${配置.耐久 || 5}`,
                    数据: {
                        耐久: 配置.耐久 || 5,
                        最大耐久: 5,
                        基础消耗: 30,
                        强化折扣: -0.2
                    }
                });
            }

            使用() {
                if (this.自定义数据.get("耐久") <= 0) {
                    显示通知("重铸台已损坏！", "错误");
                    return false;
                }
                this.显示重铸界面();
                return true;
            }

            显示重铸界面() {
                if (界面可见性.背包) 切换背包显示();
                玩家属性.允许移动 = false;
                const 遮罩 = document.createElement("div");
                遮罩.className = "重铸遮罩";
                const 弹窗 = document.createElement("div");
                弹窗.className = "重铸弹窗";
                弹窗.innerHTML = `
      <div class="重铸弹窗-header">
        <h3>重铸台（耐久：${this.自定义数据.get("耐久")}/${this.自定义数据.get("最大耐久")} | 金币：<span id="repairCost">0</span>）</h3>
        <button class="关闭按钮" onclick="关闭重铸界面()">×</button>
      </div>
      <div style="display: flex; gap: 20px;">
        <div class="重铸弹窗-column">
          <h4>待修复装备</h4>
          <div class="重铸弹窗-items" id="sourceItems"></div>
        </div>
        <div class="重铸弹窗-column">
          <h4>材料装备</h4>
          <div class="重铸弹窗-items" id="materialItems"></div>
        </div>
      </div>
      <button class="附魔确认按钮" style="margin-top:15px;" onclick="执行重铸()">开始重铸</button>
    `;

                遮罩.appendChild(弹窗);
                document.body.appendChild(遮罩);

                // 添加进场动画
                setTimeout(() => {
                    弹窗.style.transform = "translate(-50%, -50%) scale(1)";
                }, 10);

                this.填充可选物品(弹窗.querySelector("#sourceItems"), "source");
                this.填充可选物品(弹窗.querySelector("#materialItems"), "material");
                window.当前重铸台 = this;
                window.当前重铸遮罩 = 遮罩; //懒得写进全局变量了...
                弹窗.querySelectorAll(".重铸弹窗-items").forEach(容器 => {
                    容器.addEventListener("click", () => this.更新消耗显示());
                });
            }
            计算消耗(源物品, 材料物品) {
                if (!源物品 || !材料物品) {
                    return "-";
                }
                if (源物品 === 材料物品) {
                    return "-";
                }
                if (源物品.名称 !== 材料物品.名称) {
                    return "-";
                }
                let 基础消耗 = this.自定义数据.get("基础消耗");
                const 折扣率 = this.自定义数据.get("强化折扣");
                const 当前耐久 = 源物品.自定义数据.get("耐久");
                const 最大耐久 = 源物品.自定义数据.get("原耐久");
                const 可用空间 = 最大耐久 - 当前耐久;
                const 可转移量 = Math.min(材料物品.自定义数据.get("耐久"), 可用空间);
                基础消耗 += Math.floor(可转移量 / 最大耐久 * 基础消耗)
                // 任一物品强化即打折（虽然是负折扣
                const 有强化 = 源物品.强化 || 材料物品?.强化;
                if (有强化) 基础消耗 *= (1 - 折扣率);

                return Math.floor(基础消耗);
            }
            更新消耗显示() {
                const 源物品 = document.querySelector("#sourceItems .selected")?.__物品实例;
                const 材料物品 = document.querySelector("#materialItems .selected")?.__物品实例;

                if (!源物品 || !材料物品) {
                    document.getElementById("repairCost").textContent = "0";
                    return;
                }

                let 消耗 = this.计算消耗(源物品, 材料物品);
                document.getElementById("repairCost").textContent = 消耗;
                if (消耗 === "-") 消耗 = 10000;
                // 根据玩家金币改变颜色
                const 玩家金币 = [...玩家背包.values()]
                    .filter(i => i instanceof 金币)
                    .reduce((sum, i) => sum + i.堆叠数量, 0);

                document.getElementById("repairCost").style.color =
                    玩家金币 >= 消耗 ? "#4CAF50" : "#F44336";
            }

            填充可选物品(容器, 类型) {
                容器.innerHTML = "";
                const 有效物品 = [...玩家背包.values()].filter(item =>
                    (item instanceof 武器类 || item instanceof 防御装备类) &&
                    item.自定义数据?.has("耐久") &&
                    item !== this
                );

                有效物品.forEach(item => {
                    const 元素 = document.createElement("div");
                    元素.className = "重铸物品";
                    元素.innerHTML = `
      ${item.强化 ? '<div class="重铸台强化标识">★</div>' : ''}
        <div class="物品图标">${item.图标}</div>
        <div class="物品名称">${item.名称}</div>
        <div class="重铸台耐久标签">耐久 ${item.自定义数据.get("耐久")}/${item.自定义数据.get("原耐久")}</div>
      `;

                    // 直接绑定实例引用
                    元素.__物品实例 = item;
                    元素.addEventListener("click", () => this.选择物品(元素, 类型));
                    容器.appendChild(元素);
                });
            }

            选择物品(元素, 类型) {
                document.querySelectorAll(`.重铸物品[data-type="${类型}"]`).forEach(el => {
                    el.classList.remove("selected");
                    el.style.transform = "scale(1)";
                });
                元素.classList.add("selected");
                元素.style.transform = "scale(1.05)";
                元素.dataset.type = 类型;
            }
        }
        class 神秘商人 extends 物品 {
            constructor(配置) {
                super({
                    类型: "NPC",
                    名称: "神秘商人",
                    图标: 图标映射.神秘商人,
                    品质: 4,
                    颜色索引: 3,
                    能否拾起: false, // 不可拾取
                    效果描述: "毫无卵用的奸商",
                    数据: {
                        库存: 配置.库存 || [],
                        刷新次数: 3 // 可交易次数
                    }
                });
                this.能否拾起 = false;
                this.生成库存(当前层数);
            }

            生成库存(层数) {
                this.自定义数据.set("库存", []);
                const 品质权重 = [
                    { 品质: 1, 权重: 50 - 层数 * 5 },
                    { 品质: 2, 权重: 30 + 层数 * 3 },
                    { 品质: 3, 权重: 15 + 层数 * 2 },
                    { 品质: 4, 权重: 5 + 层数 * 1 }
                ].filter((w) => w.权重 > 0);
                let 已选中 = false;
                let 尝试次数 = 0;
                for (let i = 0; i < 3; i++) {
                    while (!已选中 && 尝试次数 < 100) {
                        const 选中品质 = 加权随机选择(品质权重);
                        const 候选物品 = Object.values(物品池)
                            .flat()
                            .filter((item) => item.品质 == 选中品质.品质 && 层数 >= item.最小层); // 我知道这里可以改进，但是我的snippet已经跳出来了

                        if (候选物品.length > 0) {
                            const 模板 = 候选物品[Math.floor(Math.random() * 候选物品.length)];
                            const 物品实例 = new 模板.类({
                                数量: 1,
                                强化: Math.random() < Math.min(0.85, 层数 * 0.15), // 层数越高强化概率越大
                                已解锁: true,
                                品质: 2 + Math.floor(Math.random() * 4),
                            });
                            if (!this.自定义数据.get("库存").some((item) => item.名称 === 物品实例.名称) && 物品实例.是否正常物品) {
                                this.自定义数据.get("库存").push(物品实例);
                                已选中 = true;
                            }
                        }
                        尝试次数++
                    }
                    已选中 = false;
                    尝试次数 = 0;
                }
            }

            获取价格(物品) {
                return Math.max(物品.品质 * 20 + (物品.强化 ? 20 : 0) + Math.floor(Math.random() * 15) - 当前层数 * 2, 30);
            }
        }
        class 物品祭坛 extends 物品 {
            constructor(配置) {
                super({
                    类型: "祭坛",
                    名称: "物品祭坛",
                    图标: 图标映射.祭坛,
                    是否正常物品: false,
                    品质: 4,
                    颜色索引: 3,
                    能否拾起: false,
                    数据: {
                        库存: 配置.库存 || [],
                    }

                });
                let 已选中 = false;
                let 尝试次数 = 0;
                while (!已选中 && 尝试次数 < 100) {
                    已选中 = this.生成库存();
                    尝试次数++
                }
            }
            尝试互动() {
                const 当前生命 =
                    parseFloat(
                        document.querySelector(".health-bar").style.width
                    ) || 0;

                if (this.自定义数据.get("库存").length <= 0) {
                    显示通知("祭坛已无效！", "错误");
                    return false;
                }
                if (当前生命 > 75) {
                    let 库存 = this.自定义数据.get("库存").shift()
                    if (尝试收集物品(库存, false)) {
                        if (是否为教程层) {
                            显示通知("居然还有这么多血！？", "成功");
                        } else {
                            显示通知("物品祭坛献祭成功！", "成功");
                        }
                        伤害玩家(75, this.名称);
                        return true;
                    } else {
                        this.自定义数据.get("库存").push(库存);
                    }
                } else {
                    显示通知("血量不足，无法献祭！", "错误");
                    return false;
                }
                return false;
            }
            生成库存() {
                this.自定义数据.set("库存", []);
                const 候选物品 = Object.values(物品池)
                    .flat()
                const 物品实例 = new 候选物品[Math.floor(Math.random() * 候选物品.length)].类({ 强化: true, 已解锁: true });
                if (物品实例.是否正常物品 && !(物品实例 instanceof 神秘商人)) {
                    this.自定义数据.get("库存").push(物品实例);
                    return true;
                }
                return false;
            }
        }
        class 耐久祭坛 extends 物品 {
            constructor(配置) {
                super({
                    类型: "祭坛",
                    名称: "耐久祭坛",
                    图标: 图标映射.祭坛,
                    是否正常物品: false,
                    品质: 4,
                    颜色索引: 3,
                    能否拾起: false,
                    数据: {
                        使用次数: 0,
                    }

                });
            }
            get 使用次数() {
                return this.自定义数据.get("使用次数");
            }
            set 使用次数(item) {
                this.自定义数据.set("使用次数", item);
            }
            尝试互动() {
                const 当前生命 =
                    parseFloat(
                        document.querySelector(".health-bar").style.width
                    ) || 0;
                if (this.使用次数 >= 3) {
                    显示通知("祭坛已无效！", "错误");
                    return false;
                }
                if (当前生命 > 75) {
                    伤害玩家(75, this.名称);
                    [...玩家装备.values()].forEach((装备) => {
                        if (装备.自定义数据.get("原耐久")) 装备.自定义数据.set("耐久", 装备.自定义数据.get("原耐久"))
                    });
                    显示通知("耐久祭坛献祭成功！", "成功");
                    更新装备显示();
                    this.使用次数++;
                    return true;
                } else {
                    显示通知("血量不足，无法献祭！", "错误");
                    return false;
                }
            }
        }
        class 宠物 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "宠物",
                    名称: 配置.名称 || "宠物",
                    图标: 配置.图标 || 图标映射.宠物,
                    品质: 配置.品质 || 3,
                    颜色索引: 配置.颜色索引 || 2,
                    最大堆叠数量: 1,
                    堆叠数量: 配置.堆叠数量 || 1,
                    效果描述: 配置.效果描述 || "一只忠诚的伙伴。",
                    强化: 配置.强化 || false,
                    数据: {
                        ...配置.数据,
                        等级: 配置.等级 || 1,
                        当前生命值: 配置.当前生命值 || (配置.最大生命值 || 100),
                        最大生命值: 配置.最大生命值 || 100,
                        基础攻击力: 配置.基础攻击力 || 5,
                        基础防御力: 配置.基础防御力 || 2,
                        经验值: 配置.经验值 || 0,
                        升级所需经验: 配置.升级所需经验 || 20,
                        升级所需金币: 配置.升级所需金币 || 30,
                        技能: 配置.技能 || [], // { 名称: "", 等级: 1, 描述: "" }
                        装备: {}, // "武器": 物品实例, "防具": 物品实例
                        休眠中: false,
                        每移动恢复量: 配置.每移动恢复量 || 1,
                    },
                });
                if (this.强化) {
                    this.自定义数据.set("升级所需金币", Math.round(this.自定义数据.get("升级所需金币") * 0.5));
                    this.自定义数据.set("升级所需经验", Math.round(this.自定义数据.get("升级所需经验") * 0.5));
                }
            }

            当玩家攻击(目标怪物列表) {
                if (this.自定义数据.get("休眠中")) return;

                this.攻击(目标怪物列表);

                const 武器 = this.自定义数据.get("装备")?.武器;
                if (
                    武器 &&
                    武器.堆叠数量 > 0 &&
                    武器.自定义数据.get("冷却剩余") == 0
                ) {
                    const { 怪物, 路径 } = 获取周围怪物(
                        武器.自定义数据.get("攻击目标数"),
                        武器.自定义数据.get("攻击范围")
                    );
                    if (怪物 !== null) {
                        路径.forEach((攻击路径) => 计划显示格子特效(攻击路径));
                        武器.使用(怪物);
                    }
                }
                this.触发技能("攻击", 目标怪物列表);
            }

            攻击(目标怪物列表) {
                const 总伤害 = this.自定义数据.get("基础攻击力");
                目标怪物列表.forEach(怪物 => {
                    if (怪物.当前生命值 > 0) 怪物.受伤(总伤害, this); // 伤害来源改为宠物实例
                });
                显示通知(`${this.名称}发起攻击，造成了${总伤害}点伤害`, "成功");
            }


            // 当玩家被攻击时触发 (需要传入攻击力和攻击来源)
            当玩家被攻击(原始攻击力, 来源) {
                if (this.自定义数据.get("休眠中")) return 原始攻击力;

                let 最终攻击力 = 原始攻击力;

                // 宠物装备的防具效果
                const 防具 = this.自定义数据.get("装备")?.防具;
                if (防具) {
                    最终攻击力 = 防具.当被攻击(最终攻击力, 来源);
                }

                // 宠物自身防御
                最终攻击力 = Math.max(0, 最终攻击力 - this.自定义数据.get("基础防御力"));
                if (最终攻击力 <= 0) 最终攻击力 = Math.round(Math.random() * 100) / 100;

                const 承担比例 = 0.3;
                const 宠物承担伤害 = Math.ceil(最终攻击力 * 承担比例);
                this.受伤(宠物承担伤害);

                // 触发宠物技能 (被攻击时)
                this.触发技能("被攻击", 来源);
                return 最终攻击力 * (1 - 承担比例);
            }

            受伤(伤害值) {
                let 当前生命值 = this.自定义数据.get("当前生命值");
                当前生命值 = Math.max(0, 当前生命值 - 伤害值);
                this.自定义数据.set("当前生命值", 当前生命值);
                this.更新宠物管理窗口();
                if (当前生命值 <= 0) {
                    this.进入休眠();
                }
            }

            进入休眠() {
                this.自定义数据.set("休眠中", true);
                显示通知(`${this.名称}生命值过低，进入休眠！`, "警告");
            }

            // 移动玩家调用
            恢复生命值() {
                if (!this.自定义数据.get("休眠中")) return;

                let 当前生命值 = this.自定义数据.get("当前生命值");
                const 最大生命值 = this.自定义数据.get("最大生命值");
                const 恢复量 = this.自定义数据.get("每移动恢复量");

                当前生命值 = Math.min(最大生命值, 当前生命值 + 恢复量);
                this.自定义数据.set("当前生命值", 当前生命值);
                this.更新宠物管理窗口();
                if (当前生命值 >= 最大生命值 && this.自定义数据.get("休眠中")) {
                    this.自定义数据.set("休眠中", false);
                    显示通知(`${this.名称}已恢复，退出休眠！`, "成功");
                }
            }
            //子类自行升级技能
            升级() {
                const 当前等级 = this.自定义数据.get("等级");
                const 升级所需金币 = this.自定义数据.get("升级所需金币");
                if (this.自定义数据.get("升级所需经验") <= this.自定义数据.get("经验值")) {
                    if (扣除金币(升级所需金币)) {
                        this.自定义数据.set("等级", 当前等级 + 1);
                        this.自定义数据.set("最大生命值", this.自定义数据.get("最大生命值") + 20);
                        this.自定义数据.set("当前生命值", this.自定义数据.get("最大生命值")); // 升级后回满血
                        this.自定义数据.set("基础攻击力", this.自定义数据.get("基础攻击力") + 2);
                        this.自定义数据.set("基础防御力", this.自定义数据.get("基础防御力") + 1);

                        // 增加升级所需经验和金币
                        this.自定义数据.set("升级所需经验", Math.floor(this.自定义数据.get("升级所需经验") * 1.5));
                        this.自定义数据.set("升级所需金币", Math.floor(this.自定义数据.get("升级所需金币") * 1.2));
                        显示通知(`${this.名称}升级成功！`, "成功");
                        this.更新宠物管理窗口();
                        return true;
                    } else {
                        显示通知("金币不足，无法升级！", "错误");
                        return false;
                    }
                } else {
                    显示通知("经验不足，无法升级！", "错误");
                    return false;
                }
            }

            获得经验(经验值) {
                let 当前经验 = this.自定义数据.get("经验值") + 经验值;
                this.自定义数据.set("经验值", 当前经验);
                //检查是否可以升级
                while (当前经验 >= this.自定义数据.get("升级所需经验")) {
                    if (this.升级()) {
                        当前经验 = this.自定义数据.get("经验值");
                    } else {
                        break; //金币不足时停止自动升级
                    }
                }
            }

            装备物品(物品, 槽位) {
                if (槽位 !== "武器" && 槽位 !== "防具") {
                    显示通知("无效的宠物装备槽位", "错误");
                    return;
                }
                if ((槽位 === "武器" && !(物品 instanceof 武器类)) || (槽位 === "防具" && !(物品 instanceof 防御装备类))) {
                    显示通知("该物品不能装备到此槽位", "错误");
                    return;
                }

                // 该槽位已有装备，先卸下
                if (this.自定义数据.get("装备")[槽位]) {
                    this.卸下装备(槽位);
                }
                物品.是否隐藏 = true;
                卸下装备槽物品(物品.装备槽位); //内部会调用 更新背包显示

                this.自定义数据.get("装备")[槽位] = 物品;
                显示通知(`${this.名称}装备了${物品.获取名称()}`, "成功");
                this.更新宠物管理窗口();

            }

            卸下装备(槽位) {
                const 装备 = this.自定义数据.get("装备");
                if (装备 && 装备[槽位] && [...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0) < 最大背包容量) {
                    const 卸下物品 = 装备[槽位];
                    装备[槽位] = null;
                    卸下物品.是否隐藏 = false;
                    显示通知(`${this.名称}卸下了${卸下物品.获取名称()}`, "成功");
                    this.自定义数据.set("装备", 装备);
                    this.更新宠物管理窗口();
                    更新背包显示();
                } else {
                    显示通知("背包已满！", "错误")
                }
            }

            // (时机: "攻击" 或 "被攻击")
            触发技能(时机, 额外参数) {
                const 技能列表 = this.自定义数据.get("技能");
                if (!技能列表) return;

                技能列表.forEach(技能 => {
                    if (技能.时机 === 时机 && Math.random() > 0.5) {
                        技能.效果(this, 额外参数);
                    }
                });
            }

            使用() {
                this.打开宠物管理窗口();
                return true;
            }

            打开宠物管理窗口() {
                if (界面可见性.背包) 切换背包显示();
                玩家属性.允许移动 = false;
                if (window.宠物管理窗口) {
                    显示通知("一次只能打开一个宠物管理窗口", "错误");
                    return;
                }
                const 窗口 = document.createElement("div");
                窗口.className = "宠物管理窗口";
                window.宠物管理窗口 = 窗口;

                const 基本信息面板 = this.创建基本信息面板();
                const 装备面板 = this.创建装备面板();
                const 技能面板 = this.创建技能面板();

                const 升级按钮 = document.createElement("button");
                升级按钮.className = "通用按钮"; // 使用通用按钮样式
                升级按钮.textContent = `升级宠物（${this.自定义数据.get("升级所需金币")} 金币 ${this.自定义数据.get("升级所需经验")} EXP）`;
                升级按钮.addEventListener("click", () => {
                    this.升级();
                    this.更新基本信息面板(基本信息面板); // 更新信息
                    升级按钮.textContent = `升级宠物（${this.自定义数据.get("升级所需金币")} 金币 ${this.自定义数据.get("升级所需经验")} EXP）`;
                });

                const 关闭按钮 = document.createElement("button");
                关闭按钮.className = "关闭按钮";
                关闭按钮.textContent = "×";
                关闭按钮.onclick = () => {
                    // 添加关闭动画
                    窗口.style.transform = "translate(-50%, -50%) scale(0.9)";
                    窗口.style.opacity = 0;
                    setTimeout(() => {
                        玩家属性.允许移动 = true;
                        窗口.remove();
                    }, 300);
                    window.宠物管理窗口 = null;
                };

                窗口.appendChild(关闭按钮);
                窗口.appendChild(基本信息面板);
                窗口.appendChild(装备面板);
                窗口.appendChild(技能面板);
                窗口.appendChild(升级按钮);

                document.body.appendChild(窗口);
            }

            更新宠物管理窗口() {
                if (!window.宠物管理窗口) return;
                const 基本信息面板 = window.宠物管理窗口.querySelector(".宠物基本信息面板");
                if (基本信息面板) this.更新基本信息面板(基本信息面板);
                const 装备面板 = window.宠物管理窗口.querySelector(".宠物装备面板");
                if (装备面板) {
                    装备面板.innerHTML = "";
                    装备面板.appendChild(this.创建装备面板());
                }
            }

            创建基本信息面板() {
                const 面板 = document.createElement("div");
                面板.className = "宠物基本信息面板";
                this.更新基本信息面板(面板);
                return 面板;
            }

            更新基本信息面板(面板) {
                const data = this.自定义数据;
                面板.innerHTML = `
            <h3>${this.名称} (等级 ${data.get("等级")})</h3>
            <p>生命值: ${data.get("当前生命值")} / ${data.get("最大生命值")}</p>
            <p>攻击力: ${this.自定义数据.get("基础攻击力")}</p>
            <p>防御力: ${this.自定义数据.get("基础防御力")}</p>
            <p>经验值: ${data.get("经验值")} / ${data.get("升级所需经验")}</p>
            <P>升级所需金币：${data.get("升级所需金币")}</P>
            <p>状态: ${data.get("休眠中") ? "休眠中" : "活跃"}</p>
        `;
            }

            创建装备面板() {
                const 面板 = document.createElement("div");
                面板.className = "宠物装备面板";
                面板.innerHTML = "<h4>装备</h4>";

                const 武器槽 = this.创建装备槽("武器");
                const 防具槽 = this.创建装备槽("防具");

                面板.appendChild(武器槽);
                面板.appendChild(防具槽);
                return 面板;
            }

            创建装备槽(槽位类型) {
                const 槽 = document.createElement("div");
                槽.className = "宠物装备槽";
                槽.dataset.槽位 = 槽位类型;

                const 槽位名 = document.createElement("span");
                槽位名.className = "宠物装备槽位名";
                槽位名.textContent = 槽位类型;
                槽.appendChild(槽位名);

                const 已装备物品 = this.自定义数据.get("装备")[槽位类型];
                if (已装备物品) {
                    const 物品元素 = this.创建装备物品元素(已装备物品);
                    槽.appendChild(物品元素);
                } else {
                    const 选择按钮 = document.createElement("button");
                    选择按钮.className = "通用按钮";
                    选择按钮.textContent = `选择${槽位类型}`;
                    选择按钮.addEventListener("click", () => this.显示装备选择(槽位类型));
                    槽.appendChild(选择按钮);
                }
                return 槽;
            }

            创建装备物品元素(物品) {
                const 元素 = document.createElement("div");
                元素.className = "宠物已装备物品";

                const 图标 = document.createElement("span");
                图标.className = "宠物装备图标";
                图标.textContent = 物品.图标;
                图标.style.color = 物品.颜色表[物品.颜色索引];

                const 名称 = document.createElement("span");
                名称.className = "宠物装备名称";
                名称.textContent = 物品.获取名称();

                const 卸下按钮 = document.createElement("button");
                卸下按钮.className = "通用按钮";
                卸下按钮.textContent = "卸下";
                卸下按钮.addEventListener("click", () => {
                    this.卸下装备(物品.类型 === "武器" ? "武器" : "防具"); // 卸下装备
                    this.更新宠物管理窗口();
                });

                元素.appendChild(图标);
                元素.appendChild(名称);
                元素.appendChild(卸下按钮);
                return 元素;
            }

            显示装备选择(槽位类型) {
                const 遮罩 = document.createElement("div");
                遮罩.className = "宠物装备选择遮罩";

                const 弹窗 = document.createElement("div");
                弹窗.className = "宠物装备选择弹窗";

                const 标题 = document.createElement("h4");
                标题.textContent = `选择${槽位类型}`;
                弹窗.appendChild(标题);

                const 物品列表 = document.createElement("div");
                物品列表.className = "宠物装备选择列表";

                const 可用装备 = [...玩家背包.values()].filter(物品 =>
                    (槽位类型 === "武器" && 物品 instanceof 武器类) ||
                    (槽位类型 === "防具" && 物品 instanceof 防御装备类)
                );

                if (可用装备.length === 0) {
                    const 提示 = document.createElement("div");
                    提示.className = "无装备提示";
                    提示.textContent = `无可用${槽位类型}装备`;
                    物品列表.appendChild(提示);
                } else {
                    可用装备.forEach(物品 => {
                        const 物品元素 = this.创建可选装备元素(物品, 槽位类型);
                        物品列表.appendChild(物品元素);
                    });
                }

                弹窗.appendChild(物品列表);

                const 关闭按钮 = document.createElement("button");
                关闭按钮.className = "关闭按钮";
                关闭按钮.textContent = "×";
                关闭按钮.onclick = () => {
                    弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
                    弹窗.style.opacity = 0;
                    setTimeout(() => {
                        遮罩.remove();
                    }, 300);
                };
                弹窗.appendChild(关闭按钮);

                遮罩.appendChild(弹窗);
                document.querySelector(".宠物管理窗口").appendChild(遮罩);
            }

            创建可选装备元素(物品, 槽位类型) {
                const 元素 = document.createElement("div");
                元素.className = "宠物可选装备";

                const 图标 = document.createElement("span");
                图标.className = "宠物可选装备图标";
                图标.textContent = 物品.图标;
                图标.style.color = 物品.颜色表[物品.颜色索引];

                const 名称 = document.createElement("span");
                名称.className = "宠物可选装备名称";
                名称.textContent = 物品.获取名称();

                const 选择按钮 = document.createElement("button");
                选择按钮.className = "宠物装备选择确认按钮";
                选择按钮.textContent = "选择";
                选择按钮.addEventListener("click", () => {
                    this.装备物品(物品, 槽位类型);
                    let 弹窗 = document.querySelector(".宠物装备选择弹窗");
                    弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
                    弹窗.style.opacity = 0;
                    setTimeout(() => {
                        document.querySelector(".宠物装备选择遮罩").remove();
                    }, 300);
                    更新装备显示();
                    更新背包显示();
                });

                元素.appendChild(图标);
                元素.appendChild(名称);
                元素.appendChild(选择按钮);
                return 元素;
            }

            创建技能面板() {
                const 面板 = document.createElement("div");
                面板.className = "宠物技能面板";
                面板.innerHTML = "<h4>技能</h4>";

                const 技能列表 = this.自定义数据.get("技能");
                if (技能列表 && 技能列表.length > 0) {
                    技能列表.forEach(技能 => {
                        const 技能元素 = document.createElement("div");
                        技能元素.className = "宠物技能";
                        技能元素.innerHTML = `
                    <p><strong>${技能.名称}</strong> (等级 ${技能.等级})</p>
                    <p>${技能.描述}</p>
                `;
                        面板.appendChild(技能元素);
                    });
                } else {
                    面板.innerHTML += "<p>暂无技能</p>";
                }
                return 面板;
            }

            获取提示() {
                const data = this.自定义数据;
                const 装备 = data.get("装备");
                const 武器 = 装备?.武器 ? 装备.武器.获取名称() : "无";
                const 防具 = 装备?.防具 ? 装备.防具.获取名称() : "无";

                return [
                    `${this.获取名称()} (等级 ${data.get("等级")})`,
                    `类型：${this.类型}`,
                    `品质：${"★".repeat(this.品质)}`,
                    `生命值: ${data.get("当前生命值")} / ${data.get("最大生命值")}`,
                    `武器: ${武器}`,
                    `防具: ${防具}`,
                    `${this.效果描述}`,
                ].join("\n");
            }
        }
        class 熊猫 extends 宠物 {
            constructor(配置 = {}) {
                super({
                    名称: "熊猫",
                    图标: 图标映射.熊猫,
                    品质: 3,
                    颜色索引: 2,
                    效果描述: "来自神秘竹林的守护者，擅长竹叶飞刀和强力防御。",
                    基础攻击力: 1,
                    基础防御力: 2,
                    最大生命值: 30,
                    强化: 配置.强化 || false,
                    技能: [
                        {
                            名称: "竹叶飞刀",
                            等级: 1,
                            描述: "投掷锋利的竹叶，对单个敌人造成伤害。伤害随技能等级提升。",
                            时机: "攻击",
                            效果: (宠物, 目标怪物列表) => {
                                if (!目标怪物列表 || 目标怪物列表.length === 0) return;
                                const 技能等级 = 宠物.自定义数据.get("技能")[0].等级; // 获取第一个技能的等级
                                const 基础伤害 = 1;
                                const 伤害 = 基础伤害 + 技能等级 * 3;

                                // 随机选择一个目标
                                const 目标 = 目标怪物列表[Math.floor(Math.random() * 目标怪物列表.length)];
                                目标.受伤(伤害, 宠物);
                                添加日志(`${宠物.名称}使用了竹叶飞刀！造成了 ${伤害} 点伤害`, "成功");
                            },
                        },
                        {
                            名称: "金钟罩",
                            等级: 1,
                            描述: "受到攻击时有几率触发金钟罩，使攻击来源攻击力下降。抵挡比例随技能等级提升。",
                            时机: "被攻击",
                            效果: (宠物, 来源) => {
                                const 技能等级 = 宠物.自定义数据.get("技能")[1].等级; // 获取第二个技能的等级
                                const 基础格挡率 = 0.15;
                                const 格挡率 = Math.min(0.85, 基础格挡率 + (技能等级 - 1) * 0.05);

                                if (Math.random() < 格挡率 && 来源 instanceof 怪物) {
                                    // 触发格挡
                                    const 基础减伤 = 0.8;
                                    const 减伤比例 = Math.min(0, 基础减伤 - 技能等级 * 0.05);
                                    来源.基础攻击力 = Math.floor(来源.基础攻击力 * 减伤比例) //修改攻击者的基础攻击力
                                    添加日志(`${宠物.名称}触发了金钟罩！`, "成功");
                                }
                            },
                        },
                    ],
                });
            }

            升级() {
                const 升级成功 = super.升级();
                if (升级成功) {
                    const 技能列表 = this.自定义数据.get("技能");
                    if (技能列表) {
                        // 随机升级一个技能
                        const 随机技能索引 = Math.floor(Math.random() * 技能列表.length);
                        技能列表[随机技能索引].等级 += 1;
                        显示通知(`${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`, "成功");
                        window.宠物管理窗口.querySelector(".宠物技能面板").innerHTML = '';
                        window.宠物管理窗口.querySelector(".宠物技能面板").appendChild(this.创建技能面板());
                    }
                }
                return 升级成功;
            }

            当玩家被攻击(原始攻击力, 来源) {
                if (this.自定义数据.get("休眠中")) return 原始攻击力;

                let 最终攻击力 = 原始攻击力;

                // 宠物装备的防具效果
                const 防具 = this.自定义数据.get("装备")?.防具;
                if (防具) {
                    最终攻击力 = 防具.当被攻击(最终攻击力, 来源);
                }

                最终攻击力 = Math.max(0, 最终攻击力 - this.自定义数据.get("基础防御力"));
                if (最终攻击力 <= 0) 最终攻击力 = Math.round(Math.random() * 100) / 100;
                const 承担比例 = 0.3;
                const 宠物承担伤害 = Math.floor(最终攻击力 * 承担比例);
                this.受伤(宠物承担伤害);
                最终攻击力 -= 宠物承担伤害;

                this.触发技能("被攻击", 来源);
                return 最终攻击力;
            }
        }
        class 水母 extends 宠物 {
            constructor(配置 = {}) {
                super({
                    名称: "水母",
                    图标: 图标映射.水母,
                    品质: 4,
                    颜色索引: 3,
                    效果描述: "来自虚空的神秘生物，可以扭曲空间，并拥有强大的精神控制力。",
                    基础攻击力: 2,
                    基础防御力: 2,
                    最大生命值: 10,
                    强化: 配置.强化 || false,
                    技能: [
                        {
                            名称: "空间扭曲",
                            等级: 1,
                            描述: "被攻击时有几率扭曲空间，使攻击者传送回其原始位置。",
                            时机: "被攻击",
                            效果: (宠物, 来源) => {
                                if (!(来源 instanceof 怪物)) return;
                                const 技能等级 = 宠物.自定义数据.get("技能")[0].等级;
                                const 触发几率 = Math.min(0.85, 0.1 + (技能等级 - 1) * 0.05); // 初始10%几率, 每级增加5%

                                if (Math.random() < 触发几率) {
                                    // 记录原始位置
                                    if (!来源.原始位置) {
                                        来源.原始位置 = { x: 来源.x, y: 来源.y }
                                        return;
                                    }
                                    if (来源.原始位置 &&
                                        来源.原始位置.x >= 0 && 来源.原始位置.x < 地牢大小 &&
                                        来源.原始位置.y >= 0 && 来源.原始位置.y < 地牢大小
                                    ) {
                                        来源.恢复原始类型();
                                        来源.x = 来源.原始位置.x;
                                        来源.y = 来源.原始位置.y;
                                        地牢[来源.y][来源.x].原始类型 = 地牢[来源.y][来源.x].类型
                                        地牢[来源.y][来源.x].类型 = 单元格类型.怪物;
                                        地牢[来源.y][来源.x].关联怪物 = 来源;
                                        显示通知(`${宠物.名称}发动了空间扭曲！`, "成功");
                                        绘制();
                                    }

                                }
                            },
                        },
                        {
                            名称: "精神控制",
                            等级: 1,
                            描述: "攻击时有几率魅惑一个敌人，使其在短时间内为你作战。",
                            时机: "攻击",
                            效果: (宠物, 目标怪物列表) => {
                                if (!目标怪物列表 || 目标怪物列表.length === 0) return;
                                const 技能等级 = 宠物.自定义数据.get("技能")[1].等级;
                                let 触发几率 = Math.min(0.85, 0.1 + (技能等级 - 1) * 0.05);
                                //触发几率 = 1;
                                if (Math.random() < 触发几率) {
                                    const 目标 = 目标怪物列表[Math.floor(Math.random() * 目标怪物列表.length)];

                                    if (怪物状态表.get(目标)?.类型 !== "魅惑" && !(目标 instanceof 炸弹怪物) && !(目标 instanceof 大魔法师)) {
                                        const 持续回合 = 2 + 技能等级; // 基础2回合，每级+1回合
                                        const 控制状态 = new 状态效果("魅惑", "#8e44ad", "魅", 持续回合, null, null, 目标);

                                        添加日志(`${宠物.名称}控制了${目标.类型}!`, "成功");
                                    }
                                }
                            },
                        },
                    ],
                });
            }
            升级() {
                const 升级成功 = super.升级();
                if (升级成功) {
                    const 技能列表 = this.自定义数据.get("技能");
                    if (技能列表) {
                        // 随机升级
                        const 随机技能索引 = Math.floor(Math.random() * 技能列表.length);
                        技能列表[随机技能索引].等级 += 1;
                        显示通知(`${this.名称}的技能 ${技能列表[随机技能索引].名称} 升级了!`, "成功");
                        window.宠物管理窗口.querySelector(".宠物技能面板").innerHTML = '';
                        window.宠物管理窗口.querySelector(".宠物技能面板").appendChild(this.创建技能面板());
                    }
                }
                return 升级成功;
            }
        }
        class 寻宝戒指 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "戒指",
                    名称: "寻宝戒指",
                    图标: 图标映射.寻宝戒指,
                    品质: 3,
                    颜色索引: 2,
                    最大堆叠数量: 1,
                    效果描述: "装备后，会为你指出隐藏大门的位置",
                    数据: {
                        ...配置.数据,
                        生效层数: 配置.生效层数 || 当前层数, // 指定生效的层数
                        已生成折跃门: false,
                    },
                });
            }
            生成显示元素(用途 = "背包") {
                const 元素 = super.生成显示元素(用途);
                if (用途 === "装备") {
                    const 标签 = document.createElement("div");
                    标签.className = "耐久标签";
                    标签.textContent = `当前层:${当前层数}`;
                    元素.appendChild(标签);
                }
                return 元素;
            }
            使用() {
                显示通知("装备不能被使用！", "错误");
                return false;
            }
            装备() {
                if (!super.装备()) return false;
                // 触发检查和生成折跃门逻辑
                if (this.自定义数据.get("生效层数") === 当前层数 && !this.自定义数据.get("已生成折跃门")) {
                    this.尝试生成折跃门();
                }

                更新装备显示();
                return true;
            }

            取消装备() {
                if (!this.已装备) return false;
                // 移除折跃门指示器（如果存在）
                const 指示器 = document.querySelector(".折跃门指示器");
                if (指示器) {
                    指示器.remove();
                }
                玩家装备.delete(this.装备槽位);
                this.已装备 = false;
                this.装备槽位 = null;
                更新装备显示();
                return true;
            }

            尝试生成折跃门() {
                const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
                if (可用房间.length === 0) return; // 没有可用房间
                const 随机房间 = 可用房间[Math.floor(Math.random() * 房间列表.length)];
                const 放置折跃门 = new 折跃门({ 目标房间: 房间列表.find((item) => item.类型 === "boss房间" || item.类型 === "解谜棋盘") }); // 假设目标房间是起始房间
                if (放置物品到房间(放置折跃门, 随机房间, 单元格类型.物品, false, true)) {
                    this.自定义数据.set("已生成折跃门", true);
                    this.自定义数据.set("折跃门位置", { x: 放置折跃门.x, y: 放置折跃门.y })
                    更新物体指示器();
                }
            }

            获取提示() {
                return [
                    `${this.获取名称()}`,
                    `类型：${this.类型}`,
                    `生效层数：${this.自定义数据.get("生效层数")}`,
                    `效果描述：${this.效果描述}`,
                ].join("\n");
            }
        }

        class 折跃门 extends 物品 {
            constructor(配置 = {}) {
                super({
                    类型: "折跃门",
                    名称: "折跃门",
                    品质: 1,
                    颜色索引: 2,
                    能否拾起: false,
                    是否正常物品: false,
                    是否为隐藏物品: true,
                    数据: {
                        目标房间: 配置.目标房间 || null, // 目标房间的配置
                    },
                });
            }

            使用() {
                // 将玩家传送到目标房间的中心
                if (this.自定义数据.get("目标房间")) {
                    玩家.x = this.自定义数据.get("目标房间").x + Math.floor(this.自定义数据.get("目标房间").w / 2);
                    玩家.y = this.自定义数据.get("目标房间").y + Math.floor(this.自定义数据.get("目标房间").h / 2);
                    const 目标房间ID = 房间地图[玩家.y][玩家.x];
                    if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
                        moveQueue = [];
                        已访问房间.add(目标房间ID);
                    }
                    更新视口();
                    绘制();
                    显示通知("你被传送到了一个神秘的房间！", "成功");
                    return true;
                }
                return false;
            }
        }
        //下面这个物品！！！闪亮登场！
        class 炸弹 extends 物品 {
            constructor(配置) {
                super({
                    类型: "炸弹",
                    名称: "炸弹",
                    图标: 图标映射.炸弹,
                    品质: 3,
                    颜色索引: (配置.颜色索引 === undefined) ? 2 : 配置.颜色索引,
                    堆叠数量: 配置.数量 || 1,
                    能否拾起: 配置.能否拾起 === undefined ? true : 配置.能否拾起,
                    数据: {
                        效果描述: "无法对爆炸怪物造成伤害",
                        倒计时: 配置.倒计时 || 2, //不可以指定为 0
                        爆炸时间: 配置.爆炸时间 || 2,
                        爆炸范围: 配置.爆炸范围 || 3,
                    },
                });
            }
            获取提示() {
                return [
                    super.获取提示(),
                    `效果描述：${this.自定义数据.get("效果描述")}`,
                ].join("\n");
            }
            使用(玩家使用 = true, x0 = 0, y0 = 0) {
                super.使用();
                if (玩家使用) {
                    this.自定义数据.set("倒计时", this.自定义数据.get("爆炸时间"));
                    const { x, y, 新物品 } = 玩家放置物品(this, false);
                    if (x === null || y === null || 新物品 === null) return false;
                    新物品.x = x;
                    新物品.y = y;
                    所有炸弹.push(新物品);
                    return true;
                }
                this.x = x0;
                this.y = y0;
                所有炸弹.push(this);
                return true;
            }
            更新倒计时() {
                const 剩余回合 = this.自定义数据.get("倒计时");

                if (剩余回合 === 0) {
                    this.触发爆炸();
                    所有炸弹 = 所有炸弹.filter((item) => item !== this);

                }
                this.自定义数据.set("倒计时", 剩余回合 - 1);
            }

            触发爆炸() {
                // BFS遍历爆炸范围
                const 爆炸范围 = this.计算爆炸范围();
                this.显示爆炸效果(爆炸范围);
                this.处理爆炸效果(爆炸范围);
            }

            计算爆炸范围() {
                const 可到达格子 = [];
                const 队列 = [{ x: this.x, y: this.y, 距离: 0 }];
                const 已访问 = new Set([`${this.x},${this.y}`]);

                while (队列.length > 0) {
                    const 当前 = 队列.shift();
                    可到达格子.push(当前);

                    if (当前.距离 >= this.自定义数据.get("爆炸范围"))
                        continue; // 最大3格

                    // 四方向扩散
                    const 方向 = [
                        { dx: 1, dy: 0 },
                        { dx: -1, dy: 0 },
                        { dx: 0, dy: 1 },
                        { dx: 0, dy: -1 },
                    ];

                    方向.forEach(({ dx, dy }) => {
                        const 新X = 当前.x + dx;
                        const 新Y = 当前.y + dy;
                        const 位置键 = `${新X},${新Y}`;

                        if (
                            新X >= 0 &&
                            新X < 地牢大小 &&
                            新Y >= 0 &&
                            新Y < 地牢大小 &&
                            !已访问.has(位置键)
                        ) {
                            // 检查路径可行性
                            if (
                                this.检查路径可行性(
                                    当前.x,
                                    当前.y,
                                    新X,
                                    新Y
                                )
                            ) {
                                已访问.add(位置键);
                                队列.push({
                                    x: 新X,
                                    y: 新Y,
                                    距离: 当前.距离 + 1,
                                });
                            }
                        }
                    });
                }
                return 可到达格子;
            }

            检查路径可行性(fromX, fromY, toX, toY) {
                const 移动方向 = 获取移动方向(fromX, fromY, toX, toY);

                const 当前单元格 = 地牢[fromY][fromX];
                const 目标单元格 = 地牢[toY][toX];

                // 检查墙壁阻挡
                if (
                    当前单元格.墙壁[移动方向.当前墙] ||
                    目标单元格.墙壁[移动方向.反方向墙]
                ) {
                    return false;
                }

                // 检查目标单元格类型
                return [
                    单元格类型.房间,
                    单元格类型.走廊,
                    单元格类型.门,
                    单元格类型.物品,
                    单元格类型.怪物,
                    单元格类型.上锁的门,
                ].includes(目标单元格.类型);
            }

            显示爆炸效果(爆炸范围) {
                if (moveQueue.length > 0) {
                    moveQueue = [];
                    isAutoMoving = false;
                }
                爆炸范围.sort((a, b) => a.距离 - b.距离);
                待显示爆炸范围 = { 爆炸范围: 爆炸范围, 范围: this.自定义数据.get("爆炸范围") }; //实际效果在 动画帧() 实现
            }

            处理爆炸效果(爆炸范围) {
                爆炸范围.forEach(({ x, y }) => {
                    const 单元格 = 地牢[y][x];

                    // 对玩家造成伤害
                    if (玩家.x === x && 玩家.y === y) {
                        伤害玩家(30, this.名称); // 基础20点伤害
                    }

                    // 对怪物造成伤害
                    if (单元格.关联怪物) {
                        if (单元格.关联怪物.类型 !== "炸弹怪物" && 单元格.关联怪物.类型 !== "大魔法师") {
                            单元格.关联怪物.受伤(30, "炸弹");
                        }
                    }

                    // 清除物品
                    if (
                        单元格.关联物品 &&
                        单元格.关联物品.类型 !== "炸弹"
                    ) {
                        单元格.关联物品 = null;
                        单元格.类型 = 单元格.原始类型;
                    }

                    // 解锁门
                    if (单元格.类型 === 单元格类型.上锁的门) {
                        单元格.类型 = 单元格类型.门;
                    }
                    地牢[this.y][this.x].关联物品 = null;
                    地牢[this.y][this.x].类型 =
                        地牢[this.y][this.x].原始类型;
                });
                绘制();
            }
        }

        // 基类：界面元素
        class 界面元素基类 {
            constructor() {
                this.元素标识 = `元素_${Date.now()}_${Math.random()
                    .toString(36)
                    .substr(2, 9)}`;
                this.容器元素 = document.createElement("div");
                this.容器元素.className = "hud-item";
                this.容器元素.dataset.元素标识 = this.元素标识;
                document.querySelector(".hud").appendChild(this.容器元素);
            }

            销毁() {
                this.容器元素.remove();
                this.容器元素 = null;
            }

            更新(参数) {
                throw new Error("必须实现更新方法");
            }
        }

        // 文本行元素
        class 文本元素 extends 界面元素基类 {
            constructor(配置) {
                super();
                this.图标元素 = null;
                this.文本元素 = null;
                this.初始化(配置);
            }

            初始化({ 图标, 内容 }) {
                const 行容器 = document.createElement("div");
                行容器.className = "界面文本行";

                if (图标) {
                    this.图标元素 = document.createElement("span");
                    this.图标元素.className = "hud-icon";
                    this.图标元素.textContent = 图标;
                    行容器.appendChild(this.图标元素);
                }

                this.文本元素 = document.createElement("span");
                this.文本元素.className = "hud-label";
                this.文本元素.textContent = 内容;
                行容器.appendChild(this.文本元素);

                this.容器元素.appendChild(行容器);
                触发HUD显示();
            }

            更新({ 内容, 图标 }) {
                if (this.文本元素.textContent == 内容) return;
                if (内容) this.文本元素.textContent = 内容;
                if (图标) this.图标元素.textContent = 图标;
                触发HUD显示();
            }
        }

        // 进度条元素
        class 进度条元素 extends 界面元素基类 {
            constructor(配置) {
                super();
                this.进度条元素 = null;
                this.标签元素 = null;
                this.初始化(配置);
            }

            初始化({ 图标, 颜色, 初始值, 标签 }) {
                this.容器元素.innerHTML = `
                                                                        <span class="hud-icon">${图标 ||
                    "⚡"
                    }</span>
                                                                        <div class="hud-bar-container">
                                                                            <div class="hud-bar" style="width: ${初始值 ||
                    100
                    }%">
                                                                                <div class="进度条标签">${标签 ||
                    ""
                    }</div>
                                                                            </div>
                                                                        </div>
                                                                    `;

                this.进度条元素 = this.容器元素.querySelector(".hud-bar");
                this.标签元素 =
                    this.进度条元素.querySelector(".进度条标签");

                if (颜色) {
                    this.进度条元素.style.background = 颜色;
                }
                触发HUD显示();
            }

            更新({ 数值, 标签, 颜色 }) {
                if (
                    this.标签元素.textContent == 标签 &&
                    this.进度条元素.style.width == `${数值}%`
                )
                    return;
                if (数值 !== undefined) {
                    this.进度条元素.style.width = `${数值}%`;

                    // 自动添加低数值警告
                    if (数值 <= 20) {
                        this.进度条元素.classList.add("低数值警告");
                    } else {
                        this.进度条元素.classList.remove("低数值警告");
                    }
                }

                // 动态调整标签位置
                if (标签) {
                    this.标签元素.textContent = 标签;
                }

                if (颜色) {
                    this.进度条元素.style.background = 颜色;
                }
                触发HUD显示();
            }
        }

        // 使用示例：
        //const 药水条 = new 进度条元素({
        //图标: '🧪',
        //颜色: 'linear-gradient(to right, #00ff88, #00ccff)',
        //初始值: 80,
        //标签: '强化药水 80%'
        //});

        //const 任务提示 = new 文本元素({
        //    图标: '📜',
        //    内容: '主线任务：寻找古代遗物'
        //});

        // 更新元素示例
        //药水条.更新({ 数值: 15, 标签: '药水剩余 15%' });
        //任务提示.更新({ 内容: '紧急任务：击败守护者' });

        const 怪物追踪提示 = new 文本元素({
            内容: `追踪怪物：0`,
        });
        const 击杀提示 = new 文本元素({
            内容: `已击杀怪物：${已击杀怪物数}`,
        });

        // 单元格类
        class 单元格 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.类型 = 单元格类型.墙壁;
                this.墙壁 = { 上: false, 右: false, 下: false, 左: false };
                this.钥匙ID = null;
                this.颜色索引 = 颜色表.length;
                this.关联物品 = null;
                this.关联怪物 = null;
                this.原始类型 = 单元格类型.墙壁;
            }

            绘制() {
                // 绘制战争迷雾
                // 计算带小数偏移的屏幕坐标
                const 小数偏移X = (当前相机X % 1) * 单元格大小;
                const 小数偏移Y = (当前相机Y % 1) * 单元格大小;
                const 屏幕X = (this.x - 视口偏移X) * 单元格大小 - 小数偏移X;
                const 屏幕Y = (this.y - 视口偏移Y) * 单元格大小 - 小数偏移Y;
                const 房间ID = 房间地图[this.y][this.x];

                // 单元格属于某个房间且该房间未被访问过，没有特殊效果，则绘制迷雾
                if (房间ID !== -1 && !已访问房间.has(房间ID) && !玩家属性.透视) {
                    ctx.fillStyle = "rgba(0, 0, 0)";
                    ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
                } else {
                    if (this.类型 === 单元格类型.怪物) {
                        this.类型 = this.原始类型;
                        this.原始类型 = 单元格类型.怪物;
                    }
                    if (this.类型 === 单元格类型.物品) {
                        this.类型 = this.原始类型;
                        this.原始类型 = 单元格类型.物品;
                    }
                    switch (this.类型) {
                        case 单元格类型.房间:
                            ctx.fillStyle = "#3a506b";
                            break;
                        case 单元格类型.走廊:
                            ctx.fillStyle = "#2b2d42";
                            break;
                        case 单元格类型.门:
                            ctx.fillStyle = "#8b4513";
                            break;
                        case 单元格类型.上锁的门:
                            ctx.fillStyle = 颜色表[this.颜色索引]; // 使用颜色索引
                            break;
                        case 单元格类型.楼梯下楼:
                        case 单元格类型.楼梯上楼:
                            ctx.fillStyle = "#3a506b";
                            ctx.fillRect(
                                屏幕X,
                                屏幕Y,
                                单元格大小,
                                单元格大小
                            );
                            this.绘制物品(屏幕X, 屏幕Y);
                            break;
                        default:
                            ctx.fillStyle = "#1a1a1a";
                    }
                    if (
                        this.类型 !== 单元格类型.物品 &&
                        this.类型 !== 单元格类型.楼梯下楼 &&
                        this.类型 !== 单元格类型.楼梯上楼
                    ) {
                        ctx.fillRect(屏幕X, 屏幕Y, 单元格大小, 单元格大小);
                    }
                    ctx.strokeStyle =
                        this.类型 === 单元格类型.上锁的门
                            ? "#ffd700"
                            : "#e0e0e0";
                    ctx.lineWidth = 2;

                    // 绘制门（水平方向）
                    if (
                        this.墙壁.上 &&
                        (this.类型 === 单元格类型.门 ||
                            this.类型 === 单元格类型.上锁的门)
                    ) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X + 单元格大小 / 3, 屏幕Y);
                        ctx.lineTo(屏幕X + (单元格大小 * 2) / 3, 屏幕Y);
                        ctx.stroke();
                    } else if (this.墙壁.上) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X, 屏幕Y);
                        ctx.lineTo(屏幕X + 单元格大小, 屏幕Y);
                        ctx.stroke();
                    }

                    // 绘制普通墙壁
                    ctx.strokeStyle = "#e0e0e0";
                    if (this.墙壁.右) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X + 单元格大小, 屏幕Y);
                        ctx.lineTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小);
                        ctx.stroke();
                    }
                    if (this.墙壁.下) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X + 单元格大小, 屏幕Y + 单元格大小);
                        ctx.lineTo(屏幕X, 屏幕Y + 单元格大小);
                        ctx.stroke();
                    }
                    if (this.墙壁.左) {
                        ctx.beginPath();
                        ctx.moveTo(屏幕X, 屏幕Y + 单元格大小);
                        ctx.lineTo(屏幕X, 屏幕Y);
                        ctx.stroke();
                    }
                }
                if (this.原始类型 === 单元格类型.物品) {
                    this.原始类型 = this.类型;
                    this.类型 = 单元格类型.物品;
                    this.绘制物品(屏幕X, 屏幕Y);
                }
                if (this.原始类型 === 单元格类型.怪物) {
                    this.原始类型 = this.类型;
                    this.类型 = 单元格类型.怪物;
                    ctx.fillStyle = "#FFFFFF";
                    ctx.font = `${单元格大小 * 0.8}px color-emoji`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    if (this.关联怪物) {
                        if (this.关联怪物.隐身中) {
                            return;
                        }
                        this.关联怪物.绘制血条();
                        if (this.关联怪物.受击动画) {
                            ctx.fillStyle = "#FF0000"; // 受击时变红
                        } else {
                            ctx.fillStyle = this.关联怪物.颜色 || "#FFFFFF";
                        }
                        ctx.fillText(
                            this.关联怪物.图标,
                            (this.关联怪物.x - 当前相机X) * 单元格大小 +
                            单元格大小 / 2,
                            (this.关联怪物.y - 当前相机Y) * 单元格大小 +
                            单元格大小 / 2
                        );
                        if (怪物状态表.get(this.关联怪物)) {
                            ctx.fillStyle = 怪物状态表.get(this.关联怪物)?.颜色;
                            ctx.font = `${单元格大小 * 0.5}px Arial`;
                            ctx.fillText(
                                怪物状态表.get(this.关联怪物)?.图标,
                                (this.x - 当前相机X) * 单元格大小 + 单元格大小 * 0.7, // 右上角位置...暂时没想好单怪物多效果...
                                (this.y - 当前相机Y) * 单元格大小 + 单元格大小 * 0.3
                            );
                        } else if (this.关联怪物.强化) {
                            ctx.fillStyle = "#FF0000";
                            ctx.font = `${单元格大小 * 0.5}px Arial`;
                            ctx.fillText(
                                "强",
                                (this.关联怪物.x - 当前相机X) * 单元格大小 + 单元格大小 * 0.7,
                                (this.关联怪物.y - 当前相机Y) * 单元格大小 + 单元格大小 * 0.3
                            );
                        }
                    }
                }

            }
            绘制物品(屏幕X, 屏幕Y) {
                // 通用物品绘制逻辑
                if (this.关联物品) {
                    if (this.关联物品.是否为隐藏物品) {
                        return;//被隐藏的物品
                    }
                    ctx.font = `${单元格大小 * 0.8}px color-emoji`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    if (this.获取物品颜色() !== "#FFFFFF") {
                        ctx.fillStyle = this.获取物品颜色();
                    } else {
                        //alert(this.关联物品.图标);
                        ctx.fillStyle = "#000";
                    }
                    if (this.关联物品.类型 === "药水") {
                        ctx.fillStyle = this.关联物品.获取药水颜色();
                    }
                    if (this.关联物品.类型 === "金币") {
                        ctx.fillStyle = 颜色表[2];
                    }
                    ctx.fillText(
                        this.关联物品.显示图标,
                        屏幕X + 单元格大小 / 2,
                        屏幕Y + 单元格大小 / 2
                    );

                    // 添加物品光晕
                    if (this.颜色索引 < 颜色表.length) {
                        ctx.shadowColor = this.获取物品颜色();
                        if (this.关联物品.类型 === "药水") {
                            ctx.shadowColor = this.关联物品.获取药水颜色();
                        }
                        if (this.关联物品.类型 === "金币") {
                            ctx.shadowColor = 颜色表[2];
                        }
                        ctx.shadowBlur = 15;
                    }
                    ctx.fillText(
                        this.关联物品.显示图标,
                        屏幕X + 单元格大小 / 2,
                        屏幕Y + 单元格大小 / 2
                    );
                    ctx.shadowBlur = 0;
                    if (this.关联物品.堆叠数量 > 1) {
                        ctx.font = `${单元格大小 * 0.4}px Arial`;
                        ctx.fillStyle = "#FFFFFF"; // 文字填充颜色为白色
                        ctx.strokeStyle = "#000000"; // 描边颜色为黑色
                        ctx.lineWidth = 2;
                        ctx.textAlign = "right";
                        ctx.textBaseline = "bottom";

                        // 先绘制描边，再绘制填充文字
                        ctx.strokeText( // 描边
                            this.关联物品.堆叠数量,
                            屏幕X + 单元格大小 - 4,
                            屏幕Y + 单元格大小 - 4
                        );
                        ctx.fillText( // 填充
                            this.关联物品.堆叠数量,
                            屏幕X + 单元格大小 - 4,
                            屏幕Y + 单元格大小 - 4
                        );
                    }
                }
            }

            获取物品颜色() {
                // 根据物品类型返回颜色
                if (
                    this.类型 === 单元格类型.楼梯下楼 ||
                    this.类型 === 单元格类型.楼梯上楼
                )
                    return "#000";
                return this.关联物品
                    ? this.关联物品.颜色表[this.关联物品.颜色索引] ||
                    "#FFFFFF"
                    : "#FFFFFF";
            }
        }

        function drawPath(path) {
            if (path.length < 2) return;

            ctx.save();
            ctx.beginPath();

            // 设置线条样式
            ctx.strokeStyle = 'rgba(255, 50, 50, 0.5)';
            ctx.lineWidth = 2 * window.devicePixelRatio; // 适应高清屏
            ctx.setLineDash([5, 15]);
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            const startX = (玩家.x - 当前相机X + 0.5) * 单元格大小;
            const startY = (玩家.y - 当前相机Y + 0.5) * 单元格大小;
            ctx.moveTo(startX, startY);

            // 连接后续点
            for (let i = 1; i < path.length; i++) {
                const { x, y } = path[i];
                const pointX = (x - 当前相机X + 0.5) * 单元格大小;
                const pointY = (y - 当前相机Y + 0.5) * 单元格大小;
                ctx.lineTo(pointX, pointY);
            }

            ctx.stroke();
            ctx.restore();
        }
        物品池 = 创建物品池();
        怪物池 = 创建怪物池();

        // 屏幕方向检测
        let resizeTimer;
        function handleResize() {
            if (window.matchMedia("(orientation: portrait)").matches) {
                //canvas.style.transform = "scale(1)";
            } else {
                //canvas.style.transform = "scale(1.2)";
            }
            if (window.innerWidth < 769) {
                if (显示模式 === "装备") {
                    document.getElementById("小地图容器")?.classList.add("隐藏");
                    document.querySelector(".装备栏")?.classList.remove("隐藏");
                } else {
                    document.getElementById("小地图容器")?.classList.remove("隐藏");
                    document.querySelector(".装备栏")?.classList.add("隐藏");
                }
            } else {
                document.getElementById("小地图容器")?.classList.remove("隐藏");
                document.querySelector(".装备栏")?.classList.remove("隐藏");
            }
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                初始化canvas();
                更新物体指示器();
                绘制();
            }, 200); // 防抖处理
        }

        window.addEventListener("resize", handleResize);
        handleResize();

        function 开始移动() {
            if (!移动状态.up && !移动状态.down && !移动状态.left && !移动状态.right) {
                return;
            }
            控制键处理移动();
        }

        function 控制键处理移动() {
            if (!玩家属性.允许移动) return false;
            clearTimeout(移动定时器);
            clearTimeout(单击移动定时器); // 清除之前的 单击移动定时器

            const 立即移动 = () => {
                const dx = 移动状态.left ? -玩家属性.移动步数 : 移动状态.right ? 玩家属性.移动步数 : 0;
                const dy = 移动状态.up ? -玩家属性.移动步数 : 移动状态.down ? 玩家属性.移动步数 : 0;

                if (dx !== 0 || dy !== 0) {
                    移动玩家(dx, dy);
                }
            };

            const 持续移动 = () => {
                if (!移动状态.left && !移动状态.right && !移动状态.up && !移动状态.down) return;

                const now = Date.now();
                if (now - 最后移动时间 >= 移动间隔) {
                    长按移动 = true;
                    立即移动();
                    最后移动时间 = now;
                }
                移动定时器 = requestAnimationFrame(持续移动);
            };

            立即移动(); // 立即移动一步（单击）
            最后移动时间 = Date.now();

            // 如果是长按，则在 首次移动延迟 后开始持续移动
            移动定时器 = setTimeout(() => {
                cancelAnimationFrame(移动定时器);
                移动定时器 = requestAnimationFrame(持续移动);
            }, 首次移动延迟);
        }
        function 停止移动() {
            clearTimeout(移动定时器);
            clearTimeout(单击移动定时器);
            clearTimeout(开始移动定时器);
            移动状态 = { up: false, down: false, left: false, right: false, };
            长按移动 = false;
        }
        function 显示HUD() {
            if (hud模式 === "常隐") return;
            if (hud模式 === "默认") {
                if (显示HUD计时器) clearTimeout(显示HUD计时器);
                document.querySelector(".hud").classList.add("可见");
                显示HUD计时器 = setTimeout(() => {
                    隐藏HUD();
                }, 700);
            } else {
                document.querySelector(".hud").classList.add("可见");
            }
        }

        function 隐藏HUD() {
            if (hud模式 !== "默认") return;
            document.querySelector(".hud").classList.remove("可见");
        }

        function 切换HUD模式() {
            const 模式顺序 = ["默认", "常显", "常隐"];
            const 当前索引 = 模式顺序.indexOf(hud模式);
            hud模式 = 模式顺序[(当前索引 + 1) % 3];

            // 更新按钮图标
            const 按钮图标映射 = {
                默认: 图标映射.HUD智能,
                常显: 图标映射.HUD常显,
                常隐: 图标映射.HUD常隐,
            };
            document.getElementById("hudToggle").textContent =
                按钮图标映射[hud模式];

            // 立即应用新模式
            if (hud模式 === "常显") {
                document.querySelector(".hud").classList.add("可见");
            } else if (hud模式 === "常隐") {
                document.querySelector(".hud").classList.remove("可见");
            } else {
                隐藏HUD(); // 恢复默认模式隐藏
            }
        }
        function 触发HUD显示() {
            if (hud模式 === "默认") {
                if (显示HUD计时器) clearTimeout(显示HUD计时器);
                document.querySelector(".hud").classList.add("可见");
                显示HUD计时器 = setTimeout(() => {
                    隐藏HUD();
                }, 700);
            }
        }

        // 防止长按触发文字选择
        document.addEventListener("contextmenu", (e) => e.preventDefault());

        const 添加控制事件 = (元素, 方向) => {
            const 事件类型 = {
                start:
                    "ontouchstart" in window ? "touchstart" : "mousedown",
                end: "ontouchend" in window ? "touchend" : "mouseup",
            };

            元素.addEventListener(事件类型.start, (e) => {
                e.preventDefault();
                移动状态[方向] = true;
                控制键处理移动();
            });

            元素.addEventListener(事件类型.end, () => {
                移动状态[方向] = false;
                停止移动();
            });
        };

        添加控制事件(upBtn, "up");
        添加控制事件(leftBtn, "left");
        添加控制事件(rightBtn, "right");
        添加控制事件(downBtn, "down");
        function 深度比较(a, b) {
            if (a === b) return true;
            if (
                typeof a !== "object" ||
                typeof b !== "object" ||
                a === null ||
                b === null
            )
                return false;

            const aKeys = Object.keys(a);
            const bKeys = Object.keys(b);
            if (aKeys.length !== bKeys.length) return false;

            for (const key of aKeys) {
                if (!b.hasOwnProperty(key)) return false;
                if (!深度比较(a[key], b[key])) return false;
            }
            return true;
        }

        // 更新HUD显示
        function 更新界面状态() {
            document.getElementById("roomCount").textContent =
                已访问房间.size;
        }

        function 初始化canvas() {
            画布宽度 = Math.min(
                window.innerWidth - 20,
                window.innerHeight - 100
            ); // 动态宽度
            画布高度 = 画布宽度; // 动态高度

            // 保持单元格比例
            const 单元格宽 = 画布宽度 / 相机显示边长;
            const 单元格高 = 画布高度 / 相机显示边长;

            单元格大小 = Math.min(单元格宽, 单元格高);
            ctx.imageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            const dpr = window.devicePixelRatio;
            const width = 单元格大小 * 相机显示边长, height = 单元格大小 * 相机显示边长;
            // 重新设置 canvas 自身宽高大小和 css 大小。放大 canvas；css 保持不变，因为我们需要那么多的点
            canvas.width = Math.round(width * dpr);
            canvas.height = Math.round(height * dpr);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            // 直接用 scale 放大整个坐标系，相对来说就是放大了每个绘制操作
            ctx.scale(dpr, dpr);
            // 初始化小地图
            const 小地图 = document.getElementById("小地图");
            小地图.width = 地牢大小 * 小地图缩放;
            小地图.height = 地牢大小 * 小地图缩放;
            小地图Ctx = 小地图.getContext("2d");
        }

        function 生成地牢() {
            地牢 = Array(地牢大小).fill().map((_, y) => Array(地牢大小).fill().map((_, x) => new 单元格(x, y)));

            let 已连接房间对 = new Set();

            let 房间宽度 = 房间尺寸范围[0] + 2 * Math.floor((Math.random() * (房间尺寸范围[1] - 房间尺寸范围[0])) / 2);
            let 房间高度 = 房间尺寸范围[0] + 2 * Math.floor((Math.random() * (房间尺寸范围[1] - 房间尺寸范围[0])) / 2);
            let 房间起始X = Math.floor(地牢大小 / 2 - 房间宽度 / 2);
            let 房间起始Y = Math.floor(地牢大小 / 2 - 房间高度 / 2);
            房间列表.push({ x: 房间起始X, y: 房间起始Y, w: 房间宽度, h: 房间高度, id: 0, 门: [], });
            放置房间(房间列表[0]);
            let 回溯 = false;
            for (let i = 1; i < 最大房间数; i++) {
                let 放置成功 = false;
                let 尝试次数 = 0;

                while (!放置成功 && 尝试次数 < 300) {
                    尝试次数++;
                    let 上一个房间 = 房间列表[i - 1];
                    if (回溯) 上一个房间 = 房间列表[i - Math.floor(Math.max(0, 尝试次数 - 10) / 40 * (房间列表.length - 2)) - 1];
                    房间宽度 = 房间尺寸范围[0] + 2 * Math.floor((Math.random() * (房间尺寸范围[1] - 房间尺寸范围[0])) / 2);
                    房间高度 = 房间尺寸范围[0] + 2 * Math.floor((Math.random() * (房间尺寸范围[1] - 房间尺寸范围[0])) / 2);

                    const 方向 = Math.floor(Math.random() * 4);

                    const 扩展距离 = Math.floor(Math.random() * Math.max(0, 尝试次数 - 10)) + 房间尺寸范围[1] + 2;

                    switch (方向) {
                        case 0:
                            房间起始X = 上一个房间.x + Math.floor((上一个房间.w - 房间宽度) / 2);
                            房间起始Y = 上一个房间.y - 房间高度 - 扩展距离;
                            break;
                        case 1:
                            房间起始X = 上一个房间.x + 上一个房间.w + 扩展距离;
                            房间起始Y = 上一个房间.y + Math.floor((上一个房间.h - 房间高度) / 2);
                            break;
                        case 2:
                            房间起始X = 上一个房间.x + Math.floor((上一个房间.w - 房间宽度) / 2);
                            房间起始Y = 上一个房间.y + 上一个房间.h + 扩展距离;
                            break;
                        case 3:
                            房间起始X = 上一个房间.x - 房间宽度 - 扩展距离;
                            房间起始Y = 上一个房间.y + Math.floor((上一个房间.h - 房间高度) / 2);
                            break;
                    }

                    房间起始X = Math.max(5, Math.min(房间起始X, 地牢大小 - 房间宽度 - 5));
                    房间起始Y = Math.max(5, Math.min(房间起始Y, 地牢大小 - 房间高度 - 5));

                    if (区域是否空闲(房间起始X, 房间起始Y, 房间宽度, 房间高度)) {
                        const 新房间 = { x: 房间起始X, y: 房间起始Y, w: 房间宽度, h: 房间高度, id: i, 门: [] };
                        房间列表.push(新房间);
                        放置房间(新房间);
                        const 房间对ID = [房间列表[i - 1].id, 新房间.id].sort().join('-');
                        // 检查是否已经连接过
                        if (!已连接房间对.has(房间对ID)) {
                            let 路径 = 连接房间(房间列表[i - 1], 新房间);
                            if (路径) {
                                生成走廊(路径);
                                已连接房间对.add(房间对ID);
                            }
                        }

                        放置成功 = true;
                    }
                }
                回溯 = false;
                if (!放置成功) {
                    console.log(`第${i}个房间多次尝试后仍然放置失败`);
                    回溯 = true;
                }
            }
            添加额外走廊(房间列表, 5, 已连接房间对);
            let has特殊房间生成 = false
            if (Math.random() < 0.5) {
                生成特殊房间();
                has特殊房间生成 = true;
            }
            const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            生成墙壁();

            const 第一个房间 = 房间列表[0];
            玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
            玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
            玩家.x = 玩家初始位置.x;
            玩家.y = 玩家初始位置.y;

            if (房间列表.length > 4) {
                处理上锁的门();
                生成钥匙();
            }
            if (has特殊房间生成) 生成寻宝戒指();
            生成金币();
            生成物品();
            生成怪物();
            if (当前层数 === 0) {
                const 初始武器 = new 钢制长剑({ 不可破坏: true }); //初始装备
                放置物品到房间(初始武器, 房间列表[0]);
            }
            更新视口();
            已访问房间.add(第一个房间.id); // 标记为已访问
            房间列表.forEach((房间) => 更新房间墙壁(房间));

            const 随机房间 =
                可用房间[Math.floor(Math.random() * 可用房间.length)];
            放置楼梯(随机房间, 楼梯图标.下楼, 单元格类型.楼梯下楼);
            if (当前层数 > 0) {
                放置楼梯(第一个房间, 楼梯图标.上楼, 单元格类型.楼梯上楼);
            }
            更新界面状态();
            return;
        }
        function 生成特殊房间() {
            let 房间宽度 = 7;
            let 房间高度 = 7;
            let 房间起始X, 房间起始Y;
            let 放置成功 = false;
            let 尝试次数 = 0;

            while (!放置成功 && 尝试次数 < 100) {
                尝试次数++;
                房间起始X = Math.floor(Math.random() * (地牢大小 - 房间宽度 - 2)) + 1; // 边缘留空
                房间起始Y = Math.floor(Math.random() * (地牢大小 - 房间高度 - 2)) + 1;

                if (区域是否空闲(房间起始X, 房间起始Y, 房间宽度, 房间高度)) {
                    const 新房间 = {
                        x: 房间起始X,
                        y: 房间起始Y,
                        w: 房间宽度,
                        h: 房间高度,
                        id: 房间列表.length,
                        门: [],
                        已连接: false,
                        类型: Math.random() < 0.5 ? "解谜棋盘" : "boss房间" // 随机选择类型
                    };
                    房间列表.push(新房间);
                    放置房间(新房间);

                    // 根据房间类型执行特定逻辑
                    if (新房间.类型 === "解谜棋盘") {
                        生成解谜棋盘(新房间);
                    } else {
                        放置怪物到单元格(new 大魔法师({ 强化: true, 状态: 怪物状态.休眠 }), 新房间.x + 2, 新房间.y + 2);
                    }
                    放置成功 = true;
                }
            }
        }
        function 生成寻宝戒指() {
            // 排除已经作为特殊房间的房间
            const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            if (可用房间.length === 0) return; // 没有可用房间则不生成

            const 目标房间 = 可用房间[Math.floor(Math.random() * 可用房间.length)];
            const 新戒指 = new 寻宝戒指({ 生效层数: 当前层数 });
            放置物品到房间(新戒指, 目标房间);
        }

        function 连接特殊房间(特殊房间) {
            let 最近房间 = null;
            let 最小距离 = Infinity;

            for (const 房间 of 房间列表) {
                if (房间 === 特殊房间 || 房间.已连接) continue; // 排除特殊房间本身和已连接的房间

                const 距离 = Math.abs(特殊房间.x - 房间.x) + Math.abs(特殊房间.y - 房间.y);
                if (距离 < 最小距离) {
                    最小距离 = 距离;
                    最近房间 = 房间;
                }
            }
            if (最近房间) {
                let 路径 = 连接房间(特殊房间, 最近房间);

                if (路径) {
                    生成走廊(路径);
                    特殊房间.已连接 = true; // 标记为已连接
                } else {
                    添加日志(`无法将特殊房间连接到地牢！房间 ID: ${特殊房间.id}`, `错误`);
                }
            } else {
                添加日志(`没有找到可连接的房间！房间 ID: ${特殊房间.id}`, `错误`);
            }
        }
        function 生成墙壁() {
            for (let y = 0; y < 地牢大小; y++) {
                for (let x = 0; x < 地牢大小; x++) {
                    const 当前单元格 = 地牢[y][x];
                    if (当前单元格.类型 !== 单元格类型.墙壁) {
                        if (![单元格类型.门, 单元格类型.上锁的门, 单元格类型.物品, 单元格类型.怪物, 单元格类型.上楼楼梯,单元格类型.下楼楼梯].includes(当前单元格.类型)) {
                            地牢[y][x].墙壁 = {
                                上: (y > 0 && 地牢[y - 1][x].类型 !== 地牢[y][x].类型 && ![单元格类型.门, 单元格类型.上锁的门, 单元格类型.物品, 单元格类型.怪物, 单元格类型.上楼楼梯,单元格类型.下楼楼梯].includes(地牢[y - 1][x].类型)),
                                下: (y < 地牢大小 - 1 && 地牢[y + 1][x].类型 !== 地牢[y][x].类型 && ![单元格类型.门, 单元格类型.上锁的门, 单元格类型.物品, 单元格类型.怪物, 单元格类型.上楼楼梯,单元格类型.下楼楼梯].includes(地牢[y + 1][x].类型)),
                                左: (x > 0 && 地牢[y][x - 1].类型 !== 地牢[y][x].类型 && ![单元格类型.门, 单元格类型.上锁的门, 单元格类型.物品, 单元格类型.怪物, 单元格类型.上楼楼梯,单元格类型.下楼楼梯].includes(地牢[y][x - 1].类型)),
                                右: (x < 地牢大小 - 1 && 地牢[y][x + 1].类型 !== 地牢[y][x].类型 && ![单元格类型.门, 单元格类型.上锁的门, 单元格类型.物品, 单元格类型.怪物, 单元格类型.上楼楼梯,单元格类型.下楼楼梯].includes(地牢[y][x + 1].类型)),
                            };
                        } else {
                            地牢[y][x].墙壁 = {
                                上: (y > 0 && 地牢[y - 1][x].类型 === 单元格类型.墙壁),
                                下: (y < 地牢大小 - 1 && 地牢[y + 1][x].类型 === 单元格类型.墙壁),
                                左: (x > 0 && 地牢[y][x - 1].类型 === 单元格类型.墙壁),
                                右: (x < 地牢大小 - 1 && 地牢[y][x + 1].类型 === 单元格类型.墙壁),
                            };
                        }
                        const directions = [
                            { dx: 0, dy: -1, 墙: "上", 反向墙: "下" },
                            { dx: 0, dy: 1, 墙: "下", 反向墙: "上" },
                            { dx: -1, dy: 0, 墙: "左", 反向墙: "右" },
                            { dx: 1, dy: 0, 墙: "右", 反向墙: "左" },
                        ];

                        directions.forEach(dir => {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;

                            if (nx >= 0 && nx < 地牢大小 && ny >= 0 && ny < 地牢大小) {
                                if (地牢[ny][nx].类型 === 单元格类型.墙壁) {
                                    地牢[y][x].墙壁[dir.墙] = true;           // 当前单元格
                                    地牢[ny][nx].墙壁[dir.反向墙] = true;    // 相邻单元格
                                }
                            }
                        });
                    }
                }
            }
        }
        function 添加额外走廊(房间列表, 数量, 已连接房间对) {
            let 添加次数 = 0;
            let 尝试次数 = 0;

            while (添加次数 < 数量 && 尝试次数 < 100) {
                尝试次数++;

                const 房间A = 房间列表[Math.floor(Math.random() * 房间列表.length)];
                const 房间B = 房间列表[Math.floor(Math.random() * 房间列表.length)];
                if (房间A === 房间B) continue;

                const 房间对ID = [房间A.id, 房间B.id].sort().join('-');
                if (已连接房间对.has(房间对ID)) {
                    continue;
                }

                const 路径 = 连接房间(房间A, 房间B);

                if (路径) {
                    已连接房间对.add(房间对ID);
                    生成走廊(路径);
                    添加次数++;
                }

            }
        }
        function 玩家死亡() {
            if (死亡界面已显示) return;
            死亡界面已显示 = true;

            const 死亡遮罩 = document.createElement("div");
            死亡遮罩.id = "死亡遮罩";
            死亡遮罩.innerHTML = `
                                                                    <div class="死亡内容容器">
                                                                        <div class="骷髅容器">
                                                                            <div class="动态骷髅">${图标映射.死亡图标}</div>
                                                                        </div>
                                                                        <div class="重生选项">
                                                                            <button class="重生按钮" id="保留重生">
                                                                                <span class="按钮图标">⚡</span>
                                                                                从本层重生（保留物品）
                                                                            </button>
                                                                            <button class="重生按钮" id="重新开始">
                                                                                <span class="按钮图标">🔄</span>
                                                                                全新开始（第0层）
                                                                            </button>
                                                                        </div>
                                                                    </div>
                                                                `;
            if (!是否为教程层) {
                添加日志(`您已死亡，但您曾经到达 ${当前层数} 层，您的凭证是：` + 生成死亡凭证(当前层数), "信息");
            }
            CopyTextToClipboard(生成死亡凭证(当前层数));
            // 添加粒子效果
            const 粒子容器 = document.createElement("div");
            粒子容器.className = "死亡粒子";
            死亡遮罩.appendChild(粒子容器);
            生成死亡粒子(粒子容器);

            // 按钮交互
            死亡遮罩.querySelectorAll(".重生按钮").forEach((按钮) => {
                按钮.addEventListener("click", function () {
                    if (按钮.id === "保留重生") {
                        处理重生(true);
                    } else {
                        处理重生(false);
                    }
                    this.style.transform = "scale(0.95)";
                    setTimeout(() => (this.style.transform = ""), 500);
                });

                按钮.addEventListener("mouseenter", () => {
                    按钮.style.background =
                        "linear-gradient(145deg, rgba(120,0,0,0.9), rgba(180,0,0,0.7))";
                });

                按钮.addEventListener("mouseleave", () => {
                    按钮.style.background = "";
                });
            });

            document.body.appendChild(死亡遮罩);
        }

        function 生成物品() {
            const 当前层数权重 = Math.min(Math.floor(当前层数 / 2), 1); // 每2层提升品质
            const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            可用房间.forEach((房间) => {
                const 是否上锁 = 上锁房间列表.some((r) => r.id === 房间.id);
                const 房间类型 = 是否上锁 ? "上锁房间" : "普通房间";
                const 基础概率 = 是否上锁
                    ? 物品生成配置.基础概率.上锁房间
                    : 物品生成配置.基础概率.普通房间;

                // 计算实际生成概率
                let 实际概率 = 基础概率;
                if (是否上锁) 实际概率 += 0.1 + 当前层数 * 0.05;
                实际概率 = Math.min(实际概率, 0.85);

                if (Math.random() > 实际概率) return;
                let 物品数量 = 1;
                if (是否上锁) {

                    while (Math.random() < 0.8) {
                        物品数量++;
                    }
                    物品数量 = Math.min(物品数量, 5);
                }
                for (let i = 0; i < 物品数量; i++) {
                    // 计算品质分布
                    const 品质分布 = Object.entries(
                        物品生成配置.品质权重
                    ).reduce((acc, [品质, 权重]) => {
                        const 总权重 = 权重[0] + 权重[1] * 当前层数权重;
                        if (总权重 > 0)
                            acc.push({ 品质: parseInt(品质), 权重: 总权重 });
                        return acc;
                    }, []);

                    // 选择物品类型
                    const 类型分布 = 物品生成配置.类型分布[房间类型];
                    const 选中类型 = 加权随机选择(类型分布);

                    // 过滤可用物品
                    const 可用物品 = 物品池[选中类型["类型"]].filter(
                        (item) =>
                            当前层数 >= item.最小层 &&
                            品质分布.some((q) => q.品质 === item.品质)
                    );

                    if (可用物品.length === 0) return;

                    // 加权选择品质
                    const 目标品质 = 加权随机选择(
                        品质分布.map((q) => ({
                            值: q.品质,
                            权重: q.权重,
                        }))
                    );

                    // 筛选符合品质的物品
                    const 候选物品 = 可用物品.filter(
                        (item) => item.品质 === 目标品质
                    );
                    if (候选物品.length === 0) return;

                    // 创建物品实例
                    const 选中物品配置 =
                        候选物品[
                        Math.round(Math.random() * (候选物品.length - 1))
                        ];
                    const 新物品 = new 选中物品配置.类({});

                    if (是否上锁) {
                        新物品.强化 = true;
                    }

                    // 尝试放置物品
                    if (!放置物品到房间(新物品, 房间)) {
                        console.log("物品放置失败，位置被占用");
                    }
                }
            });
        }
        function 生成怪物() {
            const 当前层数权重 = Math.floor(当前层数 / 3); // 每3层上上强度
            const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            可用房间.forEach((房间) => {
                if (房间.id === 0) return;//原来js不能用countinue (误)
                const 是否上锁 = 上锁房间列表.some((r) => r.id === 房间.id);
                const 房间类型 = 是否上锁 ? "上锁房间" : "普通房间";

                const 候选怪物 = 怪物池[房间类型].filter(
                    m => 当前层数 >= m.最小层
                );

                if (候选怪物.length === 0) return;

                const 最大生成数 = 是否上锁 ? 最大怪物数 + 2 : 最大怪物数;
                let 生成数量 = Math.round(Math.random() * Math.random() * Math.random() * 最大生成数 + 当前层数权重);

                for (let i = 0; i < 生成数量; i++) {
                    const 总权重 = 候选怪物.reduce((sum, m) => sum + m.权重, 0);
                    let 随机值 = Math.random() * 总权重;
                    let 选中配置 = null;

                    for (const m of 候选怪物) {
                        if (随机值 <= m.权重) {
                            选中配置 = m;
                            break;
                        }
                        随机值 -= m.权重;
                    }

                    let 生成成功 = false;
                    for (let 尝试次数 = 0; 尝试次数 < 10; 尝试次数++) {
                        const x = 房间.x + Math.floor(Math.random() * 房间.w);
                        const y = 房间.y + Math.floor(Math.random() * 房间.h);

                        if (地牢[y][x].类型 === 单元格类型.房间 && !地牢[y][x].关联怪物) {
                            const 新怪物 = new 选中配置.类({
                                x: x,
                                y: y,
                                房间ID: 房间.id,
                                强化: 是否上锁,
                                基础攻击力: 3 + 当前层数权重,
                            });
                            新怪物.基础生命值 += 当前层数权重 * 3;
                            新怪物.当前生命值 += 当前层数权重 * 3;
                            放置怪物到单元格(新怪物, x, y);
                            生成成功 = true;
                            break;
                        }
                    }
                }
            });
        }

        function 加权随机选择(选项列表) {
            const 乱序列表 = [...选项列表].sort(() => Math.random() - 0.5);

            // 计算累计权重
            let 累计权重 = 0;
            const 累计列表 = 乱序列表.map((opt) => {
                累计权重 += opt.权重;
                return { ...opt, 累计权重 };
            });

            const 随机值 = Math.random() * 累计权重;

            // 进行一个二分
            let left = 0;
            let right = 累计列表.length - 1;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                if (随机值 <= 累计列表[mid].累计权重) {
                    if (mid === 0 || 随机值 > 累计列表[mid - 1].累计权重) {
                        return 累计列表[mid].值 || 累计列表[mid];
                    }
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }

            return 累计列表[0]?.值 || 累计列表[0];
        }

        function 生成死亡粒子(容器) {
            const 粒子数量 = 30;
            const 颜色 = ["#ff0000", "#ff4444", "#ff8888"];

            for (let i = 0; i < 粒子数量; i++) {
                const 粒子 = document.createElement("div");
                粒子.className = "死亡粒子";
                粒子.style.cssText = `
                                                                        position: absolute;
                                                                        width: ${Math.random() *
                    4 +
                    2
                    }px;
                                                                        height: ${Math.random() *
                    4 +
                    2
                    }px;
                                                                        background: ${颜色[
                    Math.floor(
                        Math.random() *
                        颜色.length
                    )
                    ]
                    };
                                                                        border-radius: 50%;
                                                                        left: ${Math.random() *
                    100
                    }%;
                                                                        top: ${Math.random() *
                    100
                    }%;
                                                                        animation: 粒子飘落 ${Math.random() *
                    3 +
                    2
                    }s linear infinite;
                                                                        opacity: ${Math.random() *
                    0.6 +
                    0.4
                    };
                                                                    `;
                容器.appendChild(粒子);
            }
        }
        function 处理重生(保留物品) {


            // 重置玩家状态
            const 生命条 = document.querySelector(".health-bar");
            生命条.style.width = "100%";
            document.querySelector(".power-bar").style.width = `100%`;
            玩家状态.forEach((m) => {
                m.移除状态();
            });
            if (当前激活卷轴列表.size > 0) {
                当前激活卷轴列表.forEach(卷轴 => {
                    卷轴.卸下();
                    当前激活卷轴列表.delete(卷轴);
                });
                恢复卷轴模式();
            }
            玩家属性 = { ...初始玩家属性 };
            玩家状态 = [];
            if (保留物品) {
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;
                玩家背包.forEach((item) => {
                    if (
                        item.类型 === "武器" &&
                        item.自定义数据.get("冷却剩余") > 0
                    ) {
                        item.自定义数据.set("冷却剩余", 0);
                    }
                });

                更新装备显示();
            } else {
                玩家背包.clear();
                玩家装备.clear();
                所有地牢层.clear();
                已访问房间.clear(); // 好像没必要 Orz..
                玩家.x = 玩家初始位置.x;
                玩家.y = 玩家初始位置.y;

                地牢 = [];
                房间列表 = [];
                所有炸弹 = []; //Q：为什么不清理所有怪物 A：这是属于切换楼层的事
                if (当前层数 !== null) {
                    切换楼层(0, true);
                } else {
                    进入教程层();
                }
                更新背包显示();
                更新装备显示();

                更新界面状态();
                更新物体指示器();
            }
            document.getElementById("卷轴按钮").style.display = [
                ...玩家装备.values(),
            ].some((item) => item.类型 === "卷轴")
                ? "flex"
                : "none";
            // 恢复控制
            const 死亡遮罩 = document.getElementById("死亡遮罩");
            if (死亡遮罩) 死亡遮罩.remove();
            死亡界面已显示 = false;
            更新视口();
            所有怪物.forEach((m) => {
                        m.绘制血条();
                    });
        }
        function 切换楼层(新层数, 完全重生 = false) {
            const 遮罩 = document.getElementById("transitionMask");
            const 标题 = document.getElementById("floorTitle");

            // 第一阶段：淡出+标题动画
            遮罩.style.opacity = 1;
            标题.textContent = `地牢 ${新层数 < 0 ? 当前层数 - 1 : 新层数}`;

            // 启动标题动画
            setTimeout(() => {
                标题.style.opacity = 1;
                标题.style.transform = "scale(1)";
            }, 200);

            // 第二阶段：切换数据
            setTimeout(() => {
                const 当前数据 = {
                    地牢数组: 地牢,
                    房间列表: 房间列表,
                    门实例列表: 门实例列表,
                    玩家位置: { x: 玩家.x, y: 玩家.y },
                    上锁房间列表: 上锁房间列表,
                    已访问房间: 已访问房间,
                    房间地图: 房间地图,
                    所有怪物: 所有怪物,
                    玩家初始位置: { x: 玩家初始位置.x, y: 玩家初始位置.y },
                    所有炸弹: 所有炸弹,
                };
                if (当前层数 !== null && !完全重生) {
                    所有地牢层.set(当前层数, 当前数据);
                }
                当前层数 = 新层数;
                if (所有地牢层.has(新层数)) {
                    所有怪物.forEach((m) => {
                        m.绘制血条(true);
                    });
                    const 新地牢数据 = 所有地牢层.get(新层数);
                    地牢 = 新地牢数据.地牢数组;
                    房间列表 = 新地牢数据.房间列表;
                    门实例列表 = 新地牢数据.门实例列表;
                    玩家.x = 新地牢数据.玩家位置.x;
                    玩家.y = 新地牢数据.玩家位置.y;
                    上锁房间列表 = 新地牢数据.上锁房间列表;
                    已访问房间 = 新地牢数据.已访问房间;
                    房间地图 = 新地牢数据.房间地图;
                    所有怪物 = 新地牢数据.所有怪物;
                    所有炸弹 = 新地牢数据.所有炸弹;
                    玩家初始位置 = 新地牢数据.玩家初始位置;
                } else {
                    所有怪物.forEach((m) => {
                        m.绘制血条(true);
                    });
                    房间列表 = [];
                    上锁房间列表 = [];
                    所有怪物 = [];
                    所有炸弹 = [];
                    已访问房间 = new Set();
                    房间地图 = Array(地牢大小)
                        .fill()
                        .map(() => Array(地牢大小).fill(-1));
                    门实例列表 = new Map();
                    生成地牢();
                }

                更新视口();
                绘制();
                更新界面状态();
                更新物体指示器();
                所有怪物.forEach((m) => {
                    m.绘制血条();
                });
                移动玩家(0, 0);//刷新回合
                // 第三阶段：淡入+标题消失
                标题.style.opacity = 0;
                标题.style.transform = "scale(0.5)";
                遮罩.style.opacity = 0;
            }, 1500);
        }

        function 放置楼梯(房间, 图标, 类型) {
            const 楼梯 = {
                图标: 图标,
                显示图标: 图标,
                颜色索引: 颜色表.length,
                x: 0,
                y: 0,
                使用: () => {
                    const 目标层数 =
                        类型 === 单元格类型.楼梯下楼
                            ? 当前层数 + 1
                            : 当前层数 - 1;
                    切换楼层(目标层数);
                },
            };
            放置物品到房间(楼梯, 房间, 类型);
        }

        function 生成金币() {
            const 普通房间生成概率 = 0.3;
            const 上锁房间生成概率 = 0.7;
            const 可用房间 = 房间列表.filter(房间 => 房间.类型 !== "解谜棋盘" && 房间.类型 !== "boss房间");
            可用房间.forEach((房间) => {
                let 生成概率 = 普通房间生成概率;
                let 最大数量 = 9 + 当前层数;

                // 上锁房间生成更多金币
                if (上锁房间列表.some((r) => r.id === 房间.id)) {
                    生成概率 = 上锁房间生成概率;
                    最大数量 = 22 + 当前层数;
                }

                if (Math.random() < 生成概率) {
                    const 数量 = Math.min(Math.floor(Math.random() * 最大数量) + 1, 最大堆叠数);
                    const 金币实例 = new 金币({ 数量 });
                    放置物品到房间(金币实例, 房间);
                }
            });
        }
        function 区域是否空闲(x, y, w, h) {
            for (let i = y; i < y + h; i++) {
                for (let j = x; j < x + w; j++) {
                    if (
                        i >= 地牢大小 ||
                        j >= 地牢大小 ||
                        地牢[i][j].类型 !== 单元格类型.墙壁
                    ) {
                        return false;
                    }
                }
            }

            // 计算缓冲区范围
            const 缓冲距离 = 2;
            const xStart = Math.max(0, x - 缓冲距离);
            const xEnd = Math.min(地牢大小 - 1, x + w - 1 + 缓冲距离);
            const yStart = Math.max(0, y - 缓冲距离);
            const yEnd = Math.min(地牢大小 - 1, y + h - 1 + 缓冲距离);

            for (let yi = yStart; yi <= yEnd; yi++) {
                for (let xi = xStart; xi <= xEnd; xi++) {
                    // 计算到房间边缘的最小曼哈顿距离
                    let dx = 0,
                        dy = 0;
                    if (xi < x) dx = x - xi;
                    else if (xi >= x + w) dx = xi - (x + w - 1);

                    if (yi < y) dy = y - yi;
                    else if (yi >= y + h) dy = yi - (y + h - 1);

                    const 总距离 = dx + dy;

                    // 如果曼哈顿距离≤2且单元格非墙壁，则区域被占用
                    if (
                        总距离 <= 缓冲距离 &&
                        地牢[yi][xi].类型 !== 单元格类型.墙壁
                    ) {
                        return false;
                    }
                }
            }

            return true;
        }

        function 放置房间(房间) {
            for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                    const 单元格 = 地牢[y][x];
                    单元格.类型 = 单元格类型.房间;
                    房间地图[y][x] = 房间.id;
                    单元格.墙壁 = {
                        上: y === 房间.y,
                        下: y === 房间.y + 房间.h - 1,
                        左: x === 房间.x,
                        右: x === 房间.x + 房间.w - 1,
                    };
                }
            }
            房间.已解锁 = false;
            return true;
        }

        function 更新房间墙壁(房间) {
            房间.门.forEach((门) => {
                const { x, y } = 门;
                if (y + 1 < 地牢大小) 地牢[y + 1][x].墙壁.上 = false;
                if (y - 1 >= 0) 地牢[y - 1][x].墙壁.下 = false;
                if (x + 1 < 地牢大小) 地牢[y][x + 1].墙壁.左 = false;
                if (x - 1 >= 0) 地牢[y][x - 1].墙壁.右 = false;
            });
        }

        function 处理上锁的门() {
            // 计算房间 ID 的 50% 分位点
            const 上锁起始索引 = Math.floor(房间列表.length * 0.5);

            const 候选房间 = 房间列表.filter(
                (房间) => 房间.门.length > 1 && 房间.id >= 上锁起始索引
            );

            const 上锁数量 = Math.floor((Math.random() * 候选房间.length));

            for (let i = 0; i < 上锁数量; i++) {
                if (候选房间.length === 0) break;

                const 目标房间 = 候选房间.splice(
                    Math.floor(Math.random() * 候选房间.length),
                    1
                )[0];

                if (目标房间.id !== 0) {
                    const 颜色索引 = i % 颜色表.length;
                    目标房间.门.forEach((门) => {
                        const 单元格 = 地牢[门.y][门.x];
                        门实例列表.get(单元格.标识).类型 = "上锁的门";
                        if (单元格.类型 === 单元格类型.门) {
                            单元格.类型 = 单元格类型.上锁的门;
                            单元格.钥匙ID = 目标房间.id;
                            单元格.颜色索引 = 颜色索引;
                        }
                    });
                    上锁房间列表.push({ ...目标房间, 颜色索引 });
                }
            }

            上锁房间列表.forEach((房间) => (房间.已解锁 = false));
        }

        function 生成钥匙() {
            // 计算房间 ID 的 50% 分位点
            const 钥匙放置截止索引 = Math.floor(房间列表.length * 0.5);

            上锁房间列表.forEach((上锁房间) => {
                const 新钥匙 = new 钥匙({
                    门ID: 上锁房间.id,
                    颜色索引: 上锁房间.颜色索引,
                    地牢层数: 当前层数,
                });

                // 只在房间 ID 小于 80% 分位点的房间中生成钥匙
                const 可用房间 = 房间列表.filter(
                    (r) =>
                        !上锁房间列表.some((锁房) => 锁房.id === r.id) && r.id < 钥匙放置截止索引
                );

                const 目标房间 =
                    可用房间.length > 0
                        ? 可用房间[Math.floor(Math.random() * 可用房间.length)]
                        : null; // 确保有可用房间

                if (目标房间 && 放置物品到房间(新钥匙, 目标房间)) {
                    // 放置成功
                }
            });
        }

        function 寻找房间入口(房间, 避开方向 = {}) {
            const { x, y, w, h } = 房间;
            const 候选入口 = [];

            if (!避开方向.上 && y > 0) {
                for (let i = x + 1; i < x + w - 1; i++) {
                    if (地牢[y - 1][i].类型 === 单元格类型.墙壁) {
                        候选入口.push({ x: i, y: y - 1 });
                    }
                }
            }
            if (!避开方向.下 && y + h < 地牢大小 - 1) {
                for (let i = x + 1; i < x + w - 1; i++) {
                    if (地牢[y + h][i].类型 === 单元格类型.墙壁) {
                        候选入口.push({ x: i, y: y + h });
                    }
                }
            }
            if (!避开方向.左 && x > 0) {
                for (let i = y + 1; i < y + h - 1; i++) {
                    if (地牢[i][x - 1].类型 === 单元格类型.墙壁) {
                        候选入口.push({ x: x - 1, y: i });
                    }
                }
            }
            if (!避开方向.右 && x + w < 地牢大小 - 1) {
                for (let i = y + 1; i < y + h - 1; i++) {
                    if (地牢[i][x + w].类型 === 单元格类型.墙壁) {
                        候选入口.push({ x: x + w, y: i });
                    }
                }
            }
            return 候选入口; // 直接返回数组
        }

        function 连接房间(房间A, 房间B, 尝试 = 0) {
            if (!房间A || !房间B) return;
            if (尝试 >= 6) {
                房间A =
                    房间列表[
                    Math.floor(Math.random() * (房间列表.length - 2))
                    ];
            }
            if (尝试 >= 12) return;
            const 相对位置 = {
                左: 房间A.x < 房间B.x,
                右: 房间A.x > 房间B.x,
                上: 房间A.y < 房间B.y,
                下: 房间A.y > 房间B.y,
            };

            const 避开方向 = {
                起始: {
                    左: 相对位置.左,
                    右: 相对位置.右,
                    上: 相对位置.上,
                    下: 相对位置.下,
                },
                结束: {
                    左: 相对位置.右,
                    右: 相对位置.左,
                    上: 相对位置.下,
                    下: 相对位置.上,
                },
            };

            const 起始候选 = 寻找房间入口(房间A, 避开方向.起始);
            const 结束候选 = 寻找房间入口(房间B, 避开方向.结束);

            if (!起始候选 || !结束候选) return;


            let 起始 = null;
            let 结束 = null;
            let 最小距离 = Infinity;

            for (const 房间起始 of 起始候选) {
                for (const 房间结束 of 结束候选) {
                    const 距离 = Math.abs(房间起始.x - 房间结束.x) + Math.abs(房间起始.y - 房间结束.y);
                    if (距离 < 最小距离) {
                        最小距离 = 距离;
                        起始 = 房间起始;
                        结束 = 房间结束;
                    }
                }
            }

            if (!起始 || !结束) {
                return;
            }

            let 当前 = { x: 起始.x, y: 起始.y };
            let 路径 = [当前];
            let 门 = [];
            let 在房间内 = false;
            let 进入的房间 = null;

            门.push({ x: 起始.x, y: 起始.y, 进入的房间: 房间A });

            const x轴优先 =
                Math.abs(结束.x - 起始.x) > Math.abs(结束.y - 起始.y);

            let 上一个节点 = 当前;
            while (当前.x !== 结束.x || 当前.y !== 结束.y) {
                const dx = 结束.x - 当前.x;
                const dy = 结束.y - 当前.y;

                if (x轴优先 && dx !== 0) {
                    当前.x += dx > 0 ? 1 : -1;
                } else if (dy !== 0) {
                    当前.y += dy > 0 ? 1 : -1;
                } else if (!x轴优先 && dx !== 0) {
                    当前.x += dx > 0 ? 1 : -1;
                }

                let 附近的门数量 = [
                    { x: 当前.x, y: 当前.y - 1 },
                    { x: 当前.x, y: 当前.y + 1 },
                    { x: 当前.x - 1, y: 当前.y },
                    { x: 当前.x + 1, y: 当前.y },
                ].reduce((数量, pos) => {
                    if (
                        pos.x >= 0 &&
                        pos.x < 地牢大小 &&
                        pos.y >= 0 &&
                        pos.y < 地牢大小
                    ) {
                        return (
                            数量 +
                            (地牢[pos.y][pos.x].类型 === 单元格类型.门)
                        );
                    }
                    return 数量;
                }, 0);

                const 碰撞房间 = 房间列表.find(
                    (房间) =>
                        当前.x >= 房间.x &&
                        当前.x <= 房间.x + 房间.w - 1 &&
                        当前.y >= 房间.y &&
                        当前.y <= 房间.y + 房间.h - 1 &&
                        房间 !== 房间A
                );
                if (碰撞房间 && !在房间内) {
                    在房间内 = true;
                    进入的房间 = 碰撞房间;
                    门.push({ x: 上一个节点.x, y: 上一个节点.y, 进入的房间: 进入的房间, });
                    附近的门数量 -= 1;
                } else if (!碰撞房间 && 在房间内) {
                    if (当前.x !== 结束.x && 当前.y !== 结束.y) {
                        门.push({
                            x: 当前.x,
                            y: 当前.y,
                            进入的房间: 进入的房间,
                        });
                        路径.push({ x: 当前.x, y: 当前.y });
                        在房间内 = false;
                    }
                    附近的门数量 -= 1;
                }
                if (
                    地牢[当前.y][当前.x].类型 === 单元格类型.门 ||
                    附近的门数量 > 1
                ) {
                    let 路径 = [];
                    let 门 = [];
                    return 连接房间(房间A, 房间B, 尝试 + 1);
                }
                if (
                    路径.length === 0 &&
                    地牢[当前.y][当前.x].类型 === 单元格类型.走廊
                ) {
                    let 路径 = [];
                    let 门 = [];
                    return 连接房间(房间A, 房间B, 尝试 + 1);
                }
                if (!在房间内) {
                    路径.push({ x: 当前.x, y: 当前.y });
                }
                上一个节点 = { x: 当前.x, y: 当前.y };
            }

            if (!在房间内) {
                门.push({ x: 结束.x, y: 结束.y, 进入的房间: 房间B });
                路径.push(结束);
            }
            门.forEach((door) => {
                放置门(door.x, door.y, door.进入的房间);
            });
            return 路径;
        }

        function 生成走廊(路径) {
            for (let i = 0; i < 路径.length; i++) {
                const { x, y } = 路径[i];
                if (是否在任意房间内(x, y)) continue;

                if (
                    x < 地牢大小 &&
                    y < 地牢大小 &&
                    地牢[y][x].类型 !== 单元格类型.门
                ) {
                    地牢[y][x].类型 = 单元格类型.走廊;
                    地牢[y][x].墙壁 = {
                        上: false,
                        右: false,
                        下: false,
                        左: false,
                    };
                }
            }
        }

        function 是否在任意房间内(x, y) {
            return 房间列表.some(
                (房间) =>
                    x >= 房间.x &&
                    x < 房间.x + 房间.w &&
                    y >= 房间.y &&
                    y < 房间.h
            );//可改为直接判断单元格类型
        }

        function 放置门(x, y, 目标房间) {
            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return;
            const 新门 = new 门({
                关联房间ID: 目标房间.id,
                位置: { x, y },
            });
            地牢[y][x].标识 = 新门.唯一标识; // 绑定门标识
            地牢[y][x].关联物品 = null;
            地牢[y][x].类型 = 单元格类型.门;
            地牢[y][x].墙壁 = {
                上: false,
                右: false,
                下: false,
                左: false,
            };

            const 方向 = [
                { dx: 0, dy: -1, 墙: "下" },
                { dx: 0, dy: 1, 墙: "上" },
                { dx: -1, dy: 0, 墙: "右" },
                { dx: 1, dy: 0, 墙: "左" },
            ];

            方向.forEach((dir) => {
                const adjX = x + dir.dx;
                const adjY = y + dir.dy;
                if (
                    adjX >= 0 &&
                    adjX < 地牢大小 &&
                    adjY >= 0 &&
                    adjY < 地牢大小
                ) {
                    地牢[adjY][adjX].墙壁[dir.墙] = false;
                }
            });

            if (目标房间) {
                目标房间.门.push({ x, y });
            }
        }

        function 放置物品到房间(
            物品实例,
            目标房间,
            放置物体 = 单元格类型.物品,
            禁用光晕 = false,
            特效 = false,
        ) {
            // 寻找有效放置位置
            let 放置成功 = false;
            for (let 尝试次数 = 0; 尝试次数 < 20; 尝试次数++) {
                // 计算房间有效区域
                const 最小x = 目标房间.x;
                const 最大x = 目标房间.x + 目标房间.w - 1;
                const 最小y = 目标房间.y;
                const 最大y = 目标房间.y + 目标房间.h - 1;

                // 生成随机坐标
                const x =
                    最小x + Math.floor(Math.random() * (最大x - 最小x + 1));
                const y =
                    最小y + Math.floor(Math.random() * (最大y - 最小y + 1));

                // 验证位置有效性
                if (位置是否可用(x, y)) {
                    地牢[y][x].原始类型 = 地牢[y][x].类型;
                    地牢[y][x].类型 = 放置物体;
                    地牢[y][x].关联物品 = 物品实例;
                    if (物品实例.颜色索引 === null || 禁用光晕) {
                        物品实例.颜色索引 = 物品实例.颜色表.length;
                    }
                    物品实例.x = x;
                    物品实例.y = y;
                    地牢[y][x].颜色索引 = 物品实例.颜色索引;
                    放置成功 = true;
                    if (特效) 计划显示格子特效([{ x: x, y: y }], 物品实例.颜色表[物品实例.颜色索引].slice(1));
                    break;
                }
            }
            return 放置成功;
        }
        function 放置物品到单元格(
            物品实例,
            x,
            y,
            放置物体 = 单元格类型.物品,
            禁用光晕 = false
        ) {
            // 验证位置有效性
            if (位置是否可用(x, y, false)) {
                地牢[y][x].原始类型 = 地牢[y][x].类型;
                地牢[y][x].类型 = 放置物体;
                地牢[y][x].关联物品 = 物品实例;
                if (物品实例.颜色索引 === null || 禁用光晕) {
                    物品实例.颜色索引 = 物品实例.颜色表.length;
                }
                物品实例.x = x;
                物品实例.y = y;
                地牢[y][x].颜色索引 = 物品实例.颜色索引;
                绘制();
                return true;
            }
            return false;
        }

        function 位置是否可用(x, y, 考虑玩家 = true) {
            // 边界检查
            if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小)
                return false;
            if (考虑玩家 && 玩家.x === x && 玩家.y === y) return false;
            const 单元格 = 地牢[y][x];

            // 必须是房间地板且没有其他物品
            return (
                [单元格类型.房间, 单元格类型.走廊].includes(单元格.类型) &&
                !单元格.关联物品 &&
                !单元格.关联怪物
            );
        }


        //修改时记得同步修改使用背包物品
        function 尝试互动() {
            let 互动 = false;
            if (互动冷却) return;
            互动冷却 = true;
            setTimeout(() => (互动冷却 = false), 500);

            // 优先处理玩家所在格子的互动
            const 玩家所在单元格 = 地牢[玩家.y][玩家.x];

            if (玩家所在单元格.类型 === 单元格类型.物品) {
                if (玩家所在单元格.关联物品?.类型 === "棋子") {
                    玩家所在单元格.关联物品.能否拾起 = true;
                    if (尝试收集物品(玩家所在单元格.关联物品)) {
                        玩家所在单元格.类型 = 玩家所在单元格.原始类型;
                        玩家所在单元格.关联物品 = null;
                        绘制();
                        互动 = true;
                    }
                } else if (尝试收集物品(玩家所在单元格.关联物品)) {
                    玩家所在单元格.类型 = 玩家所在单元格.原始类型;
                    玩家所在单元格.关联物品 = null;
                    绘制();
                    互动 = true;
                } else if (玩家所在单元格.关联物品?.类型 === "NPC" && !NPC互动中) {
                    打开交易窗口(玩家所在单元格.关联物品);
                    NPC互动中 = true;
                    互动 = true;
                } else if (玩家所在单元格.关联物品?.类型 === "祭坛") {
                    if (confirm("是否献祭 75 血量给祭坛？")) 互动 = 玩家所在单元格.关联物品.尝试互动();
                }
            }
            if (互动) return;

            const 方向 = [
                { dx: 0, dy: -1 }, // 上
                { dx: 1, dy: 0 }, // 右
                { dx: 0, dy: 1 }, // 下
                { dx: -1, dy: 0 }, // 左
            ];

            for (const { dx, dy } of 方向) {
                const 目标X = 玩家.x + dx;
                const 目标Y = 玩家.y + dy;

                if (目标X < 0 || 目标X >= 地牢大小 || 目标Y < 0 || 目标Y >= 地牢大小) continue;

                const 单元格 = 地牢[目标Y][目标X];

                // 处理上锁的门
                if (单元格.类型 === 单元格类型.上锁的门) {
                    const 对应门 = 门实例列表.get(单元格.标识);
                    const 对应钥匙 = [...玩家背包.values()].find((item) => item.可交互目标(对应门));
                    if (对应钥匙) {
                        房间列表.find((房间) => 房间.id === 对应门.房间ID)?.门?.forEach((item) => {
                            房间门 = 门实例列表.get(地牢[item.y][item.x].标识);
                            互动 = 房间门.尝试解锁(玩家背包);
                            if (互动) 地牢[房间门.所在位置.y][房间门.所在位置.x].类型 = 单元格类型.门;
                        });
                        绘制();
                    }
                    if (互动) {
                        处理销毁物品(对应钥匙.唯一标识, true);
                        显示通知("解锁成功！", "成功");
                        break; // 互动成功，跳出循环
                    }
                } else if (快速直线检查(玩家.x, 玩家.y, 目标X, 目标Y, 1)) { //注意，此处未与本格互动成功才检测周围
                    if (单元格.类型 === 单元格类型.物品) {
                        if (单元格.关联物品?.类型 === "棋子") {
                            单元格.关联物品.能否拾起 = true;
                            单元格.关联物品.isActive = false;
                            if (尝试收集物品(单元格.关联物品)) {
                                单元格.类型 = 单元格.原始类型;
                                单元格.关联物品 = null;
                                绘制();
                                互动 = true;
                            }
                        } else if (尝试收集物品(单元格.关联物品)) {
                            单元格.类型 = 单元格.原始类型;
                            单元格.关联物品 = null;
                            绘制();
                            互动 = true;
                        } else if (单元格.关联物品?.类型 === "NPC" && !NPC互动中) {
                            打开交易窗口(单元格.关联物品);
                            NPC互动中 = true;
                            互动 = true;
                            break;
                        } else if (单元格.关联物品?.类型 === "祭坛") {
                            if (confirm("是否献祭 75 血量给祭坛？")) {
                                互动 = 单元格.关联物品.尝试互动();
                                if (互动) break;
                            }
                        }
                    }
                }
            }
            if (互动) return;
            const 武器 = [...玩家装备.values()].filter(
                (i) =>
                    i.类型 === "武器" &&
                    i.堆叠数量 > 0 &&
                    i.自定义数据.get("冷却剩余") == 0
            );
            if (武器) {
                let maxCount = 0;
                let maxRange = 0;
                let 目标怪物, 目标路径 = [];
                武器.forEach((可用武器) => {
                    maxCount = Math.max(maxCount, 可用武器.自定义数据.get("攻击目标数"));
                    if (!(可用武器 instanceof 金币手枪)) maxRange = Math.max(maxRange, 可用武器.自定义数据.get("攻击范围"));
                })
                let { 怪物, 路径 } = 获取周围怪物(
                    maxCount,
                    maxRange
                );
                if (怪物 && 路径) {
                    武器.forEach((可用武器) => {
                        路径 = 路径.filter((item, index) => 怪物[index].当前生命值 > 0);
                        怪物 = 怪物.filter((item) => item.当前生命值 > 0);
                        目标路径 = [];
                        目标怪物 = [];
                        路径.forEach((item) => {
                            if (item.length <= 可用武器.自定义数据.get("攻击范围") + 1) {
                                目标路径.push(item)
                            }
                        });
                        目标怪物 = 怪物.slice(0, Math.min(目标路径.length, 可用武器.自定义数据.get("攻击目标数"))); //左闭右开
                        目标路径 = 路径.slice(0, Math.min(目标路径.length, 可用武器.自定义数据.get("攻击目标数")));
                        if (目标怪物 !== null && !(可用武器 instanceof 金币手枪)) {
                            if (可用武器.使用(目标怪物)) {
                                目标路径.forEach((攻击路径) => {
                                    计划显示格子特效(攻击路径);
                                });
                                [...玩家装备.values()].forEach(装备 => {
                                    if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                                        装备.当玩家攻击(目标怪物);
                                    }
                                });
                                更新装备显示();
                                绘制();
                                互动 = true;
                            }
                        }
                    });
                }
                武器.forEach((可用武器) => {
                    if (可用武器 instanceof 金币手枪) {
                        if (可用武器.使用()) {
                            更新装备显示();
                            互动 = true;
                        }
                    }
                });
            }

            if (!互动) 显示通知("周围没有可互动物体了...", "信息");
            return;
        }
        function 克隆物品(原始物品) {
            // 浅拷贝
            return Object.assign(Object.create(Object.getPrototypeOf(原始物品)), 原始物品);
        }
        function 获取周围怪物(数量 = 1, 范围 = null) {
            let 攻击范围 = 0;
            if (范围 === null) {
                const 当前武器 = [...玩家装备.values()].find(
                    (i) =>
                        i.类型 === "武器" &&
                        i.堆叠数量 > 0 &&
                        i.自定义数据.get("冷却剩余") === 0
                );
                if (!当前武器) return { 路径: null, 怪物: null };
                攻击范围 = 当前武器.自定义数据.get("攻击范围");
            } else {
                攻击范围 = 范围;
            }
            const 候选怪物 = [];
            for (let dx = -攻击范围; dx <= 攻击范围; dx++) {
                for (let dy = -攻击范围; dy <= 攻击范围; dy++) {
                    const x = 玩家.x + dx;
                    const y = 玩家.y + dy;
                    if (
                        x >= 0 &&
                        x < 地牢大小 &&
                        y >= 0 &&
                        y < 地牢大小 &&
                        地牢[y][x].关联怪物?.状态 === 怪物状态.活跃 &&
                        怪物状态表.get(地牢[y][x].关联怪物)?.类型 !== "魅惑"
                    ) {
                        const 怪物实例 = 地牢[y][x].关联怪物;
                        if (检查视线(玩家.x, 玩家.y, x, y, 攻击范围)) {
                            候选怪物.push({
                                怪物: 怪物实例,
                                距离: Math.abs(dx) + Math.abs(dy),
                                x: x,
                                y: y,
                            });
                        }
                    }
                }
            }
            const 排序后 = 候选怪物.sort((a, b) => a.距离 - b.距离);
            const 结果 = 排序后.slice(0, 数量);
            const 路径数组 = [];
            const 怪物数组 = [];
            for (const item of 结果) {
                let 路径 = [];
                if (快速直线检查(玩家.x, 玩家.y, item.x, item.y, 攻击范围)) {
                    路径 = 获取直线路径(玩家.x, 玩家.y, item.x, item.y);
                } else {
                    路径 = 广度优先搜索路径(
                        玩家.x,
                        玩家.y,
                        item.x,
                        item.y,
                        攻击范围,
                        true
                    );
                }
                if (路径) {
                    路径.shift();
                    路径数组.push(路径);
                    怪物数组.push(item.怪物);
                }
            }
            return 路径数组.length > 0 ? { 路径: 路径数组, 怪物: 怪物数组 } : { 路径: null, 怪物: null };
        }
        function 获取直线路径(startX, startY, endX, endY) {
            const path = [];
            let currentX = startX;
            let currentY = startY;
            const dx = endX - startX;
            const dy = endY - startY;
            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            const xInc = dx / steps;
            const yInc = dy / steps;
            for (let i = 0; i <= steps; i++) {
                const x = Math.round(currentX);
                const y = Math.round(currentY);
                path.push({ x: x, y: y });
                currentX += xInc;
                currentY += yInc;
            }
            return path;
        }
        // BFS U ARE MY GOD
        function 广度优先搜索路径(
            startX,
            startY,
            endX,
            endY,
            maxSteps,
            返回路径 = false
        ) {
            const 最小步数记录 = new Array(地牢大小)
                .fill()
                .map(() => new Array(地牢大小).fill(Infinity));
            const 前驱节点 = new Array(地牢大小)
                .fill(null)
                .map(() => new Array(地牢大小).fill(null));
            const 队列 = [[startX, startY, 0]];
            最小步数记录[startY][startX] = 0;
            const 方向 = [
                { dx: 0, dy: -1, 当前墙: "上", 反方向墙: "下" },
                { dx: 0, dy: 1, 当前墙: "下", 反方向墙: "上" },
                { dx: -1, dy: 0, 当前墙: "左", 反方向墙: "右" },
                { dx: 1, dy: 0, 当前墙: "右", 反方向墙: "左" },
            ];
            while (队列.length > 0) {
                const [x, y, step] = 队列.shift();
                if (x === endX && y === endY) {
                    if (返回路径) {
                        return 从终点回溯路径(前驱节点, endX, endY);
                    }
                    return true;
                }
                if (step >= maxSteps) continue;
                for (const dir of 方向) {
                    const 新X = x + dir.dx;
                    const 新Y = y + dir.dy;
                    const 新步数 = step + 1;
                    if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小)
                        continue;
                    if (新步数 >= 最小步数记录[新Y][新X]) continue;
                    const 当前单元格 = 地牢[y][x];
                    const 下一单元格 = 地牢[新Y][新X];
                    if (当前单元格.墙壁[dir.当前墙] || 下一单元格.墙壁[dir.反方向墙])
                        continue;
                    if (
                        [单元格类型.墙壁, 单元格类型.上锁的门].includes(下一单元格.类型)
                    )
                        continue;
                    最小步数记录[新Y][新X] = 新步数;
                    前驱节点[新Y][新X] = { x: x, y: y };
                    队列.push([新X, 新Y, 新步数]);
                }
            }
            return 返回路径 ? [] : false;
        }
        function 从终点回溯路径(前驱节点, endX, endY) {
            const 路径 = [];
            let currentX = endX;
            let currentY = endY;
            while (前驱节点[currentY][currentX] !== null) {
                路径.push({ x: currentX, y: currentY });
                const tempX = 前驱节点[currentY][currentX].x;
                const tempY = 前驱节点[currentY][currentX].y;
                currentX = tempX;
                currentY = tempY;
            }
            路径.push({ x: currentX, y: currentY });
            return 路径.reverse();
        }
        function 检查视线(startX, startY, endX, endY, maxSteps = Infinity) {
            const 曼哈顿距离 = Math.abs(endX - startX) + Math.abs(endY - startY);
            if (曼哈顿距离 > maxSteps) return false;
            if (startX === endX && startY === endY) return true;
            if (快速直线检查(startX, startY, endX, endY, maxSteps)) {
                return true;
            }
            return 广度优先搜索路径(startX, startY, endX, endY, maxSteps);
        }
        function 快速直线检查(startX, startY, endX, endY, maxSteps) {
            let currentX = startX;
            let currentY = startY;
            const dx = endX - startX;
            const dy = endY - startY;
            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            if (steps > maxSteps) return false;
            const xInc = dx / steps;
            const yInc = dy / steps;
            for (let i = 0; i <= steps; i++) {
                const x = Math.round(currentX);
                const y = Math.round(currentY);
                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return false;
                if ([单元格类型.墙壁, 单元格类型.上锁的门].includes(地牢[y][x].类型))
                    return false;
                if (i > 0) {
                    const prevX = Math.round(currentX - xInc);
                    const prevY = Math.round(currentY - yInc);
                    const dirs = [];
                    if (x > prevX) dirs.push("右");
                    if (x < prevX) dirs.push("左");
                    if (y > prevY) dirs.push("下");
                    if (y < prevY) dirs.push("上");
                    for (const dir of dirs) {
                        const mapping = {
                            右: { 当前墙: "左", 反方向墙: "右" },
                            左: { 当前墙: "右", 反方向墙: "左" },
                            下: { 当前墙: "上", 反方向墙: "下" },
                            上: { 当前墙: "下", 反方向墙: "上" },
                        }[dir];
                        if (
                            地牢[y][x].墙壁[mapping.当前墙] ||
                            地牢[prevY][prevX].墙壁[mapping.反方向墙]
                        ) {
                            return false;
                        }
                    }
                }
                currentX += xInc;
                currentY += yInc;
            }
            return true;
        }
        function 获取移动方向(fromX, fromY, toX, toY) {
            const dx = toX - fromX;
            const dy = toY - fromY;
            const 主要方向 =
                Math.abs(dx) > Math.abs(dy)
                    ? dx > 0
                        ? "右"
                        : "左"
                    : dy > 0
                        ? "下"
                        : "上";
            return {
                右: { 当前墙: "右", 反方向墙: "左" },
                左: { 当前墙: "左", 反方向墙: "右" },
                下: { 当前墙: "下", 反方向墙: "上" },
                上: { 当前墙: "上", 反方向墙: "下" },
            }[主要方向];
        }
        function 计划显示格子特效(路径数组, 颜色 = 'FF0000') { // 增加颜色参数，默认为红色
            if (长按移动) {
                return;
            }
            const 可见路径 = 路径数组.filter((节点) => {
                return 节点.x >= 视口偏移X &&
                    节点.x < 视口偏移X + 相机显示边长 &&
                    节点.y >= 视口偏移Y &&
                    节点.y < 视口偏移Y + 相机显示边长
            });
            if (可见路径.length > 0) {
                玩家属性.允许移动 = false;
                相机锁定 = true;
                if (moveQueue.length > 0) {
                    moveQueue = [];
                    isAutoMoving = false;
                }
                待显示格子特效队列.push({
                    路径: 可见路径,
                    颜色: 颜色,
                });
            }
        }
        function 显示格子特效(路径, 颜色 = 'FF0000') {

            const 画布Rect = canvas.getBoundingClientRect();
            路径.forEach((节点, index) => {
                const 屏幕X = (节点.x - 相机目标X) * 单元格大小;
                const 屏幕Y = (节点.y - 相机目标Y) * 单元格大小;

                const 特效 = document.createElement("div");
                特效.className = "攻击路径特效";
                特效.style.cssText = `
    position: absolute;
    left: ${屏幕X + 画布Rect.left}px;
    top: ${屏幕Y + 画布Rect.top}px;
    width: ${单元格大小}px;
    height: ${单元格大小}px;
    background: radial-gradient(circle, 
        ${hexToRgba(颜色, 0)} 0%,
        ${hexToRgba(颜色, 0.3)} 70%,
        transparent 100%
    );
    opacity: 0.7;
    pointer-events: none;
    z-index: 998;
`;

                setTimeout(function () {
                    document.body.appendChild(特效);
                }, index * 100);
                setTimeout(function () {
                    特效.remove();

                }, 200 + index * 100);
            });

        }
        function 尝试进入特殊房间(x, y) {
            const 房间ID = 房间地图[y][x];
            if (房间ID === -1) return;
            const 房间 = 房间列表[房间ID];
            if (房间 && !房间.已连接 && (房间.类型 === "解谜棋盘" || 房间.类型 === "boss房间")) {
                连接特殊房间(房间);
                生成墙壁();
                const 待销毁戒指 = [];
                玩家背包.forEach(item => {
                    if (item instanceof 寻宝戒指 && item.自定义数据.get("生效层数") === 当前层数) {
                        待销毁戒指.push(item.唯一标识);
                    }
                })
                待销毁戒指.forEach(id => {
                    处理销毁物品(id, true);
                })
                移动玩家(0, 0);
                绘制();
            }
        }
        async function 移动玩家(dx, dy, 冷却 = true) {
            if (!玩家属性.允许移动 || 死亡界面已显示) return false;
            if (冷却) {
                const now = Date.now();
                if (now - 上次移动 < 50) return; // 强制50ms移动间隔 just appreciate more , fidget less
                上次移动 = now;
            }
            const 冻结状态 = 玩家状态.some(s => s.类型 === "冻结");
            let 新X = 玩家.x + dx;
            let 新Y = 玩家.y + dy;
            if (新X < 0 || 新X >= 地牢大小 || 新Y < 0 || 新Y >= 地牢大小 || (dy !== 0 && dx !== 0))
                return;
            相机锁定 = false;
            更新视口(); // 强制更新目标
            let 剩余步数 = 玩家属性.移动步数;
            let 实际移动 = 0;
            let 目标X, 目标Y = 0;
            while (剩余步数 > 0 && !冻结状态 && (玩家.x !== 新X || 玩家.y !== 新Y)) {
                目标X = 玩家.x + Math.sign(dx);
                目标Y = 玩家.y + Math.sign(dy);
                let 目标单元格 = 地牢[目标Y][目标X];
                let 当前单元格 = 地牢[玩家.y][玩家.x];
                if (!检查移动可行性(玩家.x, 玩家.y, 目标X, 目标Y)) break;
                if (!目标单元格) {
                    // 更新视口和状态
                    更新视口();
                    绘制();
                    return;
                }
                if (
                    [单元格类型.楼梯下楼, 单元格类型.楼梯上楼].includes(
                        目标单元格.类型
                    )
                ) {
                    if (是否为教程层) {
                        是否为教程层 = false;
                        所有怪物.forEach((m) => {
                            m.绘制血条(true);
                            地牢[m.y][m.x].关联怪物 = null;
                        });
                        所有怪物 = [];
                        document.getElementById("跳过教程按钮").style.display = "none";
                        重置玩家状态();
                        切换楼层(0);
                        return;
                    } else {
                        目标单元格.关联物品.使用();
                    }

                    // 更新视口和状态
                    更新视口();
                    更新界面状态();
                    绘制();
                    return;
                }
                if (
                    目标单元格.关联物品 &&
                    目标单元格.类型 === 单元格类型.物品
                ) {
                    if (尝试收集物品(目标单元格.关联物品)) {
                        目标单元格.类型 = 目标单元格.原始类型;
                        目标单元格.关联物品 = null;
                    }

                }


                玩家.x = 目标X;
                玩家.y = 目标Y;
                实际移动++;
                剩余步数--;
                // 消耗能量检查
                if (当前激活卷轴列表.size > 0 && 实际移动 > 0) {
                    当前激活卷轴列表.forEach(卷轴 => {
                        卷轴.消耗能量();
                    });
                }

                const 目标房间ID = 房间地图[目标Y][目标X];
                if (目标房间ID !== -1 && !已访问房间.has(目标房间ID)) {
                    moveQueue = [];
                    已访问房间.add(目标房间ID);
                    if (是否为教程层) {
                        教程阶段 = 目标房间ID;
                        教程提示已显示 = false;
                        显示教程提示();
                    }
                }
            }
            if (地牢[玩家.y][玩家.x].关联物品 instanceof 折跃门) {
                地牢[玩家.y][玩家.x].关联物品.使用();
            }
            尝试进入特殊房间(玩家.x, 玩家.y);
            if (实际移动 > 0 || 冻结状态) {
                const 方向 =
                    Math.sign(dy) === -1 ? "上" :
                        Math.sign(dy) === 1 ? "下" :
                            Math.sign(dx) === -1 ? "左" :
                                Math.sign(dx) === 1 ? "右" : "";
                移动历史.push(方向);

                // 保持历史长度不超过序列长度
                if (移动历史.length > 调试序列.length) {
                    移动历史.shift();
                }
                [...玩家装备.values()].forEach(item => {
                    if (item instanceof 寻宝戒指) {
                        if (item.自定义数据.get("生效层数") === 当前层数 && !item.自定义数据.get("已生成折跃门")) {
                            item.尝试生成折跃门();
                        }
                    }
                });


                // 检测序列
                if (移动历史.join(",") === 调试序列.join(",")) {
                    const 当前房间ID = 房间地图[玩家.y][玩家.x];
                    if (当前房间ID !== -1) {
                        const 迅捷卷轴测试 = new 迅捷卷轴({});
                        放置物品到房间(迅捷卷轴测试, 房间列表[当前房间ID]);

                        const 秘银锁甲测试 = new 秘银锁甲({});
                        放置物品到房间(秘银锁甲测试, 房间列表[当前房间ID]);

                        const 跃迁卷轴测试 = new 跃迁卷轴({});
                        放置物品到房间(跃迁卷轴测试, 房间列表[当前房间ID]);

                        const 真言卷轴测试 = new 真言卷轴({});
                        放置物品到房间(真言卷轴测试, 房间列表[当前房间ID]);

                        const 湮灭卷轴测试 = new 湮灭卷轴({});
                        放置物品到房间(湮灭卷轴测试, 房间列表[当前房间ID]);

                        const 贪婪卷轴测试 = new 贪婪卷轴({});
                        放置物品到房间(贪婪卷轴测试, 房间列表[当前房间ID]);

                        const 附魔卷轴测试 = new 附魔卷轴({});
                        放置物品到房间(附魔卷轴测试, 房间列表[当前房间ID]);

                        const 耐久祭坛测试 = new 耐久祭坛({});
                        放置物品到房间(耐久祭坛测试, 房间列表[当前房间ID]);

                        const 能量药水测试 = new 能量药水({});
                        放置物品到房间(能量药水测试, 房间列表[当前房间ID]);

                        const 狂暴药水测试 = new 狂暴药水({});
                        放置物品到房间(狂暴药水测试, 房间列表[当前房间ID]);

                        const 神龟药水测试 = new 神龟药水({});
                        放置物品到房间(神龟药水测试, 房间列表[当前房间ID]);

                        const 治疗药水测试 = new 治疗药水({});
                        放置物品到房间(治疗药水测试, 房间列表[当前房间ID]);

                        const 透视药水测试 = new 透视药水({});
                        放置物品到房间(透视药水测试, 房间列表[当前房间ID]);

                        const 隐身药水测试 = new 隐身药水({});
                        放置物品到房间(隐身药水测试, 房间列表[当前房间ID]);

                        const 橡木法杖测试 = new 橡木法杖({});
                        放置物品到房间(橡木法杖测试, 房间列表[当前房间ID]);

                        const 金币手枪测试 = new 金币手枪({});
                        放置物品到房间(金币手枪测试, 房间列表[当前房间ID]);

                        const 寻宝戒指测试 = new 寻宝戒指({});
                        放置物品到房间(寻宝戒指测试, 房间列表[当前房间ID]);

                        const 炸弹测试 = new 炸弹({});
                        放置物品到房间(炸弹测试, 房间列表[当前房间ID]);

                        const 冰盾测试 = new 冰盾({});
                        放置物品到房间(冰盾测试, 房间列表[当前房间ID]);

                        const 重铸台测试 = new 重铸台({});
                        放置物品到房间(重铸台测试, 房间列表[当前房间ID]);

                        const 神秘商人测试 = new 神秘商人({});
                        放置物品到房间(神秘商人测试, 房间列表[当前房间ID]);

                        const 宠物测试 = new 水母({});
                        放置物品到房间(宠物测试, 房间列表[当前房间ID]);
                        if (!彩蛋3触发) {
                            显示通知("你被加强了，快上！", "信息", true)
                            彩蛋3触发 = true;
                        }
                    }
                    移动历史 = []; // 重置以防重复触发
                }
                // 更新视口和状态
                更新视口();
                更新武器冷却();
                处理怪物回合();
                更新物体指示器();
                const 能量条 = document.querySelector(".power-bar");
                const 当前能量 = parseFloat(能量条.style.width) || 100;
                能量条.style.width = `${Math.min(100, 当前能量 + 1)}%`;
                玩家状态.forEach((item) => {
                    item.更新状态();
                });
                所有炸弹.forEach((item) => {
                    if (item instanceof 炸弹) item.更新倒计时();
                });
                [...玩家装备.values()].forEach(装备 => {
                    if (装备 instanceof 宠物) {
                        装备.恢复生命值();
                    }
                });
            }
            if (isAutoMoving && (玩家.x !== 新X || 玩家.y !== 新Y)) {
                moveQueue = []; // 移动被阻挡则停止
                isAutoMoving = false;
            }

            更新界面状态();
            绘制();
        }
        function 卷轴扣除能量(能量) {
            const 能量条 = document.querySelector(".power-bar");
            let 当前能量 = Math.max(
                Math.min(parseFloat(能量条.style.width), 100),
                0
            );
            当前能量 -= 能量;
            if (当前能量 <= 0) {
                if (当前激活卷轴列表.size > 0) {
                    当前激活卷轴列表.forEach(卷轴 => {
                        卷轴.卸下();
                        当前激活卷轴列表.delete(卷轴);
                    });
                    恢复卷轴模式();
                    当前能量 = 0;
                }
                更新装备显示();
                显示通知("能量不足，已自动取消卷轴效果", "信息");
                return false;
            }
            能量条.style.width = `${Math.max(0, 当前能量)}%`;
            触发HUD显示();
            return true;
        }
        function 检查移动可行性(fromX, fromY, toX, toY) {
            if (toX < 0 || toX >= 地牢大小 || toY < 0 || toY >= 地牢大小)
                return false;

            const dx = toX - fromX;
            const dy = toY - fromY;
            const 方向 = {
                dx: dx !== 0 ? (dx > 0 ? 1 : -1) : 0,
                dy: dy !== 0 ? (dy > 0 ? 1 : -1) : 0,
            };
            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                // 多格移动需要直线路径
                if (dx !== 0 && dy !== 0) return false; // 禁止斜向多格移动
                return 快速直线检查(fromX, fromY, toX, toY, Math.max(Math.abs(dx), Math.abs(dy)));
            }
            // 检查路径上的每个单元格
            let currentX = fromX;
            let currentY = fromY;

            while (currentX !== toX || currentY !== toY) {
                currentX += 方向.dx;
                currentY += 方向.dy;

                const 当前单元格 = 地牢[currentY][currentX];
                const 前一单元格 =
                    地牢[currentY - 方向.dy][currentX - 方向.dx];

                // 检查物理障碍
                const 垂直移动 = 方向.dy !== 0;
                const 墙方向 = 垂直移动
                    ? 方向.dy > 0
                        ? "下"
                        : "上"
                    : 方向.dx > 0
                        ? "右"
                        : "左";

                if (垂直移动) {
                    if (
                        前一单元格.墙壁[方向.dy > 0 ? "下" : "上"] ||
                        当前单元格.墙壁[方向.dy > 0 ? "上" : "下"]
                    ) {
                        return false;
                    }
                } else {
                    if (
                        前一单元格.墙壁[方向.dx > 0 ? "右" : "左"] ||
                        当前单元格.墙壁[方向.dx > 0 ? "左" : "右"]
                    ) {
                        return false;
                    }
                }

                // 检查单元格类型
                if (
                    [单元格类型.墙壁, 单元格类型.上锁的门].includes(
                        当前单元格.类型
                    )
                ) {
                    return false;
                }
            }
            return true;
        }
        function 伤害玩家(原始攻击力, 伤害来源 = null) {
            let 最终攻击力 = 原始攻击力;
            if (伤害来源 instanceof 怪物) {
                伤害来源_ = 伤害来源.类型;
            } else {
                伤害来源_ = 伤害来源;
            }
            [...玩家装备.values()].forEach((装备) => {
                if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                    最终攻击力 = 装备.当玩家被攻击(最终攻击力, 伤害来源);
                }
                if (
                    装备 instanceof 防御装备类 &&
                    装备.自定义数据.get("耐久") > 0
                ) {
                    最终攻击力 = 装备.当被攻击(最终攻击力, 伤害来源);
                }
            });
            最终攻击力 = Math.max(0, 最终攻击力 - 玩家属性.防御加成);
            更新装备显示();
            触发扣血特效();
            // 扣减玩家生命值
            const 生命条 = document.querySelector(".health-bar");
            const 当前宽度 = parseFloat(生命条.style.width) || 100;
            const 新宽度 = Math.max(0, 当前宽度 - 最终攻击力);
            生命条.style.width = `${新宽度}%`;
            添加日志(
                `受到了 ${伤害来源_} 的伤害！损失了 ${最终攻击力} 点血量！`,
                `警告`
            );
            // 显示通知(`受到了 ${this.图标} 的攻击！造成了 ${this.最终攻击力} 点伤害！`,`警告`);
            // console.log(新宽度);
            触发HUD显示();

            if (新宽度 <= 0) {
                玩家死亡();
            }
        }
        function 更新武器冷却() {
            玩家背包.forEach((item) => {
                if (
                    item.类型 === "武器" &&
                    item.自定义数据.get("冷却剩余") > 0
                ) {
                    item.自定义数据.set(
                        "冷却剩余",
                        item.自定义数据.get("冷却剩余") - 1
                    );
                }
            });
            更新装备显示();
        }

        function 处理怪物回合() {
            // 激活当前房间怪物
            const 当前房间ID = 房间地图[玩家.y][玩家.x];
            跟踪玩家怪物数 = 0;
            所有怪物.forEach((m) => {
                if (房间地图[m.y][m.x] === 当前房间ID) {
                    m.状态 = 怪物状态.活跃;
                }
            });

            // 处理每个活跃怪物
            所有怪物.forEach((m) => {
                if (m.状态 === 怪物状态.活跃) {

                    let { x, y } = m.选择目标();
                    m.目标路径 = m.计算路径(x, y);
                    if (m.目标路径) {
                        m.通向目标路径 = m.计算目标路径(m.目标.x, m.目标.y);
                        if (m.通向目标路径) {
                        if (m.目标路径.length > 0 && !(m.通向目标路径.length > 1 && 玩家状态.some(s => s.类型 === "隐身") && 怪物状态表.get(m)?.类型 !== "魅惑")) {
                            m.追击玩家中 = true;
                            m.尝试移动(); //可能有bug：当玩家远离怪物时，药水效果不会正常被处理。
                           
                        } else {
                        m.追击玩家中 = false;
                        }
                    } else {
                        m.追击玩家中 = false;
                        }
                    m.通向目标路径 = m.计算目标路径(m.目标.x, m.目标.y);
                    if (m.通向目标路径) {
                    if (!(m.通向目标路径.length > 1 && 玩家状态.some(s => s.类型 === "隐身") && 怪物状态表.get(m)?.类型 !== "魅惑")) {
                        m.尝试攻击();
                    } else {
                        m.绘制血条();
                    }
                    }
                    const 我的状态 = 怪物状态表.get(m);
                    我的状态?.更新状态();
                    if (m instanceof 大魔法师) {
                        m.更新技能冷却();
                    }
                } else {
                        m.追击玩家中 = false;
                        }
                }
            });
            const 提示元素 =
                怪物追踪提示.容器元素.querySelector(".hud-label");
            if (跟踪玩家怪物数 > 3) {
                提示元素.classList.add("怪物数量警告");
            } else {
                提示元素.classList.remove("怪物数量警告");
            }
            怪物追踪提示.更新({
                内容: `追踪怪物：${跟踪玩家怪物数}`,
            }); //图标: 跟踪玩家怪物数 > 0 ? "🔥" : "👹"  删去，太唐了
        }
        function 切换日志显示() {
            日志面板可见 = !日志面板可见;
            const 按钮 = document.querySelector("#设置菜单 button:nth-child(1)"); // 第一个按钮
            if (日志面板可见) {
                document.querySelector(".日志面板").classList.add("可见");
                按钮.textContent = "关闭日志界面"; // 更新按钮文本
            } else {
                document.querySelector(".日志面板").classList.remove("可见");
                按钮.textContent = "打开日志界面"; // 更新按钮文本
            }
        }
        function 切换背包显示() {
            const 弹窗 = document.querySelector(".背包弹窗");
            const 当前状态 = 弹窗.classList.contains("显示中");
            // 关闭背包时清除所有选中状态
            if (当前状态) {
                document.querySelectorAll(".物品条目").forEach((el) => {
                    el.classList.remove("active");
                    if (el.__物品实例) {
                        el.__物品实例.isActive = false;
                    }
                });
            }
            // 更新全局状态
            界面可见性.背包 = !当前状态;

            弹窗.classList.toggle("显示中", !当前状态);
        }
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && 界面可见性.背包) {
                切换背包显示();
            }
        });
        document.addEventListener("click", (e) => {
            const 弹窗 = document.querySelector(".背包弹窗");
            const 背包区域 = document.querySelector(".背包弹窗 .物品容器");

            if (
                界面可见性.背包 &&
                !e.target.closest(".背包弹窗") &&
                !e.target.closest("#背包按钮")
            ) {
                切换背包显示();
            } else if (教程提示已显示 && !e.target.closest("#教程提示窗口")) {
                关闭教程提示();
            } else if (document.getElementById("设置菜单").classList.contains("显示") &&
                !e.target.closest("#设置按钮")) {
                切换设置菜单()
            }
            if (!e.target.closest(".物品条目") && 界面可见性.背包) {
                document.querySelectorAll(".物品条目").forEach((el) => {
                    el.classList.remove("active");
                    if (el.__物品实例) {
                        el.__物品实例.isActive = false;
                        //console.log(el.__物品实例.类型);
                    }
                });
            }
        });

        // 键盘事件监听
        document.addEventListener("keydown", (e) => {
            const keyMap = {
                'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                'ArrowDown': 'down', 's': 'down', 'S': 'down',
                'ArrowRight': 'right', 'd': 'right', 'D': 'right'
            };
            if (keyMap[e.key] && 玩家属性.允许移动) {
                const direction = keyMap[e.key];

                // 不重复触发
                if (移动状态[direction]) return;

                移动状态[direction] = true;
                const dx = 移动状态.left ? -玩家属性.移动步数 : 移动状态.right ? 玩家属性.移动步数 : 0;
                const dy = 移动状态.up ? -玩家属性.移动步数 : 移动状态.down ? 玩家属性.移动步数 : 0;

                if (dx !== 0 || dy !== 0) {
                    移动玩家(dx, dy);
                }
                // 延迟调用
                clearTimeout(开始移动定时器);
                开始移动定时器 = setTimeout(开始移动, 250);

                e.preventDefault(); // 阻止默认行为
            } else if (功能键映射[e.key]) {
                功能键映射[e.key]();
            } else if (e.key === "Escape" && 界面可见性.背包) {
                切换背包显示();
            }
        });

        document.addEventListener("keyup", (e) => {
            const keyMap = {
                'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                'ArrowDown': 'down', 's': 'down', 'S': 'down',
                'ArrowRight': 'right', 'd': 'right', 'D': 'right'
            };
            if (keyMap[e.key]) {
                const direction = keyMap[e.key];
                移动状态[direction] = false; // 清除移动状态
                clearTimeout(开始移动定时器); // 重要！清除 开始移动 定时器
                停止移动();
                e.preventDefault();
            }
        });
        function 切换中文模式() {
            图标映射 = 中文对照图标映射;
            楼梯图标 = {
                下楼: 图标映射.下楼楼梯,
                上楼: 图标映射.上楼楼梯,
            };
            document
                .querySelector("#背包按钮").innerHTML = `${图标映射.背包按钮}`;
            document
                .querySelector("#互动按钮").innerHTML = `${图标映射.互动按钮}`;
            document
                .querySelector("#卷轴按钮").innerHTML = `${图标映射.卷轴按钮}`;
            处理重生(false);
            切换HUD模式();
            return;
        }
        function 使用装备槽物品(槽位编号) {
            const 物品实例 = [...玩家装备.values()].find(item => item.装备槽位 === 槽位编号);

            if (!物品实例) return;

            // 无需考虑堆叠
            if (物品实例.类型 === "武器") {
                if (
                    物品实例.堆叠数量 > 0 &&
                    物品实例.自定义数据.get("冷却剩余") == 0
                ) {
                    const { 怪物, 路径 } = 获取周围怪物(
                        物品实例.自定义数据.get("攻击目标数"),
                        物品实例.自定义数据.get("攻击范围")
                    );
                    if (怪物 !== null) {

                        if (物品实例.使用(怪物)) {
                            if (!(物品实例 instanceof 金币手枪)) 路径.forEach((攻击路径) => 计划显示格子特效(攻击路径));
                            [...玩家装备.values()].forEach(装备 => {
                                if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                                    装备.当玩家攻击(怪物);
                                }
                            });
                            更新装备显示();
                            绘制();
                            return true;
                        }
                    } else {
                        显示通知("附近没有目标", "错误");
                        return false;
                    }
                } else {
                    显示通知("武器还未准备好", "错误");
                    return false;
                }
            }
            if (物品实例.类型 === "卷轴") {
                显示通知("请使用卷轴键使用该物品", "错误");
                return false;
            }
            if (物品实例.使用()) {
                if (物品实例.堆叠数量 <= 0) {
                    if (物品实例.装备槽位)
                        玩家装备.delete(物品实例.装备槽位);
                    玩家背包.delete(物品实例.唯一标识);
                }
                更新背包显示();
                更新装备显示();
                显示通知("已使用物品", "成功");
                return true;

            } else {
                显示通知("无法使用该物品", "错误");
            }
            return false;
        }


        function 卸下装备槽物品(槽位编号) {
            const 当前物品 = [...玩家装备.values()].find(item => item.装备槽位 === 槽位编号);

            if (当前物品) {
                当前物品.取消装备();
                显示通知("已卸下", "成功");
                更新装备显示();
                更新背包显示();


                const 槽位 = document.getElementById(`装备槽${槽位编号}`);
                槽位.style.transform = "scale(0.95)";
                setTimeout(() => (槽位.style.transform = "scale(1)"), 200);
            }
        }
        function 处理销毁物品(唯一标识, 直接清理 = false) {
            const 目标物品 = 玩家背包.get(唯一标识);
            if (!直接清理) {
                if (!confirm("确定要销毁这个物品吗？")) return false;
            }
            if (!目标物品) return false;

            const 物品元素 = 目标物品.显示元素;
            document.getElementById("浮动提示框").style.display = "none";
            if (!直接清理) {

                const 烟花容器 = document.createElement("div");
                烟花容器.style.position = "fixed";
                烟花容器.style.left = `${物品元素.getBoundingClientRect().left + 40
                    }px`;
                烟花容器.style.top = `${物品元素.getBoundingClientRect().top + 40
                    }px`;
                烟花容器.style.zIndex = 99999;
                document.body.appendChild(烟花容器);


                for (let i = 0; i < 12; i++) {
                    const 粒子 = document.createElement("div");
                    粒子.className = "烟花粒子";
                    粒子.innerHTML = ["✨", "❄️", "⚡", "⭐", "💥", "🔥"][
                        i % 6
                    ];
                    粒子.style.color =
                        目标物品.颜色表[目标物品.颜色索引] || "#fff";
                    粒子.style.setProperty(
                        "--tx",
                        Math.cos((i * 30 * Math.PI) / 180)
                    );
                    粒子.style.setProperty(
                        "--ty",
                        Math.sin((i * 30 * Math.PI) / 180)
                    );
                    烟花容器.appendChild(粒子);
                }
                // 同步执行销毁
                setTimeout(() => {
                    烟花容器.remove();
                    if (目标物品.安全销毁()) {
                        [...玩家背包.values()].forEach(item => {
                            if (item instanceof 宠物) {
                                for (let 槽位 in item.自定义数据.get("装备")) {
                                    if (item.自定义数据.get("装备")[槽位] === 目标物品) {
                                        item.自定义数据.get("装备")[槽位] = null;
                                        item.更新宠物管理窗口();
                                    }
                                }
                            }
                        });
                        if (目标物品.装备槽位) 玩家装备.delete(物品实例.装备槽位);
                        玩家背包.delete(唯一标识);
                        更新背包显示();
                        更新装备显示();
                    }
                }, 800);
            } else {
                if (目标物品.安全销毁()) {
                    [...玩家背包.values()].forEach(item => {
                        if (item instanceof 宠物) {
                            for (let 槽位 in item.自定义数据.get("装备")) {
                                if (item.自定义数据.get("装备")[槽位] === 目标物品) {
                                    item.自定义数据.get("装备")[槽位] = null;
                                    item.更新宠物管理窗口();
                                }
                            }
                        }
                    });
                    if (目标物品.装备槽位) 玩家装备.delete(物品实例.装备槽位);
                    玩家背包.delete(唯一标识);
                    更新背包显示();
                    更新装备显示();
                }
            }
            // 立即隐藏原物品
            物品元素.style.opacity = "0";
            物品元素.style.transition = "opacity 0.2s";
            return true;
        }
        function 尝试收集物品(新物品, 直接收集 = false) {
            if (!新物品.能否拾起) return false;

            // 查找可堆叠物品
            const 现有物品 = [...玩家背包.values()].find((item) =>
                item.可堆叠于(新物品)
            );

            // 处理可堆叠情况
            if (现有物品) {
                if (现有物品.堆叠数量 < 最大堆叠数) {
                    if (现有物品.堆叠数量 + 新物品.堆叠数量 >= 最大堆叠数) {
                        新物品.堆叠数量 -= 最大堆叠数 - 现有物品.堆叠数量;
                        现有物品.堆叠数量 = 最大堆叠数;
                        return 尝试收集物品(新物品, 直接收集);
                    } else {
                        现有物品.堆叠数量 += 新物品.堆叠数量;
                        更新背包显示();
                        更新装备显示();
                        const 特效元素 = document.createElement("div");
                        特效元素.className = "收集特效";
                        特效元素.style.cssText = `
   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
 `;
                        if (新物品.类型 === "金币") {
                            特效元素.style.cssText = `
   --辉光颜色: ${颜色表[2]};
   color: ${颜色表[2]};
 `;
                        }
                        特效元素.innerHTML = 新物品.显示图标;
                        if (!直接收集) {
                            document.body.appendChild(特效元素);
                        }
                        setTimeout(() => 特效元素.remove(), 1100);
                        return true;
                    }
                }
                // 当前堆叠已满则创建新堆叠
            }

            // 处理新物品，需要考虑该函数会被递归调用，故需要刷新（刷新准没错（（（
            if ([...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0) >= 最大背包容量) {
                更新背包显示();
                更新装备显示();
                显示通知("背包已满！", "错误");
                return false;
            }
            if (新物品.堆叠数量 > 0) {
                玩家背包.set(新物品.唯一标识, 新物品);
                添加日志(`已收集物品 ${新物品.获取名称()}`, "信息");
            }
            更新背包显示();
            更新装备显示();
            const 特效元素 = document.createElement("div");
            特效元素.className = "收集特效";
            特效元素.style.cssText = `
   --辉光颜色: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
   color: ${新物品.颜色表[新物品.颜色索引] || "#FFF"};
 `;
            if (新物品.类型 === "金币") {
                特效元素.style.cssText = `
   --辉光颜色: ${颜色表[2]};
   color: ${颜色表[2]};
 `;
            }
            特效元素.innerHTML = 新物品.显示图标;
            if (!直接收集) {
                document.body.appendChild(特效元素);
            }
            setTimeout(() => 特效元素.remove(), 1100);
            return true;
        }

        function 使用背包物品(物品标识) {
            const 物品实例 = 玩家背包.get(物品标识);
            if (!物品实例) return false;
            if (物品实例.类型 === "武器") {
                if (
                    物品实例.堆叠数量 > 0 &&
                    物品实例.自定义数据.get("冷却剩余") == 0
                ) {
                    const { 怪物, 路径 } = 获取周围怪物(
                        物品实例.自定义数据.get("攻击目标数"),
                        物品实例.自定义数据.get("攻击范围")
                    );
                    if (怪物 !== null) {
                        if (物品实例.使用(怪物)) {
                            if (!(物品实例 instanceof 金币手枪)) 路径.forEach((攻击路径) => 计划显示格子特效(攻击路径));
                            [...玩家装备.values()].forEach(装备 => {
                                if (装备 instanceof 宠物 && !装备.自定义数据.get("休眠中")) {
                                    装备.当玩家攻击(怪物);
                                }
                            });
                            更新装备显示();
                            绘制();
                            互动 = true;
                        }
                    } else {
                        显示通知("附近没有目标", "错误");
                        return false;
                    }
                } else {
                    显示通知("武器还未准备好", "错误");
                    return false;
                }
            }
            if (物品实例.类型 === "卷轴") {
                显示通知("请在装备栏中使用该物品", "错误");
                return false;
            }
            if (物品实例.使用()) {
                document.getElementById("浮动提示框").style.display =
                    "none";
                if (物品实例.堆叠数量 <= 0) {
                    if (物品实例.装备槽位)
                        玩家装备.delete(物品实例.装备槽位);
                    玩家背包.delete(物品标识);
                    物品实例.isActive = false;
                }
                更新背包显示();
                更新装备显示();
                显示通知("已使用物品", "成功");
                return true;
            } else {
                显示通知("无法使用该物品", "错误");
            }
            return false;
        }

        function 更新背包显示() {
            const 容器 = document.getElementById("背包物品栏");
            容器.innerHTML = "";

            玩家背包.forEach((item) => {
                if (!item.是否隐藏) {
                    const 元素 = item.生成显示元素();
                    if (item.isActive) {
                        元素.classList.add("active");
                    }
                    容器.appendChild(元素);
                }
            });

            document.getElementById("当前容量").textContent = [...玩家背包.values()].reduce((sum, i) => sum + (i.是否隐藏 ? 0 : 1), 0);
        }
        function 初始化装备系统() {
            document.querySelectorAll(".装备槽").forEach((槽位, index) => {
                槽位.addEventListener("click", (e) => {
                    const 槽位编号 = index + 1;
                    const 当前物品 = [...玩家装备.values()].find(
                        (item) => item.装备槽位 === 槽位编号
                    );


                    if (当前物品) {
                        当前物品.取消装备();
                        显示通知("已卸下", "成功");
                        更新装备显示();
                        更新背包显示();


                        槽位.style.transform = "scale(0.95)";
                        setTimeout(
                            () => (槽位.style.transform = "scale(1)"),
                            200
                        );
                    }
                });
            });
        }
        function 初始化装备系统() {
            document.querySelectorAll(".装备槽").forEach((槽位, index) => {

                槽位.addEventListener("click", (e) => {
                    const 槽位编号 = index + 1;
                    const 当前物品 = [...玩家装备.values()].find(
                        (item) => item.装备槽位 === 槽位编号
                    );

                    if (当前物品) {
                        if (卷轴模式激活 && 当前物品 instanceof 卷轴类) {
                            //AI Says...
                            当前激活卷轴列表.add(当前物品);
                            当前物品.使用();
                            恢复卷轴模式();
                            document
                                .querySelectorAll(".装备槽")
                                .forEach((槽位) => {
                                    const 物品 =
                                        槽位.querySelector(".物品条目");
                                    if (物品?.__物品实例 instanceof 卷轴类) {
                                        if (当前激活卷轴列表.has(物品?.__物品实例)) {
                                            物品.classList.add("卷轴闪烁");
                                        }
                                    }
                                });
                            显示通知("已启用卷轴", "成功");
                            return;
                        }
                        if (
                            当前物品 instanceof 卷轴类 &&
                            当前激活卷轴列表.has(当前物品) &&
                            !卷轴模式激活
                        ) {
                            document
                                .querySelectorAll(".装备槽")
                                .forEach((槽位) => {
                                    const 物品 =
                                        槽位.querySelector(".物品条目");
                                    if (物品?.__物品实例 instanceof 卷轴类) {
                                        if (物品?.__物品实例 === 当前物品) {
                                            物品.classList.remove("卷轴闪烁");
                                            物品?.__物品实例.卸下();
                                        }
                                    }
                                });
                            当前激活卷轴列表.delete(当前物品);
                            显示通知("已禁用卷轴", "成功");
                            return;
                        }
                        使用装备槽物品(槽位编号);
                    }

                });


                if ('ontouchstart' in window) {
                    let 长按计时器;
                    槽位.addEventListener("touchstart", (e) => {
                        //e.preventDefault()
                        长按计时器 = setTimeout(() => {
                            卸下装备槽物品(index + 1);
                        }, 500); // 长按时长 500ms
                    });
                    槽位.addEventListener("touchend", () => {
                        clearTimeout(长按计时器);
                    });
                    槽位.addEventListener("touchcancel", () => {
                        clearTimeout(长按计时器);
                    });
                } else { // 鼠标设备
                    槽位.addEventListener("contextmenu", (e) => {
                        e.preventDefault();
                        卸下装备槽物品(index + 1);
                    });
                }
            });
        }
        function 更新装备显示() {
            for (let i = 1; i <= 4; i++) {
                const 槽位 = document.getElementById(`装备槽${i}`);

                const 装备物品 = [...玩家装备.values()].find(
                    (item) => item.装备槽位 === i
                );

                if (装备物品) {
                    const 克隆元素 = 装备物品
                        .生成显示元素("装备")
                        .cloneNode(true);
                    克隆元素.style.transform =
                        "scale(0.75) translateY(-3px)";
                    克隆元素.style.margin = "-5px 0";
                    克隆元素.classList.remove("active");
                    克隆元素.classList.remove("hover");
                    克隆元素.__物品实例 = 装备物品;
                    克隆元素.removeAttribute("data-quality");


                    ["销毁按钮", "使用按钮", "装备按钮"].forEach(
                        (className) => {
                            克隆元素.querySelector(
                                `.${className}`
                            )?.remove();
                        }
                    );
                    if (装备物品.类型 === "武器" && (装备物品.自定义数据.get("冷却剩余") > 0 || 槽位.querySelector(`.冷却遮罩`))) {
                        if (槽位.innerHTML === "") {
                            const 耐久标签 = document.createElement("div");
                            耐久标签.className = "耐久标签";
                            耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
                                "耐久"
                            )}`;
                            克隆元素.appendChild(耐久标签);
                            槽位.appendChild(克隆元素);
                        }//考虑武器冷却过程中被装备的情况
                        let 遮罩 = 槽位.querySelector(`.冷却遮罩`);
                        if (!遮罩) {
                            遮罩 = document.createElement("div");
                        }
                        遮罩.className = "冷却遮罩";
                        const 进度 = 1 - (装备物品.自定义数据.get("冷却剩余") /
                            装备物品.自定义数据.get("冷却回合"));
                        遮罩.style.clipPath = `inset(0 0 ${进度 * 100}% 0)`;
                        if (!槽位.querySelector(`.冷却遮罩`)) {
                            槽位.appendChild(遮罩);
                        }
                        if (进度 === 1) {
                            setTimeout(() => 遮罩.remove(), 220);
                        }
                        continue;
                    }
                    if (装备物品.类型 === "防御装备" || (装备物品.类型 === "武器" && !槽位.querySelector(`.冷却遮罩`))) {
                        const 耐久标签 = document.createElement("div");
                        耐久标签.className = "耐久标签";
                        耐久标签.textContent = `耐久:${装备物品.自定义数据.get(
                            "耐久"
                        )}`;
                        克隆元素.appendChild(耐久标签);
                    }
                    if (装备物品.类型 === "卷轴" && 卷轴模式激活) {
                        克隆元素.classList.add("卷轴闪烁");
                    }
                    if (装备物品 instanceof 宠物) {
                        const 血量标签 = document.createElement("div");
                        血量标签.className = "宠物血量标签";
                        血量标签.textContent = `HP: ${装备物品.自定义数据.get("当前生命值")} / ${装备物品.自定义数据.get("最大生命值")}`;
                        克隆元素.appendChild(血量标签);
                    }
                    当前激活卷轴列表.forEach(卷轴 => {
                        if (克隆元素.__物品实例 === 卷轴) {
                            克隆元素.classList.add('卷轴闪烁');
                        }
                    });
                    槽位.innerHTML = "";
                    槽位.appendChild(克隆元素);
                } else {
                    槽位.innerHTML = "";
                }
            }
        }
        function 怪物放置物品(物品, x, y, 能否拾起 = false) {
            let 目标X = x;
            let 目标Y = y;
            let 可用 = false;
            if (位置是否可用(目标X, 目标Y, false)) {
                可用 = true;
            } else {
                const 主要方向 = [
                    [0, -1],
                    [0, 1],
                    [-1, 0],
                    [1, 0],
                ];

                const 次要方向 = [
                    [1, -1],
                    [1, 1],
                    [-1, 1],
                    [-1, -1],
                ];

                for (const [dx, dy] of 主要方向) {
                    const 新X = x + dx;
                    const 新Y = y + dy;

                    if (
                        新X < 0 ||
                        新X >= 地牢大小 ||
                        新Y < 0 ||
                        新Y >= 地牢大小
                    )
                        continue;
                    if (位置是否可用(新X, 新Y)) {
                        目标X = 新X;
                        目标Y = 新Y;
                        可用 = true;
                        break;
                    }
                }

                if (!可用) {
                    for (const [dx, dy] of 次要方向) {
                        const 新X = x + dx;
                        const 新Y = y + dy;

                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            continue;
                        if (位置是否可用(新X, 新Y)) {
                            目标X = 新X;
                            目标Y = 新Y;
                            可用 = true;
                            break;
                        }
                    }
                }
            }
            if (!可用) {
                添加日志("怪物放置物品：没有可放置的位置");
                return { x: null, y: null, 新物品: null };
            }
            let 放置物品 = 物品;
            放置物品.堆叠数量 = 1;
            放置物品.能否拾起 = 能否拾起;
            放置怪物到单元格(放置物品, 目标X, 目标Y);
            return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
        }

        function 玩家放置物品(物品, 能否拾起 = false) {
            let 目标X = 玩家.x;
            let 目标Y = 玩家.y;
            let 可用 = false;
            if (位置是否可用(目标X, 目标Y, false)) {
                可用 = true;
            } else {
                const 主要方向 = [
                    [0, -1],
                    [0, 1],
                    [-1, 0],
                    [1, 0],
                ];

                const 次要方向 = [
                    [1, -1],
                    [1, 1],
                    [-1, 1],
                    [-1, -1],
                ];

                for (const [dx, dy] of 主要方向) {
                    const 新X = 玩家.x + dx;
                    const 新Y = 玩家.y + dy;

                    if (
                        新X < 0 ||
                        新X >= 地牢大小 ||
                        新Y < 0 ||
                        新Y >= 地牢大小
                    )
                        continue;
                    if (位置是否可用(新X, 新Y)) {
                        目标X = 新X;
                        目标Y = 新Y;
                        可用 = true;
                        break;
                    }
                }

                if (!可用) {
                    for (const [dx, dy] of 次要方向) {
                        const 新X = 玩家.x + dx;
                        const 新Y = 玩家.y + dy;

                        if (
                            新X < 0 ||
                            新X >= 地牢大小 ||
                            新Y < 0 ||
                            新Y >= 地牢大小
                        )
                            continue;
                        if (位置是否可用(新X, 新Y)) {
                            目标X = 新X;
                            目标Y = 新Y;
                            可用 = true;
                            break;
                        }
                    }
                }
            }
            if (!可用) {
                添加日志("玩家放置物品：没有可放置的位置");
                return { x: null, y: null, 新物品: null };
            }
            let 放置物品 = 克隆物品(物品);
            放置物品.堆叠数量 = 1;
            放置物品.能否拾起 = 能否拾起;
            放置物品到单元格(放置物品, 目标X, 目标Y);
            return { x: 目标X, y: 目标Y, 新物品: 放置物品 };
        }
        function 放置怪物到单元格(怪物, x, y) {
            地牢[y][x].原始类型 = 地牢[y][x].类型;
            地牢[y][x].类型 = 单元格类型.怪物;
            地牢[y][x].关联怪物 = 怪物;
            怪物.x = x
            怪物.y = y;
            怪物.房间ID = 房间地图[y][x];
            所有怪物.push(怪物);
            绘制();
            return;
        }
        function 生成奖励(房间) {
            const 奖励数量 = 3;
            const 奖励物品 = [];
            const 层数 = 当前层数;
            const 品质权重 = [
                { 品质: 3, 权重: 40 + 层数 * 5 },
                { 品质: 4, 权重: 35 + 层数 * 3 },
                { 品质: 5, 权重: 25 + 层数 * 2 },
            ].filter((w) => w.权重 > 0);

            let 已选中 = false;
            let 尝试次数 = 0;
            for (let i = 0; i < 奖励数量; i++) {
                while (!已选中 && 尝试次数 < 100) {
                    const 选中品质 = 加权随机选择(品质权重);
                    const 候选物品 = Object.values(物品池).flat().filter((item) => item.品质 == 选中品质.品质);
                    if (候选物品.length > 0) {
                        const 模板 = 候选物品[Math.floor(Math.random() * 候选物品.length)];
                        const 物品实例 = new 模板.类({
                            数量: 1,
                            强化: Math.random() < Math.min(0.95, 层数 * 0.2),
                            已解锁: true,
                            品质: 选中品质.品质
                        });
                        if (!奖励物品.some((item) => item.名称 === 物品实例.名称) && 物品实例.是否正常物品) {
                            奖励物品.push(物品实例);
                            已选中 = true;
                        }
                    }
                    尝试次数++;
                }
                已选中 = false;
                尝试次数 = 0;
            }


            奖励物品.forEach(物品 => {
                放置物品到房间(物品, 房间, 单元格类型.物品, false, true);
            });
        }
        function 解谜成功(房间) {

            for (let y = 房间.y; y < 房间.y + 房间.h; y++) {
                for (let x = 房间.x; x < 房间.x + 房间.w; x++) {
                    if (地牢[y][x].类型 === 单元格类型.物品 && 地牢[y][x].关联物品 instanceof 棋子) {
                        地牢[y][x].类型 = 地牢[y][x].原始类型;
                        地牢[y][x].关联物品 = null;
                    }
                }
            }
            生成奖励(房间);
            显示通知("解谜成功！获得了丰厚奖励！", "成功");
            绘制();
        }
        function 检查解谜是否成功(棋子数量) {
            const 当前房间ID = 房间地图[玩家.y][玩家.x];
            if (当前房间ID === -1) return false;

            const 当前房间 = 房间列表[当前房间ID];
            if (当前房间.类型 !== "解谜棋盘") return false;
            let 棋子现存数量 = 0;
            const 棋盘宽度 = 当前房间.w;
            const 棋盘高度 = 当前房间.h;
            const 棋盘 = Array(棋盘高度).fill(null).map(() => Array(棋盘宽度).fill(0));
            const 棋子列表 = [];


            for (let y = 当前房间.y; y < 当前房间.y + 当前房间.h; y++) {
                for (let x = 当前房间.x; x < 当前房间.x + 当前房间.w; x++) {
                    if (地牢[y][x].类型 === 单元格类型.物品 && 地牢[y][x].关联物品 instanceof 棋子) {
                        棋盘[y - 当前房间.y][x - 当前房间.x] = 地牢[y][x].关联物品;
                        棋子列表.push({ x: x - 当前房间.x, y: y - 当前房间.y, 棋子: 地牢[y][x].关联物品 });
                        棋子现存数量++;
                    }
                }
            }
            if (棋子现存数量 >= 棋子数量) {

                for (const 棋子信息 of 棋子列表) {
                    const 攻击位置 = 棋子信息.棋子.可攻击位置(棋子信息.x, 棋子信息.y, 棋盘);
                    for (const 其他棋子信息 of 棋子列表) {
                        if (棋子信息 === 其他棋子信息) continue;
                        if (攻击位置.some(pos => pos.x === 其他棋子信息.x && pos.y === 其他棋子信息.y)) {
                            return false;
                        }
                    }
                }


                解谜成功(当前房间);
                return true;
            }
            return false;
        }
        function 生成解谜棋盘(房间) {
            const 棋盘大小 = Math.min(房间.w, 房间.h);
            const 棋盘 = Array(棋盘大小).fill(null).map(() => Array(棋盘大小).fill(0));
            const 棋子种类 = {
                "A": [国际象棋车, 国际象棋象],
                "B": [国际象棋马, 中国象棋炮],
            };


            const 首个棋子层级 = Math.random() < 0.6 ? "A" : "B";
            const 首个棋子类 = 棋子种类[首个棋子层级][Math.floor(Math.random() * 棋子种类[首个棋子层级].length)];
            棋盘[0][0] = new 首个棋子类({});

            for (let y = 0; y < 棋盘大小; y++) {
                for (let x = 0; x < 棋盘大小; x++) {
                    if (x === 0 && y === 0) continue;
                    if (棋盘[y][x]) continue;

                    let 当前层级 = "A";
                    while (当前层级) {
                        const 可放置棋子 = [];
                        for (const 棋子类 of 棋子种类[当前层级]) {
                            if (可以放置(x, y, 棋子类, 棋盘)) {
                                可放置棋子.push(棋子类);
                            }
                        }

                        if (可放置棋子.length > 0) {

                            const 权重 = 可放置棋子.map(棋子类 => {
                                const 威胁数 = 计算新增威胁格子数(x, y, 棋子类, 棋盘);
                                return 1 / (威胁数 + 1);
                            });


                            const 最小权重 = Math.min(...权重);


                            if (当前层级 === "A") {
                                可放置棋子.push("下一层");
                                权重.push(最小权重);
                            }


                            const 总权重 = 权重.reduce((sum, w) => sum + w, 0);
                            let 随机数 = Math.random() * 总权重;
                            let 选中棋子类 = null;
                            for (let i = 0; i < 可放置棋子.length; i++) {
                                if (随机数 < 权重[i]) {
                                    选中棋子类 = 可放置棋子[i];
                                    break;
                                }
                                随机数 -= 权重[i];
                            }


                            if (选中棋子类) {
                                if (选中棋子类 === "下一层") {
                                    当前层级 = "B";
                                } else {
                                    棋盘[y][x] = new 选中棋子类({});
                                    break;
                                }
                            }
                        } else {

                            if (当前层级 === "A") {
                                当前层级 = "B";
                            } else {
                                break;
                            }
                        }
                    }
                }
            }
            const 棋子 = [];
            房间.棋子数量 = 0;
            for (let i = 0; i < 棋盘大小; i++) {
                for (let j = 0; j < 棋盘大小; j++) {
                    if (棋盘[j][i]) {
                        棋子.push(棋盘[j][i]);
                    }
                }
            }
            棋子.forEach(棋子 => {
                放置物品到房间(棋子, 房间);
                房间.棋子数量++;
            });
            return { 棋盘 };
        }

        function 可以放置(x, y, 棋子类, 棋盘) {
            if (棋盘[y][x]) return false;


            for (let i = 0; i < 棋盘.length; i++) {
                for (let j = 0; j < 棋盘[i].length; j++) {
                    const 已放置棋子 = 棋盘[j][i];
                    if (已放置棋子) {
                        const 攻击位置 = 已放置棋子.可攻击位置(i, j, 棋盘);
                        if (攻击位置.some(pos => pos.x === x && pos.y === y)) {
                            return false;
                        }
                    }
                }
            }


            const 临时棋盘 = 棋盘.map(row => row.map(cell => cell ? new (cell.constructor)() : null));
            临时棋盘[y][x] = new 棋子类();
            const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(x, y, 临时棋盘);
            for (let i = 0; i < 棋盘.length; i++) {
                for (let j = 0; j < 棋盘.length; j++) {
                    if (临时棋盘[j][i] && (i !== x || j !== y)) {
                        if (新棋子攻击位置.some(pos => pos.x === i && pos.y === j)) {
                            return false;
                        }
                    }
                }
            }


            for (let i = 0; i < 棋盘.length; i++) {
                for (let j = 0; j < 棋盘.length; j++) {
                    if (临时棋盘[j][i] instanceof 中国象棋炮) {
                        const 炮的攻击位置 = 临时棋盘[j][i].可攻击位置(i, j, 临时棋盘);
                        for (let m = 0; m < 棋盘.length; m++) {
                            for (let n = 0; n < 棋盘.length; n++) {
                                if (临时棋盘[n][m] && (m !== i || n !== j)) {
                                    if (炮的攻击位置.some(pos => pos.x === m && pos.y === n)) {
                                        return false;
                                    }

                                }
                            }
                        }
                    }
                }
            }
            return true;
        }


        function 计算新增威胁格子数(x, y, 棋子类, 棋盘) {
            const 临时棋盘 = 棋盘.map(row => row.map(cell => cell ? new (cell.constructor)() : null));
            临时棋盘[y][x] = new 棋子类();
            const 新棋子攻击位置 = 临时棋盘[y][x].可攻击位置(x, y, 临时棋盘);

            let 新增威胁数 = 0;

            for (let i = 0; i < 棋盘.length; i++) {
                for (let j = 0; j < 棋盘[i].length; j++) {
                    if (临时棋盘[j][i] === null) {
                        if (新棋子攻击位置.some(pos => pos.x === i && pos.y === j) ||
                            !可以放置(i, j, 棋子类, 临时棋盘)) {
                            新增威胁数++;
                        }
                    }
                }
            }
            return 新增威胁数;
        }
        function 激活卷轴模式() {
            if (!卷轴模式激活) {
                const 装备卷轴 = [...玩家装备.values()].filter(
                    (i) => i instanceof 卷轴类
                );
                if (装备卷轴.length === 0) return;

                卷轴模式激活 = true;
                const 提示遮罩 = document.createElement("div");
                提示遮罩.style.cssText = `
                                                                    position: fixed;
                                                                    top: 0;
                                                                    left: 0;
                                                                    width: 100%;
                                                                    height: 100%;
                                                                    background: rgba(0,0,0,0.5);
                                                                    z-index: 9999;
                                                                    display: flex;
                                                                    align-items: center;
                                                                    justify-content: center;
                                                                    font-size: 2em;
                                                                    color: gold;
                                                                    pointer-events: none;
                                                                `;
                提示遮罩.innerHTML = "点击闪烁的卷轴装备槽使用！";
                //document.body.appendChild(提示遮罩);
                //有点烦人，删去...
                setTimeout(() => 提示遮罩.remove(), 1000);
                // 添加闪烁效果
                document.querySelectorAll(".装备槽").forEach((槽位) => {
                    const 物品 = 槽位.querySelector(".物品条目");
                    if (物品?.__物品实例 instanceof 卷轴类) {
                        物品.classList.add("卷轴闪烁");
                    }
                });
            } else {
                恢复卷轴模式();
                document.querySelectorAll(".装备槽").forEach((槽位) => {
                    const 物品 = 槽位.querySelector(".物品条目");
                    if (物品?.__物品实例 instanceof 卷轴类) {
                        if (当前激活卷轴列表.has(物品?.__物品实例)) {
                            物品.classList.add("卷轴闪烁");
                        }
                    }
                });
            }
        }

        function 恢复卷轴模式() {
            卷轴模式激活 = false;


            document
                .querySelectorAll(".装备槽")
                .forEach((槽位) => {
                    const 物品 =
                        槽位.querySelector(".物品条目");
                    if (物品?.__物品实例 instanceof 卷轴类) {
                        if (!当前激活卷轴列表.has(物品?.__物品实例)) {
                            物品.classList.remove("卷轴闪烁");
                            物品?.__物品实例.卸下();
                        }
                    }
                });
        }
        function 显示通知(内容, 类型 = "信息", 强制显示 = false, 持续时间 = 1500) {
            添加日志(内容, 类型);
            if (!是否显示通知 && !强制显示) {
                return;
            }

            // 添加数量检查（立即执行移除）
            const 容器 = document.querySelector(".通知容器") || document.createElement("div");
            容器.className = "通知容器";

            // 移除旧通知逻辑
            const 当前通知列表 = 容器.querySelectorAll('.通知条目');
            if (当前通知列表.length >= 2) {
                // 找到最早的非持久通知
                const 可移除通知 = Array.from(当前通知列表).find(n =>
                    !n.classList.contains('持久')
                );
                if (可移除通知) 隐藏通知(可移除通知);
            }

            // 创建新通知（完整DOM操作）
            const 图标表 = {
                信息: "ℹ️",
                成功: 图标映射.成功,
                警告: "⚠️",
                错误: 图标映射.错误,
            };
            const 通知 = document.createElement("div");
            通知.className = `通知条目 ${类型} ${强制显示 ? '持久' : ''}`;
            通知.innerHTML = `
    <span class="通知图标">${图标表[类型]}</span>
    <span class="通知内容">${内容}</span>
    <button class="关闭按钮">×</button>
  `;

            // 事件处理
            通知.querySelector('.关闭按钮').addEventListener('click', () => {
                隐藏通知(通知);
                cancelAnimationFrame(通知._timer);
            });
            通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
            通知.addEventListener('mouseenter', () => clearTimeout(通知._timer));
            通知.addEventListener('mouseleave', () => {
                通知._timer = setTimeout(() => 隐藏通知(通知), 持续时间);
            });
            // 添加到容器
            if (!document.body.contains(容器)) document.body.appendChild(容器);
            容器.appendChild(通知);

            // 容器位置修正
            const 第一个通知 = 容器.firstElementChild;
            if (第一个通知) {
                const rect = 第一个通知.getBoundingClientRect();
                if (rect.bottom > window.innerHeight) {
                    容器.style.bottom = `${rect.height + 20}px`;
                }
            }
        }

        function 隐藏通知(通知元素) {
            if (!通知元素 || !通知元素.parentElement) return;

            通知元素.classList.add('离场');
            通知元素.addEventListener('animationend', () => {
                通知元素.remove();
                // 容器清理
                const 容器 = document.querySelector(".通知容器");
                if (容器 && 容器.children.length === 0) {
                    容器.remove();
                }
            });
        }

        function 添加日志(内容, 类型 = "信息") {
            const 时间戳 = new Date().toLocaleTimeString();
            const 条目 = document.createElement("div");
            条目.className = `日志条目 ${类型}`;
            条目.innerHTML = `<span class="日志时间">[${时间戳}]</span> ${内容}`;

            document.getElementById("logContent").appendChild(条目);
            // 自动滚动到底部
            条目.scrollIntoView({ behavior: "smooth" });
            日志历史.push({ 时间戳, 内容, 类型 });
        }
        function 收纳通知() {
            是否显示通知 = !是否显示通知;
            const 按钮 = document.querySelector("#设置菜单 button:nth-child(2)"); // 第二个按钮
            if (是否显示通知) {
                按钮.innerHTML = "收纳通知";
                显示通知("已重新显示通知", "信息");
                按钮.textContent = "收纳通知"; // 更新按钮文本
            } else {
                按钮.innerHTML = "显示通知";
                显示通知("已将通知收纳入日志中", "信息");
                按钮.textContent = "显示通知"; // 更新按钮文本
            }
        }
        function 关闭重铸界面() {
            const 弹窗 = document.querySelector(".重铸弹窗");
            if (!弹窗) return;

            // 添加关闭动画
            弹窗.style.transform = "translate(-50%, -50%) scale(0.9)";
            弹窗.style.opacity = 0;

            // 清理实例引用
            document.querySelectorAll(".重铸物品").forEach(el => {
                el.__物品实例 = null;
            });

            setTimeout(() => {
                弹窗.parentElement?.remove(); // 移除遮罩
                更新背包显示(); // 强制刷新
                玩家属性.允许移动 = true;
            }, 300);
        }

        function 执行重铸() {
            const 源元素 = document.querySelector("#sourceItems .selected");
            const 材料元素 = document.querySelector("#materialItems .selected");

            // 通过实例引用直接获取
            const 源物品 = 源元素?.__物品实例;
            const 材料物品 = 材料元素?.__物品实例;

            if (!源物品 || !材料物品) {
                显示通知("需要选择两个有效装备", "错误");
                return;
            }
            if (源物品 === 材料物品) {
                显示通知("需要选择两个不同装备", "错误");
                return;
            }
            if (源物品.名称 !== 材料物品.名称) {
                显示通知("装备名称不一致", "错误");
                return;
            }

            const 当前耐久 = 源物品.自定义数据.get("耐久");
            const 最大耐久 = 源物品.自定义数据.get("原耐久");
            const 可用空间 = 最大耐久 - 当前耐久;
            const 可转移量 = Math.min(材料物品.自定义数据.get("耐久"), 可用空间);

            if (可转移量 <= 0) {
                显示通知(可用空间 <= 0 ? "目标已满耐久" : "材料无可用耐久", "错误");
                return;
            }
            const 消耗金币 = 当前重铸台.计算消耗(源物品, 材料物品);
            if (!扣除金币(消耗金币)) {
                显示通知("金币不足！", "错误");
                return false;
            }

            // 执行转移
            源物品.自定义数据.set("耐久", 当前耐久 + 可转移量);
            处理销毁物品(材料物品.唯一标识, true);

            // 更新重铸台耐久
            const 剩余耐久 = 当前重铸台.自定义数据.get("耐久") - 1;
            当前重铸台.自定义数据.set("耐久", 剩余耐久);
            当前重铸台.效果描述 = `将同名装备的耐久融合\n剩余耐久：${剩余耐久}/${当前重铸台.自定义数据.get("最大耐久")}`;

            显示通知(`消耗 ${消耗金币} 金币成功修复！`, "成功");
            关闭重铸界面();
        }
        function 扣除金币(数量) {
            const 玩家金币 = [...玩家背包.values()]
                .filter(i => i instanceof 金币)
                .reduce((sum, i) => sum + i.堆叠数量, 0);

            if (玩家金币 < 数量) {
                return false;
            }
            const 金币列表 = [...玩家背包.values()].filter(i => i instanceof 金币);
            let 剩余扣除 = 数量;

            for (const 金币 of 金币列表) {
                const 扣除量 = Math.min(金币.堆叠数量, 剩余扣除);
                金币.堆叠数量 -= 扣除量;
                剩余扣除 -= 扣除量;
                if (金币.堆叠数量 === 0) {
                    处理销毁物品(金币.唯一标识, true);
                }
                if (剩余扣除 === 0) break;
            }

            return 剩余扣除 === 0;
        }
        // ====== 玩家扣血特效 ======
        function 触发扣血特效() {
            const 特效 = document.getElementById("扣血特效");
            特效.style.animation = "none";
            特效.offsetHeight; // 触发重绘
            特效.style.animation = "扣血脉冲 0.8s ease-out";
        }

        let 指示器缓存 = new Map();

        function 计算精确边缘位置(怪物) {
            const 画布 = document.getElementById("dungeonCanvas");
            const 画布Rect = 画布.getBoundingClientRect();

            // 获取实时视口参数
            const 视口左边界 = 当前相机X;
            const 视口右边界 =
                当前相机X + Math.floor(画布Rect.width / 单元格大小) - 1;
            const 视口上边界 = 当前相机Y;
            const 视口下边界 =
                当前相机Y + Math.floor(画布Rect.height / 单元格大小) - 1;

            // 判断怪物是否在视口内
            if (
                怪物.x >= 视口左边界 &&
                怪物.x <= 视口右边界 &&
                怪物.y >= 视口上边界 &&
                怪物.y <= 视口下边界
            ) {
                return null; // 在视野内不显示指示器
            }

            const 玩家像素X =
                (玩家.x - 当前相机X) * 单元格大小 + 单元格大小 / 2;
            const 玩家像素Y =
                (玩家.y - 当前相机Y) * 单元格大小 + 单元格大小 / 2;

            const dx =
                (怪物.x - 当前相机X) * 单元格大小 +
                单元格大小 / 2 -
                玩家像素X;
            const dy =
                (怪物.y - 当前相机Y) * 单元格大小 +
                单元格大小 / 2 -
                玩家像素Y;

            // 计算射线方向向量
            const 方向长度 = Math.sqrt(dx * dx + dy * dy);
            if (方向长度 === 0) return null;
            const dirX = dx / 方向长度;
            const dirY = dy / 方向长度;

            // 计算与画布边界的交点（使用视口实际尺寸）
            const 画布左 = 0;
            const 画布右 = 画布Rect.width;
            const 画布上 = 0;
            const 画布下 = 画布Rect.height;

            let t = Infinity;

            if (dirX < 0) {
                const tLeft = (画布左 - 玩家像素X) / dirX;
                const y = 玩家像素Y + dirY * tLeft;
                if (y >= 画布上 && y <= 画布下) t = tLeft;
            }

            if (dirX > 0) {
                const tRight = (画布右 - 玩家像素X) / dirX;
                const y = 玩家像素Y + dirY * tRight;
                if (y >= 画布上 && y <= 画布下) t = Math.min(t, tRight);
            }

            if (dirY < 0) {
                const tTop = (画布上 - 玩家像素Y) / dirY;
                const x = 玩家像素X + dirX * tTop;
                if (x >= 画布左 && x <= 画布右) t = Math.min(t, tTop);
            }

            if (dirY > 0) {
                const tBottom = (画布下 - 玩家像素Y) / dirY;
                const x = 玩家像素X + dirX * tBottom;
                if (x >= 画布左 && x <= 画布右) t = Math.min(t, tBottom);
            }

            if (t === Infinity) return null;

            // 计算最终交点位置（页面坐标）
            return {
                x: 玩家像素X + dirX * t + 画布Rect.left,
                y: 玩家像素Y + dirY * t + 画布Rect.top,
            };
        }

        function 更新物体指示器() {
            const 容器 = document.getElementById("怪物指示器容器");
            const 可见怪物 = new Set();

            所有怪物.forEach((怪物, index) => {
                if (怪物.状态 !== 怪物状态.活跃) return;
                if (!怪物.追击玩家中) return;

                // 计算精确位置，其内部会处理怪物不可见情况
                const 位置 = 计算精确边缘位置(怪物);
                if (!位置) {
                    if (指示器缓存.has(index))
                        指示器缓存.get(index).remove();
                    return;
                }

                // 创建/更新指示器
                let 指示器 = 指示器缓存.get(index);
                if (!指示器) {
                    指示器 = document.createElement("div");
                    指示器.className = "怪物指示器";
                    容器.appendChild(指示器);
                    指示器缓存.set(index, 指示器);
                }

                指示器.style.transform = `translate(${位置.x}px, ${位置.y}px)`;
                可见怪物.add(index);
            });

            // 清理不可见指示器
            指示器缓存.forEach((指示器, key) => {
                if (!可见怪物.has(key)) {
                    指示器.remove();
                    指示器缓存.delete(key);
                }
            });
            const 玩家寻宝戒指列表 = [...玩家装备.values()].filter(item => item instanceof 寻宝戒指);
            let 玩家寻宝戒指 = null;
            if (玩家寻宝戒指列表) {
                玩家寻宝戒指 = 玩家寻宝戒指列表.find(item => item.自定义数据.get("生效层数") === 当前层数);
            } else {
                const 指示器 = document.querySelector(".折跃门指示器");
                if (指示器) {
                    指示器.style.display = "none"; // 隐藏
                }
            }
            if (玩家寻宝戒指) {
                const 折跃门位置 = 玩家寻宝戒指.自定义数据.get("折跃门位置");
                if (折跃门位置) {
                    const 屏幕位置 = 计算精确边缘位置({ x: 折跃门位置.x, y: 折跃门位置.y });

                    let 指示器 = document.querySelector(".折跃门指示器");
                    if (!指示器) {
                        指示器 = document.createElement("div");
                        指示器.className = "怪物指示器 折跃门指示器"; // 添加额外的类名
                        指示器.style.background = 'gold';
                        指示器.style.boxShadow = "0 0 8px gold";
                        容器.appendChild(指示器);
                    }
                    if (屏幕位置) {
                        指示器.style.transform = `translate(${屏幕位置.x}px, ${屏幕位置.y}px)`;
                        指示器.style.display = "block"; // 确保显示
                    } else {
                        指示器.style.display = "none"; // 隐藏
                    }
                } else {
                    const 指示器 = document.querySelector(".折跃门指示器");
                    if (指示器) {
                        指示器.style.display = "none"; // 隐藏
                    }
                }
            } else {
                const 指示器 = document.querySelector(".折跃门指示器");
                if (指示器) {
                    指示器.style.display = "none"; // 隐藏
                }
            }
        }
        function hexToRgba(hex, alpha) {
            let r = parseInt(hex.slice(0, 2), 16),
                g = parseInt(hex.slice(2, 4), 16),
                b = parseInt(hex.slice(4, 6), 16);

            if (alpha) {
                return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
            } else {
                return "rgb(" + r + ", " + g + ", " + b + ")";
            }
        }
        // Hex转RGB
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                (num >> 16) & 0xff,
                (num >> 8) & 0xff,
                num & 0xff
            ];
        }
        function blendColors(hexArray) {
            if (hexArray.length === 0) return '#000000'; // 处理空数组情况



            // RGB转HSL
            function rgbToHsl(r, g, b) {
                r /= 255, g /= 255, b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h *= 60;
                }
                return [h, s, l];
            }

            // HSL转RGB
            function hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l; // 灰色
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h / 360 + 1 / 3);
                    g = hue2rgb(p, q, h / 360);
                    b = hue2rgb(p, q, h / 360 - 1 / 3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }

            // RGB转Hex
            function rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }

            // 处理每个Hex颜色
            const hslArray = hexArray.map(hex => {
                const [r, g, b] = hexToRgb(hex);
                return rgbToHsl(r, g, b);
            });

            // 计算平均H（向量平均）
            let sumSin = 0, sumCos = 0;
            for (const [h] of hslArray) {
                const radians = (h * Math.PI) / 180;
                sumSin += Math.sin(radians);
                sumCos += Math.cos(radians);
            }
            const avgH = (Math.atan2(sumSin / hexArray.length, sumCos / hexArray.length) * 180) / Math.PI;
            const normalizedH = (avgH + 360) % 360; // 确保在0-360度之间

            // 计算平均S和L
            const avgS = hslArray.reduce((sum, [, s]) => sum + s, 0) / hexArray.length;
            const avgL = hslArray.reduce((sum, [, , l]) => sum + l, 0) / hexArray.length;

            // 转换回RGB并转为Hex
            const [r, g, b] = hslToRgb(normalizedH, avgS, avgL);
            return rgbToHex(r, g, b);
        }


        function 打开交易窗口(npc) {
            if (npc.自定义数据.get("刷新次数") === 0) {
                显示通知("货物已告罄", "信息");
                return;
            }
            玩家属性.允许移动 = false;
            当前NPC = npc;
            const 窗口 = document.getElementById("交易窗口");
            窗口.querySelector("#交易次数").textContent = npc.自定义数据.get("刷新次数");
            窗口.querySelector("#当前金币").textContent = [...玩家背包.values()]
                .filter((i) => i instanceof 金币)
                .reduce((sum, i) => sum + i.堆叠数量, 0);

            const 库存容器 = 窗口.querySelector(".库存列表");
            库存容器.innerHTML = "";

            npc.自定义数据.get("库存").forEach(物品 => {
                const 元素 = document.createElement("div");
                元素.className = "交易物品条目";
                元素.innerHTML = `
            <div class="物品头">
                <span style="color:${物品.颜色表[物品.颜色索引]}; font-family: color-emoji">${物品.图标}</span>
                ${物品.获取名称()}
                <span class="物品价格">${npc.获取价格(物品)} 金币</span>
            </div>
            <div class="物品描述">${物品.效果描述 || "神秘物品"}</div>
        `;

                元素.addEventListener("click", () => 尝试购买(物品));
                库存容器.appendChild(元素);
            });

            窗口.style.display = "block";
            document.body.appendChild(窗口);
        }

        function 尝试购买(物品) {
            const npc = 当前NPC;
            const 价格 = npc.获取价格(物品);
            const 金币列表 = [...玩家背包.values()].filter((i) => i instanceof 金币);
            const 总金币 = 金币列表.reduce((sum, i) => sum + i.堆叠数量, 0);

            if (总金币 < 价格) {
                显示通知("金币不足！", "错误");
                return;
            }
            // 添加物品
            if (物品.类型 === "NPC" && !彩蛋2触发) {
                显示通知("就是你小子在酒吧里点了一个酒吧!?", "信息", true);
                彩蛋2触发 = true;
            }
            const 新物品 = 克隆物品(物品);
            if (!尝试收集物品(新物品, true)) { //注意：如果购买物品数量多，则会出现部分成功收集并返回false的情况
                return;
            }

            if (!扣除金币(价格)) {
                显示通知("金币不足！", "错误");
                return;
            }

            // 更新NPC状态
            npc.自定义数据.set("刷新次数", npc.自定义数据.get("刷新次数") - 1);
            if (npc.自定义数据.get("刷新次数") === 0) {
                关闭交易窗口();
            } else {
                打开交易窗口(npc);
            }

            更新背包显示();
            显示通知(`购买 ${物品.名称} 成功！`, "成功");
        }

        function 关闭交易窗口() {
            document.getElementById("交易窗口").style.display = "none";
            当前NPC = null;
            NPC互动中 = false;
            玩家属性.允许移动 = true;
        }

        function 进入教程层() {
            是否为教程层 = true;
            教程阶段 = 0;
            教程提示已显示 = false;
            document.getElementById("跳过教程按钮").style.display = "block";
            生成教程地牢();
            显示教程提示();
            // 确保其他 UI 元素正确显示或隐藏
            更新物体指示器();
            所有怪物.forEach((m) => { m.绘制血条(); });
            绘制();
        }

        function 跳过教程() {
            是否为教程层 = false;
            document.getElementById("跳过教程按钮").style.display = "none";
            所有怪物.forEach((m) => {
                m.绘制血条(true);
                地牢[m.y][m.x].关联怪物 = null;
            }); // 隐藏教程层怪物血条
            所有怪物 = [];
            重置玩家状态();
            切换楼层(0); // 切换到正常地牢的第 0 层
        }

        function 重置玩家状态() {
            玩家背包.clear();
            玩家装备.clear();
            玩家状态.forEach((m) => {
                m.移除状态();
            });
            玩家状态 = [];
            // 重置 HUD
            document.querySelector(".health-bar").style.width = "100%";
            document.querySelector(".power-bar").style.width = "100%";
            document.getElementById("卷轴按钮").style.display = [
                ...玩家装备.values(),
            ].some((item) => item.类型 === "卷轴")
                ? "flex"
                : "none";
            更新装备显示();
            更新背包显示();
        }

        function 生成教程地牢() {
            地牢 = Array(地牢大小).fill().map((_, y) => Array(地牢大小).fill().map((_, x) => new 单元格(x, y)));
            房间列表 = [];
            上锁房间列表 = [];
            所有怪物 = [];
            门实例列表 = new Map();
            房间地图 = Array(地牢大小).fill().map(() => Array(地牢大小).fill(-1));
            已访问房间 = new Set();

            const 教程房间配置 = [
                { x: 10, y: 10, w: 7, h: 5, id: 0, 门: [] },  // 初始房间：移动教学
                { x: 20, y: 10, w: 7, h: 5, id: 1, 门: [] },  // 背包、装备教学：钢制长剑
                { x: 30, y: 10, w: 7, h: 5, id: 2, 门: [] },  // 战斗、HUD、互动教学：普通怪物
                { x: 40, y: 10, w: 7, h: 5, id: 3, 门: [] },  // 上锁房间、药水、强化：上锁的门，房间内有狂暴药水
                { x: 50, y: 10, w: 7, h: 5, id: 4, 门: [] },  // 卷轴、冰冻怪物：冰冻怪物，清净卷轴（未鉴定）
                { x: 60, y: 10, w: 7, h: 5, id: 5, 门: [] }, // 新物品：商人、祭坛、宠物
                { x: 70, y: 10, w: 7, h: 5, id: 6, 门: [] },  // 下楼
            ];

            for (const 房间配置 of 教程房间配置) {
                房间列表.push(房间配置);
                放置房间(房间配置);
            }


            for (let i = 0; i < 房间列表.length - 1; i++) {
                let 路径 = 连接房间(房间列表[i], 房间列表[i + 1]);
                if (路径) {
                    生成走廊(路径);
                }
            }
            生成墙壁();


            const 颜色索引 = 3 % 颜色表.length;
            房间列表[3].门.forEach((门) => {
                const 单元格 = 地牢[门.y][门.x];
                门实例列表.get(单元格.标识).类型 = "上锁的门";
                if (单元格.类型 === 单元格类型.门) {
                    单元格.类型 = 单元格类型.上锁的门;
                    单元格.钥匙ID = 房间列表[3].id;
                    单元格.颜色索引 = 颜色索引;
                }
            });
            上锁房间列表.push({ ...房间列表[3], 颜色索引 });


            const 第一个房间 = 房间列表[0];
            玩家初始位置.x = 第一个房间.x + Math.floor(第一个房间.w / 2);
            玩家初始位置.y = 第一个房间.y + Math.floor(第一个房间.h / 2);
            玩家.x = 玩家初始位置.x;
            玩家.y = 玩家初始位置.y;
            已访问房间.add(第一个房间.id);


            放置物品到房间(new 钢制长剑({ 不可破坏: true }), 房间列表[1]);
            放置怪物到单元格(new 怪物({ 掉落概率: 1, 基础攻击力: 1, 基础生命值: 15, 掉落物: new 钥匙({ 门ID: 上锁房间列表[0].id, 颜色索引: 上锁房间列表[0].颜色索引, 地牢层数: -1, }) }), 房间列表[2].x + 3, 房间列表[2].y + 2);

            放置怪物到单元格(new 怪物({ 基础攻击力: 1, 基础生命值: 15, 强化: true }), 房间列表[3].x + 3, 房间列表[3].y + 2);
            放置物品到房间(new 清净卷轴({ 已解锁: false, 强化: true }), 房间列表[3]);
            放置物品到房间(new 狂暴药水({ 强化: true }), 房间列表[3]);


            放置怪物到单元格(new 冰冻怪物({ 基础攻击力: 3, 基础生命值: 45, 掉落物: new 冰盾({}), 掉落概率: 1 }), 房间列表[4].x + 2, 房间列表[4].y + 2);
            放置物品到房间(new 神秘商人({}), 房间列表[5]);
            放置物品到房间(new 物品祭坛({}), 房间列表[5]);
            放置物品到房间(new 宠物({}), 房间列表[5]);
            //生成解谜棋盘(房间列表[1]);
            //房间列表[1].类型 = "解谜棋盘"
            放置楼梯(房间列表[Math.ceil(Math.random()*(房间列表.length - 1))], 楼梯图标.下楼, 单元格类型.楼梯下楼);
            房间列表.forEach((房间) => 更新房间墙壁(房间));
            更新视口();
            绘制();
        }

        function 显示教程提示(强制 = false) {
            if (教程提示已显示 && !强制) return;

            const 提示窗口 = document.getElementById("教程提示窗口");
            const 提示内容元素 = document.getElementById("教程提示内容");
            let 提示文本 = "";

            switch (教程阶段) {
                case 0:
                    提示文本 = `欢迎来到中文地牢！<br>
                <b>基础移动：</b><br>
                - 电脑玩家：使用 W (上)、A (左)、S (下)、D (右) 键 或 ↑↓←→ 方向键移动。<br>
                - 手机玩家：长按方向键可以连续移动。<br>
                - 直接点击地图上的目标位置，角色会自动寻路。<br>
                <br>
                <b>注意：</b>长按移动会忽略攻击和互动，适合快速探索。<br><b>兼容模式:</b>如果 emoji 无法显示，可以按 - 键切换成汉字模式`;
                    break;
                case 1:
                    提示文本 = `<b>背包与装备：</b><br>
                - 打开背包：<br>
                    - 电脑玩家：按 E 键。<br>
                    - 手机玩家：点击屏幕下方的背包图标 ${图标映射.背包按钮}。<br>
                - 背包功能：<br>
                    - 点击物品：使用、销毁或装备物品。<br>
                    - 装备武器：点击武器，再点击“装备”按钮（${图标映射.装备按钮}）。<br>
                    
                - 装备栏 (屏幕右下角的“田”字格)：<br>
                    - 电脑: 使用数字键 1-4 使用对应槽位物品，右键卸下。<br>
                    - 手机: 单击装备槽内物品以使用，长按卸下<br>
                请尝试打开背包，装备上你找到的钢制长剑。`;
                    break;
                case 2: // 进入房间时的提示
                    提示文本 = `<b>战斗与HUD：</b><br>
                - HUD（屏幕左上角）：<br>
                    - 显示/隐藏：按 Q 键或点击眼睛图标 ${图标映射.HUD智能} 按钮。<br>
                    - ❤️ 生命条：显示你的生命值。<br>
                    - ⚡ 能量条：显示你的能量值（使用卷轴等特殊物品会消耗）。<br>
                - 武器有冷却时间与耐久，耐久即将耗尽时可以停止使用，后续等待机会修补<br>
                <b>战斗：</b><br>
                - 靠近怪物，使用已装备的武器攻击它（按对应数字键或点击装备栏中武器）。<br>
                - 击败怪物可获得战利品。<br>`;
                    break;

                case 2.5: // 击败怪物后的提示
                    提示文本 = `<b>互动：</b><br>
                - 电脑玩家：按 F 键。<br>
                - 手机玩家：点击屏幕下方的互动按钮 ${图标映射.互动按钮}。<br>
                - 互动功能：<br>
                    - 拾取周围的物品（直接走到物品的格子上也可以拾取）。<br>
                    - 打开上锁的门（需要拥有对应颜色的钥匙）。<br>
                    - 与 NPC、祭坛等互动。<br>
                    - 自动选择武器并攻击范围内的敌人。<br>
                 <b>提示：</b>掉落的钥匙有光晕，门的颜色和钥匙发出的光晕的颜色要一致才能解锁。<br>
                 请使用互动键拾取钥匙,并尝试打开下一道门.`;
                    break;
                case 3:
                    提示文本 = `你成功打开了上锁的房间！<br>
                <b>强化物品：</b><br>
                - 上锁房间内通常有更高品质的物品，它们带有强化效果，属性更强。<br>
                - 注意：怪物也会被强化！<br>
                <br>
                <b>药水：</b><br>
                - 药水有持续时间，效果会在一定回合后消失。<br>
                - 在关键时候打开背包使用药水,它可以救你一命！`;
                    break;
                case 4:
                    提示文本 = `<b>卷轴与能量：</b><br>
                - 卷轴是强大的消耗品，但使用需要消耗能量，能量条在左上角的HUD中显示，并随玩家移动恢复。<br>
                - 卷轴使用方法：<br>
                    1. 装备：打开背包(E/${图标映射.背包按钮})，点击卷轴，再点击“装备”按钮(${图标映射.装备按钮})。<br>
                    2. 激活：<br>
                        - 电脑玩家：按 R 键。<br>
                        - 手机玩家：点击屏幕下方的卷轴图标 ${图标映射.卷轴按钮} 按钮,再点击装备栏中高亮的卷轴。<br>
                - 你获得的清净卷轴可以移除身上的所有状态效果。<br>
                - 卷轴需要使用特殊卷轴解读后才能知道效果。<br>
                - 激活后再点击装备槽中高亮的卷轴可以取消激活`;
                    break;

                case 5:
                    提示文本 = `<b>探索更多：</b><br>
               这个房间里有一些特殊的物品，为你展示地牢物品的多样。<br>
                如果背包已满，你可以尝试销毁一些物品或将它们装备给宠物。<br>
                如果装备槽已满，长按或右键已装备物品可以将其卸下<br>
                遇到未知物品尝试与其互动 或 拾起后在背包中使用。`;
                    break;
                case 6:
                    提示文本 = `<b>开始游戏：</b><br>
                按 G 键可以打开日志界面。<br>
                - 地牢有很多层，每层都有不同的怪物和宝藏。<br>
                - 找到并走下楼梯 ${图标映射.下楼楼梯} 即可进入下一层，开始你的冒险！`;
                    break;
                default:
                    提示窗口.style.display = "none";
                    return;
            }

            提示内容元素.innerHTML = 提示文本;
            提示窗口.style.display = "block";
            玩家属性.允许移动 = false;
            教程提示已显示 = true;
        }
        function 关闭教程提示() {
            const 提示窗口 = document.getElementById("教程提示窗口");
            if (提示窗口) {
                提示窗口.classList.add("关闭中");
                教程提示已显示 = false;
                setTimeout(() => {
                    提示窗口.style.display = "none";
                    提示窗口.classList.remove("关闭中");
                }, 300);
                玩家属性.允许移动 = true;
            }
        }

        const 安全参数 = {
            方程组: [{
                a: 7,
                b: 3,
                c: 2,
                d: 5
            },
            {
                a: 4,
                b: 9,
                c: 6,
                d: 8
            }
            ],
            模数: 9973
        }

        function 生成死亡凭证(L) {
            let R;
            do {
                // R ≡ (L^2 + 1) mod 13
                const 基础值 = (L * L + 1) % 13;
                R = 基础值 + Math.floor(Math.random() * (安全参数.模数 - 基础值)) * 13;
            } while (R >= 安全参数.模数 || R === 0);


            const 方程计算 = (系数, L, R) => {
                const 项1 = 系数.a * L;
                const 项2 = 系数.b * R * R;
                const 项3 = 系数.c * L * R;
                const 项4 = 系数.d * R * R * R;
                return (项1 + 项2 + 项3 + 项4) % 安全参数.模数;
            };

            const C1 = 方程计算(安全参数.方程组[0], L, R);
            const C2 = 方程计算(安全参数.方程组[1], L, R);


            const 组件 = [
                L.toString().padStart(3, '0'),
                R.toString().padStart(4, '0'),
                (C1 + C2).toString().padStart(3, '0')
            ];

            return 组件.join('-');
        }

        function 验证死亡凭证(凭证, 待验层数) {
            const [L部分, R部分, C部分] = 凭证.split('-');
            const L = parseInt(L部分);
            const R = parseInt(R部分);
            const 总校验码 = parseInt(C部分);

            if (L !== 待验层数 || R <= 0 || R >= 安全参数.模数) return false;

            // R ≡ (L² +1) mod 13 
            if ((R % 13) !== ((L * L + 1) % 13)) return false;


            const 方程计算 = (系数, L, R) => {
                const 计算值 = 系数.a * L + 系数.b * R * R + 系数.c * L * R + 系数.d * R * R * R;
                return 计算值 % 安全参数.模数;
            };

            const 真实C1 = 方程计算(安全参数.方程组[0], L, R);
            const 真实C2 = 方程计算(安全参数.方程组[1], L, R);

            return (真实C1 + 真实C2) === 总校验码;
        }

        function CopyTextToClipboard(val) {
            const textArea = document.createElement('textArea')
            textArea.value = val
            textArea.style.width = 0
            textArea.style.position = 'fixed'
            textArea.style.left = '-999px'
            textArea.style.top = '10px'
            textArea.setAttribute('readonly', 'readonly')
            document.body.appendChild(textArea)

            textArea.select()
            document.execCommand('copy')
            document.body.removeChild(textArea)
        }
        function 获取附魔描述(enchantments) {

            const numberToRoman = (num) => {
                const romanMap = {
                    1: 'I',
                    2: 'II',
                    3: 'III',
                    4: 'IV',
                    5: 'V',
                    6: 'VI',
                    7: 'VII',
                    8: 'VIII',
                    9: 'IX',
                    10: 'X'
                };
                return romanMap[num] || '';
            };

            return enchantments
                .map(enchant => {
                    const romanLevel = numberToRoman(enchant.等级);
                    return `[${enchant.种类}] ${romanLevel}级`;
                })
                .join('\n');
        }

        function 切换设置菜单() {
            const 菜单 = document.getElementById("设置菜单");
            if (菜单.classList.contains("显示")) {
                菜单.classList.remove("显示");
                菜单.classList.add("隐藏"); // 添加隐藏类以触发动画
                setTimeout(() => {
                    菜单.classList.remove("隐藏");
                }, 300)
            } else {
                菜单.classList.remove("隐藏");
                菜单.classList.add("显示");
            }
        }


        function 关闭设置菜单() {
            const 菜单 = document.getElementById("设置菜单");
            菜单.classList.remove("显示");
            菜单.classList.add("隐藏"); // 添加隐藏类以触发动画
            setTimeout(() => {
                菜单.classList.remove("隐藏");
            }, 300)
        }

        function 切换显示模式() {
            const 装备栏 = document.querySelector(".装备栏");
            const 小地图容器 = document.getElementById("小地图容器");
            const 按钮 = document.getElementById("切换显示按钮");

            if (显示模式 === "装备") {
                装备栏.classList.add("隐藏");
                小地图容器.classList.remove("隐藏");
                显示模式 = "小地图";
                按钮.textContent = "装备栏";
            } else {
                装备栏.classList.remove("隐藏");
                小地图容器.classList.add("隐藏");
                显示模式 = "装备";
                按钮.textContent = "地图";
            }
        }
        function 更新视口() {
            if (相机锁定) return;

            let 原始目标X = 玩家.x - 7
            let 原始目标Y = 玩家.y - 7

            原始目标X = Math.max(0, Math.min(原始目标X, 地牢大小 - 15));
            原始目标Y = Math.max(0, Math.min(原始目标Y, 地牢大小 - 15));

            // 缓动更新目标
            if (相机目标X !== 原始目标X || 相机目标Y !== 原始目标Y) {
                相机锁定 = true;
                相机目标X = 原始目标X;
                相机目标Y = 原始目标Y;

            }
        }
        function 动画帧() {
            // 插值
            const dx = 相机目标X - 当前相机X;
            const dy = 相机目标Y - 当前相机Y;

            当前相机X += dx * 相机移动速度;
            当前相机Y += dy * 相机移动速度;

            // 检测移动完成
            if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1 && 相机锁定) {
                当前相机X = 相机目标X;
                当前相机Y = 相机目标Y;

                更新物体指示器();
                所有怪物.forEach((m) => {
                    m.绘制血条();
                });

                let maxPauseTime = 0; // 最大停顿时间

                // 处理攻击路径显示
                if (待显示格子特效队列.length > 0) {
                    // 玩家属性.允许移动 = false; // 移动到循环外面
                    for (let i = 待显示格子特效队列.length - 1; i >= 0; i--) {
                        const 路径数据 = 待显示格子特效队列[i];
                        显示格子特效(路径数据.路径, 路径数据.颜色);

                        // 计算当前路径的停顿时间
                        const 路径停顿时间 = 100 + 路径数据.路径.length * 100;
                        maxPauseTime = Math.max(maxPauseTime, 路径停顿时间);
                    }
                    待显示格子特效队列 = [];
                }

                // 处理爆炸范围显示
                if (待显示爆炸范围.爆炸范围.length > 0) {
                    // 玩家属性.允许移动 = false; // 移动到循环外面
                    const 画布Rect = canvas.getBoundingClientRect();
                    待显示爆炸范围.爆炸范围.forEach(({ x, y, 距离 }) => {
                        const 屏幕X = (x - 当前相机X) * 单元格大小;
                        const 屏幕Y = (y - 当前相机Y) * 单元格大小;

                        const 特效 = document.createElement("div");
                        特效.style.cssText = `
                    position: absolute;
                    left: ${屏幕X + 画布Rect.left}px;
                    top: ${屏幕Y + 画布Rect.top}px;
                    width: ${单元格大小}px;
                    height: ${单元格大小}px;
                    background: ${获取爆炸颜色(距离)};
                    opacity: 0.7;
                    animation: 爆炸闪烁 ${0.4 + (距离 / 待显示爆炸范围.范围) * 0.1}s;
                    pointer-events: none;
                    z-index: 999;
                `;
                        document.body.appendChild(特效);

                        setTimeout(() => 特效.remove(), 500);
                    });

                    // 计算爆炸的停顿时间
                    const 爆炸停顿时间 = 500; // 爆炸动画时间
                    maxPauseTime = Math.max(maxPauseTime, 爆炸停顿时间);

                    待显示爆炸范围 = { 爆炸范围: [], 爆炸距离: null };
                }

                // 统一设置禁止移动和恢复移动
                if (maxPauseTime > 0) {
                    玩家属性.允许移动 = false;
                    setTimeout(() => {
                        玩家属性.允许移动 = true;
                        更新视口(); // 确保在恢复移动后更新视口
                    }, maxPauseTime);
                }

                相机锁定 = false;
            }

            // 更新整数视口
            视口偏移X = Math.floor(当前相机X);
            视口偏移Y = Math.floor(当前相机Y);

            绘制();
            requestAnimationFrame(动画帧);
        }
        function 获取爆炸颜色(距离) {
            const 渐变 = [
                "radial-gradient(circle, #ff0000 0%, #ff4500 70%, transparent 100%)",
                "radial-gradient(circle, #ff4500 0%, #ff8c00 70%, transparent 100%)",
                "radial-gradient(circle, #ff8c00 0%, #ffd700 70%, transparent 100%)",
            ];
            return 渐变[Math.min(距离, 2)];
        }
        function 绘制() {

            const 缓冲区域 = 2;
            const 起始X = Math.max(0, Math.floor(当前相机X - 缓冲区域));
            const 结束X = Math.min(地牢大小, 起始X + 相机显示边长 + 缓冲区域 * 2);
            const 起始Y = Math.max(0, Math.floor(当前相机Y - 缓冲区域));
            const 结束Y = Math.min(地牢大小, 起始Y + 相机显示边长 + 缓冲区域 * 2);
            ctx.clearRect(0, 0, 画布宽度, 画布高度);

            const 小数偏移X = (当前相机X % 1) * 单元格大小;
            const 小数偏移Y = (当前相机Y % 1) * 单元格大小;

            for (let y = 起始Y; y < 结束Y; y++) {
                for (let x = 起始X; x < 结束X; x++) {
                    if (地牢.length > 0) {
                        地牢[y][x]?.绘制();
                    }
                }
            }

            const 玩家屏幕X = (玩家.x - 当前相机X + 0.5) * 单元格大小;
            const 玩家屏幕Y = (玩家.y - 当前相机Y + 0.5) * 单元格大小;
            if (moveQueue.length > 0) {
                drawPath(moveQueue);
            }
            const hexArray_ = [];
            if (玩家状态.length > 0) {
                玩家状态.forEach((item) => {
                    hexArray_.push(item.颜色);
                });
                ctx.fillStyle = blendColors(hexArray_);
            } else {
                ctx.fillStyle = "#ff4444";
            }
            ctx.beginPath();
            ctx.arc(
                玩家屏幕X,
                玩家屏幕Y,
                单元格大小 / 3,
                0,
                Math.PI * 2
            );

            ctx.fill();
            ctx.stroke();
            绘制小地图();
        }
        function 绘制小地图() {
            const 缩放比例 = 3;
            小地图Ctx.fillStyle = "#1a1a1a";
            小地图Ctx.fillRect(0, 0, 小地图.width, 小地图.height);
            if (地牢.length > 0) {
                // 绘制走廊
                for (let y = 0; y < 地牢大小; y++) {
                    for (let x = 0; x < 地牢大小; x++) {
                        if (地牢[y][x]?.类型 === 单元格类型.走廊) {
                            小地图Ctx.strokeStyle = "#666666";

                            小地图Ctx.strokeRect(x * 缩放比例, y * 缩放比例, 缩放比例, 缩放比例);
                        }
                    }
                }
            }

            // 绘制房间
            房间列表.forEach(房间 => {
                const 已访问 = 已访问房间.has(房间.id);
                const 是上锁房间 = 上锁房间列表.some(r => r.id === 房间.id);

                // 设置房间颜色
                if (是上锁房间) {
                    const 颜色索引 = 上锁房间列表.find(r => r.id === 房间.id).颜色索引;
                    小地图Ctx.strokeStyle = 颜色表[颜色索引] || "#FFD700";
                } else {
                    小地图Ctx.strokeStyle = 已访问 ? "#4caf50" : "#666666";
                }

                小地图Ctx.strokeRect(
                    房间.x * 缩放比例,
                    房间.y * 缩放比例,
                    房间.w * 缩放比例,
                    房间.h * 缩放比例
                );

                if (已访问) {
                    小地图Ctx.fillStyle = "#4caf5022";
                    小地图Ctx.fillRect(
                        房间.x * 缩放比例,
                        房间.y * 缩放比例,
                        房间.w * 缩放比例,
                        房间.h * 缩放比例
                    );
                }
            });

            // 玩家位置
            小地图Ctx.fillStyle = "#ff0000";
            小地图Ctx.beginPath();
            小地图Ctx.arc(
                玩家.x * 缩放比例,
                玩家.y * 缩放比例,
                Math.max(3, 缩放比例 / 2),
                0,
                Math.PI * 2
            );
            小地图Ctx.fill();
            小地图Ctx.strokeStyle = "#ffffff";
            小地图Ctx.lineWidth = 2;
            小地图Ctx.stroke();

            // 修正视野框位置（以玩家为中心）
            const 视野半径 = Math.floor(相机显示边长 / 2);
            const 视野框X = (玩家.x - 视野半径) * 缩放比例;
            const 视野框Y = (玩家.y - 视野半径) * 缩放比例;
            const 视野框尺寸 = 相机显示边长 * 缩放比例;

            小地图Ctx.strokeStyle = "#ffd700";
            小地图Ctx.lineWidth = 1;
            小地图Ctx.strokeRect(视野框X, 视野框Y, 视野框尺寸, 视野框尺寸);
        }
        async function startAutoMove() {
            if (moveQueue.length === 0) return;
            const moveInterval = setInterval(() => {
                if (moveQueue.length === 0) {
                    clearInterval(moveInterval);
                    return;
                }
                if (玩家属性.允许移动) {
                    let targetIndex = Math.min(玩家属性.移动步数 - 1, moveQueue.length - 1);
                    let validMove = true;
                    // 检查直线可行性
                    for (let i = 0; i <= targetIndex; i++) {
                        if (!检查直线移动可行性(玩家.x, 玩家.y, moveQueue[i].x, moveQueue[i].y)) {
                            targetIndex = i - 1;
                            validMove = false;
                            break;
                        }
                    }
                    if (targetIndex >= 0 && validMove) {
                        const target = moveQueue[targetIndex];
                        移动玩家(target.x - 玩家.x, target.y - 玩家.y, false);
                        moveQueue = moveQueue.slice(targetIndex + 1);
                    } else {
                        // 无法多格移动时单格移动
                        const target = moveQueue.shift();
                        移动玩家(target.x - 玩家.x, target.y - 玩家.y, false);
                    }
                }
            }, 移动间隔); // 间隔时间
        }

        function 检查直线移动可行性(fromX, fromY, toX, toY) {
            const dx = toX - fromX;
            const dy = toY - fromY;

            if (dx !== 0 && dy !== 0) return false; // 禁止斜向移动

            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            const dirX = dx > 0 ? 1 : dx < 0 ? -1 : 0;
            const dirY = dy > 0 ? 1 : dy < 0 ? -1 : 0;

            for (let i = 1; i <= steps; i++) {
                const x = fromX + dirX * i;
                const y = fromY + dirY * i;

                if (x < 0 || x >= 地牢大小 || y < 0 || y >= 地牢大小) return false;
                if (!检查移动可行性(x - dirX, y - dirY, x, y)) return false;
            }

            return true;
        }
        // 设置画布尺寸
        初始化canvas();
        初始化装备系统();
        if (window.innerWidth < 769) {
            document.getElementById("小地图容器").classList.add("隐藏");
        }
        当前层数 = null;
        进入教程层();
        //切换楼层(0);
        更新背包显示();
        更新界面状态();
        动画帧(); // 启动动画循环
    </script>
</body>

</html>
